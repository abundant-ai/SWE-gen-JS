diff --git a/index.js b/index.js
index 8ec320ee..febd1804 100644
--- a/index.js
+++ b/index.js
@@ -124,9 +124,12 @@ module.exports = {
   mean: require('./src/mean'),
   median: require('./src/median'),
   memoize: require('./src/memoize'),
-  memoizeWith: require('./src/memoizeWith'),
   merge: require('./src/merge'),
   mergeAll: require('./src/mergeAll'),
+  mergeDeepLeft: require('./src/mergeDeepLeft'),
+  mergeDeepRight: require('./src/mergeDeepRight'),
+  mergeDeepWith: require('./src/mergeDeepWith'),
+  mergeDeepWithKey: require('./src/mergeDeepWithKey'),
   mergeWith: require('./src/mergeWith'),
   mergeWithKey: require('./src/mergeWithKey'),
   min: require('./src/min'),
@@ -139,6 +142,7 @@ module.exports = {
   not: require('./src/not'),
   nth: require('./src/nth'),
   nthArg: require('./src/nthArg'),
+  o: require('./src/o'),
   objOf: require('./src/objOf'),
   of: require('./src/of'),
   omit: require('./src/omit'),
diff --git a/src/memoize.js b/src/memoize.js
index 420541af..34c33129 100644
--- a/src/memoize.js
+++ b/src/memoize.js
@@ -1,4 +1,6 @@
-var memoizeWith = require('./memoizeWith');
+var _arity = require('./internal/_arity');
+var _curry1 = require('./internal/_curry1');
+var _has = require('./internal/_has');
 var toString = require('./toString');
 
 
@@ -18,8 +20,8 @@ var toString = require('./toString');
  * @return {Function} Memoized version of `fn`.
  * @example
  *
- *      let count = 0;
- *      const factorial = R.memoize(n => {
+ *      var count = 0;
+ *      var factorial = R.memoize(n => {
  *        count += 1;
  *        return R.product(R.range(1, n + 1));
  *      });
@@ -28,4 +30,13 @@ var toString = require('./toString');
  *      factorial(5); //=> 120
  *      count; //=> 1
  */
-module.exports = memoizeWith(toString);
+module.exports = _curry1(function memoize(fn) {
+  var cache = {};
+  return _arity(fn.length, function() {
+    var key = toString(arguments);
+    if (!_has(key, cache)) {
+      cache[key] = fn.apply(this, arguments);
+    }
+    return cache[key];
+  });
+});
diff --git a/src/memoizeWith.js b/src/memoizeWith.js
deleted file mode 100644
index 37b942b2..00000000
--- a/src/memoizeWith.js
+++ /dev/null
@@ -1,43 +0,0 @@
-var _arity = require('./internal/_arity');
-var _curry2 = require('./internal/_curry2');
-var _has = require('./internal/_has');
-
-
-/**
- * A customisable version of R.memoize. memoizeWith takes an additional
- * function that will be applied to a given argument set and used to create
- * the cache key under which the results of the function to be memoized will
- * be stored. Care must be taken when implementing key generation to avoid
- * clashes that may overwrite previous entries erroneously.
- *
- *
- * @func
- * @memberOf R
- * @category Function
- * @sig (*... -> String) -> (*... -> a) -> (*... -> a)
- * @param {Function} fn The function to generate the cache key.
- * @param {Function} fn The function to memoize.
- * @return {Function} Memoized version of `fn`.
- * @see R.memoize
- * @example
- *
- *      let count = 0;
- *      const factorial = R.memoizeWith(R.identity, n => {
- *        count += 1;
- *        return R.product(R.range(1, n + 1));
- *      });
- *      factorial(5); //=> 120
- *      factorial(5); //=> 120
- *      factorial(5); //=> 120
- *      count; //=> 1
- */
-module.exports = _curry2(function memoizeWith(mFn, fn) {
-  var cache = {};
-  return _arity(fn.length, function() {
-    var key = mFn.apply(this, arguments);
-    if (!_has(key, cache)) {
-      cache[key] = fn.apply(this, arguments);
-    }
-    return cache[key];
-  });
-});
diff --git a/src/merge.js b/src/merge.js
index 37707660..b4396730 100644
--- a/src/merge.js
+++ b/src/merge.js
@@ -15,7 +15,7 @@ var _curry2 = require('./internal/_curry2');
  * @param {Object} l
  * @param {Object} r
  * @return {Object}
- * @see R.mergeWith, R.mergeWithKey
+ * @see R.mergeDeepRight, R.mergeWith, R.mergeWithKey
  * @example
  *
  *      R.merge({ 'name': 'fred', 'age': 10 }, { 'age': 40 });
diff --git a/src/mergeDeepLeft.js b/src/mergeDeepLeft.js
new file mode 100644
index 00000000..3f16660d
--- /dev/null
+++ b/src/mergeDeepLeft.js
@@ -0,0 +1,29 @@
+var _curry2 = require('./internal/_curry2');
+var mergeDeepWithKey = require('./mergeDeepWithKey');
+
+
+/**
+ * Creates a new object with the own properties of the first object merged with
+ * the own properties of the second object. If a key exists in both objects:
+ * - and both values are objects, the two values will be recursively merged
+ * - otherwise the value from the first object will be used.
+ *
+ * @func
+ * @memberOf R
+ * @category Object
+ * @sig {a} -> {a} -> {a}
+ * @param {Object} lObj
+ * @param {Object} rObj
+ * @return {Object}
+ * @see R.merge, R.mergeDeepRight, R.mergeDeepWith, R.mergeDeepWithKey
+ * @example
+ *
+ *      R.mergeDeepLeft({ name: 'fred', age: 10, contact: { email: 'moo@example.com' }},
+ *                      { age: 40, contact: { email: 'baa@example.com' }});
+ *      //=> { name: 'fred', age: 10, contact: { email: 'moo@example.com' }}
+ */
+module.exports = _curry2(function mergeDeepLeft(lObj, rObj) {
+  return mergeDeepWithKey(function(k, lVal, rVal) {
+    return lVal;
+  }, lObj, rObj);
+});
diff --git a/src/mergeDeepRight.js b/src/mergeDeepRight.js
new file mode 100644
index 00000000..813ad320
--- /dev/null
+++ b/src/mergeDeepRight.js
@@ -0,0 +1,29 @@
+var _curry2 = require('./internal/_curry2');
+var mergeDeepWithKey = require('./mergeDeepWithKey');
+
+
+/**
+ * Creates a new object with the own properties of the first object merged with
+ * the own properties of the second object. If a key exists in both objects:
+ * - and both values are objects, the two values will be recursively merged
+ * - otherwise the value from the second object will be used.
+ *
+ * @func
+ * @memberOf R
+ * @category Object
+ * @sig {a} -> {a} -> {a}
+ * @param {Object} lObj
+ * @param {Object} rObj
+ * @return {Object}
+ * @see R.merge, R.mergeDeepLeft, R.mergeDeepWith, R.mergeDeepWithKey
+ * @example
+ *
+ *      R.mergeDeepRight({ name: 'fred', age: 10, contact: { email: 'moo@example.com' }},
+ *                       { age: 40, contact: { email: 'baa@example.com' }});
+ *      //=> { name: 'fred', age: 40, contact: { email: 'baa@example.com' }}
+ */
+module.exports = _curry2(function mergeDeepRight(lObj, rObj) {
+  return mergeDeepWithKey(function(k, lVal, rVal) {
+    return rVal;
+  }, lObj, rObj);
+});
diff --git a/src/mergeDeepWith.js b/src/mergeDeepWith.js
new file mode 100644
index 00000000..35e8241f
--- /dev/null
+++ b/src/mergeDeepWith.js
@@ -0,0 +1,35 @@
+var _curry3 = require('./internal/_curry3');
+var mergeDeepWithKey = require('./mergeDeepWithKey');
+
+
+/**
+ * Creates a new object with the own properties of the two provided objects.
+ * If a key exists in both objects:
+ * - and both associated values are also objects then the values will be
+ *   recursively merged.
+ * - otherwise the provided function is applied to associated values using the
+ *   resulting value as the new value associated with the key.
+ * If a key only exists in one object, the value will be associated with the key
+ * of the resulting object.
+ *
+ * @func
+ * @memberOf R
+ * @category Object
+ * @sig (a -> a -> a) -> {a} -> {a} -> {a}
+ * @param {Function} fn
+ * @param {Object} lObj
+ * @param {Object} rObj
+ * @return {Object}
+ * @see R.mergeWith, R.mergeDeep, R.mergeDeepWithKey
+ * @example
+ *
+ *      R.mergeDeepWith(R.concat,
+ *                      { a: true, c: { values: [10, 20] }},
+ *                      { b: true, c: { values: [15, 35] }});
+ *      //=> { a: true, b: true, c: { values: [10, 20, 15, 35] }}
+ */
+module.exports = _curry3(function mergeDeepWith(fn, lObj, rObj) {
+  return mergeDeepWithKey(function(k, lVal, rVal) {
+    return fn(lVal, rVal);
+  }, lObj, rObj);
+});
diff --git a/src/mergeDeepWithKey.js b/src/mergeDeepWithKey.js
new file mode 100644
index 00000000..128e50ac
--- /dev/null
+++ b/src/mergeDeepWithKey.js
@@ -0,0 +1,41 @@
+var _curry3 = require('./internal/_curry3');
+var _isObject = require('./internal/_isObject');
+var mergeWithKey = require('./mergeWithKey');
+
+
+/**
+ * Creates a new object with the own properties of the two provided objects.
+ * If a key exists in both objects:
+ * - and both associated values are also objects then the values will be
+ *   recursively merged.
+ * - otherwise the provided function is applied to the key and associated values
+ *   using the resulting value as the new value associated with the key.
+ * If a key only exists in one object, the value will be associated with the key
+ * of the resulting object.
+ *
+ * @func
+ * @memberOf R
+ * @category Object
+ * @sig (String -> a -> a -> a) -> {a} -> {a} -> {a}
+ * @param {Function} fn
+ * @param {Object} lObj
+ * @param {Object} rObj
+ * @return {Object}
+ * @see R.mergeWithKey, R.mergeDeep, R.mergeDeepWith
+ * @example
+ *
+ *      let concatValues = (k, l, r) => k == 'values' ? R.concat(l, r) : r
+ *      R.mergeDeepWithKey(concatValues,
+ *                         { a: true, c: { thing: 'foo', values: [10, 20] }},
+ *                         { b: true, c: { thing: 'bar', values: [15, 35] }});
+ *      //=> { a: true, b: true, c: { thing: 'bar', values: [10, 20, 15, 35] }}
+ */
+module.exports = _curry3(function mergeDeepWithKey(fn, lObj, rObj) {
+  return mergeWithKey(function(k, lVal, rVal) {
+    if (_isObject(lVal) && _isObject(rVal)) {
+      return mergeDeepWithKey(fn, lVal, rVal);
+    } else {
+      return fn(k, lVal, rVal);
+    }
+  }, lObj, rObj);
+});
diff --git a/src/mergeWith.js b/src/mergeWith.js
index d6c7e0bf..1156d012 100644
--- a/src/mergeWith.js
+++ b/src/mergeWith.js
@@ -6,8 +6,7 @@ var mergeWithKey = require('./mergeWithKey');
  * Creates a new object with the own properties of the two provided objects. If
  * a key exists in both objects, the provided function is applied to the values
  * associated with the key in each object, with the result being used as the
- * value associated with the key in the returned object. The key will be
- * excluded from the returned object if the resulting value is `undefined`.
+ * value associated with the key in the returned object.
  *
  * @func
  * @memberOf R
@@ -18,7 +17,7 @@ var mergeWithKey = require('./mergeWithKey');
  * @param {Object} l
  * @param {Object} r
  * @return {Object}
- * @see R.merge, R.mergeWithKey
+ * @see R.mergeDeepWith, R.merge, R.mergeWithKey
  * @example
  *
  *      R.mergeWith(R.concat,
diff --git a/src/mergeWithKey.js b/src/mergeWithKey.js
index 9ca7b2bc..75c44f63 100644
--- a/src/mergeWithKey.js
+++ b/src/mergeWithKey.js
@@ -6,9 +6,7 @@ var _has = require('./internal/_has');
  * Creates a new object with the own properties of the two provided objects. If
  * a key exists in both objects, the provided function is applied to the key
  * and the values associated with the key in each object, with the result being
- * used as the value associated with the key in the returned object. The key
- * will be excluded from the returned object if the resulting value is
- * `undefined`.
+ * used as the value associated with the key in the returned object.
  *
  * @func
  * @memberOf R
@@ -19,7 +17,7 @@ var _has = require('./internal/_has');
  * @param {Object} l
  * @param {Object} r
  * @return {Object}
- * @see R.merge, R.mergeWith
+ * @see R.mergeDeepWithKey, R.merge, R.mergeWith
  * @example
  *
  *      let concatValues = (k, l, r) => k == 'values' ? R.concat(l, r) : r
diff --git a/src/o.js b/src/o.js
new file mode 100644
index 00000000..98d9d05b
--- /dev/null
+++ b/src/o.js
@@ -0,0 +1,29 @@
+var _curry3 = require('./internal/_curry3');
+
+
+/**
+ * `o` is a curried composition function that returns a unary function.
+ * Like `compose`, `o` performs right-to-left function composition. Unlike `compose`,
+ * the rightmost function passed to `o` will be invoked with only one argument.
+ *
+ * @func
+ * @memberOf R
+ * @category Function
+ * @sig (b -> c) -> (a -> b) -> a -> c
+ * @param {Function} f
+ * @param {Function} g
+ * @return {Function}
+ * @see R.compose, R.pipe
+ * @example
+ *
+ *      var classyGreeting = name => "The name's " + name.last + ", " + name.first + " " + lastName
+ *      var yellGreeting = R.o(R.toUpper, classyGreeting);
+ *      yellGreeting({first: 'James', last: 'Bond'}); //=> "THE NAME'S BOND, JAMES BOND"
+ *
+ *      R.o(R.multiply(10), R.add(10))(-4) //=> 60
+ *
+ * @symb R.o(f, g, x) = f(g(x))
+ */
+module.exports = _curry3(function o(f, g, x) {
+  return f(g(x));
+});
diff --git a/test/memoize.js b/test/memoize.js
index 80466d7c..2411df83 100644
--- a/test/memoize.js
+++ b/test/memoize.js
@@ -3,6 +3,28 @@ var eq = require('./shared/eq');
 
 
 describe('memoize', function() {
+  it('calculates the value for a given input only once', function() {
+    var ctr = 0;
+    var fib = R.memoize(function(n) {ctr += 1; return n < 2 ? n : fib(n - 2) + fib(n - 1);});
+    var result = fib(10);
+    eq(result, 55);
+    eq(ctr, 11); // fib(0), fib(1), ... fib(10), no memoization would take 177 iterations.
+  });
+
+  it('handles multiple parameters', function() {
+    var f = R.memoize(function(a, b, c) {return a + ', ' + b + c;});
+    eq(f('Hello', 'World' , '!'), 'Hello, World!');
+    eq(f('Goodbye', 'Cruel World' , '!!!'), 'Goodbye, Cruel World!!!');
+    eq(f('Hello', 'how are you' , '?'), 'Hello, how are you?');
+    eq(f('Hello', 'World' , '!'), 'Hello, World!');
+  });
+
+  it('does not rely on reported arity', function() {
+    var identity = R.memoize(function() { return arguments[0]; });
+    eq(identity('x'), 'x');
+    eq(identity('y'), 'y');
+  });
+
   it('memoizes "false" return values', function() {
     var count = 0;
     var inc = R.memoize(function(n) {
@@ -15,6 +37,34 @@ describe('memoize', function() {
     eq(count, 1);
   });
 
+  it('can be applied to nullary function', function() {
+    var count = 0;
+    var f = R.memoize(function() {
+      count += 1;
+      return 42;
+    });
+    eq(f(), 42);
+    eq(f(), 42);
+    eq(f(), 42);
+    eq(count, 1);
+  });
+
+  it('can be applied to function with optional arguments', function() {
+    var count = 0;
+    var f = R.memoize(function concat(a, b) {
+      count += 1;
+      switch (arguments.length) {
+        case 0: a = 'foo';
+        case 1: b = 'bar';
+      }
+      return a + b;
+    });
+    eq(f(), 'foobar');
+    eq(f(), 'foobar');
+    eq(f(), 'foobar');
+    eq(count, 1);
+  });
+
   it('differentiates values with same string representation', function() {
     var f = R.memoize(R.toString);
     eq(f(42), '42');
@@ -35,4 +85,9 @@ describe('memoize', function() {
     eq(count, 1);
   });
 
+  it('retains arity', function() {
+    var f = R.memoize(function(a, b) { return a + b; });
+    eq(f.length, 2);
+  });
+
 });
diff --git a/test/memoizeWith.js b/test/memoizeWith.js
deleted file mode 100644
index bf0f59a6..00000000
--- a/test/memoizeWith.js
+++ /dev/null
@@ -1,66 +0,0 @@
-var R = require('..');
-var eq = require('./shared/eq');
-
-
-describe('memoizeWith', function() {
-  it('calculates the value for a given input only once', function() {
-    var ctr = 0;
-    var fib = R.memoizeWith(R.identity, function(n) {
-      ctr += 1;
-      return n < 2 ? n : fib(n - 2) + fib(n - 1);
-    });
-    var result = fib(10);
-    eq(result, 55);
-    eq(ctr, 11); // fib(0), fib(1), ... fib(10), no memoization would take 177 iterations.
-  });
-
-  it('handles multiple parameters', function() {
-    var f = R.memoizeWith(function(a, b, c) {
-      return a + b + c;
-    }, function(a, b, c) {return a + ', ' + b + c;});
-    eq(f('Hello', 'World' , '!'), 'Hello, World!');
-    eq(f('Goodbye', 'Cruel World' , '!!!'), 'Goodbye, Cruel World!!!');
-    eq(f('Hello', 'how are you' , '?'), 'Hello, how are you?');
-    eq(f('Hello', 'World' , '!'), 'Hello, World!');
-  });
-
-  it('does not rely on reported arity', function() {
-    var identity = R.memoizeWith(R.identity, function() { return arguments[0]; });
-    eq(identity('x'), 'x');
-    eq(identity('y'), 'y');
-  });
-
-  it('can be applied to nullary function', function() {
-    var count = 0;
-    var f = R.memoizeWith(R.identity, function() {
-      count += 1;
-      return 42;
-    });
-    eq(f(), 42);
-    eq(f(), 42);
-    eq(f(), 42);
-    eq(count, 1);
-  });
-
-  it('can be applied to function with optional arguments', function() {
-    var count = 0;
-    var f = R.memoizeWith(R.concat, function concat(a, b) {
-      count += 1;
-      switch (arguments.length) {
-        case 0: a = 'foo';
-        case 1: b = 'bar';
-      }
-      return a + b;
-    });
-    eq(f(), 'foobar');
-    eq(f(), 'foobar');
-    eq(f(), 'foobar');
-    eq(count, 1);
-  });
-
-  it('retains arity', function() {
-    var f = R.memoizeWith(R.concat, function(a, b) { return a + b; });
-    eq(f.length, 2);
-  });
-
-});
diff --git a/test/mergeDeepLeft.js b/test/mergeDeepLeft.js
new file mode 100644
index 00000000..45ba29b8
--- /dev/null
+++ b/test/mergeDeepLeft.js
@@ -0,0 +1,42 @@
+var assert = require('assert');
+
+var R = require('..');
+var eq = require('./shared/eq');
+
+
+describe('mergeDeepLeft', function() {
+  it('takes two objects, recursively merges their own properties and returns a new object', function() {
+    var a = { w: 1, x: 2, y: { z: 3 }};
+    var b = { a: 4, b: 5, c: { d: 6 }};
+    eq(R.mergeDeepLeft(a, b), { w: 1, x: 2, y: { z: 3 }, a: 4, b: 5, c: { d: 6 }});
+  });
+
+  it('overrides properties in the second object with properties in the first object', function() {
+    var a = { a: { b: 1, c: 2 }, y: 0 };
+    var b = { a: { b: 3, d: 4 }, z: 0 };
+    eq(R.mergeDeepLeft(a, b), { a: { b: 1, c: 2, d: 4 }, y: 0, z: 0 });
+  });
+
+  it('is not destructive', function() {
+    var a = { w: 1, x: { y: 2 }};
+    var res = R.mergeDeepLeft(a, { x: { y: 3 }});
+    assert.notStrictEqual(a, res);
+    assert.notStrictEqual(a.x, res.x);
+    eq(res, { w: 1, x: { y: 2 }});
+  });
+
+  it('reports only own properties', function() {
+    var a = { w: 1, x: { y: 2 }};
+    function Cla() {}
+    Cla.prototype.y = 5;
+    eq(R.mergeDeepLeft({ x: new Cla() }, a), { w: 1, x: { y: 2 }});
+    eq(R.mergeDeepLeft(a, { x: new Cla() }), { w: 1, x: { y: 2 }});
+  });
+
+  it('is curried', function() {
+    var curried = R.mergeDeepLeft({ w: 1, x: 2 });
+    var b = { y: 3, z: 4 };
+    eq(curried(b), { w: 1, x: 2, y: 3, z: 4 });
+  });
+
+});
diff --git a/test/mergeDeepRight.js b/test/mergeDeepRight.js
new file mode 100644
index 00000000..9537b917
--- /dev/null
+++ b/test/mergeDeepRight.js
@@ -0,0 +1,42 @@
+var assert = require('assert');
+
+var R = require('..');
+var eq = require('./shared/eq');
+
+
+describe('mergeDeepRight', function() {
+  it('takes two objects, recursively merges their own properties and returns a new object', function() {
+    var a = { w: 1, x: 2, y: { z: 3 }};
+    var b = { a: 4, b: 5, c: { d: 6 }};
+    eq(R.mergeDeepRight(a, b), { w: 1, x: 2, y: { z: 3 }, a: 4, b: 5, c: { d: 6 }});
+  });
+
+  it('overrides properties in the first object with properties in the second object', function() {
+    var a = { a: { b: 1, c: 2 }, y: 0 };
+    var b = { a: { b: 3, d: 4 }, z: 0 };
+    eq(R.mergeDeepRight(a, b), { a: { b: 3, c: 2, d: 4 }, y: 0, z: 0 });
+  });
+
+  it('is not destructive', function() {
+    var a = { w: 1, x: { y: 2 }};
+    var res = R.mergeDeepRight(a, { x: { y: 3 }});
+    assert.notStrictEqual(a, res);
+    assert.notStrictEqual(a.x, res.x);
+    eq(res, { w: 1, x: { y: 3 }});
+  });
+
+  it('reports only own properties', function() {
+    var a = { w: 1, x: { y: 2 }};
+    function Cla() {}
+    Cla.prototype.y = 5;
+    eq(R.mergeDeepRight({ x: new Cla() }, a), { w: 1, x: { y: 2 }});
+    eq(R.mergeDeepRight(a, { x: new Cla() }), { w: 1, x: { y: 2 }});
+  });
+
+  it('is curried', function() {
+    var curried = R.mergeDeepRight({ w: 1, x: 2 });
+    var b = { y: 3, z: 4 };
+    eq(curried(b), { w: 1, x: 2, y: 3, z: 4 });
+  });
+
+});
diff --git a/test/mergeDeepWith.js b/test/mergeDeepWith.js
new file mode 100644
index 00000000..9d72fe53
--- /dev/null
+++ b/test/mergeDeepWith.js
@@ -0,0 +1,44 @@
+var assert = require('assert');
+
+var R = require('..');
+var eq = require('./shared/eq');
+
+
+describe('mergeDeepWith', function() {
+  function last(x, y) { return y; }
+
+  it('takes two objects, recursively merges their own properties and returns a new object', function() {
+    var a = { w: 1, x: 2, y: { z: 3 }};
+    var b = { a: 4, b: 5, c: { d: 6 }};
+    eq(R.mergeDeepWith(last, a, b), { w: 1, x: 2, y: { z: 3 }, a: 4, b: 5, c: { d: 6 }});
+  });
+
+  it('applies the provided function to the value from the first object and the' +
+    ' value from the second object to determine the value for keys that exist in' +
+    ' both objects', function() {
+    var a = { a: { b: 'B1', c: 'C' }, y: 'Y' };
+    var b = { a: { b: 'B2', d: 'D' }, z: 'Z' };
+    var c = R.mergeDeepWith(function(a, b) { return a + b; }, a, b);
+    eq(c, { a: { b: 'B1B2', c: 'C', d: 'D' }, y: 'Y', z: 'Z' });
+  });
+
+  it('is not destructive', function() {
+    var a = { w: 1, x: { y: 2 }};
+    var res = R.mergeDeepWith(last, a, { x: { y: 3 }});
+    assert.notStrictEqual(a, res);
+    assert.notStrictEqual(a.x, res.x);
+    eq(res, { w: 1, x: { y: 3 }});
+  });
+
+  it('reports only own properties', function() {
+    var a = { w: 1, x: { y: 2 }};
+    function Cla() {}
+    Cla.prototype.y = 5;
+    eq(R.mergeDeepWith(last, { x: new Cla() }, a), { w: 1, x: { y: 2 }});
+    eq(R.mergeDeepWith(last, a, { x: new Cla() }), { w: 1, x: { y: 2 }});
+  });
+
+  it('is curried', function() {
+    eq(R.mergeDeepWith(last)({w: 1, x: 2})({y: 3, z: 4}), {w: 1, x: 2, y: 3, z: 4});
+  });
+});
diff --git a/test/mergeDeepWithKey.js b/test/mergeDeepWithKey.js
new file mode 100644
index 00000000..135f29a5
--- /dev/null
+++ b/test/mergeDeepWithKey.js
@@ -0,0 +1,44 @@
+var assert = require('assert');
+
+var R = require('..');
+var eq = require('./shared/eq');
+
+
+describe('mergeDeepWithKey', function() {
+  function last(k, x, y) { return y; }
+
+  it('takes two objects, recursively merges their own properties and returns a new object', function() {
+    var a = { w: 1, x: 2, y: { z: 3 }};
+    var b = { a: 4, b: 5, c: { d: 6 }};
+    eq(R.mergeDeepWithKey(last, a, b), { w: 1, x: 2, y: { z: 3 }, a: 4, b: 5, c: { d: 6 }});
+  });
+
+  it('applies the provided function to the key, the value from the first object' +
+    ' and the value from the second object to determine the value for keys that' +
+    ' exist in both objects', function() {
+    var a = { a: { b: 'B1', c: 'C' }, y: 'Y' };
+    var b = { a: { b: 'B2', d: 'D' }, z: 'Z' };
+    var c = R.mergeDeepWithKey(function(k, a, b) { return k + a + b; }, a, b);
+    eq(c, { a: { b: 'bB1B2', c: 'C', d: 'D' }, y: 'Y', z: 'Z' });
+  });
+
+  it('is not destructive', function() {
+    var a = { w: 1, x: { y: 2 }};
+    var res = R.mergeDeepWithKey(last, a, { x: { y: 3 }});
+    assert.notStrictEqual(a, res);
+    assert.notStrictEqual(a.x, res.x);
+    eq(res, { w: 1, x: { y: 3 }});
+  });
+
+  it('reports only own properties', function() {
+    var a = { w: 1, x: { y: 2 }};
+    function Cla() {}
+    Cla.prototype.y = 5;
+    eq(R.mergeDeepWithKey(last, { x: new Cla() }, a), { w: 1, x: { y: 2 }});
+    eq(R.mergeDeepWithKey(last, a, { x: new Cla() }), { w: 1, x: { y: 2 }});
+  });
+
+  it('is curried', function() {
+    eq(R.mergeDeepWithKey(last)({w: 1, x: 2})({y: 3, z: 4}), {w: 1, x: 2, y: 3, z: 4});
+  });
+});
diff --git a/test/o.js b/test/o.js
new file mode 100644
index 00000000..29df3ec8
--- /dev/null
+++ b/test/o.js
@@ -0,0 +1,44 @@
+var jsv = require('jsverify');
+
+var R = require('..');
+var eq = require('./shared/eq');
+
+
+describe('o', function() {
+
+  it('is not a variadic function', function() {
+    eq(typeof R.o, 'function');
+    eq(R.o.length, 3);
+  });
+
+  it('is a curried function', function() {
+    eq(R.o(R.add(1), R.multiply(2), 10), R.o(R.add(1))(R.multiply(2))(10));
+  });
+
+  it('performs right-to-left function composition', function() {
+    //  f :: Number -> ([Number] -> [Number])
+    var f = R.o(R.map, R.multiply);
+
+    eq(f.length, 1);
+    eq(f(10)([1, 2, 3]), [10, 20, 30]);
+  });
+
+  describe('o properties', function() {
+
+    jsv.property('composes two functions', jsv.fn(), jsv.fn(), jsv.nat, function(f, g, x) {
+      return R.equals(R.o(f, g)(x), f(g(x)));
+    });
+
+    jsv.property('associative',  jsv.fn(), jsv.fn(), jsv.fn(), jsv.nat, function(f, g, h, x) {
+      var result = f(g(h(x)));
+      var fg = R.o(f, g);
+      var gh = R.o(g, h);
+      return R.all(R.equals(result), [
+        R.o(f, gh, x),
+        R.o(fg, h, x),
+        R.o(f, gh)(x),
+        R.o(fg, h)(x)
+      ]);
+    });
+  });
+});
