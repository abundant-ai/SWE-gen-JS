diff --git a/.gitignore b/.gitignore
index ccd52cd34..16202c352 100644
--- a/.gitignore
+++ b/.gitignore
@@ -39,7 +39,6 @@ stats.html
 .pnpm-store
 .svelte-kit
 .tsup
-.vinxi
 
 vite.config.js.timestamp-*
 vite.config.ts.timestamp-*
diff --git a/docs/framework/angular/guides/optimistic-updates.md b/docs/framework/angular/guides/optimistic-updates.md
index 478675912..0f148e76b 100644
--- a/docs/framework/angular/guides/optimistic-updates.md
+++ b/docs/framework/angular/guides/optimistic-updates.md
@@ -72,6 +72,7 @@ addTodo = injectMutation(() => ({
 
 // access variables somewhere else
 
+// Note: injectMutationState is not available yet in Angular Query
 mutationState = injectMutationState<string>(() => ({
   filters: { mutationKey: ['addTodo'], status: 'pending' },
   select: (mutation) => mutation.state.variables,
diff --git a/packages/angular-query-experimental/src/__tests__/inject-mutation-state.test-d.ts b/packages/angular-query-experimental/src/__tests__/inject-mutation-state.test-d.ts
deleted file mode 100644
index 463c06b53..000000000
--- a/packages/angular-query-experimental/src/__tests__/inject-mutation-state.test-d.ts
+++ /dev/null
@@ -1,22 +0,0 @@
-import { describe, expectTypeOf } from 'vitest'
-import { injectMutationState } from '../inject-mutation-state'
-import type { MutationState, MutationStatus } from '@tanstack/query-core'
-
-describe('injectMutationState', () => {
-  it('should default to QueryState', () => {
-    const result = injectMutationState(() => ({
-      filters: { status: 'pending' },
-    }))
-
-    expectTypeOf(result()).toEqualTypeOf<Array<MutationState>>()
-  })
-
-  it('should infer with select', () => {
-    const result = injectMutationState(() => ({
-      filters: { status: 'pending' },
-      select: (mutation) => mutation.state.status,
-    }))
-
-    expectTypeOf(result()).toEqualTypeOf<Array<MutationStatus>>()
-  })
-})
diff --git a/packages/angular-query-experimental/src/__tests__/inject-mutation-state.test.ts b/packages/angular-query-experimental/src/__tests__/inject-mutation-state.test.ts
deleted file mode 100644
index 2e6a86bc3..000000000
--- a/packages/angular-query-experimental/src/__tests__/inject-mutation-state.test.ts
+++ /dev/null
@@ -1,108 +0,0 @@
-import { signal } from '@angular/core'
-import { QueryClient } from '@tanstack/query-core'
-import { TestBed } from '@angular/core/testing'
-import { describe, expect, test, vi } from 'vitest'
-import { injectMutation } from '../inject-mutation'
-import { injectMutationState } from '../inject-mutation-state'
-import { provideAngularQuery } from '../providers'
-import { successMutator } from './test-utils'
-
-describe('injectMutationState', () => {
-  let queryClient: QueryClient
-
-  beforeEach(() => {
-    queryClient = new QueryClient()
-    vi.useFakeTimers()
-    TestBed.configureTestingModule({
-      providers: [provideAngularQuery(queryClient)],
-    })
-  })
-
-  afterEach(() => {
-    vi.useRealTimers()
-  })
-
-  describe('injectMutationState', () => {
-    test('should return variables after calling mutate', async () => {
-      const mutationKey = ['mutation']
-      const variables = 'foo123'
-
-      const mutation = TestBed.runInInjectionContext(() => {
-        return injectMutation(() => ({
-          mutationKey: mutationKey,
-          mutationFn: (params: string) => successMutator(params),
-        }))
-      })
-
-      mutation.mutate(variables)
-
-      const mutationState = TestBed.runInInjectionContext(() => {
-        return injectMutationState(() => ({
-          filters: { mutationKey, status: 'pending' },
-          select: (m) => m.state.variables,
-        }))
-      })
-
-      expect(mutationState()).toEqual([variables])
-    })
-
-    test('reactive options should update injectMutationState', async () => {
-      const mutationKey1 = ['mutation1']
-      const mutationKey2 = ['mutation2']
-      const variables1 = 'foo123'
-      const variables2 = 'bar234'
-
-      const [mutation1, mutation2] = TestBed.runInInjectionContext(() => {
-        return [
-          injectMutation(() => ({
-            mutationKey: mutationKey1,
-            mutationFn: (params: string) => successMutator(params),
-          })),
-          injectMutation(() => ({
-            mutationKey: mutationKey2,
-            mutationFn: (params: string) => successMutator(params),
-          })),
-        ]
-      })
-
-      mutation1.mutate(variables1)
-      mutation2.mutate(variables2)
-
-      const filterKey = signal(mutationKey1)
-
-      const mutationState = TestBed.runInInjectionContext(() => {
-        return injectMutationState(() => ({
-          filters: { mutationKey: filterKey(), status: 'pending' },
-          select: (m) => m.state.variables,
-        }))
-      })
-
-      expect(mutationState()).toEqual([variables1])
-
-      filterKey.set(mutationKey2)
-      TestBed.flushEffects()
-      expect(mutationState()).toEqual([variables2])
-    })
-
-    test('should return variables after calling mutate', async () => {
-      queryClient.clear()
-      const mutationKey = ['mutation']
-      const variables = 'bar234'
-
-      const mutation = TestBed.runInInjectionContext(() => {
-        return injectMutation(() => ({
-          mutationKey: mutationKey,
-          mutationFn: (params: string) => successMutator(params),
-        }))
-      })
-
-      mutation.mutate(variables)
-
-      const mutationState = TestBed.runInInjectionContext(() => {
-        return injectMutationState()
-      })
-
-      expect(mutationState()[0]?.variables).toEqual(variables)
-    })
-  })
-})
diff --git a/packages/angular-query-experimental/src/__tests__/inject-mutation.test.ts b/packages/angular-query-experimental/src/__tests__/inject-mutation.test.ts
index 259e1caf2..2d538bb20 100644
--- a/packages/angular-query-experimental/src/__tests__/inject-mutation.test.ts
+++ b/packages/angular-query-experimental/src/__tests__/inject-mutation.test.ts
@@ -123,9 +123,7 @@ describe('injectMutation', () => {
 
   test('reactive options should update mutation', async () => {
     const mutationCache = queryClient.getMutationCache()
-    // Signal will be updated before the mutation is called
-    // this test confirms that the mutation uses the updated value
-    const mutationKey = signal(['1'])
+    const mutationKey = signal(['foo'])
     const mutation = TestBed.runInInjectionContext(() => {
       return injectMutation(() => ({
         mutationKey: mutationKey(),
@@ -133,15 +131,19 @@ describe('injectMutation', () => {
       }))
     })
 
-    mutationKey.set(['2'])
+    mutationKey.set(['bar'])
 
     TestBed.flushEffects()
 
+    await resolveMutations()
+
     mutation.mutate('xyz')
 
-    const mutations = mutationCache.find({ mutationKey: ['2'] })
+    await resolveMutations()
+
+    const mutations = mutationCache.find({ mutationKey: ['bar'] })
 
-    expect(mutations?.options.mutationKey).toEqual(['2'])
+    expect(mutations?.options.mutationKey).toEqual(['bar'])
   })
 
   test('should reset state after invoking mutation.reset', async () => {
diff --git a/packages/angular-query-experimental/src/create-base-query.ts b/packages/angular-query-experimental/src/create-base-query.ts
index 3fbde300f..c5a0e1183 100644
--- a/packages/angular-query-experimental/src/create-base-query.ts
+++ b/packages/angular-query-experimental/src/create-base-query.ts
@@ -5,7 +5,6 @@ import {
   effect,
   inject,
   signal,
-  untracked,
 } from '@angular/core'
 import { notifyManager } from '@tanstack/query-core'
 import { signalProxy } from './signal-proxy'
@@ -63,19 +62,18 @@ export function createBaseQuery<
     observer.getOptimisticResult(defaultedOptionsSignal()),
   )
 
-  effect(() => {
-    const defaultedOptions = defaultedOptionsSignal()
-    observer.setOptions(defaultedOptions, {
+  effect(
+    () => {
       // Do not notify on updates because of changes in the options because
       // these changes should already be reflected in the optimistic result.
-      listeners: false,
-    })
-    untracked(() =>
-      // Set the signal in effect because it's both 'computed' from options()
-      // and needs to be set imperatively in the query observer listener.
-      resultSignal.set(observer.getOptimisticResult(defaultedOptions)),
-    )
-  })
+      const defaultedOptions = defaultedOptionsSignal()
+      observer.setOptions(defaultedOptions, {
+        listeners: false,
+      })
+      resultSignal.set(observer.getOptimisticResult(defaultedOptions))
+    },
+    { allowSignalWrites: true },
+  )
 
   // observer.trackResult is not used as this optimization is not needed for Angular
   const unsubscribe = observer.subscribe(
diff --git a/packages/angular-query-experimental/src/index.ts b/packages/angular-query-experimental/src/index.ts
index d56be2adb..89587b496 100644
--- a/packages/angular-query-experimental/src/index.ts
+++ b/packages/angular-query-experimental/src/index.ts
@@ -17,7 +17,6 @@ export * from './inject-infinite-query'
 export * from './inject-is-fetching'
 export * from './inject-is-mutating'
 export * from './inject-mutation'
-export * from './inject-mutation-state'
 export * from './inject-queries'
 export * from './inject-query'
 export {
diff --git a/packages/angular-query-experimental/src/inject-mutation-state.ts b/packages/angular-query-experimental/src/inject-mutation-state.ts
deleted file mode 100644
index 94fd80458..000000000
--- a/packages/angular-query-experimental/src/inject-mutation-state.ts
+++ /dev/null
@@ -1,81 +0,0 @@
-import { DestroyRef, effect, inject, signal, untracked } from '@angular/core'
-import {
-  type DefaultError,
-  type Mutation,
-  type MutationCache,
-  type MutationFilters,
-  type MutationState,
-  notifyManager,
-  replaceEqualDeep,
-} from '@tanstack/query-core'
-import { assertInjector } from './util/assert-injector/assert-injector'
-import { injectQueryClient } from './inject-query-client'
-import type { Injector, Signal } from '@angular/core'
-
-type MutationStateOptions<TResult = MutationState> = {
-  filters?: MutationFilters
-  select?: (
-    mutation: Mutation<unknown, DefaultError, unknown, unknown>,
-  ) => TResult
-}
-
-function getResult<TResult = MutationState>(
-  mutationCache: MutationCache,
-  options: MutationStateOptions<TResult>,
-): Array<TResult> {
-  return mutationCache
-    .findAll(options.filters)
-    .map(
-      (mutation): TResult =>
-        (options.select
-          ? options.select(
-              mutation as Mutation<unknown, DefaultError, unknown, unknown>,
-            )
-          : mutation.state) as TResult,
-    )
-}
-
-export interface InjectMutationStateOptions {
-  injector?: Injector
-}
-
-export function injectMutationState<TResult = MutationState>(
-  mutationStateOptionsFn: () => MutationStateOptions<TResult> = () => ({}),
-  options?: InjectMutationStateOptions,
-): Signal<Array<TResult>> {
-  return assertInjector(injectMutationState, options?.injector, () => {
-    const destroyRef = inject(DestroyRef)
-    const queryClient = injectQueryClient()
-
-    const mutationCache = queryClient.getMutationCache()
-
-    const result = signal<Array<TResult>>(
-      getResult(mutationCache, mutationStateOptionsFn()),
-    )
-
-    effect(() => {
-      const mutationStateOptions = mutationStateOptionsFn()
-      untracked(() => {
-        // Setting the signal from an effect because it's both 'computed' from options()
-        // and needs to be set imperatively in the mutationCache listener.
-        result.set(getResult(mutationCache, mutationStateOptions))
-      })
-    })
-
-    const unsubscribe = mutationCache.subscribe(
-      notifyManager.batchCalls(() => {
-        const nextResult = replaceEqualDeep(
-          result(),
-          getResult(mutationCache, mutationStateOptionsFn()),
-        )
-        if (result() !== nextResult) {
-          result.set(nextResult)
-        }
-      }),
-    )
-
-    destroyRef.onDestroy(unsubscribe)
-
-    return result
-  })
-}
