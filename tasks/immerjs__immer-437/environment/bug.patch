diff --git a/.travis.yml b/.travis.yml
index b317e36..1d3f0c4 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -2,7 +2,7 @@ language: node_js
 node_js:
     - "8"
     - "10"
-    # - "node"
+    - "node"
 env:
     - NODE_ENV=TEST
 cache:
diff --git a/__tests__/__snapshots__/hooks.js.snap b/__tests__/__snapshots__/hooks.js.snap
index 514fbfb..822fcb4 100644
--- a/__tests__/__snapshots__/hooks.js.snap
+++ b/__tests__/__snapshots__/hooks.js.snap
@@ -1,90 +1,5 @@
 // Jest Snapshot v1, https://goo.gl/fbAQLP
 
-exports[`hooks (es5) - onAssign() when draft is a Map assign 1`] = `
-Array [
-  Array [
-    "a",
-    10,
-  ],
-  Array [
-    Object {
-      "prop": "val1",
-    },
-    11,
-  ],
-]
-`;
-
-exports[`hooks (es5) - onAssign() when draft is a Map nested assignments 1`] = `
-Array [
-  Array [
-    "b",
-    2,
-  ],
-  Array [
-    Object {
-      "prop": "val1",
-    },
-    Map {
-      "b" => 2,
-      "d" => 1,
-    },
-  ],
-  Array [
-    "a",
-    Map {
-      Object {
-        "prop": "val1",
-      } => Map {
-        "b" => 2,
-        "d" => 1,
-      },
-    },
-  ],
-]
-`;
-
-exports[`hooks (es5) - onAssign() when draft is a Set assign 1`] = `
-Array [
-  Array [
-    "a",
-    Set {
-      1,
-      2,
-      3,
-      4,
-    },
-  ],
-]
-`;
-
-exports[`hooks (es5) - onAssign() when draft is a Set delete 1`] = `
-Array [
-  Array [
-    "a",
-    Set {
-      2,
-      3,
-    },
-  ],
-]
-`;
-
-exports[`hooks (es5) - onAssign() when draft is a Set nested assignments 1`] = `
-Array [
-  Array [
-    "a",
-    Set {
-      "a",
-      Set {
-        1,
-        2,
-      },
-    },
-  ],
-]
-`;
-
 exports[`hooks (es5) - onAssign() when draft is an array assign 1`] = `
 Array [
   Array [
@@ -193,27 +108,6 @@ Array [
 ]
 `;
 
-exports[`hooks (es5) - onDelete() when draft is a Map - delete 1`] = `
-Array [
-  Array [
-    "a",
-  ],
-  Array [
-    Object {
-      "prop": "val1",
-    },
-  ],
-]
-`;
-
-exports[`hooks (es5) - onDelete() when draft is a Map - nested deletions 1`] = `
-Array [
-  Array [
-    "b",
-  ],
-]
-`;
-
 exports[`hooks (es5) - onDelete() when draft is an array - length = 0 1`] = `
 Array [
   Array [
diff --git a/__tests__/base.js b/__tests__/base.js
index 928ea0a..025cb24 100644
--- a/__tests__/base.js
+++ b/__tests__/base.js
@@ -299,430 +299,450 @@ function runBaseTest(name, useProxies, autoFreeze, useListener) {
             }
         })
 
-        describe("map drafts", () => {
-            it("supports key access", () => {
-                const value = baseState.aMap.get("jedi")
-                const nextState = produce(baseState, s => {
-                    expect(s.aMap.get("jedi")).toEqual(value)
+        if (useProxies) {
+            describe("map drafts", () => {
+                it("supports key access", () => {
+                    const value = baseState.aMap.get("jedi")
+                    const nextState = produce(baseState, s => {
+                        expect(s.aMap.get("jedi")).toEqual(value)
+                    })
+                    expect(nextState).toBe(baseState)
                 })
-                expect(nextState).toBe(baseState)
-            })
 
-            it("supports key access for non-primitive keys", () => {
-                const key = {prop: "val"}
-                const base = new Map([[key, {id: 1, a: 1}]])
-                const value = base.get(key)
-                const nextState = produce(base, s => {
-                    expect(s.get(key)).toEqual(value)
+                it("supports key access for non-primitive keys", () => {
+                    const key = {prop: "val"}
+                    const base = new Map([[key, {id: 1, a: 1}]])
+                    const value = base.get(key)
+                    const nextState = produce(base, s => {
+                        expect(s.get(key)).toEqual(value)
+                    })
+                    expect(nextState).toBe(base)
                 })
-                expect(nextState).toBe(base)
-            })
 
-            it("supports iteration", () => {
-                const base = new Map([
-                    ["first", {id: 1, a: 1}],
-                    ["second", {id: 2, a: 1}]
-                ])
-                const findById = (map, id) => {
-                    for (const [, item] of map) {
-                        if (item.id === id) return item
+                it("supports iteration", () => {
+                    const base = new Map([
+                        ["first", {id: 1, a: 1}],
+                        ["second", {id: 2, a: 1}]
+                    ])
+                    const findById = (map, id) => {
+                        for (const [, item] of map) {
+                            if (item.id === id) return item
+                        }
+                        return null
                     }
-                    return null
-                }
-                const result = produce(base, draft => {
-                    const obj1 = findById(draft, 1)
-                    const obj2 = findById(draft, 2)
-                    obj1.a = 2
-                    obj2.a = 2
+                    const result = produce(base, draft => {
+                        const obj1 = findById(draft, 1)
+                        const obj2 = findById(draft, 2)
+                        obj1.a = 2
+                        obj2.a = 2
+                    })
+                    expect(result).not.toBe(base)
+                    expect(result.get("first").a).toEqual(2)
+                    expect(result.get("second").a).toEqual(2)
                 })
-                expect(result).not.toBe(base)
-                expect(result.get("first").a).toEqual(2)
-                expect(result.get("second").a).toEqual(2)
-            })
 
-            it("supports 'entries'", () => {
-                const base = new Map([
-                    ["first", {id: 1, a: 1}],
-                    ["second", {id: 2, a: 1}]
-                ])
-                const findById = (map, id) => {
-                    for (const [, item] of map.entries()) {
-                        if (item.id === id) return item
+                it("supports 'entries'", () => {
+                    const base = new Map([
+                        ["first", {id: 1, a: 1}],
+                        ["second", {id: 2, a: 1}]
+                    ])
+                    const findById = (map, id) => {
+                        for (const [, item] of map.entries()) {
+                            if (item.id === id) return item
+                        }
+                        return null
                     }
-                    return null
-                }
-                const result = produce(base, draft => {
-                    const obj1 = findById(draft, 1)
-                    const obj2 = findById(draft, 2)
-                    obj1.a = 2
-                    obj2.a = 2
+                    const result = produce(base, draft => {
+                        const obj1 = findById(draft, 1)
+                        const obj2 = findById(draft, 2)
+                        obj1.a = 2
+                        obj2.a = 2
+                    })
+                    expect(result).not.toBe(base)
+                    expect(result.get("first").a).toEqual(2)
+                    expect(result.get("second").a).toEqual(2)
                 })
-                expect(result).not.toBe(base)
-                expect(result.get("first").a).toEqual(2)
-                expect(result.get("second").a).toEqual(2)
-            })
 
-            it("supports 'values'", () => {
-                const base = new Map([
-                    ["first", {id: 1, a: 1}],
-                    ["second", {id: 2, a: 1}]
-                ])
-                const findById = (map, id) => {
-                    for (const item of map.values()) {
-                        if (item.id === id) return item
+                it("supports 'values'", () => {
+                    const base = new Map([
+                        ["first", {id: 1, a: 1}],
+                        ["second", {id: 2, a: 1}]
+                    ])
+                    const findById = (map, id) => {
+                        for (const item of map.values()) {
+                            if (item.id === id) return item
+                        }
+                        return null
                     }
-                    return null
-                }
-                const result = produce(base, draft => {
-                    const obj1 = findById(draft, 1)
-                    const obj2 = findById(draft, 2)
-                    obj1.a = 2
-                    obj2.a = 2
+                    const result = produce(base, draft => {
+                        const obj1 = findById(draft, 1)
+                        const obj2 = findById(draft, 2)
+                        obj1.a = 2
+                        obj2.a = 2
+                    })
+                    expect(result).not.toBe(base)
+                    expect(result.get("first").a).toEqual(2)
+                    expect(result.get("second").a).toEqual(2)
                 })
-                expect(result).not.toBe(base)
-                expect(result.get("first").a).toEqual(2)
-                expect(result.get("second").a).toEqual(2)
-            })
 
-            it("supports 'keys", () => {
-                const base = new Map([
-                    ["first", Symbol()],
-                    ["second", Symbol()]
-                ])
-                const result = produce(base, draft => {
-                    expect([...draft.keys()]).toEqual(["first", "second"])
-                    draft.set("third", Symbol())
-                    expect([...draft.keys()]).toEqual([
-                        "first",
-                        "second",
-                        "third"
+                it("supports 'keys", () => {
+                    const base = new Map([
+                        ["first", Symbol()],
+                        ["second", Symbol()]
                     ])
+                    const result = produce(base, draft => {
+                        expect([...draft.keys()]).toEqual(["first", "second"])
+                        draft.set("third", Symbol())
+                        expect([...draft.keys()]).toEqual([
+                            "first",
+                            "second",
+                            "third"
+                        ])
+                    })
                 })
-            })
 
-            it("supports forEach", () => {
-                const key1 = {prop: "val1"}
-                const key2 = {prop: "val2"}
-                const base = new Map([
-                    ["first", {id: 1, a: 1}],
-                    ["second", {id: 2, a: 1}],
-                    [key1, {id: 3, a: 1}],
-                    [key2, {id: 4, a: 1}]
-                ])
-                const result = produce(base, draft => {
-                    let sum1 = 0
-                    draft.forEach(({a}) => {
-                        sum1 += a
-                    })
-                    expect(sum1).toBe(4)
-                    let sum2 = 0
-                    draft.get("first").a = 10
-                    draft.get("second").a = 20
-                    draft.get(key1).a = 30
-                    draft.get(key2).a = 40
-                    draft.forEach(({a}) => {
-                        sum2 += a
+                it("supports forEach", () => {
+                    const key1 = {prop: "val1"}
+                    const key2 = {prop: "val2"}
+                    const base = new Map([
+                        ["first", {id: 1, a: 1}],
+                        ["second", {id: 2, a: 1}],
+                        [key1, {id: 3, a: 1}],
+                        [key2, {id: 4, a: 1}]
+                    ])
+                    const result = produce(base, draft => {
+                        let sum1 = 0
+                        draft.forEach(({a}) => {
+                            sum1 += a
+                        })
+                        expect(sum1).toBe(4)
+                        let sum2 = 0
+                        draft.get("first").a = 10
+                        draft.get("second").a = 20
+                        draft.get(key1).a = 30
+                        draft.get(key2).a = 40
+                        draft.forEach(({a}) => {
+                            sum2 += a
+                        })
+                        expect(sum2).toBe(100)
                     })
-                    expect(sum2).toBe(100)
-                })
-                expect(result).not.toBe(base)
-                expect(base.get("first").a).toEqual(1)
-                expect(base.get("second").a).toEqual(1)
-                expect(base.get(key1).a).toEqual(1)
-                expect(base.get(key2).a).toEqual(1)
-                expect(result.get("first").a).toEqual(10)
-                expect(result.get("second").a).toEqual(20)
-                expect(result.get(key1).a).toEqual(30)
-                expect(result.get(key2).a).toEqual(40)
-            })
-
-            it("supports forEach mutation", () => {
-                const base = new Map([
-                    ["first", {id: 1, a: 1}],
-                    ["second", {id: 2, a: 1}]
-                ])
-                const result = produce(base, draft => {
-                    draft.forEach(item => {
-                        item.a = 100
+                    expect(result).not.toBe(base)
+                    expect(base.get("first").a).toEqual(1)
+                    expect(base.get("second").a).toEqual(1)
+                    expect(base.get(key1).a).toEqual(1)
+                    expect(base.get(key2).a).toEqual(1)
+                    expect(result.get("first").a).toEqual(10)
+                    expect(result.get("second").a).toEqual(20)
+                    expect(result.get(key1).a).toEqual(30)
+                    expect(result.get(key2).a).toEqual(40)
+                })
+
+                it("supports forEach mutation", () => {
+                    const base = new Map([
+                        ["first", {id: 1, a: 1}],
+                        ["second", {id: 2, a: 1}]
+                    ])
+                    const result = produce(base, draft => {
+                        draft.forEach(item => {
+                            item.a = 100
+                        })
                     })
+                    expect(result).not.toBe(base)
+                    expect(result.get("first").a).toEqual(100)
+                    expect(result.get("second").a).toEqual(100)
                 })
-                expect(result).not.toBe(base)
-                expect(result.get("first").a).toEqual(100)
-                expect(result.get("second").a).toEqual(100)
-            })
 
-            it("can assign by key", () => {
-                const nextState = produce(baseState, s => {
-                    // Map.prototype.set should return the Map itself
-                    const res = s.aMap.set("force", true)
-                    expect(res).toBe(s.aMap[DRAFT_STATE].draft)
+                it("can assign by key", () => {
+                    const nextState = produce(baseState, s => {
+                        // Map.prototype.set should return the Map itself
+                        const res = s.aMap.set("force", true)
+                        expect(res).toBe(s.aMap[DRAFT_STATE].draft)
+                    })
+                    expect(nextState).not.toBe(baseState)
+                    expect(nextState.aMap).not.toBe(baseState.aMap)
+                    expect(nextState.aMap.get("force")).toEqual(true)
                 })
-                expect(nextState).not.toBe(baseState)
-                expect(nextState.aMap).not.toBe(baseState.aMap)
-                expect(nextState.aMap.get("force")).toEqual(true)
-            })
 
-            it("can assign by a non-primitive key", () => {
-                const key = {prop: "val"}
-                const value = {id: 1, a: 1}
-                const base = new Map([[key, value]])
-                const nextState = produce(base, s => {
-                    s.set(key, true)
+                it("can assign by a non-primitive key", () => {
+                    const key = {prop: "val"}
+                    const value = {id: 1, a: 1}
+                    const base = new Map([[key, value]])
+                    const nextState = produce(base, s => {
+                        s.set(key, true)
+                    })
+                    expect(nextState).not.toBe(base)
+                    expect(base.get(key)).toEqual(value)
+                    expect(nextState.get(key)).toEqual(true)
                 })
-                expect(nextState).not.toBe(base)
-                expect(base.get(key)).toEqual(value)
-                expect(nextState.get(key)).toEqual(true)
-            })
 
-            it("state stays the same if the the same item is assigned by key", () => {
-                const nextState = produce(baseState, s => {
-                    s.aMap.set("jediTotal", 42)
+                it("state stays the same if the the same item is assigned by key", () => {
+                    const nextState = produce(baseState, s => {
+                        s.aMap.set("jediTotal", 42)
+                    })
+                    expect(nextState).toBe(baseState)
+                    expect(nextState.aMap).toBe(baseState.aMap)
                 })
-                expect(nextState).toBe(baseState)
-                expect(nextState.aMap).toBe(baseState.aMap)
-            })
 
-            it("returns 'size'", () => {
-                const nextState = produce(baseState, s => {
-                    s.aMap.set("newKey", true)
-                    expect(s.aMap.size).toBe(baseState.aMap.size + 1)
+                it("returns 'size'", () => {
+                    const nextState = produce(baseState, s => {
+                        s.aMap.set("newKey", true)
+                        expect(s.aMap.size).toBe(baseState.aMap.size + 1)
+                    })
+                    expect(nextState).not.toBe(baseState)
+                    expect(nextState.aMap).not.toBe(baseState.aMap)
+                    expect(nextState.aMap.get("newKey")).toEqual(true)
+                    expect(nextState.aMap.size).toEqual(baseState.aMap.size + 1)
                 })
-                expect(nextState).not.toBe(baseState)
-                expect(nextState.aMap).not.toBe(baseState.aMap)
-                expect(nextState.aMap.get("newKey")).toEqual(true)
-                expect(nextState.aMap.size).toEqual(baseState.aMap.size + 1)
-            })
 
-            it("can use 'delete' to remove items", () => {
-                const nextState = produce(baseState, s => {
-                    expect(s.aMap.has("jedi")).toBe(true)
-                    s.aMap.delete("jedi")
-                    expect(s.aMap.has("jedi")).toBe(false)
+                it("can use 'delete' to remove items", () => {
+                    const nextState = produce(baseState, s => {
+                        expect(s.aMap.has("jedi")).toBe(true)
+                        s.aMap.delete("jedi")
+                        expect(s.aMap.has("jedi")).toBe(false)
+                    })
+                    expect(nextState.aMap).not.toBe(baseState.aMap)
+                    expect(nextState.aMap.size).toBe(baseState.aMap.size - 1)
+                    expect(baseState.aMap.has("jedi")).toBe(true)
+                    expect(nextState.aMap.has("jedi")).toBe(false)
                 })
-                expect(nextState.aMap).not.toBe(baseState.aMap)
-                expect(nextState.aMap.size).toBe(baseState.aMap.size - 1)
-                expect(baseState.aMap.has("jedi")).toBe(true)
-                expect(nextState.aMap.has("jedi")).toBe(false)
-            })
 
-            it("can use 'clear' to remove items", () => {
-                const nextState = produce(baseState, s => {
-                    expect(s.aMap.size).not.toBe(0)
-                    s.aMap.clear()
-                    expect(s.aMap.size).toBe(0)
+                it("can use 'clear' to remove items", () => {
+                    const nextState = produce(baseState, s => {
+                        expect(s.aMap.size).not.toBe(0)
+                        s.aMap.clear()
+                        expect(s.aMap.size).toBe(0)
+                    })
+                    expect(nextState.aMap).not.toBe(baseState.aMap)
+                    expect(baseState.aMap.size).not.toBe(0)
+                    expect(nextState.aMap.size).toBe(0)
                 })
-                expect(nextState.aMap).not.toBe(baseState.aMap)
-                expect(baseState.aMap.size).not.toBe(0)
-                expect(nextState.aMap.size).toBe(0)
-            })
 
-            it("support 'has'", () => {
-                const nextState = produce(baseState, s => {
-                    expect(s.aMap.has("newKey")).toBe(false)
-                    s.aMap.set("newKey", true)
-                    expect(s.aMap.has("newKey")).toBe(true)
+                it("support 'has'", () => {
+                    const nextState = produce(baseState, s => {
+                        expect(s.aMap.has("newKey")).toBe(false)
+                        s.aMap.set("newKey", true)
+                        expect(s.aMap.has("newKey")).toBe(true)
+                    })
+                    expect(nextState).not.toBe(baseState)
+                    expect(nextState.aMap).not.toBe(baseState.aMap)
+                    expect(baseState.aMap.has("newKey")).toBe(false)
+                    expect(nextState.aMap.has("newKey")).toBe(true)
                 })
-                expect(nextState).not.toBe(baseState)
-                expect(nextState.aMap).not.toBe(baseState.aMap)
-                expect(baseState.aMap.has("newKey")).toBe(false)
-                expect(nextState.aMap.has("newKey")).toBe(true)
-            })
 
-            it("supports nested maps", () => {
-                const base = new Map([
-                    ["first", new Map([["second", {prop: "test"}]])]
-                ])
-                const result = produce(base, draft => {
-                    draft.get("first").get("second").prop = "test1"
-                })
-                expect(result).not.toBe(base)
-                expect(result.get("first")).not.toBe(base.get("first"))
-                expect(result.get("first").get("second")).not.toBe(
-                    base.get("first").get("second")
-                )
-                expect(base.get("first").get("second").prop).toBe("test")
-                expect(result.get("first").get("second").prop).toBe("test1")
-            })
-        })
-
-        describe("set drafts", () => {
-            it("supports iteration", () => {
-                const base = new Set([{id: 1, a: 1}, {id: 2, a: 1}])
-                const findById = (set, id) => {
-                    for (const item of set) {
-                        if (item.id === id) return item
+                it("supports nested maps", () => {
+                    const base = new Map([
+                        ["first", new Map([["second", {prop: "test"}]])]
+                    ])
+                    const result = produce(base, draft => {
+                        draft.get("first").get("second").prop = "test1"
+                    })
+                    expect(result).not.toBe(base)
+                    expect(result.get("first")).not.toBe(base.get("first"))
+                    expect(result.get("first").get("second")).not.toBe(
+                        base.get("first").get("second")
+                    )
+                    expect(base.get("first").get("second").prop).toBe("test")
+                    expect(result.get("first").get("second").prop).toBe("test1")
+                })
+            })
+
+            describe("set drafts", () => {
+                it("supports iteration", () => {
+                    const base = new Set([{id: 1, a: 1}, {id: 2, a: 1}])
+                    const findById = (set, id) => {
+                        for (const item of set) {
+                            if (item.id === id) return item
+                        }
+                        return null
                     }
-                    return null
-                }
-                const result = produce(base, draft => {
-                    const obj1 = findById(draft, 1)
-                    const obj2 = findById(draft, 2)
-                    obj1.a = 2
-                    obj2.a = 2
-                })
-                expect(result).not.toBe(base)
-                expect(base).toEqual(new Set([{id: 1, a: 1}, {id: 2, a: 1}]))
-                expect(result).toEqual(new Set([{id: 1, a: 2}, {id: 2, a: 2}]))
-            })
-
-            it("supports 'entries'", () => {
-                const base = new Set([{id: 1, a: 1}, {id: 2, a: 1}])
-                const findById = (set, id) => {
-                    for (const [item1, item2] of set.entries()) {
-                        expect(item1).toBe(item2)
-                        if (item1.id === id) return item1
+                    const result = produce(base, draft => {
+                        const obj1 = findById(draft, 1)
+                        const obj2 = findById(draft, 2)
+                        obj1.a = 2
+                        obj2.a = 2
+                    })
+                    expect(result).not.toBe(base)
+                    expect(base).toEqual(
+                        new Set([{id: 1, a: 1}, {id: 2, a: 1}])
+                    )
+                    expect(result).toEqual(
+                        new Set([{id: 1, a: 2}, {id: 2, a: 2}])
+                    )
+                })
+
+                it("supports 'entries'", () => {
+                    const base = new Set([{id: 1, a: 1}, {id: 2, a: 1}])
+                    const findById = (set, id) => {
+                        for (const [item1, item2] of set.entries()) {
+                            expect(item1).toBe(item2)
+                            if (item1.id === id) return item1
+                        }
+                        return null
                     }
-                    return null
-                }
-                const result = produce(base, draft => {
-                    const obj1 = findById(draft, 1)
-                    const obj2 = findById(draft, 2)
-                    obj1.a = 2
-                    obj2.a = 2
-                })
-                expect(result).not.toBe(base)
-                expect(base).toEqual(new Set([{id: 1, a: 1}, {id: 2, a: 1}]))
-                expect(result).toEqual(new Set([{id: 1, a: 2}, {id: 2, a: 2}]))
-            })
-
-            it("supports 'values'", () => {
-                const base = new Set([{id: 1, a: 1}, {id: 2, a: 1}])
-                const findById = (set, id) => {
-                    for (const item of set.values()) {
-                        if (item.id === id) return item
+                    const result = produce(base, draft => {
+                        const obj1 = findById(draft, 1)
+                        const obj2 = findById(draft, 2)
+                        obj1.a = 2
+                        obj2.a = 2
+                    })
+                    expect(result).not.toBe(base)
+                    expect(base).toEqual(
+                        new Set([{id: 1, a: 1}, {id: 2, a: 1}])
+                    )
+                    expect(result).toEqual(
+                        new Set([{id: 1, a: 2}, {id: 2, a: 2}])
+                    )
+                })
+
+                it("supports 'values'", () => {
+                    const base = new Set([{id: 1, a: 1}, {id: 2, a: 1}])
+                    const findById = (set, id) => {
+                        for (const item of set.values()) {
+                            if (item.id === id) return item
+                        }
+                        return null
                     }
-                    return null
-                }
-                const result = produce(base, draft => {
-                    const obj1 = findById(draft, 1)
-                    const obj2 = findById(draft, 2)
-                    obj1.a = 2
-                    obj2.a = 2
-                })
-                expect(result).not.toBe(base)
-                expect(base).toEqual(new Set([{id: 1, a: 1}, {id: 2, a: 1}]))
-                expect(result).toEqual(new Set([{id: 1, a: 2}, {id: 2, a: 2}]))
-            })
-
-            it("supports 'keys'", () => {
-                const base = new Set([{id: 1, a: 1}, {id: 2, a: 1}])
-                const findById = (set, id) => {
-                    for (const item of set.keys()) {
-                        if (item.id === id) return item
+                    const result = produce(base, draft => {
+                        const obj1 = findById(draft, 1)
+                        const obj2 = findById(draft, 2)
+                        obj1.a = 2
+                        obj2.a = 2
+                    })
+                    expect(result).not.toBe(base)
+                    expect(base).toEqual(
+                        new Set([{id: 1, a: 1}, {id: 2, a: 1}])
+                    )
+                    expect(result).toEqual(
+                        new Set([{id: 1, a: 2}, {id: 2, a: 2}])
+                    )
+                })
+
+                it("supports 'keys'", () => {
+                    const base = new Set([{id: 1, a: 1}, {id: 2, a: 1}])
+                    const findById = (set, id) => {
+                        for (const item of set.keys()) {
+                            if (item.id === id) return item
+                        }
+                        return null
                     }
-                    return null
-                }
-                const result = produce(base, draft => {
-                    const obj1 = findById(draft, 1)
-                    const obj2 = findById(draft, 2)
-                    obj1.a = 2
-                    obj2.a = 2
-                })
-                expect(result).not.toBe(base)
-                expect(base).toEqual(new Set([{id: 1, a: 1}, {id: 2, a: 1}]))
-                expect(result).toEqual(new Set([{id: 1, a: 2}, {id: 2, a: 2}]))
-            })
-
-            it("supports forEach with mutation after reads", () => {
-                const base = new Set([{id: 1, a: 1}, {id: 2, a: 2}])
-                const result = produce(base, draft => {
-                    let sum1 = 0
-                    draft.forEach(({a}) => {
-                        sum1 += a
+                    const result = produce(base, draft => {
+                        const obj1 = findById(draft, 1)
+                        const obj2 = findById(draft, 2)
+                        obj1.a = 2
+                        obj2.a = 2
                     })
-                    expect(sum1).toBe(3)
-                    let sum2 = 0
-                    draft.forEach(item => {
-                        item.a += 10
-                        sum2 += item.a
+                    expect(result).not.toBe(base)
+                    expect(base).toEqual(
+                        new Set([{id: 1, a: 1}, {id: 2, a: 1}])
+                    )
+                    expect(result).toEqual(
+                        new Set([{id: 1, a: 2}, {id: 2, a: 2}])
+                    )
+                })
+
+                it("supports forEach with mutation after reads", () => {
+                    const base = new Set([{id: 1, a: 1}, {id: 2, a: 2}])
+                    const result = produce(base, draft => {
+                        let sum1 = 0
+                        draft.forEach(({a}) => {
+                            sum1 += a
+                        })
+                        expect(sum1).toBe(3)
+                        let sum2 = 0
+                        draft.forEach(item => {
+                            item.a += 10
+                            sum2 += item.a
+                        })
+                        expect(sum2).toBe(23)
                     })
-                    expect(sum2).toBe(23)
-                })
-                expect(result).not.toBe(base)
-                expect(base).toEqual(new Set([{id: 1, a: 1}, {id: 2, a: 2}]))
-                expect(result).toEqual(
-                    new Set([{id: 1, a: 11}, {id: 2, a: 12}])
-                )
-            })
-
-            it("state stays the same if the same item is added", () => {
-                const nextState = produce(baseState, s => {
-                    s.aSet.add("Luke")
+                    expect(result).not.toBe(base)
+                    expect(base).toEqual(
+                        new Set([{id: 1, a: 1}, {id: 2, a: 2}])
+                    )
+                    expect(result).toEqual(
+                        new Set([{id: 1, a: 11}, {id: 2, a: 12}])
+                    )
+                })
+
+                it("state stays the same if the same item is added", () => {
+                    const nextState = produce(baseState, s => {
+                        s.aSet.add("Luke")
+                    })
+                    expect(nextState).toBe(baseState)
+                    expect(nextState.aSet).toBe(baseState.aSet)
                 })
-                expect(nextState).toBe(baseState)
-                expect(nextState.aSet).toBe(baseState.aSet)
-            })
 
-            it("can add new items", () => {
-                const nextState = produce(baseState, s => {
-                    // Set.prototype.set should return the Set itself
-                    const res = s.aSet.add("force")
-                    expect(res).toBe(s.aSet[DRAFT_STATE].draft)
+                it("can add new items", () => {
+                    const nextState = produce(baseState, s => {
+                        // Set.prototype.set should return the Set itself
+                        const res = s.aSet.add("force")
+                        expect(res).toBe(s.aSet[DRAFT_STATE].draft)
+                    })
+                    expect(nextState).not.toBe(baseState)
+                    expect(nextState.aSet).not.toBe(baseState.aSet)
+                    expect(baseState.aSet.has("force")).toBe(false)
+                    expect(nextState.aSet.has("force")).toBe(true)
                 })
-                expect(nextState).not.toBe(baseState)
-                expect(nextState.aSet).not.toBe(baseState.aSet)
-                expect(baseState.aSet.has("force")).toBe(false)
-                expect(nextState.aSet.has("force")).toBe(true)
-            })
 
-            it("returns 'size'", () => {
-                const nextState = produce(baseState, s => {
-                    s.aSet.add("newKey")
-                    expect(s.aSet.size).toBe(baseState.aSet.size + 1)
+                it("returns 'size'", () => {
+                    const nextState = produce(baseState, s => {
+                        s.aSet.add("newKey")
+                        expect(s.aSet.size).toBe(baseState.aSet.size + 1)
+                    })
+                    expect(nextState).not.toBe(baseState)
+                    expect(nextState.aSet).not.toBe(baseState.aSet)
+                    expect(nextState.aSet.has("newKey")).toBe(true)
+                    expect(nextState.aSet.size).toEqual(baseState.aSet.size + 1)
                 })
-                expect(nextState).not.toBe(baseState)
-                expect(nextState.aSet).not.toBe(baseState.aSet)
-                expect(nextState.aSet.has("newKey")).toBe(true)
-                expect(nextState.aSet.size).toEqual(baseState.aSet.size + 1)
-            })
 
-            it("can use 'delete' to remove items", () => {
-                const nextState = produce(baseState, s => {
-                    expect(s.aSet.has("Luke")).toBe(true)
-                    s.aSet.delete("Luke")
-                    expect(s.aSet.has("Luke")).toBe(false)
+                it("can use 'delete' to remove items", () => {
+                    const nextState = produce(baseState, s => {
+                        expect(s.aSet.has("Luke")).toBe(true)
+                        s.aSet.delete("Luke")
+                        expect(s.aSet.has("Luke")).toBe(false)
+                    })
+                    expect(nextState.aSet).not.toBe(baseState.aSet)
+                    expect(nextState.aSet.size).toBe(baseState.aSet.size - 1)
+                    expect(baseState.aSet.has("Luke")).toBe(true)
+                    expect(nextState.aSet.has("Luke")).toBe(false)
                 })
-                expect(nextState.aSet).not.toBe(baseState.aSet)
-                expect(nextState.aSet.size).toBe(baseState.aSet.size - 1)
-                expect(baseState.aSet.has("Luke")).toBe(true)
-                expect(nextState.aSet.has("Luke")).toBe(false)
-            })
 
-            it("can use 'clear' to remove items", () => {
-                const nextState = produce(baseState, s => {
-                    expect(s.aSet.size).not.toBe(0)
-                    s.aSet.clear()
-                    expect(s.aSet.size).toBe(0)
+                it("can use 'clear' to remove items", () => {
+                    const nextState = produce(baseState, s => {
+                        expect(s.aSet.size).not.toBe(0)
+                        s.aSet.clear()
+                        expect(s.aSet.size).toBe(0)
+                    })
+                    expect(nextState.aSet).not.toBe(baseState.aSet)
+                    expect(baseState.aSet.size).not.toBe(0)
+                    expect(nextState.aSet.size).toBe(0)
                 })
-                expect(nextState.aSet).not.toBe(baseState.aSet)
-                expect(baseState.aSet.size).not.toBe(0)
-                expect(nextState.aSet.size).toBe(0)
-            })
 
-            it("supports 'has'", () => {
-                const nextState = produce(baseState, s => {
-                    expect(s.aSet.has("newKey")).toBe(false)
-                    s.aSet.add("newKey")
-                    expect(s.aSet.has("newKey")).toBe(true)
+                it("supports 'has'", () => {
+                    const nextState = produce(baseState, s => {
+                        expect(s.aSet.has("newKey")).toBe(false)
+                        s.aSet.add("newKey")
+                        expect(s.aSet.has("newKey")).toBe(true)
+                    })
+                    expect(nextState).not.toBe(baseState)
+                    expect(nextState.aSet).not.toBe(baseState.aSet)
+                    expect(baseState.aSet.has("newKey")).toBe(false)
+                    expect(nextState.aSet.has("newKey")).toBe(true)
                 })
-                expect(nextState).not.toBe(baseState)
-                expect(nextState.aSet).not.toBe(baseState.aSet)
-                expect(baseState.aSet.has("newKey")).toBe(false)
-                expect(nextState.aSet.has("newKey")).toBe(true)
-            })
 
-            it("supports nested sets", () => {
-                const base = new Set([new Set(["Serenity"])])
-                const result = produce(base, draft => {
-                    draft.forEach(nestedItem => nestedItem.add("Firefly"))
+                it("supports nested sets", () => {
+                    const base = new Set([new Set(["Serenity"])])
+                    const result = produce(base, draft => {
+                        draft.forEach(nestedItem => nestedItem.add("Firefly"))
+                    })
+                    expect(result).not.toBe(base)
+                    expect(base).toEqual(new Set([new Set(["Serenity"])]))
+                    expect(result).toEqual(
+                        new Set([new Set(["Serenity", "Firefly"])])
+                    )
                 })
-                expect(result).not.toBe(base)
-                expect(base).toEqual(new Set([new Set(["Serenity"])]))
-                expect(result).toEqual(
-                    new Set([new Set(["Serenity", "Firefly"])])
-                )
             })
-        })
+        }
 
         it("supports `immerable` symbol on constructor", () => {
             class One {}
diff --git a/__tests__/hooks.js b/__tests__/hooks.js
index 88b10f0..454630c 100644
--- a/__tests__/hooks.js
+++ b/__tests__/hooks.js
@@ -120,86 +120,91 @@ function createHookTests(useProxies) {
             })
         })
 
-        describe("when draft is a Map", () => {
-            test("assign", () => {
-                const key1 = {prop: "val1"}
-                const key2 = {prop: "val2"}
-                produce(new Map([["a", 0], [key1, 1], [key2, 2]]), s => {
-                    s.set("a", 10)
-                    s.set(key1, 11)
+        if (useProxies) {
+            describe("when draft is a Map", () => {
+                test("assign", () => {
+                    const key1 = {prop: "val1"}
+                    const key2 = {prop: "val2"}
+                    produce(new Map([["a", 0], [key1, 1], [key2, 2]]), s => {
+                        s.set("a", 10)
+                        s.set(key1, 11)
+                    })
+                    expectCalls(onAssign)
                 })
-                expectCalls(onAssign)
-            })
-            test("assign (no change)", () => {
-                produce(new Map([["a", 0]]), s => {
-                    s.set("a", 0)
+                test("assign (no change)", () => {
+                    produce(new Map([["a", 0]]), s => {
+                        s.set("a", 0)
+                    })
+                    expect(onAssign).not.toBeCalled()
                 })
-                expect(onAssign).not.toBeCalled()
-            })
-            test("delete", () => {
-                produce(new Map([["a", 0]]), s => {
-                    s.delete("a")
+                test("delete", () => {
+                    produce(new Map([["a", 0]]), s => {
+                        s.delete("a")
+                    })
+                    expect(onAssign).not.toBeCalled()
+                })
+                test("nested assignments", () => {
+                    const key1 = {prop: "val1"}
+                    produce(
+                        new Map([
+                            [
+                                "a",
+                                new Map([
+                                    [
+                                        key1,
+                                        new Map([["b", 1], ["c", 1], ["d", 1]])
+                                    ]
+                                ])
+                            ]
+                        ]),
+                        s => {
+                            const nested = s.get("a").get(key1)
+                            nested.set("b", 2)
+                            nested.delete("c")
+                            nested.set("d", 1) // no-op
+                        }
+                    )
+                    expectCalls(onAssign)
                 })
-                expect(onAssign).not.toBeCalled()
-            })
-            test("nested assignments", () => {
-                const key1 = {prop: "val1"}
-                produce(
-                    new Map([
-                        [
-                            "a",
-                            new Map([
-                                [key1, new Map([["b", 1], ["c", 1], ["d", 1]])]
-                            ])
-                        ]
-                    ]),
-                    s => {
-                        const nested = s.get("a").get(key1)
-                        nested.set("b", 2)
-                        nested.delete("c")
-                        nested.set("d", 1) // no-op
-                    }
-                )
-                expectCalls(onAssign)
             })
-        })
 
-        describe("when draft is a Set", () => {
-            test("assign", () => {
-                produce({a: new Set([1, 2, 3])}, s => {
-                    s.a.add(4)
+            describe("when draft is a Set", () => {
+                test("assign", () => {
+                    produce({a: new Set([1, 2, 3])}, s => {
+                        s.a.add(4)
+                    })
+                    expectCalls(onAssign)
                 })
-                expectCalls(onAssign)
-            })
-            test("assign (no change)", () => {
-                produce({a: new Set([1, 2, 3])}, s => {
-                    s.a.add(3)
+                test("assign (no change)", () => {
+                    produce({a: new Set([1, 2, 3])}, s => {
+                        s.a.add(3)
+                    })
+                    expect(onAssign).not.toBeCalled()
                 })
-                expect(onAssign).not.toBeCalled()
-            })
-            // Any mutation of a Set results in a new assignment. Including deletes.
-            test("delete", () => {
-                produce({a: new Set([1, 2, 3])}, s => {
-                    s.a.delete(1)
+                // Any mutation of a Set results in a new assignment. Including deletes.
+                test("delete", () => {
+                    produce({a: new Set([1, 2, 3])}, s => {
+                        s.a.delete(1)
+                    })
+                    expectCalls(onAssign)
                 })
-                expectCalls(onAssign)
-            })
-            test("nested assignments", () => {
-                const val1 = {prop: "val1"}
-                produce({a: new Set(["a", new Set([val1, 1])])}, s => {
-                    let nested
-                    s.a.forEach(value => {
-                        if (isSet(value)) {
-                            nested = value
-                        }
+                test("nested assignments", () => {
+                    const val1 = {prop: "val1"}
+                    produce({a: new Set(["a", new Set([val1, 1])])}, s => {
+                        let nested
+                        s.a.forEach(value => {
+                            if (isSet(value)) {
+                                nested = value
+                            }
+                        })
+                        nested.add(2)
+                        nested.delete(val1)
+                        nested.add(1) // no-op
                     })
-                    nested.add(2)
-                    nested.delete(val1)
-                    nested.add(1) // no-op
+                    expectCalls(onAssign)
                 })
-                expectCalls(onAssign)
             })
-        })
+        }
     })
 
     describe("onDelete()", () => {
@@ -246,44 +251,48 @@ function createHookTests(useProxies) {
             })
         })
 
-        describe("when draft is a Map -", () => {
-            test("delete", () => {
-                const key1 = {prop: "val1"}
-                const key2 = {prop: "val2"}
-                produce(new Map([["a", 0], [key1, 1], [key2, 2]]), s => {
-                    s.delete("a")
-                    s.delete(key1)
+        if (useProxies) {
+            describe("when draft is a Map -", () => {
+                test("delete", () => {
+                    const key1 = {prop: "val1"}
+                    const key2 = {prop: "val2"}
+                    produce(new Map([["a", 0], [key1, 1], [key2, 2]]), s => {
+                        s.delete("a")
+                        s.delete(key1)
+                    })
+                    expectCalls(onDelete)
                 })
-                expectCalls(onDelete)
-            })
-            test("delete (no change)", () => {
-                produce(new Map(), s => {
-                    s.delete("a")
+                test("delete (no change)", () => {
+                    produce(new Map(), s => {
+                        s.delete("a")
+                    })
+                    expect(onDelete).not.toBeCalled()
+                })
+                test("nested deletions", () => {
+                    const key1 = {prop: "val1"}
+                    produce(
+                        new Map([
+                            ["a", new Map([[key1, new Map([["b", 1]])]])]
+                        ]),
+                        s => {
+                            s.get("a")
+                                .get(key1)
+                                .delete("b")
+                        }
+                    )
+                    expectCalls(onDelete)
                 })
-                expect(onDelete).not.toBeCalled()
-            })
-            test("nested deletions", () => {
-                const key1 = {prop: "val1"}
-                produce(
-                    new Map([["a", new Map([[key1, new Map([["b", 1]])]])]]),
-                    s => {
-                        s.get("a")
-                            .get(key1)
-                            .delete("b")
-                    }
-                )
-                expectCalls(onDelete)
             })
-        })
 
-        describe("when draft is a Set -", () => {
-            test("delete", () => {
-                produce({a: new Set([1])}, s => {
-                    s.a.delete(1)
+            describe("when draft is a Set -", () => {
+                test("delete", () => {
+                    produce({a: new Set([1])}, s => {
+                        s.a.delete(1)
+                    })
+                    expect(onDelete).not.toBeCalled()
                 })
-                expect(onDelete).not.toBeCalled()
             })
-        })
+        }
     })
 
     describe("onCopy()", () => {
@@ -304,22 +313,24 @@ function createHookTests(useProxies) {
             expect(calls).toShallowEqual([base.a.b, base.a, base])
         })
 
-        it("is called in the right order for Maps", () => {
-            const base = new Map([["a", new Map([["b", 0]])]])
-            produce(base, s => {
-                s.get("a").delete("b")
+        if (useProxies) {
+            it("is called in the right order for Maps", () => {
+                const base = new Map([["a", new Map([["b", 0]])]])
+                produce(base, s => {
+                    s.get("a").delete("b")
+                })
+                expect(calls).toShallowEqual([base.get("a"), base])
             })
-            expect(calls).toShallowEqual([base.get("a"), base])
-        })
 
-        it("is called in the right order for Sets", () => {
-            const item1 = {a: 0}
-            const base = new Set([item1])
-            produce(base, s => {
-                s.forEach(item => item.a++)
+            it("is called in the right order for Sets", () => {
+                const item1 = {a: 0}
+                const base = new Set([item1])
+                produce(base, s => {
+                    s.forEach(item => item.a++)
+                })
+                expect(calls).toShallowEqual([item1, base])
             })
-            expect(calls).toShallowEqual([item1, base])
-        })
+        }
     })
 
     function useSharedTests(getHook) {
diff --git a/__tests__/patch.js b/__tests__/patch.js
index bc9a1ff..587b9ec 100644
--- a/__tests__/patch.js
+++ b/__tests__/patch.js
@@ -3,7 +3,13 @@ import produce, {setUseProxies, applyPatches} from "../src/index"
 
 jest.setTimeout(1000)
 
-function runPatchTest(base, producer, patches, inversePathes) {
+function runPatchTest(
+    base,
+    producer,
+    patches,
+    inversePathes,
+    proxyOnly = false
+) {
     function runPatchTestHelper() {
         let recordedPatches
         let recordedInversePatches
@@ -29,13 +35,15 @@ function runPatchTest(base, producer, patches, inversePathes) {
     }
 
     describe(`proxy`, () => {
-        setUseProxies(true)
+        beforeAll(() => setUseProxies(true))
         runPatchTestHelper()
     })
 
     describe(`es5`, () => {
-        setUseProxies(false)
-        runPatchTestHelper()
+        if (!proxyOnly) {
+            beforeAll(() => setUseProxies(false))
+            runPatchTestHelper()
+        }
     })
 }
 
@@ -116,7 +124,8 @@ describe("simple assignment - 4", () => {
             d.get("x").y++
         },
         [{op: "replace", path: ["x", "y"], value: 5}],
-        [{op: "replace", path: ["x", "y"], value: 4}]
+        [{op: "replace", path: ["x", "y"], value: 4}],
+        true
     )
 })
 
@@ -127,7 +136,8 @@ describe("simple assignment - 5", () => {
             d.x.set("y", 5)
         },
         [{op: "replace", path: ["x", "y"], value: 5}],
-        [{op: "replace", path: ["x", "y"], value: 4}]
+        [{op: "replace", path: ["x", "y"], value: 4}],
+        true
     )
 })
 
@@ -143,7 +153,8 @@ describe("simple assignment - 6", () => {
             {op: "replace", path: ["x"], value: 2},
             {op: "add", path: ["y"], value: 3}
         ],
-        [{op: "replace", path: ["x"], value: 1}, {op: "remove", path: ["y"]}]
+        [{op: "replace", path: ["x"], value: 1}, {op: "remove", path: ["y"]}],
+        true
     )
 })
 
@@ -163,7 +174,8 @@ describe("simple assignment - 7", () => {
         [
             {op: "replace", path: ["x", key1], value: 4},
             {op: "remove", path: ["x", key2]}
-        ]
+        ],
+        true
     )
 })
 
@@ -184,7 +196,8 @@ describe("delete 2", () => {
             d.delete("x")
         },
         [{op: "remove", path: ["x"]}],
-        [{op: "add", path: ["x"], value: 1}]
+        [{op: "add", path: ["x"], value: 1}],
+        true
     )
 })
 
@@ -195,7 +208,8 @@ describe("delete 3", () => {
             d.x.delete("y")
         },
         [{op: "remove", path: ["x", "y"]}],
-        [{op: "add", path: ["x", "y"], value: 1}]
+        [{op: "add", path: ["x", "y"], value: 1}],
+        true
     )
 })
 
@@ -212,7 +226,8 @@ describe("delete 5", () => {
         [
             {op: "add", path: ["x", key1], value: 1},
             {op: "add", path: ["x", key2], value: 2}
-        ]
+        ],
+        true
     )
 })
 
@@ -223,7 +238,8 @@ describe("delete 6", () => {
             d.delete("x")
         },
         [{op: "remove", path: [0], value: "x"}],
-        [{op: "add", path: [0], value: "x"}]
+        [{op: "add", path: [0], value: "x"}],
+        true
     )
 })
 
@@ -234,7 +250,8 @@ describe("delete 7", () => {
             d.x.delete("y")
         },
         [{op: "remove", path: ["x", 0], value: "y"}],
-        [{op: "add", path: ["x", 0], value: "y"}]
+        [{op: "add", path: ["x", 0], value: "y"}],
+        true
     )
 })
 
@@ -267,7 +284,8 @@ describe("renaming properties", () => {
             [
                 {op: "remove", path: ["x"]},
                 {op: "add", path: ["a"], value: new Map([["b", 1]])}
-            ]
+            ],
+            true
         )
     })
 
@@ -311,7 +329,8 @@ describe("renaming properties", () => {
             [
                 {op: "remove", path: ["x"]},
                 {op: "add", path: ["a"], value: new Map([["b", 1], ["c", 1]])}
-            ]
+            ],
+            true
         )
     })
 
@@ -363,7 +382,8 @@ describe("renaming properties", () => {
                     path: ["a", "b"],
                     value: new Map([["c", 1], ["d", 1]])
                 }
-            ]
+            ],
+            true
         )
     })
 })
@@ -559,7 +579,8 @@ describe("sets - add - 1", () => {
             d.add(2)
         },
         [{op: "add", path: [1], value: 2}],
-        [{op: "remove", path: [1], value: 2}]
+        [{op: "remove", path: [1], value: 2}],
+        true
     )
 })
 
@@ -572,7 +593,8 @@ describe("sets - add, delete, add - 1", () => {
             d.add(2)
         },
         [{op: "add", path: [1], value: 2}],
-        [{op: "remove", path: [1], value: 2}]
+        [{op: "remove", path: [1], value: 2}],
+        true
     )
 })
 
@@ -585,7 +607,8 @@ describe("sets - add, delete, add - 2", () => {
             d.add(2)
         },
         [],
-        []
+        [],
+        true
     )
 })
 
@@ -614,7 +637,8 @@ describe("sets - mutate - 1", () => {
             {op: "remove", path: [0], value: {id: 1, val: "rock"}},
             {op: "add", path: [1], value: {id: 2, val: "will"}},
             {op: "add", path: [0], value: {id: 1, val: "We"}}
-        ]
+        ],
+        true
     )
 })
 
@@ -674,7 +698,8 @@ describe("same value replacement - 5", () => {
             d.set("x", 3)
         },
         [],
-        []
+        [],
+        true
     )
 })
 
@@ -686,7 +711,8 @@ describe("same value replacement - 6", () => {
             d.add("x")
         },
         [],
-        []
+        [],
+        true
     )
 })
 
diff --git a/src/common.js b/src/common.js
index 16dce51..4919b46 100644
--- a/src/common.js
+++ b/src/common.js
@@ -131,78 +131,10 @@ export function is(x, y) {
     }
 }
 
-const hasMap = typeof Map !== "undefined"
-
 export function isMap(target) {
-    return hasMap && target instanceof Map
+    return target instanceof Map
 }
 
-const hasSet = typeof Set !== "undefined"
-
 export function isSet(target) {
-    return hasSet && target instanceof Set
-}
-
-export function makeIterable(next) {
-    let self
-    return (self = {
-        [Symbol.iterator]: () => self,
-        next
-    })
-}
-
-/** Map.prototype.values _-or-_ Map.prototype.entries */
-export function iterateMapValues(state, prop, receiver) {
-    const isEntries = prop !== "values"
-    return () => {
-        const iterator = latest(state)[Symbol.iterator]()
-        return makeIterable(() => {
-            const result = iterator.next()
-            if (!result.done) {
-                const [key] = result.value
-                const value = receiver.get(key)
-                result.value = isEntries ? [key, value] : value
-            }
-            return result
-        })
-    }
-}
-
-export function makeIterateSetValues(createProxy) {
-    function iterateSetValues(state, prop) {
-        const isEntries = prop === "entries"
-        return () => {
-            const iterator = latest(state)[Symbol.iterator]()
-            return makeIterable(() => {
-                const result = iterator.next()
-                if (!result.done) {
-                    const value = wrapSetValue(state, result.value)
-                    result.value = isEntries ? [value, value] : value
-                }
-                return result
-            })
-        }
-    }
-
-    function wrapSetValue(state, value) {
-        const key = original(value) || value
-        let draft = state.drafts.get(key)
-        if (!draft) {
-            if (state.finalized || !isDraftable(value) || state.finalizing) {
-                return value
-            }
-            draft = createProxy(value, state)
-            state.drafts.set(key, draft)
-            if (state.modified) {
-                state.copy.add(draft)
-            }
-        }
-        return draft
-    }
-
-    return iterateSetValues
-}
-
-function latest(state) {
-    return state.copy || state.base
+    return target instanceof Set
 }
diff --git a/src/es5.js b/src/es5.js
index 7bb02a9..fab25f2 100644
--- a/src/es5.js
+++ b/src/es5.js
@@ -6,16 +6,15 @@ import {
     isDraft,
     isDraftable,
     isEnumerable,
-    isMap,
-    isSet,
     shallowCopy,
-    DRAFT_STATE,
-    iterateMapValues,
-    makeIterable,
-    makeIterateSetValues
+    DRAFT_STATE
 } from "./common"
 import {ImmerScope} from "./scope"
 
+// property descriptors are recycled to make sure we don't create a get and set closure per property,
+// but share them all instead
+const descriptors = {}
+
 export function willFinalize(scope, result, isReplaced) {
     scope.drafts.forEach(draft => {
         draft[DRAFT_STATE].finalizing = true
@@ -36,16 +35,9 @@ export function willFinalize(scope, result, isReplaced) {
 export function createProxy(base, parent) {
     const isArray = Array.isArray(base)
     const draft = clonePotentialDraft(base)
-
-    if (isMap(base)) {
-        proxyMap(draft)
-    } else if (isSet(base)) {
-        proxySet(draft)
-    } else {
-        each(draft, prop => {
-            proxyProperty(draft, prop, isArray || isEnumerable(base, prop))
-        })
-    }
+    each(draft, prop => {
+        proxyProperty(draft, prop, isArray || isEnumerable(base, prop))
+    })
 
     // See "proxy.js" for property documentation.
     const scope = parent ? parent.scope : ImmerScope.current
@@ -54,11 +46,10 @@ export function createProxy(base, parent) {
         modified: false,
         finalizing: false, // es5 only
         finalized: false,
-        assigned: isMap(base) ? new Map() : {},
+        assigned: {},
         parent,
         base,
         draft,
-        drafts: isSet(base) ? new Map() : null,
         copy: null,
         revoke,
         revoked: false // es5 only
@@ -134,10 +125,6 @@ function clonePotentialDraft(base) {
     return shallowCopy(base)
 }
 
-// property descriptors are recycled to make sure we don't create a get and set closure per property,
-// but share them all instead
-const descriptors = {}
-
 function proxyProperty(draft, prop, enumerable) {
     let desc = descriptors[prop]
     if (desc) {
@@ -157,161 +144,6 @@ function proxyProperty(draft, prop, enumerable) {
     Object.defineProperty(draft, prop, desc)
 }
 
-function proxyMap(target) {
-    Object.defineProperties(target, mapTraps)
-
-    if (typeof Symbol !== undefined) {
-        Object.defineProperty(
-            target,
-            Symbol.iterator,
-            proxyMethod(iterateMapValues)
-        )
-    }
-}
-
-const mapTraps = finalizeTraps({
-    size: state => latest(state).size,
-    has: state => key => latest(state).has(key),
-    set: state => (key, value) => {
-        if (latest(state).get(key) !== value) {
-            prepareCopy(state)
-            markChanged(state)
-            state.assigned.set(key, true)
-            state.copy.set(key, value)
-        }
-        return state.draft
-    },
-    delete: state => key => {
-        prepareCopy(state)
-        markChanged(state)
-        state.assigned.set(key, false)
-        state.copy.delete(key)
-        return false
-    },
-    clear: state => () => {
-        if (!state.copy) {
-            prepareCopy(state)
-        }
-        markChanged(state)
-        state.assigned = new Map()
-        for (const key of latest(state).keys()) {
-            state.assigned.set(key, false)
-        }
-        return state.copy.clear()
-    },
-    forEach: (state, key, reciever) => cb => {
-        latest(state).forEach((value, key, map) => {
-            cb(reciever.get(key), key, map)
-        })
-    },
-    get: state => key => {
-        const value = latest(state).get(key)
-
-        if (state.finalizing || state.finalized || !isDraftable(value)) {
-            return value
-        }
-
-        if (value !== state.base.get(key)) {
-            return value
-        }
-        const draft = createProxy(value, state)
-        prepareCopy(state)
-        state.copy.set(key, draft)
-        return draft
-    },
-    keys: state => () => latest(state).keys(),
-    values: iterateMapValues,
-    entries: iterateMapValues
-})
-
-function proxySet(target) {
-    Object.defineProperties(target, setTraps)
-
-    if (typeof Symbol !== undefined) {
-        Object.defineProperty(
-            target,
-            Symbol.iterator,
-            proxyMethod(iterateSetValues)
-        )
-    }
-}
-
-const iterateSetValues = makeIterateSetValues(createProxy)
-
-const setTraps = finalizeTraps({
-    size: state => {
-        return latest(state).size
-    },
-    add: state => value => {
-        if (!latest(state).has(value)) {
-            markChanged(state)
-            if (!state.copy) {
-                prepareCopy(state)
-            }
-            state.copy.add(value)
-        }
-        return state.draft
-    },
-    delete: state => value => {
-        markChanged(state)
-        if (!state.copy) {
-            prepareCopy(state)
-        }
-        return state.copy.delete(value)
-    },
-    has: state => key => {
-        return latest(state).has(key)
-    },
-    clear: state => () => {
-        markChanged(state)
-        if (!state.copy) {
-            prepareCopy(state)
-        }
-        return state.copy.clear()
-    },
-    keys: iterateSetValues,
-    entries: iterateSetValues,
-    values: iterateSetValues,
-    forEach: state => (cb, thisArg) => {
-        const iterator = iterateSetValues(state)()
-        let result = iterator.next()
-        while (!result.done) {
-            cb.call(thisArg, result.value, result.value, state.draft)
-            result = iterator.next()
-        }
-    }
-})
-
-function finalizeTraps(traps) {
-    return Object.keys(traps).reduce(function(acc, key) {
-        const builder = key === "size" ? proxyAttr : proxyMethod
-        acc[key] = builder(traps[key], key)
-        return acc
-    }, {})
-}
-
-function proxyAttr(fn) {
-    return {
-        get() {
-            const state = this[DRAFT_STATE]
-            assertUnrevoked(state)
-            return fn(state)
-        }
-    }
-}
-
-function proxyMethod(trap, key) {
-    return {
-        get() {
-            return (...args) => {
-                const state = this[DRAFT_STATE]
-                assertUnrevoked(state)
-                return trap(state, key, state.draft)(...args)
-            }
-        }
-    }
-}
-
 function assertUnrevoked(state) {
     if (state.revoked === true)
         throw new Error(
@@ -331,13 +163,7 @@ function markChangesSweep(drafts) {
         if (!state.modified) {
             if (Array.isArray(state.base)) {
                 if (hasArrayChanges(state)) markChanged(state)
-            } else if (isMap(state.base)) {
-                if (hasMapChanges(state)) markChanged(state)
-            } else if (isSet(state.base)) {
-                if (hasSetChanges(state)) markChanged(state)
-            } else if (hasObjectChanges(state)) {
-                markChanged(state)
-            }
+            } else if (hasObjectChanges(state)) markChanged(state)
         }
     }
 }
@@ -428,38 +254,6 @@ function hasArrayChanges(state) {
     return false
 }
 
-function hasMapChanges(state) {
-    const {base, draft} = state
-
-    if (base.size !== draft.size) return true
-
-    // IE11 supports only forEach iteration
-    let hasChanges = false
-    draft.forEach(function(value, key) {
-        if (!hasChanges) {
-            hasChanges = isDraftable(value)
-                ? value.modified
-                : value !== base.get(key)
-        }
-    })
-    return hasChanges
-}
-
-function hasSetChanges(state) {
-    const {base, draft} = state
-
-    if (base.size !== draft.size) return true
-
-    // IE11 supports only forEach iteration
-    let hasChanges = false
-    draft.forEach(function(value, key) {
-        if (!hasChanges) {
-            hasChanges = isDraftable(value) ? value.modified : !base.has(key)
-        }
-    })
-    return hasChanges
-}
-
 function createHiddenProperty(target, prop, value) {
     Object.defineProperty(target, prop, {
         value: value,
diff --git a/src/proxy.js b/src/proxy.js
index 67b4610..e1e312b 100644
--- a/src/proxy.js
+++ b/src/proxy.js
@@ -9,13 +9,10 @@ import {
     isMap,
     isSet,
     shallowCopy,
-    makeIterable,
     DRAFT_STATE,
     assignMap,
     assignSet,
-    original,
-    iterateMapValues,
-    makeIterateSetValues
+    original
 } from "./common"
 import {ImmerScope} from "./scope"
 
@@ -258,7 +255,23 @@ const mapTraps = makeTrapsForGetters({
     [Symbol.iterator]: iterateMapValues
 })
 
-const iterateSetValues = makeIterateSetValues(createProxy)
+/** Map.prototype.values _-or-_ Map.prototype.entries */
+function iterateMapValues(state, prop, receiver) {
+    const isEntries = prop !== "values"
+    return () => {
+        const iterator = latest(state)[Symbol.iterator]()
+        return makeIterable(() => {
+            const result = iterator.next()
+            if (!result.done) {
+                const [key] = result.value
+                const value = receiver.get(key)
+                result.value = isEntries ? [key, value] : value
+            }
+            return result
+        })
+    }
+}
+
 /**
  * Set drafts
  */
@@ -296,6 +309,37 @@ const setTraps = makeTrapsForGetters({
     [Symbol.iterator]: iterateSetValues
 })
 
+function iterateSetValues(state, prop) {
+    const isEntries = prop === "entries"
+    return () => {
+        const iterator = latest(state)[Symbol.iterator]()
+        return makeIterable(() => {
+            const result = iterator.next()
+            if (!result.done) {
+                const value = wrapSetValue(state, result.value)
+                result.value = isEntries ? [value, value] : value
+            }
+            return result
+        })
+    }
+}
+
+function wrapSetValue(state, value) {
+    const key = original(value) || value
+    let draft = state.drafts.get(key)
+    if (!draft) {
+        if (state.finalized || !isDraftable(value)) {
+            return value
+        }
+        draft = createProxy(value, state)
+        state.drafts.set(key, draft)
+        if (state.modified) {
+            state.copy.add(draft)
+        }
+    }
+    return draft
+}
+
 /**
  * Helpers
  */
@@ -340,6 +384,14 @@ function markChanged(state) {
     }
 }
 
+function makeIterable(next) {
+    let self
+    return (self = {
+        [Symbol.iterator]: () => self,
+        next
+    })
+}
+
 /** Create traps that all use the `Reflect` API on the `latest(state)` */
 function makeReflectTraps(names) {
     return names.reduce((traps, name) => {
