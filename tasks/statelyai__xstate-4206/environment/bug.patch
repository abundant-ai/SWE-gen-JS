diff --git a/.changeset/curvy-seahorses-obey.md b/.changeset/curvy-seahorses-obey.md
deleted file mode 100644
index cfa9d1510b..0000000000
--- a/.changeset/curvy-seahorses-obey.md
+++ /dev/null
@@ -1,5 +0,0 @@
----
-'xstate': patch
----
-
-Fixed type-related issue that prevented guards `not('checkFoo')` from being used in machines.
diff --git a/packages/core/src/StateNode.ts b/packages/core/src/StateNode.ts
index 7e3ff12717..29e8a74e70 100644
--- a/packages/core/src/StateNode.ts
+++ b/packages/core/src/StateNode.ts
@@ -374,16 +374,10 @@ export class StateNode<
           !guard ||
           evaluateGuard<TContext, TEvent>(guard, resolvedContext, event, state);
       } catch (err: any) {
-        const guardType =
-          typeof guard === 'string'
-            ? guard
-            : typeof guard === 'object'
-            ? guard.type
-            : undefined;
         throw new Error(
-          `Unable to evaluate guard ${
-            guardType ? `'${guardType}' ` : ''
-          }in transition for event '${eventType}' in state node '${
+          `Unable to evaluate guard '${
+            guard!.type
+          }' in transition for event '${eventType}' in state node '${
             this.id
           }':\n${err.message}`
         );
diff --git a/packages/core/src/actions/choose.ts b/packages/core/src/actions/choose.ts
index 04814be5cc..7697ca5fe2 100644
--- a/packages/core/src/actions/choose.ts
+++ b/packages/core/src/actions/choose.ts
@@ -8,7 +8,7 @@ import {
   ActionArgs,
   ParameterizedObject
 } from '../types.ts';
-import { evaluateGuard } from '../guards.ts';
+import { evaluateGuard, toGuardDefinition } from '../guards.ts';
 import { toArray } from '../utils.ts';
 
 function resolve(
@@ -22,9 +22,14 @@ function resolve(
   }
 ) {
   const matchedActions = branches.find((condition) => {
+    const guard =
+      condition.guard &&
+      toGuardDefinition(
+        condition.guard,
+        (guardType) => state.machine.implementations.guards[guardType]
+      );
     return (
-      !condition.guard ||
-      evaluateGuard(condition.guard, state.context, actionArgs.event, state)
+      !guard || evaluateGuard(guard, state.context, actionArgs.event, state)
     );
   })?.actions;
 
diff --git a/packages/core/src/guards.ts b/packages/core/src/guards.ts
index 250cdd1278..eb802dedeb 100644
--- a/packages/core/src/guards.ts
+++ b/packages/core/src/guards.ts
@@ -1,198 +1,172 @@
-import isDevelopment from '#is-development';
 import type {
   EventObject,
   StateValue,
+  BooleanGuardDefinition,
+  GuardConfig,
+  GuardDefinition,
+  GuardPredicate,
   MachineContext,
-  TODO,
-  ParameterizedObject,
-  AnyState
+  TODO
 } from './types.ts';
 import { isStateId } from './stateUtils.ts';
-import { State } from './State.ts';
-
-export type GuardPredicate<
-  TContext extends MachineContext,
-  TExpressionEvent extends EventObject
-> = (args: GuardArgs<TContext, TExpressionEvent>) => boolean;
-
-export interface GuardArgs<
-  TContext extends MachineContext,
-  TExpressionEvent extends EventObject
-> {
-  context: TContext;
-  event: TExpressionEvent;
-  guard: ParameterizedObject | undefined;
-}
-
-export type Guard<
-  TContext extends MachineContext,
-  TEvent extends EventObject
-> = string | ParameterizedObject | GuardPredicate<TContext, TEvent>;
-
-export type UnknownGuard = Guard<MachineContext, EventObject>;
-
-interface BuiltinGuard {
-  (): boolean;
-  check: (
-    state: AnyState,
-    guardArgs: GuardArgs<any, any>,
-    params: unknown
-  ) => boolean;
-}
-
-function checkStateIn(
-  state: AnyState,
-  _: GuardArgs<any, any>,
-  { stateValue }: { stateValue: StateValue }
-) {
-  if (typeof stateValue === 'string' && isStateId(stateValue)) {
-    return state.configuration.some((sn) => sn.id === stateValue.slice(1));
-  }
-
-  return state.matches(stateValue);
-}
+import type { State } from './State.ts';
 
 export function stateIn<
   TContext extends MachineContext,
   TEvent extends EventObject
->(stateValue: StateValue) {
-  function stateIn(_: GuardArgs<TContext, TEvent>) {
-    if (isDevelopment) {
-      throw new Error(`This isn't supposed to be called`);
+>(stateValue: StateValue): GuardDefinition<TContext, TEvent> {
+  return {
+    type: 'xstate.guard:in',
+    params: { stateValue },
+    predicate: ({ state }) => {
+      if (typeof stateValue === 'string' && isStateId(stateValue)) {
+        return state.configuration.some((sn) => sn.id === stateValue.slice(1));
+      }
+
+      return state.matches(stateValue);
     }
-    return false;
-  }
-
-  stateIn.check = checkStateIn;
-  stateIn.stateValue = stateValue;
-
-  return stateIn;
-}
-
-function checkNot(
-  state: AnyState,
-  { context, event }: GuardArgs<any, any>,
-  { guards }: { guards: readonly UnknownGuard[] }
-) {
-  return !evaluateGuard(guards[0], context, event, state);
+  };
 }
 
 export function not<
   TContext extends MachineContext,
   TEvent extends EventObject
->(guard: Guard<TContext, TEvent>) {
-  function not() {
-    if (isDevelopment) {
-      throw new Error(`This isn't supposed to be called`);
+>(
+  guard: GuardConfig<TContext, TEvent>
+): BooleanGuardDefinition<TContext, TEvent> {
+  return {
+    type: 'xstate.boolean',
+    params: { op: 'not' },
+    children: [toGuardDefinition(guard)],
+    predicate: ({ evaluate, guard, context, event, state }) => {
+      return !evaluate(guard.children![0], context, event, state);
     }
-    return false;
-  }
-
-  not.check = checkNot;
-  not.guards = [guard];
-
-  return not;
-}
-
-function checkAnd(
-  state: AnyState,
-  { context, event }: GuardArgs<any, any>,
-  { guards }: { guards: readonly UnknownGuard[] }
-) {
-  return guards.every((guard) => evaluateGuard(guard, context, event, state));
+  };
 }
 
 export function and<
   TContext extends MachineContext,
   TEvent extends EventObject
->(guards: ReadonlyArray<Guard<TContext, TEvent>>) {
-  function and() {
-    if (isDevelopment) {
-      throw new Error(`This isn't supposed to be called`);
+>(
+  guards: Array<GuardConfig<TContext, TEvent>>
+): BooleanGuardDefinition<TContext, TEvent> {
+  return {
+    type: 'xstate.boolean',
+    params: { op: 'and' },
+    children: guards.map((guard) => toGuardDefinition(guard)),
+    predicate: ({ evaluate, guard, context, event, state }) => {
+      return guard.children!.every((childGuard) => {
+        return evaluate(childGuard, context, event, state);
+      });
     }
-    return false;
-  }
-
-  and.check = checkAnd;
-  and.guards = guards;
-
-  return and;
-}
-
-function checkOr(
-  state: AnyState,
-  { context, event }: GuardArgs<any, any>,
-  { guards }: { guards: readonly UnknownGuard[] }
-) {
-  return guards.some((guard) => evaluateGuard(guard, context, event, state));
+  };
 }
 
 export function or<TContext extends MachineContext, TEvent extends EventObject>(
-  guards: ReadonlyArray<Guard<TContext, TEvent>>
-) {
-  function or() {
-    if (isDevelopment) {
-      throw new Error(`This isn't supposed to be called`);
+  guards: Array<GuardConfig<TContext, TEvent>>
+): BooleanGuardDefinition<TContext, TEvent> {
+  return {
+    type: 'xstate.boolean',
+    params: { op: 'or' },
+    children: guards.map((guard) => toGuardDefinition(guard)),
+    predicate: ({ evaluate, guard, context, event, state }) => {
+      return guard.children!.some((childGuard) => {
+        return evaluate(childGuard, context, event, state);
+      });
     }
-    return false;
-  }
-
-  or.check = checkOr;
-  or.guards = guards;
-
-  return or;
+  };
 }
 
-// TODO: throw on cycles (depth check should be enough)
 export function evaluateGuard<
   TContext extends MachineContext,
   TEvent extends EventObject
 >(
-  guard: UnknownGuard,
+  guard: GuardDefinition<TContext, TEvent>,
   context: TContext,
   event: TEvent,
   state: State<TContext, TEvent, TODO, TODO>
 ): boolean {
   const { machine } = state;
-  const isInline = typeof guard === 'function';
 
-  const resolved = isInline
-    ? guard
-    : machine.implementations.guards?.[
-        typeof guard === 'string' ? guard : guard.type
-      ];
+  const predicate =
+    machine?.implementations?.guards?.[guard.type] ?? guard.predicate;
 
-  if (!isInline && !resolved) {
-    throw new Error(
-      `Guard '${
-        typeof guard === 'string' ? guard : guard.type
-      }' is not implemented.'.`
-    );
+  if (!predicate) {
+    throw new Error(`Guard '${guard.type}' is not implemented.'.`);
   }
 
-  if (typeof resolved !== 'function') {
-    return evaluateGuard(resolved, context, event, state);
-  }
-
-  const guardArgs = {
+  return predicate({
     context,
     event,
-    guard: isInline
-      ? undefined
-      : typeof guard === 'string'
-      ? { type: guard }
-      : guard
-  };
+    state,
+    guard,
+    evaluate: evaluateGuard
+  });
+}
 
-  if (!('check' in resolved)) {
-    return resolved(guardArgs);
+export function toGuardDefinition<
+  TContext extends MachineContext,
+  TEvent extends EventObject
+>(
+  guardConfig: GuardConfig<TContext, TEvent>,
+  getPredicate?: (
+    guardType: string
+  ) => GuardPredicate<TContext, TEvent> | GuardDefinition<TContext, TEvent>
+): GuardDefinition<TContext, TEvent> {
+  // TODO: check for cycles and consider a refactor to more lazily evaluated guards
+  // TODO: resolve this more recursively: https://github.com/statelyai/xstate/pull/4064#discussion_r1229915724
+  if (typeof guardConfig === 'string') {
+    const predicateOrDef = getPredicate?.(guardConfig);
+
+    if (typeof predicateOrDef === 'function') {
+      return {
+        type: guardConfig,
+        predicate: predicateOrDef,
+        params: { type: guardConfig }
+      };
+    } else if (predicateOrDef) {
+      return predicateOrDef;
+    } else {
+      return {
+        type: guardConfig,
+        params: { type: guardConfig }
+      };
+    }
   }
 
-  const builtinGuard = resolved as unknown as BuiltinGuard;
+  if (typeof guardConfig === 'function') {
+    return {
+      type: guardConfig.name,
+      predicate: guardConfig,
+      params: {
+        type: guardConfig.name,
+        name: guardConfig.name
+      }
+    };
+  }
 
-  return builtinGuard.check(
-    state,
-    guardArgs,
-    resolved // this holds all params
-  );
+  const predicateOrDef = getPredicate?.(guardConfig.type);
+
+  if (typeof predicateOrDef === 'function') {
+    return {
+      type: guardConfig.type,
+      params: guardConfig.params || guardConfig,
+      children: (
+        guardConfig.children as Array<GuardConfig<TContext, TEvent>>
+      )?.map((childGuard) => toGuardDefinition(childGuard, getPredicate)),
+      predicate:
+        getPredicate?.(guardConfig.type) || (guardConfig as any).predicate
+    };
+  } else if (predicateOrDef) {
+    return predicateOrDef;
+  } else {
+    return {
+      type: guardConfig.type,
+      params: guardConfig.params || guardConfig,
+      children: (
+        guardConfig.children as Array<GuardConfig<TContext, TEvent>>
+      )?.map((childGuard) => toGuardDefinition(childGuard, getPredicate)),
+      predicate: (guardConfig as any).predicate
+    };
+  }
 }
diff --git a/packages/core/src/stateUtils.ts b/packages/core/src/stateUtils.ts
index 819627c251..cb24554a88 100644
--- a/packages/core/src/stateUtils.ts
+++ b/packages/core/src/stateUtils.ts
@@ -13,7 +13,7 @@ import {
   STATE_IDENTIFIER,
   WILDCARD
 } from './constants.ts';
-import { evaluateGuard } from './guards.ts';
+import { evaluateGuard, toGuardDefinition } from './guards.ts';
 import { ActorStatus } from './interpreter.ts';
 import {
   ActionArgs,
@@ -349,6 +349,7 @@ export function formatTransition<
 ): AnyTransitionDefinition {
   const normalizedTarget = normalizeTarget(transitionConfig.target);
   const reenter = transitionConfig.reenter ?? false;
+  const { guards } = stateNode.machine.implementations;
   const target = resolveTarget(stateNode, normalizedTarget);
 
   // TODO: should this be part of a lint rule instead?
@@ -360,7 +361,12 @@ export function formatTransition<
   const transition = {
     ...transitionConfig,
     actions: toArray(transitionConfig.actions),
-    guard: transitionConfig.guard as never,
+    guard: transitionConfig.guard
+      ? toGuardDefinition(
+          transitionConfig.guard,
+          (guardType) => guards[guardType]
+        )
+      : undefined,
     target,
     source: stateNode,
     reenter,
@@ -1429,7 +1435,7 @@ export function resolveActionsAndContext<
       continue;
     }
 
-    const actionArgs = {
+    const args = {
       context: intermediateState.context,
       event,
       self: actorCtx?.self,
@@ -1443,9 +1449,9 @@ export function resolveActionsAndContext<
 
     if (!('resolve' in resolved)) {
       if (actorCtx?.self.status === ActorStatus.Running) {
-        resolved(actionArgs);
+        resolved(args);
       } else {
-        actorCtx?.defer(() => resolved(actionArgs));
+        actorCtx?.defer(() => resolved(args));
       }
       continue;
     }
@@ -1455,7 +1461,7 @@ export function resolveActionsAndContext<
     const [nextState, params, actions] = builtinAction.resolve(
       actorCtx,
       intermediateState,
-      actionArgs,
+      args,
       resolved // this holds all params
     );
     intermediateState = nextState;
diff --git a/packages/core/src/types.ts b/packages/core/src/types.ts
index 8e828932b4..8a9f103de0 100644
--- a/packages/core/src/types.ts
+++ b/packages/core/src/types.ts
@@ -10,7 +10,6 @@ import {
   AreAllImplementationsAssumedToBeProvided
 } from './typegenTypes.ts';
 import { PromiseActorLogic } from './actors/promise.ts';
-import { Guard, GuardPredicate, UnknownGuard } from './guards.ts';
 
 /**
  * `T | unknown` reduces to `unknown` and that can be problematic when it comes to contextual typing.
@@ -77,11 +76,11 @@ export interface ParameterizedObject {
 
 export interface UnifiedArg<
   TContext extends MachineContext,
-  TExpressionEvent extends EventObject
+  TEvent extends EventObject
 > {
   context: TContext;
-  event: TExpressionEvent;
-  self: ActorRef<TExpressionEvent>; // TODO: this should refer to `TEvent`
+  event: TEvent;
+  self: ActorRef<TEvent>;
   system: ActorSystem<any>;
 }
 
@@ -165,7 +164,7 @@ export interface ChooseBranch<
   TEvent extends EventObject = TExpressionEvent,
   TAction extends ParameterizedObject = ParameterizedObject
 > {
-  guard?: Guard<TContext, TExpressionEvent>;
+  guard?: GuardConfig<TContext, TExpressionEvent>;
   actions: Actions<TContext, TExpressionEvent, TEvent, undefined, TAction>;
 }
 
@@ -224,6 +223,88 @@ export interface StateValueMap {
  */
 export type StateValue = string | StateValueMap;
 
+export type GuardPredicate<
+  TContext extends MachineContext,
+  TEvent extends EventObject
+> = (
+  args: {
+    context: TContext;
+    event: TEvent;
+  } & GuardArgs<TContext, TEvent>
+) => boolean;
+
+export interface DefaultGuardObject<
+  TContext extends MachineContext,
+  TEvent extends EventObject
+> extends ParameterizedObject {
+  /**
+   * Nested guards
+   */
+  children?: Array<GuardObject<TContext, TEvent>>;
+  predicate?: GuardPredicate<TContext, TEvent>;
+}
+
+export type GuardEvaluator<
+  TContext extends MachineContext,
+  TEvent extends EventObject
+> = (
+  guard: GuardDefinition<TContext, TEvent>,
+  context: TContext,
+  event: TEvent,
+  state: State<TContext, TEvent, TODO, TODO>
+) => boolean;
+
+export interface GuardArgs<
+  TContext extends MachineContext,
+  TEvent extends EventObject
+> {
+  state: State<TContext, TEvent, TODO, TODO>;
+  guard: GuardDefinition<TContext, TEvent>;
+  evaluate: GuardEvaluator<TContext, TEvent>;
+}
+
+export type GuardConfig<
+  TContext extends MachineContext,
+  TEvent extends EventObject
+> = string | GuardPredicate<TContext, TEvent> | GuardObject<TContext, TEvent>;
+
+export type GuardObject<
+  TContext extends MachineContext,
+  TEvent extends EventObject
+> = BooleanGuardObject<TContext, TEvent> | DefaultGuardObject<TContext, TEvent>;
+
+export interface GuardDefinition<
+  TContext extends MachineContext,
+  TEvent extends EventObject
+> {
+  type: string;
+  children?: Array<GuardDefinition<TContext, TEvent>>;
+  predicate?: GuardPredicate<TContext, TEvent>;
+  params: { [key: string]: any };
+}
+
+export interface BooleanGuardObject<
+  TContext extends MachineContext,
+  TEvent extends EventObject
+> extends ParameterizedObject {
+  type: 'xstate.boolean';
+  children: Array<GuardConfig<TContext, TEvent>>;
+  params: {
+    op: 'and' | 'or' | 'not';
+  };
+  predicate: undefined;
+}
+
+export interface BooleanGuardDefinition<
+  TContext extends MachineContext,
+  TEvent extends EventObject
+> extends GuardDefinition<TContext, TEvent> {
+  type: 'xstate.boolean';
+  params: {
+    op: 'and' | 'or' | 'not';
+  };
+}
+
 export type TransitionTarget = SingleOrArray<string>;
 
 export interface TransitionConfig<
@@ -232,7 +313,7 @@ export interface TransitionConfig<
   TEvent extends EventObject,
   TAction extends ParameterizedObject
 > {
-  guard?: Guard<TContext, TExpressionEvent>;
+  guard?: GuardConfig<TContext, TExpressionEvent>;
   actions?: Actions<TContext, TExpressionEvent, TEvent, undefined, TAction>;
   reenter?: boolean;
   target?: TransitionTarget | undefined;
@@ -857,7 +938,7 @@ type MachineImplementationsGuards<
         TContext,
         Cast<Prop<TIndexedEvents, TEventsCausingGuards[K]>, EventObject>
       >
-    | Guard<
+    | GuardConfig<
         TContext,
         Cast<Prop<TIndexedEvents, TEventsCausingGuards[K]>, EventObject>
       >;
@@ -1263,25 +1344,18 @@ export type PropertyMapper<
 export interface TransitionDefinition<
   TContext extends MachineContext,
   TEvent extends EventObject
-> extends Omit<
-    TransitionConfig<TContext, TEvent, TEvent, TODO>,
-    | 'target'
-    // `guard` is correctly rejected by `extends` here and `actions` should be too
-    // however, `any` passed to `TransitionConfig` as `TAction` collapses its `.actions` to `any` and it's accidentally allowed here
-    // it doesn't exactly have to be incorrect, we are overriding this here anyway but it looks like a lucky accident rather than smth done on purpose
-    | 'guard'
-  > {
+> extends Omit<TransitionConfig<TContext, TEvent, TEvent, TODO>, 'target'> {
   target: ReadonlyArray<StateNode<TContext, TEvent>> | undefined;
   source: StateNode<TContext, TEvent>;
   actions: readonly UnknownAction[];
   reenter: boolean;
-  guard?: UnknownGuard;
+  guard?: GuardDefinition<TContext, TEvent>;
   eventType: TEvent['type'] | '*';
   toJSON: () => {
     target: string[] | undefined;
     source: string;
     actions: readonly UnknownAction[];
-    guard?: UnknownGuard;
+    guard?: GuardDefinition<TContext, TEvent>;
     eventType: TEvent['type'] | '*';
     meta?: Record<string, any>;
   };
diff --git a/packages/core/test/actions.test.ts b/packages/core/test/actions.test.ts
index 1591c008a5..249c96e544 100644
--- a/packages/core/test/actions.test.ts
+++ b/packages/core/test/actions.test.ts
@@ -2863,6 +2863,42 @@ describe('choose', () => {
     expect(service.getSnapshot().context).toEqual({ answer: 42 });
   });
 
+  it('should provide stateGuard.state to a condition expression', () => {
+    type Ctx = { counter: number; answer?: number };
+    const machine = createMachine<Ctx>({
+      context: {
+        counter: 101
+      },
+      type: 'parallel',
+      states: {
+        foo: {
+          initial: 'waiting',
+          states: {
+            waiting: {
+              on: {
+                GIVE_ANSWER: 'answering'
+              }
+            },
+            answering: {
+              entry: choose([
+                {
+                  guard: ({ state }) => state.matches('bar'),
+                  actions: assign({ answer: 42 })
+                }
+              ])
+            }
+          }
+        },
+        bar: {}
+      }
+    });
+
+    const service = createActor(machine).start();
+    service.send({ type: 'GIVE_ANSWER' });
+
+    expect(service.getSnapshot().context).toEqual({ counter: 101, answer: 42 });
+  });
+
   it('should be able to use actions and guards defined in options', () => {
     interface Ctx {
       answer?: number;
diff --git a/packages/core/test/guards.test.ts b/packages/core/test/guards.test.ts
index c40c5de5eb..2fddff186b 100644
--- a/packages/core/test/guards.test.ts
+++ b/packages/core/test/guards.test.ts
@@ -1,5 +1,5 @@
 import { createActor, createMachine, raise } from '../src/index.ts';
-import { and, not, or, stateIn } from '../src/guards';
+import { and, not, or } from '../src/guards';
 import { trackEntries } from './utils.ts';
 
 describe('guard conditions', () => {
@@ -331,7 +331,7 @@ describe('guard conditions', () => {
                 T2: [
                   {
                     target: 'B2',
-                    guard: stateIn('A.A2')
+                    guard: ({ state }) => state.matches('A.A2')
                   }
                 ]
               }
@@ -381,7 +381,7 @@ describe('guard conditions', () => {
               always: [
                 {
                   target: 'B4',
-                  guard: stateIn('A.A4')
+                  guard: ({ state }) => state.matches('A.A4')
                 }
               ]
             },
@@ -399,6 +399,35 @@ describe('guard conditions', () => {
       B: 'B4'
     });
   });
+
+  it('should be able to check source state tags when checking', () => {
+    const machine = createMachine({
+      initial: 'a',
+      states: {
+        a: {
+          on: {
+            MACRO: 'b'
+          }
+        },
+        b: {
+          entry: raise({ type: 'MICRO' }),
+          tags: 'theTag',
+          on: {
+            MICRO: {
+              guard: ({ state }) => state.hasTag('theTag'),
+              target: 'c'
+            }
+          }
+        },
+        c: {}
+      }
+    });
+
+    const service = createActor(machine).start();
+    service.send({ type: 'MACRO' });
+
+    expect(service.getSnapshot().value).toBe('c');
+  });
 });
 
 describe('custom guards', () => {
@@ -435,7 +464,7 @@ describe('custom guards', () => {
       {
         guards: {
           custom: ({ context, event, guard }) => {
-            const { prop, compare, op } = (guard as any).params;
+            const { prop, compare, op } = guard.params;
             if (op === 'greaterThan') {
               return (
                 context[prop as keyof typeof context] + event.value > compare
@@ -463,62 +492,60 @@ describe('custom guards', () => {
 });
 
 describe('referencing guards', () => {
-  it('guard should be checked when referenced by a string', () => {
-    const spy = jest.fn();
-    const machine = createMachine(
-      {
-        on: {
-          EV: {
-            guard: 'checkStuff'
+  const stringGuardFn = () => true;
+  const guardsMachine = createMachine(
+    {
+      id: 'guards',
+      initial: 'active',
+      states: {
+        active: {
+          on: {
+            EVENT: [
+              { guard: 'string' },
+              {
+                guard: function guardFn() {
+                  return true;
+                }
+              },
+              {
+                guard: {
+                  type: 'object',
+                  params: { foo: 'bar' }
+                }
+              }
+            ]
           }
         }
-      },
-      {
-        guards: {
-          checkStuff: spy
-        }
       }
-    );
-
-    const actorRef = createActor(machine).start();
+    },
+    {
+      guards: {
+        string: stringGuardFn
+      }
+    }
+  );
 
-    expect(spy).not.toHaveBeenCalled();
+  const def = guardsMachine.definition;
+  const [stringGuard, functionGuard, objectGuard] = def.states.active.on.EVENT;
 
-    actorRef.send({
-      type: 'EV'
-    });
+  it('guard predicates should be able to be referenced from a string', () => {
+    expect(stringGuard.guard!.predicate).toBeDefined();
+    expect(stringGuard.guard!.type).toEqual('string');
+  });
 
-    expect(spy).toHaveBeenCalledTimes(1);
+  it('guard predicates should be able to be referenced from a function', () => {
+    expect(functionGuard.guard!.predicate).toBeDefined();
+    expect(functionGuard.guard!.type).toEqual('guardFn');
   });
 
-  it('guard should be checked when referenced by a parametrized guard object', () => {
-    const spy = jest.fn();
-    const machine = createMachine(
-      {
-        on: {
-          EV: {
-            guard: {
-              type: 'checkStuff'
-            }
-          }
-        }
-      },
-      {
-        guards: {
-          checkStuff: spy
-        }
-      }
+  it('guard predicates should be able to be referenced from an object', () => {
+    expect(objectGuard.guard).toBeDefined();
+    expect(objectGuard.guard).toEqual(
+      expect.objectContaining({
+        type: 'object',
+        params: expect.objectContaining({ foo: 'bar' })
+      })
     );
-
-    const actorRef = createActor(machine).start();
-
-    expect(spy).not.toHaveBeenCalled();
-
-    actorRef.send({
-      type: 'EV'
-    });
-
-    expect(spy).toHaveBeenCalledTimes(1);
   });
 
   it('should throw for guards with missing predicates', () => {
@@ -617,8 +644,34 @@ describe('referencing guards', () => {
 
     expect(actorRef.getSnapshot().matches('b')).toBeTruthy();
   });
+});
+
+describe('guards - other', () => {
+  it('should allow for a fallback target to be a simple string', () => {
+    const machine = createMachine({
+      initial: 'a',
+      states: {
+        a: {
+          on: {
+            EVENT: [{ target: 'b', guard: () => false }, 'c']
+          }
+        },
+        b: {},
+        c: {}
+      }
+    });
+
+    const service = createActor(machine).start();
+    service.send({ type: 'EVENT' });
+
+    expect(service.getSnapshot().value).toBe('c');
+  });
+});
+
+describe('guards with child guards', () => {
+  it('guards can contain child guards', () => {
+    expect.assertions(3);
 
-  it('should be possible to resolve referenced guards recursively', () => {
     const machine = createMachine(
       {
         initial: 'a',
@@ -627,7 +680,26 @@ describe('referencing guards', () => {
             on: {
               EVENT: {
                 target: 'b',
-                guard: 'ref1'
+                guard: {
+                  type: 'testGuard',
+                  children: [
+                    {
+                      type: 'customGuard',
+                      predicate: () => true
+                    },
+                    { type: 'customGuard' }
+                  ],
+                  predicate: ({ guard }) => {
+                    expect(guard.children).toHaveLength(2);
+                    expect(
+                      guard.children?.find(
+                        (childGuard: any) => childGuard.type === 'customGuard'
+                      )?.predicate
+                    ).toBeInstanceOf(Function);
+
+                    return true;
+                  }
+                }
               }
             }
           },
@@ -636,9 +708,7 @@ describe('referencing guards', () => {
       },
       {
         guards: {
-          ref1: 'ref2',
-          ref2: 'ref3',
-          ref3: () => true
+          customGuard: () => true
         }
       }
     );
@@ -650,28 +720,6 @@ describe('referencing guards', () => {
   });
 });
 
-describe('guards - other', () => {
-  it('should allow for a fallback target to be a simple string', () => {
-    const machine = createMachine({
-      initial: 'a',
-      states: {
-        a: {
-          on: {
-            EVENT: [{ target: 'b', guard: () => false }, 'c']
-          }
-        },
-        b: {},
-        c: {}
-      }
-    });
-
-    const service = createActor(machine).start();
-    service.send({ type: 'EVENT' });
-
-    expect(service.getSnapshot().value).toBe('c');
-  });
-});
-
 describe('not() guard', () => {
   it('should guard with inline function', () => {
     const machine = createMachine({
@@ -744,7 +792,7 @@ describe('not() guard', () => {
       {
         guards: {
           greaterThan10: ({ guard }) => {
-            return (guard as any).params.value > 10;
+            return guard.params.value > 10;
           }
         }
       }
@@ -861,7 +909,7 @@ describe('and() guard', () => {
       {
         guards: {
           greaterThan10: ({ guard }) => {
-            return (guard as any).params.value > 10;
+            return guard.params.value > 10;
           }
         }
       }
@@ -983,7 +1031,7 @@ describe('or() guard', () => {
       {
         guards: {
           greaterThan10: ({ guard }) => {
-            return (guard as any).params.value > 10;
+            return guard.params.value > 10;
           }
         }
       }
diff --git a/packages/core/test/types.test.ts b/packages/core/test/types.test.ts
index 9c091c1431..460fce6291 100644
--- a/packages/core/test/types.test.ts
+++ b/packages/core/test/types.test.ts
@@ -12,8 +12,7 @@ import {
   Spawner,
   StateMachine,
   pure,
-  choose,
-  not
+  choose
 } from '../src/index';
 
 function noop(_x: unknown) {
@@ -2200,27 +2199,3 @@ describe('input', () => {
     });
   });
 });
-
-describe('guards', () => {
-  it('`not` guard should be accepted when it references another guard using a string', () => {
-    createMachine(
-      {
-        id: 'b',
-        types: {} as {
-          events: { type: 'EVENT' };
-        },
-        on: {
-          EVENT: {
-            target: '#b',
-            guard: not('falsy')
-          }
-        }
-      },
-      {
-        guards: {
-          falsy: () => false
-        }
-      }
-    );
-  });
-});
