diff --git a/docs/developer-guide/nodejs-api.md b/docs/developer-guide/nodejs-api.md
index 8bfa9aecb..991a1cbcd 100644
--- a/docs/developer-guide/nodejs-api.md
+++ b/docs/developer-guide/nodejs-api.md
@@ -926,7 +926,7 @@ The top-level report object has a `results` array containing all linting results
 * `source` - The source code for the given file. This property is omitted if this file has no errors/warnings or if the `output` property is present.
 * `output` - The source code for the given file with as many fixes applied as possible, so you can use that to rewrite the files if necessary. This property is omitted if no fix is available.
 
-The top-level report object also has `errorCount` and `warningCount` which give the exact number of errors and warnings respectively on all the files. Additionally, `usedDeprecatedRules` signals any deprecated rules used and their replacement (if available). Specifically, it is an array of objects with properties like so:
+The top-level report object also has `errorCount` and `warningCount` which give the exact number of errors and warnings respectively on all the files. Additionally, `usedDeprecatedRules` signals any deprecated rules used and their replacement (if available). Specifically, it is array of objects with properties like so:
 
 * `ruleId` - The name of the rule (e.g. `indent-legacy`).
 * `replacedBy` - An array of rules that replace the deprecated rule (e.g. `["indent"]`).
diff --git a/docs/developer-guide/working-with-rules.md b/docs/developer-guide/working-with-rules.md
index 2b814e7a9..2f47c316c 100644
--- a/docs/developer-guide/working-with-rules.md
+++ b/docs/developer-guide/working-with-rules.md
@@ -375,7 +375,7 @@ context.report({
 {% endraw %}
 ```
 
-Note: Suggestions will be applied as a stand-alone change, without triggering multipass fixes. Each suggestion should focus on a singular change in the code and should not try to conform to user defined styles. For example, if a suggestion is adding a new statement into the codebase, it should not try to match correct indentation, or confirm to user preferences on presence/absence of semicolons. All of those things can be corrected by multipass autofix when the user triggers it.
+Note: Suggestions will be applied as a stand-alone change, without triggering multipass fixes. Each suggestion should focus on a singular change in the code and should not try to conform to user defined styles. For example, if a suggestion is adding a new statement into the codebase, it should not try to match correct indentation, or confirm to user preferences on presence/absence of semicolumns. All of those things can be corrected by multipass autofix when the user triggers it.
 
 Best practices for suggestions:
 
diff --git a/docs/rules/operator-assignment.md b/docs/rules/operator-assignment.md
index 977edfd34..b926462b3 100644
--- a/docs/rules/operator-assignment.md
+++ b/docs/rules/operator-assignment.md
@@ -23,6 +23,8 @@ JavaScript provides shorthand operators that combine variable assignment and som
 
 This rule requires or disallows assignment operator shorthand where possible.
 
+The rule applies to the operators listed in the above table. It does not report the logical assignment operators `&&=`, `||=`, and `??=` because their short-circuiting behavior is different from the other assignment operators.
+
 ## Options
 
 This rule has a single string option:
diff --git a/lib/rules/constructor-super.js b/lib/rules/constructor-super.js
index 65ed7422c..8787fc569 100644
--- a/lib/rules/constructor-super.js
+++ b/lib/rules/constructor-super.js
@@ -60,7 +60,23 @@ function isPossibleConstructor(node) {
             return node.name !== "undefined";
 
         case "AssignmentExpression":
-            return isPossibleConstructor(node.right);
+            if (["=", "&&="].includes(node.operator)) {
+                return isPossibleConstructor(node.right);
+            }
+
+            if (["||=", "??="].includes(node.operator)) {
+                return (
+                    isPossibleConstructor(node.left) ||
+                    isPossibleConstructor(node.right)
+                );
+            }
+
+            /**
+             * All other assignment operators are mathematical assignment operators (arithmetic or bitwise).
+             * An assignment expression with a mathematical operator can either evaluate to a primitive value,
+             * or throw, depending on the operands. Thus, it cannot evaluate to a constructor function.
+             */
+            return false;
 
         case "LogicalExpression":
             return (
diff --git a/lib/rules/operator-assignment.js b/lib/rules/operator-assignment.js
index aee79077f..fdb088492 100644
--- a/lib/rules/operator-assignment.js
+++ b/lib/rules/operator-assignment.js
@@ -151,7 +151,7 @@ module.exports = {
          * @returns {void}
          */
         function prohibit(node) {
-            if (node.operator !== "=") {
+            if (node.operator !== "=" && !astUtils.isLogicalAssignmentOperator(node.operator)) {
                 context.report({
                     node,
                     messageId: "unexpected",
diff --git a/lib/rules/utils/ast-utils.js b/lib/rules/utils/ast-utils.js
index d0dd770d1..cee6975d3 100644
--- a/lib/rules/utils/ast-utils.js
+++ b/lib/rules/utils/ast-utils.js
@@ -40,6 +40,8 @@ const STATEMENT_LIST_PARENTS = new Set(["Program", "BlockStatement", "SwitchCase
 const DECIMAL_INTEGER_PATTERN = /^(0|[1-9]\d*)$/u;
 const OCTAL_ESCAPE_PATTERN = /^(?:[^\\]|\\[^0-7]|\\0(?![0-9]))*\\(?:[1-7]|0[0-9])/u;
 
+const LOGICAL_ASSIGNMENT_OPERATORS = new Set(["&&=", "||=", "??="]);
+
 /**
  * Checks reference if is non initializer and writable.
  * @param {Reference} reference A reference to check.
@@ -722,6 +724,15 @@ function isMixedLogicalAndCoalesceExpressions(left, right) {
     );
 }
 
+/**
+ * Checks if the given operator is a logical assignment operator.
+ * @param {string} operator The operator to check.
+ * @returns {boolean} `true` if the operator is a logical assignment operator.
+ */
+function isLogicalAssignmentOperator(operator) {
+    return LOGICAL_ASSIGNMENT_OPERATORS.has(operator);
+}
+
 //------------------------------------------------------------------------------
 // Public Interface
 //------------------------------------------------------------------------------
@@ -1567,7 +1578,20 @@ module.exports = {
                 return true; // possibly an error object.
 
             case "AssignmentExpression":
-                return module.exports.couldBeError(node.right);
+                if (["=", "&&="].includes(node.operator)) {
+                    return module.exports.couldBeError(node.right);
+                }
+
+                if (["||=", "??="].includes(node.operator)) {
+                    return module.exports.couldBeError(node.left) || module.exports.couldBeError(node.right);
+                }
+
+                /**
+                 * All other assignment operators are mathematical assignment operators (arithmetic or bitwise).
+                 * An assignment expression with a mathematical operator can either evaluate to a primitive value,
+                 * or throw, depending on the operands. Thus, it cannot evaluate to an `Error` object.
+                 */
+                return false;
 
             case "SequenceExpression": {
                 const exprs = node.expressions;
@@ -1754,5 +1778,6 @@ module.exports = {
     isSpecificId,
     isSpecificMemberAccess,
     equalLiteralValue,
-    isSameReference
+    isSameReference,
+    isLogicalAssignmentOperator
 };
