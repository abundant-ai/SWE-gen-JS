diff --git a/docs/transform.md b/docs/transform.md
index 885031e..3305f0b 100644
--- a/docs/transform.md
+++ b/docs/transform.md
@@ -7,9 +7,10 @@ Transforms map or filter the input or output of a child process. They are define
 ```js
 import {execa} from 'execa';
 
-const transform = async function * (chunks) {
-	for await (const chunk of chunks) {
-		yield chunk.toUpperCase();
+const transform = async function * (lines) {
+	for await (const line of lines) {
+		const prefix = line.includes('error') ? 'ERROR' : 'INFO'
+		yield `${prefix}: ${line}`
 	}
 };
 
@@ -19,21 +20,21 @@ console.log(stdout); // HELLO
 
 ## Encoding
 
-The `chunks` argument passed to the transform is an [`AsyncIterable<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#the_async_iterator_and_async_iterable_protocols). If the [`encoding`](../readme.md#encoding) option is `buffer`, it is an `AsyncIterable<Uint8Array>` instead.
+The `lines` argument passed to the transform is an [`AsyncIterable<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#the_async_iterator_and_async_iterable_protocols). If the [`encoding`](../readme.md#encoding) option is `buffer`, it is an `AsyncIterable<Uint8Array>` instead.
 
-The transform can `yield` either a `string` or an `Uint8Array`, regardless of the `chunks` argument's type.
+The transform can `yield` either a `string` or an `Uint8Array`, regardless of the `lines` argument's type.
 
 ## Filtering
 
-`yield` can be called 0, 1 or multiple times. Not calling `yield` enables filtering a specific chunk.
+`yield` can be called 0, 1 or multiple times. Not calling `yield` enables filtering a specific line.
 
 ```js
 import {execa} from 'execa';
 
-const transform = async function * (chunks) {
-	for await (const chunk of chunks) {
-		if (!chunk.includes('secret')) {
-			yield chunk;
+const transform = async function * (lines) {
+	for await (const line of lines) {
+		if (!line.includes('secret')) {
+			yield line;
 		}
 	}
 };
@@ -42,6 +43,19 @@ const {stdout} = await execa('echo', ['This is a secret.'], {stdout: transform})
 console.log(stdout); // ''
 ```
 
+## Binary data
+
+The transform iterates over lines by default.\
+However, if a `{transform, binary: true}` plain object is passed, it iterates over arbitrary chunks of data instead.
+
+```js
+await execa('./binary.js', {stdout: {transform, binary: true}});
+```
+
+This is more efficient and recommended if the data is either:
+	- Binary: Which does not have lines.
+	- Text: But the transform works even if a line or word is split across multiple chunks.
+
 ## Combining
 
 The [`stdin`](../readme.md#stdin), [`stdout`](../readme.md#stdout-1), [`stderr`](../readme.md#stderr-1) and [`stdio`](../readme.md#stdio-1) options can accept an array of values. While this is not specific to transforms, this can be useful with them too. For example, the following transform impacts the value printed by `inherit`.
diff --git a/index.d.ts b/index.d.ts
index b535073..6cba55b 100644
--- a/index.d.ts
+++ b/index.d.ts
@@ -18,6 +18,10 @@ type BaseStdioOption =
 	| 'ignore'
 	| 'inherit';
 
+// @todo Use either `Iterable<string>` or `Iterable<Uint8Array>` based on whether `encoding: 'buffer'` is used.
+// See https://github.com/sindresorhus/execa/issues/694
+type StdioTransform = ((chunks: Iterable<string | Uint8Array>) => AsyncGenerator<string | Uint8Array, void, void>);
+
 type CommonStdioOption<IsSync extends boolean = boolean> =
 	| BaseStdioOption
 	| 'ipc'
@@ -25,9 +29,12 @@ type CommonStdioOption<IsSync extends boolean = boolean> =
 	| undefined
 	| URL
 	| {file: string}
-	// TODO: Use either `Iterable<string>` or `Iterable<Uint8Array>` based on whether `encoding: 'buffer'` is used.
-	// See https://github.com/sindresorhus/execa/issues/694
-	| IfAsync<IsSync, ((chunks: Iterable<string | Uint8Array>) => AsyncGenerator<string | Uint8Array, void, void>)>;
+	| IfAsync<IsSync,
+	| StdioTransform
+	| {
+		transform: StdioTransform;
+		binary?: boolean;
+	}>;
 
 type InputStdioOption<IsSync extends boolean = boolean> =
 	| Uint8Array
diff --git a/index.test-d.ts b/index.test-d.ts
index 5f6c04c..0600177 100644
--- a/index.test-d.ts
+++ b/index.test-d.ts
@@ -569,35 +569,35 @@ const asyncStringGenerator = async function * () {
 
 const fileUrl = new URL('file:///test');
 
-const stringOrUint8ArrayGenerator = async function * (chunks: Iterable<string | Uint8Array>) {
-	for await (const chunk of chunks) {
-		yield chunk;
+const stringOrUint8ArrayGenerator = async function * (lines: Iterable<string | Uint8Array>) {
+	for await (const line of lines) {
+		yield line;
 	}
 };
 
-const booleanGenerator = async function * (chunks: Iterable<boolean>) {
-	for await (const chunk of chunks) {
-		yield chunk;
+const booleanGenerator = async function * (lines: Iterable<boolean>) {
+	for await (const line of lines) {
+		yield line;
 	}
 };
 
-const arrayGenerator = async function * (chunks: string[]) {
-	for await (const chunk of chunks) {
-		yield chunk;
+const arrayGenerator = async function * (lines: string[]) {
+	for await (const line of lines) {
+		yield line;
 	}
 };
 
-const invalidReturnGenerator = async function * (chunks: Iterable<string>) {
-	for await (const chunk of chunks) {
-		yield chunk;
+const invalidReturnGenerator = async function * (lines: Iterable<string>) {
+	for await (const line of lines) {
+		yield line;
 	}
 
 	return false;
 };
 
-const syncGenerator = function * (chunks: Iterable<string>) {
-	for (const chunk of chunks) {
-		yield chunk;
+const syncGenerator = function * (lines: Iterable<string>) {
+	for (const line of lines) {
+		yield line;
 	}
 
 	return false;
@@ -712,6 +712,18 @@ expectError(execa('unicorns', {stdin: booleanGenerator}));
 expectError(execa('unicorns', {stdin: arrayGenerator}));
 expectError(execa('unicorns', {stdin: invalidReturnGenerator}));
 expectError(execa('unicorns', {stdin: syncGenerator}));
+execa('unicorns', {stdin: {transform: stringOrUint8ArrayGenerator}});
+expectError(execaSync('unicorns', {stdin: {transform: stringOrUint8ArrayGenerator}}));
+execa('unicorns', {stdin: [{transform: stringOrUint8ArrayGenerator}]});
+expectError(execaSync('unicorns', {stdin: [{transform: stringOrUint8ArrayGenerator}]}));
+expectError(execa('unicorns', {stdin: {transform: booleanGenerator}}));
+expectError(execa('unicorns', {stdin: {transform: arrayGenerator}}));
+expectError(execa('unicorns', {stdin: {transform: invalidReturnGenerator}}));
+expectError(execa('unicorns', {stdin: {transform: syncGenerator}}));
+expectError(execa('unicorns', {stdin: {}}));
+expectError(execa('unicorns', {stdin: {binary: true}}));
+execa('unicorns', {stdin: {transform: stringOrUint8ArrayGenerator, binary: true}});
+expectError(execa('unicorns', {stdin: {transform: stringOrUint8ArrayGenerator, binary: 'true'}}));
 execa('unicorns', {stdin: undefined});
 execaSync('unicorns', {stdin: undefined});
 execa('unicorns', {stdin: [undefined]});
@@ -778,6 +790,18 @@ expectError(execa('unicorns', {stdout: booleanGenerator}));
 expectError(execa('unicorns', {stdout: arrayGenerator}));
 expectError(execa('unicorns', {stdout: invalidReturnGenerator}));
 expectError(execa('unicorns', {stdout: syncGenerator}));
+execa('unicorns', {stdout: {transform: stringOrUint8ArrayGenerator}});
+expectError(execaSync('unicorns', {stdout: {transform: stringOrUint8ArrayGenerator}}));
+execa('unicorns', {stdout: [{transform: stringOrUint8ArrayGenerator}]});
+expectError(execaSync('unicorns', {stdout: [{transform: stringOrUint8ArrayGenerator}]}));
+expectError(execa('unicorns', {stdout: {transform: booleanGenerator}}));
+expectError(execa('unicorns', {stdout: {transform: arrayGenerator}}));
+expectError(execa('unicorns', {stdout: {transform: invalidReturnGenerator}}));
+expectError(execa('unicorns', {stdout: {transform: syncGenerator}}));
+expectError(execa('unicorns', {stdout: {}}));
+expectError(execa('unicorns', {stdout: {binary: true}}));
+execa('unicorns', {stdout: {transform: stringOrUint8ArrayGenerator, binary: true}});
+expectError(execa('unicorns', {stdout: {transform: stringOrUint8ArrayGenerator, binary: 'true'}}));
 execa('unicorns', {stdout: undefined});
 execaSync('unicorns', {stdout: undefined});
 execa('unicorns', {stdout: [undefined]});
@@ -844,6 +868,18 @@ expectError(execa('unicorns', {stderr: booleanGenerator}));
 expectError(execa('unicorns', {stderr: arrayGenerator}));
 expectError(execa('unicorns', {stderr: invalidReturnGenerator}));
 expectError(execa('unicorns', {stderr: syncGenerator}));
+execa('unicorns', {stderr: {transform: stringOrUint8ArrayGenerator}});
+expectError(execaSync('unicorns', {stderr: {transform: stringOrUint8ArrayGenerator}}));
+execa('unicorns', {stderr: [{transform: stringOrUint8ArrayGenerator}]});
+expectError(execaSync('unicorns', {stderr: [{transform: stringOrUint8ArrayGenerator}]}));
+expectError(execa('unicorns', {stderr: {transform: booleanGenerator}}));
+expectError(execa('unicorns', {stderr: {transform: arrayGenerator}}));
+expectError(execa('unicorns', {stderr: {transform: invalidReturnGenerator}}));
+expectError(execa('unicorns', {stderr: {transform: syncGenerator}}));
+expectError(execa('unicorns', {stderr: {}}));
+expectError(execa('unicorns', {stderr: {binary: true}}));
+execa('unicorns', {stderr: {transform: stringOrUint8ArrayGenerator, binary: true}});
+expectError(execa('unicorns', {stderr: {transform: stringOrUint8ArrayGenerator, binary: 'true'}}));
 execa('unicorns', {stderr: undefined});
 execaSync('unicorns', {stderr: undefined});
 execa('unicorns', {stderr: [undefined]});
@@ -882,6 +918,8 @@ expectError(execa('unicorns', {stdio: 1}));
 expectError(execaSync('unicorns', {stdio: 1}));
 expectError(execa('unicorns', {stdio: stringOrUint8ArrayGenerator}));
 expectError(execaSync('unicorns', {stdio: stringOrUint8ArrayGenerator}));
+expectError(execa('unicorns', {stdio: {transform: stringOrUint8ArrayGenerator}}));
+expectError(execaSync('unicorns', {stdio: {transform: stringOrUint8ArrayGenerator}}));
 expectError(execa('unicorns', {stdio: fileUrl}));
 expectError(execaSync('unicorns', {stdio: fileUrl}));
 expectError(execa('unicorns', {stdio: {file: './test'}}));
@@ -934,6 +972,8 @@ execa('unicorns', {
 		process.stdin,
 		1,
 		stringOrUint8ArrayGenerator,
+		{transform: stringOrUint8ArrayGenerator},
+		{transform: stringOrUint8ArrayGenerator, binary: true},
 		undefined,
 		fileUrl,
 		{file: './test'},
@@ -962,6 +1002,7 @@ execaSync('unicorns', {
 	],
 });
 expectError(execaSync('unicorns', {stdio: [stringOrUint8ArrayGenerator]}));
+expectError(execaSync('unicorns', {stdio: [{transform: stringOrUint8ArrayGenerator}]}));
 expectError(execaSync('unicorns', {stdio: [new Writable()]}));
 expectError(execaSync('unicorns', {stdio: [new Readable()]}));
 expectError(execaSync('unicorns', {stdio: [new WritableStream()]}));
@@ -979,6 +1020,8 @@ execa('unicorns', {
 		[process.stdin],
 		[1],
 		[stringOrUint8ArrayGenerator],
+		[{transform: stringOrUint8ArrayGenerator}],
+		[{transform: stringOrUint8ArrayGenerator, binary: true}],
 		[undefined],
 		[fileUrl],
 		[{file: './test'}],
@@ -1008,6 +1051,7 @@ execaSync('unicorns', {
 	],
 });
 expectError(execaSync('unicorns', {stdio: [[stringOrUint8ArrayGenerator]]}));
+expectError(execaSync('unicorns', {stdio: [[{transform: stringOrUint8ArrayGenerator}]]}));
 expectError(execaSync('unicorns', {stdio: [[new Writable()]]}));
 expectError(execaSync('unicorns', {stdio: [[new Readable()]]}));
 expectError(execaSync('unicorns', {stdio: [[new WritableStream()]]}));
diff --git a/lib/stdio/encoding.js b/lib/stdio/encoding.js
index 06802a3..5462e24 100644
--- a/lib/stdio/encoding.js
+++ b/lib/stdio/encoding.js
@@ -7,8 +7,16 @@ export const handleStreamsEncoding = (stdioStreams, {encoding}, isSync) => {
 		return stdioStreams.map(stdioStream => ({...stdioStream, encoding}));
 	}
 
-	const value = encodingEndGenerator.bind(undefined, encoding);
-	return [...stdioStreams, {...stdioStreams[0], type: 'generator', value, encoding: 'buffer'}];
+	const transform = encodingEndGenerator.bind(undefined, encoding);
+	return [
+		...stdioStreams,
+		{
+			...stdioStreams[0],
+			type: 'generator',
+			value: {transform, binary: true},
+			encoding: 'buffer',
+		},
+	];
 };
 
 // eslint-disable-next-line unicorn/text-encoding-identifier-case
diff --git a/lib/stdio/generator.js b/lib/stdio/generator.js
index fa5e3b4..d97227f 100644
--- a/lib/stdio/generator.js
+++ b/lib/stdio/generator.js
@@ -1,5 +1,7 @@
 import {generatorsToDuplex} from './duplex.js';
 import {getEncodingStartGenerator} from './encoding.js';
+import {getLinesGenerator} from './lines.js';
+import {isGeneratorOptions} from './type.js';
 
 /*
 Generators can be used to transform/filter standard streams.
@@ -20,7 +22,12 @@ We ensure `objectMode` is `false` for better buffering.
 Chunks are currently processed serially. We could add a `concurrency` option to parallelize in the future.
 */
 export const generatorToDuplexStream = ({value, encoding}) => {
-	const generators = [getEncodingStartGenerator(encoding), value];
+	const {transform, binary} = isGeneratorOptions(value) ? value : {transform: value};
+	const generators = [
+		getEncodingStartGenerator(encoding),
+		getLinesGenerator(encoding, binary),
+		transform,
+	].filter(Boolean);
 	const duplexStream = generatorsToDuplex(generators, {objectMode: false});
 	return {value: duplexStream};
 };
diff --git a/lib/stdio/lines.js b/lib/stdio/lines.js
new file mode 100644
index 0000000..04fba41
--- /dev/null
+++ b/lib/stdio/lines.js
@@ -0,0 +1,57 @@
+// Split chunks line-wise
+export const getLinesGenerator = (encoding, binary) => {
+	if (binary) {
+		return;
+	}
+
+	return encoding === 'buffer' ? linesUint8ArrayGenerator : linesStringGenerator;
+};
+
+const linesUint8ArrayGenerator = async function * (chunks) {
+	yield * linesGenerator(chunks, new Uint8Array(0), 0x0A, concatUint8Array);
+};
+
+const concatUint8Array = (firstChunk, secondChunk) => {
+	const chunk = new Uint8Array(firstChunk.length + secondChunk.length);
+	chunk.set(firstChunk, 0);
+	chunk.set(secondChunk, firstChunk.length);
+	return chunk;
+};
+
+const linesStringGenerator = async function * (chunks) {
+	yield * linesGenerator(chunks, '', '\n', concatString);
+};
+
+const concatString = (firstChunk, secondChunk) => `${firstChunk}${secondChunk}`;
+
+// This imperative logic is much faster than using `String.split()` and uses very low memory.
+// Also, it allows sharing it with `Uint8Array`.
+const linesGenerator = async function * (chunks, emptyValue, newline, concat) {
+	let previousChunks = emptyValue;
+
+	for await (const chunk of chunks) {
+		let start = -1;
+
+		for (let end = 0; end < chunk.length; end += 1) {
+			if (chunk[end] === newline) {
+				let line = chunk.slice(start + 1, end + 1);
+
+				if (previousChunks.length > 0) {
+					line = concat(previousChunks, line);
+					previousChunks = emptyValue;
+				}
+
+				yield line;
+				start = end;
+			}
+		}
+
+		if (start !== chunk.length - 1) {
+			previousChunks = concat(previousChunks, chunk.slice(start + 1));
+		}
+	}
+
+	if (previousChunks.length > 0) {
+		yield previousChunks;
+	}
+};
diff --git a/lib/stdio/type.js b/lib/stdio/type.js
index 53c87ad..28cd75b 100644
--- a/lib/stdio/type.js
+++ b/lib/stdio/type.js
@@ -35,11 +35,30 @@ export const getStdioOptionType = (stdioOption, optionName) => {
 		return 'iterable';
 	}
 
+	if (isGeneratorOptions(stdioOption)) {
+		return getGeneratorObjectType(stdioOption, optionName);
+	}
+
 	return 'native';
 };
 
+const getGeneratorObjectType = ({transform, binary}, optionName) => {
+	if (!isAsyncGenerator(transform)) {
+		throw new TypeError(`The \`${optionName}.transform\` option must use an asynchronous generator.`);
+	}
+
+	if (binary !== undefined && typeof binary !== 'boolean') {
+		throw new TypeError(`The \`${optionName}.binary\` option must use a boolean.`);
+	}
+
+	return 'generator';
+};
+
 const isAsyncGenerator = stdioOption => Object.prototype.toString.call(stdioOption) === '[object AsyncGeneratorFunction]';
 const isSyncGenerator = stdioOption => Object.prototype.toString.call(stdioOption) === '[object GeneratorFunction]';
+export const isGeneratorOptions = stdioOption => typeof stdioOption === 'object'
+	&& stdioOption !== null
+	&& stdioOption.transform !== undefined;
 
 export const isUrl = stdioOption => Object.prototype.toString.call(stdioOption) === '[object URL]';
 export const isRegularUrl = stdioOption => isUrl(stdioOption) && stdioOption.protocol !== 'file:';
diff --git a/readme.md b/readme.md
index 5d0ba78..5b79233 100644
--- a/readme.md
+++ b/readme.md
@@ -47,6 +47,9 @@ This package improves [`child_process`](https://nodejs.org/api/child_process.htm
 - Improved [Windows support](https://github.com/IndigoUnited/node-cross-spawn#why), including [shebang](https://en.wikipedia.org/wiki/Shebang_(Unix)) binaries.
 - Executes [locally installed binaries](#preferlocal) without `npx`.
 - [Cleans up](#cleanup) child processes when the parent process ends.
+- Redirect [`stdin`](#stdin)/[`stdout`](#stdout-1)/[`stderr`](#stderr-1) to files, streams, iterables, strings or `Uint8Array`.
+- [Transform](docs/transform.md) `stdin`/`stdout`/`stderr` with simple functions.
+- Iterate over [each text line](docs/transform.md#binary-data) output by the process.
 - [Graceful termination](#optionsforcekillaftertimeout).
 - Get [interleaved output](#all) from `stdout` and `stderr` similar to what is printed on the terminal.
 - [Strips the final newline](#stripfinalnewline) from the output so you don't have to do `stdout.trim()`.
