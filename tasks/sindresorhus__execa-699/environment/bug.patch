diff --git a/docs/transform.md b/docs/transform.md
index 3305f0b..885031e 100644
--- a/docs/transform.md
+++ b/docs/transform.md
@@ -7,10 +7,9 @@ Transforms map or filter the input or output of a child process. They are define
 ```js
 import {execa} from 'execa';
 
-const transform = async function * (lines) {
-	for await (const line of lines) {
-		const prefix = line.includes('error') ? 'ERROR' : 'INFO'
-		yield `${prefix}: ${line}`
+const transform = async function * (chunks) {
+	for await (const chunk of chunks) {
+		yield chunk.toUpperCase();
 	}
 };
 
@@ -20,21 +19,21 @@ console.log(stdout); // HELLO
 
 ## Encoding
 
-The `lines` argument passed to the transform is an [`AsyncIterable<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#the_async_iterator_and_async_iterable_protocols). If the [`encoding`](../readme.md#encoding) option is `buffer`, it is an `AsyncIterable<Uint8Array>` instead.
+The `chunks` argument passed to the transform is an [`AsyncIterable<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#the_async_iterator_and_async_iterable_protocols). If the [`encoding`](../readme.md#encoding) option is `buffer`, it is an `AsyncIterable<Uint8Array>` instead.
 
-The transform can `yield` either a `string` or an `Uint8Array`, regardless of the `lines` argument's type.
+The transform can `yield` either a `string` or an `Uint8Array`, regardless of the `chunks` argument's type.
 
 ## Filtering
 
-`yield` can be called 0, 1 or multiple times. Not calling `yield` enables filtering a specific line.
+`yield` can be called 0, 1 or multiple times. Not calling `yield` enables filtering a specific chunk.
 
 ```js
 import {execa} from 'execa';
 
-const transform = async function * (lines) {
-	for await (const line of lines) {
-		if (!line.includes('secret')) {
-			yield line;
+const transform = async function * (chunks) {
+	for await (const chunk of chunks) {
+		if (!chunk.includes('secret')) {
+			yield chunk;
 		}
 	}
 };
@@ -43,19 +42,6 @@ const {stdout} = await execa('echo', ['This is a secret.'], {stdout: transform})
 console.log(stdout); // ''
 ```
 
-## Binary data
-
-The transform iterates over lines by default.\
-However, if a `{transform, binary: true}` plain object is passed, it iterates over arbitrary chunks of data instead.
-
-```js
-await execa('./binary.js', {stdout: {transform, binary: true}});
-```
-
-This is more efficient and recommended if the data is either:
-	- Binary: Which does not have lines.
-	- Text: But the transform works even if a line or word is split across multiple chunks.
-
 ## Combining
 
 The [`stdin`](../readme.md#stdin), [`stdout`](../readme.md#stdout-1), [`stderr`](../readme.md#stderr-1) and [`stdio`](../readme.md#stdio-1) options can accept an array of values. While this is not specific to transforms, this can be useful with them too. For example, the following transform impacts the value printed by `inherit`.
diff --git a/index.d.ts b/index.d.ts
index 6cba55b..b535073 100644
--- a/index.d.ts
+++ b/index.d.ts
@@ -18,10 +18,6 @@ type BaseStdioOption =
 	| 'ignore'
 	| 'inherit';
 
-// @todo Use either `Iterable<string>` or `Iterable<Uint8Array>` based on whether `encoding: 'buffer'` is used.
-// See https://github.com/sindresorhus/execa/issues/694
-type StdioTransform = ((chunks: Iterable<string | Uint8Array>) => AsyncGenerator<string | Uint8Array, void, void>);
-
 type CommonStdioOption<IsSync extends boolean = boolean> =
 	| BaseStdioOption
 	| 'ipc'
@@ -29,12 +25,9 @@ type CommonStdioOption<IsSync extends boolean = boolean> =
 	| undefined
 	| URL
 	| {file: string}
-	| IfAsync<IsSync,
-	| StdioTransform
-	| {
-		transform: StdioTransform;
-		binary?: boolean;
-	}>;
+	// TODO: Use either `Iterable<string>` or `Iterable<Uint8Array>` based on whether `encoding: 'buffer'` is used.
+	// See https://github.com/sindresorhus/execa/issues/694
+	| IfAsync<IsSync, ((chunks: Iterable<string | Uint8Array>) => AsyncGenerator<string | Uint8Array, void, void>)>;
 
 type InputStdioOption<IsSync extends boolean = boolean> =
 	| Uint8Array
diff --git a/index.test-d.ts b/index.test-d.ts
index 0600177..5f6c04c 100644
--- a/index.test-d.ts
+++ b/index.test-d.ts
@@ -569,35 +569,35 @@ const asyncStringGenerator = async function * () {
 
 const fileUrl = new URL('file:///test');
 
-const stringOrUint8ArrayGenerator = async function * (lines: Iterable<string | Uint8Array>) {
-	for await (const line of lines) {
-		yield line;
+const stringOrUint8ArrayGenerator = async function * (chunks: Iterable<string | Uint8Array>) {
+	for await (const chunk of chunks) {
+		yield chunk;
 	}
 };
 
-const booleanGenerator = async function * (lines: Iterable<boolean>) {
-	for await (const line of lines) {
-		yield line;
+const booleanGenerator = async function * (chunks: Iterable<boolean>) {
+	for await (const chunk of chunks) {
+		yield chunk;
 	}
 };
 
-const arrayGenerator = async function * (lines: string[]) {
-	for await (const line of lines) {
-		yield line;
+const arrayGenerator = async function * (chunks: string[]) {
+	for await (const chunk of chunks) {
+		yield chunk;
 	}
 };
 
-const invalidReturnGenerator = async function * (lines: Iterable<string>) {
-	for await (const line of lines) {
-		yield line;
+const invalidReturnGenerator = async function * (chunks: Iterable<string>) {
+	for await (const chunk of chunks) {
+		yield chunk;
 	}
 
 	return false;
 };
 
-const syncGenerator = function * (lines: Iterable<string>) {
-	for (const line of lines) {
-		yield line;
+const syncGenerator = function * (chunks: Iterable<string>) {
+	for (const chunk of chunks) {
+		yield chunk;
 	}
 
 	return false;
@@ -712,18 +712,6 @@ expectError(execa('unicorns', {stdin: booleanGenerator}));
 expectError(execa('unicorns', {stdin: arrayGenerator}));
 expectError(execa('unicorns', {stdin: invalidReturnGenerator}));
 expectError(execa('unicorns', {stdin: syncGenerator}));
-execa('unicorns', {stdin: {transform: stringOrUint8ArrayGenerator}});
-expectError(execaSync('unicorns', {stdin: {transform: stringOrUint8ArrayGenerator}}));
-execa('unicorns', {stdin: [{transform: stringOrUint8ArrayGenerator}]});
-expectError(execaSync('unicorns', {stdin: [{transform: stringOrUint8ArrayGenerator}]}));
-expectError(execa('unicorns', {stdin: {transform: booleanGenerator}}));
-expectError(execa('unicorns', {stdin: {transform: arrayGenerator}}));
-expectError(execa('unicorns', {stdin: {transform: invalidReturnGenerator}}));
-expectError(execa('unicorns', {stdin: {transform: syncGenerator}}));
-expectError(execa('unicorns', {stdin: {}}));
-expectError(execa('unicorns', {stdin: {binary: true}}));
-execa('unicorns', {stdin: {transform: stringOrUint8ArrayGenerator, binary: true}});
-expectError(execa('unicorns', {stdin: {transform: stringOrUint8ArrayGenerator, binary: 'true'}}));
 execa('unicorns', {stdin: undefined});
 execaSync('unicorns', {stdin: undefined});
 execa('unicorns', {stdin: [undefined]});
@@ -790,18 +778,6 @@ expectError(execa('unicorns', {stdout: booleanGenerator}));
 expectError(execa('unicorns', {stdout: arrayGenerator}));
 expectError(execa('unicorns', {stdout: invalidReturnGenerator}));
 expectError(execa('unicorns', {stdout: syncGenerator}));
-execa('unicorns', {stdout: {transform: stringOrUint8ArrayGenerator}});
-expectError(execaSync('unicorns', {stdout: {transform: stringOrUint8ArrayGenerator}}));
-execa('unicorns', {stdout: [{transform: stringOrUint8ArrayGenerator}]});
-expectError(execaSync('unicorns', {stdout: [{transform: stringOrUint8ArrayGenerator}]}));
-expectError(execa('unicorns', {stdout: {transform: booleanGenerator}}));
-expectError(execa('unicorns', {stdout: {transform: arrayGenerator}}));
-expectError(execa('unicorns', {stdout: {transform: invalidReturnGenerator}}));
-expectError(execa('unicorns', {stdout: {transform: syncGenerator}}));
-expectError(execa('unicorns', {stdout: {}}));
-expectError(execa('unicorns', {stdout: {binary: true}}));
-execa('unicorns', {stdout: {transform: stringOrUint8ArrayGenerator, binary: true}});
-expectError(execa('unicorns', {stdout: {transform: stringOrUint8ArrayGenerator, binary: 'true'}}));
 execa('unicorns', {stdout: undefined});
 execaSync('unicorns', {stdout: undefined});
 execa('unicorns', {stdout: [undefined]});
@@ -868,18 +844,6 @@ expectError(execa('unicorns', {stderr: booleanGenerator}));
 expectError(execa('unicorns', {stderr: arrayGenerator}));
 expectError(execa('unicorns', {stderr: invalidReturnGenerator}));
 expectError(execa('unicorns', {stderr: syncGenerator}));
-execa('unicorns', {stderr: {transform: stringOrUint8ArrayGenerator}});
-expectError(execaSync('unicorns', {stderr: {transform: stringOrUint8ArrayGenerator}}));
-execa('unicorns', {stderr: [{transform: stringOrUint8ArrayGenerator}]});
-expectError(execaSync('unicorns', {stderr: [{transform: stringOrUint8ArrayGenerator}]}));
-expectError(execa('unicorns', {stderr: {transform: booleanGenerator}}));
-expectError(execa('unicorns', {stderr: {transform: arrayGenerator}}));
-expectError(execa('unicorns', {stderr: {transform: invalidReturnGenerator}}));
-expectError(execa('unicorns', {stderr: {transform: syncGenerator}}));
-expectError(execa('unicorns', {stderr: {}}));
-expectError(execa('unicorns', {stderr: {binary: true}}));
-execa('unicorns', {stderr: {transform: stringOrUint8ArrayGenerator, binary: true}});
-expectError(execa('unicorns', {stderr: {transform: stringOrUint8ArrayGenerator, binary: 'true'}}));
 execa('unicorns', {stderr: undefined});
 execaSync('unicorns', {stderr: undefined});
 execa('unicorns', {stderr: [undefined]});
@@ -918,8 +882,6 @@ expectError(execa('unicorns', {stdio: 1}));
 expectError(execaSync('unicorns', {stdio: 1}));
 expectError(execa('unicorns', {stdio: stringOrUint8ArrayGenerator}));
 expectError(execaSync('unicorns', {stdio: stringOrUint8ArrayGenerator}));
-expectError(execa('unicorns', {stdio: {transform: stringOrUint8ArrayGenerator}}));
-expectError(execaSync('unicorns', {stdio: {transform: stringOrUint8ArrayGenerator}}));
 expectError(execa('unicorns', {stdio: fileUrl}));
 expectError(execaSync('unicorns', {stdio: fileUrl}));
 expectError(execa('unicorns', {stdio: {file: './test'}}));
@@ -972,8 +934,6 @@ execa('unicorns', {
 		process.stdin,
 		1,
 		stringOrUint8ArrayGenerator,
-		{transform: stringOrUint8ArrayGenerator},
-		{transform: stringOrUint8ArrayGenerator, binary: true},
 		undefined,
 		fileUrl,
 		{file: './test'},
@@ -1002,7 +962,6 @@ execaSync('unicorns', {
 	],
 });
 expectError(execaSync('unicorns', {stdio: [stringOrUint8ArrayGenerator]}));
-expectError(execaSync('unicorns', {stdio: [{transform: stringOrUint8ArrayGenerator}]}));
 expectError(execaSync('unicorns', {stdio: [new Writable()]}));
 expectError(execaSync('unicorns', {stdio: [new Readable()]}));
 expectError(execaSync('unicorns', {stdio: [new WritableStream()]}));
@@ -1020,8 +979,6 @@ execa('unicorns', {
 		[process.stdin],
 		[1],
 		[stringOrUint8ArrayGenerator],
-		[{transform: stringOrUint8ArrayGenerator}],
-		[{transform: stringOrUint8ArrayGenerator, binary: true}],
 		[undefined],
 		[fileUrl],
 		[{file: './test'}],
@@ -1051,7 +1008,6 @@ execaSync('unicorns', {
 	],
 });
 expectError(execaSync('unicorns', {stdio: [[stringOrUint8ArrayGenerator]]}));
-expectError(execaSync('unicorns', {stdio: [[{transform: stringOrUint8ArrayGenerator}]]}));
 expectError(execaSync('unicorns', {stdio: [[new Writable()]]}));
 expectError(execaSync('unicorns', {stdio: [[new Readable()]]}));
 expectError(execaSync('unicorns', {stdio: [[new WritableStream()]]}));
diff --git a/lib/stdio/encoding.js b/lib/stdio/encoding.js
index 5462e24..06802a3 100644
--- a/lib/stdio/encoding.js
+++ b/lib/stdio/encoding.js
@@ -7,16 +7,8 @@ export const handleStreamsEncoding = (stdioStreams, {encoding}, isSync) => {
 		return stdioStreams.map(stdioStream => ({...stdioStream, encoding}));
 	}
 
-	const transform = encodingEndGenerator.bind(undefined, encoding);
-	return [
-		...stdioStreams,
-		{
-			...stdioStreams[0],
-			type: 'generator',
-			value: {transform, binary: true},
-			encoding: 'buffer',
-		},
-	];
+	const value = encodingEndGenerator.bind(undefined, encoding);
+	return [...stdioStreams, {...stdioStreams[0], type: 'generator', value, encoding: 'buffer'}];
 };
 
 // eslint-disable-next-line unicorn/text-encoding-identifier-case
diff --git a/lib/stdio/generator.js b/lib/stdio/generator.js
index d97227f..fa5e3b4 100644
--- a/lib/stdio/generator.js
+++ b/lib/stdio/generator.js
@@ -1,7 +1,5 @@
 import {generatorsToDuplex} from './duplex.js';
 import {getEncodingStartGenerator} from './encoding.js';
-import {getLinesGenerator} from './lines.js';
-import {isGeneratorOptions} from './type.js';
 
 /*
 Generators can be used to transform/filter standard streams.
@@ -22,12 +20,7 @@ We ensure `objectMode` is `false` for better buffering.
 Chunks are currently processed serially. We could add a `concurrency` option to parallelize in the future.
 */
 export const generatorToDuplexStream = ({value, encoding}) => {
-	const {transform, binary} = isGeneratorOptions(value) ? value : {transform: value};
-	const generators = [
-		getEncodingStartGenerator(encoding),
-		getLinesGenerator(encoding, binary),
-		transform,
-	].filter(Boolean);
+	const generators = [getEncodingStartGenerator(encoding), value];
 	const duplexStream = generatorsToDuplex(generators, {objectMode: false});
 	return {value: duplexStream};
 };
diff --git a/lib/stdio/lines.js b/lib/stdio/lines.js
deleted file mode 100644
index 04fba41..0000000
--- a/lib/stdio/lines.js
+++ /dev/null
@@ -1,57 +0,0 @@
-// Split chunks line-wise
-export const getLinesGenerator = (encoding, binary) => {
-	if (binary) {
-		return;
-	}
-
-	return encoding === 'buffer' ? linesUint8ArrayGenerator : linesStringGenerator;
-};
-
-const linesUint8ArrayGenerator = async function * (chunks) {
-	yield * linesGenerator(chunks, new Uint8Array(0), 0x0A, concatUint8Array);
-};
-
-const concatUint8Array = (firstChunk, secondChunk) => {
-	const chunk = new Uint8Array(firstChunk.length + secondChunk.length);
-	chunk.set(firstChunk, 0);
-	chunk.set(secondChunk, firstChunk.length);
-	return chunk;
-};
-
-const linesStringGenerator = async function * (chunks) {
-	yield * linesGenerator(chunks, '', '\n', concatString);
-};
-
-const concatString = (firstChunk, secondChunk) => `${firstChunk}${secondChunk}`;
-
-// This imperative logic is much faster than using `String.split()` and uses very low memory.
-// Also, it allows sharing it with `Uint8Array`.
-const linesGenerator = async function * (chunks, emptyValue, newline, concat) {
-	let previousChunks = emptyValue;
-
-	for await (const chunk of chunks) {
-		let start = -1;
-
-		for (let end = 0; end < chunk.length; end += 1) {
-			if (chunk[end] === newline) {
-				let line = chunk.slice(start + 1, end + 1);
-
-				if (previousChunks.length > 0) {
-					line = concat(previousChunks, line);
-					previousChunks = emptyValue;
-				}
-
-				yield line;
-				start = end;
-			}
-		}
-
-		if (start !== chunk.length - 1) {
-			previousChunks = concat(previousChunks, chunk.slice(start + 1));
-		}
-	}
-
-	if (previousChunks.length > 0) {
-		yield previousChunks;
-	}
-};
diff --git a/lib/stdio/type.js b/lib/stdio/type.js
index 28cd75b..53c87ad 100644
--- a/lib/stdio/type.js
+++ b/lib/stdio/type.js
@@ -35,30 +35,11 @@ export const getStdioOptionType = (stdioOption, optionName) => {
 		return 'iterable';
 	}
 
-	if (isGeneratorOptions(stdioOption)) {
-		return getGeneratorObjectType(stdioOption, optionName);
-	}
-
 	return 'native';
 };
 
-const getGeneratorObjectType = ({transform, binary}, optionName) => {
-	if (!isAsyncGenerator(transform)) {
-		throw new TypeError(`The \`${optionName}.transform\` option must use an asynchronous generator.`);
-	}
-
-	if (binary !== undefined && typeof binary !== 'boolean') {
-		throw new TypeError(`The \`${optionName}.binary\` option must use a boolean.`);
-	}
-
-	return 'generator';
-};
-
 const isAsyncGenerator = stdioOption => Object.prototype.toString.call(stdioOption) === '[object AsyncGeneratorFunction]';
 const isSyncGenerator = stdioOption => Object.prototype.toString.call(stdioOption) === '[object GeneratorFunction]';
-export const isGeneratorOptions = stdioOption => typeof stdioOption === 'object'
-	&& stdioOption !== null
-	&& stdioOption.transform !== undefined;
 
 export const isUrl = stdioOption => Object.prototype.toString.call(stdioOption) === '[object URL]';
 export const isRegularUrl = stdioOption => isUrl(stdioOption) && stdioOption.protocol !== 'file:';
diff --git a/readme.md b/readme.md
index 5b79233..5d0ba78 100644
--- a/readme.md
+++ b/readme.md
@@ -47,9 +47,6 @@ This package improves [`child_process`](https://nodejs.org/api/child_process.htm
 - Improved [Windows support](https://github.com/IndigoUnited/node-cross-spawn#why), including [shebang](https://en.wikipedia.org/wiki/Shebang_(Unix)) binaries.
 - Executes [locally installed binaries](#preferlocal) without `npx`.
 - [Cleans up](#cleanup) child processes when the parent process ends.
-- Redirect [`stdin`](#stdin)/[`stdout`](#stdout-1)/[`stderr`](#stderr-1) to files, streams, iterables, strings or `Uint8Array`.
-- [Transform](docs/transform.md) `stdin`/`stdout`/`stderr` with simple functions.
-- Iterate over [each text line](docs/transform.md#binary-data) output by the process.
 - [Graceful termination](#optionsforcekillaftertimeout).
 - Get [interleaved output](#all) from `stdout` and `stderr` similar to what is printed on the terminal.
 - [Strips the final newline](#stripfinalnewline) from the output so you don't have to do `stdout.trim()`.
diff --git a/test/fixtures/nested-inherit.js b/test/fixtures/nested-inherit.js
index 8a12bdc..219c336 100755
--- a/test/fixtures/nested-inherit.js
+++ b/test/fixtures/nested-inherit.js
@@ -1,9 +1,9 @@
 #!/usr/bin/env node
 import {execa} from '../../index.js';
 
-const uppercaseGenerator = async function * (lines) {
-	for await (const line of lines) {
-		yield line.toUpperCase();
+const uppercaseGenerator = async function * (chunks) {
+	for await (const chunk of chunks) {
+		yield chunk.toUpperCase();
 	}
 };
 
diff --git a/test/stdio/encoding.js b/test/stdio/encoding.js
index c567c98..92eba89 100644
--- a/test/stdio/encoding.js
+++ b/test/stdio/encoding.js
@@ -132,9 +132,9 @@ test('validate unknown encodings', async t => {
 
 const foobarArray = ['fo', 'ob', 'ar', '..'];
 
-const delayedGenerator = async function * (lines) {
+const delayedGenerator = async function * (chunks) {
 	// eslint-disable-next-line no-unused-vars
-	for await (const line of lines) {
+	for await (const chunk of chunks) {
 		yield foobarArray[0];
 		await setTimeout(0);
 		yield foobarArray[1];
diff --git a/test/stdio/generator.js b/test/stdio/generator.js
index 46d1827..9ad9680 100644
--- a/test/stdio/generator.js
+++ b/test/stdio/generator.js
@@ -16,9 +16,9 @@ const foobarUppercase = foobarString.toUpperCase();
 const foobarBuffer = Buffer.from(foobarString);
 const foobarUint8Array = new TextEncoder().encode(foobarString);
 
-const uppercaseGenerator = async function * (lines) {
-	for await (const line of lines) {
-		yield line.toUpperCase();
+const uppercaseGenerator = async function * (chunks) {
+	for await (const chunk of chunks) {
+		yield chunk.toUpperCase();
 	}
 };
 
@@ -99,35 +99,16 @@ test('Can use generators with input option', async t => {
 
 const syncGenerator = function * () {};
 
-const testInvalidGenerator = (t, index, stdioOption) => {
+const testSyncGenerator = (t, index) => {
 	t.throws(() => {
-		execa('empty.js', getStdio(index, stdioOption));
+		execa('empty.js', getStdio(index, syncGenerator));
 	}, {message: /asynchronous generator/});
 };
 
-test('Cannot use sync generators with stdin', testInvalidGenerator, 0, syncGenerator);
-test('Cannot use sync generators with stdout', testInvalidGenerator, 1, syncGenerator);
-test('Cannot use sync generators with stderr', testInvalidGenerator, 2, syncGenerator);
-test('Cannot use sync generators with stdio[*]', testInvalidGenerator, 3, syncGenerator);
-test('Cannot use sync generators with stdin, with options', testInvalidGenerator, 0, {transform: syncGenerator});
-test('Cannot use sync generators with stdout, with options', testInvalidGenerator, 1, {transform: syncGenerator});
-test('Cannot use sync generators with stderr, with options', testInvalidGenerator, 2, {transform: syncGenerator});
-test('Cannot use sync generators with stdio[*], with options', testInvalidGenerator, 3, {transform: syncGenerator});
-test('Cannot use invalid "transform" with stdin', testInvalidGenerator, 0, {transform: true});
-test('Cannot use invalid "transform" with stdout', testInvalidGenerator, 1, {transform: true});
-test('Cannot use invalid "transform" with stderr', testInvalidGenerator, 2, {transform: true});
-test('Cannot use invalid "transform" with stdio[*]', testInvalidGenerator, 3, {transform: true});
-
-const testInvalidBinary = (t, index) => {
-	t.throws(() => {
-		execa('empty.js', getStdio(index, {transform: uppercaseGenerator, binary: 'true'}));
-	}, {message: /a boolean/});
-};
-
-test('Cannot use invalid "binary" with stdin', testInvalidBinary, 0);
-test('Cannot use invalid "binary" with stdout', testInvalidBinary, 1);
-test('Cannot use invalid "binary" with stderr', testInvalidBinary, 2);
-test('Cannot use invalid "binary" with stdio[*]', testInvalidBinary, 3);
+test('Cannot use sync generators with stdin', testSyncGenerator, 0);
+test('Cannot use sync generators with stdout', testSyncGenerator, 1);
+test('Cannot use sync generators with stderr', testSyncGenerator, 2);
+test('Cannot use sync generators with stdio[*]', testSyncGenerator, 3);
 
 const testSyncMethods = (t, index) => {
 	t.throws(() => {
@@ -142,42 +123,30 @@ test('Cannot use generators with sync methods and stdio[*]', testSyncMethods, 3)
 
 const repeatHighWaterMark = 10;
 
-const writerGenerator = async function * (lines) {
+const writerGenerator = async function * (chunks) {
 	// eslint-disable-next-line no-unused-vars
-	for await (const line of lines) {
+	for await (const chunk of chunks) {
 		for (let index = 0; index < getDefaultHighWaterMark() * repeatHighWaterMark; index += 1) {
-			yield '\n';
+			yield '.';
 		}
 	}
 };
 
 const passThroughGenerator = async function * (chunks) {
-	yield * chunks;
-};
-
-const getLengthGenerator = async function * (chunks) {
 	for await (const chunk of chunks) {
 		yield `${chunk.length}`;
 	}
 };
 
-const testHighWaterMark = async (t, passThrough) => {
+test('Stream respects highWaterMark', async t => {
 	const index = 1;
-	const {stdout} = await execa('noop-fd.js', [`${index}`], getStdio(index, [
-		writerGenerator,
-		...passThrough,
-		{transform: getLengthGenerator, binary: true},
-	]));
+	const {stdout} = await execa('noop-fd.js', [`${index}`], getStdio(index, [writerGenerator, passThroughGenerator]));
 	t.is(stdout, `${getDefaultHighWaterMark()}`.repeat(repeatHighWaterMark));
-};
-
-test('Stream respects highWaterMark, no passThrough', testHighWaterMark, []);
-test('Stream respects highWaterMark, line-wise passThrough', testHighWaterMark, [passThroughGenerator]);
-test('Stream respects highWaterMark, binary passThrough', testHighWaterMark, [{transform: passThroughGenerator, binary: true}]);
+});
 
-const typeofGenerator = async function * (lines) {
-	for await (const line of lines) {
-		yield Object.prototype.toString.call(line);
+const typeofGenerator = async function * (chunks) {
+	for await (const chunk of chunks) {
+		yield Object.prototype.toString.call(chunk);
 	}
 };
 
@@ -199,9 +168,9 @@ test('First generator argument is Uint8Array with encoding "hex", with string wr
 test('First generator argument is Uint8Array with encoding "hex", with Buffer writes', testGeneratorFirstEncoding, foobarBuffer, 'hex');
 test('First generator argument is Uint8Array with encoding "hex", with Uint8Array writes', testGeneratorFirstEncoding, foobarUint8Array, 'hex');
 
-const outputGenerator = async function * (input, lines) {
+const outputGenerator = async function * (input, chunks) {
 	// eslint-disable-next-line no-unused-vars
-	for await (const line of lines) {
+	for await (const chunk of chunks) {
 		yield input;
 	}
 };
@@ -241,8 +210,10 @@ const multibyteUint8Array = new TextEncoder().encode(multibyteString);
 const breakingLength = multibyteUint8Array.length * 0.75;
 const brokenSymbol = '\uFFFD';
 
-const noopGenerator = async function * (lines) {
-	yield * lines;
+const noopGenerator = async function * (chunks) {
+	for await (const chunk of chunks) {
+		yield chunk;
+	}
 };
 
 test('Generator handles multibyte characters with Uint8Array', async t => {
@@ -260,9 +231,9 @@ test('Generator handles partial multibyte characters with Uint8Array', async t =
 });
 
 // eslint-disable-next-line require-yield
-const noYieldGenerator = async function * (lines) {
+const noYieldGenerator = async function * (chunks) {
 	// eslint-disable-next-line no-empty, no-unused-vars
-	for await (const line of lines) {}
+	for await (const chunk of chunks) {}
 };
 
 test('Generator can filter by not calling yield', async t => {
@@ -273,11 +244,11 @@ test('Generator can filter by not calling yield', async t => {
 const prefix = '> ';
 const suffix = ' <';
 
-const multipleYieldGenerator = async function * (lines) {
-	for await (const line of lines) {
+const multipleYieldGenerator = async function * (chunks) {
+	for await (const chunk of chunks) {
 		yield prefix;
 		await setTimeout(0);
-		yield line;
+		yield chunk;
 		await setTimeout(0);
 		yield suffix;
 	}
@@ -340,9 +311,9 @@ test('Can use generators with "inherit"', async t => {
 
 const casedSuffix = 'k';
 
-const appendGenerator = async function * (lines) {
-	for await (const line of lines) {
-		yield `${line}${casedSuffix}`;
+const appendGenerator = async function * (chunks) {
+	for await (const chunk of chunks) {
+		yield `${chunk}${casedSuffix}`;
 	}
 };
 
@@ -383,10 +354,10 @@ test('Generators take "maxBuffer" into account', async t => {
 	await t.throwsAsync(execa('noop.js', {maxBuffer, stdout: outputGenerator.bind(undefined, `${bigString}.`)}));
 });
 
-const timeoutGenerator = async function * (timeout, lines) {
-	for await (const line of lines) {
+const timeoutGenerator = async function * (timeout, chunks) {
+	for await (const chunk of chunks) {
 		await setTimeout(timeout);
-		yield line;
+		yield chunk;
 	}
 };
 
@@ -396,10 +367,10 @@ test('Generators are awaited on success', async t => {
 });
 
 // eslint-disable-next-line require-yield
-const throwingGenerator = async function * (lines) {
+const throwingGenerator = async function * (chunks) {
 	// eslint-disable-next-line no-unreachable-loop
-	for await (const line of lines) {
-		throw new Error(`Generator error ${line}`);
+	for await (const chunk of chunks) {
+		throw new Error(`Generator error ${chunk}`);
 	}
 };
 
@@ -411,10 +382,10 @@ test('Generators errors make process fail', async t => {
 });
 
 // eslint-disable-next-line require-yield
-const errorHandlerGenerator = async function * (state, lines) {
+const errorHandlerGenerator = async function * (state, chunks) {
 	try {
 		// eslint-disable-next-line no-unused-vars
-		for await (const line of lines) {
+		for await (const chunk of chunks) {
 			await setTimeout(1e8);
 		}
 	} catch (error) {
diff --git a/test/stdio/lines.js b/test/stdio/lines.js
deleted file mode 100644
index 788c423..0000000
--- a/test/stdio/lines.js
+++ /dev/null
@@ -1,94 +0,0 @@
-import {scheduler} from 'node:timers/promises';
-import test from 'ava';
-import {execa} from '../../index.js';
-import {setFixtureDir} from '../helpers/fixtures-dir.js';
-import {getStdio} from '../helpers/stdio.js';
-
-setFixtureDir();
-
-const bigLine = '.'.repeat(1e5);
-const manyChunks = Array.from({length: 1e3}).fill('.');
-
-const inputGenerator = async function * (input, chunks) {
-	// eslint-disable-next-line no-unused-vars
-	for await (const chunk of chunks) {
-		for (const inputItem of input) {
-			yield inputItem;
-			// eslint-disable-next-line no-await-in-loop
-			await scheduler.yield();
-		}
-	}
-};
-
-const resultGenerator = async function * (lines, chunks) {
-	for await (const chunk of chunks) {
-		lines.push(chunk);
-		yield chunk;
-	}
-};
-
-const textEncoder = new TextEncoder();
-const textDecoder = new TextDecoder();
-
-const stringsToUint8Arrays = (strings, isUint8Array) => isUint8Array
-	? strings.map(string => textEncoder.encode(string))
-	: strings;
-const uint8ArrayToString = (result, isUint8Array) => isUint8Array ? textDecoder.decode(result) : result;
-
-// eslint-disable-next-line max-params
-const testLines = async (t, index, input, expectedLines, isUint8Array) => {
-	const lines = [];
-	const {stdio} = await execa('noop-fd.js', [`${index}`], {
-		...getStdio(index, [
-			inputGenerator.bind(undefined, stringsToUint8Arrays(input, isUint8Array)),
-			resultGenerator.bind(undefined, lines),
-		]),
-		encoding: isUint8Array ? 'buffer' : 'utf8',
-		stripFinalNewline: false,
-	});
-	t.is(uint8ArrayToString(stdio[index], isUint8Array), input.join(''));
-	t.deepEqual(lines, stringsToUint8Arrays(expectedLines, isUint8Array));
-};
-
-test('Split string stdout - n newlines, 1 chunk', testLines, 1, ['aaa\nbbb\nccc'], ['aaa\n', 'bbb\n', 'ccc'], false);
-test('Split string stderr - n newlines, 1 chunk', testLines, 2, ['aaa\nbbb\nccc'], ['aaa\n', 'bbb\n', 'ccc'], false);
-test('Split string stdio[*] - n newlines, 1 chunk', testLines, 3, ['aaa\nbbb\nccc'], ['aaa\n', 'bbb\n', 'ccc'], false);
-test('Split string stdout - no newline, n chunks', testLines, 1, ['aaa', 'bbb', 'ccc'], ['aaabbbccc'], false);
-test('Split string stdout - 0 newlines, 1 chunk', testLines, 1, ['aaa'], ['aaa'], false);
-test('Split string stdout - Windows newlines', testLines, 1, ['aaa\r\nbbb\r\nccc'], ['aaa\r\n', 'bbb\r\n', 'ccc'], false);
-test('Split string stdout - chunk ends with newline', testLines, 1, ['aaa\nbbb\nccc\n'], ['aaa\n', 'bbb\n', 'ccc\n'], false);
-test('Split string stdout - single newline', testLines, 1, ['\n'], ['\n'], false);
-test('Split string stdout - only newlines', testLines, 1, ['\n\n\n'], ['\n', '\n', '\n'], false);
-test('Split string stdout - only Windows newlines', testLines, 1, ['\r\n\r\n\r\n'], ['\r\n', '\r\n', '\r\n'], false);
-test('Split string stdout - line split over multiple chunks', testLines, 1, ['aaa\nb', 'b', 'b\nccc'], ['aaa\n', 'bbb\n', 'ccc'], false);
-test('Split string stdout - 0 newlines, big line', testLines, 1, [bigLine], [bigLine], false);
-test('Split string stdout - 0 newlines, many chunks', testLines, 1, manyChunks, [manyChunks.join('')], false);
-test('Split Uint8Array stdout - n newlines, 1 chunk', testLines, 1, ['aaa\nbbb\nccc'], ['aaa\n', 'bbb\n', 'ccc'], true);
-test('Split Uint8Array stderr - n newlines, 1 chunk', testLines, 2, ['aaa\nbbb\nccc'], ['aaa\n', 'bbb\n', 'ccc'], true);
-test('Split Uint8Array stdio[*] - n newlines, 1 chunk', testLines, 3, ['aaa\nbbb\nccc'], ['aaa\n', 'bbb\n', 'ccc'], true);
-test('Split Uint8Array stdout - no newline, n chunks', testLines, 1, ['aaa', 'bbb', 'ccc'], ['aaabbbccc'], true);
-test('Split Uint8Array stdout - 0 newlines, 1 chunk', testLines, 1, ['aaa'], ['aaa'], true);
-test('Split Uint8Array stdout - Windows newlines', testLines, 1, ['aaa\r\nbbb\r\nccc'], ['aaa\r\n', 'bbb\r\n', 'ccc'], true);
-test('Split Uint8Array stdout - chunk ends with newline', testLines, 1, ['aaa\nbbb\nccc\n'], ['aaa\n', 'bbb\n', 'ccc\n'], true);
-test('Split Uint8Array stdout - single newline', testLines, 1, ['\n'], ['\n'], true);
-test('Split Uint8Array stdout - only newlines', testLines, 1, ['\n\n\n'], ['\n', '\n', '\n'], true);
-test('Split Uint8Array stdout - only Windows newlines', testLines, 1, ['\r\n\r\n\r\n'], ['\r\n', '\r\n', '\r\n'], true);
-test('Split Uint8Array stdout - line split over multiple chunks', testLines, 1, ['aaa\nb', 'b', 'b\nccc'], ['aaa\n', 'bbb\n', 'ccc'], true);
-test('Split Uint8Array stdout - 0 newlines, big line', testLines, 1, [bigLine], [bigLine], true);
-test('Split Uint8Array stdout - 0 newlines, many chunks', testLines, 1, manyChunks, [manyChunks.join('')], true);
-
-const testBinaryOption = async (t, binary, input, expectedLines) => {
-	const lines = [];
-	const {stdout} = await execa('noop-fd.js', ['1'], {
-		stdout: [
-			inputGenerator.bind(undefined, input),
-			{transform: resultGenerator.bind(undefined, lines), binary},
-		],
-	});
-	t.is(stdout, input.join(''));
-	t.deepEqual(lines, expectedLines);
-};
-
-test('Does not split lines when "binary" is true', testBinaryOption, true, ['aaa\nbbb\nccc'], ['aaa\nbbb\nccc']);
-test('Splits lines when "binary" is false', testBinaryOption, false, ['aaa\nbbb\nccc'], ['aaa\n', 'bbb\n', 'ccc']);
-test('Splits lines when "binary" is undefined', testBinaryOption, undefined, ['aaa\nbbb\nccc'], ['aaa\n', 'bbb\n', 'ccc']);
