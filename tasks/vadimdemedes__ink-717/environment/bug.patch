diff --git a/src/devtools-window-polyfill.ts b/src/devtools-window-polyfill.ts
index e3ed695..7ce8285 100644
--- a/src/devtools-window-polyfill.ts
+++ b/src/devtools-window-polyfill.ts
@@ -5,7 +5,6 @@ import ws from 'ws';
 const customGlobal = global as any;
 
 // These things must exist before importing `react-devtools-core`
-// eslint-disable-next-line n/no-unsupported-features/node-builtins
 customGlobal.WebSocket ||= ws;
 
 customGlobal.window ||= global;
diff --git a/src/ink.tsx b/src/ink.tsx
index 2ed09f5..c5098e5 100644
--- a/src/ink.tsx
+++ b/src/ink.tsx
@@ -34,7 +34,6 @@ export default class Ink {
 	// Ignore last render after unmounting a tree to prevent empty output before exit
 	private isUnmounted: boolean;
 	private lastOutput: string;
-	private lastOutputHeight: number;
 	private readonly container: FiberRoot;
 	private readonly rootNode: dom.DOMElement;
 	// This variable is used only in debug mode to store full static output
@@ -72,7 +71,6 @@ export default class Ink {
 
 		// Store last output to only rerender when needed
 		this.lastOutput = '';
-		this.lastOutputHeight = 0;
 
 		// This variable is used only in debug mode to store full static output
 		// so that it's rerendered every time, not just new static parts, like in non-debug mode
@@ -165,7 +163,6 @@ export default class Ink {
 			}
 
 			this.lastOutput = output;
-			this.lastOutputHeight = outputHeight;
 			return;
 		}
 
@@ -173,13 +170,11 @@ export default class Ink {
 			this.fullStaticOutput += staticOutput;
 		}
 
-		if (this.lastOutputHeight >= this.options.stdout.rows) {
+		if (outputHeight >= this.options.stdout.rows) {
 			this.options.stdout.write(
-				ansiEscapes.clearTerminal + this.fullStaticOutput + output + '\n',
+				ansiEscapes.clearTerminal + this.fullStaticOutput + output,
 			);
 			this.lastOutput = output;
-			this.lastOutputHeight = outputHeight;
-			this.log.sync(output);
 			return;
 		}
 
@@ -195,7 +190,6 @@ export default class Ink {
 		}
 
 		this.lastOutput = output;
-		this.lastOutputHeight = outputHeight;
 	};
 
 	render(node: ReactNode): void {
diff --git a/src/log-update.ts b/src/log-update.ts
index 33458e0..a38e565 100644
--- a/src/log-update.ts
+++ b/src/log-update.ts
@@ -5,7 +5,6 @@ import cliCursor from 'cli-cursor';
 export type LogUpdate = {
 	clear: () => void;
 	done: () => void;
-	sync: (str: string) => void;
 	(str: string): void;
 };
 
@@ -46,12 +45,6 @@ const create = (stream: Writable, {showCursor = false} = {}): LogUpdate => {
 		}
 	};
 
-	render.sync = (str: string) => {
-		const output = str + '\n';
-		previousOutput = output;
-		previousLineCount = output.split('\n').length;
-	};
-
 	return render;
 };
 
diff --git a/test/fixtures/erase-with-state-change.tsx b/test/fixtures/erase-with-state-change.tsx
deleted file mode 100644
index 0cd7c50..0000000
--- a/test/fixtures/erase-with-state-change.tsx
+++ /dev/null
@@ -1,32 +0,0 @@
-import process from 'node:process';
-import React, {useEffect, useState} from 'react';
-import {Box, Text, render} from '../../src/index.js';
-
-function Erase() {
-	const [show, setShow] = useState(true);
-
-	useEffect(() => {
-		const timer = setTimeout(() => {
-			setShow(false);
-		});
-
-		return () => {
-			clearTimeout(timer);
-		};
-	}, []);
-
-	return (
-		<Box flexDirection="column">
-			{show && (
-				<>
-					<Text>A</Text>
-					<Text>B</Text>
-					<Text>C</Text>
-				</>
-			)}
-		</Box>
-	);
-}
-
-process.stdout.rows = Number(process.argv[2]);
-render(<Erase />);
diff --git a/test/render.tsx b/test/render.tsx
index 565a6f2..907e944 100644
--- a/test/render.tsx
+++ b/test/render.tsx
@@ -120,29 +120,6 @@ test.serial(
 	},
 );
 
-test.serial('erase screen where state changes', async t => {
-	const ps = term('erase-with-state-change', ['4']);
-	await ps.waitForExit();
-
-	const secondFrame = ps.output.split(ansiEscapes.eraseLines(3))[1];
-
-	for (const letter of ['A', 'B', 'C']) {
-		t.false(secondFrame?.includes(letter));
-	}
-});
-
-test.serial('erase screen where state changes in small viewport', async t => {
-	const ps = term('erase-with-state-change', ['3']);
-	await ps.waitForExit();
-
-	const frames = ps.output.split(ansiEscapes.clearTerminal);
-	const lastFrame = frames.at(-1);
-
-	for (const letter of ['A', 'B', 'C']) {
-		t.false(lastFrame?.includes(letter));
-	}
-});
-
 test.serial('clear output', async t => {
 	const ps = term('clear');
 	await ps.waitForExit();
