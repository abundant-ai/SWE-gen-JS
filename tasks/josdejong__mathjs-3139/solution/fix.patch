diff --git a/HISTORY.md b/HISTORY.md
index e7586a138..0edf5ca75 100644
--- a/HISTORY.md
+++ b/HISTORY.md
@@ -1,12 +1,6 @@
 # History
 
 
-# Unpublished changes since 12.3.2
-
-- Docs: describe method `getAllAsMap` in the Parser docs (#3158, #3157).
-  Thanks @dvd101x.
-
-
 # 2024-02-08, 12.3.2
 
 - Improved the performance of custom defined functions in the expression
diff --git a/docs/expressions/parsing.md b/docs/expressions/parsing.md
index b11eb8132..9e8d1cbc8 100644
--- a/docs/expressions/parsing.md
+++ b/docs/expressions/parsing.md
@@ -167,9 +167,7 @@ The parser contains the following functions:
 - `get(name)`
   Retrieve a variable or function from the parser's scope.
 - `getAll()`
-  Retrieve an object with all defined variables in the parser's scope.
-- `getAllAsMap()`
-  Retrieve a map with all defined variables in the parser's scope.
+  Retrieve a map with all defined a variables from the parser's scope.
 - `remove(name)`
   Remove a variable or function from the parser's scope.
 - `set(name, value)`
diff --git a/docs/expressions/syntax.md b/docs/expressions/syntax.md
index a21f1d62c..722f8084a 100644
--- a/docs/expressions/syntax.md
+++ b/docs/expressions/syntax.md
@@ -472,6 +472,19 @@ parser.evaluate('i * i')        // Number,  -1
 parser.evaluate('sqrt(-4)')     // Complex, 2i
 ```
 
+Math.js does not automatically convert complex numbers with an imaginary part
+of zero to numbers. They can be converted to a number using the function
+`number`.
+
+```js
+// convert a complex number to a number
+const parser = math.parser()
+parser.evaluate('a = 2 + 3i')   // Complex, 2 + 3i
+parser.evaluate('b = a - 3i')   // Complex, 2 + 0i
+parser.evaluate('number(b)')    // Number,  2
+parser.evaluate('number(a)')    // Error: unexpected type of argument
+```
+
 
 ### Units
 
diff --git a/src/function/utils/isNegative.js b/src/function/utils/isNegative.js
index 72755d072..4ff3f1665 100644
--- a/src/function/utils/isNegative.js
+++ b/src/function/utils/isNegative.js
@@ -1,11 +1,13 @@
 import { deepMap } from '../../utils/collection.js'
 import { factory } from '../../utils/factory.js'
 import { isNegativeNumber } from '../../plain/number/index.js'
+import { nearlyEqual as bigNearlyEqual } from '../../utils/bignumber/nearlyEqual.js'
+import { nearlyEqual } from '../../utils/number.js'
 
 const name = 'isNegative'
-const dependencies = ['typed']
+const dependencies = ['typed', 'config']
 
-export const createIsNegative = /* #__PURE__ */ factory(name, dependencies, ({ typed }) => {
+export const createIsNegative = /* #__PURE__ */ factory(name, dependencies, ({ typed, config }) => {
   /**
    * Test whether a value is negative: smaller than zero.
    * The function supports types `number`, `BigNumber`, `Fraction`, and `Unit`.
@@ -36,15 +38,13 @@ export const createIsNegative = /* #__PURE__ */ factory(name, dependencies, ({ t
    *                    Throws an error in case of an unknown data type.
    */
   return typed(name, {
-    number: isNegativeNumber,
+    number: x => nearlyEqual(x, 0, config.epsilon) ? false : isNegativeNumber(x),
 
-    BigNumber: function (x) {
-      return x.isNeg() && !x.isZero() && !x.isNaN()
-    },
+    BigNumber: x => bigNearlyEqual(x, new x.constructor(0), config.epsilon)
+      ? false
+      : x.isNeg() && !x.isZero() && !x.isNaN(),
 
-    Fraction: function (x) {
-      return x.s < 0 // It's enough to decide on the sign
-    },
+    Fraction: x => x.s < 0, // It's enough to decide on the sign
 
     Unit: typed.referToSelf(self =>
       x => typed.find(self, x.valueType())(x.value)),
diff --git a/src/function/utils/isPositive.js b/src/function/utils/isPositive.js
index a2cdb28e3..95fd59b07 100644
--- a/src/function/utils/isPositive.js
+++ b/src/function/utils/isPositive.js
@@ -1,11 +1,13 @@
 import { deepMap } from '../../utils/collection.js'
 import { factory } from '../../utils/factory.js'
 import { isPositiveNumber } from '../../plain/number/index.js'
+import { nearlyEqual as bigNearlyEqual } from '../../utils/bignumber/nearlyEqual.js'
+import { nearlyEqual } from '../../utils/number.js'
 
 const name = 'isPositive'
-const dependencies = ['typed']
+const dependencies = ['typed', 'config']
 
-export const createIsPositive = /* #__PURE__ */ factory(name, dependencies, ({ typed }) => {
+export const createIsPositive = /* #__PURE__ */ factory(name, dependencies, ({ typed, config }) => {
   /**
    * Test whether a value is positive: larger than zero.
    * The function supports types `number`, `BigNumber`, `Fraction`, and `Unit`.
@@ -38,15 +40,14 @@ export const createIsPositive = /* #__PURE__ */ factory(name, dependencies, ({ t
    *                    Throws an error in case of an unknown data type.
    */
   return typed(name, {
-    number: isPositiveNumber,
+    number: x => nearlyEqual(x, 0, config.epsilon) ? false : isPositiveNumber(x),
 
-    BigNumber: function (x) {
-      return !x.isNeg() && !x.isZero() && !x.isNaN()
-    },
+    BigNumber: x =>
+      bigNearlyEqual(x, new x.constructor(0), config.epsilon)
+        ? false
+        : !x.isNeg() && !x.isZero() && !x.isNaN(),
 
-    Fraction: function (x) {
-      return x.s > 0 && x.n > 0
-    },
+    Fraction: x => x.s > 0 && x.n > 0,
 
     Unit: typed.referToSelf(self =>
       x => typed.find(self, x.valueType())(x.value)),
diff --git a/src/function/utils/isZero.js b/src/function/utils/isZero.js
index 4134200dc..ea3572f59 100644
--- a/src/function/utils/isZero.js
+++ b/src/function/utils/isZero.js
@@ -1,11 +1,10 @@
 import { deepMap } from '../../utils/collection.js'
 import { factory } from '../../utils/factory.js'
-import { isZeroNumber } from '../../plain/number/index.js'
 
 const name = 'isZero'
-const dependencies = ['typed']
+const dependencies = ['typed', 'equalScalar']
 
-export const createIsZero = /* #__PURE__ */ factory(name, dependencies, ({ typed }) => {
+export const createIsZero = /* #__PURE__ */ factory(name, dependencies, ({ typed, equalScalar }) => {
   /**
    * Test whether a value is zero.
    * The function can check for zero for types `number`, `BigNumber`, `Fraction`,
@@ -40,19 +39,7 @@ export const createIsZero = /* #__PURE__ */ factory(name, dependencies, ({ typed
    *                    Throws an error in case of an unknown data type.
    */
   return typed(name, {
-    number: isZeroNumber,
-
-    BigNumber: function (x) {
-      return x.isZero()
-    },
-
-    Complex: function (x) {
-      return x.re === 0 && x.im === 0
-    },
-
-    Fraction: function (x) {
-      return x.d === 1 && x.n === 0
-    },
+    'number | BigNumber | Complex | Fraction': x => equalScalar(x, 0),
 
     Unit: typed.referToSelf(self =>
       x => typed.find(self, x.valueType())(x.value)),
