diff --git a/HISTORY.md b/HISTORY.md
index 0edf5ca75..e7586a138 100644
--- a/HISTORY.md
+++ b/HISTORY.md
@@ -1,6 +1,12 @@
 # History
 
 
+# Unpublished changes since 12.3.2
+
+- Docs: describe method `getAllAsMap` in the Parser docs (#3158, #3157).
+  Thanks @dvd101x.
+
+
 # 2024-02-08, 12.3.2
 
 - Improved the performance of custom defined functions in the expression
diff --git a/docs/expressions/parsing.md b/docs/expressions/parsing.md
index 9e8d1cbc8..b11eb8132 100644
--- a/docs/expressions/parsing.md
+++ b/docs/expressions/parsing.md
@@ -167,7 +167,9 @@ The parser contains the following functions:
 - `get(name)`
   Retrieve a variable or function from the parser's scope.
 - `getAll()`
-  Retrieve a map with all defined a variables from the parser's scope.
+  Retrieve an object with all defined variables in the parser's scope.
+- `getAllAsMap()`
+  Retrieve a map with all defined variables in the parser's scope.
 - `remove(name)`
   Remove a variable or function from the parser's scope.
 - `set(name, value)`
diff --git a/docs/expressions/syntax.md b/docs/expressions/syntax.md
index 722f8084a..a21f1d62c 100644
--- a/docs/expressions/syntax.md
+++ b/docs/expressions/syntax.md
@@ -472,19 +472,6 @@ parser.evaluate('i * i')        // Number,  -1
 parser.evaluate('sqrt(-4)')     // Complex, 2i
 ```
 
-Math.js does not automatically convert complex numbers with an imaginary part
-of zero to numbers. They can be converted to a number using the function
-`number`.
-
-```js
-// convert a complex number to a number
-const parser = math.parser()
-parser.evaluate('a = 2 + 3i')   // Complex, 2 + 3i
-parser.evaluate('b = a - 3i')   // Complex, 2 + 0i
-parser.evaluate('number(b)')    // Number,  2
-parser.evaluate('number(a)')    // Error: unexpected type of argument
-```
-
 
 ### Units
 
diff --git a/src/function/utils/isNegative.js b/src/function/utils/isNegative.js
index 4ff3f1665..72755d072 100644
--- a/src/function/utils/isNegative.js
+++ b/src/function/utils/isNegative.js
@@ -1,13 +1,11 @@
 import { deepMap } from '../../utils/collection.js'
 import { factory } from '../../utils/factory.js'
 import { isNegativeNumber } from '../../plain/number/index.js'
-import { nearlyEqual as bigNearlyEqual } from '../../utils/bignumber/nearlyEqual.js'
-import { nearlyEqual } from '../../utils/number.js'
 
 const name = 'isNegative'
-const dependencies = ['typed', 'config']
+const dependencies = ['typed']
 
-export const createIsNegative = /* #__PURE__ */ factory(name, dependencies, ({ typed, config }) => {
+export const createIsNegative = /* #__PURE__ */ factory(name, dependencies, ({ typed }) => {
   /**
    * Test whether a value is negative: smaller than zero.
    * The function supports types `number`, `BigNumber`, `Fraction`, and `Unit`.
@@ -38,13 +36,15 @@ export const createIsNegative = /* #__PURE__ */ factory(name, dependencies, ({ t
    *                    Throws an error in case of an unknown data type.
    */
   return typed(name, {
-    number: x => nearlyEqual(x, 0, config.epsilon) ? false : isNegativeNumber(x),
+    number: isNegativeNumber,
 
-    BigNumber: x => bigNearlyEqual(x, new x.constructor(0), config.epsilon)
-      ? false
-      : x.isNeg() && !x.isZero() && !x.isNaN(),
+    BigNumber: function (x) {
+      return x.isNeg() && !x.isZero() && !x.isNaN()
+    },
 
-    Fraction: x => x.s < 0, // It's enough to decide on the sign
+    Fraction: function (x) {
+      return x.s < 0 // It's enough to decide on the sign
+    },
 
     Unit: typed.referToSelf(self =>
       x => typed.find(self, x.valueType())(x.value)),
diff --git a/src/function/utils/isPositive.js b/src/function/utils/isPositive.js
index 95fd59b07..a2cdb28e3 100644
--- a/src/function/utils/isPositive.js
+++ b/src/function/utils/isPositive.js
@@ -1,13 +1,11 @@
 import { deepMap } from '../../utils/collection.js'
 import { factory } from '../../utils/factory.js'
 import { isPositiveNumber } from '../../plain/number/index.js'
-import { nearlyEqual as bigNearlyEqual } from '../../utils/bignumber/nearlyEqual.js'
-import { nearlyEqual } from '../../utils/number.js'
 
 const name = 'isPositive'
-const dependencies = ['typed', 'config']
+const dependencies = ['typed']
 
-export const createIsPositive = /* #__PURE__ */ factory(name, dependencies, ({ typed, config }) => {
+export const createIsPositive = /* #__PURE__ */ factory(name, dependencies, ({ typed }) => {
   /**
    * Test whether a value is positive: larger than zero.
    * The function supports types `number`, `BigNumber`, `Fraction`, and `Unit`.
@@ -40,14 +38,15 @@ export const createIsPositive = /* #__PURE__ */ factory(name, dependencies, ({ t
    *                    Throws an error in case of an unknown data type.
    */
   return typed(name, {
-    number: x => nearlyEqual(x, 0, config.epsilon) ? false : isPositiveNumber(x),
+    number: isPositiveNumber,
 
-    BigNumber: x =>
-      bigNearlyEqual(x, new x.constructor(0), config.epsilon)
-        ? false
-        : !x.isNeg() && !x.isZero() && !x.isNaN(),
+    BigNumber: function (x) {
+      return !x.isNeg() && !x.isZero() && !x.isNaN()
+    },
 
-    Fraction: x => x.s > 0 && x.n > 0,
+    Fraction: function (x) {
+      return x.s > 0 && x.n > 0
+    },
 
     Unit: typed.referToSelf(self =>
       x => typed.find(self, x.valueType())(x.value)),
diff --git a/src/function/utils/isZero.js b/src/function/utils/isZero.js
index ea3572f59..4134200dc 100644
--- a/src/function/utils/isZero.js
+++ b/src/function/utils/isZero.js
@@ -1,10 +1,11 @@
 import { deepMap } from '../../utils/collection.js'
 import { factory } from '../../utils/factory.js'
+import { isZeroNumber } from '../../plain/number/index.js'
 
 const name = 'isZero'
-const dependencies = ['typed', 'equalScalar']
+const dependencies = ['typed']
 
-export const createIsZero = /* #__PURE__ */ factory(name, dependencies, ({ typed, equalScalar }) => {
+export const createIsZero = /* #__PURE__ */ factory(name, dependencies, ({ typed }) => {
   /**
    * Test whether a value is zero.
    * The function can check for zero for types `number`, `BigNumber`, `Fraction`,
@@ -39,7 +40,19 @@ export const createIsZero = /* #__PURE__ */ factory(name, dependencies, ({ typed
    *                    Throws an error in case of an unknown data type.
    */
   return typed(name, {
-    'number | BigNumber | Complex | Fraction': x => equalScalar(x, 0),
+    number: isZeroNumber,
+
+    BigNumber: function (x) {
+      return x.isZero()
+    },
+
+    Complex: function (x) {
+      return x.re === 0 && x.im === 0
+    },
+
+    Fraction: function (x) {
+      return x.d === 1 && x.n === 0
+    },
 
     Unit: typed.referToSelf(self =>
       x => typed.find(self, x.valueType())(x.value)),
diff --git a/test/unit-tests/function/matrix/det.test.js b/test/unit-tests/function/matrix/det.test.js
index 5b91e3690..a8fb19e50 100644
--- a/test/unit-tests/function/matrix/det.test.js
+++ b/test/unit-tests/function/matrix/det.test.js
@@ -38,12 +38,6 @@ describe('det', function () {
       [2, 7, 4, 3, 7]
     ]), 1176)
     assert.strictEqual(det(diag([4, -5, 6])), -120)
-    assert.strictEqual(
-      det([
-        [6.123234262925839e-17, -1, 1],
-        [-0.8660253882408142, 0.5, 1],
-        [-0.6495190262794495, -0.3749999701976776, 1]
-      ]), 0.4330126459590976)
   })
 
   it('should return the determinant of a sparse matrix', function () {
diff --git a/test/unit-tests/function/utils/isNegative.test.js b/test/unit-tests/function/utils/isNegative.test.js
index e6fee8a19..c4b8cce14 100644
--- a/test/unit-tests/function/utils/isNegative.test.js
+++ b/test/unit-tests/function/utils/isNegative.test.js
@@ -17,14 +17,6 @@ describe('isNegative', function () {
     assert.strictEqual(isNegative(NaN), false)
   })
 
-  it('should test whether a number is near negative', function () {
-    // when epsilon is 1e-12
-    assert.strictEqual(isNegative(1e-17), false)
-    assert.strictEqual(isNegative(-1e-17), false)
-    assert.strictEqual(isNegative(1e-14), false)
-    assert.strictEqual(isNegative(-1e-14), true)
-  })
-
   it('should test whether a boolean is negative', function () {
     assert.strictEqual(isNegative(true), false)
     assert.strictEqual(isNegative(false), false)
diff --git a/test/unit-tests/function/utils/isPositive.test.js b/test/unit-tests/function/utils/isPositive.test.js
index 070a9b8da..f5ba63dfb 100644
--- a/test/unit-tests/function/utils/isPositive.test.js
+++ b/test/unit-tests/function/utils/isPositive.test.js
@@ -17,14 +17,6 @@ describe('isPositive', function () {
     assert.strictEqual(isPositive(NaN), false)
   })
 
-  it('should test whether a number is near positive', function () {
-    // when epsilon is 1e-12
-    assert.strictEqual(isPositive(1e-17), false)
-    assert.strictEqual(isPositive(-1e-17), false)
-    assert.strictEqual(isPositive(1e-14), true)
-    assert.strictEqual(isPositive(-1e-14), false)
-  })
-
   it('should test whether a boolean is positive', function () {
     assert.strictEqual(isPositive(true), true)
     assert.strictEqual(isPositive(false), false)
diff --git a/test/unit-tests/function/utils/isZero.test.js b/test/unit-tests/function/utils/isZero.test.js
index 03ae45aff..6e1f7dd4d 100644
--- a/test/unit-tests/function/utils/isZero.test.js
+++ b/test/unit-tests/function/utils/isZero.test.js
@@ -19,14 +19,6 @@ describe('isZero', function () {
     assert.strictEqual(isZero(NaN), false)
   })
 
-  it('should test whether a number is near zero', function () {
-    // when epsilon is 1e-12
-    assert.strictEqual(isZero(1e-17), true)
-    assert.strictEqual(isZero(1e-16), true)
-    assert.strictEqual(isZero(1e-15), false)
-    assert.strictEqual(isZero(1e-14), false)
-  })
-
   it('should test whether a boolean is zero', function () {
     assert.strictEqual(isZero(true), false)
     assert.strictEqual(isZero(false), true)
