diff --git a/packages/core/injector/injector.ts b/packages/core/injector/injector.ts
index d4e8c232d..4f29986c6 100644
--- a/packages/core/injector/injector.ts
+++ b/packages/core/injector/injector.ts
@@ -20,7 +20,6 @@ import {
   isNil,
   isObject,
   isString,
-  isSymbol,
   isUndefined,
 } from '@nestjs/common/utils/shared.utils';
 import { iterate } from 'iterare';
@@ -46,7 +45,7 @@ export type InjectorDependency = InjectionToken;
  * The property-based dependency
  */
 export interface PropertyDependency {
-  key: symbol | string;
+  key: string;
   name: InjectorDependency;
   isOptional?: boolean;
   instance?: any;
@@ -361,7 +360,7 @@ export class Injector {
     moduleRef: Module,
     contextId = STATIC_CONTEXT,
     inquirer?: InstanceWrapper,
-    keyOrIndex?: symbol | string | number,
+    keyOrIndex?: string | number,
   ) {
     if (isUndefined(param)) {
       this.logger.log(
@@ -403,7 +402,7 @@ export class Injector {
     wrapper: InstanceWrapper<T>,
     contextId = STATIC_CONTEXT,
     inquirer?: InstanceWrapper,
-    keyOrIndex?: symbol | string | number,
+    keyOrIndex?: string | number,
   ): Promise<InstanceWrapper> {
     this.printResolvingDependenciesLog(token, inquirer);
     this.printLookingForProviderLog(token, moduleRef);
@@ -479,7 +478,7 @@ export class Injector {
     wrapper: InstanceWrapper<T>,
     contextId = STATIC_CONTEXT,
     inquirer?: InstanceWrapper,
-    keyOrIndex?: symbol | string | number,
+    keyOrIndex?: string | number,
   ): Promise<InstanceWrapper<T>> {
     const token = wrapper.token || wrapper.name;
     const { name } = dependencyContext;
@@ -512,7 +511,7 @@ export class Injector {
     wrapper: InstanceWrapper<T>,
     contextId = STATIC_CONTEXT,
     inquirer?: InstanceWrapper,
-    keyOrIndex?: symbol | string | number,
+    keyOrIndex?: string | number,
   ) {
     const instanceWrapper = await this.lookupComponentInImports(
       moduleRef,
@@ -540,7 +539,7 @@ export class Injector {
     moduleRegistry: any[] = [],
     contextId = STATIC_CONTEXT,
     inquirer?: InstanceWrapper,
-    keyOrIndex?: symbol | string | number,
+    keyOrIndex?: string | number,
     isTraversing?: boolean,
   ): Promise<any> {
     let instanceWrapperRef: InstanceWrapper = null;
@@ -831,15 +830,13 @@ export class Injector {
   }
 
   protected addDependencyMetadata(
-    keyOrIndex: symbol | string | number,
+    keyOrIndex: number | string,
     hostWrapper: InstanceWrapper,
     instanceWrapper: InstanceWrapper,
   ) {
-    if (isSymbol(keyOrIndex) || isString(keyOrIndex)) {
-      hostWrapper.addPropertiesMetadata(keyOrIndex, instanceWrapper);
-    } else {
-      hostWrapper.addCtorMetadata(keyOrIndex, instanceWrapper);
-    }
+    isString(keyOrIndex)
+      ? hostWrapper.addPropertiesMetadata(keyOrIndex, instanceWrapper)
+      : hostWrapper.addCtorMetadata(keyOrIndex, instanceWrapper);
   }
 
   private getTokenName(token: InstanceToken): string {
diff --git a/packages/core/injector/instance-wrapper.ts b/packages/core/injector/instance-wrapper.ts
index 239e89dea..18ba4714c 100644
--- a/packages/core/injector/instance-wrapper.ts
+++ b/packages/core/injector/instance-wrapper.ts
@@ -24,7 +24,7 @@ export interface InstancePerContext<T> {
   donePromise?: Promise<void>;
 }
 export interface PropertyMetadata {
-  key: symbol | string;
+  key: string;
   wrapper: InstanceWrapper;
 }
 
@@ -146,7 +146,7 @@ export class InstanceWrapper<T = any> {
     return this[INSTANCE_METADATA_SYMBOL].dependencies;
   }
 
-  public addPropertiesMetadata(key: symbol | string, wrapper: InstanceWrapper) {
+  public addPropertiesMetadata(key: string, wrapper: InstanceWrapper) {
     if (!this[INSTANCE_METADATA_SYMBOL].properties) {
       this[INSTANCE_METADATA_SYMBOL].properties = [];
     }
diff --git a/packages/core/nest-application-context.ts b/packages/core/nest-application-context.ts
index c6e3799a1..a61b9b8b0 100644
--- a/packages/core/nest-application-context.ts
+++ b/packages/core/nest-application-context.ts
@@ -324,7 +324,6 @@ export class NestApplicationContext implements INestApplicationContext {
       wrapperRef.host,
       collection,
       contextId,
-      wrapperRef,
     );
     if (!instance) {
       throw new UnknownElementException();
diff --git a/packages/core/test/injector/injector.spec.ts b/packages/core/test/injector/injector.spec.ts
index 3a1068afc..ef2f10da9 100644
--- a/packages/core/test/injector/injector.spec.ts
+++ b/packages/core/test/injector/injector.spec.ts
@@ -852,57 +852,4 @@ describe('Injector', () => {
       expect(optionalDependenciesIds).to.deep.eq([1]);
     });
   });
-
-  describe('addDependencyMetadata', () => {
-    interface IInjector extends Omit<Injector, 'addDependencyMetadata'> {
-      addDependencyMetadata: (
-        keyOrIndex: symbol | string | number,
-        hostWrapper: InstanceWrapper,
-        instanceWrapper: InstanceWrapper,
-      ) => void;
-    }
-
-    let exposedInjector: IInjector;
-    let hostWrapper: InstanceWrapper;
-    let instanceWrapper: InstanceWrapper;
-
-    beforeEach(() => {
-      exposedInjector = injector as unknown as IInjector;
-      hostWrapper = new InstanceWrapper();
-      instanceWrapper = new InstanceWrapper();
-    });
-
-    it('should add dependency metadata to PropertiesMetadata when key is symbol', async () => {
-      const addPropertiesMetadataSpy = sinon.spy(
-        hostWrapper,
-        'addPropertiesMetadata',
-      );
-
-      const key = Symbol.for('symbol');
-      exposedInjector.addDependencyMetadata(key, hostWrapper, instanceWrapper);
-
-      expect(addPropertiesMetadataSpy.called).to.be.true;
-    });
-
-    it('should add dependency metadata to PropertiesMetadata when key is string', async () => {
-      const addPropertiesMetadataSpy = sinon.spy(
-        hostWrapper,
-        'addPropertiesMetadata',
-      );
-
-      const key = 'string';
-      exposedInjector.addDependencyMetadata(key, hostWrapper, instanceWrapper);
-
-      expect(addPropertiesMetadataSpy.called).to.be.true;
-    });
-
-    it('should add dependency metadata to CtorMetadata when key is number', async () => {
-      const addCtorMetadataSpy = sinon.spy(hostWrapper, 'addCtorMetadata');
-
-      const key = 0;
-      exposedInjector.addDependencyMetadata(key, hostWrapper, instanceWrapper);
-
-      expect(addCtorMetadataSpy.called).to.be.true;
-    });
-  });
 });
diff --git a/packages/core/test/nest-application-context.spec.ts b/packages/core/test/nest-application-context.spec.ts
deleted file mode 100644
index 10f9659c8..000000000
--- a/packages/core/test/nest-application-context.spec.ts
+++ /dev/null
@@ -1,263 +0,0 @@
-import { expect } from 'chai';
-import { InjectionToken, Logger, Scope } from '@nestjs/common';
-import { ContextIdFactory } from '../helpers/context-id-factory';
-import { InstanceLoader } from '../injector/instance-loader';
-import { NestContainer } from '../injector/container';
-import { NestApplicationContext } from '../nest-application-context';
-
-describe('NestApplicationContext', () => {
-  class A {}
-
-  async function testHelper(
-    injectionKey: InjectionToken,
-    scope: Scope,
-  ): Promise<NestApplicationContext> {
-    const nestContainer = new NestContainer();
-    const instanceLoader = new InstanceLoader(nestContainer);
-    const module = await nestContainer.addModule(class T {}, []);
-
-    nestContainer.addProvider(
-      {
-        provide: injectionKey,
-        useClass: A,
-        scope,
-      },
-      module.token,
-    );
-
-    nestContainer.addInjectable(
-      {
-        provide: injectionKey,
-        useClass: A,
-        scope,
-      },
-      module.token,
-    );
-
-    const modules = nestContainer.getModules();
-    await instanceLoader.createInstancesOfDependencies(modules);
-
-    const applicationContext = new NestApplicationContext(nestContainer, []);
-    return applicationContext;
-  }
-
-  describe('get', () => {
-    describe('when scope = DEFAULT', () => {
-      it('should get value with function injection key', async () => {
-        const key = A;
-        const applicationContext = await testHelper(key, Scope.DEFAULT);
-
-        const a1: A = await applicationContext.get(key);
-        const a2: A = await applicationContext.get(key);
-
-        expect(a1).instanceOf(A);
-        expect(a2).instanceOf(A);
-        expect(a1).equal(a2);
-      });
-
-      it('should get value with string injection key', async () => {
-        const key = 'KEY_A';
-        const applicationContext = await testHelper(key, Scope.DEFAULT);
-
-        const a1: A = await applicationContext.get(key);
-        const a2: A = await applicationContext.get(key);
-
-        expect(a1).instanceOf(A);
-        expect(a2).instanceOf(A);
-        expect(a1).equal(a2);
-      });
-
-      it('should get value with symbol injection key', async () => {
-        const key = Symbol('KEY_A');
-        const applicationContext = await testHelper(key, Scope.DEFAULT);
-
-        const a1: A = await applicationContext.get(key);
-        const a2: A = await applicationContext.get(key);
-
-        expect(a1).instanceOf(A);
-        expect(a2).instanceOf(A);
-        expect(a1).equal(a2);
-      });
-    });
-
-    describe('when scope = REQUEST', () => {
-      it('should throw error when use function injection key', async () => {
-        const key = A;
-        const applicationContext = await testHelper(key, Scope.REQUEST);
-
-        expect(() => applicationContext.get(key)).to.be.throw;
-      });
-
-      it('should throw error when use string injection key', async () => {
-        const key = 'KEY_A';
-        const applicationContext = await testHelper(key, Scope.REQUEST);
-
-        expect(() => applicationContext.get(key)).to.be.throw;
-      });
-
-      it('should throw error when use symbol injection key', async () => {
-        const key = Symbol('KEY_A');
-        const applicationContext = await testHelper(key, Scope.REQUEST);
-
-        expect(() => applicationContext.get(key)).to.be.throw;
-      });
-    });
-
-    describe('when scope = TRANSIENT', () => {
-      it('should throw error when use function injection key', async () => {
-        const key = A;
-        const applicationContext = await testHelper(key, Scope.TRANSIENT);
-
-        expect(() => applicationContext.get(key)).to.be.throw;
-      });
-
-      it('should throw error when use string injection key', async () => {
-        const key = 'KEY_A';
-        const applicationContext = await testHelper(key, Scope.TRANSIENT);
-
-        expect(() => applicationContext.get(key)).to.be.throw;
-      });
-
-      it('should throw error when use symbol injection key', async () => {
-        const key = Symbol('KEY_A');
-        const applicationContext = await testHelper(key, Scope.TRANSIENT);
-
-        expect(() => applicationContext.get(key)).to.be.throw;
-      });
-    });
-  });
-
-  describe('resolve', () => {
-    describe('when scope = DEFAULT', () => {
-      it('should resolve value with function injection key', async () => {
-        const key = A;
-        const applicationContext = await testHelper(key, Scope.DEFAULT);
-
-        const a1: A = await applicationContext.resolve(key);
-        const a2: A = await applicationContext.resolve(key);
-
-        expect(a1).instanceOf(A);
-        expect(a2).instanceOf(A);
-        expect(a1).equal(a2);
-      });
-
-      it('should resolve value with string injection key', async () => {
-        const key = 'KEY_A';
-        const applicationContext = await testHelper(key, Scope.DEFAULT);
-
-        const a1: A = await applicationContext.resolve(key);
-        const a2: A = await applicationContext.resolve(key);
-
-        expect(a1).instanceOf(A);
-        expect(a2).instanceOf(A);
-        expect(a1).equal(a2);
-      });
-
-      it('should resolve value with symbol injection key', async () => {
-        const key = Symbol('KEY_A');
-        const applicationContext = await testHelper(key, Scope.DEFAULT);
-
-        const a1: A = await applicationContext.resolve(key);
-        const a2: A = await applicationContext.resolve(key);
-
-        expect(a1).instanceOf(A);
-        expect(a2).instanceOf(A);
-        expect(a1).equal(a2);
-      });
-    });
-
-    describe('when scope = REQUEST', () => {
-      it('should resolve value with function injection key', async () => {
-        const key = A;
-        const applicationContext = await testHelper(key, Scope.REQUEST);
-
-        const contextId = ContextIdFactory.create();
-        const a1: A = await applicationContext.resolve(key);
-        const a2: A = await applicationContext.resolve(key, contextId);
-        const a3: A = await applicationContext.resolve(key, contextId);
-
-        expect(a1).instanceOf(A);
-        expect(a2).instanceOf(A);
-        expect(a1).not.equal(a2);
-        expect(a2).equal(a3);
-      });
-
-      it('should resolve value with string injection key', async () => {
-        const key = 'KEY_A';
-        const applicationContext = await testHelper(key, Scope.REQUEST);
-
-        const contextId = ContextIdFactory.create();
-        const a1: A = await applicationContext.resolve(key);
-        const a2: A = await applicationContext.resolve(key, contextId);
-        const a3: A = await applicationContext.resolve(key, contextId);
-
-        expect(a1).instanceOf(A);
-        expect(a2).instanceOf(A);
-        expect(a1).not.equal(a2);
-        expect(a2).equal(a3);
-      });
-
-      it('should resolve value with symbol injection key', async () => {
-        const key = Symbol('KEY_A');
-        const applicationContext = await testHelper(key, Scope.REQUEST);
-
-        const contextId = ContextIdFactory.create();
-        const a1: A = await applicationContext.resolve(key);
-        const a2: A = await applicationContext.resolve(key, contextId);
-        const a3: A = await applicationContext.resolve(key, contextId);
-
-        expect(a1).instanceOf(A);
-        expect(a2).instanceOf(A);
-        expect(a1).not.equal(a2);
-        expect(a2).equal(a3);
-      });
-    });
-
-    describe('when scope = TRANSIENT', () => {
-      it('should resolve value with function injection key', async () => {
-        const key = A;
-        const applicationContext = await testHelper(key, Scope.TRANSIENT);
-
-        const contextId = ContextIdFactory.create();
-        const a1: A = await applicationContext.resolve(key);
-        const a2: A = await applicationContext.resolve(key, contextId);
-        const a3: A = await applicationContext.resolve(key, contextId);
-
-        expect(a1).instanceOf(A);
-        expect(a2).instanceOf(A);
-        expect(a1).not.equal(a2);
-        expect(a2).equal(a3);
-      });
-
-      it('should resolve value with string injection key', async () => {
-        const key = 'KEY_A';
-        const applicationContext = await testHelper(key, Scope.TRANSIENT);
-
-        const contextId = ContextIdFactory.create();
-        const a1: A = await applicationContext.resolve(key);
-        const a2: A = await applicationContext.resolve(key, contextId);
-        const a3: A = await applicationContext.resolve(key, contextId);
-
-        expect(a1).instanceOf(A);
-        expect(a2).instanceOf(A);
-        expect(a1).not.equal(a2);
-        expect(a2).equal(a3);
-      });
-
-      it('should resolve value with symbol injection key', async () => {
-        const key = Symbol('KEY_A');
-        const applicationContext = await testHelper(key, Scope.TRANSIENT);
-
-        const contextId = ContextIdFactory.create();
-        const a1: A = await applicationContext.resolve(key);
-        const a2: A = await applicationContext.resolve(key, contextId);
-        const a3: A = await applicationContext.resolve(key, contextId);
-
-        expect(a1).instanceOf(A);
-        expect(a2).instanceOf(A);
-        expect(a1).not.equal(a2);
-        expect(a2).equal(a3);
-      });
-    });
-  });
-});
