diff --git a/AUTHORS b/AUTHORS
index 4fd2767fc..dfd737ae0 100644
--- a/AUTHORS
+++ b/AUTHORS
@@ -278,5 +278,6 @@ kyle-compute <kyle@intelvis.ai>
 DongKwanKho <70864292+dodokw@users.noreply.github.com>
 Ikem Peter <ikempeter2020@gmail.com>
 Josh Kelley <joshkel@gmail.com>
+Richard Taylor <richard.taylor@claconnect.com>
 
 # Generated by tools/update-authors.js
diff --git a/HISTORY.md b/HISTORY.md
index 4ce11edea..8b5368b2e 100644
--- a/HISTORY.md
+++ b/HISTORY.md
@@ -4,6 +4,8 @@
 
 - Feat: implement functions `isFinite` and `isBounded` (#3554, #3553). 
   Thanks @gwhitney.
+- Fix: #3564 Avoid error throws when mapping/filtering empty arrays/matrices.
+  (#3567). Thanks @richardt-cla.
 
 # 2025-10-10, 15.0.0
 
diff --git a/src/type/matrix/SparseMatrix.js b/src/type/matrix/SparseMatrix.js
index bbb6c8069..2eba606ce 100644
--- a/src/type/matrix/SparseMatrix.js
+++ b/src/type/matrix/SparseMatrix.js
@@ -16,9 +16,27 @@ const dependencies = [
 
 export const createSparseMatrixClass = /* #__PURE__ */ factory(name, dependencies, ({ typed, equalScalar, Matrix }) => {
   /**
-   * Sparse Matrix implementation. This type implements
-   * a [Compressed Column Storage](https://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_column_(CSC_or_CCS))
-   * format for two-dimensional sparse matrices.
+   * Sparse Matrix implementation. This type (currently) implements 2D
+   * matrices only via the format known as
+   * [Compressed Column Storage](https://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_column_(CSC_or_CCS)).
+   *
+   * The structure/invariants of the internal data should be:
+   * 1. _values is an array of the nonzero values in order from top to bottom
+   *    (of each column), left to right.
+   * 2. _index is an array of row numbers, of the same length as and
+   *    corresponding positionally to _values.
+   * 3. _ptr is an array of length one more than the number of columns. For j
+   *    less than the number of columns, the "half-open" span of indices
+   *    _ptr[j] to _ptr[j+1] (i.e. including _ptr[j] if it is less than
+   *    _ptr[j+1], but never including _ptr[j+1]) are the indices in _values
+   *    of the nonzero elements in column j. Note there are no nonzero elements
+   *    in column j exactly when _ptr[j] === _ptr[j+1], and that the final
+   *    entry in _ptr is always exactly the number of nonzero entries in the
+   *    matrix.
+   * 4. _size is a length-2 array consisting of the number of rows followed by
+   *    the number of columns.
+   * 5. _datatype, if set, is the mathjs typeOf value of all entries of the
+   *    SparseMatrix.
    * @class SparseMatrix
    */
   function SparseMatrix (data, datatype) {
@@ -133,7 +151,9 @@ export const createSparseMatrixClass = /* #__PURE__ */ factory(name, dependencie
       while (j < columns)
     }
     // store number of values in ptr
-    matrix._ptr.push(matrix._index.length)
+    while (matrix._ptr.length <= columns) {
+      matrix._ptr.push(matrix._index.length)
+    }
     // size
     matrix._size = [rows, columns]
   }
diff --git a/src/utils/optimizeCallback.js b/src/utils/optimizeCallback.js
index 0209e8b4f..5e6a0b94f 100644
--- a/src/utils/optimizeCallback.js
+++ b/src/utils/optimizeCallback.js
@@ -17,7 +17,17 @@ export function optimizeCallback (callback, array, name, isUnary) {
     if (isUnary) {
       numberOfArguments = 1
     } else {
-      const firstIndex = (array.isMatrix ? array.size() : arraySize(array)).map(() => 0)
+      const size = array.isMatrix ? array.size() : arraySize(array)
+
+      // Check the size of the last dimension to see if the array/matrix is empty
+      const isEmpty = size.length ? size[size.length - 1] === 0 : true
+      if (isEmpty) {
+        // don't optimize callbacks for empty arrays/matrix, as they will never be called
+        // and in fact will throw an exception when we try to access the first element below
+        return { isUnary, fn: callback }
+      }
+
+      const firstIndex = size.map(() => 0)
       const firstValue = array.isMatrix ? array.get(firstIndex) : get(array, firstIndex)
       numberOfArguments = _findNumberOfArgumentsTyped(callback, firstValue, firstIndex, array)
     }
