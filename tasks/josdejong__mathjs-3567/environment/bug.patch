diff --git a/AUTHORS b/AUTHORS
index dfd737ae0..4fd2767fc 100644
--- a/AUTHORS
+++ b/AUTHORS
@@ -278,6 +278,5 @@ kyle-compute <kyle@intelvis.ai>
 DongKwanKho <70864292+dodokw@users.noreply.github.com>
 Ikem Peter <ikempeter2020@gmail.com>
 Josh Kelley <joshkel@gmail.com>
-Richard Taylor <richard.taylor@claconnect.com>
 
 # Generated by tools/update-authors.js
diff --git a/HISTORY.md b/HISTORY.md
index 8b5368b2e..4ce11edea 100644
--- a/HISTORY.md
+++ b/HISTORY.md
@@ -4,8 +4,6 @@
 
 - Feat: implement functions `isFinite` and `isBounded` (#3554, #3553). 
   Thanks @gwhitney.
-- Fix: #3564 Avoid error throws when mapping/filtering empty arrays/matrices.
-  (#3567). Thanks @richardt-cla.
 
 # 2025-10-10, 15.0.0
 
diff --git a/src/type/matrix/SparseMatrix.js b/src/type/matrix/SparseMatrix.js
index 2eba606ce..bbb6c8069 100644
--- a/src/type/matrix/SparseMatrix.js
+++ b/src/type/matrix/SparseMatrix.js
@@ -16,27 +16,9 @@ const dependencies = [
 
 export const createSparseMatrixClass = /* #__PURE__ */ factory(name, dependencies, ({ typed, equalScalar, Matrix }) => {
   /**
-   * Sparse Matrix implementation. This type (currently) implements 2D
-   * matrices only via the format known as
-   * [Compressed Column Storage](https://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_column_(CSC_or_CCS)).
-   *
-   * The structure/invariants of the internal data should be:
-   * 1. _values is an array of the nonzero values in order from top to bottom
-   *    (of each column), left to right.
-   * 2. _index is an array of row numbers, of the same length as and
-   *    corresponding positionally to _values.
-   * 3. _ptr is an array of length one more than the number of columns. For j
-   *    less than the number of columns, the "half-open" span of indices
-   *    _ptr[j] to _ptr[j+1] (i.e. including _ptr[j] if it is less than
-   *    _ptr[j+1], but never including _ptr[j+1]) are the indices in _values
-   *    of the nonzero elements in column j. Note there are no nonzero elements
-   *    in column j exactly when _ptr[j] === _ptr[j+1], and that the final
-   *    entry in _ptr is always exactly the number of nonzero entries in the
-   *    matrix.
-   * 4. _size is a length-2 array consisting of the number of rows followed by
-   *    the number of columns.
-   * 5. _datatype, if set, is the mathjs typeOf value of all entries of the
-   *    SparseMatrix.
+   * Sparse Matrix implementation. This type implements
+   * a [Compressed Column Storage](https://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_column_(CSC_or_CCS))
+   * format for two-dimensional sparse matrices.
    * @class SparseMatrix
    */
   function SparseMatrix (data, datatype) {
@@ -151,9 +133,7 @@ export const createSparseMatrixClass = /* #__PURE__ */ factory(name, dependencie
       while (j < columns)
     }
     // store number of values in ptr
-    while (matrix._ptr.length <= columns) {
-      matrix._ptr.push(matrix._index.length)
-    }
+    matrix._ptr.push(matrix._index.length)
     // size
     matrix._size = [rows, columns]
   }
diff --git a/src/utils/optimizeCallback.js b/src/utils/optimizeCallback.js
index 5e6a0b94f..0209e8b4f 100644
--- a/src/utils/optimizeCallback.js
+++ b/src/utils/optimizeCallback.js
@@ -17,17 +17,7 @@ export function optimizeCallback (callback, array, name, isUnary) {
     if (isUnary) {
       numberOfArguments = 1
     } else {
-      const size = array.isMatrix ? array.size() : arraySize(array)
-
-      // Check the size of the last dimension to see if the array/matrix is empty
-      const isEmpty = size.length ? size[size.length - 1] === 0 : true
-      if (isEmpty) {
-        // don't optimize callbacks for empty arrays/matrix, as they will never be called
-        // and in fact will throw an exception when we try to access the first element below
-        return { isUnary, fn: callback }
-      }
-
-      const firstIndex = size.map(() => 0)
+      const firstIndex = (array.isMatrix ? array.size() : arraySize(array)).map(() => 0)
       const firstValue = array.isMatrix ? array.get(firstIndex) : get(array, firstIndex)
       numberOfArguments = _findNumberOfArgumentsTyped(callback, firstValue, firstIndex, array)
     }
diff --git a/test/unit-tests/expression/transforms.test.js b/test/unit-tests/expression/transforms.test.js
index 800e09bd6..6c93f0408 100644
--- a/test/unit-tests/expression/transforms.test.js
+++ b/test/unit-tests/expression/transforms.test.js
@@ -175,75 +175,6 @@ describe('transforms', function () {
     })
   })
 
-  describe('empty arrays and matrices', function () {
-    const testCases = [
-      '[]',
-      '[[]]',
-      '[[], []]',
-      '[[[]]]',
-      '[[[], []]]',
-      '[[[], []],[[], []]]',
-
-      'matrix()', // empty matrix with size 0
-      'matrix([[], []])', // Equivalent to one above, but just to be careful
-      'matrix([], "sparse")',
-      'matrix([[]], "sparse")',
-      'matrix([[], []], "sparse")'
-    ]
-
-    describe('with untyped callbacks', function () {
-      it('filter should return an empty array on empty input', function () {
-        assert.deepStrictEqual(
-          parseAndEval('filter([], x > 0)'),
-          math.matrix([])
-        )
-      })
-
-      it('map should return the input unchanged on empty input', function () {
-        testCases.forEach(function (testCase) {
-          assert.deepStrictEqual(
-            parseAndEval(`map(${testCase}, x > 0)`),
-            parseAndEval(testCase)
-          )
-        })
-      })
-
-      it('forEach should not throw on empty input', function () {
-        testCases.forEach(function (testCase) {
-          assert.doesNotThrow(() => {
-            parseAndEval(`forEach(${testCase}, x > 0)`)
-          })
-        })
-      })
-    })
-
-    describe('with typed callbacks', function () {
-      it('should return an empty array when filtering an empty array', function () {
-        assert.deepStrictEqual(
-          parseAndEval('filter([], f(x) = x > 0)'),
-          math.matrix([])
-        )
-      })
-
-      it('map should return the input unchanged on empty input', function () {
-        testCases.forEach(function (testCase) {
-          assert.deepStrictEqual(
-            parseAndEval(`map(${testCase}, f(x) = x > 0)`),
-            parseAndEval(testCase)
-          )
-        })
-      })
-
-      it('forEach should not throw on empty input', function () {
-        testCases.forEach(function (testCase) {
-          assert.doesNotThrow(() => {
-            parseAndEval(`forEach(${testCase}, f(x) = x > 0)`)
-          })
-        })
-      })
-    })
-  })
-
   // TODO: test transforms more thoroughly
 })
 
diff --git a/test/unit-tests/function/matrix/filter.test.js b/test/unit-tests/function/matrix/filter.test.js
index 6698e4780..24f954a7e 100644
--- a/test/unit-tests/function/matrix/filter.test.js
+++ b/test/unit-tests/function/matrix/filter.test.js
@@ -70,17 +70,6 @@ describe('filter', function () {
     assert.deepStrictEqual(math.filter(math.matrix(['23', 'foo', '100', '55', 'bar']), /[0-9]+/), math.matrix(['23', '100', '55']))
   })
 
-  it('should return an empty array when called with an empty array and a typed callback', function () {
-    assert.deepStrictEqual(math.filter([], math.square), [])
-  })
-
-  it('should return an empty matrix when called with an empty matrix and a typed callback', function () {
-    assert.deepStrictEqual(
-      math.filter(math.matrix([]), math.square),
-      math.matrix([])
-    )
-  })
-
   it('should throw an error if called with a multi dimensional matrix', function () {
     function isPositive (x) {
       return x > 0
diff --git a/test/unit-tests/function/matrix/forEach.test.js b/test/unit-tests/function/matrix/forEach.test.js
index 15ed4edd7..1c4c19ab9 100644
--- a/test/unit-tests/function/matrix/forEach.test.js
+++ b/test/unit-tests/function/matrix/forEach.test.js
@@ -74,67 +74,6 @@ describe('forEach', function () {
     assert.deepStrictEqual(output, [3, 3, 3])
   })
 
-  it(
-    'should not throw on empty arrays/matrices, with a typed callback',
-    function () {
-      const testCases = [
-        [],
-        [[]],
-        [[], []],
-        [[[]]],
-        [[[], []]],
-        [
-          [[], []],
-          [[], []]
-        ],
-        // We are going to wait until after discussion #3537 resolves to
-        // settle on the expected behavior of the following two cases:
-        // [[], [1]], // Empty 2nd dimension b/c 1st nested array is empty
-        // [[1], []], // Non-empty 2nd dimension b/c 1st nested array non-empty
-
-        math.matrix([]),
-        math.matrix([[]]),
-        math.matrix([[], []]),
-        math.matrix([[[]]]),
-        math.matrix([[[], []]]),
-        math.matrix([
-          [[], []],
-          [[], []]
-        ]),
-        // The next is not a valid matrix because rows have different sizes
-        // math.matrix([[], [1]]),
-        math.matrix(), // empty matrix with size 0
-
-        math.matrix([], 'sparse'),
-        math.matrix([[]], 'sparse'),
-        math.matrix([[], []], 'sparse')
-      ]
-      testCases.forEach(function (testCase) {
-        assert.doesNotThrow(function () {
-          math.forEach(
-            testCase,
-            math.typed('callback', {
-              'any, any, any': function (value) {
-                throw new Error(`Somehow callback was called on '${value}'`)
-              }
-            })
-          )
-        })
-      })
-    })
-
-  it('should not throw an error on an empty array with a typed function', function () {
-    assert.doesNotThrow(function () {
-      math.forEach([], math.square)
-    })
-  })
-
-  it('should not throw an error on an empty matrix with a typed function', function () {
-    assert.doesNotThrow(function () {
-      math.forEach(math.matrix([]), math.square)
-    })
-  })
-
   it('should throw an error if called with unsupported type', function () {
     assert.throws(function () { math.forEach(1, function () {}) })
     assert.throws(function () { math.forEach('arr', function () {}) })
diff --git a/test/unit-tests/function/matrix/map.test.js b/test/unit-tests/function/matrix/map.test.js
index 4a864c23b..387f4e5f9 100644
--- a/test/unit-tests/function/matrix/map.test.js
+++ b/test/unit-tests/function/matrix/map.test.js
@@ -210,48 +210,6 @@ describe('map', function () {
     assert.deepStrictEqual(math.map(math.matrix([1, 8, 27], 'sparse'), math.format), math.matrix(['1', '8', '27'], 'sparse'))
   })
 
-  it(
-    'should return an empty array/matrix unchanged, with a typed callback',
-    function () {
-      const testCases = [
-        [],
-        [[]],
-        [[], []],
-        [[[]]],
-        [[[], []]],
-        [
-          [[], []],
-          [[], []]
-        ],
-
-        math.matrix([]),
-        math.matrix([[]]),
-        math.matrix([[], []]),
-        math.matrix([[[]]]),
-        math.matrix([[[], []]]),
-        math.matrix([
-          [[], []],
-          [[], []]
-        ]),
-        math.matrix(), // empty matrix with size 0
-
-        math.matrix([], 'sparse'),
-        math.matrix([[]], 'sparse'),
-        math.matrix([[], []], 'sparse')
-      ]
-      testCases.forEach(function (testCase) {
-        const result = math.map(
-          testCase,
-          math.typed({
-            'any, any, any': function (value) {
-              throw new Error(`Callback somehow called with ${value}`)
-            }
-          })
-        )
-        assert.deepStrictEqual(result, testCase)
-      })
-    })
-
   it('should throw an error if called with unsupported type', function () {
     assert.throws(function () { math.map(1, function () {}) })
     assert.throws(function () { math.map('arr', function () {}) })
