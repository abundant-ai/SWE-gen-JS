diff --git a/__tests__/base.js b/__tests__/base.js
index 3909d74..9184998 100644
--- a/__tests__/base.js
+++ b/__tests__/base.js
@@ -1,21 +1,16 @@
 "use strict"
-import * as immerProxy from ".."
-import * as immerEs5 from "../es5"
-import deepFreeze from "deep-freeze"
+import immerProxy from ".."
+import immerEs5 from "../es5"
 
-runBaseTest("proxy (no freeze)", immerProxy, false)
-runBaseTest("proxy (autofreeze)", immerProxy, true)
-runBaseTest("es5 (no freeze)", immerEs5, false)
-runBaseTest("es5 (autofreeze)", immerEs5, true)
+runBaseTest("proxy", immerProxy)
+runBaseTest("es5", immerEs5)
 
-function runBaseTest(name, lib, freeze) {
+function runBaseTest(name, immer) {
     describe(`base functionality - ${name}`, () => {
-        const immer = lib.default
         let baseState
         let origBaseState
 
         beforeEach(() => {
-            lib.setAutoFreeze(freeze)
             origBaseState = baseState = createBaseState()
         })
 
@@ -124,13 +119,7 @@ function runBaseTest(name, lib, freeze) {
             expect(nextState).not.toBe(baseState)
             expect(nextState.anArray).not.toBe(baseState.anArray)
 
-            expect(enumerableOnly(nextState.anArray)).toEqual([
-                3,
-                "a",
-                "b",
-                {c: 3},
-                1
-            ])
+            expect(nextState.anArray).toEqual([3, "a", "b", {c: 3}, 1])
         })
 
         it("should support sorting arrays", () => {
@@ -141,49 +130,7 @@ function runBaseTest(name, lib, freeze) {
             })
             expect(nextState).not.toBe(baseState)
             expect(nextState.anArray).not.toBe(baseState.anArray)
-            expect(enumerableOnly(nextState.anArray)).toEqual([1, 2, 3, {c: 5}])
-        })
-
-        it("should expose property descriptors", () => {
-            const nextState = immer([], s => {
-                expect(Object.getOwnPropertyDescriptor(s, 0)).toBe(undefined)
-                s.unshift("x")
-                expect(Object.getOwnPropertyDescriptor(s, 0)).toEqual({
-                    configurable: true,
-                    enumerable: true,
-                    value: "x",
-                    writable: true
-                })
-                expect(s.length).toBe(1)
-                expect(s[0] === "x").toBe(true)
-            })
-            expect(nextState).toEqual(["x"])
-            expect(Object.getOwnPropertyDescriptor(nextState, 0)).toEqual({
-                configurable: !freeze,
-                enumerable: true,
-                value: "x",
-                writable: !freeze
-            })
-        })
-
-        it("should support sorting arrays - 2", () => {
-            const nextState = immer(baseState, s => {
-                s.anArray.unshift("x")
-                s.anArray[3].c = 4
-                s.anArray.sort()
-                s.anArray[3].c = 5
-                s.anArray.unshift("y")
-            })
-            expect(nextState).not.toBe(baseState)
-            expect(nextState.anArray).not.toBe(baseState.anArray)
-            expect(enumerableOnly(nextState.anArray)).toEqual([
-                "y",
-                1,
-                2,
-                3,
-                {c: 5},
-                "x"
-            ])
+            expect(nextState.anArray).toEqual([1, 2, 3, {c: 5}])
         })
 
         it("should updating inside arrays", () => {
@@ -203,7 +150,7 @@ function runBaseTest(name, lib, freeze) {
             })
             expect(nextState).not.toBe(baseState)
             expect(nextState.anArray).toBe(baseState.anArray)
-            expect(enumerableOnly(nextState)).toEqual({
+            expect(nextState).toEqual({
                 anArray: [3, 2, {c: 3}, 1],
                 aProp: "hi",
                 messy: {
@@ -226,7 +173,7 @@ function runBaseTest(name, lib, freeze) {
             })
             expect(nextState).not.toBe(baseState)
             expect(nextState.anArray).toBe(baseState.anArray)
-            expect(enumerableOnly(nextState)).toEqual({
+            expect(nextState).toEqual({
                 anArray: [3, 2, {c: 3}, 1],
                 aProp: "hello",
                 messy: {
@@ -311,7 +258,7 @@ function runBaseTest(name, lib, freeze) {
         })
 
         function createBaseState() {
-            const data = {
+            return {
                 anArray: [3, 2, {c: 3}, 1],
                 aProp: "hi",
                 anObject: {
@@ -321,12 +268,6 @@ function runBaseTest(name, lib, freeze) {
                     coffee: false
                 }
             }
-            return freeze ? deepFreeze(data) : data
         }
     })
 }
-
-function enumerableOnly(x) {
-    // this can be done better...
-    return JSON.parse(JSON.stringify(x))
-}
diff --git a/__tests__/frozen.js b/__tests__/frozen.js
index 2f9798f..17191d0 100644
--- a/__tests__/frozen.js
+++ b/__tests__/frozen.js
@@ -1,57 +1,49 @@
 "use strict"
-import * as immerProxy from ".."
-import * as immerEs5 from "../es5"
-import deepFreeze from "deep-freeze"
+import immer from ".."
 
-runBaseTest("proxy", immerProxy)
-runBaseTest("es5", immerEs5)
+describe("auto freeze", () => {
+    const baseState = {
+        object: {a: 1},
+        array: [1, 2]
+    }
 
-function runBaseTest(name, lib) {
-    describe("auto freeze - " + name, () => {
-        const immer = lib.default
-        const baseState = {
-            object: {a: 1},
-            array: [1, 2]
-        }
-
-        it("should freeze objects after modifications", () => {
-            expect(Object.isFrozen(baseState.object)).toBe(false) // initially not frozen
-            const next = immer(baseState, draft => {
-                draft.object.c = 2
-            })
-            expect(Object.isFrozen(next.object)).toBe(true)
-            expect(Object.isFrozen(next)).toBe(true)
-            expect(Object.isFrozen(next.array)).toBe(false)
-
-            expect(() => {
-                next.object.a = 2
-            }).toThrow(/Cannot assign to read only property/)
+    it("should freeze objects after modifications", () => {
+        expect(Object.isFrozen(baseState.object)).toBe(false) // initially not frozen
+        const next = immer(baseState, draft => {
+            draft.object.c = 2
         })
+        expect(Object.isFrozen(next.object)).toBe(true)
+        expect(Object.isFrozen(next)).toBe(true)
+        expect(Object.isFrozen(next.array)).toBe(false)
 
-        it("should freeze arrays after modifications", () => {
-            expect(Object.isFrozen(baseState.object)).toBe(false) // initially not frozen
-            const next = immer(baseState, draft => {
-                draft.array.push(3)
-            })
-            expect(Object.isFrozen(next.object)).toBe(false) // not touched
-            expect(Object.isFrozen(next)).toBe(true)
-            expect(Object.isFrozen(next.array)).toBe(true)
+        expect(() => {
+            next.object.a = 2
+        }).toThrow(/Cannot assign to read only property/)
+    })
 
-            expect(() => {
-                next.array.shift()
-            }).toThrow(/Cannot add\/remove sealed array elements/)
+    it("should freeze arrays after modifications", () => {
+        expect(Object.isFrozen(baseState.object)).toBe(false) // initially not frozen
+        const next = immer(baseState, draft => {
+            draft.array.push(3)
         })
+        expect(Object.isFrozen(next.object)).toBe(false) // not touched
+        expect(Object.isFrozen(next)).toBe(true)
+        expect(Object.isFrozen(next.array)).toBe(true)
+
+        expect(() => {
+            next.array.shift()
+        }).toThrow(/Cannot add\/remove sealed array elements/)
+    })
 
-        it("can handle already frozen trees", () => {
-            const a = []
-            const b = {a: a}
-            Object.freeze(a)
-            Object.freeze(b)
-            const n = immer(b, draft => {
-                draft.c = true
-                draft.a.push(3)
-            })
-            expect(n).toEqual({c: true, a: [3]})
+    it("can handle already frozen trees", () => {
+        const a = []
+        const b = {a: a}
+        Object.freeze(a)
+        Object.freeze(b)
+        const n = immer(b, draft => {
+            draft.c = true
+            draft.a.push(3)
         })
+        expect(n).toEqual({c: true, a: [3]})
     })
-}
+})
diff --git a/changelog.md b/changelog.md
index ad86060..803862b 100644
--- a/changelog.md
+++ b/changelog.md
@@ -1,9 +1,5 @@
 # Changelog
 
-### 0.2.2
-
-* Fixed [#32](https://github.com/mweststrate/immer/issue/32): changes are not properly reflected in proxies when using for example `console.dir`
-
 ### 0.2.1
 
 * Fixed: `immer/es5.js` was not packed into the package. PR [#28](https://github.com/mweststrate/immer/pull/28) by [Nicolas Lepage](https://github.com/nlepage)
diff --git a/immer.js b/immer.js
index b2bb4ba..9085ff3 100644
--- a/immer.js
+++ b/immer.js
@@ -66,19 +66,6 @@ function immer(baseState, thunk) {
             const copy = getOrCreateCopy(target)
             delete copy[property]
             return true
-        },
-        getOwnPropertyDescriptor(target, prop) {
-            return Reflect.getOwnPropertyDescriptor(
-                getCurrentSource(target),
-                prop
-            )
-        },
-        defineProperty(target, property, descriptor) {
-            Object.defineProperty(getOrCreateCopy(target), property, descriptor)
-            return true
-        },
-        setPrototypeOf() {
-            throw new Error("Don't even try this...")
         }
     }
 
diff --git a/package.json b/package.json
index 4faafbe..72c7744 100644
--- a/package.json
+++ b/package.json
@@ -37,7 +37,6 @@
     "babel-core": "^6.26.0",
     "babel-jest": "^22.0.4",
     "babel-preset-env": "^1.6.1",
-    "deep-freeze": "^0.0.1",
     "immutable": "^3.8.2",
     "jest": "^22.0.4",
     "lodash.clonedeep": "^4.5.0",
diff --git a/yarn.lock b/yarn.lock
index 95122d4..78f4137 100644
--- a/yarn.lock
+++ b/yarn.lock
@@ -925,10 +925,6 @@ deep-extend@~0.4.0:
   version "0.4.2"
   resolved "https://registry.yarnpkg.com/deep-extend/-/deep-extend-0.4.2.tgz#48b699c27e334bf89f10892be432f6e4c7d34a7f"
 
-deep-freeze@^0.0.1:
-  version "0.0.1"
-  resolved "https://registry.yarnpkg.com/deep-freeze/-/deep-freeze-0.0.1.tgz#3a0b0005de18672819dfd38cd31f91179c893e84"
-
 deep-is@~0.1.3:
   version "0.1.3"
   resolved "https://registry.yarnpkg.com/deep-is/-/deep-is-0.1.3.tgz#b369d6fb5dbc13eecf524f91b070feedc357cf34"
