diff --git a/index.d.ts b/index.d.ts
index dc97323..68ec6fa 100644
--- a/index.d.ts
+++ b/index.d.ts
@@ -337,8 +337,8 @@ export type ExecaReturnBase<StdoutStderrType> = {
 	signalDescription?: string;
 };
 
-export type ExecaSyncReturnValue<StdoutStderrType = string> = {
-} & ExecaReturnBase<StdoutStderrType>;
+export type ExecaSyncReturnValue<StdoutErrorType = string> = {
+} & ExecaReturnBase<StdoutErrorType>;
 
 /**
 Result of a child process execution. On success this is a plain object. On failure this is also an `Error` instance.
@@ -350,7 +350,7 @@ The child process fails when:
 - being canceled
 - there's not enough memory or there are already too many child processes
 */
-export type ExecaReturnValue<StdoutStderrType = string> = {
+export type ExecaReturnValue<StdoutErrorType = string> = {
 	/**
 	The output of the process with `stdout` and `stderr` interleaved.
 
@@ -358,7 +358,7 @@ export type ExecaReturnValue<StdoutStderrType = string> = {
 	- the `all` option is `false` (default value)
 	- `execaSync()` was used
 	*/
-	all?: StdoutStderrType;
+	all?: StdoutErrorType;
 
 	/**
 	Whether the process was canceled.
@@ -366,9 +366,9 @@ export type ExecaReturnValue<StdoutStderrType = string> = {
 	You can cancel the spawned process using the [`signal`](https://github.com/sindresorhus/execa#signal-1) option.
 	*/
 	isCanceled: boolean;
-} & ExecaSyncReturnValue<StdoutStderrType>;
+} & ExecaSyncReturnValue<StdoutErrorType>;
 
-export type ExecaSyncError<StdoutStderrType = string> = {
+export type ExecaSyncError<StdoutErrorType = string> = {
 	/**
 	Error message when the child process failed to run. In addition to the underlying error message, it also contains some information related to why the child process errored.
 
@@ -387,9 +387,9 @@ export type ExecaSyncError<StdoutStderrType = string> = {
 	This is `undefined` unless the child process exited due to an `error` event or a timeout.
 	*/
 	originalMessage?: string;
-} & Error & ExecaReturnBase<StdoutStderrType>;
+} & Error & ExecaReturnBase<StdoutErrorType>;
 
-export type ExecaError<StdoutStderrType = string> = {
+export type ExecaError<StdoutErrorType = string> = {
 	/**
 	The output of the process with `stdout` and `stderr` interleaved.
 
@@ -397,13 +397,13 @@ export type ExecaError<StdoutStderrType = string> = {
 	- the `all` option is `false` (default value)
 	- `execaSync()` was used
 	*/
-	all?: StdoutStderrType;
+	all?: StdoutErrorType;
 
 	/**
 	Whether the process was canceled.
 	*/
 	isCanceled: boolean;
-} & ExecaSyncError<StdoutStderrType>;
+} & ExecaSyncError<StdoutErrorType>;
 
 export type KillOptions = {
 	/**
@@ -416,7 +416,7 @@ export type KillOptions = {
 	forceKillAfterTimeout?: number | false;
 };
 
-export type ExecaChildPromise<StdoutStderrType> = {
+export type ExecaChildPromise<StdoutErrorType> = {
 	/**
 	Stream combining/interleaving [`stdout`](https://nodejs.org/api/child_process.html#child_process_subprocess_stdout) and [`stderr`](https://nodejs.org/api/child_process.html#child_process_subprocess_stderr).
 
@@ -427,8 +427,8 @@ export type ExecaChildPromise<StdoutStderrType> = {
 	all?: ReadableStream;
 
 	catch<ResultType = never>(
-		onRejected?: (reason: ExecaError<StdoutStderrType>) => ResultType | PromiseLike<ResultType>
-	): Promise<ExecaReturnValue<StdoutStderrType> | ResultType>;
+		onRejected?: (reason: ExecaError<StdoutErrorType>) => ResultType | PromiseLike<ResultType>
+	): Promise<ExecaReturnValue<StdoutErrorType> | ResultType>;
 
 	/**
 	Same as the original [`child_process#kill()`](https://nodejs.org/api/child_process.html#child_process_subprocess_kill_signal), except if `signal` is `SIGTERM` (the default value) and the child process is not terminated after 5 seconds, force it by sending `SIGKILL`.
@@ -441,9 +441,9 @@ export type ExecaChildPromise<StdoutStderrType> = {
 	cancel(): void;
 };
 
-export type ExecaChildProcess<StdoutStderrType = string> = ChildProcess &
-ExecaChildPromise<StdoutStderrType> &
-Promise<ExecaReturnValue<StdoutStderrType>>;
+export type ExecaChildProcess<StdoutErrorType = string> = ChildProcess &
+ExecaChildPromise<StdoutErrorType> &
+Promise<ExecaReturnValue<StdoutErrorType>>;
 
 /**
 Execute a file.
@@ -541,148 +541,6 @@ console.log(stdout);
 export function execaCommand(command: string, options?: Options): ExecaChildProcess;
 export function execaCommand(command: string, options?: Options<null>): ExecaChildProcess<Buffer>;
 
-type TemplateExpression = string | number | Array<string | number>;
-
-type Execa$<StdoutStderrType = string> = {
-	/**
-	Same as `execa()` except both file and arguments are specified in a single tagged template string. For example, `` $`echo unicorns` `` is the same as `execa('echo', ['unicorns'])`.
-
-	It's important to note that quotes, backslashes, and spaces are automatically escaped and have no special meaning unless the `shell` option is used. This escaping behavior also applies to interpolated expressions such as strings (`` $`echo ${'string'}` ``), arrays of strings (`` $`echo ${['array', 'of strings']}` ``), and so on.
-
-	The `shell` option must be used if the `command` uses shell-specific features (for example, `&&` or `||`), as opposed to being a simple `file` followed by its `arguments`.
-
-	@returns A [`child_process` instance](https://nodejs.org/api/child_process.html#child_process_class_childprocess), which is enhanced to also be a `Promise` for a result `Object` with `stdout` and `stderr` properties.
-
-	@example <caption>Basic</caption>
-	```
-	import {$} from 'execa';
-
-	const {stdout} = await $`echo unicorns`;
-	// const {stdout} = await $`echo ${'unicorns'}`;
-	// const {stdout} = await $`echo ${['unicorns', 'rainbows']}`;
-
-	console.log(stdout);
-	//=> 'unicorns'
-	```
-
-	@example <caption>With options</caption>
-	```
-	import {$} from 'execa';
-
-	await $({stdio: 'inherit'})`echo unicorns`;
-	//=> 'unicorns'
-	```
-
-	@example <caption>With pre-defined options</caption>
-	```
-	import {$} from 'execa';
-
-	const $$ = $({stdio: 'inherit'});
-	await $$`echo unicorns`;
-	//=> 'unicorns'
-	await $$({shell: true})`echo unicorns && echo rainbows`;
-	//=> 'unicorns'
-	//=> 'rainbows'
-	```
-
-	@example <caption>Synchronous</caption>
-	```
-	import {$} from 'execa';
-
-	const {stdout} = $.sync`echo unicorns`;
-	console.log(stdout);
-	//=> 'unicorns'
-
-	$({stdio: 'inherit'}).sync`echo rainbows`;
-	//=> 'rainbows'
-	```
-	*/
-	(options: Options<undefined>): Execa$<StdoutStderrType>;
-	(options: Options): Execa$;
-	(options: Options<null>): Execa$<Buffer>;
-	(
-		templates: TemplateStringsArray,
-		...expressions: TemplateExpression[]
-	): ExecaChildProcess<StdoutStderrType>;
-
-	/**
-	Same as `$` but synchronous like `execaSync()`.
-
-	@returns The stdout and stderr output.
-
-	@example
-	```
-	import {$} from 'execa';
-
-	const {stdout} = $.sync`echo unicorns`;
-	console.log(stdout);
-	//=> 'unicorns'
-
-	$({stdio: 'inherit'}).sync`echo rainbows`;
-	//=> 'rainbows'
-	```
-	*/
-	sync(
-		templates: TemplateStringsArray,
-		...expressions: TemplateExpression[]
-	): ExecaSyncReturnValue<StdoutStderrType>;
-};
-
-/**
-Same as `execa()` except both file and arguments are specified in a single tagged template string. For example, `` $`echo unicorns` `` is the same as `execa('echo', ['unicorns'])`.
-
-It's important to note that quotes, backslashes, and spaces are automatically escaped and have no special meaning unless the `shell` option is used. This escaping behavior also applies to interpolated expressions such as strings (`` $`echo ${'string'}` ``), arrays of strings (`` $`echo ${['array', 'of strings']}` ``), and so on.
-
-The `shell` option must be used if the `command` uses shell-specific features (for example, `&&` or `||`), as opposed to being a simple `file` followed by its `arguments`.
-
-@returns A [`child_process` instance](https://nodejs.org/api/child_process.html#child_process_class_childprocess), which is enhanced to also be a `Promise` for a result `Object` with `stdout` and `stderr` properties.
-
-@example <caption>Basic</caption>
-```
-import {$} from 'execa';
-
-const {stdout} = await $`echo unicorns`;
-// const {stdout} = await $`echo ${'unicorns'}`;
-// const {stdout} = await $`echo ${['unicorns', 'rainbows']}`;
-
-console.log(stdout);
-//=> 'unicorns'
-```
-
-@example <caption>With options</caption>
-```
-import {$} from 'execa';
-
-await $({stdio: 'inherit'})`echo unicorns`;
-//=> 'unicorns'
-```
-
-@example <caption>With pre-defined options</caption>
-```
-import {$} from 'execa';
-
-const $$ = $({stdio: 'inherit'});
-await $$`echo unicorns`;
-//=> 'unicorns'
-await $$({shell: true})`echo unicorns && echo rainbows`;
-//=> 'unicorns'
-//=> 'rainbows'
-```
-
-@example <caption>Synchronous</caption>
-```
-import {$} from 'execa';
-
-const {stdout} = $.sync`echo unicorns`;
-console.log(stdout);
-//=> 'unicorns'
-
-$({stdio: 'inherit'}).sync`echo rainbows`;
-//=> 'rainbows'
-```
-*/
-export const $: Execa$;
-
 /**
 Same as `execaCommand()` but synchronous.
 
diff --git a/index.js b/index.js
index e9f3582..f060590 100644
--- a/index.js
+++ b/index.js
@@ -11,7 +11,7 @@ import {normalizeStdio, normalizeStdioNode} from './lib/stdio.js';
 import {spawnedKill, spawnedCancel, setupTimeout, validateTimeout, setExitHandler} from './lib/kill.js';
 import {handleInput, getSpawnedResult, makeAllStream, validateInputSync} from './lib/stream.js';
 import {mergePromise, getSpawnedPromise} from './lib/promise.js';
-import {joinCommand, parseCommand, parseTemplates, getEscapedCommand} from './lib/command.js';
+import {joinCommand, parseCommand, getEscapedCommand} from './lib/command.js';
 
 const DEFAULT_MAX_BUFFER = 1000 * 1000 * 100;
 
@@ -224,26 +224,6 @@ export function execaSync(file, args, options) {
 	};
 }
 
-function create$(options) {
-	function $(templatesOrOptions, ...expressions) {
-		if (Array.isArray(templatesOrOptions)) {
-			const [file, ...args] = parseTemplates(templatesOrOptions, expressions);
-			return execa(file, args, options);
-		}
-
-		return create$({...options, ...templatesOrOptions});
-	}
-
-	$.sync = (templates, ...expressions) => {
-		const [file, ...args] = parseTemplates(templates, expressions);
-		return execaSync(file, args, options);
-	};
-
-	return $;
-}
-
-export const $ = create$();
-
 export function execaCommand(command, options) {
 	const [file, ...args] = parseCommand(command);
 	return execa(file, args, options);
diff --git a/index.test-d.ts b/index.test-d.ts
index 32fb555..a805354 100644
--- a/index.test-d.ts
+++ b/index.test-d.ts
@@ -6,7 +6,6 @@ import * as process from 'node:process';
 import {type Readable as ReadableStream} from 'node:stream';
 import {expectType, expectError} from 'tsd';
 import {
-	$,
 	execa,
 	execaSync,
 	execaCommand,
@@ -220,52 +219,3 @@ expectType<ExecaChildProcess<Buffer>>(
 expectType<ExecaChildProcess<Buffer>>(
 	execaNode('unicorns', ['foo'], {nodeOptions: ['--async-stack-traces'], encoding: null}),
 );
-
-expectType<ExecaChildProcess>($`unicorns`);
-expectType<ExecaReturnValue>(await $`unicorns`);
-expectType<ExecaSyncReturnValue>($.sync`unicorns`);
-
-expectType<ExecaChildProcess>($({encoding: 'utf8'})`unicorns`);
-expectType<ExecaReturnValue>(await $({encoding: 'utf8'})`unicorns`);
-expectType<ExecaSyncReturnValue>($({encoding: 'utf8'}).sync`unicorns`);
-
-expectType<ExecaChildProcess>($({encoding: 'utf8'})`unicorns foo`);
-expectType<ExecaReturnValue>(await $({encoding: 'utf8'})`unicorns foo`);
-expectType<ExecaSyncReturnValue>($({encoding: 'utf8'}).sync`unicorns foo`);
-
-expectType<ExecaChildProcess<Buffer>>($({encoding: null})`unicorns`);
-expectType<ExecaReturnValue<Buffer>>(await $({encoding: null})`unicorns`);
-expectType<ExecaSyncReturnValue<Buffer>>($({encoding: null}).sync`unicorns`);
-
-expectType<ExecaChildProcess<Buffer>>($({encoding: null})`unicorns foo`);
-expectType<ExecaReturnValue<Buffer>>(await $({encoding: null})`unicorns foo`);
-expectType<ExecaSyncReturnValue<Buffer>>($({encoding: null}).sync`unicorns foo`);
-
-expectType<ExecaChildProcess>($({encoding: null})({encoding: 'utf8'})`unicorns`);
-expectType<ExecaReturnValue>(await $({encoding: null})({encoding: 'utf8'})`unicorns`);
-expectType<ExecaSyncReturnValue>($({encoding: null})({encoding: 'utf8'}).sync`unicorns`);
-
-expectType<ExecaChildProcess>($({encoding: null})({encoding: 'utf8'})`unicorns foo`);
-expectType<ExecaReturnValue>(await $({encoding: null})({encoding: 'utf8'})`unicorns foo`);
-expectType<ExecaSyncReturnValue>($({encoding: null})({encoding: 'utf8'}).sync`unicorns foo`);
-
-expectType<ExecaChildProcess<Buffer>>($({encoding: null})({})`unicorns`);
-expectType<ExecaReturnValue<Buffer>>(await $({encoding: null})({})`unicorns`);
-expectType<ExecaSyncReturnValue<Buffer>>($({encoding: null})({}).sync`unicorns`);
-
-expectType<ExecaChildProcess<Buffer>>($({encoding: null})({})`unicorns foo`);
-expectType<ExecaReturnValue<Buffer>>(await $({encoding: null})({})`unicorns foo`);
-expectType<ExecaSyncReturnValue<Buffer>>($({encoding: null})({}).sync`unicorns foo`);
-
-expectType<ExecaReturnValue>(await $`unicorns ${'foo'}`);
-expectType<ExecaSyncReturnValue>($.sync`unicorns ${'foo'}`);
-expectType<ExecaReturnValue>(await $`unicorns ${1}`);
-expectType<ExecaSyncReturnValue>($.sync`unicorns ${1}`);
-expectType<ExecaReturnValue>(await $`unicorns ${['foo', 'bar']}`);
-expectType<ExecaSyncReturnValue>($.sync`unicorns ${['foo', 'bar']}`);
-expectType<ExecaReturnValue>(await $`unicorns ${[1, 2]}`);
-expectType<ExecaSyncReturnValue>($.sync`unicorns ${[1, 2]}`);
-expectType<ExecaReturnValue>(await $`unicorns ${true.toString()}`);
-expectType<ExecaSyncReturnValue>($.sync`unicorns ${false.toString()}`);
-expectError<ExecaReturnValue>(await $`unicorns ${true}`);
-expectError<ExecaSyncReturnValue>($.sync`unicorns ${false}`);
diff --git a/lib/command.js b/lib/command.js
index d40877f..be64255 100644
--- a/lib/command.js
+++ b/lib/command.js
@@ -39,22 +39,3 @@ export const parseCommand = command => {
 
 	return tokens;
 };
-
-const parseTemplate = (template, index, templates, expressions) => {
-	const templateString = template ?? templates.raw[index];
-	const templateTokens = templateString.split(SPACES_REGEXP).filter(Boolean);
-
-	if (index === expressions.length) {
-		return templateTokens;
-	}
-
-	const expression = expressions[index];
-
-	return Array.isArray(expression)
-		? [...templateTokens, ...expression.map(String)]
-		: [...templateTokens, String(expression)];
-};
-
-export const parseTemplates = (templates, expressions) => templates.flatMap(
-	(template, index) => parseTemplate(template, index, templates, expressions),
-);
diff --git a/readme.md b/readme.md
index 0b9a5a2..dd1612f 100644
--- a/readme.md
+++ b/readme.md
@@ -39,57 +39,6 @@ console.log(stdout);
 //=> 'unicorns'
 ```
 
-### Using the tagged templates API
-
-#### Basic
-
-```js
-import {$} from 'execa';
-
-const {stdout} = await $`echo unicorns`;
-// const {stdout} = await $`echo ${'unicorns'}`;
-// const {stdout} = await $`echo ${['unicorns', 'rainbows']}`;
-
-console.log(stdout);
-//=> 'unicorns'
-```
-
-#### With options
-
-```js
-import {$} from 'execa';
-
-await $({stdio: 'inherit'})`echo unicorns`;
-//=> 'unicorns'
-```
-
-#### With pre-defined options
-
-```js
-import {$} from 'execa';
-
-const $$ = $({stdio: 'inherit'});
-
-await $$`echo unicorns`;
-//=> 'unicorns'
-await $$({shell: true})`echo unicorns && echo rainbows`;
-//=> 'unicorns'
-//=> 'rainbows'
-```
-
-#### Synchronous
-
-```js
-import {$} from 'execa';
-
-const {stdout} = $.sync`echo unicorns`;
-console.log(stdout);
-//=> 'unicorns'
-
-$({stdio: 'inherit'}).sync`echo rainbows`;
-//=> 'rainbows'
-```
-
 ### Pipe the child process stdout to the parent
 
 ```js
@@ -242,28 +191,6 @@ Execute a file synchronously.
 
 Returns or throws a [`childProcessResult`](#childProcessResult).
 
-### $\`command\`
-
-Same as [`execa()`](#execafile-arguments-options) except both file and arguments are specified in a single tagged template string. For example, `` $`echo unicorns` `` is the same as `execa('echo', ['unicorns'])`.
-
-It's important to note that quotes, backslashes, and spaces are automatically escaped and have no special meaning unless the [`shell` option](#shell) is used. This escaping behavior also applies to interpolated expressions such as strings (`` $`echo ${'string'}` ``), arrays of strings (`` $`echo ${['array', 'of strings']}` ``), and so on.
-
-The [`shell` option](#shell) must be used if the `command` uses shell-specific features (for example, `&&` or `||`), as opposed to being a simple `file` followed by its `arguments`.
-
-Returns a `Promise` that resolves or rejects with a [`childProcessResult`](#childProcessResult).
-
-### $.sync\`command\`
-
-Same as [$\`command\`](#command) but synchronous like [`execaSync()`](#execasyncfile-arguments-options).
-
-Returns or throws a [`childProcessResult`](#childProcessResult).
-
-### $(options)
-
-Binds options to the [`$`](#command) API. For example, you can use `$(options)` to create a new `$` instance with specific default options, which are then bound to both the asynchronous [`` $`command` ``](#command) and synchronous [`` $.sync`command` ``](#synccommand) APIs.
-
-> **Note:** Consecutive calls to this API will shallow merge the options.
-
 ### execaCommand(command, options?)
 
 Same as [`execa()`](#execafile-arguments-options) except both file and arguments are specified in a single `command` string. For example, `execa('echo', ['unicorns'])` is the same as `execaCommand('echo unicorns')`.
diff --git a/test/command.js b/test/command.js
index 1659306..4286b49 100644
--- a/test/command.js
+++ b/test/command.js
@@ -1,5 +1,5 @@
 import test from 'ava';
-import {execa, execaSync, execaCommand, execaCommandSync, $} from '../index.js';
+import {execa, execaSync, execaCommand, execaCommandSync} from '../index.js';
 import {setFixtureDir} from './helpers/fixtures-dir.js';
 
 setFixtureDir();
@@ -85,88 +85,3 @@ test('execaCommandSync()', t => {
 	const {stdout} = execaCommandSync('node test/fixtures/echo.js foo bar');
 	t.is(stdout, 'foo\nbar');
 });
-
-test('$', async t => {
-	const {stdout} = await $`node test/fixtures/echo.js foo bar`;
-	t.is(stdout, 'foo\nbar');
-});
-
-test('$ accepts options', async t => {
-	const {stdout} = await $({stripFinalNewline: true})`noop.js foo`;
-	t.is(stdout, 'foo');
-});
-
-test('$ allows string interpolation', async t => {
-	const {stdout} = await $`node test/fixtures/echo.js foo ${'bar'}`;
-	t.is(stdout, 'foo\nbar');
-});
-
-test('$ allows array interpolation', async t => {
-	const {stdout} = await $`node test/fixtures/echo.js ${['foo', 'bar']}`;
-	t.is(stdout, 'foo\nbar');
-});
-
-test('$ ignores consecutive spaces', async t => {
-	const {stdout} = await $`node test/fixtures/echo.js foo    bar`;
-	t.is(stdout, 'foo\nbar');
-});
-
-test('$ allows escaping spaces with interpolation', async t => {
-	const {stdout} = await $`node test/fixtures/echo.js ${'foo bar'}`;
-	t.is(stdout, 'foo bar');
-});
-
-test('$ disallows escaping spaces with backslashes', async t => {
-	const {stdout} = await $`node test/fixtures/echo.js foo\\ bar`;
-	t.is(stdout, 'foo\\\nbar');
-});
-
-test('$ allows space escaped values in array interpolation', async t => {
-	const {stdout} = await $`node test/fixtures/echo.js ${['foo', 'bar baz']}`;
-	t.is(stdout, 'foo\nbar baz');
-});
-
-test('$ passes newline escape sequence as one argument', async t => {
-	const {stdout} = await $`node test/fixtures/echo.js \n`;
-	t.is(stdout, '\n');
-});
-
-test('$ passes newline escape sequence in interpolation as one argument', async t => {
-	const {stdout} = await $`node test/fixtures/echo.js ${'\n'}`;
-	t.is(stdout, '\n');
-});
-
-test('$ handles invalid escape sequence', async t => {
-	const {stdout} = await $`node test/fixtures/echo.js \u`;
-	t.is(stdout, '\\u');
-});
-
-test('$ coerces all interpolated expressions to strings', async t => {
-	const {stdout} = await $`node test/fixtures/echo.js ${0} ${undefined} ${null}`;
-	t.is(stdout, '0\nundefined\nnull');
-});
-
-test('$ allows escaping spaces in commands with interpolation', async t => {
-	const {stdout} = await $`${'command with space.js'} foo bar`;
-	t.is(stdout, 'foo\nbar');
-});
-
-test('$ escapes other whitespaces', async t => {
-	const {stdout} = await $`node test/fixtures/echo.js foo\tbar`;
-	t.is(stdout, 'foo\tbar');
-});
-
-test('$ trims', async t => {
-	const {stdout} = await $`  node test/fixtures/echo.js foo bar  `;
-	t.is(stdout, 'foo\nbar');
-});
-
-test('$.sync', t => {
-	const {stdout} = $.sync`node test/fixtures/echo.js foo bar`;
-	t.is(stdout, 'foo\nbar');
-});
-
-test('$.sync accepts options', t => {
-	const {stdout} = $({stripFinalNewline: true}).sync`noop.js foo`;
-	t.is(stdout, 'foo');
-});
