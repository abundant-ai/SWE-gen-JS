diff --git a/index.d.ts b/index.d.ts
index 68ec6fa..dc97323 100644
--- a/index.d.ts
+++ b/index.d.ts
@@ -337,8 +337,8 @@ export type ExecaReturnBase<StdoutStderrType> = {
 	signalDescription?: string;
 };
 
-export type ExecaSyncReturnValue<StdoutErrorType = string> = {
-} & ExecaReturnBase<StdoutErrorType>;
+export type ExecaSyncReturnValue<StdoutStderrType = string> = {
+} & ExecaReturnBase<StdoutStderrType>;
 
 /**
 Result of a child process execution. On success this is a plain object. On failure this is also an `Error` instance.
@@ -350,7 +350,7 @@ The child process fails when:
 - being canceled
 - there's not enough memory or there are already too many child processes
 */
-export type ExecaReturnValue<StdoutErrorType = string> = {
+export type ExecaReturnValue<StdoutStderrType = string> = {
 	/**
 	The output of the process with `stdout` and `stderr` interleaved.
 
@@ -358,7 +358,7 @@ export type ExecaReturnValue<StdoutErrorType = string> = {
 	- the `all` option is `false` (default value)
 	- `execaSync()` was used
 	*/
-	all?: StdoutErrorType;
+	all?: StdoutStderrType;
 
 	/**
 	Whether the process was canceled.
@@ -366,9 +366,9 @@ export type ExecaReturnValue<StdoutErrorType = string> = {
 	You can cancel the spawned process using the [`signal`](https://github.com/sindresorhus/execa#signal-1) option.
 	*/
 	isCanceled: boolean;
-} & ExecaSyncReturnValue<StdoutErrorType>;
+} & ExecaSyncReturnValue<StdoutStderrType>;
 
-export type ExecaSyncError<StdoutErrorType = string> = {
+export type ExecaSyncError<StdoutStderrType = string> = {
 	/**
 	Error message when the child process failed to run. In addition to the underlying error message, it also contains some information related to why the child process errored.
 
@@ -387,9 +387,9 @@ export type ExecaSyncError<StdoutErrorType = string> = {
 	This is `undefined` unless the child process exited due to an `error` event or a timeout.
 	*/
 	originalMessage?: string;
-} & Error & ExecaReturnBase<StdoutErrorType>;
+} & Error & ExecaReturnBase<StdoutStderrType>;
 
-export type ExecaError<StdoutErrorType = string> = {
+export type ExecaError<StdoutStderrType = string> = {
 	/**
 	The output of the process with `stdout` and `stderr` interleaved.
 
@@ -397,13 +397,13 @@ export type ExecaError<StdoutErrorType = string> = {
 	- the `all` option is `false` (default value)
 	- `execaSync()` was used
 	*/
-	all?: StdoutErrorType;
+	all?: StdoutStderrType;
 
 	/**
 	Whether the process was canceled.
 	*/
 	isCanceled: boolean;
-} & ExecaSyncError<StdoutErrorType>;
+} & ExecaSyncError<StdoutStderrType>;
 
 export type KillOptions = {
 	/**
@@ -416,7 +416,7 @@ export type KillOptions = {
 	forceKillAfterTimeout?: number | false;
 };
 
-export type ExecaChildPromise<StdoutErrorType> = {
+export type ExecaChildPromise<StdoutStderrType> = {
 	/**
 	Stream combining/interleaving [`stdout`](https://nodejs.org/api/child_process.html#child_process_subprocess_stdout) and [`stderr`](https://nodejs.org/api/child_process.html#child_process_subprocess_stderr).
 
@@ -427,8 +427,8 @@ export type ExecaChildPromise<StdoutErrorType> = {
 	all?: ReadableStream;
 
 	catch<ResultType = never>(
-		onRejected?: (reason: ExecaError<StdoutErrorType>) => ResultType | PromiseLike<ResultType>
-	): Promise<ExecaReturnValue<StdoutErrorType> | ResultType>;
+		onRejected?: (reason: ExecaError<StdoutStderrType>) => ResultType | PromiseLike<ResultType>
+	): Promise<ExecaReturnValue<StdoutStderrType> | ResultType>;
 
 	/**
 	Same as the original [`child_process#kill()`](https://nodejs.org/api/child_process.html#child_process_subprocess_kill_signal), except if `signal` is `SIGTERM` (the default value) and the child process is not terminated after 5 seconds, force it by sending `SIGKILL`.
@@ -441,9 +441,9 @@ export type ExecaChildPromise<StdoutErrorType> = {
 	cancel(): void;
 };
 
-export type ExecaChildProcess<StdoutErrorType = string> = ChildProcess &
-ExecaChildPromise<StdoutErrorType> &
-Promise<ExecaReturnValue<StdoutErrorType>>;
+export type ExecaChildProcess<StdoutStderrType = string> = ChildProcess &
+ExecaChildPromise<StdoutStderrType> &
+Promise<ExecaReturnValue<StdoutStderrType>>;
 
 /**
 Execute a file.
@@ -541,6 +541,148 @@ console.log(stdout);
 export function execaCommand(command: string, options?: Options): ExecaChildProcess;
 export function execaCommand(command: string, options?: Options<null>): ExecaChildProcess<Buffer>;
 
+type TemplateExpression = string | number | Array<string | number>;
+
+type Execa$<StdoutStderrType = string> = {
+	/**
+	Same as `execa()` except both file and arguments are specified in a single tagged template string. For example, `` $`echo unicorns` `` is the same as `execa('echo', ['unicorns'])`.
+
+	It's important to note that quotes, backslashes, and spaces are automatically escaped and have no special meaning unless the `shell` option is used. This escaping behavior also applies to interpolated expressions such as strings (`` $`echo ${'string'}` ``), arrays of strings (`` $`echo ${['array', 'of strings']}` ``), and so on.
+
+	The `shell` option must be used if the `command` uses shell-specific features (for example, `&&` or `||`), as opposed to being a simple `file` followed by its `arguments`.
+
+	@returns A [`child_process` instance](https://nodejs.org/api/child_process.html#child_process_class_childprocess), which is enhanced to also be a `Promise` for a result `Object` with `stdout` and `stderr` properties.
+
+	@example <caption>Basic</caption>
+	```
+	import {$} from 'execa';
+
+	const {stdout} = await $`echo unicorns`;
+	// const {stdout} = await $`echo ${'unicorns'}`;
+	// const {stdout} = await $`echo ${['unicorns', 'rainbows']}`;
+
+	console.log(stdout);
+	//=> 'unicorns'
+	```
+
+	@example <caption>With options</caption>
+	```
+	import {$} from 'execa';
+
+	await $({stdio: 'inherit'})`echo unicorns`;
+	//=> 'unicorns'
+	```
+
+	@example <caption>With pre-defined options</caption>
+	```
+	import {$} from 'execa';
+
+	const $$ = $({stdio: 'inherit'});
+	await $$`echo unicorns`;
+	//=> 'unicorns'
+	await $$({shell: true})`echo unicorns && echo rainbows`;
+	//=> 'unicorns'
+	//=> 'rainbows'
+	```
+
+	@example <caption>Synchronous</caption>
+	```
+	import {$} from 'execa';
+
+	const {stdout} = $.sync`echo unicorns`;
+	console.log(stdout);
+	//=> 'unicorns'
+
+	$({stdio: 'inherit'}).sync`echo rainbows`;
+	//=> 'rainbows'
+	```
+	*/
+	(options: Options<undefined>): Execa$<StdoutStderrType>;
+	(options: Options): Execa$;
+	(options: Options<null>): Execa$<Buffer>;
+	(
+		templates: TemplateStringsArray,
+		...expressions: TemplateExpression[]
+	): ExecaChildProcess<StdoutStderrType>;
+
+	/**
+	Same as `$` but synchronous like `execaSync()`.
+
+	@returns The stdout and stderr output.
+
+	@example
+	```
+	import {$} from 'execa';
+
+	const {stdout} = $.sync`echo unicorns`;
+	console.log(stdout);
+	//=> 'unicorns'
+
+	$({stdio: 'inherit'}).sync`echo rainbows`;
+	//=> 'rainbows'
+	```
+	*/
+	sync(
+		templates: TemplateStringsArray,
+		...expressions: TemplateExpression[]
+	): ExecaSyncReturnValue<StdoutStderrType>;
+};
+
+/**
+Same as `execa()` except both file and arguments are specified in a single tagged template string. For example, `` $`echo unicorns` `` is the same as `execa('echo', ['unicorns'])`.
+
+It's important to note that quotes, backslashes, and spaces are automatically escaped and have no special meaning unless the `shell` option is used. This escaping behavior also applies to interpolated expressions such as strings (`` $`echo ${'string'}` ``), arrays of strings (`` $`echo ${['array', 'of strings']}` ``), and so on.
+
+The `shell` option must be used if the `command` uses shell-specific features (for example, `&&` or `||`), as opposed to being a simple `file` followed by its `arguments`.
+
+@returns A [`child_process` instance](https://nodejs.org/api/child_process.html#child_process_class_childprocess), which is enhanced to also be a `Promise` for a result `Object` with `stdout` and `stderr` properties.
+
+@example <caption>Basic</caption>
+```
+import {$} from 'execa';
+
+const {stdout} = await $`echo unicorns`;
+// const {stdout} = await $`echo ${'unicorns'}`;
+// const {stdout} = await $`echo ${['unicorns', 'rainbows']}`;
+
+console.log(stdout);
+//=> 'unicorns'
+```
+
+@example <caption>With options</caption>
+```
+import {$} from 'execa';
+
+await $({stdio: 'inherit'})`echo unicorns`;
+//=> 'unicorns'
+```
+
+@example <caption>With pre-defined options</caption>
+```
+import {$} from 'execa';
+
+const $$ = $({stdio: 'inherit'});
+await $$`echo unicorns`;
+//=> 'unicorns'
+await $$({shell: true})`echo unicorns && echo rainbows`;
+//=> 'unicorns'
+//=> 'rainbows'
+```
+
+@example <caption>Synchronous</caption>
+```
+import {$} from 'execa';
+
+const {stdout} = $.sync`echo unicorns`;
+console.log(stdout);
+//=> 'unicorns'
+
+$({stdio: 'inherit'}).sync`echo rainbows`;
+//=> 'rainbows'
+```
+*/
+export const $: Execa$;
+
 /**
 Same as `execaCommand()` but synchronous.
 
diff --git a/index.js b/index.js
index f060590..e9f3582 100644
--- a/index.js
+++ b/index.js
@@ -11,7 +11,7 @@ import {normalizeStdio, normalizeStdioNode} from './lib/stdio.js';
 import {spawnedKill, spawnedCancel, setupTimeout, validateTimeout, setExitHandler} from './lib/kill.js';
 import {handleInput, getSpawnedResult, makeAllStream, validateInputSync} from './lib/stream.js';
 import {mergePromise, getSpawnedPromise} from './lib/promise.js';
-import {joinCommand, parseCommand, getEscapedCommand} from './lib/command.js';
+import {joinCommand, parseCommand, parseTemplates, getEscapedCommand} from './lib/command.js';
 
 const DEFAULT_MAX_BUFFER = 1000 * 1000 * 100;
 
@@ -224,6 +224,26 @@ export function execaSync(file, args, options) {
 	};
 }
 
+function create$(options) {
+	function $(templatesOrOptions, ...expressions) {
+		if (Array.isArray(templatesOrOptions)) {
+			const [file, ...args] = parseTemplates(templatesOrOptions, expressions);
+			return execa(file, args, options);
+		}
+
+		return create$({...options, ...templatesOrOptions});
+	}
+
+	$.sync = (templates, ...expressions) => {
+		const [file, ...args] = parseTemplates(templates, expressions);
+		return execaSync(file, args, options);
+	};
+
+	return $;
+}
+
+export const $ = create$();
+
 export function execaCommand(command, options) {
 	const [file, ...args] = parseCommand(command);
 	return execa(file, args, options);
diff --git a/index.test-d.ts b/index.test-d.ts
index a805354..32fb555 100644
--- a/index.test-d.ts
+++ b/index.test-d.ts
@@ -6,6 +6,7 @@ import * as process from 'node:process';
 import {type Readable as ReadableStream} from 'node:stream';
 import {expectType, expectError} from 'tsd';
 import {
+	$,
 	execa,
 	execaSync,
 	execaCommand,
@@ -219,3 +220,52 @@ expectType<ExecaChildProcess<Buffer>>(
 expectType<ExecaChildProcess<Buffer>>(
 	execaNode('unicorns', ['foo'], {nodeOptions: ['--async-stack-traces'], encoding: null}),
 );
+
+expectType<ExecaChildProcess>($`unicorns`);
+expectType<ExecaReturnValue>(await $`unicorns`);
+expectType<ExecaSyncReturnValue>($.sync`unicorns`);
+
+expectType<ExecaChildProcess>($({encoding: 'utf8'})`unicorns`);
+expectType<ExecaReturnValue>(await $({encoding: 'utf8'})`unicorns`);
+expectType<ExecaSyncReturnValue>($({encoding: 'utf8'}).sync`unicorns`);
+
+expectType<ExecaChildProcess>($({encoding: 'utf8'})`unicorns foo`);
+expectType<ExecaReturnValue>(await $({encoding: 'utf8'})`unicorns foo`);
+expectType<ExecaSyncReturnValue>($({encoding: 'utf8'}).sync`unicorns foo`);
+
+expectType<ExecaChildProcess<Buffer>>($({encoding: null})`unicorns`);
+expectType<ExecaReturnValue<Buffer>>(await $({encoding: null})`unicorns`);
+expectType<ExecaSyncReturnValue<Buffer>>($({encoding: null}).sync`unicorns`);
+
+expectType<ExecaChildProcess<Buffer>>($({encoding: null})`unicorns foo`);
+expectType<ExecaReturnValue<Buffer>>(await $({encoding: null})`unicorns foo`);
+expectType<ExecaSyncReturnValue<Buffer>>($({encoding: null}).sync`unicorns foo`);
+
+expectType<ExecaChildProcess>($({encoding: null})({encoding: 'utf8'})`unicorns`);
+expectType<ExecaReturnValue>(await $({encoding: null})({encoding: 'utf8'})`unicorns`);
+expectType<ExecaSyncReturnValue>($({encoding: null})({encoding: 'utf8'}).sync`unicorns`);
+
+expectType<ExecaChildProcess>($({encoding: null})({encoding: 'utf8'})`unicorns foo`);
+expectType<ExecaReturnValue>(await $({encoding: null})({encoding: 'utf8'})`unicorns foo`);
+expectType<ExecaSyncReturnValue>($({encoding: null})({encoding: 'utf8'}).sync`unicorns foo`);
+
+expectType<ExecaChildProcess<Buffer>>($({encoding: null})({})`unicorns`);
+expectType<ExecaReturnValue<Buffer>>(await $({encoding: null})({})`unicorns`);
+expectType<ExecaSyncReturnValue<Buffer>>($({encoding: null})({}).sync`unicorns`);
+
+expectType<ExecaChildProcess<Buffer>>($({encoding: null})({})`unicorns foo`);
+expectType<ExecaReturnValue<Buffer>>(await $({encoding: null})({})`unicorns foo`);
+expectType<ExecaSyncReturnValue<Buffer>>($({encoding: null})({}).sync`unicorns foo`);
+
+expectType<ExecaReturnValue>(await $`unicorns ${'foo'}`);
+expectType<ExecaSyncReturnValue>($.sync`unicorns ${'foo'}`);
+expectType<ExecaReturnValue>(await $`unicorns ${1}`);
+expectType<ExecaSyncReturnValue>($.sync`unicorns ${1}`);
+expectType<ExecaReturnValue>(await $`unicorns ${['foo', 'bar']}`);
+expectType<ExecaSyncReturnValue>($.sync`unicorns ${['foo', 'bar']}`);
+expectType<ExecaReturnValue>(await $`unicorns ${[1, 2]}`);
+expectType<ExecaSyncReturnValue>($.sync`unicorns ${[1, 2]}`);
+expectType<ExecaReturnValue>(await $`unicorns ${true.toString()}`);
+expectType<ExecaSyncReturnValue>($.sync`unicorns ${false.toString()}`);
+expectError<ExecaReturnValue>(await $`unicorns ${true}`);
+expectError<ExecaSyncReturnValue>($.sync`unicorns ${false}`);
diff --git a/lib/command.js b/lib/command.js
index be64255..d40877f 100644
--- a/lib/command.js
+++ b/lib/command.js
@@ -39,3 +39,22 @@ export const parseCommand = command => {
 
 	return tokens;
 };
+
+const parseTemplate = (template, index, templates, expressions) => {
+	const templateString = template ?? templates.raw[index];
+	const templateTokens = templateString.split(SPACES_REGEXP).filter(Boolean);
+
+	if (index === expressions.length) {
+		return templateTokens;
+	}
+
+	const expression = expressions[index];
+
+	return Array.isArray(expression)
+		? [...templateTokens, ...expression.map(String)]
+		: [...templateTokens, String(expression)];
+};
+
+export const parseTemplates = (templates, expressions) => templates.flatMap(
+	(template, index) => parseTemplate(template, index, templates, expressions),
+);
diff --git a/readme.md b/readme.md
index dd1612f..0b9a5a2 100644
--- a/readme.md
+++ b/readme.md
@@ -39,6 +39,57 @@ console.log(stdout);
 //=> 'unicorns'
 ```
 
+### Using the tagged templates API
+
+#### Basic
+
+```js
+import {$} from 'execa';
+
+const {stdout} = await $`echo unicorns`;
+// const {stdout} = await $`echo ${'unicorns'}`;
+// const {stdout} = await $`echo ${['unicorns', 'rainbows']}`;
+
+console.log(stdout);
+//=> 'unicorns'
+```
+
+#### With options
+
+```js
+import {$} from 'execa';
+
+await $({stdio: 'inherit'})`echo unicorns`;
+//=> 'unicorns'
+```
+
+#### With pre-defined options
+
+```js
+import {$} from 'execa';
+
+const $$ = $({stdio: 'inherit'});
+
+await $$`echo unicorns`;
+//=> 'unicorns'
+await $$({shell: true})`echo unicorns && echo rainbows`;
+//=> 'unicorns'
+//=> 'rainbows'
+```
+
+#### Synchronous
+
+```js
+import {$} from 'execa';
+
+const {stdout} = $.sync`echo unicorns`;
+console.log(stdout);
+//=> 'unicorns'
+
+$({stdio: 'inherit'}).sync`echo rainbows`;
+//=> 'rainbows'
+```
+
 ### Pipe the child process stdout to the parent
 
 ```js
@@ -191,6 +242,28 @@ Execute a file synchronously.
 
 Returns or throws a [`childProcessResult`](#childProcessResult).
 
+### $\`command\`
+
+Same as [`execa()`](#execafile-arguments-options) except both file and arguments are specified in a single tagged template string. For example, `` $`echo unicorns` `` is the same as `execa('echo', ['unicorns'])`.
+
+It's important to note that quotes, backslashes, and spaces are automatically escaped and have no special meaning unless the [`shell` option](#shell) is used. This escaping behavior also applies to interpolated expressions such as strings (`` $`echo ${'string'}` ``), arrays of strings (`` $`echo ${['array', 'of strings']}` ``), and so on.
+
+The [`shell` option](#shell) must be used if the `command` uses shell-specific features (for example, `&&` or `||`), as opposed to being a simple `file` followed by its `arguments`.
+
+Returns a `Promise` that resolves or rejects with a [`childProcessResult`](#childProcessResult).
+
+### $.sync\`command\`
+
+Same as [$\`command\`](#command) but synchronous like [`execaSync()`](#execasyncfile-arguments-options).
+
+Returns or throws a [`childProcessResult`](#childProcessResult).
+
+### $(options)
+
+Binds options to the [`$`](#command) API. For example, you can use `$(options)` to create a new `$` instance with specific default options, which are then bound to both the asynchronous [`` $`command` ``](#command) and synchronous [`` $.sync`command` ``](#synccommand) APIs.
+
+> **Note:** Consecutive calls to this API will shallow merge the options.
+
 ### execaCommand(command, options?)
 
 Same as [`execa()`](#execafile-arguments-options) except both file and arguments are specified in a single `command` string. For example, `execa('echo', ['unicorns'])` is the same as `execaCommand('echo unicorns')`.
