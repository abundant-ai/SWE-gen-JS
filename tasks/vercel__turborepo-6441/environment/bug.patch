diff --git a/packages/turbo-repository/__tests__/detect.test.ts b/packages/turbo-repository/__tests__/detect.test.ts
new file mode 100644
index 0000000000..6a5df212c5
--- /dev/null
+++ b/packages/turbo-repository/__tests__/detect.test.ts
@@ -0,0 +1,19 @@
+import * as path from "node:path";
+import { Repository } from "../js/dist/index.js";
+
+describe("detect", () => {
+  it("detects a repo", async () => {
+    const repo = await Repository.detectJS();
+    console.log(repo);
+    const expectedRoot = path.resolve(__dirname, "../../..");
+    expect(repo.root).toBe(expectedRoot);
+  });
+
+  it("enumerates workspaces", async () => {
+    const repo = await Repository.detectJS();
+    const workspaces = await repo.workspaces();
+    expect(workspaces.length).not.toBe(0);
+  });
+
+  // TODO: proper tests on real fixtures
+});
diff --git a/packages/turbo-repository/__tests__/find.test.ts b/packages/turbo-repository/__tests__/find.test.ts
deleted file mode 100644
index 17a1f4de3c..0000000000
--- a/packages/turbo-repository/__tests__/find.test.ts
+++ /dev/null
@@ -1,19 +0,0 @@
-import * as path from "node:path";
-import { PackageManagerRoot } from "../js/dist/index.js";
-
-describe("find", () => {
-  it("finds a package manager root", async () => {
-    const packageManagerRoot = await PackageManagerRoot.find();
-    console.log(packageManagerRoot);
-    const expectedRoot = path.resolve(__dirname, "../../..");
-    expect(packageManagerRoot.root).toBe(expectedRoot);
-  });
-
-  it("enumerates workspaces", async () => {
-    const packageManagerRoot = await PackageManagerRoot.find();
-    const workspaces = await packageManagerRoot.packages();
-    expect(workspaces.length).not.toBe(0);
-  });
-
-  // TODO: proper tests on real fixtures
-});
diff --git a/packages/turbo-repository/js/index.d.ts b/packages/turbo-repository/js/index.d.ts
index 5d49a1de26..edadd8889e 100644
--- a/packages/turbo-repository/js/index.d.ts
+++ b/packages/turbo-repository/js/index.d.ts
@@ -3,12 +3,12 @@
 
 /* auto-generated by NAPI-RS */
 
-export class PackageManagerRoot {
+export class Repository {
   readonly root: string;
-  readonly isSinglePackage: boolean;
-  static find(path?: string | undefined | null): Promise<PackageManagerRoot>;
+  readonly isMonorepo: boolean;
+  static detectJS(path?: string | undefined | null): Promise<Repository>;
   packageManager(): PackageManager;
-  packages(): Promise<Array<Workspace>>;
+  workspaces(): Promise<Array<Workspace>>;
 }
 export class PackageManager {
   readonly name: string;
diff --git a/packages/turbo-repository/js/index.js b/packages/turbo-repository/js/index.js
index 8cd6441dd1..371c8f792d 100644
--- a/packages/turbo-repository/js/index.js
+++ b/packages/turbo-repository/js/index.js
@@ -106,8 +106,7 @@ switch (platform) {
 
 nativeBinding = loadViaSuffix(suffix);
 
-const { PackageManagerRoot, PackageManager, Workspace } = nativeBinding;
+const { Repository, PackageManager } = nativeBinding;
 
-module.exports.PackageManagerRoot = PackageManagerRoot;
+module.exports.Repository = Repository;
 module.exports.PackageManager = PackageManager;
-module.exports.Workspace = Workspace;
diff --git a/packages/turbo-repository/rust/src/internal.rs b/packages/turbo-repository/rust/src/internal.rs
index 511aca9b36..fa939d6bac 100644
--- a/packages/turbo-repository/rust/src/internal.rs
+++ b/packages/turbo-repository/rust/src/internal.rs
@@ -8,7 +8,7 @@ use turborepo_repository::{
     package_manager,
 };
 
-use crate::{PackageManagerRoot, Workspace};
+use crate::{Repository, Workspace};
 
 /// This module is used to isolate code with defined errors
 /// from code in lib.rs that needs to have errors coerced to strings /
@@ -42,8 +42,8 @@ impl From<Error> for napi::Error<Status> {
     }
 }
 
-impl PackageManagerRoot {
-    pub(crate) async fn find_internal(path: Option<String>) -> Result<Self, Error> {
+impl Repository {
+    pub(crate) async fn detect_js_internal(path: Option<String>) -> Result<Self, Error> {
         let reference_dir = path
             .map(|path| {
                 AbsoluteSystemPathBuf::from_cwd(&path).map_err(|path_error| Error::StartingPath {
@@ -62,11 +62,11 @@ impl PackageManagerRoot {
         Ok(Self {
             root: repo_state.root.to_string(),
             repo_state,
-            is_single_package: !is_monorepo,
+            is_monorepo,
         })
     }
 
-    pub(crate) async fn packages_internal(&self) -> Result<Vec<Workspace>, Error> {
+    pub(crate) async fn workspaces_internal(&self) -> Result<Vec<Workspace>, Error> {
         // Note: awkward error handling because we memoize the error from package
         // manager discovery. That probably isn't the best design. We should
         // address it when we decide how we want to handle possibly finding a
diff --git a/packages/turbo-repository/rust/src/lib.rs b/packages/turbo-repository/rust/src/lib.rs
index 160425403e..5f1640abaa 100644
--- a/packages/turbo-repository/rust/src/lib.rs
+++ b/packages/turbo-repository/rust/src/lib.rs
@@ -7,12 +7,12 @@ use turborepo_repository::{
 mod internal;
 
 #[napi]
-pub struct PackageManagerRoot {
+pub struct Repository {
     repo_state: RepoState,
     #[napi(readonly)]
     pub root: String,
     #[napi(readonly)]
-    pub is_single_package: bool,
+    pub is_monorepo: bool,
 }
 
 #[napi]
@@ -53,10 +53,10 @@ impl From<RustPackageManager> for PackageManager {
 }
 
 #[napi]
-impl PackageManagerRoot {
-    #[napi(factory)]
-    pub async fn find(path: Option<String>) -> Result<PackageManagerRoot, napi::Error> {
-        Self::find_internal(path).await.map_err(|e| e.into())
+impl Repository {
+    #[napi(factory, js_name = "detectJS")]
+    pub async fn detect_js_repository(path: Option<String>) -> Result<Repository, napi::Error> {
+        Self::detect_js_internal(path).await.map_err(|e| e.into())
     }
 
     #[napi]
@@ -71,7 +71,7 @@ impl PackageManagerRoot {
     }
 
     #[napi]
-    pub async fn packages(&self) -> std::result::Result<Vec<Workspace>, napi::Error> {
-        self.packages_internal().await.map_err(|e| e.into())
+    pub async fn workspaces(&self) -> std::result::Result<Vec<Workspace>, napi::Error> {
+        self.workspaces_internal().await.map_err(|e| e.into())
     }
 }
