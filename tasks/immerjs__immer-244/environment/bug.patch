diff --git a/__tests__/types.ts b/__tests__/types.ts
index 29c4f3b..8fe6dec 100644
--- a/__tests__/types.ts
+++ b/__tests__/types.ts
@@ -109,233 +109,174 @@ it("can apply patches", () => {
  */
 
 // For checking if a type is assignable to its draft type (and vice versa)
-declare const toDraft: <T>(value: T) => Draft<T>
-declare const fromDraft: <T>(draft: Draft<T>) => T
-
-/** Trigger a compiler error when a value is _not_ an exact type. */
-declare const exactType: <T, U extends T>(
-    draft?: U,
-    expected?: T
-) => T extends U ? T : 1 & 0
+const toDraft = <T>(value: T): Draft<T> => value as any
+const fromDraft = <T>(draft: Draft<T>): T => draft as any
 
 // Tuple
 {
     let val: [1, 2]
-    val = exactType(toDraft(val), val)
-    val = exactType(fromDraft(toDraft(val)), val)
+    val = fromDraft(toDraft(val))
+    let draft: DraftTuple<typeof val> = toDraft(val)
 }
 
 // Tuple (nested in a tuple)
 {
     let val: [[1, 2]]
-    val = exactType(toDraft(val), val)
-    val = exactType(fromDraft(toDraft(val)), val)
+    val = fromDraft(toDraft(val))
+    let draft: DraftTuple<typeof val> = toDraft(val)
 }
 
 // Tuple (nested in two readonly arrays)
 {
     let val: ReadonlyArray<ReadonlyArray<[1, 2]>>
-    let draft: [1, 2][][]
-    draft = exactType(toDraft(val), draft)
-    val = fromDraft(draft)
+    val = fromDraft(toDraft(val))
+    let draft: DraftTuple<[1, 2]>[][] = toDraft(val)
 }
 
 // Mutable array
 {
     let val: string[]
-    val = exactType(toDraft(val), val)
-    val = exactType(fromDraft(toDraft(val)), val)
-}
-
-// Mutable array (nested in tuple)
-{
-    let val: [string[]]
-    val = exactType(toDraft(val), val)
-    val = exactType(fromDraft(toDraft(val)), val)
+    val = fromDraft(toDraft(val))
+    let draft: typeof val = toDraft(val)
 }
 
 // Readonly array
 {
     let val: ReadonlyArray<string>
-    let draft: string[]
-    draft = exactType(toDraft(val), draft)
-    val = fromDraft(draft)
+    val = fromDraft(toDraft(val))
+    let draft: string[] = toDraft(val)
 }
 
 // Readonly array (nested in readonly object)
 {
     let val: {readonly a: ReadonlyArray<string>}
-    let draft: {a: string[]}
-    draft = exactType(toDraft(val), draft)
-    val = fromDraft(draft)
+    val = fromDraft(toDraft(val))
+    let draft: {a: string[]} = toDraft(val)
 }
 
 // Mutable object
 {
     let val: {a: 1}
-    val = exactType(toDraft(val), val)
-    val = exactType(fromDraft(toDraft(val)), val)
-}
-
-// Mutable object (nested in mutable object)
-{
-    let val: {a: {b: 1}}
-    val = exactType(toDraft(val), val)
-    val = exactType(fromDraft(toDraft(val)), val)
-}
-
-// Interface
-{
-    interface Foo {
-        a: {b: number}
-    }
-    let val: Foo
-    val = exactType(toDraft(val), val)
-    val = exactType(fromDraft(toDraft(val)), val)
-}
-
-// Interface (nested in interface)
-{
-    interface Foo {
-        a: {b: number}
-    }
-    interface Bar {
-        foo: Foo
-    }
-    let val: Bar
-    val = exactType(toDraft(val), val)
-    val = exactType(fromDraft(toDraft(val)), val)
+    val = fromDraft(toDraft(val))
+    let draft: typeof val = toDraft(val)
 }
 
 // Readonly object
 {
     let val: Readonly<{a: 1}>
-    let draft: {a: 1}
-    draft = exactType(toDraft(val), val)
-    val = exactType(fromDraft(draft), val)
+    val = fromDraft(toDraft(val))
+    let draft: {a: 1} = toDraft(val)
 }
 
 // Readonly object (nested in tuple)
 {
     let val: [Readonly<{a: 1}>]
-    let draft: DraftTuple<[{a: 1}]>
-    draft = exactType(toDraft(val), val)
-    val = exactType(fromDraft(draft), val)
+    val = fromDraft(toDraft(val))
+    let draft: DraftTuple<[{a: 1}]> = toDraft(val)
 }
 
 // Loose function
 {
     let val: Function
-    val = exactType(toDraft(val), val)
-    val = exactType(fromDraft(toDraft(val)), val)
+    val = fromDraft(toDraft(val))
+    let draft: typeof val = toDraft(val)
 }
 
 // Strict function
 {
     let val: () => void
-    val = exactType(toDraft(val), val)
-    val = exactType(fromDraft(toDraft(val)), val)
+    val = fromDraft(toDraft(val))
+    let draft: typeof val = toDraft(val)
 }
 
 // Map instance
 {
     let val: Map<any, any>
-    val = exactType(toDraft(val), val)
-    val = exactType(fromDraft(toDraft(val)), val)
+    val = fromDraft(toDraft(val))
+    let draft: typeof val = toDraft(val)
 
-    // Weak maps
     let weak: WeakMap<any, any>
-    weak = exactType(toDraft(weak), weak)
-    weak = exactType(fromDraft(toDraft(weak)), weak)
+    weak = fromDraft(toDraft(weak))
+    let weakDraft: typeof weak = toDraft(weak)
 }
 
 // Set instance
 {
     let val: Set<any>
-    val = exactType(toDraft(val), val)
-    val = exactType(fromDraft(toDraft(val)), val)
+    val = fromDraft(toDraft(val))
+    let draft: typeof val = toDraft(val)
 
-    // Weak sets
     let weak: WeakSet<any>
-    weak = exactType(toDraft(weak), weak)
-    weak = exactType(fromDraft(toDraft(weak)), weak)
+    weak = fromDraft(toDraft(weak))
+    let weakDraft: typeof weak = toDraft(weak)
 }
 
 // Promise object
 {
     let val: Promise<any>
-    val = exactType(toDraft(val), val)
-    val = exactType(fromDraft(toDraft(val)), val)
+    val = fromDraft(toDraft(val))
+    let draft: typeof val = toDraft(val)
 }
 
 // Date instance
 {
     let val: Date
-    val = exactType(toDraft(val), val)
-    val = exactType(fromDraft(toDraft(val)), val)
+    val = fromDraft(toDraft(val))
+    let draft: typeof val = toDraft(val)
 }
 
 // RegExp instance
 {
     let val: RegExp
-    val = exactType(toDraft(val), val)
-    val = exactType(fromDraft(toDraft(val)), val)
+    val = fromDraft(toDraft(val))
+    let draft: typeof val = toDraft(val)
 }
 
 // Boxed primitive
 {
     let val: Boolean
-    val = exactType(toDraft(val), val)
-    val = exactType(fromDraft(toDraft(val)), val)
+    val = fromDraft(toDraft(val))
+    let draft: typeof val = toDraft(val)
 }
 
 // String literal
 {
     let val: string
-    val = exactType(toDraft(val), val)
-    val = exactType(fromDraft(toDraft(val)), val)
+    val = fromDraft(toDraft(val))
+    let draft: typeof val = toDraft(val)
 }
 
 // Any
 {
     let val: any
-    val = exactType(toDraft(val), val)
-    val = exactType(fromDraft(toDraft(val)), val)
+    val = fromDraft(toDraft(val))
+    let draft: typeof val = toDraft(val)
 }
 
 // Never
 {
     let val: never
-    val = exactType(toDraft(val), val)
-    val = exactType(fromDraft(toDraft(val)), val)
-}
-
-// Unknown
-{
-    // TODO: Uncomment this when Typescript is upgraded to 3.0+
-    // let val: unknown
-    // val = exactType(toDraft(val), val)
-    // val = exactType(fromDraft(toDraft(val)), val)
+    val = fromDraft(toDraft(val))
+    let draft: typeof val = toDraft(val)
 }
 
 // Numeral
 {
     let val: 1
-    val = exactType(toDraft(val), val)
-    val = exactType(fromDraft(toDraft(val)), val)
+    val = fromDraft(toDraft(val))
+    let draft: typeof val = toDraft(val)
 }
 
 // Union of numerals
 {
     let val: 1 | 2 | 3
-    val = exactType(toDraft(val), val)
-    val = exactType(fromDraft(toDraft(val)), val)
+    val = fromDraft(toDraft(val))
+    let draft: typeof val = toDraft(val)
 }
 
 // Union of tuple, array, object
 {
     let val: [0] | ReadonlyArray<string> | Readonly<{a: 1}>
-    let draft: DraftTuple<[0]> | string[] | {a: 1}
-    draft = exactType(toDraft(val), val)
-    val = exactType(fromDraft(draft), val)
+    val = fromDraft(toDraft(val))
+    let draft: DraftTuple<[0]> | string[] | {a: 1} = toDraft(val)
 }
diff --git a/package.json b/package.json
index c3ff623..53be265 100644
--- a/package.json
+++ b/package.json
@@ -70,7 +70,7 @@
     "rollup-plugin-node-resolve": "^3.0.2",
     "rollup-plugin-uglify": "^2.0.1",
     "seamless-immutable": "^7.1.3",
-    "typescript": "3.1.1",
+    "typescript": "2.8.1",
     "uglify-es": "^3.3.6",
     "yarn-or-npm": "^2.0.4"
   },
diff --git a/readme.md b/readme.md
index a08b273..2b1b4e7 100644
--- a/readme.md
+++ b/readme.md
@@ -513,7 +513,7 @@ const newState = produce<State>(state, draft => {
 
 This ensures that the only place you can modify your state is in your produce callbacks. It even works recursively and with `ReadonlyArray`s!
 
-**Note:** Immer v1.9+ supports Typescript v3.1+ only.
+Using TypeScript v2.7.x or lower is _not_ supported by Immer.
 
 ## Immer on older JavaScript environments?
 
diff --git a/src/immer.d.ts b/src/immer.d.ts
index 1c58ed3..62e79a6 100644
--- a/src/immer.d.ts
+++ b/src/immer.d.ts
@@ -15,14 +15,10 @@ type AtomicObject =
 /** Use type inference to know when an array is finite */
 type IsFinite<T extends any[]> = T extends never[]
     ? true
-    : T extends ReadonlyArray<infer U>
-    ? (U[] extends T ? false : true)
-    : true
+    : T extends ReadonlyArray<infer U> ? (U[] extends T ? false : true) : true
 
 export type DraftObject<T> = T extends object
-    ? T extends AtomicObject
-        ? T
-        : {-readonly [P in keyof T]: Draft<T[P]>}
+    ? T extends AtomicObject ? T : {-readonly [P in keyof T]: Draft<T[P]>}
     : T
 
 export type DraftArray<T> = Array<
@@ -36,14 +32,10 @@ export type DraftTuple<T extends any[]> = {
 }
 
 export type Draft<T> = T extends any[]
-    ? IsFinite<T> extends true
-        ? DraftTuple<T>
-        : DraftArray<T[number]>
+    ? IsFinite<T> extends true ? DraftTuple<T> : DraftArray<T[number]>
     : T extends ReadonlyArray<any>
-    ? DraftArray<T[number]>
-    : T extends object
-    ? DraftObject<T>
-    : T
+        ? DraftArray<T[number]>
+        : T extends object ? DraftObject<T> : T
 
 export interface Patch {
     op: "replace" | "remove" | "add"
@@ -67,26 +59,84 @@ export interface IProduce {
      * @param initialState - if a curried function is created and this argument was given, it will be used as fallback if the curried function is called with a state of undefined
      * @returns The next state: a new state, or the current state if nothing was modified
      */
-    <S = any, R = never>(
+    <S = any>(
         currentState: S,
-        recipe: (this: Draft<S>, draftState: Draft<S>) => void | R,
+        recipe: (this: Draft<S>, draftState: Draft<S>) => void | S,
         listener?: PatchListener
-    ): R
+    ): S
 
-    /** Curried producer with an initial state */
-    <S = any, R = never>(
-        recipe: (this: Draft<S>, draftState: Draft<S>) => void | R,
+    // curried invocations with default initial state
+    // 0 additional arguments
+    <S = any>(
+        recipe: (this: Draft<S>, draftState: Draft<S>) => void | S,
         initialState: S
-    ): (currentState: S | undefined) => R
-
-    /** Curried producer with no initial state */
-    <S = any, R = never, Args extends any[] = any[]>(
+    ): (currentState: S | undefined) => S
+    // 1 additional argument of type A
+    <S = any, A = any>(
+        recipe: (this: Draft<S>, draftState: Draft<S>, a: A) => void | S,
+        initialState: S
+    ): (currentState: S | undefined, a: A) => S
+    // 2 additional arguments of types A and B
+    <S = any, A = any, B = any>(
+        recipe: (this: Draft<S>, draftState: Draft<S>, a: A, b: B) => void | S,
+        initialState: S
+    ): (currentState: S | undefined, a: A, b: B) => S
+    // 3 additional arguments of types A, B and C
+    <S = any, A = any, B = any, C = any>(
+        recipe: (
+            this: Draft<S>,
+            draftState: Draft<S>,
+            a: A,
+            b: B,
+            c: C
+        ) => void | S,
+        initialState: S
+    ): (currentState: S | undefined, a: A, b: B, c: C) => S
+    // any number of additional arguments, but with loss of type safety
+    // this may be alleviated if "variadic kinds" makes it into Typescript:
+    // https://github.com/Microsoft/TypeScript/issues/5453
+    <S = any>(
+        recipe: (
+            this: Draft<S>,
+            draftState: Draft<S>,
+            ...extraArgs: any[]
+        ) => void | S,
+        initialState: S
+    ): (currentState: S | undefined, ...extraArgs: any[]) => S
+
+    // curried invocations without default initial state
+    // 0 additional arguments
+    <S = any>(recipe: (this: Draft<S>, draftState: Draft<S>) => void | S): (
+        currentState: S
+    ) => S
+    // 1 additional argument of type A
+    <S = any, A = any>(
+        recipe: (this: Draft<S>, draftState: Draft<S>, a: A) => void | S
+    ): (currentState: S, a: A) => S
+    // 2 additional arguments of types A and B
+    <S = any, A = any, B = any>(
+        recipe: (this: Draft<S>, draftState: Draft<S>, a: A, b: B) => void | S
+    ): (currentState: S, a: A, b: B) => S
+    // 3 additional arguments of types A, B and C
+    <S = any, A = any, B = any, C = any>(
+        recipe: (
+            this: Draft<S>,
+            draftState: Draft<S>,
+            a: A,
+            b: B,
+            c: C
+        ) => void | S
+    ): (currentState: S, a: A, b: B, c: C) => S
+    // any number of additional arguments, but with loss of type safety
+    // this may be alleviated if "variadic kinds" makes it into Typescript:
+    // https://github.com/Microsoft/TypeScript/issues/5453
+    <S = any>(
         recipe: (
             this: Draft<S>,
             draftState: Draft<S>,
-            ...extraArgs: Args
-        ) => void | R
-    ): (currentState: S, ...extraArgs: Args) => R
+            ...extraArgs: any[]
+        ) => void | S
+    ): (currentState: S, ...extraArgs: any[]) => S
 }
 
 export const produce: IProduce
diff --git a/yarn.lock b/yarn.lock
index bdfdc2f..5dee40c 100644
--- a/yarn.lock
+++ b/yarn.lock
@@ -4483,10 +4483,10 @@ type-check@~0.3.2:
   dependencies:
     prelude-ls "~1.1.2"
 
-typescript@3.1.1:
-  version "3.1.1"
-  resolved "https://registry.yarnpkg.com/typescript/-/typescript-3.1.1.tgz#3362ba9dd1e482ebb2355b02dfe8bcd19a2c7c96"
-  integrity sha512-Veu0w4dTc/9wlWNf2jeRInNodKlcdLgemvPsrNpfu5Pq39sgfFjvIIgTsvUHCoLBnMhPoUA+tFxsXjU6VexVRQ==
+typescript@2.8.1:
+  version "2.8.1"
+  resolved "https://registry.yarnpkg.com/typescript/-/typescript-2.8.1.tgz#6160e4f8f195d5ba81d4876f9c0cc1fbc0820624"
+  integrity sha512-Ao/f6d/4EPLq0YwzsQz8iXflezpTkQzqAyenTiw4kCUGr1uPiFLC3+fZ+gMZz6eeI/qdRUqvC+HxIJzUAzEFdg==
 
 uglify-es@^3.3.6:
   version "3.3.9"
