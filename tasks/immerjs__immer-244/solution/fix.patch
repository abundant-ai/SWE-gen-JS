diff --git a/package.json b/package.json
index 53be265..c3ff623 100644
--- a/package.json
+++ b/package.json
@@ -70,7 +70,7 @@
     "rollup-plugin-node-resolve": "^3.0.2",
     "rollup-plugin-uglify": "^2.0.1",
     "seamless-immutable": "^7.1.3",
-    "typescript": "2.8.1",
+    "typescript": "3.1.1",
     "uglify-es": "^3.3.6",
     "yarn-or-npm": "^2.0.4"
   },
diff --git a/readme.md b/readme.md
index 2b1b4e7..a08b273 100644
--- a/readme.md
+++ b/readme.md
@@ -513,7 +513,7 @@ const newState = produce<State>(state, draft => {
 
 This ensures that the only place you can modify your state is in your produce callbacks. It even works recursively and with `ReadonlyArray`s!
 
-Using TypeScript v2.7.x or lower is _not_ supported by Immer.
+**Note:** Immer v1.9+ supports Typescript v3.1+ only.
 
 ## Immer on older JavaScript environments?
 
diff --git a/src/immer.d.ts b/src/immer.d.ts
index 62e79a6..1c58ed3 100644
--- a/src/immer.d.ts
+++ b/src/immer.d.ts
@@ -15,10 +15,14 @@ type AtomicObject =
 /** Use type inference to know when an array is finite */
 type IsFinite<T extends any[]> = T extends never[]
     ? true
-    : T extends ReadonlyArray<infer U> ? (U[] extends T ? false : true) : true
+    : T extends ReadonlyArray<infer U>
+    ? (U[] extends T ? false : true)
+    : true
 
 export type DraftObject<T> = T extends object
-    ? T extends AtomicObject ? T : {-readonly [P in keyof T]: Draft<T[P]>}
+    ? T extends AtomicObject
+        ? T
+        : {-readonly [P in keyof T]: Draft<T[P]>}
     : T
 
 export type DraftArray<T> = Array<
@@ -32,10 +36,14 @@ export type DraftTuple<T extends any[]> = {
 }
 
 export type Draft<T> = T extends any[]
-    ? IsFinite<T> extends true ? DraftTuple<T> : DraftArray<T[number]>
+    ? IsFinite<T> extends true
+        ? DraftTuple<T>
+        : DraftArray<T[number]>
     : T extends ReadonlyArray<any>
-        ? DraftArray<T[number]>
-        : T extends object ? DraftObject<T> : T
+    ? DraftArray<T[number]>
+    : T extends object
+    ? DraftObject<T>
+    : T
 
 export interface Patch {
     op: "replace" | "remove" | "add"
@@ -59,84 +67,26 @@ export interface IProduce {
      * @param initialState - if a curried function is created and this argument was given, it will be used as fallback if the curried function is called with a state of undefined
      * @returns The next state: a new state, or the current state if nothing was modified
      */
-    <S = any>(
+    <S = any, R = never>(
         currentState: S,
-        recipe: (this: Draft<S>, draftState: Draft<S>) => void | S,
+        recipe: (this: Draft<S>, draftState: Draft<S>) => void | R,
         listener?: PatchListener
-    ): S
+    ): R
 
-    // curried invocations with default initial state
-    // 0 additional arguments
-    <S = any>(
-        recipe: (this: Draft<S>, draftState: Draft<S>) => void | S,
-        initialState: S
-    ): (currentState: S | undefined) => S
-    // 1 additional argument of type A
-    <S = any, A = any>(
-        recipe: (this: Draft<S>, draftState: Draft<S>, a: A) => void | S,
-        initialState: S
-    ): (currentState: S | undefined, a: A) => S
-    // 2 additional arguments of types A and B
-    <S = any, A = any, B = any>(
-        recipe: (this: Draft<S>, draftState: Draft<S>, a: A, b: B) => void | S,
-        initialState: S
-    ): (currentState: S | undefined, a: A, b: B) => S
-    // 3 additional arguments of types A, B and C
-    <S = any, A = any, B = any, C = any>(
-        recipe: (
-            this: Draft<S>,
-            draftState: Draft<S>,
-            a: A,
-            b: B,
-            c: C
-        ) => void | S,
+    /** Curried producer with an initial state */
+    <S = any, R = never>(
+        recipe: (this: Draft<S>, draftState: Draft<S>) => void | R,
         initialState: S
-    ): (currentState: S | undefined, a: A, b: B, c: C) => S
-    // any number of additional arguments, but with loss of type safety
-    // this may be alleviated if "variadic kinds" makes it into Typescript:
-    // https://github.com/Microsoft/TypeScript/issues/5453
-    <S = any>(
-        recipe: (
-            this: Draft<S>,
-            draftState: Draft<S>,
-            ...extraArgs: any[]
-        ) => void | S,
-        initialState: S
-    ): (currentState: S | undefined, ...extraArgs: any[]) => S
-
-    // curried invocations without default initial state
-    // 0 additional arguments
-    <S = any>(recipe: (this: Draft<S>, draftState: Draft<S>) => void | S): (
-        currentState: S
-    ) => S
-    // 1 additional argument of type A
-    <S = any, A = any>(
-        recipe: (this: Draft<S>, draftState: Draft<S>, a: A) => void | S
-    ): (currentState: S, a: A) => S
-    // 2 additional arguments of types A and B
-    <S = any, A = any, B = any>(
-        recipe: (this: Draft<S>, draftState: Draft<S>, a: A, b: B) => void | S
-    ): (currentState: S, a: A, b: B) => S
-    // 3 additional arguments of types A, B and C
-    <S = any, A = any, B = any, C = any>(
-        recipe: (
-            this: Draft<S>,
-            draftState: Draft<S>,
-            a: A,
-            b: B,
-            c: C
-        ) => void | S
-    ): (currentState: S, a: A, b: B, c: C) => S
-    // any number of additional arguments, but with loss of type safety
-    // this may be alleviated if "variadic kinds" makes it into Typescript:
-    // https://github.com/Microsoft/TypeScript/issues/5453
-    <S = any>(
+    ): (currentState: S | undefined) => R
+
+    /** Curried producer with no initial state */
+    <S = any, R = never, Args extends any[] = any[]>(
         recipe: (
             this: Draft<S>,
             draftState: Draft<S>,
-            ...extraArgs: any[]
-        ) => void | S
-    ): (currentState: S, ...extraArgs: any[]) => S
+            ...extraArgs: Args
+        ) => void | R
+    ): (currentState: S, ...extraArgs: Args) => R
 }
 
 export const produce: IProduce
diff --git a/yarn.lock b/yarn.lock
index 5dee40c..bdfdc2f 100644
--- a/yarn.lock
+++ b/yarn.lock
@@ -4483,10 +4483,10 @@ type-check@~0.3.2:
   dependencies:
     prelude-ls "~1.1.2"
 
-typescript@2.8.1:
-  version "2.8.1"
-  resolved "https://registry.yarnpkg.com/typescript/-/typescript-2.8.1.tgz#6160e4f8f195d5ba81d4876f9c0cc1fbc0820624"
-  integrity sha512-Ao/f6d/4EPLq0YwzsQz8iXflezpTkQzqAyenTiw4kCUGr1uPiFLC3+fZ+gMZz6eeI/qdRUqvC+HxIJzUAzEFdg==
+typescript@3.1.1:
+  version "3.1.1"
+  resolved "https://registry.yarnpkg.com/typescript/-/typescript-3.1.1.tgz#3362ba9dd1e482ebb2355b02dfe8bcd19a2c7c96"
+  integrity sha512-Veu0w4dTc/9wlWNf2jeRInNodKlcdLgemvPsrNpfu5Pq39sgfFjvIIgTsvUHCoLBnMhPoUA+tFxsXjU6VexVRQ==
 
 uglify-es@^3.3.6:
   version "3.3.9"
