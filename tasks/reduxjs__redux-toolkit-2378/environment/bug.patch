diff --git a/packages/toolkit/src/createReducer.ts b/packages/toolkit/src/createReducer.ts
index ca26edfa..06e48467 100644
--- a/packages/toolkit/src/createReducer.ts
+++ b/packages/toolkit/src/createReducer.ts
@@ -4,7 +4,6 @@ import type { AnyAction, Action, Reducer } from 'redux'
 import type { ActionReducerMapBuilder } from './mapBuilders'
 import { executeReducerBuilderCallback } from './mapBuilders'
 import type { NoInfer } from './tsHelpers'
-import { freezeDraftable } from './utils'
 
 /**
  * Defines a mapping from action types to corresponding action object shapes.
@@ -224,12 +223,12 @@ export function createReducer<S extends NotFunction<any>>(
       ? executeReducerBuilderCallback(mapOrBuilderCallback)
       : [mapOrBuilderCallback, actionMatchers, defaultCaseReducer]
 
-  // Ensure the initial state gets frozen either way (if draftable)
+  // Ensure the initial state gets frozen either way
   let getInitialState: () => S
   if (isStateFunction(initialState)) {
-    getInitialState = () => freezeDraftable(initialState())
+    getInitialState = () => createNextState(initialState(), () => {})
   } else {
-    const frozenInitialState = freezeDraftable(initialState)
+    const frozenInitialState = createNextState(initialState, () => {})
     getInitialState = () => frozenInitialState
   }
 
diff --git a/packages/toolkit/src/createSlice.ts b/packages/toolkit/src/createSlice.ts
index bbebc09b..5e120ae4 100644
--- a/packages/toolkit/src/createSlice.ts
+++ b/packages/toolkit/src/createSlice.ts
@@ -17,7 +17,6 @@ import { createReducer, NotFunction } from './createReducer'
 import type { ActionReducerMapBuilder } from './mapBuilders'
 import { executeReducerBuilderCallback } from './mapBuilders'
 import type { NoInfer } from './tsHelpers'
-import { freezeDraftable } from './utils'
 
 /**
  * An action creator attached to a slice.
@@ -227,15 +226,16 @@ type SliceDefinedCaseReducers<CaseReducers extends SliceCaseReducers<any>> = {
 export type ValidateSliceCaseReducers<
   S,
   ACR extends SliceCaseReducers<S>
-> = ACR & {
-  [T in keyof ACR]: ACR[T] extends {
-    reducer(s: S, action?: infer A): any
+> = ACR &
+  {
+    [T in keyof ACR]: ACR[T] extends {
+      reducer(s: S, action?: infer A): any
+    }
+      ? {
+          prepare(...a: never[]): Omit<A, 'type'>
+        }
+      : {}
   }
-    ? {
-        prepare(...a: never[]): Omit<A, 'type'>
-      }
-    : {}
-}
 
 function getType(slice: string, actionKey: string): string {
   return `${slice}/${actionKey}`
@@ -265,7 +265,7 @@ export function createSlice<
   const initialState =
     typeof options.initialState == 'function'
       ? options.initialState
-      : freezeDraftable(options.initialState)
+      : createNextState(options.initialState, () => {})
 
   const reducers = options.reducers || {}
 
diff --git a/packages/toolkit/src/tests/createReducer.test.ts b/packages/toolkit/src/tests/createReducer.test.ts
index 2356d209..97985991 100644
--- a/packages/toolkit/src/tests/createReducer.test.ts
+++ b/packages/toolkit/src/tests/createReducer.test.ts
@@ -106,9 +106,6 @@ describe('createReducer', () => {
         /Cannot assign to read only property/
       )
     })
-    test('does not throw error if initial state is not draftable', () => {
-      expect(() => createReducer(new URLSearchParams(), {})).not.toThrowError()
-    })
   })
 
   describe('given pure reducers with immutable updates', () => {
diff --git a/packages/toolkit/src/tests/createSlice.test.ts b/packages/toolkit/src/tests/createSlice.test.ts
index 5b8ba633..3aee1309 100644
--- a/packages/toolkit/src/tests/createSlice.test.ts
+++ b/packages/toolkit/src/tests/createSlice.test.ts
@@ -74,16 +74,6 @@ describe('createSlice', () => {
 
       expect(slice.getInitialState()).toBe(initialState)
     })
-
-    it('should allow non-draftable initial state', () => {
-      expect(() =>
-        createSlice({
-          name: 'params',
-          initialState: new URLSearchParams(),
-          reducers: {},
-        })
-      ).not.toThrowError()
-    })
   })
 
   describe('when initialState is a function', () => {
@@ -115,16 +105,6 @@ describe('createSlice', () => {
 
       expect(slice.getInitialState()).toBe(42)
     })
-
-    it('should allow non-draftable initial state', () => {
-      expect(() =>
-        createSlice({
-          name: 'params',
-          initialState: () => new URLSearchParams(),
-          reducers: {},
-        })
-      ).not.toThrowError()
-    })
   })
 
   describe('when mutating state object', () => {
diff --git a/packages/toolkit/src/utils.ts b/packages/toolkit/src/utils.ts
index c16eb835..5a3c77e1 100644
--- a/packages/toolkit/src/utils.ts
+++ b/packages/toolkit/src/utils.ts
@@ -1,4 +1,3 @@
-import createNextState, { isDraftable } from 'immer'
 import type { Middleware } from 'redux'
 
 export function getTimeMeasureUtils(maxDelay: number, fnName: string) {
@@ -65,7 +64,3 @@ export class MiddlewareArray<
     return new MiddlewareArray(...arr.concat(this))
   }
 }
-
-export function freezeDraftable<T>(val: T) {
-  return isDraftable(val) ? createNextState(val, () => {}) : val
-}
