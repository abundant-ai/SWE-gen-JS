diff --git a/CHANGELOG.md b/CHANGELOG.md
index b6ae73da..38c2bb06 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -5,7 +5,6 @@
 ### Breaking changes:
 
 - [#368]: The (undocumented) `toJSON()` method of nodes has been removed. It was originally intended to support an experimental feature of the Ohm Editor.
-- [#398]: Changed the default behavior `toAST` for the built-in list rules (`ListOf` and friends). Both the syntactic (`ListOf`, ...) and lexical versions (`listOf`, ...) are now represented as arrays, with the separators _discarded_. Previously, the syntactic versions were represented by arrays, but with separators _included_, and the lexical versions were represented as strings (just like other lexical rules).
 
 ### Other notable changes:
 
diff --git a/doc/extras.md b/doc/extras.md
index a0553e8e..0567a90b 100644
--- a/doc/extras.md
+++ b/doc/extras.md
@@ -62,13 +62,12 @@ There are certain general assumptions for the CST-to-AST conversion. They are ex
 
 ### General Assumptions
 
-By default:
+Per default:
 
 1. Every node in an AST has a **'type' property** that is derived from the name of the matching rule (those rule names may consist of the original rule name and the case name (see [Inline Rule Declarations](syntax-reference.md#inline-rule-declarations))).
 2. If a node's value is a **concrete value**, like the `"+"` in the example above, it will be omitted in the AST (not if there different possibilities though).
 3. If a rule only has one child node, it is considered an **intermediate node** that does not add any value and is therefore omitted.
 4. Possibly **repetitive** applications (`*` and `+` operator, `ListOf`) are represented as arrays of values, **optional** applications (`?` operator) are represented by their matched value or `null`.
-5. The built-in list rules (`ListOf`/`listOf` and friends) are represented as arrays of values, with the separators discarded.
 
 All those defaults can be changed by the optional second parameter - _mapping_ - handed to `toAST()`.
 
diff --git a/packages/ohm-js/extras/semantics-toAST.js b/packages/ohm-js/extras/semantics-toAST.js
index a96d50e8..1f67559e 100644
--- a/packages/ohm-js/extras/semantics-toAST.js
+++ b/packages/ohm-js/extras/semantics-toAST.js
@@ -1,27 +1,8 @@
 'use strict';
 
-function handleListOf(child) {
-  return child.toAST(this.args.mapping);
-}
-
-function handleEmptyListOf() {
-  return [];
-}
-
-function handleNonemptyListOf(first, sep, rest) {
-  return [first.toAST(this.args.mapping)].concat(rest.toAST(this.args.mapping));
-}
-
-const defaultMapping = {
-  listOf: handleListOf,
-  ListOf: handleListOf,
-
-  emptyListOf: handleEmptyListOf,
-  EmptyListOf: handleEmptyListOf,
-
-  nonemptyListOf: handleNonemptyListOf,
-  NonemptyListOf: handleNonemptyListOf,
-};
+// --------------------------------------------------------------------
+// Operations
+// --------------------------------------------------------------------
 
 const defaultOperation = {
   _terminal() {
@@ -47,6 +28,7 @@ const defaultOperation = {
 
       // rest: terms with multiple children
     }
+
     // direct forward
     if (typeof mapping[ctorName] === 'number') {
       return children[mapping[ctorName]].toAST(mapping);
@@ -97,7 +79,17 @@ const defaultOperation = {
       }
     }
 
-    return children.map(c => c.toAST(this.args.mapping));
+    return children.map(function(child) {
+      return child.toAST(this.args.mapping);
+    }, this);
+  },
+
+  NonemptyListOf(first, sep, rest) {
+    return [first.toAST(this.args.mapping)].concat(rest.toAST(this.args.mapping));
+  },
+
+  EmptyListOf() {
+    return [];
   },
 };
 
@@ -110,7 +102,7 @@ function toAST(res, mapping) {
     throw new Error('toAST() expects a succesful MatchResult as first parameter');
   }
 
-  mapping = Object.assign({}, defaultMapping, mapping);
+  mapping = Object.assign({}, mapping);
   const operation = Object.assign({}, defaultOperation);
   for (const termName in mapping) {
     if (typeof mapping[termName] === 'function') {
diff --git a/packages/ohm-js/test/extras/test-toAST.js b/packages/ohm-js/test/extras/test-toAST.js
index a98fbc42..075a8641 100644
--- a/packages/ohm-js/test/extras/test-toAST.js
+++ b/packages/ohm-js/test/extras/test-toAST.js
@@ -264,49 +264,3 @@ test('usage errors', t => {
     message: /semanticsToAST\(\) expects a Grammar as parameter/,
   });
 });
-
-test('listOf and friends - #394', t => {
-  // By default, toAST assumes that lexical rules represent indivisible tokens,
-  // but that doesn't make sense for listOf, nonemptyListOf, and emptyListOf.
-  const g = ohm.grammar(`
-    G {
-      Exp = listOf<digit, "+">
-      Exp2 = ListOf<digit, "+">
-    }
-  `);
-
-  const ast = (input, mapping) => toAST(g.match(input), mapping);
-  const astSyntactic = input => toAST(g.match(input, 'Exp2'));
-
-  // By default, the `listOf` action should pass through, and both `nonemptyListOf`
-  // and `emptyListOf` should return an array.
-  t.deepEqual(ast('3+5'), ['3', '5']);
-  t.deepEqual(ast(''), []);
-
-  // The AST should be the same whether we use `listOf` or `ListOf`.
-  t.deepEqual(ast('3+5'), astSyntactic('3 + 5'));
-  t.deepEqual(ast(''), astSyntactic(''));
-
-  // Ensure that it's still be possible to override the default mappings.
-
-  t.is(
-      ast('0+1', {
-        nonemptyListOf: (first, sep, rest) => 'XX',
-      }),
-      'XX'
-  );
-
-  t.is(
-      ast('1+2', {
-        nonemptyListOf: 0,
-      }),
-      '1'
-  );
-
-  t.is(
-      ast('', {
-        emptyListOf: () => 'nix',
-      }),
-      'nix'
-  );
-});
