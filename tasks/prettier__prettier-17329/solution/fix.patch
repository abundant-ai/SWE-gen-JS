diff --git a/changelog_unreleased/javascript/17329.md b/changelog_unreleased/javascript/17329.md
new file mode 100644
index 000000000..434d8c569
--- /dev/null
+++ b/changelog_unreleased/javascript/17329.md
@@ -0,0 +1,19 @@
+#### Allow break import attributes into multiple lines (#17329 by @fisker)
+
+<!-- prettier-ignore -->
+```jsx
+// Input
+import syntaxImportAssertions from "@babel/plugin-syntax-import-assertions" with {
+  BABEL_8_BREAKING: "false",
+  USE_ESM: "true", IS_STANDALONE: "false" };
+
+// Prettier stable
+import syntaxImportAssertions from "@babel/plugin-syntax-import-assertions" with { BABEL_8_BREAKING: "false", USE_ESM: "true", IS_STANDALONE: "false" };
+
+// Prettier main
+import syntaxImportAssertions from "@babel/plugin-syntax-import-assertions" with {
+  BABEL_8_BREAKING: "false",
+  USE_ESM: "true",
+  IS_STANDALONE: "false",
+};
+```
diff --git a/src/language-js/print/module.js b/src/language-js/print/module.js
index a97402537..f78761505 100644
--- a/src/language-js/print/module.js
+++ b/src/language-js/print/module.js
@@ -7,6 +7,7 @@ import {
   line,
   softline,
 } from "../../document/builders.js";
+import { removeLines } from "../../document/utils.js";
 import { printDanglingComments } from "../../main/comments/print.js";
 import isNonEmptyArray from "../../utils/is-non-empty-array.js";
 import UnexpectedNodeError from "../../utils/unexpected-node-error.js";
@@ -23,11 +24,15 @@ import {
 } from "../utils/index.js";
 import { printDecoratorsBeforeExport } from "./decorators.js";
 import { printDeclareToken } from "./misc.js";
+import { printObject } from "./object.js";
 
 /**
  * @import {Doc} from "../../document/builders.js"
  */
 
+/*
+- `ImportDeclaration`
+*/
 function printImportDeclaration(path, options, print) {
   const { node } = path;
   /** @type{Doc[]} */
@@ -49,8 +54,8 @@ const isDefaultExport = (node) =>
 /*
 - `ExportDefaultDeclaration`
 - `ExportNamedDeclaration`
-- `DeclareExportDeclaration`(flow)
 - `ExportAllDeclaration`
+- `DeclareExportDeclaration`(flow)
 - `DeclareExportAllDeclaration`(flow)
 */
 function printExportDeclaration(path, options, print) {
@@ -271,6 +276,34 @@ function getImportAttributesKeyword(node, options) {
   return isNonEmptyArray(node.attributes) ? "with" : undefined;
 }
 
+const isSingleTypeImportAttributes = (node) => {
+  const { attributes } = node;
+
+  if (attributes.length !== 1) {
+    return false;
+  }
+
+  const [attribute] = attributes;
+  const { type, key, value } = attribute;
+  return (
+    type === "ImportAttribute" &&
+    ((key.type === "Identifier" && key.name === "type") ||
+      (isStringLiteral(key) && key.value === "type")) &&
+    isStringLiteral(value) &&
+    !hasComment(attribute) &&
+    !hasComment(key) &&
+    !hasComment(value)
+  );
+};
+
+/*
+- `ImportDeclaration`
+- `ExportDefaultDeclaration`
+- `ExportNamedDeclaration`
+- `ExportAllDeclaration`
+- `DeclareExportDeclaration` (Flow)
+- `DeclareExportAllDeclaration` (Flow)
+*/
 function printImportAttributes(path, options, print) {
   const { node } = path;
 
@@ -283,23 +316,12 @@ function printImportAttributes(path, options, print) {
     return "";
   }
 
-  /** @type{Doc[]} */
-  const parts = [` ${keyword} {`];
-
-  if (isNonEmptyArray(node.attributes)) {
-    if (options.bracketSpacing) {
-      parts.push(" ");
-    }
-
-    parts.push(join(", ", path.map(print, "attributes")));
-
-    if (options.bracketSpacing) {
-      parts.push(" ");
-    }
+  let attributesDoc = printObject(path, options, print);
+  if (isSingleTypeImportAttributes(node)) {
+    attributesDoc = removeLines(attributesDoc);
   }
-  parts.push("}");
 
-  return parts;
+  return [` ${keyword} `, attributesDoc];
 }
 
 function printModuleSpecifier(path, options, print) {
diff --git a/src/language-js/print/object.js b/src/language-js/print/object.js
index eb7c004c6..e0f38641f 100644
--- a/src/language-js/print/object.js
+++ b/src/language-js/print/object.js
@@ -1,3 +1,4 @@
+import * as assert from "#universal/assert";
 import {
   group,
   hardline,
@@ -11,8 +12,10 @@ import hasNewline from "../../utils/has-newline.js";
 import hasNewlineInRange from "../../utils/has-newline-in-range.js";
 import isNonEmptyArray from "../../utils/is-non-empty-array.js";
 import { locEnd, locStart } from "../loc.js";
+import getTextWithoutComments from "../utils/get-text-without-comments.js";
 import {
   CommentCheckFlags,
+  createTypeCheckFunction,
   getComments,
   hasComment,
   isNextLineEmpty,
@@ -26,10 +29,39 @@ import { printTypeAnnotationProperty } from "./type-annotation.js";
 
 /** @import {Doc} from "../../document/builders.js" */
 
+const isPrintingImportAttributes = createTypeCheckFunction([
+  "ImportDeclaration",
+  "ExportDefaultDeclaration",
+  "ExportNamedDeclaration",
+  "ExportAllDeclaration",
+  "DeclareExportDeclaration",
+  "DeclareExportAllDeclaration",
+]);
+
+/*
+- `ObjectExpression`
+- `ObjectPattern`
+- `RecordExpression`
+- `ImportDeclaration`
+- `ExportDefaultDeclaration`
+- `ExportNamedDeclaration`
+- `ExportAllDeclaration`
+- `ObjectTypeAnnotation` (Flow)
+- `EnumBooleanBody` (Flow)
+- `EnumNumberBody` (Flow)
+- `EnumBigIntBody` (Flow)
+- `EnumStringBody` (Flow)
+- `EnumSymbolBody` (Flow)
+- `DeclareExportDeclaration` (Flow)
+- `DeclareExportAllDeclaration` (Flow)
+- `TSInterfaceBody` (TypeScript)
+- `TSTypeLiteral` (TypeScript)
+- `TSEnumDeclaration`(TypeScript)
+*/
 function printObject(path, options, print) {
   const { node } = path;
 
-  const isTypeAnnotation = node.type === "ObjectTypeAnnotation";
+  const isFlowTypeAnnotation = node.type === "ObjectTypeAnnotation";
   const isEnumBody =
     node.type === "TSEnumBody" ||
     node.type === "EnumBooleanBody" ||
@@ -37,15 +69,22 @@ function printObject(path, options, print) {
     node.type === "EnumBigIntBody" ||
     node.type === "EnumStringBody" ||
     node.type === "EnumSymbolBody";
-  const fields = [
-    node.type === "TSTypeLiteral" || isEnumBody
-      ? "members"
-      : node.type === "TSInterfaceBody"
-        ? "body"
-        : "properties",
-  ];
-  if (isTypeAnnotation) {
-    fields.push("indexers", "callProperties", "internalSlots");
+  const isInterfaceBody = node.type === "TSInterfaceBody";
+  const isImportAttributes = isPrintingImportAttributes(node);
+
+  const fields = [];
+  if (node.type === "TSTypeLiteral" || isEnumBody) {
+    fields.push("members");
+  } else if (isInterfaceBody) {
+    fields.push("body");
+  } else if (isImportAttributes) {
+    fields.push("attributes");
+  } else {
+    fields.push("properties");
+
+    if (isFlowTypeAnnotation) {
+      fields.push("indexers", "callProperties", "internalSlots");
+    }
   }
 
   // Unfortunately, things grouped together in the ast can be
@@ -68,13 +107,13 @@ function printObject(path, options, print) {
 
   const { parent, key } = path;
   const isFlowInterfaceLikeBody =
-    isTypeAnnotation &&
+    isFlowTypeAnnotation &&
     key === "body" &&
     (parent.type === "InterfaceDeclaration" ||
       parent.type === "DeclareInterface" ||
       parent.type === "DeclareClass");
   const shouldBreak =
-    node.type === "TSInterfaceBody" ||
+    isInterfaceBody ||
     isEnumBody ||
     isFlowInterfaceLikeBody ||
     (node.type === "ObjectPattern" &&
@@ -95,15 +134,11 @@ function printObject(path, options, print) {
     (node.type !== "ObjectPattern" &&
       options.objectWrap === "preserve" &&
       propsAndLoc.length > 0 &&
-      hasNewlineInRange(
-        options.originalText,
-        locStart(node),
-        propsAndLoc[0].loc,
-      ));
+      hasNewLineAfterLeftBrace(node, propsAndLoc[0], options));
 
   const separator = isFlowInterfaceLikeBody
     ? ";"
-    : node.type === "TSInterfaceBody" || node.type === "TSTypeLiteral"
+    : isInterfaceBody || node.type === "TSTypeLiteral"
       ? options.semi
         ? ";"
         : ifBreak("", ";")
@@ -180,19 +215,20 @@ function printObject(path, options, print) {
       printTypeAnnotationProperty(path, print),
     ]);
   } else {
+    const spacing = options.bracketSpacing ? line : softline;
     content = [
       isFlowInterfaceLikeBody && isNonEmptyArray(node.properties)
         ? printHardlineAfterHeritage(parent)
         : "",
       leftBrace,
-      indent([options.bracketSpacing ? line : softline, ...props]),
+      indent([spacing, ...props]),
       ifBreak(
         canHaveTrailingSeparator &&
           (separator !== "," || shouldPrintComma(options))
           ? separator
           : "",
       ),
-      options.bracketSpacing ? line : softline,
+      spacing,
       rightBrace,
       printOptionalToken(path),
       printTypeAnnotationProperty(path, print),
@@ -244,4 +280,27 @@ function shouldHugTheOnlyParameter(node, name) {
   );
 }
 
+function hasNewLineAfterLeftBrace(node, firstPropertyAndLoc, options) {
+  const text = options.originalText;
+  let leftBraceIndex = locStart(node);
+  const firstPropertyStart = firstPropertyAndLoc.loc;
+
+  if (isPrintingImportAttributes(node)) {
+    const start = locStart(node);
+    const textBeforeAttributes = getTextWithoutComments(
+      options,
+      start,
+      firstPropertyStart,
+    );
+    leftBraceIndex = start + textBeforeAttributes.lastIndexOf("{");
+  }
+
+  /* c8 ignore next 3 */
+  if (process.env.NODE_ENV !== "production") {
+    assert.equal(text.charAt(leftBraceIndex), "{");
+  }
+
+  return hasNewlineInRange(text, leftBraceIndex, firstPropertyStart);
+}
+
 export { printObject };
diff --git a/src/language-js/utils/get-text-without-comments.js b/src/language-js/utils/get-text-without-comments.js
index 936661a56..bbff70c46 100644
--- a/src/language-js/utils/get-text-without-comments.js
+++ b/src/language-js/utils/get-text-without-comments.js
@@ -16,15 +16,17 @@ function getTextWithoutComments(options, start, end) {
       continue;
     }
 
-    const commentLength = commentEnd - commentStart;
+    const startIndex = commentStart - start;
+    const endIndex = commentEnd - start;
+
     text =
-      text.slice(0, commentStart - start) +
-      " ".repeat(commentLength) +
-      text.slice(commentEnd - start);
+      text.slice(0, startIndex) +
+      text.slice(startIndex, endIndex).replaceAll(/[^\n]/gu, " ") +
+      text.slice(endIndex);
   }
 
   if (process.env.NODE_ENV !== "production") {
-    assert.ok(text.length === end - start);
+    assert.equal(text.length, end - start);
   }
 
   return text;
