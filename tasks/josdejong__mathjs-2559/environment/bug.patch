diff --git a/docs/core/chaining.md b/docs/core/chaining.md
index a26d36755..c97bcc57d 100644
--- a/docs/core/chaining.md
+++ b/docs/core/chaining.md
@@ -39,11 +39,3 @@ a number of special functions:
    Executes `math.format(value)` onto the chain's value, returning
    a string representation of the value.
 
-Note that a "rest" or "..." parameter may not be broken across the value
-in the chain and a function call. For example
-
-```js
-math.chain(3).median(4,5).done() // throws error
-```
-
-does not compute the median of 3, 4, and 5.
diff --git a/src/core/create.js b/src/core/create.js
index 88c4556b5..dcb416fb0 100644
--- a/src/core/create.js
+++ b/src/core/create.js
@@ -1,5 +1,4 @@
 import './../utils/polyfills.js'
-import typedFunction from 'typed-function'
 import { deepFlatten, isLegacyFactory, values } from '../utils/object.js'
 import * as emitter from './../utils/emitter.js'
 import { importFactory } from './function/import.js'
@@ -207,8 +206,6 @@ export function create (factories, config) {
   function lazyTyped (...args) {
     return math.typed.apply(math.typed, args)
   }
-  lazyTyped.isTypedFunction = typedFunction.isTypedFunction
-
   const internalImport = importFactory(lazyTyped, load, math, importedFactories)
   math.import = internalImport
 
diff --git a/src/core/function/import.js b/src/core/function/import.js
index ac7c5980c..b4a6a02b0 100644
--- a/src/core/function/import.js
+++ b/src/core/function/import.js
@@ -144,7 +144,7 @@ export function importFactory (typed, load, math, importedFactories) {
       })
     }
 
-    if (typed.isTypedFunction(math[name]) && typed.isTypedFunction(value)) {
+    if (isTypedFunction(math[name]) && isTypedFunction(value)) {
       if (options.override) {
         // give the typed function the right name
         value = typed(name, value.signatures)
@@ -280,7 +280,7 @@ export function importFactory (typed, load, math, importedFactories) {
         return instance
       }
 
-      if (typed.isTypedFunction(existing) && typed.isTypedFunction(instance)) {
+      if (isTypedFunction(existing) && isTypedFunction(instance)) {
         // merge the existing and new typed function
         return typed(existing, instance)
       }
@@ -344,6 +344,15 @@ export function importFactory (typed, load, math, importedFactories) {
         Array.isArray(object)
   }
 
+  /**
+   * Test whether a given thing is a typed-function
+   * @param {*} fn
+   * @return {boolean} Returns true when `fn` is a typed-function
+   */
+  function isTypedFunction (fn) {
+    return typeof fn === 'function' && typeof fn.signatures === 'object'
+  }
+
   function hasTypedFunctionSignature (fn) {
     return typeof fn === 'function' && typeof fn.signature === 'string'
   }
diff --git a/src/core/function/typed.js b/src/core/function/typed.js
index 037345cfc..a3f9c90d6 100644
--- a/src/core/function/typed.js
+++ b/src/core/function/typed.js
@@ -361,25 +361,6 @@ export const createTyped = /* #__PURE__ */ factory('typed', dependencies, functi
     throw usualError
   }
 
-  // Provide a suggestion on how to call a function elementwise
-  // This was added primarily as guidance for the v10 -> v11 transition,
-  // and could potentially be removed in the future if it no longer seems
-  // to be helpful.
-  typed.onMismatch = (name, args, signatures) => {
-    const usualError = typed.createError(name, args, signatures)
-    if (['wrongType', 'mismatch'].includes(usualError.data.category) &&
-        args.length === 1 && isCollection(args[0]) &&
-        // check if the function can be unary:
-        signatures.some(sig => !sig.params.includes(','))) {
-      const err = new TypeError(
-        `Function '${name}' doesn't apply to matrices. To call it ` +
-          `elementwise on a matrix 'M', try 'map(M, ${name})'.`)
-      err.data = usualError.data
-      throw err
-    }
-    throw usualError
-  }
-
   return typed
 })
 
diff --git a/src/function/matrix/ones.js b/src/function/matrix/ones.js
index 5bd55b771..7e501304c 100644
--- a/src/function/matrix/ones.js
+++ b/src/function/matrix/ones.js
@@ -24,7 +24,6 @@ export const createOnes = /* #__PURE__ */ factory(name, dependencies, ({ typed,
    *
    * Examples:
    *
-   *    math.ones()                    // returns []
    *    math.ones(3)                   // returns [1, 1, 1]
    *    math.ones(3, 2)                // returns [[1, 1], [1, 1], [1, 1]]
    *    math.ones(3, 2, 'dense')       // returns Dense Matrix [[1, 1], [1, 1], [1, 1]]
@@ -36,7 +35,7 @@ export const createOnes = /* #__PURE__ */ factory(name, dependencies, ({ typed,
    *
    *    zeros, identity, size, range
    *
-   * @param {...(number|BigNumber) | Array} size    The size of each dimension of the matrix
+   * @param {...number | Array} size    The size of each dimension of the matrix
    * @param {string} [format]           The Matrix storage format
    *
    * @return {Array | Matrix | number}  A matrix filled with ones
diff --git a/src/function/matrix/zeros.js b/src/function/matrix/zeros.js
index 95f5d7912..eb53ceb41 100644
--- a/src/function/matrix/zeros.js
+++ b/src/function/matrix/zeros.js
@@ -22,7 +22,6 @@ export const createZeros = /* #__PURE__ */ factory(name, dependencies, ({ typed,
    *
    * Examples:
    *
-   *    math.zeros()                   // returns []
    *    math.zeros(3)                  // returns [0, 0, 0]
    *    math.zeros(3, 2)               // returns [[0, 0], [0, 0], [0, 0]]
    *    math.zeros(3, 'dense')         // returns [0, 0, 0]
@@ -34,7 +33,7 @@ export const createZeros = /* #__PURE__ */ factory(name, dependencies, ({ typed,
    *
    *    ones, identity, size, range
    *
-   * @param {...(number|BigNumber) | Array} size    The size of each dimension of the matrix
+   * @param {...number | Array} size    The size of each dimension of the matrix
    * @param {string} [format]           The Matrix storage format
    *
    * @return {Array | Matrix}           A matrix filled with zeros
diff --git a/src/type/chain/Chain.js b/src/type/chain/Chain.js
index 31ae3e9c7..351252a4a 100644
--- a/src/type/chain/Chain.js
+++ b/src/type/chain/Chain.js
@@ -4,9 +4,9 @@ import { hasOwnProperty, lazy } from '../../utils/object.js'
 import { factory } from '../../utils/factory.js'
 
 const name = 'Chain'
-const dependencies = ['?on', 'math', 'typed']
+const dependencies = ['?on', 'math']
 
-export const createChainClass = /* #__PURE__ */ factory(name, dependencies, ({ on, math, typed }) => {
+export const createChainClass = /* #__PURE__ */ factory(name, dependencies, ({ on, math }) => {
   /**
    * @constructor Chain
    * Wrap any value in a chain, allowing to perform chained operations on
@@ -130,26 +130,11 @@ export const createChainClass = /* #__PURE__ */ factory(name, dependencies, ({ o
    */
   function chainify (fn) {
     return function () {
-      // Here, `this` will be the context of a Chain instance
-      if (arguments.length === 0) {
-        return new Chain(fn(this.value))
-      }
-      const args = [this.value]
+      const args = [this.value] // `this` will be the context of a Chain instance
       for (let i = 0; i < arguments.length; i++) {
         args[i + 1] = arguments[i]
       }
-      if (typed.isTypedFunction(fn)) {
-        const sigObject = typed.resolve(fn, args)
-        // We want to detect if a rest parameter has matched across the
-        // value in the chain and the current arguments of this call.
-        // That is the case if and only if the matching signature has
-        // exactly one parameter (which then must be a rest parameter
-        // as it is matching at least two actual arguments).
-        if (sigObject.params.length === 1) {
-          throw new Error('chain function ' + fn.name + ' cannot match rest parameter between chain value and additional arguments.')
-        }
-        return new Chain(sigObject.implementation.apply(fn, args))
-      }
+
       return new Chain(fn.apply(fn, args))
     }
   }
diff --git a/test/unit-tests/type/chain/Chain.test.js b/test/unit-tests/type/chain/Chain.test.js
index 491c653e6..e14c7c1ef 100644
--- a/test/unit-tests/type/chain/Chain.test.js
+++ b/test/unit-tests/type/chain/Chain.test.js
@@ -11,15 +11,6 @@ describe('Chain', function () {
     assert.strictEqual(new Chain(0).add(3).done(), 3)
   })
 
-  it('should not chain a rest parameter across stored value and additional arguments', function () {
-    assert.throws(
-      () => new Chain(3).median(4, 5).done(),
-      /Error:.*median.*rest/)
-    assert.throws(
-      () => new Chain(3).ones(2, 'dense').done(),
-      /Error:.*ones.*rest/)
-  })
-
   it('should have a property isChain', function () {
     const a = new math.Chain(5)
     assert.strictEqual(a.isChain, true)
diff --git a/types/index.d.ts b/types/index.d.ts
index 89d5d06c6..713f8b0fb 100644
--- a/types/index.d.ts
+++ b/types/index.d.ts
@@ -978,7 +978,7 @@ declare namespace math {
     cbrt(x: number, allRoots?: boolean): number
     cbrt(x: BigNumber): BigNumber
     cbrt(x: Complex, allRoots?: boolean): Complex
-    cbrt(x: Unit): Unit
+    cbrt(x: Unit, allRoots?: boolean): Unit
 
     // Rounding functions, grouped for similarity, even though it breaks
     // the alphabetic order among arithmetic functions.
@@ -1845,37 +1845,14 @@ declare namespace math {
      * @param format The matrix storage format
      * @returns A matrix filled with ones
      */
-    ones(
-      size?: number | number[] | BigNumber | BigNumber[],
-      format?: string
-    ): MathCollection
+    ones(size: number | number[], format?: string): MathCollection
     /**
      * @param m The x dimension of the matrix
-     * @param n The y dimension of the matrix
-     * @param format The matrix storage format
-     * @returns A matrix filled with ones
-     */
-    ones(
-      m: number | BigNumber,
-      n: number | BigNumber,
-      format?: string
-    ): MathCollection
-    /**
-     * @param m The x dimension of the matrix
-     * @param n The y dimension of the matrix
-     * @param p The z dimension of the matrix
+     * @param n The y dimension of the amtrix
      * @param format The matrix storage format
      * @returns A matrix filled with ones
      */
-    ones(
-      m: number | BigNumber,
-      n: number | BigNumber,
-      p: number | BigNumber,
-      format?: string
-    ): MathCollection
-    /** Actually ones can take an arbitrary number of dimensions before the
-     ** optional format, not sure how to write that in TypeScript
-     **/
+    ones(m: number, n: number, format?: string): MathCollection
 
     /**
      * Partition-based selection of an array or 1D matrix. Will find the kth
@@ -2056,37 +2033,14 @@ declare namespace math {
      * @param format The matrix storage format
      * @returns A matrix filled with zeros
      */
-    zeros(
-      size?: number | number[] | BigNumber | BigNumber[],
-      format?: string
-    ): MathCollection
-    /**
-     * @param m The x dimension of the matrix
-     * @param n The y dimension of the matrix
-     * @param format The matrix storage format
-     * @returns A matrix filled with zeros
-     */
-    zeros(
-      m: number | BigNumber,
-      n: number | BigNumber,
-      format?: string
-    ): MathCollection
+    zeros(size: number | number[], format?: string): MathCollection
     /**
      * @param m The x dimension of the matrix
      * @param n The y dimension of the matrix
-     * @param p The z dimension of the matrix
      * @param format The matrix storage format
      * @returns A matrix filled with zeros
      */
-    zeros(
-      m: number | BigNumber,
-      n: number | BigNumber,
-      p: number | BigNumber,
-      format?: string
-    ): MathCollection
-    /** Actually zeros can take any number of dimensions before the
-     ** optional format, not sure how to write that in TypeScript
-     **/
+    zeros(m: number, n: number, format?: string): MathCollection
 
     /**
      * Calculate N-dimensional fourier transform
@@ -5269,7 +5223,16 @@ declare namespace math {
      * @param format The matrix storage format
      */
     ones(
-      this: MathJsChain<number | number[] | BigNumber | BigNumber[]>,
+      this: MathJsChain<number | number[]>,
+      format?: string
+    ): MathJsChain<MathCollection>
+
+    /**
+     * @param format The matrix storage format
+     */
+    ones(
+      this: MathJsChain<number>,
+      n: number,
       format?: string
     ): MathJsChain<MathCollection>
 
@@ -5408,7 +5371,17 @@ declare namespace math {
      * @returns A matrix filled with zeros
      */
     zeros(
-      this: MathJsChain<number | number[] | BigNumber | BigNumber[]>,
+      this: MathJsChain<number | number[]>,
+      format?: string
+    ): MathJsChain<MathCollection>
+
+    /**
+     * @param n The y dimension of the matrix
+     * @param format The matrix storage format
+     */
+    zeros(
+      this: MathJsChain<number>,
+      n: number,
       format?: string
     ): MathJsChain<MathCollection>
 
diff --git a/types/index.ts b/types/index.ts
index bee08685d..18dafe583 100644
--- a/types/index.ts
+++ b/types/index.ts
@@ -1100,11 +1100,6 @@ Matrices examples
   const b: math.Matrix = math.matrix(math.ones([2, 3]))
   b.size()
 
-  // @ts-expect-error ... ones() in a chain cannot take more dimensions
-  assert.throws(() => math.chain(3).ones(2, 'dense').done(), /Error:.*ones/)
-  // @ts-expect-error ... and neither can zeros()
-  assert.throws(() => math.chain(3).zeros(2, 'sparse').done(), /Error:.*zeros/)
-
   // the Array data of a Matrix can be retrieved using valueOf()
   const _array = a.valueOf()
 
