diff --git a/docs/core/chaining.md b/docs/core/chaining.md
index c97bcc57d..a26d36755 100644
--- a/docs/core/chaining.md
+++ b/docs/core/chaining.md
@@ -39,3 +39,11 @@ a number of special functions:
    Executes `math.format(value)` onto the chain's value, returning
    a string representation of the value.
 
+Note that a "rest" or "..." parameter may not be broken across the value
+in the chain and a function call. For example
+
+```js
+math.chain(3).median(4,5).done() // throws error
+```
+
+does not compute the median of 3, 4, and 5.
diff --git a/src/core/create.js b/src/core/create.js
index dcb416fb0..88c4556b5 100644
--- a/src/core/create.js
+++ b/src/core/create.js
@@ -1,4 +1,5 @@
 import './../utils/polyfills.js'
+import typedFunction from 'typed-function'
 import { deepFlatten, isLegacyFactory, values } from '../utils/object.js'
 import * as emitter from './../utils/emitter.js'
 import { importFactory } from './function/import.js'
@@ -206,6 +207,8 @@ export function create (factories, config) {
   function lazyTyped (...args) {
     return math.typed.apply(math.typed, args)
   }
+  lazyTyped.isTypedFunction = typedFunction.isTypedFunction
+
   const internalImport = importFactory(lazyTyped, load, math, importedFactories)
   math.import = internalImport
 
diff --git a/src/core/function/import.js b/src/core/function/import.js
index b4a6a02b0..ac7c5980c 100644
--- a/src/core/function/import.js
+++ b/src/core/function/import.js
@@ -144,7 +144,7 @@ export function importFactory (typed, load, math, importedFactories) {
       })
     }
 
-    if (isTypedFunction(math[name]) && isTypedFunction(value)) {
+    if (typed.isTypedFunction(math[name]) && typed.isTypedFunction(value)) {
       if (options.override) {
         // give the typed function the right name
         value = typed(name, value.signatures)
@@ -280,7 +280,7 @@ export function importFactory (typed, load, math, importedFactories) {
         return instance
       }
 
-      if (isTypedFunction(existing) && isTypedFunction(instance)) {
+      if (typed.isTypedFunction(existing) && typed.isTypedFunction(instance)) {
         // merge the existing and new typed function
         return typed(existing, instance)
       }
@@ -344,15 +344,6 @@ export function importFactory (typed, load, math, importedFactories) {
         Array.isArray(object)
   }
 
-  /**
-   * Test whether a given thing is a typed-function
-   * @param {*} fn
-   * @return {boolean} Returns true when `fn` is a typed-function
-   */
-  function isTypedFunction (fn) {
-    return typeof fn === 'function' && typeof fn.signatures === 'object'
-  }
-
   function hasTypedFunctionSignature (fn) {
     return typeof fn === 'function' && typeof fn.signature === 'string'
   }
diff --git a/src/core/function/typed.js b/src/core/function/typed.js
index a3f9c90d6..037345cfc 100644
--- a/src/core/function/typed.js
+++ b/src/core/function/typed.js
@@ -361,6 +361,25 @@ export const createTyped = /* #__PURE__ */ factory('typed', dependencies, functi
     throw usualError
   }
 
+  // Provide a suggestion on how to call a function elementwise
+  // This was added primarily as guidance for the v10 -> v11 transition,
+  // and could potentially be removed in the future if it no longer seems
+  // to be helpful.
+  typed.onMismatch = (name, args, signatures) => {
+    const usualError = typed.createError(name, args, signatures)
+    if (['wrongType', 'mismatch'].includes(usualError.data.category) &&
+        args.length === 1 && isCollection(args[0]) &&
+        // check if the function can be unary:
+        signatures.some(sig => !sig.params.includes(','))) {
+      const err = new TypeError(
+        `Function '${name}' doesn't apply to matrices. To call it ` +
+          `elementwise on a matrix 'M', try 'map(M, ${name})'.`)
+      err.data = usualError.data
+      throw err
+    }
+    throw usualError
+  }
+
   return typed
 })
 
diff --git a/src/function/matrix/ones.js b/src/function/matrix/ones.js
index 7e501304c..5bd55b771 100644
--- a/src/function/matrix/ones.js
+++ b/src/function/matrix/ones.js
@@ -24,6 +24,7 @@ export const createOnes = /* #__PURE__ */ factory(name, dependencies, ({ typed,
    *
    * Examples:
    *
+   *    math.ones()                    // returns []
    *    math.ones(3)                   // returns [1, 1, 1]
    *    math.ones(3, 2)                // returns [[1, 1], [1, 1], [1, 1]]
    *    math.ones(3, 2, 'dense')       // returns Dense Matrix [[1, 1], [1, 1], [1, 1]]
@@ -35,7 +36,7 @@ export const createOnes = /* #__PURE__ */ factory(name, dependencies, ({ typed,
    *
    *    zeros, identity, size, range
    *
-   * @param {...number | Array} size    The size of each dimension of the matrix
+   * @param {...(number|BigNumber) | Array} size    The size of each dimension of the matrix
    * @param {string} [format]           The Matrix storage format
    *
    * @return {Array | Matrix | number}  A matrix filled with ones
diff --git a/src/function/matrix/zeros.js b/src/function/matrix/zeros.js
index eb53ceb41..95f5d7912 100644
--- a/src/function/matrix/zeros.js
+++ b/src/function/matrix/zeros.js
@@ -22,6 +22,7 @@ export const createZeros = /* #__PURE__ */ factory(name, dependencies, ({ typed,
    *
    * Examples:
    *
+   *    math.zeros()                   // returns []
    *    math.zeros(3)                  // returns [0, 0, 0]
    *    math.zeros(3, 2)               // returns [[0, 0], [0, 0], [0, 0]]
    *    math.zeros(3, 'dense')         // returns [0, 0, 0]
@@ -33,7 +34,7 @@ export const createZeros = /* #__PURE__ */ factory(name, dependencies, ({ typed,
    *
    *    ones, identity, size, range
    *
-   * @param {...number | Array} size    The size of each dimension of the matrix
+   * @param {...(number|BigNumber) | Array} size    The size of each dimension of the matrix
    * @param {string} [format]           The Matrix storage format
    *
    * @return {Array | Matrix}           A matrix filled with zeros
diff --git a/src/type/chain/Chain.js b/src/type/chain/Chain.js
index 351252a4a..31ae3e9c7 100644
--- a/src/type/chain/Chain.js
+++ b/src/type/chain/Chain.js
@@ -4,9 +4,9 @@ import { hasOwnProperty, lazy } from '../../utils/object.js'
 import { factory } from '../../utils/factory.js'
 
 const name = 'Chain'
-const dependencies = ['?on', 'math']
+const dependencies = ['?on', 'math', 'typed']
 
-export const createChainClass = /* #__PURE__ */ factory(name, dependencies, ({ on, math }) => {
+export const createChainClass = /* #__PURE__ */ factory(name, dependencies, ({ on, math, typed }) => {
   /**
    * @constructor Chain
    * Wrap any value in a chain, allowing to perform chained operations on
@@ -130,11 +130,26 @@ export const createChainClass = /* #__PURE__ */ factory(name, dependencies, ({ o
    */
   function chainify (fn) {
     return function () {
-      const args = [this.value] // `this` will be the context of a Chain instance
+      // Here, `this` will be the context of a Chain instance
+      if (arguments.length === 0) {
+        return new Chain(fn(this.value))
+      }
+      const args = [this.value]
       for (let i = 0; i < arguments.length; i++) {
         args[i + 1] = arguments[i]
       }
-
+      if (typed.isTypedFunction(fn)) {
+        const sigObject = typed.resolve(fn, args)
+        // We want to detect if a rest parameter has matched across the
+        // value in the chain and the current arguments of this call.
+        // That is the case if and only if the matching signature has
+        // exactly one parameter (which then must be a rest parameter
+        // as it is matching at least two actual arguments).
+        if (sigObject.params.length === 1) {
+          throw new Error('chain function ' + fn.name + ' cannot match rest parameter between chain value and additional arguments.')
+        }
+        return new Chain(sigObject.implementation.apply(fn, args))
+      }
       return new Chain(fn.apply(fn, args))
     }
   }
diff --git a/types/index.d.ts b/types/index.d.ts
index 713f8b0fb..89d5d06c6 100644
--- a/types/index.d.ts
+++ b/types/index.d.ts
@@ -978,7 +978,7 @@ declare namespace math {
     cbrt(x: number, allRoots?: boolean): number
     cbrt(x: BigNumber): BigNumber
     cbrt(x: Complex, allRoots?: boolean): Complex
-    cbrt(x: Unit, allRoots?: boolean): Unit
+    cbrt(x: Unit): Unit
 
     // Rounding functions, grouped for similarity, even though it breaks
     // the alphabetic order among arithmetic functions.
@@ -1845,14 +1845,37 @@ declare namespace math {
      * @param format The matrix storage format
      * @returns A matrix filled with ones
      */
-    ones(size: number | number[], format?: string): MathCollection
+    ones(
+      size?: number | number[] | BigNumber | BigNumber[],
+      format?: string
+    ): MathCollection
     /**
      * @param m The x dimension of the matrix
-     * @param n The y dimension of the amtrix
+     * @param n The y dimension of the matrix
+     * @param format The matrix storage format
+     * @returns A matrix filled with ones
+     */
+    ones(
+      m: number | BigNumber,
+      n: number | BigNumber,
+      format?: string
+    ): MathCollection
+    /**
+     * @param m The x dimension of the matrix
+     * @param n The y dimension of the matrix
+     * @param p The z dimension of the matrix
      * @param format The matrix storage format
      * @returns A matrix filled with ones
      */
-    ones(m: number, n: number, format?: string): MathCollection
+    ones(
+      m: number | BigNumber,
+      n: number | BigNumber,
+      p: number | BigNumber,
+      format?: string
+    ): MathCollection
+    /** Actually ones can take an arbitrary number of dimensions before the
+     ** optional format, not sure how to write that in TypeScript
+     **/
 
     /**
      * Partition-based selection of an array or 1D matrix. Will find the kth
@@ -2033,14 +2056,37 @@ declare namespace math {
      * @param format The matrix storage format
      * @returns A matrix filled with zeros
      */
-    zeros(size: number | number[], format?: string): MathCollection
+    zeros(
+      size?: number | number[] | BigNumber | BigNumber[],
+      format?: string
+    ): MathCollection
+    /**
+     * @param m The x dimension of the matrix
+     * @param n The y dimension of the matrix
+     * @param format The matrix storage format
+     * @returns A matrix filled with zeros
+     */
+    zeros(
+      m: number | BigNumber,
+      n: number | BigNumber,
+      format?: string
+    ): MathCollection
     /**
      * @param m The x dimension of the matrix
      * @param n The y dimension of the matrix
+     * @param p The z dimension of the matrix
      * @param format The matrix storage format
      * @returns A matrix filled with zeros
      */
-    zeros(m: number, n: number, format?: string): MathCollection
+    zeros(
+      m: number | BigNumber,
+      n: number | BigNumber,
+      p: number | BigNumber,
+      format?: string
+    ): MathCollection
+    /** Actually zeros can take any number of dimensions before the
+     ** optional format, not sure how to write that in TypeScript
+     **/
 
     /**
      * Calculate N-dimensional fourier transform
@@ -5223,16 +5269,7 @@ declare namespace math {
      * @param format The matrix storage format
      */
     ones(
-      this: MathJsChain<number | number[]>,
-      format?: string
-    ): MathJsChain<MathCollection>
-
-    /**
-     * @param format The matrix storage format
-     */
-    ones(
-      this: MathJsChain<number>,
-      n: number,
+      this: MathJsChain<number | number[] | BigNumber | BigNumber[]>,
       format?: string
     ): MathJsChain<MathCollection>
 
@@ -5371,17 +5408,7 @@ declare namespace math {
      * @returns A matrix filled with zeros
      */
     zeros(
-      this: MathJsChain<number | number[]>,
-      format?: string
-    ): MathJsChain<MathCollection>
-
-    /**
-     * @param n The y dimension of the matrix
-     * @param format The matrix storage format
-     */
-    zeros(
-      this: MathJsChain<number>,
-      n: number,
+      this: MathJsChain<number | number[] | BigNumber | BigNumber[]>,
       format?: string
     ): MathJsChain<MathCollection>
 
diff --git a/types/index.ts b/types/index.ts
index 18dafe583..bee08685d 100644
--- a/types/index.ts
+++ b/types/index.ts
@@ -1100,6 +1100,11 @@ Matrices examples
   const b: math.Matrix = math.matrix(math.ones([2, 3]))
   b.size()
 
+  // @ts-expect-error ... ones() in a chain cannot take more dimensions
+  assert.throws(() => math.chain(3).ones(2, 'dense').done(), /Error:.*ones/)
+  // @ts-expect-error ... and neither can zeros()
+  assert.throws(() => math.chain(3).zeros(2, 'sparse').done(), /Error:.*zeros/)
+
   // the Array data of a Matrix can be retrieved using valueOf()
   const _array = a.valueOf()
 
