diff --git a/.changeset/fair-crabs-play.md b/.changeset/fair-crabs-play.md
deleted file mode 100644
index b8755f428b..0000000000
--- a/.changeset/fair-crabs-play.md
+++ /dev/null
@@ -1,5 +0,0 @@
----
-"@biomejs/biome": patch
----
-
-Fixed the LSP method `workspace/didChangeWorkspaceFolders` to perform incremental updates instead of replacing the entire folder list.
diff --git a/.changeset/itchy-aliens-ask.md b/.changeset/itchy-aliens-ask.md
new file mode 100644
index 0000000000..4ff2dbd49f
--- /dev/null
+++ b/.changeset/itchy-aliens-ask.md
@@ -0,0 +1,5 @@
+---
+"@biomejs/biome": patch
+---
+
+Fixed #7843: The CSS parser, when `tailwindDirectives` is enabled, correctly parses `--*: initial;`.
diff --git a/crates/biome_analyze/CONTRIBUTING.md b/crates/biome_analyze/CONTRIBUTING.md
index c8a6a76411..94e9dbe262 100644
--- a/crates/biome_analyze/CONTRIBUTING.md
+++ b/crates/biome_analyze/CONTRIBUTING.md
@@ -26,7 +26,6 @@ The analyzer allows implementors to create **three different** types of rules:
         * [Biome lint rules inspired by other lint rules](#biome-lint-rules-inspired-by-other-lint-rules)
       - [`rule_category!` macro](#rule_category-macro)
       - [Rule severity](#rule-severity)
-      - [Rule group and severity](#rule-group-and-severity)
       - [Rule domains](#rule-domains)
       - [Rule Options](#rule-options)
         * [Options for our example rule](#options-for-our-example-rule)
@@ -517,28 +516,6 @@ declare_lint_rule! {
 }
 ```
 
-#### Rule group and severity
-
-> [!NOTE]
-> This section is relevant to Biome maintainers when they want to move (promote) a rule to a group that is not `nursery`.
-
-We try to maintain consistency in the default severity level and group membership of the rules.
-For legacy reasons, we have some rules that don't follow these constraints.
-
-- `correctness`, `security`, and `a11y` rules **must** have a severity set to `error`.
-
-  If `error` is too strict for a rule, then it should certainly be in another group (for example `suspicious` instead of `correctness`).
-
-- `style` rules **must** have a severity set to `info` or `warn`. If in doubt, choose `info`.
-
-- `complexity` rules **must** have a severity set to `warn` or `info`. If in doubt, choose `info`.
-
-- `suspicious` rules **must** have a severity set to `warn` or `error`. If in doubt, choose `warn`.
-
-- `performance` rules **must** have a severity set to `warn`.
-
-- Actions **must** have a severity set to `info`.
-
 #### Rule domains
 
 Domains are very specific ways to collect rules that belong to the same "concept". Domains are a way for users to opt-in/opt-out rules that belong to the same domain.
@@ -571,7 +548,6 @@ Instead, if the rule is **recommended** but _doesn't have domains_, the rule is
 > [!NOTE]
 > Before adding a new domain, please consult with the maintainers of the project.
 
-
 #### Rule Options
 
 Some rules may allow customization [using per-rule options in `biome.json`](https://biomejs.dev/linter/#rule-options).
diff --git a/crates/biome_cli/src/service/windows.rs b/crates/biome_cli/src/service/windows.rs
index b4e05b003a..44995fe9fa 100644
--- a/crates/biome_cli/src/service/windows.rs
+++ b/crates/biome_cli/src/service/windows.rs
@@ -129,7 +129,7 @@ impl AsyncRead for ClientReadHalf {
                         return Poll::Ready(Ok(()));
                     }
 
-                    Err(err) if err.kind() == io::ErrorKind::WouldBlock => {}
+                    Err(err) if err.kind() == io::ErrorKind::WouldBlock => continue,
                     Err(err) => return Poll::Ready(Err(err)),
                 },
 
@@ -154,7 +154,7 @@ impl AsyncWrite for ClientWriteHalf {
             match self.inner.poll_write_ready(cx) {
                 Poll::Ready(Ok(())) => match self.inner.try_write(buf) {
                     Ok(count) => return Poll::Ready(Ok(count)),
-                    Err(err) if err.kind() == io::ErrorKind::WouldBlock => {}
+                    Err(err) if err.kind() == io::ErrorKind::WouldBlock => continue,
                     Err(err) => return Poll::Ready(Err(err)),
                 },
 
@@ -257,7 +257,7 @@ impl AsyncRead for ServerReadHalf {
                         return Poll::Ready(Ok(()));
                     }
 
-                    Err(err) if err.kind() == io::ErrorKind::WouldBlock => {}
+                    Err(err) if err.kind() == io::ErrorKind::WouldBlock => continue,
                     Err(err) => return Poll::Ready(Err(err)),
                 },
 
@@ -282,7 +282,7 @@ impl AsyncWrite for ServerWriteHalf {
             match self.inner.poll_write_ready(cx) {
                 Poll::Ready(Ok(())) => match self.inner.try_write(buf) {
                     Ok(count) => return Poll::Ready(Ok(count)),
-                    Err(err) if err.kind() == io::ErrorKind::WouldBlock => {}
+                    Err(err) if err.kind() == io::ErrorKind::WouldBlock => continue,
                     Err(err) => return Poll::Ready(Err(err)),
                 },
 
diff --git a/crates/biome_css_factory/src/generated/node_factory.rs b/crates/biome_css_factory/src/generated/node_factory.rs
index 1f94f4f76a..d91fe42c13 100644
--- a/crates/biome_css_factory/src/generated/node_factory.rs
+++ b/crates/biome_css_factory/src/generated/node_factory.rs
@@ -2542,17 +2542,34 @@ pub fn tw_utility_at_rule(
 }
 pub fn tw_value_theme_reference(
     reference: CssDashedIdentifier,
-    minus_token: SyntaxToken,
     star_token: SyntaxToken,
-) -> TwValueThemeReference {
-    TwValueThemeReference::unwrap_cast(SyntaxNode::new_detached(
-        CssSyntaxKind::TW_VALUE_THEME_REFERENCE,
-        [
-            Some(SyntaxElement::Node(reference.into_syntax())),
-            Some(SyntaxElement::Token(minus_token)),
-            Some(SyntaxElement::Token(star_token)),
-        ],
-    ))
+) -> TwValueThemeReferenceBuilder {
+    TwValueThemeReferenceBuilder {
+        reference,
+        star_token,
+        minus_token: None,
+    }
+}
+pub struct TwValueThemeReferenceBuilder {
+    reference: CssDashedIdentifier,
+    star_token: SyntaxToken,
+    minus_token: Option<SyntaxToken>,
+}
+impl TwValueThemeReferenceBuilder {
+    pub fn with_minus_token(mut self, minus_token: SyntaxToken) -> Self {
+        self.minus_token = Some(minus_token);
+        self
+    }
+    pub fn build(self) -> TwValueThemeReference {
+        TwValueThemeReference::unwrap_cast(SyntaxNode::new_detached(
+            CssSyntaxKind::TW_VALUE_THEME_REFERENCE,
+            [
+                Some(SyntaxElement::Node(self.reference.into_syntax())),
+                self.minus_token.map(|token| SyntaxElement::Token(token)),
+                Some(SyntaxElement::Token(self.star_token)),
+            ],
+        ))
+    }
 }
 pub fn tw_variant_at_rule(
     variant_token: SyntaxToken,
diff --git a/crates/biome_css_parser/src/lexer/mod.rs b/crates/biome_css_parser/src/lexer/mod.rs
index b4736dd7a5..dd92fba29f 100644
--- a/crates/biome_css_parser/src/lexer/mod.rs
+++ b/crates/biome_css_parser/src/lexer/mod.rs
@@ -1011,6 +1011,12 @@ impl<'src> CssLexer<'src> {
             && current == b'-'
             && self.peek_byte() == Some(b'*')
         {
+            // HACK: handle `--*`
+            if self.prev_byte() == Some(b'-') {
+                self.advance(1);
+                return Some(current as char);
+            }
+            // otherwise, handle cases like `--color-*`
             return None;
         }
 
@@ -1305,6 +1311,7 @@ impl<'src> CssLexer<'src> {
                             // or the third and fourth code points are a valid escape
                             // return true.
                             BSL => self.is_valid_escape_at(3),
+                            MUL => true,
                             _ => false,
                         }
                     }
diff --git a/crates/biome_css_parser/src/syntax/property/mod.rs b/crates/biome_css_parser/src/syntax/property/mod.rs
index 9bb0de394a..13e9718e0a 100644
--- a/crates/biome_css_parser/src/syntax/property/mod.rs
+++ b/crates/biome_css_parser/src/syntax/property/mod.rs
@@ -6,11 +6,13 @@ use crate::parser::CssParser;
 use crate::syntax::css_modules::{
     composes_not_allowed, expected_classes_list, expected_composes_import_source,
 };
-use crate::syntax::parse_error::{expected_component_value, expected_identifier};
+use crate::syntax::parse_error::{
+    expected_component_value, expected_identifier, tailwind_disabled,
+};
 use crate::syntax::{
-    is_at_any_value, is_at_dashed_identifier, is_at_identifier, is_at_string, parse_any_value,
-    parse_custom_identifier_with_keywords, parse_dashed_identifier, parse_regular_identifier,
-    parse_string,
+    CssSyntaxFeatures, is_at_any_value, is_at_dashed_identifier, is_at_identifier, is_at_string,
+    parse_any_value, parse_custom_identifier_with_keywords, parse_dashed_identifier,
+    parse_regular_identifier, parse_string,
 };
 use biome_css_syntax::CssSyntaxKind::*;
 use biome_css_syntax::{CssSyntaxKind, T};
@@ -18,7 +20,7 @@ use biome_parser::parse_lists::ParseNodeList;
 use biome_parser::parse_recovery::{ParseRecovery, ParseRecoveryTokenSet, RecoveryResult};
 use biome_parser::prelude::ParsedSyntax;
 use biome_parser::prelude::ParsedSyntax::{Absent, Present};
-use biome_parser::{Parser, TokenSet, token_set};
+use biome_parser::{Parser, SyntaxFeature, TokenSet, token_set};
 
 #[inline]
 pub(crate) fn is_at_any_property(p: &mut CssParser) -> bool {
@@ -160,7 +162,11 @@ const END_OF_COMPOSES_CLASS_TOKEN_SET: TokenSet<CssSyntaxKind> =
 #[inline]
 fn is_at_generic_property(p: &mut CssParser) -> bool {
     is_at_identifier(p)
-        && (p.nth_at(1, T![:]) || (p.nth_at(1, T![-]) && p.nth_at(2, T![*]) && p.nth_at(3, T![:])))
+        && (p.nth_at(1, T![:])
+        // handle --*:
+        || (p.nth_at(1, T![*]) && p.nth_at(2, T![:]))
+        // handle --color-*:
+        || (p.nth_at(1, T![-]) && p.nth_at(2, T![*]) && p.nth_at(3, T![:])))
 }
 
 #[inline]
@@ -174,13 +180,22 @@ fn parse_generic_property(p: &mut CssParser) -> ParsedSyntax {
     if is_at_dashed_identifier(p) {
         let ident = parse_dashed_identifier(p).ok();
         if let Some(ident) = ident
-            && p.options().is_tailwind_directives_enabled()
-            && p.at(T![-])
+            && p.at_ts(token_set![T![-], T![*]])
         {
-            let m = ident.precede(p);
-            p.expect(T![-]);
-            p.expect(T![*]);
-            m.complete(p, TW_VALUE_THEME_REFERENCE);
+            CssSyntaxFeatures::Tailwind
+                .parse_exclusive_syntax(
+                    p,
+                    |p| {
+                        let m = ident.precede(p);
+                        if p.at(T![-]) {
+                            p.expect(T![-]);
+                        }
+                        p.expect(T![*]);
+                        Present(m.complete(p, TW_VALUE_THEME_REFERENCE))
+                    },
+                    |p, m| tailwind_disabled(p, m.range(p)),
+                )
+                .ok();
         }
     } else {
         parse_regular_identifier(p).ok();
diff --git a/crates/biome_css_syntax/src/generated/nodes.rs b/crates/biome_css_syntax/src/generated/nodes.rs
index e385627f85..95c0b40414 100644
--- a/crates/biome_css_syntax/src/generated/nodes.rs
+++ b/crates/biome_css_syntax/src/generated/nodes.rs
@@ -7361,8 +7361,8 @@ impl TwValueThemeReference {
     pub fn reference(&self) -> SyntaxResult<CssDashedIdentifier> {
         support::required_node(&self.syntax, 0usize)
     }
-    pub fn minus_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 1usize)
+    pub fn minus_token(&self) -> Option<SyntaxToken> {
+        support::token(&self.syntax, 1usize)
     }
     pub fn star_token(&self) -> SyntaxResult<SyntaxToken> {
         support::required_token(&self.syntax, 2usize)
@@ -7379,7 +7379,7 @@ impl Serialize for TwValueThemeReference {
 #[derive(Serialize)]
 pub struct TwValueThemeReferenceFields {
     pub reference: SyntaxResult<CssDashedIdentifier>,
-    pub minus_token: SyntaxResult<SyntaxToken>,
+    pub minus_token: Option<SyntaxToken>,
     pub star_token: SyntaxResult<SyntaxToken>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
@@ -18619,7 +18619,7 @@ impl std::fmt::Debug for TwValueThemeReference {
                 .field("reference", &support::DebugSyntaxResult(self.reference()))
                 .field(
                     "minus_token",
-                    &support::DebugSyntaxResult(self.minus_token()),
+                    &support::DebugOptionalElement(self.minus_token()),
                 )
                 .field("star_token", &support::DebugSyntaxResult(self.star_token()))
                 .finish()
diff --git a/crates/biome_css_syntax/src/generated/nodes_mut.rs b/crates/biome_css_syntax/src/generated/nodes_mut.rs
index 3d07d71d7d..5a9fa00070 100644
--- a/crates/biome_css_syntax/src/generated/nodes_mut.rs
+++ b/crates/biome_css_syntax/src/generated/nodes_mut.rs
@@ -2992,10 +2992,10 @@ impl TwValueThemeReference {
                 .splice_slots(0usize..=0usize, once(Some(element.into_syntax().into()))),
         )
     }
-    pub fn with_minus_token(self, element: SyntaxToken) -> Self {
+    pub fn with_minus_token(self, element: Option<SyntaxToken>) -> Self {
         Self::unwrap_cast(
             self.syntax
-                .splice_slots(1usize..=1usize, once(Some(element.into()))),
+                .splice_slots(1usize..=1usize, once(element.map(|element| element.into()))),
         )
     }
     pub fn with_star_token(self, element: SyntaxToken) -> Self {
diff --git a/crates/biome_lsp/src/server.rs b/crates/biome_lsp/src/server.rs
index fdeb913ea4..746691ef1c 100644
--- a/crates/biome_lsp/src/server.rs
+++ b/crates/biome_lsp/src/server.rs
@@ -408,8 +408,7 @@ impl LanguageServer for LSPServer {
             }
         }
 
-        self.session
-            .update_workspace_folders(params.event.added, params.event.removed);
+        self.session.update_workspace_folders(params.event.added);
         self.session.load_workspace_settings(true).await;
     }
 
diff --git a/crates/biome_lsp/src/session.rs b/crates/biome_lsp/src/session.rs
index 2cbc8b98d0..89d79af5b1 100644
--- a/crates/biome_lsp/src/session.rs
+++ b/crates/biome_lsp/src/session.rs
@@ -587,24 +587,9 @@ impl Session {
         self.workspace_folders.read().unwrap().clone()
     }
 
-    pub(crate) fn update_workspace_folders(
-        &self,
-        added: Vec<WorkspaceFolder>,
-        removed: Vec<WorkspaceFolder>,
-    ) {
+    pub(crate) fn update_workspace_folders(&self, folders: Vec<WorkspaceFolder>) {
         let mut workspace_folders = self.workspace_folders.write().unwrap();
-
-        if let Some(ref mut folders) = *workspace_folders {
-            if !removed.is_empty() {
-                folders.retain(|folder| !removed.contains(folder));
-            }
-
-            if !added.is_empty() {
-                folders.extend(added);
-            }
-        } else {
-            *workspace_folders = Some(added);
-        }
+        *workspace_folders = Some(folders);
     }
 
     /// Returns the base path of the workspace on the filesystem if it has one
diff --git a/crates/biome_parser/src/lexer.rs b/crates/biome_parser/src/lexer.rs
index 01c2c31513..af08fdbe47 100644
--- a/crates/biome_parser/src/lexer.rs
+++ b/crates/biome_parser/src/lexer.rs
@@ -209,6 +209,15 @@ pub trait Lexer<'src> {
             .copied()
     }
 
+    #[inline]
+    fn prev_byte(&self) -> Option<u8> {
+        if self.position() == 0 {
+            None
+        } else {
+            self.source().as_bytes().get(self.position() - 1).copied()
+        }
+    }
+
     #[inline]
     fn text_position(&self) -> TextSize {
         TextSize::try_from(self.position()).expect("Input to be smaller than 4 GB")
diff --git a/xtask/codegen/css.ungram b/xtask/codegen/css.ungram
index 7509c76a82..9796fac751 100644
--- a/xtask/codegen/css.ungram
+++ b/xtask/codegen/css.ungram
@@ -1873,9 +1873,14 @@ CssMetavariable = value: 'grit_metavariable'
 // Tailwind
 
 // --value(--tab-size-*)
+//         ^^^^^^^^^^^^
+// --color-*: initial;
+// ^^^^^^^^^
+// --*: initial;
+// ^^^
 TwValueThemeReference =
 	reference: CssDashedIdentifier
-	'-'
+	'-'?
 	'*'
 
 // Enhanced @utility directive to support functional utilities
diff --git a/xtask/rules_check/src/lib.rs b/xtask/rules_check/src/lib.rs
index e702739fcc..03077a85cc 100644
--- a/xtask/rules_check/src/lib.rs
+++ b/xtask/rules_check/src/lib.rs
@@ -31,22 +31,30 @@ use biome_service::workspace::DocumentFileSource;
 use pulldown_cmark::{CodeBlockKind, Event, HeadingLevel, Parser, Tag, TagEnd};
 
 #[derive(Debug)]
-struct Errors {
-    message: String,
-}
+struct Errors(String);
+
 impl Errors {
-    const fn new(message: String) -> Self {
-        Self { message }
+    fn style_rule_error(rule_name: impl Display) -> Self {
+        Self(format!(
+            "The rule '{rule_name}' that belongs to the group 'style' can't have Severity::Error. Lower down the severity or change the group.",
+        ))
+    }
+
+    fn action_error(rule_name: impl Display) -> Self {
+        Self(format!(
+            "The rule '{rule_name}' is an action, and it must have Severity::Information. Lower down the severity.",
+        ))
     }
 }
-impl std::error::Error for Errors {}
+
 impl Display for Errors {
     fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
-        let Self { message } = self;
-        f.write_str(message)
+        f.write_str(self.0.as_str())
     }
 }
 
+impl std::error::Error for Errors {}
+
 type Data = BTreeMap<&'static str, (RuleMetadata, RuleCategory)>;
 pub fn check_rules() -> anyhow::Result<()> {
     #[derive(Default)]
@@ -64,75 +72,12 @@ pub fn check_rules() -> anyhow::Result<()> {
             if !matches!(category, RuleCategory::Lint | RuleCategory::Action) {
                 return;
             }
-            let group = R::Group::NAME;
-            let rule_name = R::METADATA.name;
-            let rule_severity = R::METADATA.severity;
-            if matches!(group, "a11y" | "correctness" | "security")
-                && rule_severity != Severity::Error
-                && !matches!(
-                    rule_name,
-                    // TODO: remove these exceptions in Biome 3.0
-                    "noNodejsModules"
-                        | "noPrivateImports"
-                        | "noUnusedFunctionParameters"
-                        | "noUnusedImports"
-                        | "noUnusedLabels"
-                        | "noUnusedPrivateClassMembers"
-                        | "noUnusedVariables"
-                        | "useImportExtensions"
-                        | "noNoninteractiveElementInteractions"
-                        | "noGlobalDirnameFilename"
-                        | "noProcessGlobal"
-                        | "noReactPropAssignments"
-                        | "noRestrictedElements"
-                        | "noSecrets"
-                        | "noSolidDestructuredProps"
-                        | "useJsonImportAttributes"
-                        | "useParseIntRadix"
-                        | "useSingleJsDocAsterisk"
-                )
-            {
-                self.errors.push(Errors::new(format!(
-                    "The rule '{rule_name}' belongs to the group '{group}' and has a severity set to '{rule_severity}'. Rules that belong to the group {group} must have a severity set to 'error'. Set the severity to 'error' or change the group of the rule."
-                )));
-            } else if matches!(group, "complexity" | "style") && rule_severity == Severity::Error {
-                self.errors.push(Errors::new(format!(
-                    "The rule '{rule_name}' belongs to the group '{group}' and has a severity set to '{rule_severity}'. Rules that belong to the group '{group}' must not have a severity set to 'error'. Lower down the severity or change the group of the rule."
-                )));
-            } else if group == "performance"
-                && rule_severity != Severity::Warning
-                && !matches!(
-                    rule_name,
-                    // TODO: remove these exceptions in Biome 3.0
-                    "noAwaitInLoops" | "useGoogleFontPreconnect" | "useSolidForComponent"
-                )
-            {
-                self.errors.push(Errors::new(format!(
-                    "The rule '{rule_name}' belongs to the group '{group}' and has a severity set to '{rule_severity}'. Rules that belong to the group '{group}' must have a severity set to 'warn'. Set the severity to 'warn' or change the group of the rule."
-                )));
-            } else if group == "suspicious"
-                && rule_severity == Severity::Information
-                && !matches!(
-                    rule_name,
-                    // TODO: remove these exceptions in Biome 3.0
-                    "noAlert"
-                        | "noBitwiseOperators"
-                        | "noConstantBinaryExpressions"
-                        | "noUnassignedVariables"
-                        | "useStaticResponseMethods"
-                        | "noQuickfixBiome"
-                        | "noDuplicateFields"
-                )
-            {
-                self.errors.push(Errors::new(format!(
-                    "The rule '{rule_name}' belongs to the group '{group}' and has a severity set to '{rule_severity}'. Rules that belong to the group '{group}' must have a severity set to 'warn' or 'error'. Change the severity or change the group of the rule."
-                )));
+            if R::Group::NAME == "style" && R::METADATA.severity == Severity::Error {
+                self.errors.push(Errors::style_rule_error(R::METADATA.name))
             } else if <R::Group as RuleGroup>::Category::CATEGORY == RuleCategory::Action
-                && rule_severity != Severity::Information
+                && R::METADATA.severity != Severity::Information
             {
-                self.errors.push(Errors::new(format!(
-                    "The action '{rule_name}' has a severity set to '{rule_severity}'. Actions must have a severity set to 'info'. Set the severity of the rule to 'info'."
-                )));
+                self.errors.push(Errors::action_error(R::METADATA.name));
             } else {
                 self.groups
                     .entry((<R::Group as RuleGroup>::NAME, R::METADATA.language))
