diff --git a/docs/rtk-query/comparison.md b/docs/rtk-query/comparison.md
index 7a1a95e4..96e7a508 100644
--- a/docs/rtk-query/comparison.md
+++ b/docs/rtk-query/comparison.md
@@ -33,7 +33,7 @@ RTK Query has some unique API design aspects and capabilities that are worth con
 - You can easily invalidate entities or patch existing query data (via `util.updateQueryData`) from middleware.
 - RTK Query enables [streaming cache updates](./usage/streaming-updates.mdx), such as updating the initial fetched data as messages are received over a websocket, and has built in support for [optimistic updates](./usage/manual-cache-updates.mdx#optimistic-updates) as well.
 - RTK Query ships a very tiny and flexible fetch wrapper: [`fetchBaseQuery`](./api/fetchBaseQuery.mdx). It's also very easy to [swap our client with your own](./usage/customizing-queries.mdx), such as using `axios`, `redaxios`, or something custom.
-- RTK Query has [a (currently experimental) code-gen tool](https://github.com/reduxjs/redux-toolkit/tree/master/packages/rtk-query-codegen-openapi) that will take an OpenAPI spec or GraphQL schema and give you a typed API client, as well as provide methods for enhancing the generated client after the fact.
+- RTK Query has [a (currently experimental) code-gen tool](https://github.com/rtk-incubator/rtk-query-codegen) that will take an OpenAPI spec or GraphQL schema and give you a typed API client, as well as provide methods for enhancing the generated client after the fact.
 
 ## Tradeoffs
 
diff --git a/docs/rtk-query/usage/code-generation.mdx b/docs/rtk-query/usage/code-generation.mdx
index 355e78e5..ddbe0167 100644
--- a/docs/rtk-query/usage/code-generation.mdx
+++ b/docs/rtk-query/usage/code-generation.mdx
@@ -49,7 +49,7 @@ import { ConfigFile } from '@rtk-query/codegen-openapi'
 const config: ConfigFile = {
   schemaFile: 'https://petstore3.swagger.io/api/v3/openapi.json',
   apiFile: './src/store/emptyApi.ts',
-  apiImport: 'emptySplitApi',
+  apiImport: 'emptyApi',
   outputFile: './src/store/petApi.ts',
   exportName: 'petApi',
   hooks: true,
@@ -141,13 +141,13 @@ const config: ConfigFile = {
   schemaFile: 'https://petstore3.swagger.io/api/v3/openapi.json',
   apiFile: './src/store/emptyApi.ts',
   outputFiles: {
-    './src/store/user.ts': {
+    './src/store/user.js': {
       filterEndpoints: [/user/i],
     },
-    './src/store/order.ts': {
+    './src/store/order.js': {
       filterEndpoints: [/order/i],
     },
-    './src/store/pet.ts': {
+    './src/store/pet.js': {
       filterEndpoints: [/pet/i],
     },
   },
diff --git a/packages/action-listener-middleware/src/index.ts b/packages/action-listener-middleware/src/index.ts
index abbb5637..7c26d48d 100644
--- a/packages/action-listener-middleware/src/index.ts
+++ b/packages/action-listener-middleware/src/index.ts
@@ -30,6 +30,15 @@ import type {
   ListenerErrorInfo,
 } from './types'
 
+import {
+  Job,
+  SupervisorJob,
+  JobHandle,
+  JobCancellationReason,
+  JobCancellationException,
+} from './job'
+import { Outcome } from './outcome'
+
 export type {
   ActionListener,
   ActionListenerMiddleware,
@@ -57,43 +66,76 @@ const defaultWhen: MiddlewarePhase = 'afterReducer'
 const actualMiddlewarePhases = ['beforeReducer', 'afterReducer'] as const
 
 function createTakePattern<S>(
-  addListener: AddListenerOverloads<Unsubscribe, S, Dispatch<AnyAction>>
+  addListener: AddListenerOverloads<Unsubscribe, S, Dispatch<AnyAction>>,
+  parentJob: Job<any>
 ): TakePattern<S> {
+  /**
+   * A function that takes an ActionListenerPredicate and an optional timeout,
+   * and resolves when either the predicate returns `true` based on an action
+   * state combination or when the timeout expires.
+   * If the parent listener is canceled while waiting, this will throw a
+   * JobCancellationException.
+   */
   async function take<P extends AnyActionListenerPredicate<S>>(
     predicate: P,
     timeout: number | undefined
   ) {
+    // Placeholder unsubscribe function until the listener is added
     let unsubscribe: Unsubscribe = () => {}
 
-    const tuplePromise = new Promise<[AnyAction, S, S]>((resolve) => {
-      unsubscribe = addListener({
-        predicate: predicate as any,
-        listener: (action, listenerApi): void => {
-          // One-shot listener that cleans up as soon as the predicate resolves
-          listenerApi.unsubscribe()
-          resolve([
-            action,
-            listenerApi.getState(),
-            listenerApi.getOriginalState(),
-          ])
-        },
-      })
-    })
-
-    if (timeout === undefined) {
-      return tuplePromise
-    }
+    // We'll add an additional nested Job representing this function.
+    // TODO This is really a duplicate of the other job inside the middleware.
+    // This behavior requires some additional nesting:
+    // We're going to create a `Promise` representing the result of the listener,
+    // but then wrap that in an `Outcome` for consistent error handling.
+    let job: Job<[AnyAction, S, S]> = parentJob.launch(async (job) =>
+      Outcome.wrap(
+        new Promise<[AnyAction, S, S]>((resolve) => {
+          // Inside the Promise, we synchronously add the listener.
+          unsubscribe = addListener({
+            predicate: predicate as any,
+            listener: (action, listenerApi): void => {
+              // One-shot listener that cleans up as soon as the predicate passes
+              listenerApi.unsubscribe()
+              // Resolve the promise with the same arguments the predicate saw
+              resolve([
+                action,
+                listenerApi.getState(),
+                listenerApi.getOriginalState(),
+              ])
+            },
+            parentJob,
+          })
+        })
+      )
+    )
 
-    const timedOutPromise = new Promise<null>((resolve, reject) => {
-      setTimeout(() => {
-        resolve(null)
-      }, timeout)
-    })
+    let result: Outcome<[AnyAction, S, S]>
 
-    const result = await Promise.race([tuplePromise, timedOutPromise])
+    try {
+      // Run the job and use the timeout if given
+      result = await (timeout !== undefined
+        ? job.runWithTimeout(timeout)
+        : job.run())
 
-    unsubscribe()
-    return result
+      if (result.isOk()) {
+        // Resolve the actual `take` promise with the action+states
+        return result.value
+      } else {
+        if (
+          result.error instanceof JobCancellationException &&
+          result.error.reason === JobCancellationReason.JobCancelled
+        ) {
+          // The `take` job itself was canceled due to timeout.
+          return null
+        }
+        // The parent was canceled - reject this promise with that error
+        throw result.error
+      }
+    } finally {
+      // Always clean up the listener
+      unsubscribe()
+    }
   }
 
   return take as TakePattern<S>
@@ -114,8 +156,12 @@ export const createListenerEntry: TypedCreateListenerEntry<unknown> = (
     predicate = options.actionCreator.match
   } else if ('matcher' in options) {
     predicate = options.matcher
-  } else {
+  } else if ('predicate' in options) {
     predicate = options.predicate
+  } else {
+    throw new Error(
+      'Creating a listener requires one of the known fields for matching against actions'
+    )
   }
 
   const id = nanoid()
@@ -128,6 +174,7 @@ export const createListenerEntry: TypedCreateListenerEntry<unknown> = (
     unsubscribe: () => {
       throw new Error('Unsubscribe not initialized')
     },
+    parentJob: new SupervisorJob(),
   }
 
   return entry
@@ -287,11 +334,6 @@ export function createActionListenerMiddleware<
     return true
   }
 
-  const take = createTakePattern(addListener)
-  const condition: ConditionFunction<S> = (predicate, timeout) => {
-    return take(predicate, timeout).then(Boolean)
-  }
-
   const middleware: Middleware<
     {
       (action: Action<'actionListenerMiddleware/add'>): Unsubscribe
@@ -338,7 +380,6 @@ export function createActionListenerMiddleware<
             runListener = false
 
             safelyNotifyError(onError, predicateError, {
-              async: false,
               raisedBy: 'predicate',
               phase: currentPhase,
             })
@@ -349,38 +390,47 @@ export function createActionListenerMiddleware<
           continue
         }
 
-        try {
-          let promiseLikeOrUndefined = entry.listener(action, {
-            ...api,
-            getOriginalState,
-            condition,
-            take,
-            currentPhase,
-            extra,
-            unsubscribe: entry.unsubscribe,
-            subscribe: () => {
-              listenerMap.set(entry.id, entry)
-            },
-          })
+        entry.parentJob.launchAndRun(async (jobHandle) => {
+          const take = createTakePattern(addListener, jobHandle as Job<any>)
+          const condition: ConditionFunction<S> = (predicate, timeout) => {
+            return take(predicate, timeout).then(Boolean)
+          }
 
-          if (promiseLikeOrUndefined) {
-            Promise.resolve(promiseLikeOrUndefined).catch(
-              (asyncListenerError) => {
-                safelyNotifyError(onError, asyncListenerError, {
-                  async: true,
-                  raisedBy: 'listener',
-                  phase: currentPhase,
-                })
-              }
-            )
+          const result = await Outcome.try(async () =>
+            entry.listener(action, {
+              ...api,
+              getOriginalState,
+              condition,
+              take,
+              currentPhase,
+              extra,
+              unsubscribe: entry.unsubscribe,
+              subscribe: () => {
+                listenerMap.set(entry.id, entry)
+              },
+              job: jobHandle,
+              cancelPrevious: () => {
+                entry.parentJob.cancelChildren(
+                  new JobCancellationException(
+                    JobCancellationReason.JobCancelled
+                  ),
+                  [jobHandle]
+                )
+              },
+            })
+          )
+          if (
+            result.isError() &&
+            !(result.error instanceof JobCancellationException)
+          ) {
+            safelyNotifyError(onError, result.error, {
+              raisedBy: 'listener',
+              phase: currentPhase,
+            })
           }
-        } catch (syncListenerError) {
-          safelyNotifyError(onError, syncListenerError, {
-            async: false,
-            raisedBy: 'listener',
-            phase: currentPhase,
-          })
-        }
+
+          return Outcome.ok(1)
+        })
       }
       if (currentPhase === 'beforeReducer') {
         result = next(action)
diff --git a/packages/action-listener-middleware/src/job.ts b/packages/action-listener-middleware/src/job.ts
new file mode 100644
index 00000000..e182b2f2
--- /dev/null
+++ b/packages/action-listener-middleware/src/job.ts
@@ -0,0 +1,324 @@
+// Source: https://github.com/ethossoftworks/job-ts
+
+import { Outcome } from './outcome'
+import type { Error as OutcomeError } from './outcome'
+
+/**
+ * The block of work a [Job] executes. The [job] parameter is a handle of the job's instance to allow
+ * launching of new jobs or pausing the job.
+ */
+export type JobFunc<T> = (job: JobHandle) => Promise<Outcome<T>>
+
+/**
+ * A handle for the current job used in [JobFunc]. This interface is equivalent to [Job]'s interface with the exception
+ * of [run] and [runWithTimeout] to prevent recursive running of the [Job] inside its [JobFunc].
+ */
+export interface JobHandle {
+  isActive: boolean
+  isCompleted: boolean
+  isCancelled: boolean
+  childCount: number
+  ensureActive(): void
+  launch<R>(func: JobFunc<R>): Job<R>
+  launchAndRun<R>(func: JobFunc<R>): Promise<Outcome<R>>
+  pause<R>(func: Promise<R>): Promise<R>
+  delay(milliseconds: number): Promise<void>
+  cancel(reason?: JobCancellationException): void
+  cancelChildren(
+    reason?: JobCancellationException,
+    skipChildren?: JobHandle[]
+  ): void
+}
+
+/**
+ * Thrown when a job or its parent is cancelled or if a job is run more than once.
+ */
+export class JobCancellationException implements Error {
+  reason: JobCancellationReason
+  name: string
+  message: string
+  constructor(reason: JobCancellationReason) {
+    this.name = 'JobCancellationException'
+    this.reason = reason
+    this.message = `${this.reason}`
+  }
+}
+
+/**
+ * The reason a job was cancelled.
+ *
+ * [ParentJobCancelled]: The parent job was cancelled
+ * [ParentJobCompleted]: The parent job completed
+ * [JobCancelled]: The current job was cancelled
+ * [JobCompleted]: The current job was already completed. This only happens if the same job is run more than once.
+ */
+export enum JobCancellationReason {
+  ParentJobCancelled = 'ParentJobCancelled',
+  ParentJobCompleted = 'ParentJobCompleted',
+  JobCancelled = 'JobCancelled',
+  JobCompleted = 'JobCompleted',
+}
+
+/**
+ * A cancellable unit of work with optional cancellation hierarchy.
+ *
+ * Cancellation is cooperative, meaning the user has to define pause/suspension points in the task via the [pause] or
+ * [ensureActive] methods or by checking [isActive].
+ *
+ * Cancelling a parent Job will cancel all children Jobs launched with the job defined as its parent. All children must
+ * also cooperatively check for cancellation.
+ *
+ * A parent job will not wait for any children jobs unless explicitly awaited on in the provided [JobFunc]. In this
+ * instance, if the parent completes before its child has completed, the parent will be marked as completed and the
+ * children will be cancelled at the next pause point.
+ *
+ * If an exception is thrown during a JobFunc, the job will cancel itself and its children and then rethrow the
+ * exception to be handled by the user.
+ *
+ * Running a job more than once will result in a [JobCancellationException].
+ *
+ * Note: When adding a try/catch mechanism inside of a [JobFunc], make sure to rethrow any [JobCancellationException]
+ * exceptions, otherwise job cancellation will not work as intended.
+ *
+ * Example:
+ * ```
+ const job = Job(async (job) => {
+ *     // This creates a pause point. If the job is cancelled while this operation is running,
+ *     // the job will immediately return [Error] with a [JobCancellationException] as its result.
+ *     const result = await job.pause(someLongRunningTask());
+ *
+ *     if (result.error != null) {
+ *         return Outcome.error("Problem");
+ *     }
+ *     return Outcome.ok("All good!");
+ * });
+ *
+ * const jobResult = await job.run();
+ * ```
+ */
+export class Job<T> implements JobHandle {
+  private _parent: Job<any> | undefined
+  private _children: Job<any>[] = []
+  private _func: JobFunc<T>
+  private _cancelResolver: (value: Outcome<T>) => void = () => {}
+  private _isCancelled = false
+  private _isCompleted = false
+
+  private _cancelPromise: Promise<Outcome<T>> = new Promise<Outcome<T>>(
+    (resolve) => (this._cancelResolver = resolve)
+  )
+
+  constructor(func: JobFunc<T>, options?: { parent?: Job<any> }) {
+    this._func = func
+    this._parent = options?.parent
+    this._parent?._addChild(this)
+  }
+
+  /**
+   * Returns true if the given outcome was cancelled
+   */
+  static isCancelled = (
+    outcome: Outcome<unknown>
+  ): outcome is OutcomeError<JobCancellationException> =>
+    outcome.isError() && outcome.error instanceof JobCancellationException
+
+  /**
+   * Returns true if both the parent job (if one exists) and the current job are both active. A job is active at
+   * creation and remains active until it has completed or been cancelled.
+   */
+  get isActive(): boolean {
+    return (
+      !this._isCompleted &&
+      !this._isCancelled &&
+      (this._parent?.isActive ?? true)
+    )
+  }
+
+  /**
+   * Returns true if the job was completed successfully
+   */
+  get isCompleted(): boolean {
+    return !this.isActive && !this.isCancelled
+  }
+
+  /**
+   * Returns true if the job was cancelled for any reason, either by explicit invocation of cancel or because its
+   * parent was cancelled. This does not imply that the job has fully completed because it may still be finishing
+   * whatever it was doing and waiting for its children to complete.
+   */
+  get isCancelled(): boolean {
+    return this._isCancelled || !(this._parent?.isCancelled ?? true)
+  }
+
+  /**
+   * Checks if the parent job and current job are active and throws [JobCancellationException] if either are inactive.
+   *
+   * Note: This should only be used inside of a [JobFunc].
+   */
+  ensureActive() {
+    if (this._isCompleted)
+      throw new JobCancellationException(JobCancellationReason.JobCompleted)
+    if (this._isCancelled)
+      throw new JobCancellationException(JobCancellationReason.JobCancelled)
+
+    // Check parent
+    if (this._parent === undefined) return
+    if (!this._parent.isActive) {
+      if (this._parent.isCompleted)
+        throw new JobCancellationException(
+          JobCancellationReason.ParentJobCompleted
+        )
+      throw new JobCancellationException(
+        JobCancellationReason.ParentJobCancelled
+      )
+    }
+  }
+
+  /**
+   * The current number of active children jobs.
+   */
+  get childCount(): number {
+    return this._children.length
+  }
+
+  /**
+   * Creates and returns a new job with the current job as the parent.
+   */
+  launch<R>(func: JobFunc<R>): Job<R> {
+    return new Job(func, { parent: this })
+  }
+
+  /**
+   * Creates a new job with the current job as the parent and executes it returning its result.
+   *
+   * Note: This should only be used inside of a [JobFunc].
+   */
+  launchAndRun<R>(func: JobFunc<R>): Promise<Outcome<R>> {
+    return this.launch(func).run()
+  }
+
+  /**
+   * Execute the job and return its result.
+   *
+   * [run] handles all [JobCancellationException] and will return an [Error] if a cancellation occurs.
+   */
+  async run(): Promise<Outcome<T>> {
+    try {
+      this.ensureActive()
+      const result = this._validateResult(
+        await Promise.race([this._func(this), this._cancelPromise])
+      )
+      this.ensureActive()
+      this._isCompleted = true
+      return result
+    } catch (e) {
+      if (e instanceof JobCancellationException) {
+        return Outcome.error(e)
+      } else {
+        this.cancel(
+          new JobCancellationException(JobCancellationReason.JobCancelled)
+        )
+        throw e
+      }
+    } finally {
+      this._parent?._removeChild(this)
+    }
+  }
+
+  /**
+   * Executes the job and cancels the job if it takes longer than the timeout to complete/cancel.
+   */
+  async runWithTimeout(milliseconds: number): Promise<Outcome<T>> {
+    setTimeout(() => this.cancel(), milliseconds)
+    return this.run()
+  }
+
+  private _validateResult(result: Outcome<T>): Outcome<T> {
+    if (result.isError() && result.error instanceof JobCancellationException)
+      throw result.error
+    return result
+  }
+
+  /**
+   * Await a given [func] and ensures the job is active before and after [func] execution. This effectively
+   * creates a pause/suspend point for the job and prevents returning a result or performing an action on a result
+   * if the job has been completed/cancelled.
+   *
+   * Note: This should only be used inside of a [JobFunc].
+   */
+  async pause<R>(func: Promise<R>): Promise<R> {
+    this.ensureActive()
+    const result = await func
+    this.ensureActive()
+    return result
+  }
+
+  /**
+   * Delays a job for the specified amount of time and checks for cancellation before and after the delay.
+   */
+  async delay(milliseconds: number): Promise<void> {
+    return await this.pause(
+      new Promise((resolve) => setTimeout(resolve, milliseconds))
+    )
+  }
+
+  /**
+   * Cancels the current job and all children jobs.
+   */
+  cancel(reason?: JobCancellationException) {
+    this._parent?._removeChild(this)
+    this.cancelChildren(
+      new JobCancellationException(JobCancellationReason.ParentJobCancelled)
+    )
+
+    if (this._isCancelled || this._isCompleted) return
+    this._isCancelled = true
+    this._cancelResolver(
+      Outcome.error(
+        reason ??
+          new JobCancellationException(JobCancellationReason.JobCancelled)
+      )
+    )
+  }
+
+  /**
+   * Cancels all children jobs without cancelling the current job.
+   */
+  cancelChildren(
+    reason?: JobCancellationException,
+    skipChildren: JobHandle[] = []
+  ) {
+    const childrenCopy = [...this._children]
+    const skipSet = new Set(skipChildren)
+    const remainingChildren: typeof this._children = []
+    childrenCopy.forEach((job) => {
+      if (skipSet.has(job)) {
+        remainingChildren.push(job)
+      } else {
+        job.cancel(
+          reason ??
+            new JobCancellationException(JobCancellationReason.JobCancelled)
+        )
+      }
+    })
+    this._children = remainingChildren
+  }
+
+  private _addChild(child: Job<any>) {
+    if (this.isActive) this._children.push(child)
+  }
+
+  private _removeChild(child: Job<any>) {
+    this._children.splice(this._children.indexOf(child), 1)
+  }
+}
+
+/**
+ * A helper extension of [Job] that never completes until it is cancelled. This effectively provides a long-running
+ * context to launch children jobs in.
+ */
+export class SupervisorJob extends Job<void> {
+  constructor(parent?: Job<any>) {
+    super(() => new Promise<Outcome<void>>(() => {}), { parent: parent })
+  }
+}
diff --git a/packages/action-listener-middleware/src/outcome.ts b/packages/action-listener-middleware/src/outcome.ts
new file mode 100644
index 00000000..d2e017a0
--- /dev/null
+++ b/packages/action-listener-middleware/src/outcome.ts
@@ -0,0 +1,58 @@
+// Source: https://github.com/ethossoftworks/outcome-ts
+
+const outcomeSymbol = Symbol()
+
+export class Ok<T> {
+  private outcomeSymbol = outcomeSymbol
+
+  constructor(public value: T) {}
+
+  isError(): this is Error<T> {
+    return false
+  }
+
+  isOk(): this is Ok<T> {
+    return true
+  }
+}
+
+export class Error<E = unknown> {
+  private outcomeSymbol = outcomeSymbol
+
+  constructor(public error: E) {}
+
+  isError(): this is Error {
+    return true
+  }
+
+  isOk(): this is Ok<any> {
+    return false
+  }
+}
+
+export const Outcome = {
+  ok: <T>(value: T) => new Ok(value),
+  error: <E>(error: E) => new Error(error),
+
+  wrap: async <T>(promise: Promise<T>): Promise<Outcome<T>> => {
+    try {
+      return new Ok(await promise)
+    } catch (e) {
+      return new Error(e)
+    }
+  },
+
+  try: async <T>(block: () => Promise<T>): Promise<Outcome<T>> => {
+    try {
+      return new Ok(await block())
+    } catch (e) {
+      return new Error(e)
+    }
+  },
+
+  isOutcome: (other: any): other is Outcome<any> => {
+    return other !== undefined && other.outcomeSymbol === outcomeSymbol
+  },
+}
+
+export type Outcome<T, E = unknown> = Ok<T> | Error<E>
diff --git a/packages/action-listener-middleware/src/types.ts b/packages/action-listener-middleware/src/types.ts
index ccb42183..dfe62c20 100644
--- a/packages/action-listener-middleware/src/types.ts
+++ b/packages/action-listener-middleware/src/types.ts
@@ -8,6 +8,8 @@ import type {
   ThunkDispatch,
 } from '@reduxjs/toolkit'
 
+import type { JobHandle, Job } from './job'
+
 /**
  * Types copied from RTK
  */
@@ -71,6 +73,8 @@ export interface ActionListenerMiddlewareAPI<S, D extends Dispatch<AnyAction>>
   subscribe(): void
   condition: ConditionFunction<S>
   take: TakePattern<S>
+  cancelPrevious: () => void
+  job: JobHandle
   currentPhase: MiddlewarePhase
   // TODO Figure out how to pass this through the other types correctly
   extra: unknown
@@ -96,6 +100,7 @@ export interface ActionListenerOptions {
    * Defaults to 'before'.
    */
   when?: When
+  parentJob?: JobHandle
 }
 
 export interface CreateListenerMiddlewareOptions<ExtraArgument = unknown> {
@@ -282,6 +287,7 @@ export type ListenerEntry<
   unsubscribe: () => void
   type?: string
   predicate: ListenerPredicate<AnyAction, S>
+  parentJob: JobHandle
 }
 
 const declaredMiddlewareType: unique symbol = undefined as any
@@ -322,7 +328,6 @@ export type ListenerPredicateGuardedActionType<T> = T extends ListenerPredicate<
  * Additional infos regarding the error raised.
  */
 export interface ListenerErrorInfo {
-  async: boolean
   /**
    * Which function has generated the exception.
    */
