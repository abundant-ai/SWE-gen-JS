diff --git a/index.d.ts b/index.d.ts
index 4e267f5..c1cec9b 100644
--- a/index.d.ts
+++ b/index.d.ts
@@ -20,10 +20,6 @@ export type StdinOption =
 	| string
 	| ReadableStream;
 
-export type StdoutStderrOption =
-	| StdioOption
-	| WritableStream;
-
 type EncodingOption =
   | 'utf8'
   // eslint-disable-next-line unicorn/text-encoding-identifier-case
@@ -98,7 +94,7 @@ export type CommonOptions<EncodingType extends EncodingOption = DefaultEncodingO
 	/**
 	Same options as [`stdio`](https://nodejs.org/dist/latest-v6.x/docs/api/child_process.html#child_process_options_stdio).
 
-	It can also be a file path, a file URL, a web stream ([`ReadableStream`](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream)), an [`Iterable`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#the_iterable_protocol) or an [`AsyncIterable`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#the_async_iterator_and_async_iterable_protocols), unless either [`execaSync()`](#execasyncfile-arguments-options), the [`input` option](#input) or the [`inputFile` option](#inputfile) is used. If the file path is relative, it must start with `.`.
+	It can also be a file path, a file URL, a web stream ([`ReadableStream`](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream)) an [`Iterable`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#the_iterable_protocol) or an [`AsyncIterable`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#the_async_iterator_and_async_iterable_protocols), providing neither [`execaSync()`](#execasyncfile-arguments-options), the [`input` option](#input) nor the [`inputFile` option](#inputfile) is used. If the file path is relative, it must start with `.`.
 
 	@default `inherit` with `$`, `pipe` otherwise
 	*/
@@ -107,20 +103,16 @@ export type CommonOptions<EncodingType extends EncodingOption = DefaultEncodingO
 	/**
 	Same options as [`stdio`](https://nodejs.org/dist/latest-v6.x/docs/api/child_process.html#child_process_options_stdio).
 
-	It can also be a web stream ([`WritableStream`](https://developer.mozilla.org/en-US/docs/Web/API/WritableStream)), unless [`execaSync()`](#execasyncfile-arguments-options) is used.
-
 	@default 'pipe'
 	*/
-	readonly stdout?: StdoutStderrOption;
+	readonly stdout?: StdioOption;
 
 	/**
 	Same options as [`stdio`](https://nodejs.org/dist/latest-v6.x/docs/api/child_process.html#child_process_options_stdio).
 
-	It can also be a web stream ([`WritableStream`](https://developer.mozilla.org/en-US/docs/Web/API/WritableStream)), unless [`execaSync()`](#execasyncfile-arguments-options) is used.
-
 	@default 'pipe'
 	*/
-	readonly stderr?: StdoutStderrOption;
+	readonly stderr?: StdioOption;
 
 	/**
 	Setting this to `false` resolves the promise with the error instead of rejecting it.
diff --git a/index.test-d.ts b/index.test-d.ts
index a062c37..7016a21 100644
--- a/index.test-d.ts
+++ b/index.test-d.ts
@@ -175,7 +175,6 @@ execa('unicorns', {stdout: 'ipc'});
 execa('unicorns', {stdout: 'ignore'});
 execa('unicorns', {stdout: 'inherit'});
 execa('unicorns', {stdout: process.stdout});
-execa('unicorns', {stdout: new WritableStream()});
 execa('unicorns', {stdout: 1});
 execa('unicorns', {stdout: undefined});
 execa('unicorns', {stderr: 'pipe'});
@@ -184,7 +183,6 @@ execa('unicorns', {stderr: 'ipc'});
 execa('unicorns', {stderr: 'ignore'});
 execa('unicorns', {stderr: 'inherit'});
 execa('unicorns', {stderr: process.stderr});
-execa('unicorns', {stderr: new WritableStream()});
 execa('unicorns', {stderr: 1});
 execa('unicorns', {stderr: undefined});
 execa('unicorns', {all: true});
diff --git a/lib/stdio.js b/lib/stdio.js
index cd69619..5803083 100644
--- a/lib/stdio.js
+++ b/lib/stdio.js
@@ -1,6 +1,6 @@
 import {createReadStream, readFileSync} from 'node:fs';
 import {isAbsolute} from 'node:path';
-import {Readable, Writable} from 'node:stream';
+import {Readable} from 'node:stream';
 import {isStream as isNodeStream} from 'is-stream';
 
 const aliases = ['stdin', 'stdout', 'stderr'];
@@ -13,8 +13,8 @@ const isIterableStdin = stdinOption => typeof stdinOption === 'object'
 	&& !isReadableStream(stdinOption)
 	&& (typeof stdinOption[Symbol.asyncIterator] === 'function' || typeof stdinOption[Symbol.iterator] === 'function');
 
-const getIterableStdin = stdioOption => isIterableStdin(stdioOption)
-	? stdioOption
+const getIterableStdin = stdioArray => isIterableStdin(stdioArray[0])
+	? stdioArray[0]
 	: undefined;
 
 const isUrlInstance = stdioOption => Object.prototype.toString.call(stdioOption) === '[object URL]';
@@ -27,17 +27,16 @@ const isFilePath = stdioOption => typeof stdioOption === 'string' && stringIsFil
 const isUnknownStdioString = stdioOption => typeof stdioOption === 'string' && !stringIsFilePath(stdioOption) && !KNOWN_STDIO.has(stdioOption);
 
 const isReadableStream = stdioOption => Object.prototype.toString.call(stdioOption) === '[object ReadableStream]';
-const isWritableStream = stdioOption => Object.prototype.toString.call(stdioOption) === '[object WritableStream]';
 
 // Check whether the `stdin` option results in `spawned.stdin` being `undefined`.
 // We use a deny list instead of an allow list to be forward compatible with new options.
-const cannotPipeStdin = stdinOption => NO_PIPE_STDIO.has(stdinOption)
-	|| isNodeStream(stdinOption)
-	|| isReadableStream(stdinOption)
-	|| typeof stdinOption === 'number'
-	|| isIterableStdin(stdinOption)
-	|| isFileUrl(stdinOption)
-	|| isFilePath(stdinOption);
+const cannotPipeStdio = stdioOption => NO_PIPE_STDIO.has(stdioOption)
+	|| isNodeStream(stdioOption)
+	|| isReadableStream(stdioOption)
+	|| typeof stdioOption === 'number'
+	|| isIterableStdin(stdioOption)
+	|| isFileUrl(stdioOption)
+	|| isFilePath(stdioOption);
 
 const NO_PIPE_STDIO = new Set(['ipc', 'ignore', 'inherit']);
 const KNOWN_STDIO = new Set([...NO_PIPE_STDIO, 'overlapped', 'pipe']);
@@ -58,7 +57,7 @@ const validateInputOptions = (stdioArray, input, inputFile) => {
 		throw new TypeError('The `input` and `inputFile` options cannot be both set.');
 	}
 
-	const noPipeStdin = cannotPipeStdin(stdioArray[0]);
+	const noPipeStdin = cannotPipeStdio(stdioArray[0]);
 	if (noPipeStdin && input !== undefined) {
 		throw new TypeError('The `input` and `stdin` options cannot be both set.');
 	}
@@ -70,25 +69,19 @@ const validateInputOptions = (stdioArray, input, inputFile) => {
 	validateFileSdio(stdioArray[0]);
 };
 
-const getStdioStreams = (stdioArray, {input, inputFile}) => ({
-	...getStdinStream(stdioArray[0], input, inputFile),
-	...getStdoutStream(stdioArray[1]),
-	...getStderrStream(stdioArray[2]),
-});
-
-const getStdinStream = (stdinOption, input, inputFile) => {
-	const iterableStdin = getIterableStdin(stdinOption);
+const getStdioStreams = (stdioArray, {input, inputFile}) => {
+	const iterableStdin = getIterableStdin(stdioArray);
 
 	if (iterableStdin !== undefined) {
 		return {stdinStream: Readable.from(iterableStdin)};
 	}
 
-	if (isReadableStream(stdinOption)) {
-		return {stdinStream: Readable.fromWeb(stdinOption)};
+	if (isReadableStream(stdioArray[0])) {
+		return {stdinStream: Readable.fromWeb(stdioArray[0])};
 	}
 
-	if (isFileUrl(stdinOption) || isFilePath(stdinOption)) {
-		return {stdinStream: createReadStream(stdinOption)};
+	if (isFileUrl(stdioArray[0]) || isFilePath(stdioArray[0])) {
+		return {stdinStream: createReadStream(stdioArray[0])};
 	}
 
 	if (inputFile !== undefined) {
@@ -106,42 +99,13 @@ const getStdinStream = (stdinOption, input, inputFile) => {
 	return {stdinInput: input};
 };
 
-const getStdoutStream = stdoutOption => {
-	const stdoutStream = getOutputStream(stdoutOption);
-	return stdoutStream === undefined ? {} : {stdoutStream};
-};
-
-const getStderrStream = stderrOption => {
-	const stderrStream = getOutputStream(stderrOption);
-	return stderrStream === undefined ? {} : {stderrStream};
-};
-
-const getOutputStream = stdioOption => {
-	if (isWritableStream(stdioOption)) {
-		return Writable.fromWeb(stdioOption);
-	}
-};
-
-// When the `stdin: Iterable | ReadableStream | URL | filePath`, `input` or `inputFile` option is used, we pipe to `spawned.std*`.
-// Therefore the `std*` options must be either `pipe` or `overlapped`. Other values do not set `spawned.std*`.
-const willPipeStreams = (index, {stdinStream, stdinInput, stdoutStream, stderrStream}) => {
-	if (index === 0) {
-		return stdinStream !== undefined || stdinInput !== undefined;
-	}
-
-	if (index === 1) {
-		return stdoutStream !== undefined;
-	}
-
-	if (index === 2) {
-		return stderrStream !== undefined;
-	}
-
-	return false;
-};
+// When the `stdin: iterable`, `input` or `inputFile` option is used, we pipe to `spawned.stdin`.
+// Therefore the `stdin` option must be either `pipe` or `overlapped`. Other values do not set `spawned.stdin`.
+const willPipeStdin = (index, {stdinStream, stdinInput}) =>
+	index === 0 && (stdinStream !== undefined || stdinInput !== undefined);
 
 const transformStdioItem = (stdioItem, index, stdioStreams) =>
-	willPipeStreams(index, stdioStreams) && stdioItem !== 'overlapped' ? 'pipe' : stdioItem;
+	willPipeStdin(index, stdioStreams) && stdioItem !== 'overlapped' ? 'pipe' : stdioItem;
 
 const transformStdio = (stdio, stdioStreams) => Array.isArray(stdio)
 	? stdio.map((stdioItem, index) => transformStdioItem(stdioItem, index, stdioStreams))
@@ -158,22 +122,15 @@ export const handleStdioOption = options => {
 };
 
 // Handle `input`, `inputFile` and `stdin` options, after spawning, in async mode
-export const pipeStdioOption = (spawned, {stdinStream, stdinInput, stdoutStream, stderrStream}) => {
+export const pipeStdioOption = (spawned, {stdinStream, stdinInput}) => {
 	if (stdinStream !== undefined) {
 		stdinStream.pipe(spawned.stdin);
+		return;
 	}
 
 	if (stdinInput !== undefined) {
 		spawned.stdin.end(stdinInput);
 	}
-
-	if (stdoutStream !== undefined) {
-		spawned.stdout.pipe(stdoutStream);
-	}
-
-	if (stderrStream !== undefined) {
-		spawned.stderr.pipe(stderrStream);
-	}
 };
 
 const transformStdioItemSync = stdioItem => isFileUrl(stdioItem) || isFilePath(stdioItem) ? 'pipe' : stdioItem;
@@ -182,12 +139,12 @@ const transformStdioSync = stdio => Array.isArray(stdio)
 	? stdio.map(stdioItem => transformStdioItemSync(stdioItem))
 	: stdio;
 
-const validateInputOptionsSync = (stdinOption, input) => {
-	if (getIterableStdin(stdinOption) !== undefined) {
+const validateInputOptionsSync = (stdioArray, input) => {
+	if (getIterableStdin(stdioArray) !== undefined) {
 		throw new TypeError('The `stdin` option cannot be an iterable in sync mode');
 	}
 
-	if (isReadableStream(stdinOption)) {
+	if (isReadableStream(stdioArray[0])) {
 		throw new TypeError('The `stdin` option cannot be a stream in sync mode');
 	}
 
@@ -196,22 +153,13 @@ const validateInputOptionsSync = (stdinOption, input) => {
 	}
 };
 
-const validateOutputOptionsSync = (stdioOption, optionName) => {
-	if (isWritableStream(stdioOption)) {
-		throw new TypeError(`The \`${optionName}\` option cannot be a stream in sync mode`);
-	}
-};
-
-const validateOptionsSync = (stdioArray, {input, inputFile}) => {
+const getInputOption = (stdio, {input, inputFile}) => {
+	const stdioArray = arrifyStdio(stdio);
 	validateInputOptions(stdioArray, input, inputFile);
-	validateInputOptionsSync(stdioArray[0], input);
-	validateOutputOptionsSync(stdioArray[1], 'stdout');
-	validateOutputOptionsSync(stdioArray[2], 'stderr');
-};
+	validateInputOptionsSync(stdioArray, input);
 
-const getInputOption = (stdinOption, {input, inputFile}) => {
-	if (isFileUrl(stdinOption) || isFilePath(stdinOption)) {
-		return readFileSync(stdinOption);
+	if (isFileUrl(stdioArray[0]) || isFilePath(stdioArray[0])) {
+		return readFileSync(stdioArray[0]);
 	}
 
 	if (inputFile !== undefined) {
@@ -224,10 +172,8 @@ const getInputOption = (stdinOption, {input, inputFile}) => {
 // Handle `input`, `inputFile` and `stdin` options, before spawning, in sync mode
 export const handleInputOption = options => {
 	const stdio = normalizeStdio(options);
-	const stdioArray = arrifyStdio(stdio);
-	validateOptionsSync(stdioArray, options);
 
-	const input = getInputOption(stdioArray[0], options);
+	const input = getInputOption(stdio, options);
 	if (input !== undefined) {
 		options.input = input;
 	}
diff --git a/lib/stream.js b/lib/stream.js
index 1885aa2..29420a7 100644
--- a/lib/stream.js
+++ b/lib/stream.js
@@ -53,8 +53,8 @@ const applyEncoding = async (stream, maxBuffer, encoding) => {
 	return buffer.toString(encoding);
 };
 
-// Handle any errors thrown by the iterable passed to the `stdin`/`stdout`/`stderr` option, if any.
-// We do not consume nor wait on those streams though, since it could potentially be infinite (like `process.stdin` in an interactive TTY).
+// Handle any errors thrown by the iterable passed to the `stdin` option, if any.
+// We do not consume nor wait on that stream though, since it could potentially be infinite (like `process.stdin` in an interactive TTY).
 const throwOnStreamsError = streams => streams.filter(Boolean).map(stream => throwOnStreamError(stream));
 
 const throwOnStreamError = async stream => {
@@ -63,11 +63,11 @@ const throwOnStreamError = async stream => {
 };
 
 // Retrieve result of child process: exit code, signal, error, streams (stdout/stderr/all)
-export const getSpawnedResult = async (spawned, {encoding, buffer, maxBuffer}, {stdinStream, stdoutStream, stderrStream}, processDone) => {
+export const getSpawnedResult = async (spawned, {encoding, buffer, maxBuffer}, {stdinStream}, processDone) => {
 	const stdoutPromise = getStreamPromise(spawned.stdout, {encoding, buffer, maxBuffer});
 	const stderrPromise = getStreamPromise(spawned.stderr, {encoding, buffer, maxBuffer});
 	const allPromise = getStreamPromise(spawned.all, {encoding, buffer, maxBuffer: maxBuffer * 2});
-	const processDoneOrStreamsError = Promise.race([processDone, ...throwOnStreamsError([stdinStream, stdoutStream, stderrStream])]);
+	const processDoneOrStreamsError = Promise.race([processDone, ...throwOnStreamsError([stdinStream])]);
 
 	try {
 		return await Promise.all([processDoneOrStreamsError, stdoutPromise, stderrPromise, allPromise]);
diff --git a/readme.md b/readme.md
index 9da497a..4d90328 100644
--- a/readme.md
+++ b/readme.md
@@ -564,20 +564,18 @@ Default: `inherit` with [`$`](#command), `pipe` otherwise
 
 Same options as [`stdio`](https://nodejs.org/dist/latest-v6.x/docs/api/child_process.html#child_process_options_stdio).
 
-It can also be a file path, a file URL, a web stream ([`ReadableStream`](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream)), an [`Iterable`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#the_iterable_protocol) or an [`AsyncIterable`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#the_async_iterator_and_async_iterable_protocols), unless either [`execaSync()`](#execasyncfile-arguments-options), the [`input` option](#input) or the [`inputFile` option](#inputfile) is used. If the file path is relative, it must start with `.`.
+It can also be a file path, a file URL, a web stream ([`ReadableStream`](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream)) an [`Iterable`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#the_iterable_protocol) or an [`AsyncIterable`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#the_async_iterator_and_async_iterable_protocols), providing neither [`execaSync()`](#execasyncfile-arguments-options), the [`input` option](#input) nor the [`inputFile` option](#inputfile) is used. If the file path is relative, it must start with `.`.
 
 #### stdout
 
-Type: `string | number | stream.Writable | WritableStream | undefined`\
+Type: `string | number | Stream | undefined`\
 Default: `pipe`
 
 Same options as [`stdio`](https://nodejs.org/dist/latest-v6.x/docs/api/child_process.html#child_process_options_stdio).
 
-It can also be a web stream ([`WritableStream`](https://developer.mozilla.org/en-US/docs/Web/API/WritableStream)), unless [`execaSync()`](#execasyncfile-arguments-options) is used.
-
 #### stderr
 
-Type: `string | number | stream.Writable | WritableStream | undefined`\
+Type: `string | number | Stream | undefined`\
 Default: `pipe`
 
 Same options as [`stdio`](https://nodejs.org/dist/latest-v6.x/docs/api/child_process.html#child_process_options_stdio).
diff --git a/test/stream.js b/test/stream.js
index 8c0b066..914c914 100644
--- a/test/stream.js
+++ b/test/stream.js
@@ -186,23 +186,10 @@ test('stdin option cannot be a file path when "inputFile" is used', t => {
 });
 
 test('stdin option handles errors in iterables', async t => {
-	const {originalMessage} = await t.throwsAsync(execa('stdin.js', {stdin: throwingGenerator()}));
+	const {originalMessage} = await t.throwsAsync(() => execa('stdin.js', {stdin: throwingGenerator()}));
 	t.is(originalMessage, 'generator error');
 });
 
-const testWritableStreamError = async (t, streamName) => {
-	const writableStream = new WritableStream({
-		start(controller) {
-			controller.error(new Error('foobar'));
-		},
-	});
-	const {originalMessage} = await t.throwsAsync(execa('noop.js', {[streamName]: writableStream}));
-	t.is(originalMessage, 'foobar');
-};
-
-test('stdout option handles errors in WritableStream', testWritableStreamError, 'stdout');
-test('stderr option handles errors in WritableStream', testWritableStreamError, 'stderr');
-
 test('input option can be a String', async t => {
 	const {stdout} = await execa('stdin.js', {input: 'foobar'});
 	t.is(stdout, 'foobar');
@@ -250,20 +237,6 @@ test('stdin can be a ReadableStream', async t => {
 	t.is(stdout, 'howdy');
 });
 
-const testWritableStream = async (t, streamName, fixtureName) => {
-	const result = [];
-	const writableStream = new WritableStream({
-		write(chunk) {
-			result.push(chunk);
-		},
-	});
-	await execa(fixtureName, ['foobar'], {[streamName]: writableStream});
-	t.is(result.join(''), 'foobar\n');
-};
-
-test('stdout can be a WritableStream', testWritableStream, 'stdout', 'noop.js');
-test('stderr can be a WritableStream', testWritableStream, 'stderr', 'noop-err.js');
-
 test('stdin cannot be a ReadableStream when input is used', t => {
 	const stdin = Stream.Readable.toWeb(Stream.Readable.from('howdy'));
 	t.throws(() => {
@@ -381,7 +354,7 @@ test('opts.stdout:ignore - stdout will not collect data', async t => {
 	t.is(stdout, undefined);
 });
 
-test('input cannot be a Node.js Readable in sync mode', t => {
+test('input cannot be a stream in sync mode', t => {
 	t.throws(() => {
 		execaSync('stdin.js', {input: new Stream.PassThrough()});
 	}, {message: /The `input` option cannot be a stream in sync mode/});
@@ -394,15 +367,6 @@ test('stdin cannot be a ReadableStream in sync mode', t => {
 	}, {message: /The `stdin` option cannot be a stream in sync mode/});
 });
 
-const testWritableStreamSync = (t, streamName) => {
-	t.throws(() => {
-		execaSync('noop.js', {[streamName]: new WritableStream()});
-	}, {message: new RegExp(`The \`${streamName}\` option cannot be a stream in sync mode`)});
-};
-
-test('stdout cannot be a WritableStream in sync mode', testWritableStreamSync, 'stdout');
-test('stderr cannot be a WritableStream in sync mode', testWritableStreamSync, 'stderr');
-
 test('stdin can be a file URL - sync', t => {
 	const inputFile = tempfile();
 	fs.writeFileSync(inputFile, 'howdy');
