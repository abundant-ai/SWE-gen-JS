diff --git a/.changeset/pretty-pumas-float.md b/.changeset/pretty-pumas-float.md
deleted file mode 100644
index e979230b8f..0000000000
--- a/.changeset/pretty-pumas-float.md
+++ /dev/null
@@ -1,5 +0,0 @@
----
-"@biomejs/biome": patch
----
-
-Fixed [#8144](https://github.com/biomejs/biome/issues/8144): Improve [`noSyncScripts`](https://biomejs.dev/linter/rules/no-sync-scripts), ignore script tags with `type="module"` as these are always non-blocking.
diff --git a/.changeset/seven-words-trade.md b/.changeset/seven-words-trade.md
deleted file mode 100644
index b3f7636f18..0000000000
--- a/.changeset/seven-words-trade.md
+++ /dev/null
@@ -1,13 +0,0 @@
----
-"@biomejs/biome": patch
----
-
-Added support for parsing and formatting the [CSS if function](https://developer.mozilla.org/en-US/docs/Web/CSS/Reference/Values/if).
-
-***Example***
-
-``` css
-.basic-style {
-  color: if(style(--scheme: dark): #eeeeee; else: #000000;);
-}
-```
diff --git a/crates/biome_css_factory/src/generated/node_factory.rs b/crates/biome_css_factory/src/generated/node_factory.rs
index 73b21d8a7b..d60dd70e23 100644
--- a/crates/biome_css_factory/src/generated/node_factory.rs
+++ b/crates/biome_css_factory/src/generated/node_factory.rs
@@ -686,12 +686,6 @@ impl CssDocumentCustomMatcherBuilder {
         ))
     }
 }
-pub fn css_else_keyword(else_token: SyntaxToken) -> CssElseKeyword {
-    CssElseKeyword::unwrap_cast(SyntaxNode::new_detached(
-        CssSyntaxKind::CSS_ELSE_KEYWORD,
-        [Some(SyntaxElement::Token(else_token))],
-    ))
-}
 pub fn css_empty_declaration(semicolon_token: SyntaxToken) -> CssEmptyDeclaration {
     CssEmptyDeclaration::unwrap_cast(SyntaxNode::new_detached(
         CssSyntaxKind::CSS_EMPTY_DECLARATION,
@@ -841,152 +835,6 @@ pub fn css_identifier(value_token: SyntaxToken) -> CssIdentifier {
         [Some(SyntaxElement::Token(value_token))],
     ))
 }
-pub fn css_if_branch(
-    condition: AnyCssIfCondition,
-    colon_token: SyntaxToken,
-    value: CssGenericComponentValueList,
-) -> CssIfBranch {
-    CssIfBranch::unwrap_cast(SyntaxNode::new_detached(
-        CssSyntaxKind::CSS_IF_BRANCH,
-        [
-            Some(SyntaxElement::Node(condition.into_syntax())),
-            Some(SyntaxElement::Token(colon_token)),
-            Some(SyntaxElement::Node(value.into_syntax())),
-        ],
-    ))
-}
-pub fn css_if_function(
-    if_token: SyntaxToken,
-    l_paren_token: SyntaxToken,
-    css_if_branch_list: CssIfBranchList,
-    r_paren_token: SyntaxToken,
-) -> CssIfFunction {
-    CssIfFunction::unwrap_cast(SyntaxNode::new_detached(
-        CssSyntaxKind::CSS_IF_FUNCTION,
-        [
-            Some(SyntaxElement::Token(if_token)),
-            Some(SyntaxElement::Token(l_paren_token)),
-            Some(SyntaxElement::Node(css_if_branch_list.into_syntax())),
-            Some(SyntaxElement::Token(r_paren_token)),
-        ],
-    ))
-}
-pub fn css_if_media_test(
-    media_token: SyntaxToken,
-    l_paren_token: SyntaxToken,
-    test: AnyCssIfMediaTestQuery,
-    r_paren_token: SyntaxToken,
-) -> CssIfMediaTest {
-    CssIfMediaTest::unwrap_cast(SyntaxNode::new_detached(
-        CssSyntaxKind::CSS_IF_MEDIA_TEST,
-        [
-            Some(SyntaxElement::Token(media_token)),
-            Some(SyntaxElement::Token(l_paren_token)),
-            Some(SyntaxElement::Node(test.into_syntax())),
-            Some(SyntaxElement::Token(r_paren_token)),
-        ],
-    ))
-}
-pub fn css_if_style_test(
-    style_token: SyntaxToken,
-    l_paren_token: SyntaxToken,
-    test: AnyCssContainerStyleQuery,
-    r_paren_token: SyntaxToken,
-) -> CssIfStyleTest {
-    CssIfStyleTest::unwrap_cast(SyntaxNode::new_detached(
-        CssSyntaxKind::CSS_IF_STYLE_TEST,
-        [
-            Some(SyntaxElement::Token(style_token)),
-            Some(SyntaxElement::Token(l_paren_token)),
-            Some(SyntaxElement::Node(test.into_syntax())),
-            Some(SyntaxElement::Token(r_paren_token)),
-        ],
-    ))
-}
-pub fn css_if_supports_identifier_test(
-    ident: CssIdentifier,
-    colon_token: SyntaxToken,
-    value: AnyCssGenericComponentValue,
-) -> CssIfSupportsIdentifierTest {
-    CssIfSupportsIdentifierTest::unwrap_cast(SyntaxNode::new_detached(
-        CssSyntaxKind::CSS_IF_SUPPORTS_IDENTIFIER_TEST,
-        [
-            Some(SyntaxElement::Node(ident.into_syntax())),
-            Some(SyntaxElement::Token(colon_token)),
-            Some(SyntaxElement::Node(value.into_syntax())),
-        ],
-    ))
-}
-pub fn css_if_supports_test(
-    supports_token: SyntaxToken,
-    l_paren_token: SyntaxToken,
-    test: AnyCssIfSupportsTestCondition,
-    r_paren_token: SyntaxToken,
-) -> CssIfSupportsTest {
-    CssIfSupportsTest::unwrap_cast(SyntaxNode::new_detached(
-        CssSyntaxKind::CSS_IF_SUPPORTS_TEST,
-        [
-            Some(SyntaxElement::Token(supports_token)),
-            Some(SyntaxElement::Token(l_paren_token)),
-            Some(SyntaxElement::Node(test.into_syntax())),
-            Some(SyntaxElement::Token(r_paren_token)),
-        ],
-    ))
-}
-pub fn css_if_test_boolean_and_expr(
-    left: AnyCssIfTestBooleanExprGroup,
-    and_token: SyntaxToken,
-    right: AnyCssIfTestBooleanAndCombinableExpr,
-) -> CssIfTestBooleanAndExpr {
-    CssIfTestBooleanAndExpr::unwrap_cast(SyntaxNode::new_detached(
-        CssSyntaxKind::CSS_IF_TEST_BOOLEAN_AND_EXPR,
-        [
-            Some(SyntaxElement::Node(left.into_syntax())),
-            Some(SyntaxElement::Token(and_token)),
-            Some(SyntaxElement::Node(right.into_syntax())),
-        ],
-    ))
-}
-pub fn css_if_test_boolean_expr_in_parens(
-    l_paren_token: SyntaxToken,
-    expression: AnyCssIfTestBooleanExpr,
-    r_paren_token: SyntaxToken,
-) -> CssIfTestBooleanExprInParens {
-    CssIfTestBooleanExprInParens::unwrap_cast(SyntaxNode::new_detached(
-        CssSyntaxKind::CSS_IF_TEST_BOOLEAN_EXPR_IN_PARENS,
-        [
-            Some(SyntaxElement::Token(l_paren_token)),
-            Some(SyntaxElement::Node(expression.into_syntax())),
-            Some(SyntaxElement::Token(r_paren_token)),
-        ],
-    ))
-}
-pub fn css_if_test_boolean_not_expr(
-    not_token: SyntaxToken,
-    expression: AnyCssIfTestBooleanExprGroup,
-) -> CssIfTestBooleanNotExpr {
-    CssIfTestBooleanNotExpr::unwrap_cast(SyntaxNode::new_detached(
-        CssSyntaxKind::CSS_IF_TEST_BOOLEAN_NOT_EXPR,
-        [
-            Some(SyntaxElement::Token(not_token)),
-            Some(SyntaxElement::Node(expression.into_syntax())),
-        ],
-    ))
-}
-pub fn css_if_test_boolean_or_expr(
-    left: AnyCssIfTestBooleanExprGroup,
-    or_token: SyntaxToken,
-    right: AnyCssIfTestBooleanOrCombinableExpr,
-) -> CssIfTestBooleanOrExpr {
-    CssIfTestBooleanOrExpr::unwrap_cast(SyntaxNode::new_detached(
-        CssSyntaxKind::CSS_IF_TEST_BOOLEAN_OR_EXPR,
-        [
-            Some(SyntaxElement::Node(left.into_syntax())),
-            Some(SyntaxElement::Token(or_token)),
-            Some(SyntaxElement::Node(right.into_syntax())),
-        ],
-    ))
-}
 pub fn css_import_anonymous_layer(layer_token: SyntaxToken) -> CssImportAnonymousLayer {
     CssImportAnonymousLayer::unwrap_cast(SyntaxNode::new_detached(
         CssSyntaxKind::CSS_IMPORT_ANONYMOUS_LAYER,
@@ -3097,27 +2945,6 @@ where
             .map(|item| Some(item.into_syntax().into())),
     ))
 }
-pub fn css_if_branch_list<I, S>(items: I, separators: S) -> CssIfBranchList
-where
-    I: IntoIterator<Item = AnyCssIfBranch>,
-    I::IntoIter: ExactSizeIterator,
-    S: IntoIterator<Item = CssSyntaxToken>,
-    S::IntoIter: ExactSizeIterator,
-{
-    let mut items = items.into_iter();
-    let mut separators = separators.into_iter();
-    let length = items.len() + separators.len();
-    CssIfBranchList::unwrap_cast(SyntaxNode::new_detached(
-        CssSyntaxKind::CSS_IF_BRANCH_LIST,
-        (0..length).map(|index| {
-            if index % 2 == 0 {
-                Some(items.next()?.into_syntax().into())
-            } else {
-                Some(separators.next()?.into())
-            }
-        }),
-    ))
-}
 pub fn css_keyframes_item_list<I>(items: I) -> CssKeyframesItemList
 where
     I: IntoIterator<Item = AnyCssKeyframesItem>,
@@ -3539,26 +3366,6 @@ where
         slots,
     ))
 }
-pub fn css_bogus_if_branch<I>(slots: I) -> CssBogusIfBranch
-where
-    I: IntoIterator<Item = Option<SyntaxElement>>,
-    I::IntoIter: ExactSizeIterator,
-{
-    CssBogusIfBranch::unwrap_cast(SyntaxNode::new_detached(
-        CssSyntaxKind::CSS_BOGUS_IF_BRANCH,
-        slots,
-    ))
-}
-pub fn css_bogus_if_test<I>(slots: I) -> CssBogusIfTest
-where
-    I: IntoIterator<Item = Option<SyntaxElement>>,
-    I::IntoIter: ExactSizeIterator,
-{
-    CssBogusIfTest::unwrap_cast(SyntaxNode::new_detached(
-        CssSyntaxKind::CSS_BOGUS_IF_TEST,
-        slots,
-    ))
-}
 pub fn css_bogus_keyframes_item<I>(slots: I) -> CssBogusKeyframesItem
 where
     I: IntoIterator<Item = Option<SyntaxElement>>,
diff --git a/crates/biome_css_factory/src/generated/syntax_factory.rs b/crates/biome_css_factory/src/generated/syntax_factory.rs
index 8672f2f993..4499dc6455 100644
--- a/crates/biome_css_factory/src/generated/syntax_factory.rs
+++ b/crates/biome_css_factory/src/generated/syntax_factory.rs
@@ -22,8 +22,6 @@ impl SyntaxFactory for CssSyntaxFactory {
             | CSS_BOGUS_DOCUMENT_MATCHER
             | CSS_BOGUS_FONT_FAMILY_NAME
             | CSS_BOGUS_FONT_FEATURE_VALUES_ITEM
-            | CSS_BOGUS_IF_BRANCH
-            | CSS_BOGUS_IF_TEST
             | CSS_BOGUS_KEYFRAMES_ITEM
             | CSS_BOGUS_KEYFRAMES_NAME
             | CSS_BOGUS_LAYER
@@ -1300,25 +1298,6 @@ impl SyntaxFactory for CssSyntaxFactory {
                 }
                 slots.into_node(CSS_DOCUMENT_CUSTOM_MATCHER, children)
             }
-            CSS_ELSE_KEYWORD => {
-                let mut elements = (&children).into_iter();
-                let mut slots: RawNodeSlots<1usize> = RawNodeSlots::default();
-                let mut current_element = elements.next();
-                if let Some(element) = &current_element
-                    && element.kind() == T![else]
-                {
-                    slots.mark_present();
-                    current_element = elements.next();
-                }
-                slots.next_slot();
-                if current_element.is_some() {
-                    return RawSyntaxNode::new(
-                        CSS_ELSE_KEYWORD.to_bogus(),
-                        children.into_iter().map(Some),
-                    );
-                }
-                slots.into_node(CSS_ELSE_KEYWORD, children)
-            }
             CSS_EMPTY_DECLARATION => {
                 let mut elements = (&children).into_iter();
                 let mut slots: RawNodeSlots<1usize> = RawNodeSlots::default();
@@ -1699,357 +1678,6 @@ impl SyntaxFactory for CssSyntaxFactory {
                 }
                 slots.into_node(CSS_IDENTIFIER, children)
             }
-            CSS_IF_BRANCH => {
-                let mut elements = (&children).into_iter();
-                let mut slots: RawNodeSlots<3usize> = RawNodeSlots::default();
-                let mut current_element = elements.next();
-                if let Some(element) = &current_element
-                    && AnyCssIfCondition::can_cast(element.kind())
-                {
-                    slots.mark_present();
-                    current_element = elements.next();
-                }
-                slots.next_slot();
-                if let Some(element) = &current_element
-                    && element.kind() == T ! [:]
-                {
-                    slots.mark_present();
-                    current_element = elements.next();
-                }
-                slots.next_slot();
-                if let Some(element) = &current_element
-                    && CssGenericComponentValueList::can_cast(element.kind())
-                {
-                    slots.mark_present();
-                    current_element = elements.next();
-                }
-                slots.next_slot();
-                if current_element.is_some() {
-                    return RawSyntaxNode::new(
-                        CSS_IF_BRANCH.to_bogus(),
-                        children.into_iter().map(Some),
-                    );
-                }
-                slots.into_node(CSS_IF_BRANCH, children)
-            }
-            CSS_IF_FUNCTION => {
-                let mut elements = (&children).into_iter();
-                let mut slots: RawNodeSlots<4usize> = RawNodeSlots::default();
-                let mut current_element = elements.next();
-                if let Some(element) = &current_element
-                    && element.kind() == T![if]
-                {
-                    slots.mark_present();
-                    current_element = elements.next();
-                }
-                slots.next_slot();
-                if let Some(element) = &current_element
-                    && element.kind() == T!['(']
-                {
-                    slots.mark_present();
-                    current_element = elements.next();
-                }
-                slots.next_slot();
-                if let Some(element) = &current_element
-                    && CssIfBranchList::can_cast(element.kind())
-                {
-                    slots.mark_present();
-                    current_element = elements.next();
-                }
-                slots.next_slot();
-                if let Some(element) = &current_element
-                    && element.kind() == T![')']
-                {
-                    slots.mark_present();
-                    current_element = elements.next();
-                }
-                slots.next_slot();
-                if current_element.is_some() {
-                    return RawSyntaxNode::new(
-                        CSS_IF_FUNCTION.to_bogus(),
-                        children.into_iter().map(Some),
-                    );
-                }
-                slots.into_node(CSS_IF_FUNCTION, children)
-            }
-            CSS_IF_MEDIA_TEST => {
-                let mut elements = (&children).into_iter();
-                let mut slots: RawNodeSlots<4usize> = RawNodeSlots::default();
-                let mut current_element = elements.next();
-                if let Some(element) = &current_element
-                    && element.kind() == T![media]
-                {
-                    slots.mark_present();
-                    current_element = elements.next();
-                }
-                slots.next_slot();
-                if let Some(element) = &current_element
-                    && element.kind() == T!['(']
-                {
-                    slots.mark_present();
-                    current_element = elements.next();
-                }
-                slots.next_slot();
-                if let Some(element) = &current_element
-                    && AnyCssIfMediaTestQuery::can_cast(element.kind())
-                {
-                    slots.mark_present();
-                    current_element = elements.next();
-                }
-                slots.next_slot();
-                if let Some(element) = &current_element
-                    && element.kind() == T![')']
-                {
-                    slots.mark_present();
-                    current_element = elements.next();
-                }
-                slots.next_slot();
-                if current_element.is_some() {
-                    return RawSyntaxNode::new(
-                        CSS_IF_MEDIA_TEST.to_bogus(),
-                        children.into_iter().map(Some),
-                    );
-                }
-                slots.into_node(CSS_IF_MEDIA_TEST, children)
-            }
-            CSS_IF_STYLE_TEST => {
-                let mut elements = (&children).into_iter();
-                let mut slots: RawNodeSlots<4usize> = RawNodeSlots::default();
-                let mut current_element = elements.next();
-                if let Some(element) = &current_element
-                    && element.kind() == T![style]
-                {
-                    slots.mark_present();
-                    current_element = elements.next();
-                }
-                slots.next_slot();
-                if let Some(element) = &current_element
-                    && element.kind() == T!['(']
-                {
-                    slots.mark_present();
-                    current_element = elements.next();
-                }
-                slots.next_slot();
-                if let Some(element) = &current_element
-                    && AnyCssContainerStyleQuery::can_cast(element.kind())
-                {
-                    slots.mark_present();
-                    current_element = elements.next();
-                }
-                slots.next_slot();
-                if let Some(element) = &current_element
-                    && element.kind() == T![')']
-                {
-                    slots.mark_present();
-                    current_element = elements.next();
-                }
-                slots.next_slot();
-                if current_element.is_some() {
-                    return RawSyntaxNode::new(
-                        CSS_IF_STYLE_TEST.to_bogus(),
-                        children.into_iter().map(Some),
-                    );
-                }
-                slots.into_node(CSS_IF_STYLE_TEST, children)
-            }
-            CSS_IF_SUPPORTS_IDENTIFIER_TEST => {
-                let mut elements = (&children).into_iter();
-                let mut slots: RawNodeSlots<3usize> = RawNodeSlots::default();
-                let mut current_element = elements.next();
-                if let Some(element) = &current_element
-                    && CssIdentifier::can_cast(element.kind())
-                {
-                    slots.mark_present();
-                    current_element = elements.next();
-                }
-                slots.next_slot();
-                if let Some(element) = &current_element
-                    && element.kind() == T ! [:]
-                {
-                    slots.mark_present();
-                    current_element = elements.next();
-                }
-                slots.next_slot();
-                if let Some(element) = &current_element
-                    && AnyCssGenericComponentValue::can_cast(element.kind())
-                {
-                    slots.mark_present();
-                    current_element = elements.next();
-                }
-                slots.next_slot();
-                if current_element.is_some() {
-                    return RawSyntaxNode::new(
-                        CSS_IF_SUPPORTS_IDENTIFIER_TEST.to_bogus(),
-                        children.into_iter().map(Some),
-                    );
-                }
-                slots.into_node(CSS_IF_SUPPORTS_IDENTIFIER_TEST, children)
-            }
-            CSS_IF_SUPPORTS_TEST => {
-                let mut elements = (&children).into_iter();
-                let mut slots: RawNodeSlots<4usize> = RawNodeSlots::default();
-                let mut current_element = elements.next();
-                if let Some(element) = &current_element
-                    && element.kind() == T![supports]
-                {
-                    slots.mark_present();
-                    current_element = elements.next();
-                }
-                slots.next_slot();
-                if let Some(element) = &current_element
-                    && element.kind() == T!['(']
-                {
-                    slots.mark_present();
-                    current_element = elements.next();
-                }
-                slots.next_slot();
-                if let Some(element) = &current_element
-                    && AnyCssIfSupportsTestCondition::can_cast(element.kind())
-                {
-                    slots.mark_present();
-                    current_element = elements.next();
-                }
-                slots.next_slot();
-                if let Some(element) = &current_element
-                    && element.kind() == T![')']
-                {
-                    slots.mark_present();
-                    current_element = elements.next();
-                }
-                slots.next_slot();
-                if current_element.is_some() {
-                    return RawSyntaxNode::new(
-                        CSS_IF_SUPPORTS_TEST.to_bogus(),
-                        children.into_iter().map(Some),
-                    );
-                }
-                slots.into_node(CSS_IF_SUPPORTS_TEST, children)
-            }
-            CSS_IF_TEST_BOOLEAN_AND_EXPR => {
-                let mut elements = (&children).into_iter();
-                let mut slots: RawNodeSlots<3usize> = RawNodeSlots::default();
-                let mut current_element = elements.next();
-                if let Some(element) = &current_element
-                    && AnyCssIfTestBooleanExprGroup::can_cast(element.kind())
-                {
-                    slots.mark_present();
-                    current_element = elements.next();
-                }
-                slots.next_slot();
-                if let Some(element) = &current_element
-                    && element.kind() == T![and]
-                {
-                    slots.mark_present();
-                    current_element = elements.next();
-                }
-                slots.next_slot();
-                if let Some(element) = &current_element
-                    && AnyCssIfTestBooleanAndCombinableExpr::can_cast(element.kind())
-                {
-                    slots.mark_present();
-                    current_element = elements.next();
-                }
-                slots.next_slot();
-                if current_element.is_some() {
-                    return RawSyntaxNode::new(
-                        CSS_IF_TEST_BOOLEAN_AND_EXPR.to_bogus(),
-                        children.into_iter().map(Some),
-                    );
-                }
-                slots.into_node(CSS_IF_TEST_BOOLEAN_AND_EXPR, children)
-            }
-            CSS_IF_TEST_BOOLEAN_EXPR_IN_PARENS => {
-                let mut elements = (&children).into_iter();
-                let mut slots: RawNodeSlots<3usize> = RawNodeSlots::default();
-                let mut current_element = elements.next();
-                if let Some(element) = &current_element
-                    && element.kind() == T!['(']
-                {
-                    slots.mark_present();
-                    current_element = elements.next();
-                }
-                slots.next_slot();
-                if let Some(element) = &current_element
-                    && AnyCssIfTestBooleanExpr::can_cast(element.kind())
-                {
-                    slots.mark_present();
-                    current_element = elements.next();
-                }
-                slots.next_slot();
-                if let Some(element) = &current_element
-                    && element.kind() == T![')']
-                {
-                    slots.mark_present();
-                    current_element = elements.next();
-                }
-                slots.next_slot();
-                if current_element.is_some() {
-                    return RawSyntaxNode::new(
-                        CSS_IF_TEST_BOOLEAN_EXPR_IN_PARENS.to_bogus(),
-                        children.into_iter().map(Some),
-                    );
-                }
-                slots.into_node(CSS_IF_TEST_BOOLEAN_EXPR_IN_PARENS, children)
-            }
-            CSS_IF_TEST_BOOLEAN_NOT_EXPR => {
-                let mut elements = (&children).into_iter();
-                let mut slots: RawNodeSlots<2usize> = RawNodeSlots::default();
-                let mut current_element = elements.next();
-                if let Some(element) = &current_element
-                    && element.kind() == T![not]
-                {
-                    slots.mark_present();
-                    current_element = elements.next();
-                }
-                slots.next_slot();
-                if let Some(element) = &current_element
-                    && AnyCssIfTestBooleanExprGroup::can_cast(element.kind())
-                {
-                    slots.mark_present();
-                    current_element = elements.next();
-                }
-                slots.next_slot();
-                if current_element.is_some() {
-                    return RawSyntaxNode::new(
-                        CSS_IF_TEST_BOOLEAN_NOT_EXPR.to_bogus(),
-                        children.into_iter().map(Some),
-                    );
-                }
-                slots.into_node(CSS_IF_TEST_BOOLEAN_NOT_EXPR, children)
-            }
-            CSS_IF_TEST_BOOLEAN_OR_EXPR => {
-                let mut elements = (&children).into_iter();
-                let mut slots: RawNodeSlots<3usize> = RawNodeSlots::default();
-                let mut current_element = elements.next();
-                if let Some(element) = &current_element
-                    && AnyCssIfTestBooleanExprGroup::can_cast(element.kind())
-                {
-                    slots.mark_present();
-                    current_element = elements.next();
-                }
-                slots.next_slot();
-                if let Some(element) = &current_element
-                    && element.kind() == T![or]
-                {
-                    slots.mark_present();
-                    current_element = elements.next();
-                }
-                slots.next_slot();
-                if let Some(element) = &current_element
-                    && AnyCssIfTestBooleanOrCombinableExpr::can_cast(element.kind())
-                {
-                    slots.mark_present();
-                    current_element = elements.next();
-                }
-                slots.next_slot();
-                if current_element.is_some() {
-                    return RawSyntaxNode::new(
-                        CSS_IF_TEST_BOOLEAN_OR_EXPR.to_bogus(),
-                        children.into_iter().map(Some),
-                    );
-                }
-                slots.into_node(CSS_IF_TEST_BOOLEAN_OR_EXPR, children)
-            }
             CSS_IMPORT_ANONYMOUS_LAYER => {
                 let mut elements = (&children).into_iter();
                 let mut slots: RawNodeSlots<1usize> = RawNodeSlots::default();
@@ -6031,13 +5659,6 @@ impl SyntaxFactory for CssSyntaxFactory {
             CSS_GENERIC_COMPONENT_VALUE_LIST => {
                 Self::make_node_list_syntax(kind, children, AnyCssGenericComponentValue::can_cast)
             }
-            CSS_IF_BRANCH_LIST => Self::make_separated_list_syntax(
-                kind,
-                children,
-                AnyCssIfBranch::can_cast,
-                T ! [;],
-                true,
-            ),
             CSS_KEYFRAMES_ITEM_LIST => {
                 Self::make_node_list_syntax(kind, children, AnyCssKeyframesItem::can_cast)
             }
diff --git a/crates/biome_css_formatter/src/css/any/function.rs b/crates/biome_css_formatter/src/css/any/function.rs
index b5bac4b273..115b12d821 100644
--- a/crates/biome_css_formatter/src/css/any/function.rs
+++ b/crates/biome_css_formatter/src/css/any/function.rs
@@ -9,7 +9,6 @@ impl FormatRule<AnyCssFunction> for FormatAnyCssFunction {
     fn fmt(&self, node: &AnyCssFunction, f: &mut CssFormatter) -> FormatResult<()> {
         match node {
             AnyCssFunction::CssFunction(node) => node.format().fmt(f),
-            AnyCssFunction::CssIfFunction(node) => node.format().fmt(f),
             AnyCssFunction::CssUrlFunction(node) => node.format().fmt(f),
         }
     }
diff --git a/crates/biome_css_formatter/src/css/any/if_branch.rs b/crates/biome_css_formatter/src/css/any/if_branch.rs
deleted file mode 100644
index 641b678347..0000000000
--- a/crates/biome_css_formatter/src/css/any/if_branch.rs
+++ /dev/null
@@ -1,15 +0,0 @@
-//! This is a generated file. Don't modify it by hand! Run 'cargo codegen formatter' to re-generate the file.
-
-use crate::prelude::*;
-use biome_css_syntax::AnyCssIfBranch;
-#[derive(Debug, Clone, Default)]
-pub(crate) struct FormatAnyCssIfBranch;
-impl FormatRule<AnyCssIfBranch> for FormatAnyCssIfBranch {
-    type Context = CssFormatContext;
-    fn fmt(&self, node: &AnyCssIfBranch, f: &mut CssFormatter) -> FormatResult<()> {
-        match node {
-            AnyCssIfBranch::CssBogusIfBranch(node) => node.format().fmt(f),
-            AnyCssIfBranch::CssIfBranch(node) => node.format().fmt(f),
-        }
-    }
-}
diff --git a/crates/biome_css_formatter/src/css/any/if_condition.rs b/crates/biome_css_formatter/src/css/any/if_condition.rs
deleted file mode 100644
index c5395b9292..0000000000
--- a/crates/biome_css_formatter/src/css/any/if_condition.rs
+++ /dev/null
@@ -1,15 +0,0 @@
-//! This is a generated file. Don't modify it by hand! Run 'cargo codegen formatter' to re-generate the file.
-
-use crate::prelude::*;
-use biome_css_syntax::AnyCssIfCondition;
-#[derive(Debug, Clone, Default)]
-pub(crate) struct FormatAnyCssIfCondition;
-impl FormatRule<AnyCssIfCondition> for FormatAnyCssIfCondition {
-    type Context = CssFormatContext;
-    fn fmt(&self, node: &AnyCssIfCondition, f: &mut CssFormatter) -> FormatResult<()> {
-        match node {
-            AnyCssIfCondition::AnyCssIfTestBooleanExpr(node) => node.format().fmt(f),
-            AnyCssIfCondition::CssElseKeyword(node) => node.format().fmt(f),
-        }
-    }
-}
diff --git a/crates/biome_css_formatter/src/css/any/if_media_test_query.rs b/crates/biome_css_formatter/src/css/any/if_media_test_query.rs
deleted file mode 100644
index c4d3c84d68..0000000000
--- a/crates/biome_css_formatter/src/css/any/if_media_test_query.rs
+++ /dev/null
@@ -1,15 +0,0 @@
-//! This is a generated file. Don't modify it by hand! Run 'cargo codegen formatter' to re-generate the file.
-
-use crate::prelude::*;
-use biome_css_syntax::AnyCssIfMediaTestQuery;
-#[derive(Debug, Clone, Default)]
-pub(crate) struct FormatAnyCssIfMediaTestQuery;
-impl FormatRule<AnyCssIfMediaTestQuery> for FormatAnyCssIfMediaTestQuery {
-    type Context = CssFormatContext;
-    fn fmt(&self, node: &AnyCssIfMediaTestQuery, f: &mut CssFormatter) -> FormatResult<()> {
-        match node {
-            AnyCssIfMediaTestQuery::AnyCssMediaCondition(node) => node.format().fmt(f),
-            AnyCssIfMediaTestQuery::AnyCssQueryFeature(node) => node.format().fmt(f),
-        }
-    }
-}
diff --git a/crates/biome_css_formatter/src/css/any/if_supports_test_condition.rs b/crates/biome_css_formatter/src/css/any/if_supports_test_condition.rs
deleted file mode 100644
index 6282190dc9..0000000000
--- a/crates/biome_css_formatter/src/css/any/if_supports_test_condition.rs
+++ /dev/null
@@ -1,19 +0,0 @@
-//! This is a generated file. Don't modify it by hand! Run 'cargo codegen formatter' to re-generate the file.
-
-use crate::prelude::*;
-use biome_css_syntax::AnyCssIfSupportsTestCondition;
-#[derive(Debug, Clone, Default)]
-pub(crate) struct FormatAnyCssIfSupportsTestCondition;
-impl FormatRule<AnyCssIfSupportsTestCondition> for FormatAnyCssIfSupportsTestCondition {
-    type Context = CssFormatContext;
-    fn fmt(&self, node: &AnyCssIfSupportsTestCondition, f: &mut CssFormatter) -> FormatResult<()> {
-        match node {
-            AnyCssIfSupportsTestCondition::AnyCssImportSupportsCondition(node) => {
-                node.format().fmt(f)
-            }
-            AnyCssIfSupportsTestCondition::CssIfSupportsIdentifierTest(node) => {
-                node.format().fmt(f)
-            }
-        }
-    }
-}
diff --git a/crates/biome_css_formatter/src/css/any/if_test_boolean_and_combinable_expr.rs b/crates/biome_css_formatter/src/css/any/if_test_boolean_and_combinable_expr.rs
deleted file mode 100644
index 3eadc9f137..0000000000
--- a/crates/biome_css_formatter/src/css/any/if_test_boolean_and_combinable_expr.rs
+++ /dev/null
@@ -1,25 +0,0 @@
-//! This is a generated file. Don't modify it by hand! Run 'cargo codegen formatter' to re-generate the file.
-
-use crate::prelude::*;
-use biome_css_syntax::AnyCssIfTestBooleanAndCombinableExpr;
-#[derive(Debug, Clone, Default)]
-pub(crate) struct FormatAnyCssIfTestBooleanAndCombinableExpr;
-impl FormatRule<AnyCssIfTestBooleanAndCombinableExpr>
-    for FormatAnyCssIfTestBooleanAndCombinableExpr
-{
-    type Context = CssFormatContext;
-    fn fmt(
-        &self,
-        node: &AnyCssIfTestBooleanAndCombinableExpr,
-        f: &mut CssFormatter,
-    ) -> FormatResult<()> {
-        match node {
-            AnyCssIfTestBooleanAndCombinableExpr::AnyCssIfTestBooleanExprGroup(node) => {
-                node.format().fmt(f)
-            }
-            AnyCssIfTestBooleanAndCombinableExpr::CssIfTestBooleanAndExpr(node) => {
-                node.format().fmt(f)
-            }
-        }
-    }
-}
diff --git a/crates/biome_css_formatter/src/css/any/if_test_boolean_expr.rs b/crates/biome_css_formatter/src/css/any/if_test_boolean_expr.rs
deleted file mode 100644
index f7f4c55e42..0000000000
--- a/crates/biome_css_formatter/src/css/any/if_test_boolean_expr.rs
+++ /dev/null
@@ -1,20 +0,0 @@
-//! This is a generated file. Don't modify it by hand! Run 'cargo codegen formatter' to re-generate the file.
-
-use crate::prelude::*;
-use biome_css_syntax::AnyCssIfTestBooleanExpr;
-#[derive(Debug, Clone, Default)]
-pub(crate) struct FormatAnyCssIfTestBooleanExpr;
-impl FormatRule<AnyCssIfTestBooleanExpr> for FormatAnyCssIfTestBooleanExpr {
-    type Context = CssFormatContext;
-    fn fmt(&self, node: &AnyCssIfTestBooleanExpr, f: &mut CssFormatter) -> FormatResult<()> {
-        match node {
-            AnyCssIfTestBooleanExpr::AnyCssIfTestBooleanAndCombinableExpr(node) => {
-                node.format().fmt(f)
-            }
-            AnyCssIfTestBooleanExpr::AnyCssIfTestBooleanOrCombinableExpr(node) => {
-                node.format().fmt(f)
-            }
-            AnyCssIfTestBooleanExpr::CssIfTestBooleanNotExpr(node) => node.format().fmt(f),
-        }
-    }
-}
diff --git a/crates/biome_css_formatter/src/css/any/if_test_boolean_expr_group.rs b/crates/biome_css_formatter/src/css/any/if_test_boolean_expr_group.rs
deleted file mode 100644
index 35aecf7263..0000000000
--- a/crates/biome_css_formatter/src/css/any/if_test_boolean_expr_group.rs
+++ /dev/null
@@ -1,17 +0,0 @@
-//! This is a generated file. Don't modify it by hand! Run 'cargo codegen formatter' to re-generate the file.
-
-use crate::prelude::*;
-use biome_css_syntax::AnyCssIfTestBooleanExprGroup;
-#[derive(Debug, Clone, Default)]
-pub(crate) struct FormatAnyCssIfTestBooleanExprGroup;
-impl FormatRule<AnyCssIfTestBooleanExprGroup> for FormatAnyCssIfTestBooleanExprGroup {
-    type Context = CssFormatContext;
-    fn fmt(&self, node: &AnyCssIfTestBooleanExprGroup, f: &mut CssFormatter) -> FormatResult<()> {
-        match node {
-            AnyCssIfTestBooleanExprGroup::AnyCssIfTest(node) => node.format().fmt(f),
-            AnyCssIfTestBooleanExprGroup::CssIfTestBooleanExprInParens(node) => {
-                node.format().fmt(f)
-            }
-        }
-    }
-}
diff --git a/crates/biome_css_formatter/src/css/any/if_test_boolean_or_combinable_expr.rs b/crates/biome_css_formatter/src/css/any/if_test_boolean_or_combinable_expr.rs
deleted file mode 100644
index db2c07fd91..0000000000
--- a/crates/biome_css_formatter/src/css/any/if_test_boolean_or_combinable_expr.rs
+++ /dev/null
@@ -1,23 +0,0 @@
-//! This is a generated file. Don't modify it by hand! Run 'cargo codegen formatter' to re-generate the file.
-
-use crate::prelude::*;
-use biome_css_syntax::AnyCssIfTestBooleanOrCombinableExpr;
-#[derive(Debug, Clone, Default)]
-pub(crate) struct FormatAnyCssIfTestBooleanOrCombinableExpr;
-impl FormatRule<AnyCssIfTestBooleanOrCombinableExpr> for FormatAnyCssIfTestBooleanOrCombinableExpr {
-    type Context = CssFormatContext;
-    fn fmt(
-        &self,
-        node: &AnyCssIfTestBooleanOrCombinableExpr,
-        f: &mut CssFormatter,
-    ) -> FormatResult<()> {
-        match node {
-            AnyCssIfTestBooleanOrCombinableExpr::AnyCssIfTestBooleanExprGroup(node) => {
-                node.format().fmt(f)
-            }
-            AnyCssIfTestBooleanOrCombinableExpr::CssIfTestBooleanOrExpr(node) => {
-                node.format().fmt(f)
-            }
-        }
-    }
-}
diff --git a/crates/biome_css_formatter/src/css/any/mod.rs b/crates/biome_css_formatter/src/css/any/mod.rs
index 0257cb1651..8cf7792b28 100644
--- a/crates/biome_css_formatter/src/css/any/mod.rs
+++ b/crates/biome_css_formatter/src/css/any/mod.rs
@@ -30,15 +30,6 @@ pub(crate) mod font_feature_values_block;
 pub(crate) mod font_feature_values_item;
 pub(crate) mod function;
 pub(crate) mod generic_component_value;
-pub(crate) mod if_branch;
-pub(crate) mod if_condition;
-pub(crate) mod if_media_test_query;
-pub(crate) mod if_supports_test_condition;
-pub(crate) mod if_test;
-pub(crate) mod if_test_boolean_and_combinable_expr;
-pub(crate) mod if_test_boolean_expr;
-pub(crate) mod if_test_boolean_expr_group;
-pub(crate) mod if_test_boolean_or_combinable_expr;
 pub(crate) mod import_layer;
 pub(crate) mod import_supports_condition;
 pub(crate) mod import_url;
diff --git a/crates/biome_css_formatter/src/css/auxiliary/else_keyword.rs b/crates/biome_css_formatter/src/css/auxiliary/else_keyword.rs
deleted file mode 100644
index 1d398923e7..0000000000
--- a/crates/biome_css_formatter/src/css/auxiliary/else_keyword.rs
+++ /dev/null
@@ -1,14 +0,0 @@
-use crate::prelude::*;
-use biome_css_syntax::{CssElseKeyword, CssElseKeywordFields};
-use biome_formatter::write;
-
-#[derive(Debug, Clone, Default)]
-pub(crate) struct FormatCssElseKeyword;
-
-impl FormatNodeRule<CssElseKeyword> for FormatCssElseKeyword {
-    fn fmt_fields(&self, node: &CssElseKeyword, f: &mut CssFormatter) -> FormatResult<()> {
-        let CssElseKeywordFields { else_token } = node.as_fields();
-
-        write!(f, [else_token.format()])
-    }
-}
diff --git a/crates/biome_css_formatter/src/css/auxiliary/if_branch.rs b/crates/biome_css_formatter/src/css/auxiliary/if_branch.rs
deleted file mode 100644
index d9409cda2d..0000000000
--- a/crates/biome_css_formatter/src/css/auxiliary/if_branch.rs
+++ /dev/null
@@ -1,26 +0,0 @@
-use crate::prelude::*;
-use biome_css_syntax::{CssIfBranch, CssIfBranchFields};
-use biome_formatter::write;
-
-#[derive(Debug, Clone, Default)]
-pub(crate) struct FormatCssIfBranch;
-
-impl FormatNodeRule<CssIfBranch> for FormatCssIfBranch {
-    fn fmt_fields(&self, node: &CssIfBranch, f: &mut CssFormatter) -> FormatResult<()> {
-        let CssIfBranchFields {
-            condition,
-            colon_token,
-            value,
-        } = node.as_fields();
-
-        write!(
-            f,
-            [
-                condition.format(),
-                colon_token.format(),
-                space(),
-                value.format()
-            ]
-        )
-    }
-}
diff --git a/crates/biome_css_formatter/src/css/auxiliary/if_function.rs b/crates/biome_css_formatter/src/css/auxiliary/if_function.rs
deleted file mode 100644
index 7b8871c8f8..0000000000
--- a/crates/biome_css_formatter/src/css/auxiliary/if_function.rs
+++ /dev/null
@@ -1,29 +0,0 @@
-use crate::prelude::*;
-use biome_css_syntax::{CssIfFunction, CssIfFunctionFields};
-use biome_formatter::{format_args, write};
-
-#[derive(Debug, Clone, Default)]
-pub(crate) struct FormatCssIfFunction;
-
-impl FormatNodeRule<CssIfFunction> for FormatCssIfFunction {
-    fn fmt_fields(&self, node: &CssIfFunction, f: &mut CssFormatter) -> FormatResult<()> {
-        let CssIfFunctionFields {
-            if_token,
-            l_paren_token,
-            css_if_branch_list,
-            r_paren_token,
-        } = node.as_fields();
-
-        write!(
-            f,
-            [
-                if_token.format(),
-                group(&format_args![
-                    l_paren_token.format(),
-                    soft_block_indent(&css_if_branch_list.format()),
-                    r_paren_token.format()
-                ])
-            ]
-        )
-    }
-}
diff --git a/crates/biome_css_formatter/src/css/auxiliary/if_test_boolean_and_expr.rs b/crates/biome_css_formatter/src/css/auxiliary/if_test_boolean_and_expr.rs
deleted file mode 100644
index 165b4801e5..0000000000
--- a/crates/biome_css_formatter/src/css/auxiliary/if_test_boolean_and_expr.rs
+++ /dev/null
@@ -1,27 +0,0 @@
-use crate::prelude::*;
-use biome_css_syntax::{CssIfTestBooleanAndExpr, CssIfTestBooleanAndExprFields};
-use biome_formatter::write;
-
-#[derive(Debug, Clone, Default)]
-pub(crate) struct FormatCssIfTestBooleanAndExpr;
-
-impl FormatNodeRule<CssIfTestBooleanAndExpr> for FormatCssIfTestBooleanAndExpr {
-    fn fmt_fields(&self, node: &CssIfTestBooleanAndExpr, f: &mut CssFormatter) -> FormatResult<()> {
-        let CssIfTestBooleanAndExprFields {
-            left,
-            and_token,
-            right,
-        } = node.as_fields();
-
-        write!(
-            f,
-            [
-                left.format(),
-                space(),
-                and_token.format(),
-                space(),
-                right.format()
-            ]
-        )
-    }
-}
diff --git a/crates/biome_css_formatter/src/css/auxiliary/if_test_boolean_expr_in_parens.rs b/crates/biome_css_formatter/src/css/auxiliary/if_test_boolean_expr_in_parens.rs
deleted file mode 100644
index 0f133638e0..0000000000
--- a/crates/biome_css_formatter/src/css/auxiliary/if_test_boolean_expr_in_parens.rs
+++ /dev/null
@@ -1,29 +0,0 @@
-use crate::prelude::*;
-use biome_css_syntax::{CssIfTestBooleanExprInParens, CssIfTestBooleanExprInParensFields};
-use biome_formatter::write;
-
-#[derive(Debug, Clone, Default)]
-pub(crate) struct FormatCssIfTestBooleanExprInParens;
-
-impl FormatNodeRule<CssIfTestBooleanExprInParens> for FormatCssIfTestBooleanExprInParens {
-    fn fmt_fields(
-        &self,
-        node: &CssIfTestBooleanExprInParens,
-        f: &mut CssFormatter,
-    ) -> FormatResult<()> {
-        let CssIfTestBooleanExprInParensFields {
-            l_paren_token,
-            expression,
-            r_paren_token,
-        } = node.as_fields();
-
-        write!(
-            f,
-            [
-                l_paren_token.format(),
-                soft_block_indent(&expression.format()),
-                r_paren_token.format()
-            ]
-        )
-    }
-}
diff --git a/crates/biome_css_formatter/src/css/auxiliary/if_test_boolean_not_expr.rs b/crates/biome_css_formatter/src/css/auxiliary/if_test_boolean_not_expr.rs
deleted file mode 100644
index 0b939c6d81..0000000000
--- a/crates/biome_css_formatter/src/css/auxiliary/if_test_boolean_not_expr.rs
+++ /dev/null
@@ -1,17 +0,0 @@
-use crate::prelude::*;
-use biome_css_syntax::{CssIfTestBooleanNotExpr, CssIfTestBooleanNotExprFields};
-use biome_formatter::write;
-
-#[derive(Debug, Clone, Default)]
-pub(crate) struct FormatCssIfTestBooleanNotExpr;
-
-impl FormatNodeRule<CssIfTestBooleanNotExpr> for FormatCssIfTestBooleanNotExpr {
-    fn fmt_fields(&self, node: &CssIfTestBooleanNotExpr, f: &mut CssFormatter) -> FormatResult<()> {
-        let CssIfTestBooleanNotExprFields {
-            not_token,
-            expression,
-        } = node.as_fields();
-
-        write!(f, [not_token.format(), space(), expression.format()])
-    }
-}
diff --git a/crates/biome_css_formatter/src/css/auxiliary/if_test_boolean_or_expr.rs b/crates/biome_css_formatter/src/css/auxiliary/if_test_boolean_or_expr.rs
deleted file mode 100644
index f9eba8a7ec..0000000000
--- a/crates/biome_css_formatter/src/css/auxiliary/if_test_boolean_or_expr.rs
+++ /dev/null
@@ -1,27 +0,0 @@
-use crate::prelude::*;
-use biome_css_syntax::{CssIfTestBooleanOrExpr, CssIfTestBooleanOrExprFields};
-use biome_formatter::write;
-
-#[derive(Debug, Clone, Default)]
-pub(crate) struct FormatCssIfTestBooleanOrExpr;
-
-impl FormatNodeRule<CssIfTestBooleanOrExpr> for FormatCssIfTestBooleanOrExpr {
-    fn fmt_fields(&self, node: &CssIfTestBooleanOrExpr, f: &mut CssFormatter) -> FormatResult<()> {
-        let CssIfTestBooleanOrExprFields {
-            left,
-            or_token,
-            right,
-        } = node.as_fields();
-
-        write!(
-            f,
-            [
-                left.format(),
-                space(),
-                or_token.format(),
-                space(),
-                right.format()
-            ]
-        )
-    }
-}
diff --git a/crates/biome_css_formatter/src/css/auxiliary/mod.rs b/crates/biome_css_formatter/src/css/auxiliary/mod.rs
index e5d5bf2652..385be82907 100644
--- a/crates/biome_css_formatter/src/css/auxiliary/mod.rs
+++ b/crates/biome_css_formatter/src/css/auxiliary/mod.rs
@@ -28,7 +28,6 @@ pub(crate) mod declaration_or_at_rule_block;
 pub(crate) mod declaration_or_rule_block;
 pub(crate) mod declaration_with_semicolon;
 pub(crate) mod document_custom_matcher;
-pub(crate) mod else_keyword;
 pub(crate) mod empty_declaration;
 pub(crate) mod font_face_at_rule_declarator;
 pub(crate) mod font_family_name;
@@ -37,16 +36,6 @@ pub(crate) mod font_feature_values_item;
 pub(crate) mod font_palette_values_at_rule_declarator;
 pub(crate) mod function;
 pub(crate) mod generic_delimiter;
-pub(crate) mod if_branch;
-pub(crate) mod if_function;
-pub(crate) mod if_media_test;
-pub(crate) mod if_style_test;
-pub(crate) mod if_supports_identifier_test;
-pub(crate) mod if_supports_test;
-pub(crate) mod if_test_boolean_and_expr;
-pub(crate) mod if_test_boolean_expr_in_parens;
-pub(crate) mod if_test_boolean_not_expr;
-pub(crate) mod if_test_boolean_or_expr;
 pub(crate) mod import_anonymous_layer;
 pub(crate) mod import_named_layer;
 pub(crate) mod import_supports;
diff --git a/crates/biome_css_formatter/src/css/bogus/bogus_if_branch.rs b/crates/biome_css_formatter/src/css/bogus/bogus_if_branch.rs
deleted file mode 100644
index 3274d9ec74..0000000000
--- a/crates/biome_css_formatter/src/css/bogus/bogus_if_branch.rs
+++ /dev/null
@@ -1,5 +0,0 @@
-use crate::FormatBogusNodeRule;
-use biome_css_syntax::CssBogusIfBranch;
-#[derive(Debug, Clone, Default)]
-pub(crate) struct FormatCssBogusIfBranch;
-impl FormatBogusNodeRule<CssBogusIfBranch> for FormatCssBogusIfBranch {}
diff --git a/crates/biome_css_formatter/src/css/bogus/mod.rs b/crates/biome_css_formatter/src/css/bogus/mod.rs
index ae15e39790..4c8ce5d53b 100644
--- a/crates/biome_css_formatter/src/css/bogus/mod.rs
+++ b/crates/biome_css_formatter/src/css/bogus/mod.rs
@@ -9,8 +9,6 @@ pub(crate) mod bogus_declaration_item;
 pub(crate) mod bogus_document_matcher;
 pub(crate) mod bogus_font_family_name;
 pub(crate) mod bogus_font_feature_values_item;
-pub(crate) mod bogus_if_branch;
-pub(crate) mod bogus_if_test;
 pub(crate) mod bogus_keyframes_item;
 pub(crate) mod bogus_keyframes_name;
 pub(crate) mod bogus_layer;
diff --git a/crates/biome_css_formatter/src/css/lists/if_branch_list.rs b/crates/biome_css_formatter/src/css/lists/if_branch_list.rs
deleted file mode 100644
index e55460ac7a..0000000000
--- a/crates/biome_css_formatter/src/css/lists/if_branch_list.rs
+++ /dev/null
@@ -1,18 +0,0 @@
-use crate::prelude::*;
-use biome_css_syntax::CssIfBranchList;
-use biome_formatter::separated::TrailingSeparator;
-
-#[derive(Debug, Clone, Default)]
-pub(crate) struct FormatCssIfBranchList;
-
-impl FormatRule<CssIfBranchList> for FormatCssIfBranchList {
-    type Context = CssFormatContext;
-    fn fmt(&self, node: &CssIfBranchList, f: &mut CssFormatter) -> FormatResult<()> {
-        f.join_with(&soft_line_break_or_space())
-            .entries(
-                node.format_separated(";")
-                    .with_trailing_separator(TrailingSeparator::Allowed),
-            )
-            .finish()
-    }
-}
diff --git a/crates/biome_css_formatter/src/css/lists/mod.rs b/crates/biome_css_formatter/src/css/lists/mod.rs
index bc653be362..bd4e7afbf1 100644
--- a/crates/biome_css_formatter/src/css/lists/mod.rs
+++ b/crates/biome_css_formatter/src/css/lists/mod.rs
@@ -12,7 +12,6 @@ pub(crate) mod document_matcher_list;
 pub(crate) mod font_family_name_list;
 pub(crate) mod font_feature_values_item_list;
 pub(crate) mod generic_component_value_list;
-pub(crate) mod if_branch_list;
 pub(crate) mod keyframes_item_list;
 pub(crate) mod keyframes_selector_list;
 pub(crate) mod layer_name_list;
diff --git a/crates/biome_css_formatter/src/generated.rs b/crates/biome_css_formatter/src/generated.rs
index 03da6f7f5d..773c9a6b3b 100644
--- a/crates/biome_css_formatter/src/generated.rs
+++ b/crates/biome_css_formatter/src/generated.rs
@@ -1437,44 +1437,6 @@ impl IntoFormat<CssFormatContext> for biome_css_syntax::CssDocumentCustomMatcher
         )
     }
 }
-impl FormatRule<biome_css_syntax::CssElseKeyword>
-    for crate::css::auxiliary::else_keyword::FormatCssElseKeyword
-{
-    type Context = CssFormatContext;
-    #[inline(always)]
-    fn fmt(
-        &self,
-        node: &biome_css_syntax::CssElseKeyword,
-        f: &mut CssFormatter,
-    ) -> FormatResult<()> {
-        FormatNodeRule::<biome_css_syntax::CssElseKeyword>::fmt(self, node, f)
-    }
-}
-impl AsFormat<CssFormatContext> for biome_css_syntax::CssElseKeyword {
-    type Format<'a> = FormatRefWithRule<
-        'a,
-        biome_css_syntax::CssElseKeyword,
-        crate::css::auxiliary::else_keyword::FormatCssElseKeyword,
-    >;
-    fn format(&self) -> Self::Format<'_> {
-        FormatRefWithRule::new(
-            self,
-            crate::css::auxiliary::else_keyword::FormatCssElseKeyword::default(),
-        )
-    }
-}
-impl IntoFormat<CssFormatContext> for biome_css_syntax::CssElseKeyword {
-    type Format = FormatOwnedWithRule<
-        biome_css_syntax::CssElseKeyword,
-        crate::css::auxiliary::else_keyword::FormatCssElseKeyword,
-    >;
-    fn into_format(self) -> Self::Format {
-        FormatOwnedWithRule::new(
-            self,
-            crate::css::auxiliary::else_keyword::FormatCssElseKeyword::default(),
-        )
-    }
-}
 impl FormatRule<biome_css_syntax::CssEmptyDeclaration>
     for crate::css::auxiliary::empty_declaration::FormatCssEmptyDeclaration
 {
@@ -1948,374 +1910,6 @@ impl IntoFormat<CssFormatContext> for biome_css_syntax::CssIdentifier {
         )
     }
 }
-impl FormatRule<biome_css_syntax::CssIfBranch>
-    for crate::css::auxiliary::if_branch::FormatCssIfBranch
-{
-    type Context = CssFormatContext;
-    #[inline(always)]
-    fn fmt(&self, node: &biome_css_syntax::CssIfBranch, f: &mut CssFormatter) -> FormatResult<()> {
-        FormatNodeRule::<biome_css_syntax::CssIfBranch>::fmt(self, node, f)
-    }
-}
-impl AsFormat<CssFormatContext> for biome_css_syntax::CssIfBranch {
-    type Format<'a> = FormatRefWithRule<
-        'a,
-        biome_css_syntax::CssIfBranch,
-        crate::css::auxiliary::if_branch::FormatCssIfBranch,
-    >;
-    fn format(&self) -> Self::Format<'_> {
-        FormatRefWithRule::new(
-            self,
-            crate::css::auxiliary::if_branch::FormatCssIfBranch::default(),
-        )
-    }
-}
-impl IntoFormat<CssFormatContext> for biome_css_syntax::CssIfBranch {
-    type Format = FormatOwnedWithRule<
-        biome_css_syntax::CssIfBranch,
-        crate::css::auxiliary::if_branch::FormatCssIfBranch,
-    >;
-    fn into_format(self) -> Self::Format {
-        FormatOwnedWithRule::new(
-            self,
-            crate::css::auxiliary::if_branch::FormatCssIfBranch::default(),
-        )
-    }
-}
-impl FormatRule<biome_css_syntax::CssIfFunction>
-    for crate::css::auxiliary::if_function::FormatCssIfFunction
-{
-    type Context = CssFormatContext;
-    #[inline(always)]
-    fn fmt(
-        &self,
-        node: &biome_css_syntax::CssIfFunction,
-        f: &mut CssFormatter,
-    ) -> FormatResult<()> {
-        FormatNodeRule::<biome_css_syntax::CssIfFunction>::fmt(self, node, f)
-    }
-}
-impl AsFormat<CssFormatContext> for biome_css_syntax::CssIfFunction {
-    type Format<'a> = FormatRefWithRule<
-        'a,
-        biome_css_syntax::CssIfFunction,
-        crate::css::auxiliary::if_function::FormatCssIfFunction,
-    >;
-    fn format(&self) -> Self::Format<'_> {
-        FormatRefWithRule::new(
-            self,
-            crate::css::auxiliary::if_function::FormatCssIfFunction::default(),
-        )
-    }
-}
-impl IntoFormat<CssFormatContext> for biome_css_syntax::CssIfFunction {
-    type Format = FormatOwnedWithRule<
-        biome_css_syntax::CssIfFunction,
-        crate::css::auxiliary::if_function::FormatCssIfFunction,
-    >;
-    fn into_format(self) -> Self::Format {
-        FormatOwnedWithRule::new(
-            self,
-            crate::css::auxiliary::if_function::FormatCssIfFunction::default(),
-        )
-    }
-}
-impl FormatRule<biome_css_syntax::CssIfMediaTest>
-    for crate::css::auxiliary::if_media_test::FormatCssIfMediaTest
-{
-    type Context = CssFormatContext;
-    #[inline(always)]
-    fn fmt(
-        &self,
-        node: &biome_css_syntax::CssIfMediaTest,
-        f: &mut CssFormatter,
-    ) -> FormatResult<()> {
-        FormatNodeRule::<biome_css_syntax::CssIfMediaTest>::fmt(self, node, f)
-    }
-}
-impl AsFormat<CssFormatContext> for biome_css_syntax::CssIfMediaTest {
-    type Format<'a> = FormatRefWithRule<
-        'a,
-        biome_css_syntax::CssIfMediaTest,
-        crate::css::auxiliary::if_media_test::FormatCssIfMediaTest,
-    >;
-    fn format(&self) -> Self::Format<'_> {
-        FormatRefWithRule::new(
-            self,
-            crate::css::auxiliary::if_media_test::FormatCssIfMediaTest::default(),
-        )
-    }
-}
-impl IntoFormat<CssFormatContext> for biome_css_syntax::CssIfMediaTest {
-    type Format = FormatOwnedWithRule<
-        biome_css_syntax::CssIfMediaTest,
-        crate::css::auxiliary::if_media_test::FormatCssIfMediaTest,
-    >;
-    fn into_format(self) -> Self::Format {
-        FormatOwnedWithRule::new(
-            self,
-            crate::css::auxiliary::if_media_test::FormatCssIfMediaTest::default(),
-        )
-    }
-}
-impl FormatRule<biome_css_syntax::CssIfStyleTest>
-    for crate::css::auxiliary::if_style_test::FormatCssIfStyleTest
-{
-    type Context = CssFormatContext;
-    #[inline(always)]
-    fn fmt(
-        &self,
-        node: &biome_css_syntax::CssIfStyleTest,
-        f: &mut CssFormatter,
-    ) -> FormatResult<()> {
-        FormatNodeRule::<biome_css_syntax::CssIfStyleTest>::fmt(self, node, f)
-    }
-}
-impl AsFormat<CssFormatContext> for biome_css_syntax::CssIfStyleTest {
-    type Format<'a> = FormatRefWithRule<
-        'a,
-        biome_css_syntax::CssIfStyleTest,
-        crate::css::auxiliary::if_style_test::FormatCssIfStyleTest,
-    >;
-    fn format(&self) -> Self::Format<'_> {
-        FormatRefWithRule::new(
-            self,
-            crate::css::auxiliary::if_style_test::FormatCssIfStyleTest::default(),
-        )
-    }
-}
-impl IntoFormat<CssFormatContext> for biome_css_syntax::CssIfStyleTest {
-    type Format = FormatOwnedWithRule<
-        biome_css_syntax::CssIfStyleTest,
-        crate::css::auxiliary::if_style_test::FormatCssIfStyleTest,
-    >;
-    fn into_format(self) -> Self::Format {
-        FormatOwnedWithRule::new(
-            self,
-            crate::css::auxiliary::if_style_test::FormatCssIfStyleTest::default(),
-        )
-    }
-}
-impl FormatRule<biome_css_syntax::CssIfSupportsIdentifierTest>
-    for crate::css::auxiliary::if_supports_identifier_test::FormatCssIfSupportsIdentifierTest
-{
-    type Context = CssFormatContext;
-    #[inline(always)]
-    fn fmt(
-        &self,
-        node: &biome_css_syntax::CssIfSupportsIdentifierTest,
-        f: &mut CssFormatter,
-    ) -> FormatResult<()> {
-        FormatNodeRule::<biome_css_syntax::CssIfSupportsIdentifierTest>::fmt(self, node, f)
-    }
-}
-impl AsFormat<CssFormatContext> for biome_css_syntax::CssIfSupportsIdentifierTest {
-    type Format<'a> = FormatRefWithRule<
-        'a,
-        biome_css_syntax::CssIfSupportsIdentifierTest,
-        crate::css::auxiliary::if_supports_identifier_test::FormatCssIfSupportsIdentifierTest,
-    >;
-    fn format(&self) -> Self::Format<'_> {
-        FormatRefWithRule :: new (self , crate :: css :: auxiliary :: if_supports_identifier_test :: FormatCssIfSupportsIdentifierTest :: default ())
-    }
-}
-impl IntoFormat<CssFormatContext> for biome_css_syntax::CssIfSupportsIdentifierTest {
-    type Format = FormatOwnedWithRule<
-        biome_css_syntax::CssIfSupportsIdentifierTest,
-        crate::css::auxiliary::if_supports_identifier_test::FormatCssIfSupportsIdentifierTest,
-    >;
-    fn into_format(self) -> Self::Format {
-        FormatOwnedWithRule :: new (self , crate :: css :: auxiliary :: if_supports_identifier_test :: FormatCssIfSupportsIdentifierTest :: default ())
-    }
-}
-impl FormatRule<biome_css_syntax::CssIfSupportsTest>
-    for crate::css::auxiliary::if_supports_test::FormatCssIfSupportsTest
-{
-    type Context = CssFormatContext;
-    #[inline(always)]
-    fn fmt(
-        &self,
-        node: &biome_css_syntax::CssIfSupportsTest,
-        f: &mut CssFormatter,
-    ) -> FormatResult<()> {
-        FormatNodeRule::<biome_css_syntax::CssIfSupportsTest>::fmt(self, node, f)
-    }
-}
-impl AsFormat<CssFormatContext> for biome_css_syntax::CssIfSupportsTest {
-    type Format<'a> = FormatRefWithRule<
-        'a,
-        biome_css_syntax::CssIfSupportsTest,
-        crate::css::auxiliary::if_supports_test::FormatCssIfSupportsTest,
-    >;
-    fn format(&self) -> Self::Format<'_> {
-        FormatRefWithRule::new(
-            self,
-            crate::css::auxiliary::if_supports_test::FormatCssIfSupportsTest::default(),
-        )
-    }
-}
-impl IntoFormat<CssFormatContext> for biome_css_syntax::CssIfSupportsTest {
-    type Format = FormatOwnedWithRule<
-        biome_css_syntax::CssIfSupportsTest,
-        crate::css::auxiliary::if_supports_test::FormatCssIfSupportsTest,
-    >;
-    fn into_format(self) -> Self::Format {
-        FormatOwnedWithRule::new(
-            self,
-            crate::css::auxiliary::if_supports_test::FormatCssIfSupportsTest::default(),
-        )
-    }
-}
-impl FormatRule<biome_css_syntax::CssIfTestBooleanAndExpr>
-    for crate::css::auxiliary::if_test_boolean_and_expr::FormatCssIfTestBooleanAndExpr
-{
-    type Context = CssFormatContext;
-    #[inline(always)]
-    fn fmt(
-        &self,
-        node: &biome_css_syntax::CssIfTestBooleanAndExpr,
-        f: &mut CssFormatter,
-    ) -> FormatResult<()> {
-        FormatNodeRule::<biome_css_syntax::CssIfTestBooleanAndExpr>::fmt(self, node, f)
-    }
-}
-impl AsFormat<CssFormatContext> for biome_css_syntax::CssIfTestBooleanAndExpr {
-    type Format<'a> = FormatRefWithRule<
-        'a,
-        biome_css_syntax::CssIfTestBooleanAndExpr,
-        crate::css::auxiliary::if_test_boolean_and_expr::FormatCssIfTestBooleanAndExpr,
-    >;
-    fn format(&self) -> Self::Format<'_> {
-        FormatRefWithRule::new(
-            self,
-            crate::css::auxiliary::if_test_boolean_and_expr::FormatCssIfTestBooleanAndExpr::default(
-            ),
-        )
-    }
-}
-impl IntoFormat<CssFormatContext> for biome_css_syntax::CssIfTestBooleanAndExpr {
-    type Format = FormatOwnedWithRule<
-        biome_css_syntax::CssIfTestBooleanAndExpr,
-        crate::css::auxiliary::if_test_boolean_and_expr::FormatCssIfTestBooleanAndExpr,
-    >;
-    fn into_format(self) -> Self::Format {
-        FormatOwnedWithRule::new(
-            self,
-            crate::css::auxiliary::if_test_boolean_and_expr::FormatCssIfTestBooleanAndExpr::default(
-            ),
-        )
-    }
-}
-impl FormatRule<biome_css_syntax::CssIfTestBooleanExprInParens>
-    for crate::css::auxiliary::if_test_boolean_expr_in_parens::FormatCssIfTestBooleanExprInParens
-{
-    type Context = CssFormatContext;
-    #[inline(always)]
-    fn fmt(
-        &self,
-        node: &biome_css_syntax::CssIfTestBooleanExprInParens,
-        f: &mut CssFormatter,
-    ) -> FormatResult<()> {
-        FormatNodeRule::<biome_css_syntax::CssIfTestBooleanExprInParens>::fmt(self, node, f)
-    }
-}
-impl AsFormat<CssFormatContext> for biome_css_syntax::CssIfTestBooleanExprInParens {
-    type Format<'a> = FormatRefWithRule<
-        'a,
-        biome_css_syntax::CssIfTestBooleanExprInParens,
-        crate::css::auxiliary::if_test_boolean_expr_in_parens::FormatCssIfTestBooleanExprInParens,
-    >;
-    fn format(&self) -> Self::Format<'_> {
-        FormatRefWithRule :: new (self , crate :: css :: auxiliary :: if_test_boolean_expr_in_parens :: FormatCssIfTestBooleanExprInParens :: default ())
-    }
-}
-impl IntoFormat<CssFormatContext> for biome_css_syntax::CssIfTestBooleanExprInParens {
-    type Format = FormatOwnedWithRule<
-        biome_css_syntax::CssIfTestBooleanExprInParens,
-        crate::css::auxiliary::if_test_boolean_expr_in_parens::FormatCssIfTestBooleanExprInParens,
-    >;
-    fn into_format(self) -> Self::Format {
-        FormatOwnedWithRule :: new (self , crate :: css :: auxiliary :: if_test_boolean_expr_in_parens :: FormatCssIfTestBooleanExprInParens :: default ())
-    }
-}
-impl FormatRule<biome_css_syntax::CssIfTestBooleanNotExpr>
-    for crate::css::auxiliary::if_test_boolean_not_expr::FormatCssIfTestBooleanNotExpr
-{
-    type Context = CssFormatContext;
-    #[inline(always)]
-    fn fmt(
-        &self,
-        node: &biome_css_syntax::CssIfTestBooleanNotExpr,
-        f: &mut CssFormatter,
-    ) -> FormatResult<()> {
-        FormatNodeRule::<biome_css_syntax::CssIfTestBooleanNotExpr>::fmt(self, node, f)
-    }
-}
-impl AsFormat<CssFormatContext> for biome_css_syntax::CssIfTestBooleanNotExpr {
-    type Format<'a> = FormatRefWithRule<
-        'a,
-        biome_css_syntax::CssIfTestBooleanNotExpr,
-        crate::css::auxiliary::if_test_boolean_not_expr::FormatCssIfTestBooleanNotExpr,
-    >;
-    fn format(&self) -> Self::Format<'_> {
-        FormatRefWithRule::new(
-            self,
-            crate::css::auxiliary::if_test_boolean_not_expr::FormatCssIfTestBooleanNotExpr::default(
-            ),
-        )
-    }
-}
-impl IntoFormat<CssFormatContext> for biome_css_syntax::CssIfTestBooleanNotExpr {
-    type Format = FormatOwnedWithRule<
-        biome_css_syntax::CssIfTestBooleanNotExpr,
-        crate::css::auxiliary::if_test_boolean_not_expr::FormatCssIfTestBooleanNotExpr,
-    >;
-    fn into_format(self) -> Self::Format {
-        FormatOwnedWithRule::new(
-            self,
-            crate::css::auxiliary::if_test_boolean_not_expr::FormatCssIfTestBooleanNotExpr::default(
-            ),
-        )
-    }
-}
-impl FormatRule<biome_css_syntax::CssIfTestBooleanOrExpr>
-    for crate::css::auxiliary::if_test_boolean_or_expr::FormatCssIfTestBooleanOrExpr
-{
-    type Context = CssFormatContext;
-    #[inline(always)]
-    fn fmt(
-        &self,
-        node: &biome_css_syntax::CssIfTestBooleanOrExpr,
-        f: &mut CssFormatter,
-    ) -> FormatResult<()> {
-        FormatNodeRule::<biome_css_syntax::CssIfTestBooleanOrExpr>::fmt(self, node, f)
-    }
-}
-impl AsFormat<CssFormatContext> for biome_css_syntax::CssIfTestBooleanOrExpr {
-    type Format<'a> = FormatRefWithRule<
-        'a,
-        biome_css_syntax::CssIfTestBooleanOrExpr,
-        crate::css::auxiliary::if_test_boolean_or_expr::FormatCssIfTestBooleanOrExpr,
-    >;
-    fn format(&self) -> Self::Format<'_> {
-        FormatRefWithRule::new(
-            self,
-            crate::css::auxiliary::if_test_boolean_or_expr::FormatCssIfTestBooleanOrExpr::default(),
-        )
-    }
-}
-impl IntoFormat<CssFormatContext> for biome_css_syntax::CssIfTestBooleanOrExpr {
-    type Format = FormatOwnedWithRule<
-        biome_css_syntax::CssIfTestBooleanOrExpr,
-        crate::css::auxiliary::if_test_boolean_or_expr::FormatCssIfTestBooleanOrExpr,
-    >;
-    fn into_format(self) -> Self::Format {
-        FormatOwnedWithRule::new(
-            self,
-            crate::css::auxiliary::if_test_boolean_or_expr::FormatCssIfTestBooleanOrExpr::default(),
-        )
-    }
-}
 impl FormatRule<biome_css_syntax::CssImportAnonymousLayer>
     for crate::css::auxiliary::import_anonymous_layer::FormatCssImportAnonymousLayer
 {
@@ -7022,31 +6616,6 @@ impl IntoFormat<CssFormatContext> for biome_css_syntax::CssGenericComponentValue
         FormatOwnedWithRule :: new (self , crate :: css :: lists :: generic_component_value_list :: FormatCssGenericComponentValueList :: default ())
     }
 }
-impl AsFormat<CssFormatContext> for biome_css_syntax::CssIfBranchList {
-    type Format<'a> = FormatRefWithRule<
-        'a,
-        biome_css_syntax::CssIfBranchList,
-        crate::css::lists::if_branch_list::FormatCssIfBranchList,
-    >;
-    fn format(&self) -> Self::Format<'_> {
-        FormatRefWithRule::new(
-            self,
-            crate::css::lists::if_branch_list::FormatCssIfBranchList::default(),
-        )
-    }
-}
-impl IntoFormat<CssFormatContext> for biome_css_syntax::CssIfBranchList {
-    type Format = FormatOwnedWithRule<
-        biome_css_syntax::CssIfBranchList,
-        crate::css::lists::if_branch_list::FormatCssIfBranchList,
-    >;
-    fn into_format(self) -> Self::Format {
-        FormatOwnedWithRule::new(
-            self,
-            crate::css::lists::if_branch_list::FormatCssIfBranchList::default(),
-        )
-    }
-}
 impl AsFormat<CssFormatContext> for biome_css_syntax::CssKeyframesItemList {
     type Format<'a> = FormatRefWithRule<
         'a,
@@ -7798,82 +7367,6 @@ impl IntoFormat<CssFormatContext> for biome_css_syntax::CssBogusFontFeatureValue
         FormatOwnedWithRule :: new (self , crate :: css :: bogus :: bogus_font_feature_values_item :: FormatCssBogusFontFeatureValuesItem :: default ())
     }
 }
-impl FormatRule<biome_css_syntax::CssBogusIfBranch>
-    for crate::css::bogus::bogus_if_branch::FormatCssBogusIfBranch
-{
-    type Context = CssFormatContext;
-    #[inline(always)]
-    fn fmt(
-        &self,
-        node: &biome_css_syntax::CssBogusIfBranch,
-        f: &mut CssFormatter,
-    ) -> FormatResult<()> {
-        FormatBogusNodeRule::<biome_css_syntax::CssBogusIfBranch>::fmt(self, node, f)
-    }
-}
-impl AsFormat<CssFormatContext> for biome_css_syntax::CssBogusIfBranch {
-    type Format<'a> = FormatRefWithRule<
-        'a,
-        biome_css_syntax::CssBogusIfBranch,
-        crate::css::bogus::bogus_if_branch::FormatCssBogusIfBranch,
-    >;
-    fn format(&self) -> Self::Format<'_> {
-        FormatRefWithRule::new(
-            self,
-            crate::css::bogus::bogus_if_branch::FormatCssBogusIfBranch::default(),
-        )
-    }
-}
-impl IntoFormat<CssFormatContext> for biome_css_syntax::CssBogusIfBranch {
-    type Format = FormatOwnedWithRule<
-        biome_css_syntax::CssBogusIfBranch,
-        crate::css::bogus::bogus_if_branch::FormatCssBogusIfBranch,
-    >;
-    fn into_format(self) -> Self::Format {
-        FormatOwnedWithRule::new(
-            self,
-            crate::css::bogus::bogus_if_branch::FormatCssBogusIfBranch::default(),
-        )
-    }
-}
-impl FormatRule<biome_css_syntax::CssBogusIfTest>
-    for crate::css::bogus::bogus_if_test::FormatCssBogusIfTest
-{
-    type Context = CssFormatContext;
-    #[inline(always)]
-    fn fmt(
-        &self,
-        node: &biome_css_syntax::CssBogusIfTest,
-        f: &mut CssFormatter,
-    ) -> FormatResult<()> {
-        FormatBogusNodeRule::<biome_css_syntax::CssBogusIfTest>::fmt(self, node, f)
-    }
-}
-impl AsFormat<CssFormatContext> for biome_css_syntax::CssBogusIfTest {
-    type Format<'a> = FormatRefWithRule<
-        'a,
-        biome_css_syntax::CssBogusIfTest,
-        crate::css::bogus::bogus_if_test::FormatCssBogusIfTest,
-    >;
-    fn format(&self) -> Self::Format<'_> {
-        FormatRefWithRule::new(
-            self,
-            crate::css::bogus::bogus_if_test::FormatCssBogusIfTest::default(),
-        )
-    }
-}
-impl IntoFormat<CssFormatContext> for biome_css_syntax::CssBogusIfTest {
-    type Format = FormatOwnedWithRule<
-        biome_css_syntax::CssBogusIfTest,
-        crate::css::bogus::bogus_if_test::FormatCssBogusIfTest,
-    >;
-    fn into_format(self) -> Self::Format {
-        FormatOwnedWithRule::new(
-            self,
-            crate::css::bogus::bogus_if_test::FormatCssBogusIfTest::default(),
-        )
-    }
-}
 impl FormatRule<biome_css_syntax::CssBogusKeyframesItem>
     for crate::css::bogus::bogus_keyframes_item::FormatCssBogusKeyframesItem
 {
@@ -9290,193 +8783,6 @@ impl IntoFormat<CssFormatContext> for biome_css_syntax::AnyCssGenericComponentVa
         )
     }
 }
-impl AsFormat<CssFormatContext> for biome_css_syntax::AnyCssIfBranch {
-    type Format<'a> = FormatRefWithRule<
-        'a,
-        biome_css_syntax::AnyCssIfBranch,
-        crate::css::any::if_branch::FormatAnyCssIfBranch,
-    >;
-    fn format(&self) -> Self::Format<'_> {
-        FormatRefWithRule::new(
-            self,
-            crate::css::any::if_branch::FormatAnyCssIfBranch::default(),
-        )
-    }
-}
-impl IntoFormat<CssFormatContext> for biome_css_syntax::AnyCssIfBranch {
-    type Format = FormatOwnedWithRule<
-        biome_css_syntax::AnyCssIfBranch,
-        crate::css::any::if_branch::FormatAnyCssIfBranch,
-    >;
-    fn into_format(self) -> Self::Format {
-        FormatOwnedWithRule::new(
-            self,
-            crate::css::any::if_branch::FormatAnyCssIfBranch::default(),
-        )
-    }
-}
-impl AsFormat<CssFormatContext> for biome_css_syntax::AnyCssIfCondition {
-    type Format<'a> = FormatRefWithRule<
-        'a,
-        biome_css_syntax::AnyCssIfCondition,
-        crate::css::any::if_condition::FormatAnyCssIfCondition,
-    >;
-    fn format(&self) -> Self::Format<'_> {
-        FormatRefWithRule::new(
-            self,
-            crate::css::any::if_condition::FormatAnyCssIfCondition::default(),
-        )
-    }
-}
-impl IntoFormat<CssFormatContext> for biome_css_syntax::AnyCssIfCondition {
-    type Format = FormatOwnedWithRule<
-        biome_css_syntax::AnyCssIfCondition,
-        crate::css::any::if_condition::FormatAnyCssIfCondition,
-    >;
-    fn into_format(self) -> Self::Format {
-        FormatOwnedWithRule::new(
-            self,
-            crate::css::any::if_condition::FormatAnyCssIfCondition::default(),
-        )
-    }
-}
-impl AsFormat<CssFormatContext> for biome_css_syntax::AnyCssIfMediaTestQuery {
-    type Format<'a> = FormatRefWithRule<
-        'a,
-        biome_css_syntax::AnyCssIfMediaTestQuery,
-        crate::css::any::if_media_test_query::FormatAnyCssIfMediaTestQuery,
-    >;
-    fn format(&self) -> Self::Format<'_> {
-        FormatRefWithRule::new(
-            self,
-            crate::css::any::if_media_test_query::FormatAnyCssIfMediaTestQuery::default(),
-        )
-    }
-}
-impl IntoFormat<CssFormatContext> for biome_css_syntax::AnyCssIfMediaTestQuery {
-    type Format = FormatOwnedWithRule<
-        biome_css_syntax::AnyCssIfMediaTestQuery,
-        crate::css::any::if_media_test_query::FormatAnyCssIfMediaTestQuery,
-    >;
-    fn into_format(self) -> Self::Format {
-        FormatOwnedWithRule::new(
-            self,
-            crate::css::any::if_media_test_query::FormatAnyCssIfMediaTestQuery::default(),
-        )
-    }
-}
-impl AsFormat<CssFormatContext> for biome_css_syntax::AnyCssIfSupportsTestCondition {
-    type Format<'a> = FormatRefWithRule<
-        'a,
-        biome_css_syntax::AnyCssIfSupportsTestCondition,
-        crate::css::any::if_supports_test_condition::FormatAnyCssIfSupportsTestCondition,
-    >;
-    fn format(&self) -> Self::Format<'_> {
-        FormatRefWithRule :: new (self , crate :: css :: any :: if_supports_test_condition :: FormatAnyCssIfSupportsTestCondition :: default ())
-    }
-}
-impl IntoFormat<CssFormatContext> for biome_css_syntax::AnyCssIfSupportsTestCondition {
-    type Format = FormatOwnedWithRule<
-        biome_css_syntax::AnyCssIfSupportsTestCondition,
-        crate::css::any::if_supports_test_condition::FormatAnyCssIfSupportsTestCondition,
-    >;
-    fn into_format(self) -> Self::Format {
-        FormatOwnedWithRule :: new (self , crate :: css :: any :: if_supports_test_condition :: FormatAnyCssIfSupportsTestCondition :: default ())
-    }
-}
-impl AsFormat<CssFormatContext> for biome_css_syntax::AnyCssIfTest {
-    type Format<'a> = FormatRefWithRule<
-        'a,
-        biome_css_syntax::AnyCssIfTest,
-        crate::css::any::if_test::FormatAnyCssIfTest,
-    >;
-    fn format(&self) -> Self::Format<'_> {
-        FormatRefWithRule::new(
-            self,
-            crate::css::any::if_test::FormatAnyCssIfTest::default(),
-        )
-    }
-}
-impl IntoFormat<CssFormatContext> for biome_css_syntax::AnyCssIfTest {
-    type Format = FormatOwnedWithRule<
-        biome_css_syntax::AnyCssIfTest,
-        crate::css::any::if_test::FormatAnyCssIfTest,
-    >;
-    fn into_format(self) -> Self::Format {
-        FormatOwnedWithRule::new(
-            self,
-            crate::css::any::if_test::FormatAnyCssIfTest::default(),
-        )
-    }
-}
-impl AsFormat<CssFormatContext> for biome_css_syntax::AnyCssIfTestBooleanAndCombinableExpr {
-    type Format < 'a > = FormatRefWithRule < 'a , biome_css_syntax :: AnyCssIfTestBooleanAndCombinableExpr , crate :: css :: any :: if_test_boolean_and_combinable_expr :: FormatAnyCssIfTestBooleanAndCombinableExpr > ;
-    fn format(&self) -> Self::Format<'_> {
-        FormatRefWithRule :: new (self , crate :: css :: any :: if_test_boolean_and_combinable_expr :: FormatAnyCssIfTestBooleanAndCombinableExpr :: default ())
-    }
-}
-impl IntoFormat<CssFormatContext> for biome_css_syntax::AnyCssIfTestBooleanAndCombinableExpr {
-    type Format = FormatOwnedWithRule < biome_css_syntax :: AnyCssIfTestBooleanAndCombinableExpr , crate :: css :: any :: if_test_boolean_and_combinable_expr :: FormatAnyCssIfTestBooleanAndCombinableExpr > ;
-    fn into_format(self) -> Self::Format {
-        FormatOwnedWithRule :: new (self , crate :: css :: any :: if_test_boolean_and_combinable_expr :: FormatAnyCssIfTestBooleanAndCombinableExpr :: default ())
-    }
-}
-impl AsFormat<CssFormatContext> for biome_css_syntax::AnyCssIfTestBooleanExpr {
-    type Format<'a> = FormatRefWithRule<
-        'a,
-        biome_css_syntax::AnyCssIfTestBooleanExpr,
-        crate::css::any::if_test_boolean_expr::FormatAnyCssIfTestBooleanExpr,
-    >;
-    fn format(&self) -> Self::Format<'_> {
-        FormatRefWithRule::new(
-            self,
-            crate::css::any::if_test_boolean_expr::FormatAnyCssIfTestBooleanExpr::default(),
-        )
-    }
-}
-impl IntoFormat<CssFormatContext> for biome_css_syntax::AnyCssIfTestBooleanExpr {
-    type Format = FormatOwnedWithRule<
-        biome_css_syntax::AnyCssIfTestBooleanExpr,
-        crate::css::any::if_test_boolean_expr::FormatAnyCssIfTestBooleanExpr,
-    >;
-    fn into_format(self) -> Self::Format {
-        FormatOwnedWithRule::new(
-            self,
-            crate::css::any::if_test_boolean_expr::FormatAnyCssIfTestBooleanExpr::default(),
-        )
-    }
-}
-impl AsFormat<CssFormatContext> for biome_css_syntax::AnyCssIfTestBooleanExprGroup {
-    type Format<'a> = FormatRefWithRule<
-        'a,
-        biome_css_syntax::AnyCssIfTestBooleanExprGroup,
-        crate::css::any::if_test_boolean_expr_group::FormatAnyCssIfTestBooleanExprGroup,
-    >;
-    fn format(&self) -> Self::Format<'_> {
-        FormatRefWithRule :: new (self , crate :: css :: any :: if_test_boolean_expr_group :: FormatAnyCssIfTestBooleanExprGroup :: default ())
-    }
-}
-impl IntoFormat<CssFormatContext> for biome_css_syntax::AnyCssIfTestBooleanExprGroup {
-    type Format = FormatOwnedWithRule<
-        biome_css_syntax::AnyCssIfTestBooleanExprGroup,
-        crate::css::any::if_test_boolean_expr_group::FormatAnyCssIfTestBooleanExprGroup,
-    >;
-    fn into_format(self) -> Self::Format {
-        FormatOwnedWithRule :: new (self , crate :: css :: any :: if_test_boolean_expr_group :: FormatAnyCssIfTestBooleanExprGroup :: default ())
-    }
-}
-impl AsFormat<CssFormatContext> for biome_css_syntax::AnyCssIfTestBooleanOrCombinableExpr {
-    type Format < 'a > = FormatRefWithRule < 'a , biome_css_syntax :: AnyCssIfTestBooleanOrCombinableExpr , crate :: css :: any :: if_test_boolean_or_combinable_expr :: FormatAnyCssIfTestBooleanOrCombinableExpr > ;
-    fn format(&self) -> Self::Format<'_> {
-        FormatRefWithRule :: new (self , crate :: css :: any :: if_test_boolean_or_combinable_expr :: FormatAnyCssIfTestBooleanOrCombinableExpr :: default ())
-    }
-}
-impl IntoFormat<CssFormatContext> for biome_css_syntax::AnyCssIfTestBooleanOrCombinableExpr {
-    type Format = FormatOwnedWithRule < biome_css_syntax :: AnyCssIfTestBooleanOrCombinableExpr , crate :: css :: any :: if_test_boolean_or_combinable_expr :: FormatAnyCssIfTestBooleanOrCombinableExpr > ;
-    fn into_format(self) -> Self::Format {
-        FormatOwnedWithRule :: new (self , crate :: css :: any :: if_test_boolean_or_combinable_expr :: FormatAnyCssIfTestBooleanOrCombinableExpr :: default ())
-    }
-}
 impl AsFormat<CssFormatContext> for biome_css_syntax::AnyCssImportLayer {
     type Format<'a> = FormatRefWithRule<
         'a,
diff --git a/crates/biome_css_parser/src/lexer/mod.rs b/crates/biome_css_parser/src/lexer/mod.rs
index 4f5d5b62f6..c0c04aa2e9 100644
--- a/crates/biome_css_parser/src/lexer/mod.rs
+++ b/crates/biome_css_parser/src/lexer/mod.rs
@@ -912,8 +912,6 @@ impl<'src> CssLexer<'src> {
             b"layer" => LAYER_KW,
             b"supports" => SUPPORTS_KW,
             b"selector" => SELECTOR_KW,
-            b"if" => IF_KW,
-            b"else" => ELSE_KW,
             b"url" => URL_KW,
             b"src" => SRC_KW,
             b"scope" => SCOPE_KW,
diff --git a/crates/biome_css_parser/src/syntax/at_rule/container/mod.rs b/crates/biome_css_parser/src/syntax/at_rule/container/mod.rs
index a548838072..ad33fa25c6 100644
--- a/crates/biome_css_parser/src/syntax/at_rule/container/mod.rs
+++ b/crates/biome_css_parser/src/syntax/at_rule/container/mod.rs
@@ -1,4 +1,4 @@
-pub(crate) mod error;
+mod error;
 
 use crate::lexer::CssLexContext;
 use crate::parser::CssParser;
@@ -226,7 +226,7 @@ fn parse_container_not_query(p: &mut CssParser) -> ParsedSyntax {
 }
 
 #[inline]
-pub(crate) fn parse_any_container_query_in_parens(p: &mut CssParser) -> ParsedSyntax {
+fn parse_any_container_query_in_parens(p: &mut CssParser) -> ParsedSyntax {
     if is_at_container_style_query_in_parens(p) {
         parse_container_style_query_in_parens(p)
     } else if is_at_container_query_in_parens(p) {
@@ -308,7 +308,7 @@ fn is_at_container_style_query_in_parens(p: &mut CssParser) -> bool {
 /// @container style(--my-prop: some-value) { }
 /// ```
 #[inline]
-pub(crate) fn parse_container_style_query_in_parens(p: &mut CssParser) -> ParsedSyntax {
+fn parse_container_style_query_in_parens(p: &mut CssParser) -> ParsedSyntax {
     if !is_at_container_style_query_in_parens(p) {
         return Absent;
     }
@@ -330,7 +330,7 @@ pub(crate) fn parse_container_style_query_in_parens(p: &mut CssParser) -> Parsed
 }
 
 #[inline]
-pub(crate) fn parse_any_container_style_query(p: &mut CssParser) -> ParsedSyntax {
+fn parse_any_container_style_query(p: &mut CssParser) -> ParsedSyntax {
     if is_at_declaration(p) {
         parse_declaration(p)
     } else if is_at_container_style_not_query(p) {
diff --git a/crates/biome_css_parser/src/syntax/at_rule/media.rs b/crates/biome_css_parser/src/syntax/at_rule/media.rs
index 6f10e8c88b..054f0e6922 100644
--- a/crates/biome_css_parser/src/syntax/at_rule/media.rs
+++ b/crates/biome_css_parser/src/syntax/at_rule/media.rs
@@ -106,12 +106,12 @@ fn parse_any_media_query(p: &mut CssParser) -> ParsedSyntax {
 }
 
 #[inline]
-pub(crate) fn is_at_any_media_condition(p: &mut CssParser) -> bool {
+fn is_at_any_media_condition(p: &mut CssParser) -> bool {
     is_at_media_not_condition(p) || is_at_any_media_in_parens(p)
 }
 
 #[inline]
-pub(crate) fn parse_any_media_condition(p: &mut CssParser) -> ParsedSyntax {
+fn parse_any_media_condition(p: &mut CssParser) -> ParsedSyntax {
     if !is_at_any_media_condition(p) {
         return Absent;
     }
@@ -259,7 +259,7 @@ fn is_at_any_media_in_parens(p: &mut CssParser) -> bool {
 }
 
 #[inline]
-pub(crate) fn parse_any_media_in_parens(p: &mut CssParser) -> ParsedSyntax {
+fn parse_any_media_in_parens(p: &mut CssParser) -> ParsedSyntax {
     if !is_at_any_media_in_parens(p) {
         return Absent;
     }
diff --git a/crates/biome_css_parser/src/syntax/at_rule/mod.rs b/crates/biome_css_parser/src/syntax/at_rule/mod.rs
index 963260396e..5d9aa52cde 100644
--- a/crates/biome_css_parser/src/syntax/at_rule/mod.rs
+++ b/crates/biome_css_parser/src/syntax/at_rule/mod.rs
@@ -1,17 +1,17 @@
 mod charset;
 mod color_profile;
-pub(crate) mod container;
+mod container;
 mod counter_style;
 mod document;
-pub(crate) mod error;
-pub(crate) mod feature;
+mod error;
+mod feature;
 mod font_face;
 mod font_feature_values;
 mod font_palette_values;
 mod import;
 mod keyframes;
 mod layer;
-pub(crate) mod media;
+mod media;
 mod namespace;
 mod page;
 mod parse_error;
@@ -19,7 +19,7 @@ mod position_try;
 mod property;
 mod scope;
 mod starting_style;
-pub(crate) mod supports;
+mod supports;
 mod tailwind;
 mod unknown;
 mod value;
diff --git a/crates/biome_css_parser/src/syntax/at_rule/supports/mod.rs b/crates/biome_css_parser/src/syntax/at_rule/supports/mod.rs
index 1012e04ae6..8cb76cf400 100644
--- a/crates/biome_css_parser/src/syntax/at_rule/supports/mod.rs
+++ b/crates/biome_css_parser/src/syntax/at_rule/supports/mod.rs
@@ -91,7 +91,7 @@ pub(crate) fn parse_supports_at_rule_declarator(p: &mut CssParser) -> ParsedSynt
     Present(m.complete(p, CSS_SUPPORTS_AT_RULE_DECLARATOR))
 }
 
-pub(crate) struct AnySupportsConditionParseRecovery;
+struct AnySupportsConditionParseRecovery;
 
 impl ParseRecovery for AnySupportsConditionParseRecovery {
     type Kind = CssSyntaxKind;
diff --git a/crates/biome_css_parser/src/syntax/property/mod.rs b/crates/biome_css_parser/src/syntax/property/mod.rs
index 0105e90f85..13e9718e0a 100644
--- a/crates/biome_css_parser/src/syntax/property/mod.rs
+++ b/crates/biome_css_parser/src/syntax/property/mod.rs
@@ -209,7 +209,7 @@ fn parse_generic_property(p: &mut CssParser) -> ParsedSyntax {
 }
 const END_OF_PROPERTY_VALUE_TOKEN_SET: TokenSet<CssSyntaxKind> = token_set!(T!['}'], T![;]);
 
-pub(crate) struct GenericComponentValueList;
+struct GenericComponentValueList;
 
 impl ParseNodeList for GenericComponentValueList {
     type Kind = CssSyntaxKind;
@@ -244,7 +244,7 @@ fn is_at_generic_component_value(p: &mut CssParser) -> bool {
 }
 
 #[inline]
-pub(crate) fn parse_generic_component_value(p: &mut CssParser) -> ParsedSyntax {
+fn parse_generic_component_value(p: &mut CssParser) -> ParsedSyntax {
     if !is_at_generic_component_value(p) {
         return Absent;
     }
diff --git a/crates/biome_css_parser/src/syntax/value/function.rs b/crates/biome_css_parser/src/syntax/value/function.rs
index ab180161e3..0c4a07da66 100644
--- a/crates/biome_css_parser/src/syntax/value/function.rs
+++ b/crates/biome_css_parser/src/syntax/value/function.rs
@@ -1,9 +1,7 @@
-use super::r#if::is_at_if_function;
 use super::parse_error::expected_expression;
 use super::url::{is_at_url_function, parse_url_function};
 use crate::parser::CssParser;
 use crate::syntax::parse_error::expected_declaration_item;
-use crate::syntax::value::r#if::parse_if_function;
 use crate::syntax::{
     CssComponentValueList, is_at_any_value, is_at_dashed_identifier, is_nth_at_identifier,
     parse_dashed_identifier, parse_regular_identifier,
@@ -22,7 +20,7 @@ use biome_parser::{Parser, TokenSet, token_set};
 /// It's used to quickly determine if the parser is positioned at a relevant function.
 #[inline]
 pub(crate) fn is_at_any_function(p: &mut CssParser) -> bool {
-    is_at_url_function(p) || is_at_if_function(p) || is_at_function(p)
+    is_at_url_function(p) || is_at_function(p)
 }
 
 /// Parses any recognized CSS function at the current position in the `CssParser`.
@@ -38,8 +36,6 @@ pub(crate) fn parse_any_function(p: &mut CssParser) -> ParsedSyntax {
 
     if is_at_url_function(p) {
         parse_url_function(p)
-    } else if is_at_if_function(p) {
-        parse_if_function(p)
     } else {
         parse_function(p)
     }
diff --git a/crates/biome_css_parser/src/syntax/value/if.rs b/crates/biome_css_parser/src/syntax/value/if.rs
deleted file mode 100644
index 4f79179939..0000000000
--- a/crates/biome_css_parser/src/syntax/value/if.rs
+++ /dev/null
@@ -1,474 +0,0 @@
-use biome_css_syntax::CssSyntaxKind;
-use biome_css_syntax::CssSyntaxKind::*;
-use biome_css_syntax::T;
-use biome_parser::Parser;
-use biome_parser::parse_lists::ParseNodeList;
-use biome_parser::parse_lists::ParseSeparatedList;
-use biome_parser::parse_recovery::ParseRecovery;
-use biome_parser::parse_recovery::RecoveryResult;
-use biome_parser::parsed_syntax::ParsedSyntax::{Absent, Present};
-use biome_parser::prelude::{CompletedMarker, ParsedSyntax};
-
-use crate::parser::CssParser;
-use crate::syntax::at_rule::container::error::expected_any_container_style_query;
-use crate::syntax::at_rule::container::parse_any_container_style_query;
-use crate::syntax::at_rule::error::AnyInParensParseRecovery;
-use crate::syntax::at_rule::feature::expected_any_query_feature;
-use crate::syntax::at_rule::feature::parse_any_query_feature;
-use crate::syntax::at_rule::media::is_at_any_media_condition;
-use crate::syntax::at_rule::media::parse_any_media_condition;
-use crate::syntax::at_rule::supports::AnySupportsConditionParseRecovery;
-use crate::syntax::at_rule::supports::error::expected_any_supports_condition;
-use crate::syntax::at_rule::supports::parse_any_supports_condition;
-use crate::syntax::is_at_declaration;
-use crate::syntax::parse_declaration;
-use crate::syntax::property::GenericComponentValueList;
-use crate::syntax::value::parse_error::expected_if_branch;
-use crate::syntax::value::parse_error::expected_if_test_boolean_expr_group;
-
-pub(crate) fn is_at_if_function(p: &mut CssParser) -> bool {
-    p.at(T![if])
-}
-
-/// Parses an if function from the current position of the CSS parser.
-///
-/// For more detailed information on the CSS if function syntax, refer to the
-/// [CSS Values and Units Module](https://drafts.csswg.org/css-values-5/#if-notation).
-///
-/// # If Function Syntax Examples
-///
-/// - Style if condition:
-///   ``` css
-///   if(style(--scheme: dark): #eeeeee;)
-///   ```
-///   Demonstrates a style if condition that checks if the --scheme variable is set to dark.
-///
-/// - Media if condition:
-///   ``` css
-///   if(media(print): white; else: black;)
-///   ```
-///   Demonstrates a media if condition that checks if the media query is active for print.
-///
-/// - Supports if condition:
-///   ``` css
-///   if(supports(color: lch(7.1% 60.23 300.16)): lch(7.1% 60.23 300.16);)
-///   ```
-///   Demonstrates a supports if condition that checks if lch color is supported.
-///
-/// - Else if condition:
-///   ``` css
-///   if(style(--size: "2xl"): 1em; else: 0.25em;)
-///   ```
-///   Demonstrates an else if condition that checks if the --size variable is set to "2xl".
-///
-/// - Multiple if conditions:
-///   ``` css
-///   if(
-///     style(--scheme: ice): linear-gradient(#caf0f8, white, #caf0f8);
-///     style(--scheme: fire): linear-gradient(#ffc971, white, #ffc971);
-///     else: none;
-///   )
-///   ```
-///  - If test with shortand:
-///  ``` css
-///  3px yellow if(
-///    style(--color: green): dashed;
-///    style(--color: yellow): inset;
-///    else: solid;
-///  )
-///  ```
-///
-/// # Grammar
-///
-/// ``` txt
-/// <if()> = if( [ <if-branch> ; ]* <if-branch> ;? )
-/// <if-branch> = <if-condition> : <declaration-value>?
-/// <if-condition> = <boolean-expr[ <if-test> ]> | else
-/// <if-test> =
-///   supports( [ <ident> : <declaration-value> ] | <supports-condition> ) |
-///   media( <media-feature> | <media-condition> ) |
-///   style( <style-query> )
-/// ```
-pub(crate) fn parse_if_function(p: &mut CssParser) -> ParsedSyntax {
-    if !is_at_if_function(p) {
-        return Absent;
-    }
-
-    let m = p.start();
-
-    p.bump(T![if]);
-    p.expect(T!['(']);
-
-    CssIfBranchList.parse_list(p);
-
-    p.expect(T![')']);
-
-    Present(m.complete(p, CSS_IF_FUNCTION))
-}
-
-#[inline]
-fn is_at_if_supports_test(p: &mut CssParser) -> bool {
-    p.at(T![supports]) && p.nth_at(1, T!['('])
-}
-
-/// Parses a supports if condition test.
-///
-/// # Example
-///
-/// ```css
-/// supports(color: lch(7.1% 60.23 300.16)
-/// ```
-#[inline]
-fn parse_if_supports_test(p: &mut CssParser) -> ParsedSyntax {
-    if !is_at_if_supports_test(p) {
-        return Absent;
-    }
-
-    let m = p.start();
-    p.bump(T![supports]);
-    p.bump(T!['(']);
-
-    if is_at_declaration(p) {
-        parse_declaration(p).ok();
-    } else {
-        parse_any_supports_condition(p)
-            .or_recover(
-                p,
-                &AnySupportsConditionParseRecovery,
-                expected_any_supports_condition,
-            )
-            .ok();
-    }
-
-    p.expect(T![')']);
-    Present(m.complete(p, CSS_IF_SUPPORTS_TEST))
-}
-
-#[inline]
-fn is_at_if_style_test(p: &mut CssParser) -> bool {
-    p.at(T![style]) && p.nth_at(1, T!['('])
-}
-
-/// Parses a style if condition test.
-///
-/// # Example
-///
-/// ``` css
-/// style(--scheme: dark)
-/// ```
-#[inline]
-fn parse_if_style_test(p: &mut CssParser) -> ParsedSyntax {
-    if !is_at_if_style_test(p) {
-        return Absent;
-    }
-
-    let m = p.start();
-
-    p.bump(T![style]);
-    p.bump(T!['(']);
-
-    parse_any_container_style_query(p)
-        .or_recover(
-            p,
-            &AnyInParensParseRecovery,
-            expected_any_container_style_query,
-        )
-        .ok();
-    p.expect(T![')']);
-
-    Present(m.complete(p, CSS_IF_STYLE_TEST))
-}
-
-#[inline]
-fn is_at_if_media_test(p: &mut CssParser) -> bool {
-    p.at(T![media]) && p.nth_at(1, T!['('])
-}
-
-/// Parses a media if condition test.
-///
-/// # Example
-///
-/// ``` css
-/// media(print)
-/// ```
-#[inline]
-fn parse_if_media_test(p: &mut CssParser) -> ParsedSyntax {
-    if !is_at_if_media_test(p) {
-        return Absent;
-    }
-
-    let m = p.start();
-
-    p.bump(T![media]);
-    p.bump(T!['(']);
-
-    if is_at_any_media_condition(p) {
-        parse_any_media_condition(p)
-            .or_recover(p, &AnyInParensParseRecovery, expected_any_query_feature)
-            .ok();
-    } else {
-        parse_any_query_feature(p)
-            .or_recover(p, &AnyInParensParseRecovery, expected_any_query_feature)
-            .ok();
-    }
-
-    p.expect(T![')']);
-
-    Present(m.complete(p, CSS_IF_MEDIA_TEST))
-}
-
-#[inline]
-fn parse_if_test(p: &mut CssParser) -> ParsedSyntax {
-    if is_at_if_supports_test(p) {
-        return parse_if_supports_test(p);
-    }
-
-    if is_at_if_style_test(p) {
-        return parse_if_style_test(p);
-    }
-
-    if is_at_if_media_test(p) {
-        return parse_if_media_test(p);
-    }
-
-    Absent
-}
-
-#[inline]
-fn parse_any_if_test_boolean_expr_group(p: &mut CssParser) -> ParsedSyntax {
-    // ( <boolean-expr> )
-    if p.at(T!['(']) {
-        let m = p.start();
-        p.bump(T!['(']);
-        parse_any_if_test_boolean_expr(p).ok();
-        p.expect(T![')']);
-        return Present(m.complete(p, CSS_IF_TEST_BOOLEAN_EXPR_IN_PARENS));
-    }
-
-    // <if-test>
-    parse_if_test(p)
-}
-
-fn is_at_if_test_boolean_not_expr(p: &mut CssParser) -> bool {
-    p.at(T![not])
-}
-
-/// Parses `not <boolean-expr-group>`
-///
-/// # Example
-///
-/// ``` css
-/// not style(--color: green)
-/// ```
-#[inline]
-fn parse_if_test_boolean_not_expr(p: &mut CssParser) -> ParsedSyntax {
-    if !is_at_if_test_boolean_not_expr(p) {
-        return Absent;
-    }
-
-    let m = p.start();
-
-    p.bump(T![not]);
-    parse_any_if_test_boolean_expr_group(p).ok();
-
-    Present(m.complete(p, CSS_IF_TEST_BOOLEAN_NOT_EXPR))
-}
-
-#[inline]
-fn is_at_if_test_boolean_and_expr(p: &mut CssParser) -> bool {
-    p.at(T![and])
-}
-
-/// Parses `<boolean-expr-group> and <boolean-expr-group>`
-///
-/// # Example
-///
-/// ``` css
-/// style(--color: green) and style(--color: yellow)
-/// ```
-#[inline]
-fn parse_if_test_boolean_and_expr(p: &mut CssParser, lhs: CompletedMarker) -> CompletedMarker {
-    if !is_at_if_test_boolean_and_expr(p) {
-        return lhs;
-    }
-
-    let m = lhs.precede(p);
-    p.bump(T![and]);
-
-    let recovery_result = parse_any_if_test_boolean_expr_group(p)
-        .or_recover(
-            p,
-            &AnyIfTestBooleanExprChainParseRecovery,
-            expected_if_test_boolean_expr_group,
-        )
-        .map(|rhs| parse_if_test_boolean_and_expr(p, rhs));
-
-    if recovery_result.is_err() && p.at(T![and]) {
-        // If we're here, it seems that we have
-        // if(...) and <missing exp> and <missing exp> and ...
-        // parse_any_if_test_boolean_expr_group failed to parse,
-        // but the parser is already at a recovered position.
-        let m = p.start();
-        let rhs = m.complete(p, CSS_BOGUS);
-        parse_if_test_boolean_and_expr(p, rhs);
-    }
-
-    m.complete(p, CSS_IF_TEST_BOOLEAN_AND_EXPR)
-}
-
-#[inline]
-fn is_at_if_test_boolean_or_expr(p: &mut CssParser) -> bool {
-    p.at(T![or])
-}
-
-/// Parses `<boolean-expr-group> or <boolean-expr-group>`
-///
-/// # Example
-///
-/// ``` css
-/// style(--color: green) or style(--color: yellow)
-/// ```
-#[inline]
-fn parse_if_test_boolean_or_expr(p: &mut CssParser, lhs: CompletedMarker) -> CompletedMarker {
-    if !is_at_if_test_boolean_or_expr(p) {
-        return lhs;
-    }
-
-    let m = lhs.precede(p);
-    p.bump(T![or]);
-
-    let recovery_result = parse_any_if_test_boolean_expr_group(p)
-        .or_recover(
-            p,
-            &AnyIfTestBooleanExprChainParseRecovery,
-            expected_if_test_boolean_expr_group,
-        )
-        .map(|rhs| parse_if_test_boolean_or_expr(p, rhs));
-
-    if recovery_result.is_err() && p.at(T![or]) {
-        // If we're here, it seems that we have
-        // if(...) or <missing exp> or <missing exp> or ...
-        // parse_any_if_test_boolean_expr_group failed to parse,
-        // but the parser is already at a recovered position.
-        let m = p.start();
-        let rhs = m.complete(p, CSS_BOGUS);
-        parse_if_test_boolean_or_expr(p, rhs);
-    }
-
-    m.complete(p, CSS_IF_TEST_BOOLEAN_OR_EXPR)
-}
-
-#[inline]
-fn parse_any_if_test_boolean_expr(p: &mut CssParser) -> ParsedSyntax {
-    if is_at_if_test_boolean_not_expr(p) {
-        return parse_if_test_boolean_not_expr(p);
-    }
-
-    parse_any_if_test_boolean_expr_group(p).map(|lhs| match p.cur() {
-        T![and] => parse_if_test_boolean_and_expr(p, lhs),
-        T![or] => parse_if_test_boolean_or_expr(p, lhs),
-        _ => lhs,
-    })
-}
-
-#[inline]
-fn parse_any_if_condition(p: &mut CssParser) -> ParsedSyntax {
-    if p.at(T![else]) {
-        let m = p.start();
-        p.bump(T![else]);
-        return Present(m.complete(p, CSS_ELSE_KEYWORD));
-    }
-
-    parse_any_if_test_boolean_expr(p)
-}
-
-#[inline]
-fn parse_if_branch(p: &mut CssParser) -> ParsedSyntax {
-    let m = p.start();
-
-    parse_any_if_condition(p)
-        .or_recover(p, &AnyIfTestParseRecovery, expected_if_branch)
-        .ok();
-
-    p.expect(T![:]);
-
-    GenericComponentValueList.parse_list(p);
-
-    Present(m.complete(p, CSS_IF_BRANCH))
-}
-
-struct AnyIfTestBooleanExprChainParseRecovery;
-
-impl ParseRecovery for AnyIfTestBooleanExprChainParseRecovery {
-    type Kind = CssSyntaxKind;
-    type Parser<'source> = CssParser<'source>;
-    const RECOVERED_KIND: Self::Kind = CSS_BOGUS;
-
-    fn is_at_recovered(&self, p: &mut Self::Parser<'_>) -> bool {
-        is_at_if_test_boolean_not_expr(p)
-            || is_at_if_test_boolean_and_expr(p)
-            || is_at_if_test_boolean_or_expr(p)
-            || p.has_preceding_line_break()
-    }
-}
-
-struct AnyIfTestParseRecovery;
-
-impl ParseRecovery for AnyIfTestParseRecovery {
-    type Kind = CssSyntaxKind;
-    type Parser<'source> = CssParser<'source>;
-    const RECOVERED_KIND: Self::Kind = CSS_BOGUS_IF_TEST;
-
-    fn is_at_recovered(&self, p: &mut Self::Parser<'_>) -> bool {
-        p.at(T![')']) || p.has_preceding_line_break()
-    }
-}
-
-struct IfBranchListParseRecovery;
-
-impl ParseRecovery for IfBranchListParseRecovery {
-    type Kind = CssSyntaxKind;
-    type Parser<'source> = CssParser<'source>;
-
-    const RECOVERED_KIND: Self::Kind = CSS_BOGUS_IF_BRANCH;
-
-    fn is_at_recovered(&self, p: &mut Self::Parser<'_>) -> bool {
-        p.at(T![;]) || p.at(T![')']) || p.has_preceding_line_break()
-    }
-}
-
-struct CssIfBranchList;
-
-impl ParseSeparatedList for CssIfBranchList {
-    type Kind = CssSyntaxKind;
-    type Parser<'source> = CssParser<'source>;
-    const LIST_KIND: Self::Kind = CSS_IF_BRANCH_LIST;
-
-    fn parse_element(&mut self, p: &mut Self::Parser<'_>) -> ParsedSyntax {
-        parse_if_branch(p)
-    }
-
-    fn is_at_list_end(&self, p: &mut Self::Parser<'_>) -> bool {
-        p.at(T![')'])
-    }
-
-    fn recover(
-        &mut self,
-        p: &mut Self::Parser<'_>,
-        parsed_element: ParsedSyntax,
-    ) -> RecoveryResult {
-        parsed_element.or_recover(p, &IfBranchListParseRecovery, expected_if_branch)
-    }
-
-    fn separating_element_kind(&mut self) -> Self::Kind {
-        T![;]
-    }
-
-    fn allow_trailing_separating_element(&self) -> bool {
-        true
-    }
-
-    fn allow_empty(&self) -> bool {
-        false
-    }
-}
diff --git a/crates/biome_css_parser/src/syntax/value/mod.rs b/crates/biome_css_parser/src/syntax/value/mod.rs
index 1240634cf0..2768d55648 100644
--- a/crates/biome_css_parser/src/syntax/value/mod.rs
+++ b/crates/biome_css_parser/src/syntax/value/mod.rs
@@ -1,5 +1,4 @@
 pub(crate) mod dimension;
 pub(crate) mod function;
-pub(crate) mod r#if;
 mod parse_error;
 pub(crate) mod url;
diff --git a/crates/biome_css_parser/src/syntax/value/parse_error.rs b/crates/biome_css_parser/src/syntax/value/parse_error.rs
index 83e5c96b5a..eda81761e0 100644
--- a/crates/biome_css_parser/src/syntax/value/parse_error.rs
+++ b/crates/biome_css_parser/src/syntax/value/parse_error.rs
@@ -19,14 +19,3 @@ pub(crate) fn expected_expression(p: &CssParser, range: TextRange) -> ParseDiagn
         p,
     )
 }
-
-pub(crate) fn expected_if_branch(p: &CssParser, range: TextRange) -> ParseDiagnostic {
-    expected_any(&["if branch", "if test boolean expression"], range, p)
-}
-
-pub(crate) fn expected_if_test_boolean_expr_group(
-    p: &CssParser,
-    range: TextRange,
-) -> ParseDiagnostic {
-    expected_any(&["parenthesized boolean expression", "if test"], range, p)
-}
diff --git a/crates/biome_css_syntax/src/generated/kind.rs b/crates/biome_css_syntax/src/generated/kind.rs
index f42b10c8e5..c6a7b5d089 100644
--- a/crates/biome_css_syntax/src/generated/kind.rs
+++ b/crates/biome_css_syntax/src/generated/kind.rs
@@ -101,8 +101,6 @@ pub enum CssSyntaxKind {
     TO_KW,
     VAR_KW,
     URL_KW,
-    IF_KW,
-    ELSE_KW,
     SRC_KW,
     FONT_PALETTE_VALUES_KW,
     FONT_FEATURE_VALUES_KW,
@@ -357,18 +355,6 @@ pub enum CssSyntaxKind {
     CSS_BINARY_EXPRESSION,
     CSS_URL_VALUE_RAW,
     CSS_URL_FUNCTION,
-    CSS_IF_FUNCTION,
-    CSS_IF_BRANCH_LIST,
-    CSS_IF_BRANCH,
-    CSS_ELSE_KEYWORD,
-    CSS_IF_SUPPORTS_TEST,
-    CSS_IF_STYLE_TEST,
-    CSS_IF_MEDIA_TEST,
-    CSS_IF_SUPPORTS_IDENTIFIER_TEST,
-    CSS_IF_TEST_BOOLEAN_NOT_EXPR,
-    CSS_IF_TEST_BOOLEAN_AND_EXPR,
-    CSS_IF_TEST_BOOLEAN_OR_EXPR,
-    CSS_IF_TEST_BOOLEAN_EXPR_IN_PARENS,
     CSS_URL_MODIFIER_LIST,
     CSS_COLOR,
     CSS_BORDER,
@@ -541,8 +527,6 @@ pub enum CssSyntaxKind {
     CSS_BOGUS_KEYFRAMES_NAME,
     CSS_BOGUS_UNICODE_RANGE_VALUE,
     CSS_BOGUS_SUPPORTS_CONDITION,
-    CSS_BOGUS_IF_BRANCH,
-    CSS_BOGUS_IF_TEST,
     CSS_METAVARIABLE,
     #[doc(hidden)]
     __LAST,
@@ -637,7 +621,6 @@ impl CssSyntaxKind {
                 | CSS_PSEUDO_CLASS_FUNCTION_VALUE_LIST
                 | CSS_PSEUDO_VALUE_LIST
                 | CSS_PSEUDO_CLASS_FUNCTION_CUSTOM_IDENTIFIER_LIST
-                | CSS_IF_BRANCH_LIST
                 | CSS_URL_MODIFIER_LIST
                 | CSS_BRACKETED_VALUE_LIST
                 | CSS_FONT_FAMILY_NAME_LIST
@@ -707,8 +690,6 @@ impl CssSyntaxKind {
             "to" => TO_KW,
             "var" => VAR_KW,
             "url" => URL_KW,
-            "if" => IF_KW,
-            "else" => ELSE_KW,
             "src" => SRC_KW,
             "font-palette-values" => FONT_PALETTE_VALUES_KW,
             "font-feature-values" => FONT_FEATURE_VALUES_KW,
@@ -949,8 +930,6 @@ impl CssSyntaxKind {
             TO_KW => "to",
             VAR_KW => "var",
             URL_KW => "url",
-            IF_KW => "if",
-            ELSE_KW => "else",
             SRC_KW => "src",
             FONT_PALETTE_VALUES_KW => "font-palette-values",
             FONT_FEATURE_VALUES_KW => "font-feature-values",
@@ -1105,4 +1084,4 @@ impl CssSyntaxKind {
 }
 #[doc = r" Utility macro for creating a SyntaxKind through simple macro syntax"]
 #[macro_export]
-macro_rules ! T { [;] => { $ crate :: CssSyntaxKind :: SEMICOLON } ; [,] => { $ crate :: CssSyntaxKind :: COMMA } ; ['('] => { $ crate :: CssSyntaxKind :: L_PAREN } ; [')'] => { $ crate :: CssSyntaxKind :: R_PAREN } ; ['{'] => { $ crate :: CssSyntaxKind :: L_CURLY } ; ['}'] => { $ crate :: CssSyntaxKind :: R_CURLY } ; ['['] => { $ crate :: CssSyntaxKind :: L_BRACK } ; [']'] => { $ crate :: CssSyntaxKind :: R_BRACK } ; [<] => { $ crate :: CssSyntaxKind :: L_ANGLE } ; [>] => { $ crate :: CssSyntaxKind :: R_ANGLE } ; [~] => { $ crate :: CssSyntaxKind :: TILDE } ; [#] => { $ crate :: CssSyntaxKind :: HASH } ; [&] => { $ crate :: CssSyntaxKind :: AMP } ; [|] => { $ crate :: CssSyntaxKind :: PIPE } ; [||] => { $ crate :: CssSyntaxKind :: PIPE2 } ; [+] => { $ crate :: CssSyntaxKind :: PLUS } ; [*] => { $ crate :: CssSyntaxKind :: STAR } ; [/] => { $ crate :: CssSyntaxKind :: SLASH } ; [^] => { $ crate :: CssSyntaxKind :: CARET } ; [%] => { $ crate :: CssSyntaxKind :: PERCENT } ; [.] => { $ crate :: CssSyntaxKind :: DOT } ; [:] => { $ crate :: CssSyntaxKind :: COLON } ; [::] => { $ crate :: CssSyntaxKind :: COLON2 } ; [=] => { $ crate :: CssSyntaxKind :: EQ } ; [!] => { $ crate :: CssSyntaxKind :: BANG } ; [!=] => { $ crate :: CssSyntaxKind :: NEQ } ; [-] => { $ crate :: CssSyntaxKind :: MINUS } ; [<=] => { $ crate :: CssSyntaxKind :: LTEQ } ; [>=] => { $ crate :: CssSyntaxKind :: GTEQ } ; [+=] => { $ crate :: CssSyntaxKind :: PLUSEQ } ; [|=] => { $ crate :: CssSyntaxKind :: PIPEEQ } ; [&=] => { $ crate :: CssSyntaxKind :: AMPEQ } ; [^=] => { $ crate :: CssSyntaxKind :: CARETEQ } ; [/=] => { $ crate :: CssSyntaxKind :: SLASHEQ } ; [*=] => { $ crate :: CssSyntaxKind :: STAREQ } ; [%=] => { $ crate :: CssSyntaxKind :: PERCENTEQ } ; [@] => { $ crate :: CssSyntaxKind :: AT } ; ["$="] => { $ crate :: CssSyntaxKind :: DOLLAR_EQ } ; [~=] => { $ crate :: CssSyntaxKind :: TILDE_EQ } ; [-->] => { $ crate :: CssSyntaxKind :: CDC } ; [<!--] => { $ crate :: CssSyntaxKind :: CDO } ; ["U+"] => { $ crate :: CssSyntaxKind :: UNICODE } ; [media] => { $ crate :: CssSyntaxKind :: MEDIA_KW } ; [keyframes] => { $ crate :: CssSyntaxKind :: KEYFRAMES_KW } ; [not] => { $ crate :: CssSyntaxKind :: NOT_KW } ; [and] => { $ crate :: CssSyntaxKind :: AND_KW } ; [only] => { $ crate :: CssSyntaxKind :: ONLY_KW } ; [or] => { $ crate :: CssSyntaxKind :: OR_KW } ; [i] => { $ crate :: CssSyntaxKind :: I_KW } ; [important] => { $ crate :: CssSyntaxKind :: IMPORTANT_KW } ; [highlight] => { $ crate :: CssSyntaxKind :: HIGHLIGHT_KW } ; [part] => { $ crate :: CssSyntaxKind :: PART_KW } ; [dir] => { $ crate :: CssSyntaxKind :: DIR_KW } ; [local] => { $ crate :: CssSyntaxKind :: LOCAL_KW } ; [global] => { $ crate :: CssSyntaxKind :: GLOBAL_KW } ; [any] => { $ crate :: CssSyntaxKind :: ANY_KW } ; [current] => { $ crate :: CssSyntaxKind :: CURRENT_KW } ; [past] => { $ crate :: CssSyntaxKind :: PAST_KW } ; [future] => { $ crate :: CssSyntaxKind :: FUTURE_KW } ; [host] => { $ crate :: CssSyntaxKind :: HOST_KW } ; [host_context] => { $ crate :: CssSyntaxKind :: HOST_CONTEXT_KW } ; [matches] => { $ crate :: CssSyntaxKind :: MATCHES_KW } ; [is] => { $ crate :: CssSyntaxKind :: IS_KW } ; [where] => { $ crate :: CssSyntaxKind :: WHERE_KW } ; [has] => { $ crate :: CssSyntaxKind :: HAS_KW } ; [lang] => { $ crate :: CssSyntaxKind :: LANG_KW } ; [nth_child] => { $ crate :: CssSyntaxKind :: NTH_CHILD_KW } ; [nth_last_child] => { $ crate :: CssSyntaxKind :: NTH_LAST_CHILD_KW } ; [nth_of_type] => { $ crate :: CssSyntaxKind :: NTH_OF_TYPE_KW } ; [nth_last_of_type] => { $ crate :: CssSyntaxKind :: NTH_LAST_OF_TYPE_KW } ; [active_view_transition_type] => { $ crate :: CssSyntaxKind :: ACTIVE_VIEW_TRANSITION_TYPE_KW } ; [nth_col] => { $ crate :: CssSyntaxKind :: NTH_COL_KW } ; [nth_last_col] => { $ crate :: CssSyntaxKind :: NTH_LAST_COL_KW } ; [charset] => { $ crate :: CssSyntaxKind :: CHARSET_KW } ; [color_profile] => { $ crate :: CssSyntaxKind :: COLOR_PROFILE_KW } ; [counter_style] => { $ crate :: CssSyntaxKind :: COUNTER_STYLE_KW } ; [property] => { $ crate :: CssSyntaxKind :: PROPERTY_KW } ; [container] => { $ crate :: CssSyntaxKind :: CONTAINER_KW } ; [style] => { $ crate :: CssSyntaxKind :: STYLE_KW } ; [ltr] => { $ crate :: CssSyntaxKind :: LTR_KW } ; [rtl] => { $ crate :: CssSyntaxKind :: RTL_KW } ; [n] => { $ crate :: CssSyntaxKind :: N_KW } ; [even] => { $ crate :: CssSyntaxKind :: EVEN_KW } ; [odd] => { $ crate :: CssSyntaxKind :: ODD_KW } ; [of] => { $ crate :: CssSyntaxKind :: OF_KW } ; [from] => { $ crate :: CssSyntaxKind :: FROM_KW } ; [to] => { $ crate :: CssSyntaxKind :: TO_KW } ; [var] => { $ crate :: CssSyntaxKind :: VAR_KW } ; [url] => { $ crate :: CssSyntaxKind :: URL_KW } ; [if] => { $ crate :: CssSyntaxKind :: IF_KW } ; [else] => { $ crate :: CssSyntaxKind :: ELSE_KW } ; [src] => { $ crate :: CssSyntaxKind :: SRC_KW } ; [font_palette_values] => { $ crate :: CssSyntaxKind :: FONT_PALETTE_VALUES_KW } ; [font_feature_values] => { $ crate :: CssSyntaxKind :: FONT_FEATURE_VALUES_KW } ; [stylistic] => { $ crate :: CssSyntaxKind :: STYLISTIC_KW } ; [historical_forms] => { $ crate :: CssSyntaxKind :: HISTORICAL_FORMS_KW } ; [styleset] => { $ crate :: CssSyntaxKind :: STYLESET_KW } ; [character_variant] => { $ crate :: CssSyntaxKind :: CHARACTER_VARIANT_KW } ; [state] => { $ crate :: CssSyntaxKind :: STATE_KW } ; [swash] => { $ crate :: CssSyntaxKind :: SWASH_KW } ; [ornaments] => { $ crate :: CssSyntaxKind :: ORNAMENTS_KW } ; [annotation] => { $ crate :: CssSyntaxKind :: ANNOTATION_KW } ; [auto] => { $ crate :: CssSyntaxKind :: AUTO_KW } ; [thin] => { $ crate :: CssSyntaxKind :: THIN_KW } ; [medium] => { $ crate :: CssSyntaxKind :: MEDIUM_KW } ; [thick] => { $ crate :: CssSyntaxKind :: THICK_KW } ; [none] => { $ crate :: CssSyntaxKind :: NONE_KW } ; [hidden] => { $ crate :: CssSyntaxKind :: HIDDEN_KW } ; [dotted] => { $ crate :: CssSyntaxKind :: DOTTED_KW } ; [dashed] => { $ crate :: CssSyntaxKind :: DASHED_KW } ; [solid] => { $ crate :: CssSyntaxKind :: SOLID_KW } ; [double] => { $ crate :: CssSyntaxKind :: DOUBLE_KW } ; [groove] => { $ crate :: CssSyntaxKind :: GROOVE_KW } ; [ridge] => { $ crate :: CssSyntaxKind :: RIDGE_KW } ; [inset] => { $ crate :: CssSyntaxKind :: INSET_KW } ; [outset] => { $ crate :: CssSyntaxKind :: OUTSET_KW } ; [theme] => { $ crate :: CssSyntaxKind :: THEME_KW } ; [utility] => { $ crate :: CssSyntaxKind :: UTILITY_KW } ; [variant] => { $ crate :: CssSyntaxKind :: VARIANT_KW } ; [custom_variant] => { $ crate :: CssSyntaxKind :: CUSTOM_VARIANT_KW } ; [apply] => { $ crate :: CssSyntaxKind :: APPLY_KW } ; [source] => { $ crate :: CssSyntaxKind :: SOURCE_KW } ; [reference] => { $ crate :: CssSyntaxKind :: REFERENCE_KW } ; [config] => { $ crate :: CssSyntaxKind :: CONFIG_KW } ; [plugin] => { $ crate :: CssSyntaxKind :: PLUGIN_KW } ; [slot] => { $ crate :: CssSyntaxKind :: SLOT_KW } ; [inline] => { $ crate :: CssSyntaxKind :: INLINE_KW } ; [initial] => { $ crate :: CssSyntaxKind :: INITIAL_KW } ; [inherit] => { $ crate :: CssSyntaxKind :: INHERIT_KW } ; [unset] => { $ crate :: CssSyntaxKind :: UNSET_KW } ; [revert] => { $ crate :: CssSyntaxKind :: REVERT_KW } ; [revert_layer] => { $ crate :: CssSyntaxKind :: REVERT_LAYER_KW } ; [default] => { $ crate :: CssSyntaxKind :: DEFAULT_KW } ; [em] => { $ crate :: CssSyntaxKind :: EM_KW } ; [rem] => { $ crate :: CssSyntaxKind :: REM_KW } ; [ex] => { $ crate :: CssSyntaxKind :: EX_KW } ; [rex] => { $ crate :: CssSyntaxKind :: REX_KW } ; [cap] => { $ crate :: CssSyntaxKind :: CAP_KW } ; [rcap] => { $ crate :: CssSyntaxKind :: RCAP_KW } ; [ch] => { $ crate :: CssSyntaxKind :: CH_KW } ; [rch] => { $ crate :: CssSyntaxKind :: RCH_KW } ; [ic] => { $ crate :: CssSyntaxKind :: IC_KW } ; [ric] => { $ crate :: CssSyntaxKind :: RIC_KW } ; [lh] => { $ crate :: CssSyntaxKind :: LH_KW } ; [rlh] => { $ crate :: CssSyntaxKind :: RLH_KW } ; [vw] => { $ crate :: CssSyntaxKind :: VW_KW } ; [svw] => { $ crate :: CssSyntaxKind :: SVW_KW } ; [lvw] => { $ crate :: CssSyntaxKind :: LVW_KW } ; [dvw] => { $ crate :: CssSyntaxKind :: DVW_KW } ; [vh] => { $ crate :: CssSyntaxKind :: VH_KW } ; [svh] => { $ crate :: CssSyntaxKind :: SVH_KW } ; [lvh] => { $ crate :: CssSyntaxKind :: LVH_KW } ; [dvh] => { $ crate :: CssSyntaxKind :: DVH_KW } ; [vi] => { $ crate :: CssSyntaxKind :: VI_KW } ; [svi] => { $ crate :: CssSyntaxKind :: SVI_KW } ; [lvi] => { $ crate :: CssSyntaxKind :: LVI_KW } ; [dvi] => { $ crate :: CssSyntaxKind :: DVI_KW } ; [vb] => { $ crate :: CssSyntaxKind :: VB_KW } ; [svb] => { $ crate :: CssSyntaxKind :: SVB_KW } ; [lvb] => { $ crate :: CssSyntaxKind :: LVB_KW } ; [dvb] => { $ crate :: CssSyntaxKind :: DVB_KW } ; [vmin] => { $ crate :: CssSyntaxKind :: VMIN_KW } ; [svmin] => { $ crate :: CssSyntaxKind :: SVMIN_KW } ; [lvmin] => { $ crate :: CssSyntaxKind :: LVMIN_KW } ; [dvmin] => { $ crate :: CssSyntaxKind :: DVMIN_KW } ; [vmax] => { $ crate :: CssSyntaxKind :: VMAX_KW } ; [svmax] => { $ crate :: CssSyntaxKind :: SVMAX_KW } ; [lvmax] => { $ crate :: CssSyntaxKind :: LVMAX_KW } ; [dvmax] => { $ crate :: CssSyntaxKind :: DVMAX_KW } ; [cm] => { $ crate :: CssSyntaxKind :: CM_KW } ; [mm] => { $ crate :: CssSyntaxKind :: MM_KW } ; [q] => { $ crate :: CssSyntaxKind :: Q_KW } ; [in] => { $ crate :: CssSyntaxKind :: IN_KW } ; [pc] => { $ crate :: CssSyntaxKind :: PC_KW } ; [pt] => { $ crate :: CssSyntaxKind :: PT_KW } ; [px] => { $ crate :: CssSyntaxKind :: PX_KW } ; [mozmm] => { $ crate :: CssSyntaxKind :: MOZMM_KW } ; [rpx] => { $ crate :: CssSyntaxKind :: RPX_KW } ; [cqw] => { $ crate :: CssSyntaxKind :: CQW_KW } ; [cqh] => { $ crate :: CssSyntaxKind :: CQH_KW } ; [cqi] => { $ crate :: CssSyntaxKind :: CQI_KW } ; [cqb] => { $ crate :: CssSyntaxKind :: CQB_KW } ; [cqmin] => { $ crate :: CssSyntaxKind :: CQMIN_KW } ; [cqmax] => { $ crate :: CssSyntaxKind :: CQMAX_KW } ; [deg] => { $ crate :: CssSyntaxKind :: DEG_KW } ; [grad] => { $ crate :: CssSyntaxKind :: GRAD_KW } ; [rad] => { $ crate :: CssSyntaxKind :: RAD_KW } ; [turn] => { $ crate :: CssSyntaxKind :: TURN_KW } ; [s] => { $ crate :: CssSyntaxKind :: S_KW } ; [ms] => { $ crate :: CssSyntaxKind :: MS_KW } ; [hz] => { $ crate :: CssSyntaxKind :: HZ_KW } ; [khz] => { $ crate :: CssSyntaxKind :: KHZ_KW } ; [dpi] => { $ crate :: CssSyntaxKind :: DPI_KW } ; [dpcm] => { $ crate :: CssSyntaxKind :: DPCM_KW } ; [dppx] => { $ crate :: CssSyntaxKind :: DPPX_KW } ; [x] => { $ crate :: CssSyntaxKind :: X_KW } ; [fr] => { $ crate :: CssSyntaxKind :: FR_KW } ; [page] => { $ crate :: CssSyntaxKind :: PAGE_KW } ; [left] => { $ crate :: CssSyntaxKind :: LEFT_KW } ; [right] => { $ crate :: CssSyntaxKind :: RIGHT_KW } ; [first] => { $ crate :: CssSyntaxKind :: FIRST_KW } ; [blank] => { $ crate :: CssSyntaxKind :: BLANK_KW } ; [top_left_corner] => { $ crate :: CssSyntaxKind :: TOP_LEFT_CORNER_KW } ; [top_left] => { $ crate :: CssSyntaxKind :: TOP_LEFT_KW } ; [top_center] => { $ crate :: CssSyntaxKind :: TOP_CENTER_KW } ; [top_right] => { $ crate :: CssSyntaxKind :: TOP_RIGHT_KW } ; [top_right_corner] => { $ crate :: CssSyntaxKind :: TOP_RIGHT_CORNER_KW } ; [bottom_left_corner] => { $ crate :: CssSyntaxKind :: BOTTOM_LEFT_CORNER_KW } ; [bottom_left] => { $ crate :: CssSyntaxKind :: BOTTOM_LEFT_KW } ; [bottom_center] => { $ crate :: CssSyntaxKind :: BOTTOM_CENTER_KW } ; [bottom_right] => { $ crate :: CssSyntaxKind :: BOTTOM_RIGHT_KW } ; [bottom_right_corner] => { $ crate :: CssSyntaxKind :: BOTTOM_RIGHT_CORNER_KW } ; [left_top] => { $ crate :: CssSyntaxKind :: LEFT_TOP_KW } ; [left_middle] => { $ crate :: CssSyntaxKind :: LEFT_MIDDLE_KW } ; [left_bottom] => { $ crate :: CssSyntaxKind :: LEFT_BOTTOM_KW } ; [right_top] => { $ crate :: CssSyntaxKind :: RIGHT_TOP_KW } ; [right_middle] => { $ crate :: CssSyntaxKind :: RIGHT_MIDDLE_KW } ; [right_bottom] => { $ crate :: CssSyntaxKind :: RIGHT_BOTTOM_KW } ; [layer] => { $ crate :: CssSyntaxKind :: LAYER_KW } ; [scope] => { $ crate :: CssSyntaxKind :: SCOPE_KW } ; [supports] => { $ crate :: CssSyntaxKind :: SUPPORTS_KW } ; [selector] => { $ crate :: CssSyntaxKind :: SELECTOR_KW } ; [import] => { $ crate :: CssSyntaxKind :: IMPORT_KW } ; [namespace] => { $ crate :: CssSyntaxKind :: NAMESPACE_KW } ; [starting_style] => { $ crate :: CssSyntaxKind :: STARTING_STYLE_KW } ; [document] => { $ crate :: CssSyntaxKind :: DOCUMENT_KW } ; [url_prefix] => { $ crate :: CssSyntaxKind :: URL_PREFIX_KW } ; [domain] => { $ crate :: CssSyntaxKind :: DOMAIN_KW } ; [media_document] => { $ crate :: CssSyntaxKind :: MEDIA_DOCUMENT_KW } ; [regexp] => { $ crate :: CssSyntaxKind :: REGEXP_KW } ; [value] => { $ crate :: CssSyntaxKind :: VALUE_KW } ; [as] => { $ crate :: CssSyntaxKind :: AS_KW } ; [composes] => { $ crate :: CssSyntaxKind :: COMPOSES_KW } ; [position_try] => { $ crate :: CssSyntaxKind :: POSITION_TRY_KW } ; [view_transition] => { $ crate :: CssSyntaxKind :: VIEW_TRANSITION_KW } ; [font_face] => { $ crate :: CssSyntaxKind :: FONT_FACE_KW } ; [ident] => { $ crate :: CssSyntaxKind :: IDENT } ; [EOF] => { $ crate :: CssSyntaxKind :: EOF } ; [UNICODE_BOM] => { $ crate :: CssSyntaxKind :: UNICODE_BOM } ; [#] => { $ crate :: CssSyntaxKind :: HASH } ; }
+macro_rules ! T { [;] => { $ crate :: CssSyntaxKind :: SEMICOLON } ; [,] => { $ crate :: CssSyntaxKind :: COMMA } ; ['('] => { $ crate :: CssSyntaxKind :: L_PAREN } ; [')'] => { $ crate :: CssSyntaxKind :: R_PAREN } ; ['{'] => { $ crate :: CssSyntaxKind :: L_CURLY } ; ['}'] => { $ crate :: CssSyntaxKind :: R_CURLY } ; ['['] => { $ crate :: CssSyntaxKind :: L_BRACK } ; [']'] => { $ crate :: CssSyntaxKind :: R_BRACK } ; [<] => { $ crate :: CssSyntaxKind :: L_ANGLE } ; [>] => { $ crate :: CssSyntaxKind :: R_ANGLE } ; [~] => { $ crate :: CssSyntaxKind :: TILDE } ; [#] => { $ crate :: CssSyntaxKind :: HASH } ; [&] => { $ crate :: CssSyntaxKind :: AMP } ; [|] => { $ crate :: CssSyntaxKind :: PIPE } ; [||] => { $ crate :: CssSyntaxKind :: PIPE2 } ; [+] => { $ crate :: CssSyntaxKind :: PLUS } ; [*] => { $ crate :: CssSyntaxKind :: STAR } ; [/] => { $ crate :: CssSyntaxKind :: SLASH } ; [^] => { $ crate :: CssSyntaxKind :: CARET } ; [%] => { $ crate :: CssSyntaxKind :: PERCENT } ; [.] => { $ crate :: CssSyntaxKind :: DOT } ; [:] => { $ crate :: CssSyntaxKind :: COLON } ; [::] => { $ crate :: CssSyntaxKind :: COLON2 } ; [=] => { $ crate :: CssSyntaxKind :: EQ } ; [!] => { $ crate :: CssSyntaxKind :: BANG } ; [!=] => { $ crate :: CssSyntaxKind :: NEQ } ; [-] => { $ crate :: CssSyntaxKind :: MINUS } ; [<=] => { $ crate :: CssSyntaxKind :: LTEQ } ; [>=] => { $ crate :: CssSyntaxKind :: GTEQ } ; [+=] => { $ crate :: CssSyntaxKind :: PLUSEQ } ; [|=] => { $ crate :: CssSyntaxKind :: PIPEEQ } ; [&=] => { $ crate :: CssSyntaxKind :: AMPEQ } ; [^=] => { $ crate :: CssSyntaxKind :: CARETEQ } ; [/=] => { $ crate :: CssSyntaxKind :: SLASHEQ } ; [*=] => { $ crate :: CssSyntaxKind :: STAREQ } ; [%=] => { $ crate :: CssSyntaxKind :: PERCENTEQ } ; [@] => { $ crate :: CssSyntaxKind :: AT } ; ["$="] => { $ crate :: CssSyntaxKind :: DOLLAR_EQ } ; [~=] => { $ crate :: CssSyntaxKind :: TILDE_EQ } ; [-->] => { $ crate :: CssSyntaxKind :: CDC } ; [<!--] => { $ crate :: CssSyntaxKind :: CDO } ; ["U+"] => { $ crate :: CssSyntaxKind :: UNICODE } ; [media] => { $ crate :: CssSyntaxKind :: MEDIA_KW } ; [keyframes] => { $ crate :: CssSyntaxKind :: KEYFRAMES_KW } ; [not] => { $ crate :: CssSyntaxKind :: NOT_KW } ; [and] => { $ crate :: CssSyntaxKind :: AND_KW } ; [only] => { $ crate :: CssSyntaxKind :: ONLY_KW } ; [or] => { $ crate :: CssSyntaxKind :: OR_KW } ; [i] => { $ crate :: CssSyntaxKind :: I_KW } ; [important] => { $ crate :: CssSyntaxKind :: IMPORTANT_KW } ; [highlight] => { $ crate :: CssSyntaxKind :: HIGHLIGHT_KW } ; [part] => { $ crate :: CssSyntaxKind :: PART_KW } ; [dir] => { $ crate :: CssSyntaxKind :: DIR_KW } ; [local] => { $ crate :: CssSyntaxKind :: LOCAL_KW } ; [global] => { $ crate :: CssSyntaxKind :: GLOBAL_KW } ; [any] => { $ crate :: CssSyntaxKind :: ANY_KW } ; [current] => { $ crate :: CssSyntaxKind :: CURRENT_KW } ; [past] => { $ crate :: CssSyntaxKind :: PAST_KW } ; [future] => { $ crate :: CssSyntaxKind :: FUTURE_KW } ; [host] => { $ crate :: CssSyntaxKind :: HOST_KW } ; [host_context] => { $ crate :: CssSyntaxKind :: HOST_CONTEXT_KW } ; [matches] => { $ crate :: CssSyntaxKind :: MATCHES_KW } ; [is] => { $ crate :: CssSyntaxKind :: IS_KW } ; [where] => { $ crate :: CssSyntaxKind :: WHERE_KW } ; [has] => { $ crate :: CssSyntaxKind :: HAS_KW } ; [lang] => { $ crate :: CssSyntaxKind :: LANG_KW } ; [nth_child] => { $ crate :: CssSyntaxKind :: NTH_CHILD_KW } ; [nth_last_child] => { $ crate :: CssSyntaxKind :: NTH_LAST_CHILD_KW } ; [nth_of_type] => { $ crate :: CssSyntaxKind :: NTH_OF_TYPE_KW } ; [nth_last_of_type] => { $ crate :: CssSyntaxKind :: NTH_LAST_OF_TYPE_KW } ; [active_view_transition_type] => { $ crate :: CssSyntaxKind :: ACTIVE_VIEW_TRANSITION_TYPE_KW } ; [nth_col] => { $ crate :: CssSyntaxKind :: NTH_COL_KW } ; [nth_last_col] => { $ crate :: CssSyntaxKind :: NTH_LAST_COL_KW } ; [charset] => { $ crate :: CssSyntaxKind :: CHARSET_KW } ; [color_profile] => { $ crate :: CssSyntaxKind :: COLOR_PROFILE_KW } ; [counter_style] => { $ crate :: CssSyntaxKind :: COUNTER_STYLE_KW } ; [property] => { $ crate :: CssSyntaxKind :: PROPERTY_KW } ; [container] => { $ crate :: CssSyntaxKind :: CONTAINER_KW } ; [style] => { $ crate :: CssSyntaxKind :: STYLE_KW } ; [ltr] => { $ crate :: CssSyntaxKind :: LTR_KW } ; [rtl] => { $ crate :: CssSyntaxKind :: RTL_KW } ; [n] => { $ crate :: CssSyntaxKind :: N_KW } ; [even] => { $ crate :: CssSyntaxKind :: EVEN_KW } ; [odd] => { $ crate :: CssSyntaxKind :: ODD_KW } ; [of] => { $ crate :: CssSyntaxKind :: OF_KW } ; [from] => { $ crate :: CssSyntaxKind :: FROM_KW } ; [to] => { $ crate :: CssSyntaxKind :: TO_KW } ; [var] => { $ crate :: CssSyntaxKind :: VAR_KW } ; [url] => { $ crate :: CssSyntaxKind :: URL_KW } ; [src] => { $ crate :: CssSyntaxKind :: SRC_KW } ; [font_palette_values] => { $ crate :: CssSyntaxKind :: FONT_PALETTE_VALUES_KW } ; [font_feature_values] => { $ crate :: CssSyntaxKind :: FONT_FEATURE_VALUES_KW } ; [stylistic] => { $ crate :: CssSyntaxKind :: STYLISTIC_KW } ; [historical_forms] => { $ crate :: CssSyntaxKind :: HISTORICAL_FORMS_KW } ; [styleset] => { $ crate :: CssSyntaxKind :: STYLESET_KW } ; [character_variant] => { $ crate :: CssSyntaxKind :: CHARACTER_VARIANT_KW } ; [state] => { $ crate :: CssSyntaxKind :: STATE_KW } ; [swash] => { $ crate :: CssSyntaxKind :: SWASH_KW } ; [ornaments] => { $ crate :: CssSyntaxKind :: ORNAMENTS_KW } ; [annotation] => { $ crate :: CssSyntaxKind :: ANNOTATION_KW } ; [auto] => { $ crate :: CssSyntaxKind :: AUTO_KW } ; [thin] => { $ crate :: CssSyntaxKind :: THIN_KW } ; [medium] => { $ crate :: CssSyntaxKind :: MEDIUM_KW } ; [thick] => { $ crate :: CssSyntaxKind :: THICK_KW } ; [none] => { $ crate :: CssSyntaxKind :: NONE_KW } ; [hidden] => { $ crate :: CssSyntaxKind :: HIDDEN_KW } ; [dotted] => { $ crate :: CssSyntaxKind :: DOTTED_KW } ; [dashed] => { $ crate :: CssSyntaxKind :: DASHED_KW } ; [solid] => { $ crate :: CssSyntaxKind :: SOLID_KW } ; [double] => { $ crate :: CssSyntaxKind :: DOUBLE_KW } ; [groove] => { $ crate :: CssSyntaxKind :: GROOVE_KW } ; [ridge] => { $ crate :: CssSyntaxKind :: RIDGE_KW } ; [inset] => { $ crate :: CssSyntaxKind :: INSET_KW } ; [outset] => { $ crate :: CssSyntaxKind :: OUTSET_KW } ; [theme] => { $ crate :: CssSyntaxKind :: THEME_KW } ; [utility] => { $ crate :: CssSyntaxKind :: UTILITY_KW } ; [variant] => { $ crate :: CssSyntaxKind :: VARIANT_KW } ; [custom_variant] => { $ crate :: CssSyntaxKind :: CUSTOM_VARIANT_KW } ; [apply] => { $ crate :: CssSyntaxKind :: APPLY_KW } ; [source] => { $ crate :: CssSyntaxKind :: SOURCE_KW } ; [reference] => { $ crate :: CssSyntaxKind :: REFERENCE_KW } ; [config] => { $ crate :: CssSyntaxKind :: CONFIG_KW } ; [plugin] => { $ crate :: CssSyntaxKind :: PLUGIN_KW } ; [slot] => { $ crate :: CssSyntaxKind :: SLOT_KW } ; [inline] => { $ crate :: CssSyntaxKind :: INLINE_KW } ; [initial] => { $ crate :: CssSyntaxKind :: INITIAL_KW } ; [inherit] => { $ crate :: CssSyntaxKind :: INHERIT_KW } ; [unset] => { $ crate :: CssSyntaxKind :: UNSET_KW } ; [revert] => { $ crate :: CssSyntaxKind :: REVERT_KW } ; [revert_layer] => { $ crate :: CssSyntaxKind :: REVERT_LAYER_KW } ; [default] => { $ crate :: CssSyntaxKind :: DEFAULT_KW } ; [em] => { $ crate :: CssSyntaxKind :: EM_KW } ; [rem] => { $ crate :: CssSyntaxKind :: REM_KW } ; [ex] => { $ crate :: CssSyntaxKind :: EX_KW } ; [rex] => { $ crate :: CssSyntaxKind :: REX_KW } ; [cap] => { $ crate :: CssSyntaxKind :: CAP_KW } ; [rcap] => { $ crate :: CssSyntaxKind :: RCAP_KW } ; [ch] => { $ crate :: CssSyntaxKind :: CH_KW } ; [rch] => { $ crate :: CssSyntaxKind :: RCH_KW } ; [ic] => { $ crate :: CssSyntaxKind :: IC_KW } ; [ric] => { $ crate :: CssSyntaxKind :: RIC_KW } ; [lh] => { $ crate :: CssSyntaxKind :: LH_KW } ; [rlh] => { $ crate :: CssSyntaxKind :: RLH_KW } ; [vw] => { $ crate :: CssSyntaxKind :: VW_KW } ; [svw] => { $ crate :: CssSyntaxKind :: SVW_KW } ; [lvw] => { $ crate :: CssSyntaxKind :: LVW_KW } ; [dvw] => { $ crate :: CssSyntaxKind :: DVW_KW } ; [vh] => { $ crate :: CssSyntaxKind :: VH_KW } ; [svh] => { $ crate :: CssSyntaxKind :: SVH_KW } ; [lvh] => { $ crate :: CssSyntaxKind :: LVH_KW } ; [dvh] => { $ crate :: CssSyntaxKind :: DVH_KW } ; [vi] => { $ crate :: CssSyntaxKind :: VI_KW } ; [svi] => { $ crate :: CssSyntaxKind :: SVI_KW } ; [lvi] => { $ crate :: CssSyntaxKind :: LVI_KW } ; [dvi] => { $ crate :: CssSyntaxKind :: DVI_KW } ; [vb] => { $ crate :: CssSyntaxKind :: VB_KW } ; [svb] => { $ crate :: CssSyntaxKind :: SVB_KW } ; [lvb] => { $ crate :: CssSyntaxKind :: LVB_KW } ; [dvb] => { $ crate :: CssSyntaxKind :: DVB_KW } ; [vmin] => { $ crate :: CssSyntaxKind :: VMIN_KW } ; [svmin] => { $ crate :: CssSyntaxKind :: SVMIN_KW } ; [lvmin] => { $ crate :: CssSyntaxKind :: LVMIN_KW } ; [dvmin] => { $ crate :: CssSyntaxKind :: DVMIN_KW } ; [vmax] => { $ crate :: CssSyntaxKind :: VMAX_KW } ; [svmax] => { $ crate :: CssSyntaxKind :: SVMAX_KW } ; [lvmax] => { $ crate :: CssSyntaxKind :: LVMAX_KW } ; [dvmax] => { $ crate :: CssSyntaxKind :: DVMAX_KW } ; [cm] => { $ crate :: CssSyntaxKind :: CM_KW } ; [mm] => { $ crate :: CssSyntaxKind :: MM_KW } ; [q] => { $ crate :: CssSyntaxKind :: Q_KW } ; [in] => { $ crate :: CssSyntaxKind :: IN_KW } ; [pc] => { $ crate :: CssSyntaxKind :: PC_KW } ; [pt] => { $ crate :: CssSyntaxKind :: PT_KW } ; [px] => { $ crate :: CssSyntaxKind :: PX_KW } ; [mozmm] => { $ crate :: CssSyntaxKind :: MOZMM_KW } ; [rpx] => { $ crate :: CssSyntaxKind :: RPX_KW } ; [cqw] => { $ crate :: CssSyntaxKind :: CQW_KW } ; [cqh] => { $ crate :: CssSyntaxKind :: CQH_KW } ; [cqi] => { $ crate :: CssSyntaxKind :: CQI_KW } ; [cqb] => { $ crate :: CssSyntaxKind :: CQB_KW } ; [cqmin] => { $ crate :: CssSyntaxKind :: CQMIN_KW } ; [cqmax] => { $ crate :: CssSyntaxKind :: CQMAX_KW } ; [deg] => { $ crate :: CssSyntaxKind :: DEG_KW } ; [grad] => { $ crate :: CssSyntaxKind :: GRAD_KW } ; [rad] => { $ crate :: CssSyntaxKind :: RAD_KW } ; [turn] => { $ crate :: CssSyntaxKind :: TURN_KW } ; [s] => { $ crate :: CssSyntaxKind :: S_KW } ; [ms] => { $ crate :: CssSyntaxKind :: MS_KW } ; [hz] => { $ crate :: CssSyntaxKind :: HZ_KW } ; [khz] => { $ crate :: CssSyntaxKind :: KHZ_KW } ; [dpi] => { $ crate :: CssSyntaxKind :: DPI_KW } ; [dpcm] => { $ crate :: CssSyntaxKind :: DPCM_KW } ; [dppx] => { $ crate :: CssSyntaxKind :: DPPX_KW } ; [x] => { $ crate :: CssSyntaxKind :: X_KW } ; [fr] => { $ crate :: CssSyntaxKind :: FR_KW } ; [page] => { $ crate :: CssSyntaxKind :: PAGE_KW } ; [left] => { $ crate :: CssSyntaxKind :: LEFT_KW } ; [right] => { $ crate :: CssSyntaxKind :: RIGHT_KW } ; [first] => { $ crate :: CssSyntaxKind :: FIRST_KW } ; [blank] => { $ crate :: CssSyntaxKind :: BLANK_KW } ; [top_left_corner] => { $ crate :: CssSyntaxKind :: TOP_LEFT_CORNER_KW } ; [top_left] => { $ crate :: CssSyntaxKind :: TOP_LEFT_KW } ; [top_center] => { $ crate :: CssSyntaxKind :: TOP_CENTER_KW } ; [top_right] => { $ crate :: CssSyntaxKind :: TOP_RIGHT_KW } ; [top_right_corner] => { $ crate :: CssSyntaxKind :: TOP_RIGHT_CORNER_KW } ; [bottom_left_corner] => { $ crate :: CssSyntaxKind :: BOTTOM_LEFT_CORNER_KW } ; [bottom_left] => { $ crate :: CssSyntaxKind :: BOTTOM_LEFT_KW } ; [bottom_center] => { $ crate :: CssSyntaxKind :: BOTTOM_CENTER_KW } ; [bottom_right] => { $ crate :: CssSyntaxKind :: BOTTOM_RIGHT_KW } ; [bottom_right_corner] => { $ crate :: CssSyntaxKind :: BOTTOM_RIGHT_CORNER_KW } ; [left_top] => { $ crate :: CssSyntaxKind :: LEFT_TOP_KW } ; [left_middle] => { $ crate :: CssSyntaxKind :: LEFT_MIDDLE_KW } ; [left_bottom] => { $ crate :: CssSyntaxKind :: LEFT_BOTTOM_KW } ; [right_top] => { $ crate :: CssSyntaxKind :: RIGHT_TOP_KW } ; [right_middle] => { $ crate :: CssSyntaxKind :: RIGHT_MIDDLE_KW } ; [right_bottom] => { $ crate :: CssSyntaxKind :: RIGHT_BOTTOM_KW } ; [layer] => { $ crate :: CssSyntaxKind :: LAYER_KW } ; [scope] => { $ crate :: CssSyntaxKind :: SCOPE_KW } ; [supports] => { $ crate :: CssSyntaxKind :: SUPPORTS_KW } ; [selector] => { $ crate :: CssSyntaxKind :: SELECTOR_KW } ; [import] => { $ crate :: CssSyntaxKind :: IMPORT_KW } ; [namespace] => { $ crate :: CssSyntaxKind :: NAMESPACE_KW } ; [starting_style] => { $ crate :: CssSyntaxKind :: STARTING_STYLE_KW } ; [document] => { $ crate :: CssSyntaxKind :: DOCUMENT_KW } ; [url_prefix] => { $ crate :: CssSyntaxKind :: URL_PREFIX_KW } ; [domain] => { $ crate :: CssSyntaxKind :: DOMAIN_KW } ; [media_document] => { $ crate :: CssSyntaxKind :: MEDIA_DOCUMENT_KW } ; [regexp] => { $ crate :: CssSyntaxKind :: REGEXP_KW } ; [value] => { $ crate :: CssSyntaxKind :: VALUE_KW } ; [as] => { $ crate :: CssSyntaxKind :: AS_KW } ; [composes] => { $ crate :: CssSyntaxKind :: COMPOSES_KW } ; [position_try] => { $ crate :: CssSyntaxKind :: POSITION_TRY_KW } ; [view_transition] => { $ crate :: CssSyntaxKind :: VIEW_TRANSITION_KW } ; [font_face] => { $ crate :: CssSyntaxKind :: FONT_FACE_KW } ; [ident] => { $ crate :: CssSyntaxKind :: IDENT } ; [EOF] => { $ crate :: CssSyntaxKind :: EOF } ; [UNICODE_BOM] => { $ crate :: CssSyntaxKind :: UNICODE_BOM } ; [#] => { $ crate :: CssSyntaxKind :: HASH } ; }
diff --git a/crates/biome_css_syntax/src/generated/macros.rs b/crates/biome_css_syntax/src/generated/macros.rs
index 130381b01b..783c1bf5a9 100644
--- a/crates/biome_css_syntax/src/generated/macros.rs
+++ b/crates/biome_css_syntax/src/generated/macros.rs
@@ -197,10 +197,6 @@ macro_rules! map_syntax_node {
                     let $pattern = unsafe { $crate::CssDocumentCustomMatcher::new_unchecked(node) };
                     $body
                 }
-                $crate::CssSyntaxKind::CSS_ELSE_KEYWORD => {
-                    let $pattern = unsafe { $crate::CssElseKeyword::new_unchecked(node) };
-                    $body
-                }
                 $crate::CssSyntaxKind::CSS_EMPTY_DECLARATION => {
                     let $pattern = unsafe { $crate::CssEmptyDeclaration::new_unchecked(node) };
                     $body
@@ -263,48 +259,6 @@ macro_rules! map_syntax_node {
                     let $pattern = unsafe { $crate::CssIdentifier::new_unchecked(node) };
                     $body
                 }
-                $crate::CssSyntaxKind::CSS_IF_BRANCH => {
-                    let $pattern = unsafe { $crate::CssIfBranch::new_unchecked(node) };
-                    $body
-                }
-                $crate::CssSyntaxKind::CSS_IF_FUNCTION => {
-                    let $pattern = unsafe { $crate::CssIfFunction::new_unchecked(node) };
-                    $body
-                }
-                $crate::CssSyntaxKind::CSS_IF_MEDIA_TEST => {
-                    let $pattern = unsafe { $crate::CssIfMediaTest::new_unchecked(node) };
-                    $body
-                }
-                $crate::CssSyntaxKind::CSS_IF_STYLE_TEST => {
-                    let $pattern = unsafe { $crate::CssIfStyleTest::new_unchecked(node) };
-                    $body
-                }
-                $crate::CssSyntaxKind::CSS_IF_SUPPORTS_IDENTIFIER_TEST => {
-                    let $pattern =
-                        unsafe { $crate::CssIfSupportsIdentifierTest::new_unchecked(node) };
-                    $body
-                }
-                $crate::CssSyntaxKind::CSS_IF_SUPPORTS_TEST => {
-                    let $pattern = unsafe { $crate::CssIfSupportsTest::new_unchecked(node) };
-                    $body
-                }
-                $crate::CssSyntaxKind::CSS_IF_TEST_BOOLEAN_AND_EXPR => {
-                    let $pattern = unsafe { $crate::CssIfTestBooleanAndExpr::new_unchecked(node) };
-                    $body
-                }
-                $crate::CssSyntaxKind::CSS_IF_TEST_BOOLEAN_EXPR_IN_PARENS => {
-                    let $pattern =
-                        unsafe { $crate::CssIfTestBooleanExprInParens::new_unchecked(node) };
-                    $body
-                }
-                $crate::CssSyntaxKind::CSS_IF_TEST_BOOLEAN_NOT_EXPR => {
-                    let $pattern = unsafe { $crate::CssIfTestBooleanNotExpr::new_unchecked(node) };
-                    $body
-                }
-                $crate::CssSyntaxKind::CSS_IF_TEST_BOOLEAN_OR_EXPR => {
-                    let $pattern = unsafe { $crate::CssIfTestBooleanOrExpr::new_unchecked(node) };
-                    $body
-                }
                 $crate::CssSyntaxKind::CSS_IMPORT_ANONYMOUS_LAYER => {
                     let $pattern = unsafe { $crate::CssImportAnonymousLayer::new_unchecked(node) };
                     $body
@@ -911,14 +865,6 @@ macro_rules! map_syntax_node {
                         unsafe { $crate::CssBogusFontFeatureValuesItem::new_unchecked(node) };
                     $body
                 }
-                $crate::CssSyntaxKind::CSS_BOGUS_IF_BRANCH => {
-                    let $pattern = unsafe { $crate::CssBogusIfBranch::new_unchecked(node) };
-                    $body
-                }
-                $crate::CssSyntaxKind::CSS_BOGUS_IF_TEST => {
-                    let $pattern = unsafe { $crate::CssBogusIfTest::new_unchecked(node) };
-                    $body
-                }
                 $crate::CssSyntaxKind::CSS_BOGUS_KEYFRAMES_ITEM => {
                     let $pattern = unsafe { $crate::CssBogusKeyframesItem::new_unchecked(node) };
                     $body
@@ -1051,10 +997,6 @@ macro_rules! map_syntax_node {
                         unsafe { $crate::CssGenericComponentValueList::new_unchecked(node) };
                     $body
                 }
-                $crate::CssSyntaxKind::CSS_IF_BRANCH_LIST => {
-                    let $pattern = unsafe { $crate::CssIfBranchList::new_unchecked(node) };
-                    $body
-                }
                 $crate::CssSyntaxKind::CSS_KEYFRAMES_ITEM_LIST => {
                     let $pattern = unsafe { $crate::CssKeyframesItemList::new_unchecked(node) };
                     $body
diff --git a/crates/biome_css_syntax/src/generated/nodes.rs b/crates/biome_css_syntax/src/generated/nodes.rs
index 01b56eb735..495aafc6c5 100644
--- a/crates/biome_css_syntax/src/generated/nodes.rs
+++ b/crates/biome_css_syntax/src/generated/nodes.rs
@@ -1808,41 +1808,6 @@ pub struct CssDocumentCustomMatcherFields {
     pub r_paren_token: SyntaxResult<SyntaxToken>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssElseKeyword {
-    pub(crate) syntax: SyntaxNode,
-}
-impl CssElseKeyword {
-    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
-    #[doc = r""]
-    #[doc = r" # Safety"]
-    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
-    #[doc = r" or a match on [SyntaxNode::kind]"]
-    #[inline]
-    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
-        Self { syntax }
-    }
-    pub fn as_fields(&self) -> CssElseKeywordFields {
-        CssElseKeywordFields {
-            else_token: self.else_token(),
-        }
-    }
-    pub fn else_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 0usize)
-    }
-}
-impl Serialize for CssElseKeyword {
-    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
-    where
-        S: Serializer,
-    {
-        self.as_fields().serialize(serializer)
-    }
-}
-#[derive(Serialize)]
-pub struct CssElseKeywordFields {
-    pub else_token: SyntaxResult<SyntaxToken>,
-}
-#[derive(Clone, PartialEq, Eq, Hash)]
 pub struct CssEmptyDeclaration {
     pub(crate) syntax: SyntaxNode,
 }
@@ -2408,10 +2373,10 @@ pub struct CssIdentifierFields {
     pub value_token: SyntaxResult<SyntaxToken>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssIfBranch {
+pub struct CssImportAnonymousLayer {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssIfBranch {
+impl CssImportAnonymousLayer {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -2421,24 +2386,16 @@ impl CssIfBranch {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssIfBranchFields {
-        CssIfBranchFields {
-            condition: self.condition(),
-            colon_token: self.colon_token(),
-            value: self.value(),
+    pub fn as_fields(&self) -> CssImportAnonymousLayerFields {
+        CssImportAnonymousLayerFields {
+            layer_token: self.layer_token(),
         }
     }
-    pub fn condition(&self) -> SyntaxResult<AnyCssIfCondition> {
-        support::required_node(&self.syntax, 0usize)
-    }
-    pub fn colon_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 1usize)
-    }
-    pub fn value(&self) -> CssGenericComponentValueList {
-        support::list(&self.syntax, 2usize)
+    pub fn layer_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 0usize)
     }
 }
-impl Serialize for CssIfBranch {
+impl Serialize for CssImportAnonymousLayer {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -2447,16 +2404,14 @@ impl Serialize for CssIfBranch {
     }
 }
 #[derive(Serialize)]
-pub struct CssIfBranchFields {
-    pub condition: SyntaxResult<AnyCssIfCondition>,
-    pub colon_token: SyntaxResult<SyntaxToken>,
-    pub value: CssGenericComponentValueList,
+pub struct CssImportAnonymousLayerFields {
+    pub layer_token: SyntaxResult<SyntaxToken>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssIfFunction {
+pub struct CssImportAtRule {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssIfFunction {
+impl CssImportAtRule {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -2466,28 +2421,36 @@ impl CssIfFunction {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssIfFunctionFields {
-        CssIfFunctionFields {
-            if_token: self.if_token(),
-            l_paren_token: self.l_paren_token(),
-            css_if_branch_list: self.css_if_branch_list(),
-            r_paren_token: self.r_paren_token(),
+    pub fn as_fields(&self) -> CssImportAtRuleFields {
+        CssImportAtRuleFields {
+            import_token: self.import_token(),
+            url: self.url(),
+            layer: self.layer(),
+            supports: self.supports(),
+            media: self.media(),
+            semicolon_token: self.semicolon_token(),
         }
     }
-    pub fn if_token(&self) -> SyntaxResult<SyntaxToken> {
+    pub fn import_token(&self) -> SyntaxResult<SyntaxToken> {
         support::required_token(&self.syntax, 0usize)
     }
-    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 1usize)
+    pub fn url(&self) -> SyntaxResult<AnyCssImportUrl> {
+        support::required_node(&self.syntax, 1usize)
     }
-    pub fn css_if_branch_list(&self) -> CssIfBranchList {
-        support::list(&self.syntax, 2usize)
+    pub fn layer(&self) -> Option<AnyCssImportLayer> {
+        support::node(&self.syntax, 2usize)
     }
-    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 3usize)
+    pub fn supports(&self) -> Option<CssImportSupports> {
+        support::node(&self.syntax, 3usize)
+    }
+    pub fn media(&self) -> CssMediaQueryList {
+        support::list(&self.syntax, 4usize)
+    }
+    pub fn semicolon_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 5usize)
     }
 }
-impl Serialize for CssIfFunction {
+impl Serialize for CssImportAtRule {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -2496,17 +2459,19 @@ impl Serialize for CssIfFunction {
     }
 }
 #[derive(Serialize)]
-pub struct CssIfFunctionFields {
-    pub if_token: SyntaxResult<SyntaxToken>,
-    pub l_paren_token: SyntaxResult<SyntaxToken>,
-    pub css_if_branch_list: CssIfBranchList,
-    pub r_paren_token: SyntaxResult<SyntaxToken>,
+pub struct CssImportAtRuleFields {
+    pub import_token: SyntaxResult<SyntaxToken>,
+    pub url: SyntaxResult<AnyCssImportUrl>,
+    pub layer: Option<AnyCssImportLayer>,
+    pub supports: Option<CssImportSupports>,
+    pub media: CssMediaQueryList,
+    pub semicolon_token: SyntaxResult<SyntaxToken>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssIfMediaTest {
+pub struct CssImportNamedLayer {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssIfMediaTest {
+impl CssImportNamedLayer {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -2516,28 +2481,28 @@ impl CssIfMediaTest {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssIfMediaTestFields {
-        CssIfMediaTestFields {
-            media_token: self.media_token(),
+    pub fn as_fields(&self) -> CssImportNamedLayerFields {
+        CssImportNamedLayerFields {
+            layer_token: self.layer_token(),
             l_paren_token: self.l_paren_token(),
-            test: self.test(),
+            name: self.name(),
             r_paren_token: self.r_paren_token(),
         }
     }
-    pub fn media_token(&self) -> SyntaxResult<SyntaxToken> {
+    pub fn layer_token(&self) -> SyntaxResult<SyntaxToken> {
         support::required_token(&self.syntax, 0usize)
     }
     pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
         support::required_token(&self.syntax, 1usize)
     }
-    pub fn test(&self) -> SyntaxResult<AnyCssIfMediaTestQuery> {
-        support::required_node(&self.syntax, 2usize)
+    pub fn name(&self) -> CssLayerNameList {
+        support::list(&self.syntax, 2usize)
     }
     pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
         support::required_token(&self.syntax, 3usize)
     }
 }
-impl Serialize for CssIfMediaTest {
+impl Serialize for CssImportNamedLayer {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -2546,17 +2511,17 @@ impl Serialize for CssIfMediaTest {
     }
 }
 #[derive(Serialize)]
-pub struct CssIfMediaTestFields {
-    pub media_token: SyntaxResult<SyntaxToken>,
+pub struct CssImportNamedLayerFields {
+    pub layer_token: SyntaxResult<SyntaxToken>,
     pub l_paren_token: SyntaxResult<SyntaxToken>,
-    pub test: SyntaxResult<AnyCssIfMediaTestQuery>,
+    pub name: CssLayerNameList,
     pub r_paren_token: SyntaxResult<SyntaxToken>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssIfStyleTest {
+pub struct CssImportSupports {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssIfStyleTest {
+impl CssImportSupports {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -2566,28 +2531,28 @@ impl CssIfStyleTest {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssIfStyleTestFields {
-        CssIfStyleTestFields {
-            style_token: self.style_token(),
+    pub fn as_fields(&self) -> CssImportSupportsFields {
+        CssImportSupportsFields {
+            supports_token: self.supports_token(),
             l_paren_token: self.l_paren_token(),
-            test: self.test(),
+            condition: self.condition(),
             r_paren_token: self.r_paren_token(),
         }
     }
-    pub fn style_token(&self) -> SyntaxResult<SyntaxToken> {
+    pub fn supports_token(&self) -> SyntaxResult<SyntaxToken> {
         support::required_token(&self.syntax, 0usize)
     }
     pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
         support::required_token(&self.syntax, 1usize)
     }
-    pub fn test(&self) -> SyntaxResult<AnyCssContainerStyleQuery> {
+    pub fn condition(&self) -> SyntaxResult<AnyCssImportSupportsCondition> {
         support::required_node(&self.syntax, 2usize)
     }
     pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
         support::required_token(&self.syntax, 3usize)
     }
 }
-impl Serialize for CssIfStyleTest {
+impl Serialize for CssImportSupports {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -2596,17 +2561,17 @@ impl Serialize for CssIfStyleTest {
     }
 }
 #[derive(Serialize)]
-pub struct CssIfStyleTestFields {
-    pub style_token: SyntaxResult<SyntaxToken>,
+pub struct CssImportSupportsFields {
+    pub supports_token: SyntaxResult<SyntaxToken>,
     pub l_paren_token: SyntaxResult<SyntaxToken>,
-    pub test: SyntaxResult<AnyCssContainerStyleQuery>,
+    pub condition: SyntaxResult<AnyCssImportSupportsCondition>,
     pub r_paren_token: SyntaxResult<SyntaxToken>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssIfSupportsIdentifierTest {
+pub struct CssKeyframesAtRule {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssIfSupportsIdentifierTest {
+impl CssKeyframesAtRule {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -2616,24 +2581,24 @@ impl CssIfSupportsIdentifierTest {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssIfSupportsIdentifierTestFields {
-        CssIfSupportsIdentifierTestFields {
-            ident: self.ident(),
-            colon_token: self.colon_token(),
-            value: self.value(),
+    pub fn as_fields(&self) -> CssKeyframesAtRuleFields {
+        CssKeyframesAtRuleFields {
+            keyframes_token: self.keyframes_token(),
+            name: self.name(),
+            block: self.block(),
         }
     }
-    pub fn ident(&self) -> SyntaxResult<CssIdentifier> {
-        support::required_node(&self.syntax, 0usize)
+    pub fn keyframes_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 0usize)
     }
-    pub fn colon_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 1usize)
+    pub fn name(&self) -> SyntaxResult<AnyCssKeyframesName> {
+        support::required_node(&self.syntax, 1usize)
     }
-    pub fn value(&self) -> SyntaxResult<AnyCssGenericComponentValue> {
+    pub fn block(&self) -> SyntaxResult<AnyCssKeyframesBlock> {
         support::required_node(&self.syntax, 2usize)
     }
 }
-impl Serialize for CssIfSupportsIdentifierTest {
+impl Serialize for CssKeyframesAtRule {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -2642,16 +2607,16 @@ impl Serialize for CssIfSupportsIdentifierTest {
     }
 }
 #[derive(Serialize)]
-pub struct CssIfSupportsIdentifierTestFields {
-    pub ident: SyntaxResult<CssIdentifier>,
-    pub colon_token: SyntaxResult<SyntaxToken>,
-    pub value: SyntaxResult<AnyCssGenericComponentValue>,
+pub struct CssKeyframesAtRuleFields {
+    pub keyframes_token: SyntaxResult<SyntaxToken>,
+    pub name: SyntaxResult<AnyCssKeyframesName>,
+    pub block: SyntaxResult<AnyCssKeyframesBlock>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssIfSupportsTest {
+pub struct CssKeyframesBlock {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssIfSupportsTest {
+impl CssKeyframesBlock {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -2661,28 +2626,24 @@ impl CssIfSupportsTest {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssIfSupportsTestFields {
-        CssIfSupportsTestFields {
-            supports_token: self.supports_token(),
-            l_paren_token: self.l_paren_token(),
-            test: self.test(),
-            r_paren_token: self.r_paren_token(),
+    pub fn as_fields(&self) -> CssKeyframesBlockFields {
+        CssKeyframesBlockFields {
+            l_curly_token: self.l_curly_token(),
+            items: self.items(),
+            r_curly_token: self.r_curly_token(),
         }
     }
-    pub fn supports_token(&self) -> SyntaxResult<SyntaxToken> {
+    pub fn l_curly_token(&self) -> SyntaxResult<SyntaxToken> {
         support::required_token(&self.syntax, 0usize)
     }
-    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 1usize)
-    }
-    pub fn test(&self) -> SyntaxResult<AnyCssIfSupportsTestCondition> {
-        support::required_node(&self.syntax, 2usize)
+    pub fn items(&self) -> CssKeyframesItemList {
+        support::list(&self.syntax, 1usize)
     }
-    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 3usize)
+    pub fn r_curly_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 2usize)
     }
 }
-impl Serialize for CssIfSupportsTest {
+impl Serialize for CssKeyframesBlock {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -2691,17 +2652,16 @@ impl Serialize for CssIfSupportsTest {
     }
 }
 #[derive(Serialize)]
-pub struct CssIfSupportsTestFields {
-    pub supports_token: SyntaxResult<SyntaxToken>,
-    pub l_paren_token: SyntaxResult<SyntaxToken>,
-    pub test: SyntaxResult<AnyCssIfSupportsTestCondition>,
-    pub r_paren_token: SyntaxResult<SyntaxToken>,
+pub struct CssKeyframesBlockFields {
+    pub l_curly_token: SyntaxResult<SyntaxToken>,
+    pub items: CssKeyframesItemList,
+    pub r_curly_token: SyntaxResult<SyntaxToken>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssIfTestBooleanAndExpr {
+pub struct CssKeyframesIdentSelector {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssIfTestBooleanAndExpr {
+impl CssKeyframesIdentSelector {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -2711,24 +2671,16 @@ impl CssIfTestBooleanAndExpr {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssIfTestBooleanAndExprFields {
-        CssIfTestBooleanAndExprFields {
-            left: self.left(),
-            and_token: self.and_token(),
-            right: self.right(),
+    pub fn as_fields(&self) -> CssKeyframesIdentSelectorFields {
+        CssKeyframesIdentSelectorFields {
+            selector: self.selector(),
         }
     }
-    pub fn left(&self) -> SyntaxResult<AnyCssIfTestBooleanExprGroup> {
-        support::required_node(&self.syntax, 0usize)
-    }
-    pub fn and_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 1usize)
-    }
-    pub fn right(&self) -> SyntaxResult<AnyCssIfTestBooleanAndCombinableExpr> {
-        support::required_node(&self.syntax, 2usize)
+    pub fn selector(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 0usize)
     }
 }
-impl Serialize for CssIfTestBooleanAndExpr {
+impl Serialize for CssKeyframesIdentSelector {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -2737,16 +2689,14 @@ impl Serialize for CssIfTestBooleanAndExpr {
     }
 }
 #[derive(Serialize)]
-pub struct CssIfTestBooleanAndExprFields {
-    pub left: SyntaxResult<AnyCssIfTestBooleanExprGroup>,
-    pub and_token: SyntaxResult<SyntaxToken>,
-    pub right: SyntaxResult<AnyCssIfTestBooleanAndCombinableExpr>,
+pub struct CssKeyframesIdentSelectorFields {
+    pub selector: SyntaxResult<SyntaxToken>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssIfTestBooleanExprInParens {
+pub struct CssKeyframesItem {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssIfTestBooleanExprInParens {
+impl CssKeyframesItem {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -2756,24 +2706,20 @@ impl CssIfTestBooleanExprInParens {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssIfTestBooleanExprInParensFields {
-        CssIfTestBooleanExprInParensFields {
-            l_paren_token: self.l_paren_token(),
-            expression: self.expression(),
-            r_paren_token: self.r_paren_token(),
+    pub fn as_fields(&self) -> CssKeyframesItemFields {
+        CssKeyframesItemFields {
+            selectors: self.selectors(),
+            block: self.block(),
         }
     }
-    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 0usize)
+    pub fn selectors(&self) -> CssKeyframesSelectorList {
+        support::list(&self.syntax, 0usize)
     }
-    pub fn expression(&self) -> SyntaxResult<AnyCssIfTestBooleanExpr> {
+    pub fn block(&self) -> SyntaxResult<AnyCssDeclarationBlock> {
         support::required_node(&self.syntax, 1usize)
     }
-    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 2usize)
-    }
 }
-impl Serialize for CssIfTestBooleanExprInParens {
+impl Serialize for CssKeyframesItem {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -2782,16 +2728,15 @@ impl Serialize for CssIfTestBooleanExprInParens {
     }
 }
 #[derive(Serialize)]
-pub struct CssIfTestBooleanExprInParensFields {
-    pub l_paren_token: SyntaxResult<SyntaxToken>,
-    pub expression: SyntaxResult<AnyCssIfTestBooleanExpr>,
-    pub r_paren_token: SyntaxResult<SyntaxToken>,
+pub struct CssKeyframesItemFields {
+    pub selectors: CssKeyframesSelectorList,
+    pub block: SyntaxResult<AnyCssDeclarationBlock>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssIfTestBooleanNotExpr {
+pub struct CssKeyframesPercentageSelector {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssIfTestBooleanNotExpr {
+impl CssKeyframesPercentageSelector {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -2801,20 +2746,16 @@ impl CssIfTestBooleanNotExpr {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssIfTestBooleanNotExprFields {
-        CssIfTestBooleanNotExprFields {
-            not_token: self.not_token(),
-            expression: self.expression(),
+    pub fn as_fields(&self) -> CssKeyframesPercentageSelectorFields {
+        CssKeyframesPercentageSelectorFields {
+            selector: self.selector(),
         }
     }
-    pub fn not_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 0usize)
-    }
-    pub fn expression(&self) -> SyntaxResult<AnyCssIfTestBooleanExprGroup> {
-        support::required_node(&self.syntax, 1usize)
+    pub fn selector(&self) -> SyntaxResult<CssPercentage> {
+        support::required_node(&self.syntax, 0usize)
     }
 }
-impl Serialize for CssIfTestBooleanNotExpr {
+impl Serialize for CssKeyframesPercentageSelector {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -2823,15 +2764,14 @@ impl Serialize for CssIfTestBooleanNotExpr {
     }
 }
 #[derive(Serialize)]
-pub struct CssIfTestBooleanNotExprFields {
-    pub not_token: SyntaxResult<SyntaxToken>,
-    pub expression: SyntaxResult<AnyCssIfTestBooleanExprGroup>,
+pub struct CssKeyframesPercentageSelectorFields {
+    pub selector: SyntaxResult<CssPercentage>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssIfTestBooleanOrExpr {
+pub struct CssKeyframesScopeFunction {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssIfTestBooleanOrExpr {
+impl CssKeyframesScopeFunction {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -2841,24 +2781,28 @@ impl CssIfTestBooleanOrExpr {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssIfTestBooleanOrExprFields {
-        CssIfTestBooleanOrExprFields {
-            left: self.left(),
-            or_token: self.or_token(),
-            right: self.right(),
+    pub fn as_fields(&self) -> CssKeyframesScopeFunctionFields {
+        CssKeyframesScopeFunctionFields {
+            scope: self.scope(),
+            l_paren_token: self.l_paren_token(),
+            name: self.name(),
+            r_paren_token: self.r_paren_token(),
         }
     }
-    pub fn left(&self) -> SyntaxResult<AnyCssIfTestBooleanExprGroup> {
-        support::required_node(&self.syntax, 0usize)
+    pub fn scope(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 0usize)
     }
-    pub fn or_token(&self) -> SyntaxResult<SyntaxToken> {
+    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
         support::required_token(&self.syntax, 1usize)
     }
-    pub fn right(&self) -> SyntaxResult<AnyCssIfTestBooleanOrCombinableExpr> {
+    pub fn name(&self) -> SyntaxResult<AnyCssKeyframesIdentifier> {
         support::required_node(&self.syntax, 2usize)
     }
+    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 3usize)
+    }
 }
-impl Serialize for CssIfTestBooleanOrExpr {
+impl Serialize for CssKeyframesScopeFunction {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -2867,16 +2811,17 @@ impl Serialize for CssIfTestBooleanOrExpr {
     }
 }
 #[derive(Serialize)]
-pub struct CssIfTestBooleanOrExprFields {
-    pub left: SyntaxResult<AnyCssIfTestBooleanExprGroup>,
-    pub or_token: SyntaxResult<SyntaxToken>,
-    pub right: SyntaxResult<AnyCssIfTestBooleanOrCombinableExpr>,
+pub struct CssKeyframesScopeFunctionFields {
+    pub scope: SyntaxResult<SyntaxToken>,
+    pub l_paren_token: SyntaxResult<SyntaxToken>,
+    pub name: SyntaxResult<AnyCssKeyframesIdentifier>,
+    pub r_paren_token: SyntaxResult<SyntaxToken>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssImportAnonymousLayer {
+pub struct CssKeyframesScopePrefix {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssImportAnonymousLayer {
+impl CssKeyframesScopePrefix {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -2886,16 +2831,20 @@ impl CssImportAnonymousLayer {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssImportAnonymousLayerFields {
-        CssImportAnonymousLayerFields {
-            layer_token: self.layer_token(),
+    pub fn as_fields(&self) -> CssKeyframesScopePrefixFields {
+        CssKeyframesScopePrefixFields {
+            scope: self.scope(),
+            name: self.name(),
         }
     }
-    pub fn layer_token(&self) -> SyntaxResult<SyntaxToken> {
+    pub fn scope(&self) -> SyntaxResult<SyntaxToken> {
         support::required_token(&self.syntax, 0usize)
     }
+    pub fn name(&self) -> SyntaxResult<AnyCssKeyframesIdentifier> {
+        support::required_node(&self.syntax, 1usize)
+    }
 }
-impl Serialize for CssImportAnonymousLayer {
+impl Serialize for CssKeyframesScopePrefix {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -2904,14 +2853,15 @@ impl Serialize for CssImportAnonymousLayer {
     }
 }
 #[derive(Serialize)]
-pub struct CssImportAnonymousLayerFields {
-    pub layer_token: SyntaxResult<SyntaxToken>,
+pub struct CssKeyframesScopePrefixFields {
+    pub scope: SyntaxResult<SyntaxToken>,
+    pub name: SyntaxResult<AnyCssKeyframesIdentifier>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssImportAtRule {
+pub struct CssKeyframesScopedName {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssImportAtRule {
+impl CssKeyframesScopedName {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -2921,36 +2871,20 @@ impl CssImportAtRule {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssImportAtRuleFields {
-        CssImportAtRuleFields {
-            import_token: self.import_token(),
-            url: self.url(),
-            layer: self.layer(),
-            supports: self.supports(),
-            media: self.media(),
-            semicolon_token: self.semicolon_token(),
+    pub fn as_fields(&self) -> CssKeyframesScopedNameFields {
+        CssKeyframesScopedNameFields {
+            colon_token: self.colon_token(),
+            scope: self.scope(),
         }
     }
-    pub fn import_token(&self) -> SyntaxResult<SyntaxToken> {
+    pub fn colon_token(&self) -> SyntaxResult<SyntaxToken> {
         support::required_token(&self.syntax, 0usize)
     }
-    pub fn url(&self) -> SyntaxResult<AnyCssImportUrl> {
+    pub fn scope(&self) -> SyntaxResult<AnyCssKeyframesScope> {
         support::required_node(&self.syntax, 1usize)
     }
-    pub fn layer(&self) -> Option<AnyCssImportLayer> {
-        support::node(&self.syntax, 2usize)
-    }
-    pub fn supports(&self) -> Option<CssImportSupports> {
-        support::node(&self.syntax, 3usize)
-    }
-    pub fn media(&self) -> CssMediaQueryList {
-        support::list(&self.syntax, 4usize)
-    }
-    pub fn semicolon_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 5usize)
-    }
 }
-impl Serialize for CssImportAtRule {
+impl Serialize for CssKeyframesScopedName {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -2959,19 +2893,15 @@ impl Serialize for CssImportAtRule {
     }
 }
 #[derive(Serialize)]
-pub struct CssImportAtRuleFields {
-    pub import_token: SyntaxResult<SyntaxToken>,
-    pub url: SyntaxResult<AnyCssImportUrl>,
-    pub layer: Option<AnyCssImportLayer>,
-    pub supports: Option<CssImportSupports>,
-    pub media: CssMediaQueryList,
-    pub semicolon_token: SyntaxResult<SyntaxToken>,
+pub struct CssKeyframesScopedNameFields {
+    pub colon_token: SyntaxResult<SyntaxToken>,
+    pub scope: SyntaxResult<AnyCssKeyframesScope>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssImportNamedLayer {
+pub struct CssLayerAtRule {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssImportNamedLayer {
+impl CssLayerAtRule {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -2981,28 +2911,20 @@ impl CssImportNamedLayer {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssImportNamedLayerFields {
-        CssImportNamedLayerFields {
+    pub fn as_fields(&self) -> CssLayerAtRuleFields {
+        CssLayerAtRuleFields {
             layer_token: self.layer_token(),
-            l_paren_token: self.l_paren_token(),
-            name: self.name(),
-            r_paren_token: self.r_paren_token(),
+            layer: self.layer(),
         }
     }
     pub fn layer_token(&self) -> SyntaxResult<SyntaxToken> {
         support::required_token(&self.syntax, 0usize)
     }
-    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 1usize)
-    }
-    pub fn name(&self) -> CssLayerNameList {
-        support::list(&self.syntax, 2usize)
-    }
-    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 3usize)
+    pub fn layer(&self) -> SyntaxResult<AnyCssLayer> {
+        support::required_node(&self.syntax, 1usize)
     }
 }
-impl Serialize for CssImportNamedLayer {
+impl Serialize for CssLayerAtRule {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -3011,17 +2933,15 @@ impl Serialize for CssImportNamedLayer {
     }
 }
 #[derive(Serialize)]
-pub struct CssImportNamedLayerFields {
+pub struct CssLayerAtRuleFields {
     pub layer_token: SyntaxResult<SyntaxToken>,
-    pub l_paren_token: SyntaxResult<SyntaxToken>,
-    pub name: CssLayerNameList,
-    pub r_paren_token: SyntaxResult<SyntaxToken>,
+    pub layer: SyntaxResult<AnyCssLayer>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssImportSupports {
+pub struct CssLayerDeclaration {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssImportSupports {
+impl CssLayerDeclaration {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -3031,28 +2951,20 @@ impl CssImportSupports {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssImportSupportsFields {
-        CssImportSupportsFields {
-            supports_token: self.supports_token(),
-            l_paren_token: self.l_paren_token(),
-            condition: self.condition(),
-            r_paren_token: self.r_paren_token(),
+    pub fn as_fields(&self) -> CssLayerDeclarationFields {
+        CssLayerDeclarationFields {
+            references: self.references(),
+            block: self.block(),
         }
     }
-    pub fn supports_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 0usize)
-    }
-    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 1usize)
-    }
-    pub fn condition(&self) -> SyntaxResult<AnyCssImportSupportsCondition> {
-        support::required_node(&self.syntax, 2usize)
+    pub fn references(&self) -> CssLayerReferenceList {
+        support::list(&self.syntax, 0usize)
     }
-    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 3usize)
+    pub fn block(&self) -> SyntaxResult<AnyCssConditionalBlock> {
+        support::required_node(&self.syntax, 1usize)
     }
 }
-impl Serialize for CssImportSupports {
+impl Serialize for CssLayerDeclaration {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -3061,17 +2973,15 @@ impl Serialize for CssImportSupports {
     }
 }
 #[derive(Serialize)]
-pub struct CssImportSupportsFields {
-    pub supports_token: SyntaxResult<SyntaxToken>,
-    pub l_paren_token: SyntaxResult<SyntaxToken>,
-    pub condition: SyntaxResult<AnyCssImportSupportsCondition>,
-    pub r_paren_token: SyntaxResult<SyntaxToken>,
+pub struct CssLayerDeclarationFields {
+    pub references: CssLayerReferenceList,
+    pub block: SyntaxResult<AnyCssConditionalBlock>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssKeyframesAtRule {
+pub struct CssLayerReference {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssKeyframesAtRule {
+impl CssLayerReference {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -3081,24 +2991,20 @@ impl CssKeyframesAtRule {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssKeyframesAtRuleFields {
-        CssKeyframesAtRuleFields {
-            keyframes_token: self.keyframes_token(),
-            name: self.name(),
-            block: self.block(),
+    pub fn as_fields(&self) -> CssLayerReferenceFields {
+        CssLayerReferenceFields {
+            references: self.references(),
+            semicolon_token: self.semicolon_token(),
         }
     }
-    pub fn keyframes_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 0usize)
-    }
-    pub fn name(&self) -> SyntaxResult<AnyCssKeyframesName> {
-        support::required_node(&self.syntax, 1usize)
+    pub fn references(&self) -> CssLayerReferenceList {
+        support::list(&self.syntax, 0usize)
     }
-    pub fn block(&self) -> SyntaxResult<AnyCssKeyframesBlock> {
-        support::required_node(&self.syntax, 2usize)
+    pub fn semicolon_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 1usize)
     }
 }
-impl Serialize for CssKeyframesAtRule {
+impl Serialize for CssLayerReference {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -3107,16 +3013,15 @@ impl Serialize for CssKeyframesAtRule {
     }
 }
 #[derive(Serialize)]
-pub struct CssKeyframesAtRuleFields {
-    pub keyframes_token: SyntaxResult<SyntaxToken>,
-    pub name: SyntaxResult<AnyCssKeyframesName>,
-    pub block: SyntaxResult<AnyCssKeyframesBlock>,
+pub struct CssLayerReferenceFields {
+    pub references: CssLayerReferenceList,
+    pub semicolon_token: SyntaxResult<SyntaxToken>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssKeyframesBlock {
+pub struct CssListOfComponentValuesExpression {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssKeyframesBlock {
+impl CssListOfComponentValuesExpression {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -3126,24 +3031,16 @@ impl CssKeyframesBlock {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssKeyframesBlockFields {
-        CssKeyframesBlockFields {
-            l_curly_token: self.l_curly_token(),
-            items: self.items(),
-            r_curly_token: self.r_curly_token(),
+    pub fn as_fields(&self) -> CssListOfComponentValuesExpressionFields {
+        CssListOfComponentValuesExpressionFields {
+            css_component_value_list: self.css_component_value_list(),
         }
     }
-    pub fn l_curly_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 0usize)
-    }
-    pub fn items(&self) -> CssKeyframesItemList {
-        support::list(&self.syntax, 1usize)
-    }
-    pub fn r_curly_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 2usize)
+    pub fn css_component_value_list(&self) -> CssComponentValueList {
+        support::list(&self.syntax, 0usize)
     }
 }
-impl Serialize for CssKeyframesBlock {
+impl Serialize for CssListOfComponentValuesExpression {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -3152,16 +3049,14 @@ impl Serialize for CssKeyframesBlock {
     }
 }
 #[derive(Serialize)]
-pub struct CssKeyframesBlockFields {
-    pub l_curly_token: SyntaxResult<SyntaxToken>,
-    pub items: CssKeyframesItemList,
-    pub r_curly_token: SyntaxResult<SyntaxToken>,
+pub struct CssListOfComponentValuesExpressionFields {
+    pub css_component_value_list: CssComponentValueList,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssKeyframesIdentSelector {
+pub struct CssMarginAtRule {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssKeyframesIdentSelector {
+impl CssMarginAtRule {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -3171,16 +3066,24 @@ impl CssKeyframesIdentSelector {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssKeyframesIdentSelectorFields {
-        CssKeyframesIdentSelectorFields {
-            selector: self.selector(),
+    pub fn as_fields(&self) -> CssMarginAtRuleFields {
+        CssMarginAtRuleFields {
+            at_token: self.at_token(),
+            name: self.name(),
+            block: self.block(),
         }
     }
-    pub fn selector(&self) -> SyntaxResult<SyntaxToken> {
+    pub fn at_token(&self) -> SyntaxResult<SyntaxToken> {
         support::required_token(&self.syntax, 0usize)
     }
+    pub fn name(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 1usize)
+    }
+    pub fn block(&self) -> SyntaxResult<AnyCssDeclarationOrAtRuleBlock> {
+        support::required_node(&self.syntax, 2usize)
+    }
 }
-impl Serialize for CssKeyframesIdentSelector {
+impl Serialize for CssMarginAtRule {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -3189,14 +3092,16 @@ impl Serialize for CssKeyframesIdentSelector {
     }
 }
 #[derive(Serialize)]
-pub struct CssKeyframesIdentSelectorFields {
-    pub selector: SyntaxResult<SyntaxToken>,
+pub struct CssMarginAtRuleFields {
+    pub at_token: SyntaxResult<SyntaxToken>,
+    pub name: SyntaxResult<SyntaxToken>,
+    pub block: SyntaxResult<AnyCssDeclarationOrAtRuleBlock>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssKeyframesItem {
+pub struct CssMediaAndCondition {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssKeyframesItem {
+impl CssMediaAndCondition {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -3206,20 +3111,24 @@ impl CssKeyframesItem {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssKeyframesItemFields {
-        CssKeyframesItemFields {
-            selectors: self.selectors(),
-            block: self.block(),
+    pub fn as_fields(&self) -> CssMediaAndConditionFields {
+        CssMediaAndConditionFields {
+            left: self.left(),
+            and_token: self.and_token(),
+            right: self.right(),
         }
     }
-    pub fn selectors(&self) -> CssKeyframesSelectorList {
-        support::list(&self.syntax, 0usize)
+    pub fn left(&self) -> SyntaxResult<AnyCssMediaInParens> {
+        support::required_node(&self.syntax, 0usize)
     }
-    pub fn block(&self) -> SyntaxResult<AnyCssDeclarationBlock> {
-        support::required_node(&self.syntax, 1usize)
+    pub fn and_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 1usize)
     }
-}
-impl Serialize for CssKeyframesItem {
+    pub fn right(&self) -> SyntaxResult<AnyCssMediaAndCombinableCondition> {
+        support::required_node(&self.syntax, 2usize)
+    }
+}
+impl Serialize for CssMediaAndCondition {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -3228,15 +3137,16 @@ impl Serialize for CssKeyframesItem {
     }
 }
 #[derive(Serialize)]
-pub struct CssKeyframesItemFields {
-    pub selectors: CssKeyframesSelectorList,
-    pub block: SyntaxResult<AnyCssDeclarationBlock>,
+pub struct CssMediaAndConditionFields {
+    pub left: SyntaxResult<AnyCssMediaInParens>,
+    pub and_token: SyntaxResult<SyntaxToken>,
+    pub right: SyntaxResult<AnyCssMediaAndCombinableCondition>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssKeyframesPercentageSelector {
+pub struct CssMediaAndTypeQuery {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssKeyframesPercentageSelector {
+impl CssMediaAndTypeQuery {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -3246,16 +3156,24 @@ impl CssKeyframesPercentageSelector {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssKeyframesPercentageSelectorFields {
-        CssKeyframesPercentageSelectorFields {
-            selector: self.selector(),
+    pub fn as_fields(&self) -> CssMediaAndTypeQueryFields {
+        CssMediaAndTypeQueryFields {
+            left: self.left(),
+            and_token: self.and_token(),
+            right: self.right(),
         }
     }
-    pub fn selector(&self) -> SyntaxResult<CssPercentage> {
+    pub fn left(&self) -> SyntaxResult<CssMediaTypeQuery> {
         support::required_node(&self.syntax, 0usize)
     }
+    pub fn and_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 1usize)
+    }
+    pub fn right(&self) -> SyntaxResult<AnyCssMediaTypeCondition> {
+        support::required_node(&self.syntax, 2usize)
+    }
 }
-impl Serialize for CssKeyframesPercentageSelector {
+impl Serialize for CssMediaAndTypeQuery {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -3264,14 +3182,16 @@ impl Serialize for CssKeyframesPercentageSelector {
     }
 }
 #[derive(Serialize)]
-pub struct CssKeyframesPercentageSelectorFields {
-    pub selector: SyntaxResult<CssPercentage>,
+pub struct CssMediaAndTypeQueryFields {
+    pub left: SyntaxResult<CssMediaTypeQuery>,
+    pub and_token: SyntaxResult<SyntaxToken>,
+    pub right: SyntaxResult<AnyCssMediaTypeCondition>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssKeyframesScopeFunction {
+pub struct CssMediaAtRule {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssKeyframesScopeFunction {
+impl CssMediaAtRule {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -3281,28 +3201,20 @@ impl CssKeyframesScopeFunction {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssKeyframesScopeFunctionFields {
-        CssKeyframesScopeFunctionFields {
-            scope: self.scope(),
-            l_paren_token: self.l_paren_token(),
-            name: self.name(),
-            r_paren_token: self.r_paren_token(),
+    pub fn as_fields(&self) -> CssMediaAtRuleFields {
+        CssMediaAtRuleFields {
+            declarator: self.declarator(),
+            block: self.block(),
         }
     }
-    pub fn scope(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 0usize)
-    }
-    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 1usize)
-    }
-    pub fn name(&self) -> SyntaxResult<AnyCssKeyframesIdentifier> {
-        support::required_node(&self.syntax, 2usize)
+    pub fn declarator(&self) -> SyntaxResult<CssMediaAtRuleDeclarator> {
+        support::required_node(&self.syntax, 0usize)
     }
-    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 3usize)
+    pub fn block(&self) -> SyntaxResult<AnyCssConditionalBlock> {
+        support::required_node(&self.syntax, 1usize)
     }
 }
-impl Serialize for CssKeyframesScopeFunction {
+impl Serialize for CssMediaAtRule {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -3311,17 +3223,15 @@ impl Serialize for CssKeyframesScopeFunction {
     }
 }
 #[derive(Serialize)]
-pub struct CssKeyframesScopeFunctionFields {
-    pub scope: SyntaxResult<SyntaxToken>,
-    pub l_paren_token: SyntaxResult<SyntaxToken>,
-    pub name: SyntaxResult<AnyCssKeyframesIdentifier>,
-    pub r_paren_token: SyntaxResult<SyntaxToken>,
+pub struct CssMediaAtRuleFields {
+    pub declarator: SyntaxResult<CssMediaAtRuleDeclarator>,
+    pub block: SyntaxResult<AnyCssConditionalBlock>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssKeyframesScopePrefix {
+pub struct CssMediaAtRuleDeclarator {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssKeyframesScopePrefix {
+impl CssMediaAtRuleDeclarator {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -3331,20 +3241,20 @@ impl CssKeyframesScopePrefix {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssKeyframesScopePrefixFields {
-        CssKeyframesScopePrefixFields {
-            scope: self.scope(),
-            name: self.name(),
+    pub fn as_fields(&self) -> CssMediaAtRuleDeclaratorFields {
+        CssMediaAtRuleDeclaratorFields {
+            media_token: self.media_token(),
+            queries: self.queries(),
         }
     }
-    pub fn scope(&self) -> SyntaxResult<SyntaxToken> {
+    pub fn media_token(&self) -> SyntaxResult<SyntaxToken> {
         support::required_token(&self.syntax, 0usize)
     }
-    pub fn name(&self) -> SyntaxResult<AnyCssKeyframesIdentifier> {
-        support::required_node(&self.syntax, 1usize)
+    pub fn queries(&self) -> CssMediaQueryList {
+        support::list(&self.syntax, 1usize)
     }
 }
-impl Serialize for CssKeyframesScopePrefix {
+impl Serialize for CssMediaAtRuleDeclarator {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -3353,15 +3263,15 @@ impl Serialize for CssKeyframesScopePrefix {
     }
 }
 #[derive(Serialize)]
-pub struct CssKeyframesScopePrefixFields {
-    pub scope: SyntaxResult<SyntaxToken>,
-    pub name: SyntaxResult<AnyCssKeyframesIdentifier>,
+pub struct CssMediaAtRuleDeclaratorFields {
+    pub media_token: SyntaxResult<SyntaxToken>,
+    pub queries: CssMediaQueryList,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssKeyframesScopedName {
+pub struct CssMediaConditionInParens {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssKeyframesScopedName {
+impl CssMediaConditionInParens {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -3371,20 +3281,24 @@ impl CssKeyframesScopedName {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssKeyframesScopedNameFields {
-        CssKeyframesScopedNameFields {
-            colon_token: self.colon_token(),
-            scope: self.scope(),
+    pub fn as_fields(&self) -> CssMediaConditionInParensFields {
+        CssMediaConditionInParensFields {
+            l_paren_token: self.l_paren_token(),
+            condition: self.condition(),
+            r_paren_token: self.r_paren_token(),
         }
     }
-    pub fn colon_token(&self) -> SyntaxResult<SyntaxToken> {
+    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
         support::required_token(&self.syntax, 0usize)
     }
-    pub fn scope(&self) -> SyntaxResult<AnyCssKeyframesScope> {
+    pub fn condition(&self) -> SyntaxResult<AnyCssMediaCondition> {
         support::required_node(&self.syntax, 1usize)
     }
+    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 2usize)
+    }
 }
-impl Serialize for CssKeyframesScopedName {
+impl Serialize for CssMediaConditionInParens {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -3393,15 +3307,16 @@ impl Serialize for CssKeyframesScopedName {
     }
 }
 #[derive(Serialize)]
-pub struct CssKeyframesScopedNameFields {
-    pub colon_token: SyntaxResult<SyntaxToken>,
-    pub scope: SyntaxResult<AnyCssKeyframesScope>,
+pub struct CssMediaConditionInParensFields {
+    pub l_paren_token: SyntaxResult<SyntaxToken>,
+    pub condition: SyntaxResult<AnyCssMediaCondition>,
+    pub r_paren_token: SyntaxResult<SyntaxToken>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssLayerAtRule {
+pub struct CssMediaConditionQuery {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssLayerAtRule {
+impl CssMediaConditionQuery {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -3411,20 +3326,16 @@ impl CssLayerAtRule {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssLayerAtRuleFields {
-        CssLayerAtRuleFields {
-            layer_token: self.layer_token(),
-            layer: self.layer(),
+    pub fn as_fields(&self) -> CssMediaConditionQueryFields {
+        CssMediaConditionQueryFields {
+            condition: self.condition(),
         }
     }
-    pub fn layer_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 0usize)
-    }
-    pub fn layer(&self) -> SyntaxResult<AnyCssLayer> {
-        support::required_node(&self.syntax, 1usize)
+    pub fn condition(&self) -> SyntaxResult<AnyCssMediaCondition> {
+        support::required_node(&self.syntax, 0usize)
     }
 }
-impl Serialize for CssLayerAtRule {
+impl Serialize for CssMediaConditionQuery {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -3433,15 +3344,14 @@ impl Serialize for CssLayerAtRule {
     }
 }
 #[derive(Serialize)]
-pub struct CssLayerAtRuleFields {
-    pub layer_token: SyntaxResult<SyntaxToken>,
-    pub layer: SyntaxResult<AnyCssLayer>,
+pub struct CssMediaConditionQueryFields {
+    pub condition: SyntaxResult<AnyCssMediaCondition>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssLayerDeclaration {
+pub struct CssMediaFeatureInParens {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssLayerDeclaration {
+impl CssMediaFeatureInParens {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -3451,20 +3361,24 @@ impl CssLayerDeclaration {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssLayerDeclarationFields {
-        CssLayerDeclarationFields {
-            references: self.references(),
-            block: self.block(),
+    pub fn as_fields(&self) -> CssMediaFeatureInParensFields {
+        CssMediaFeatureInParensFields {
+            l_paren_token: self.l_paren_token(),
+            feature: self.feature(),
+            r_paren_token: self.r_paren_token(),
         }
     }
-    pub fn references(&self) -> CssLayerReferenceList {
-        support::list(&self.syntax, 0usize)
+    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 0usize)
     }
-    pub fn block(&self) -> SyntaxResult<AnyCssConditionalBlock> {
+    pub fn feature(&self) -> SyntaxResult<AnyCssQueryFeature> {
         support::required_node(&self.syntax, 1usize)
     }
+    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 2usize)
+    }
 }
-impl Serialize for CssLayerDeclaration {
+impl Serialize for CssMediaFeatureInParens {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -3473,15 +3387,16 @@ impl Serialize for CssLayerDeclaration {
     }
 }
 #[derive(Serialize)]
-pub struct CssLayerDeclarationFields {
-    pub references: CssLayerReferenceList,
-    pub block: SyntaxResult<AnyCssConditionalBlock>,
+pub struct CssMediaFeatureInParensFields {
+    pub l_paren_token: SyntaxResult<SyntaxToken>,
+    pub feature: SyntaxResult<AnyCssQueryFeature>,
+    pub r_paren_token: SyntaxResult<SyntaxToken>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssLayerReference {
+pub struct CssMediaNotCondition {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssLayerReference {
+impl CssMediaNotCondition {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -3491,20 +3406,20 @@ impl CssLayerReference {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssLayerReferenceFields {
-        CssLayerReferenceFields {
-            references: self.references(),
-            semicolon_token: self.semicolon_token(),
+    pub fn as_fields(&self) -> CssMediaNotConditionFields {
+        CssMediaNotConditionFields {
+            not_token: self.not_token(),
+            condition: self.condition(),
         }
     }
-    pub fn references(&self) -> CssLayerReferenceList {
-        support::list(&self.syntax, 0usize)
+    pub fn not_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 0usize)
     }
-    pub fn semicolon_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 1usize)
+    pub fn condition(&self) -> SyntaxResult<AnyCssMediaInParens> {
+        support::required_node(&self.syntax, 1usize)
     }
 }
-impl Serialize for CssLayerReference {
+impl Serialize for CssMediaNotCondition {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -3513,15 +3428,15 @@ impl Serialize for CssLayerReference {
     }
 }
 #[derive(Serialize)]
-pub struct CssLayerReferenceFields {
-    pub references: CssLayerReferenceList,
-    pub semicolon_token: SyntaxResult<SyntaxToken>,
+pub struct CssMediaNotConditionFields {
+    pub not_token: SyntaxResult<SyntaxToken>,
+    pub condition: SyntaxResult<AnyCssMediaInParens>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssListOfComponentValuesExpression {
+pub struct CssMediaOrCondition {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssListOfComponentValuesExpression {
+impl CssMediaOrCondition {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -3531,16 +3446,24 @@ impl CssListOfComponentValuesExpression {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssListOfComponentValuesExpressionFields {
-        CssListOfComponentValuesExpressionFields {
-            css_component_value_list: self.css_component_value_list(),
+    pub fn as_fields(&self) -> CssMediaOrConditionFields {
+        CssMediaOrConditionFields {
+            left: self.left(),
+            or_token: self.or_token(),
+            right: self.right(),
         }
     }
-    pub fn css_component_value_list(&self) -> CssComponentValueList {
-        support::list(&self.syntax, 0usize)
+    pub fn left(&self) -> SyntaxResult<AnyCssMediaInParens> {
+        support::required_node(&self.syntax, 0usize)
+    }
+    pub fn or_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 1usize)
+    }
+    pub fn right(&self) -> SyntaxResult<AnyCssMediaOrCombinableCondition> {
+        support::required_node(&self.syntax, 2usize)
     }
 }
-impl Serialize for CssListOfComponentValuesExpression {
+impl Serialize for CssMediaOrCondition {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -3549,14 +3472,16 @@ impl Serialize for CssListOfComponentValuesExpression {
     }
 }
 #[derive(Serialize)]
-pub struct CssListOfComponentValuesExpressionFields {
-    pub css_component_value_list: CssComponentValueList,
+pub struct CssMediaOrConditionFields {
+    pub left: SyntaxResult<AnyCssMediaInParens>,
+    pub or_token: SyntaxResult<SyntaxToken>,
+    pub right: SyntaxResult<AnyCssMediaOrCombinableCondition>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssMarginAtRule {
+pub struct CssMediaType {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssMarginAtRule {
+impl CssMediaType {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -3566,24 +3491,16 @@ impl CssMarginAtRule {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssMarginAtRuleFields {
-        CssMarginAtRuleFields {
-            at_token: self.at_token(),
-            name: self.name(),
-            block: self.block(),
+    pub fn as_fields(&self) -> CssMediaTypeFields {
+        CssMediaTypeFields {
+            value: self.value(),
         }
     }
-    pub fn at_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 0usize)
-    }
-    pub fn name(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 1usize)
-    }
-    pub fn block(&self) -> SyntaxResult<AnyCssDeclarationOrAtRuleBlock> {
-        support::required_node(&self.syntax, 2usize)
+    pub fn value(&self) -> SyntaxResult<CssIdentifier> {
+        support::required_node(&self.syntax, 0usize)
     }
 }
-impl Serialize for CssMarginAtRule {
+impl Serialize for CssMediaType {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -3592,16 +3509,14 @@ impl Serialize for CssMarginAtRule {
     }
 }
 #[derive(Serialize)]
-pub struct CssMarginAtRuleFields {
-    pub at_token: SyntaxResult<SyntaxToken>,
-    pub name: SyntaxResult<SyntaxToken>,
-    pub block: SyntaxResult<AnyCssDeclarationOrAtRuleBlock>,
+pub struct CssMediaTypeFields {
+    pub value: SyntaxResult<CssIdentifier>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssMediaAndCondition {
+pub struct CssMediaTypeQuery {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssMediaAndCondition {
+impl CssMediaTypeQuery {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -3611,24 +3526,20 @@ impl CssMediaAndCondition {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssMediaAndConditionFields {
-        CssMediaAndConditionFields {
-            left: self.left(),
-            and_token: self.and_token(),
-            right: self.right(),
+    pub fn as_fields(&self) -> CssMediaTypeQueryFields {
+        CssMediaTypeQueryFields {
+            modifier: self.modifier(),
+            ty: self.ty(),
         }
     }
-    pub fn left(&self) -> SyntaxResult<AnyCssMediaInParens> {
-        support::required_node(&self.syntax, 0usize)
-    }
-    pub fn and_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 1usize)
+    pub fn modifier(&self) -> Option<SyntaxToken> {
+        support::token(&self.syntax, 0usize)
     }
-    pub fn right(&self) -> SyntaxResult<AnyCssMediaAndCombinableCondition> {
-        support::required_node(&self.syntax, 2usize)
+    pub fn ty(&self) -> SyntaxResult<CssMediaType> {
+        support::required_node(&self.syntax, 1usize)
     }
 }
-impl Serialize for CssMediaAndCondition {
+impl Serialize for CssMediaTypeQuery {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -3637,16 +3548,15 @@ impl Serialize for CssMediaAndCondition {
     }
 }
 #[derive(Serialize)]
-pub struct CssMediaAndConditionFields {
-    pub left: SyntaxResult<AnyCssMediaInParens>,
-    pub and_token: SyntaxResult<SyntaxToken>,
-    pub right: SyntaxResult<AnyCssMediaAndCombinableCondition>,
+pub struct CssMediaTypeQueryFields {
+    pub modifier: Option<SyntaxToken>,
+    pub ty: SyntaxResult<CssMediaType>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssMediaAndTypeQuery {
+pub struct CssMetavariable {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssMediaAndTypeQuery {
+impl CssMetavariable {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -3656,24 +3566,16 @@ impl CssMediaAndTypeQuery {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssMediaAndTypeQueryFields {
-        CssMediaAndTypeQueryFields {
-            left: self.left(),
-            and_token: self.and_token(),
-            right: self.right(),
+    pub fn as_fields(&self) -> CssMetavariableFields {
+        CssMetavariableFields {
+            value_token: self.value_token(),
         }
     }
-    pub fn left(&self) -> SyntaxResult<CssMediaTypeQuery> {
-        support::required_node(&self.syntax, 0usize)
-    }
-    pub fn and_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 1usize)
-    }
-    pub fn right(&self) -> SyntaxResult<AnyCssMediaTypeCondition> {
-        support::required_node(&self.syntax, 2usize)
+    pub fn value_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 0usize)
     }
 }
-impl Serialize for CssMediaAndTypeQuery {
+impl Serialize for CssMetavariable {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -3682,16 +3584,14 @@ impl Serialize for CssMediaAndTypeQuery {
     }
 }
 #[derive(Serialize)]
-pub struct CssMediaAndTypeQueryFields {
-    pub left: SyntaxResult<CssMediaTypeQuery>,
-    pub and_token: SyntaxResult<SyntaxToken>,
-    pub right: SyntaxResult<AnyCssMediaTypeCondition>,
+pub struct CssMetavariableFields {
+    pub value_token: SyntaxResult<SyntaxToken>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssMediaAtRule {
+pub struct CssNamedNamespacePrefix {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssMediaAtRule {
+impl CssNamedNamespacePrefix {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -3701,20 +3601,14 @@ impl CssMediaAtRule {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssMediaAtRuleFields {
-        CssMediaAtRuleFields {
-            declarator: self.declarator(),
-            block: self.block(),
-        }
+    pub fn as_fields(&self) -> CssNamedNamespacePrefixFields {
+        CssNamedNamespacePrefixFields { name: self.name() }
     }
-    pub fn declarator(&self) -> SyntaxResult<CssMediaAtRuleDeclarator> {
+    pub fn name(&self) -> SyntaxResult<CssIdentifier> {
         support::required_node(&self.syntax, 0usize)
     }
-    pub fn block(&self) -> SyntaxResult<AnyCssConditionalBlock> {
-        support::required_node(&self.syntax, 1usize)
-    }
 }
-impl Serialize for CssMediaAtRule {
+impl Serialize for CssNamedNamespacePrefix {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -3723,15 +3617,14 @@ impl Serialize for CssMediaAtRule {
     }
 }
 #[derive(Serialize)]
-pub struct CssMediaAtRuleFields {
-    pub declarator: SyntaxResult<CssMediaAtRuleDeclarator>,
-    pub block: SyntaxResult<AnyCssConditionalBlock>,
+pub struct CssNamedNamespacePrefixFields {
+    pub name: SyntaxResult<CssIdentifier>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssMediaAtRuleDeclarator {
+pub struct CssNamespace {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssMediaAtRuleDeclarator {
+impl CssNamespace {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -3741,20 +3634,20 @@ impl CssMediaAtRuleDeclarator {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssMediaAtRuleDeclaratorFields {
-        CssMediaAtRuleDeclaratorFields {
-            media_token: self.media_token(),
-            queries: self.queries(),
+    pub fn as_fields(&self) -> CssNamespaceFields {
+        CssNamespaceFields {
+            prefix: self.prefix(),
+            bitwise_or_token: self.bitwise_or_token(),
         }
     }
-    pub fn media_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 0usize)
+    pub fn prefix(&self) -> Option<AnyCssNamespacePrefix> {
+        support::node(&self.syntax, 0usize)
     }
-    pub fn queries(&self) -> CssMediaQueryList {
-        support::list(&self.syntax, 1usize)
+    pub fn bitwise_or_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 1usize)
     }
 }
-impl Serialize for CssMediaAtRuleDeclarator {
+impl Serialize for CssNamespace {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -3763,15 +3656,15 @@ impl Serialize for CssMediaAtRuleDeclarator {
     }
 }
 #[derive(Serialize)]
-pub struct CssMediaAtRuleDeclaratorFields {
-    pub media_token: SyntaxResult<SyntaxToken>,
-    pub queries: CssMediaQueryList,
+pub struct CssNamespaceFields {
+    pub prefix: Option<AnyCssNamespacePrefix>,
+    pub bitwise_or_token: SyntaxResult<SyntaxToken>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssMediaConditionInParens {
+pub struct CssNamespaceAtRule {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssMediaConditionInParens {
+impl CssNamespaceAtRule {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -3781,24 +3674,28 @@ impl CssMediaConditionInParens {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssMediaConditionInParensFields {
-        CssMediaConditionInParensFields {
-            l_paren_token: self.l_paren_token(),
-            condition: self.condition(),
-            r_paren_token: self.r_paren_token(),
+    pub fn as_fields(&self) -> CssNamespaceAtRuleFields {
+        CssNamespaceAtRuleFields {
+            namespace_token: self.namespace_token(),
+            prefix: self.prefix(),
+            url: self.url(),
+            semicolon_token: self.semicolon_token(),
         }
     }
-    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
+    pub fn namespace_token(&self) -> SyntaxResult<SyntaxToken> {
         support::required_token(&self.syntax, 0usize)
     }
-    pub fn condition(&self) -> SyntaxResult<AnyCssMediaCondition> {
-        support::required_node(&self.syntax, 1usize)
+    pub fn prefix(&self) -> Option<CssIdentifier> {
+        support::node(&self.syntax, 1usize)
     }
-    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 2usize)
+    pub fn url(&self) -> SyntaxResult<AnyCssNamespaceUrl> {
+        support::required_node(&self.syntax, 2usize)
+    }
+    pub fn semicolon_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 3usize)
     }
 }
-impl Serialize for CssMediaConditionInParens {
+impl Serialize for CssNamespaceAtRule {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -3807,16 +3704,17 @@ impl Serialize for CssMediaConditionInParens {
     }
 }
 #[derive(Serialize)]
-pub struct CssMediaConditionInParensFields {
-    pub l_paren_token: SyntaxResult<SyntaxToken>,
-    pub condition: SyntaxResult<AnyCssMediaCondition>,
-    pub r_paren_token: SyntaxResult<SyntaxToken>,
+pub struct CssNamespaceAtRuleFields {
+    pub namespace_token: SyntaxResult<SyntaxToken>,
+    pub prefix: Option<CssIdentifier>,
+    pub url: SyntaxResult<AnyCssNamespaceUrl>,
+    pub semicolon_token: SyntaxResult<SyntaxToken>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssMediaConditionQuery {
+pub struct CssNestedQualifiedRule {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssMediaConditionQuery {
+impl CssNestedQualifiedRule {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -3826,16 +3724,20 @@ impl CssMediaConditionQuery {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssMediaConditionQueryFields {
-        CssMediaConditionQueryFields {
-            condition: self.condition(),
+    pub fn as_fields(&self) -> CssNestedQualifiedRuleFields {
+        CssNestedQualifiedRuleFields {
+            prelude: self.prelude(),
+            block: self.block(),
         }
     }
-    pub fn condition(&self) -> SyntaxResult<AnyCssMediaCondition> {
-        support::required_node(&self.syntax, 0usize)
+    pub fn prelude(&self) -> CssRelativeSelectorList {
+        support::list(&self.syntax, 0usize)
+    }
+    pub fn block(&self) -> SyntaxResult<AnyCssDeclarationOrRuleBlock> {
+        support::required_node(&self.syntax, 1usize)
     }
 }
-impl Serialize for CssMediaConditionQuery {
+impl Serialize for CssNestedQualifiedRule {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -3844,14 +3746,15 @@ impl Serialize for CssMediaConditionQuery {
     }
 }
 #[derive(Serialize)]
-pub struct CssMediaConditionQueryFields {
-    pub condition: SyntaxResult<AnyCssMediaCondition>,
+pub struct CssNestedQualifiedRuleFields {
+    pub prelude: CssRelativeSelectorList,
+    pub block: SyntaxResult<AnyCssDeclarationOrRuleBlock>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssMediaFeatureInParens {
+pub struct CssNestedSelector {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssMediaFeatureInParens {
+impl CssNestedSelector {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -3861,24 +3764,16 @@ impl CssMediaFeatureInParens {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssMediaFeatureInParensFields {
-        CssMediaFeatureInParensFields {
-            l_paren_token: self.l_paren_token(),
-            feature: self.feature(),
-            r_paren_token: self.r_paren_token(),
+    pub fn as_fields(&self) -> CssNestedSelectorFields {
+        CssNestedSelectorFields {
+            amp_token: self.amp_token(),
         }
     }
-    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
+    pub fn amp_token(&self) -> SyntaxResult<SyntaxToken> {
         support::required_token(&self.syntax, 0usize)
     }
-    pub fn feature(&self) -> SyntaxResult<AnyCssQueryFeature> {
-        support::required_node(&self.syntax, 1usize)
-    }
-    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 2usize)
-    }
 }
-impl Serialize for CssMediaFeatureInParens {
+impl Serialize for CssNestedSelector {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -3887,16 +3782,14 @@ impl Serialize for CssMediaFeatureInParens {
     }
 }
 #[derive(Serialize)]
-pub struct CssMediaFeatureInParensFields {
-    pub l_paren_token: SyntaxResult<SyntaxToken>,
-    pub feature: SyntaxResult<AnyCssQueryFeature>,
-    pub r_paren_token: SyntaxResult<SyntaxToken>,
+pub struct CssNestedSelectorFields {
+    pub amp_token: SyntaxResult<SyntaxToken>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssMediaNotCondition {
+pub struct CssNthOffset {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssMediaNotCondition {
+impl CssNthOffset {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -3906,20 +3799,20 @@ impl CssMediaNotCondition {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssMediaNotConditionFields {
-        CssMediaNotConditionFields {
-            not_token: self.not_token(),
-            condition: self.condition(),
+    pub fn as_fields(&self) -> CssNthOffsetFields {
+        CssNthOffsetFields {
+            sign: self.sign(),
+            value: self.value(),
         }
     }
-    pub fn not_token(&self) -> SyntaxResult<SyntaxToken> {
+    pub fn sign(&self) -> SyntaxResult<SyntaxToken> {
         support::required_token(&self.syntax, 0usize)
     }
-    pub fn condition(&self) -> SyntaxResult<AnyCssMediaInParens> {
+    pub fn value(&self) -> SyntaxResult<CssNumber> {
         support::required_node(&self.syntax, 1usize)
     }
 }
-impl Serialize for CssMediaNotCondition {
+impl Serialize for CssNthOffset {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -3928,15 +3821,15 @@ impl Serialize for CssMediaNotCondition {
     }
 }
 #[derive(Serialize)]
-pub struct CssMediaNotConditionFields {
-    pub not_token: SyntaxResult<SyntaxToken>,
-    pub condition: SyntaxResult<AnyCssMediaInParens>,
+pub struct CssNthOffsetFields {
+    pub sign: SyntaxResult<SyntaxToken>,
+    pub value: SyntaxResult<CssNumber>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssMediaOrCondition {
+pub struct CssNumber {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssMediaOrCondition {
+impl CssNumber {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -3946,24 +3839,16 @@ impl CssMediaOrCondition {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssMediaOrConditionFields {
-        CssMediaOrConditionFields {
-            left: self.left(),
-            or_token: self.or_token(),
-            right: self.right(),
+    pub fn as_fields(&self) -> CssNumberFields {
+        CssNumberFields {
+            value_token: self.value_token(),
         }
     }
-    pub fn left(&self) -> SyntaxResult<AnyCssMediaInParens> {
-        support::required_node(&self.syntax, 0usize)
-    }
-    pub fn or_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 1usize)
-    }
-    pub fn right(&self) -> SyntaxResult<AnyCssMediaOrCombinableCondition> {
-        support::required_node(&self.syntax, 2usize)
+    pub fn value_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 0usize)
     }
 }
-impl Serialize for CssMediaOrCondition {
+impl Serialize for CssNumber {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -3972,16 +3857,14 @@ impl Serialize for CssMediaOrCondition {
     }
 }
 #[derive(Serialize)]
-pub struct CssMediaOrConditionFields {
-    pub left: SyntaxResult<AnyCssMediaInParens>,
-    pub or_token: SyntaxResult<SyntaxToken>,
-    pub right: SyntaxResult<AnyCssMediaOrCombinableCondition>,
+pub struct CssNumberFields {
+    pub value_token: SyntaxResult<SyntaxToken>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssMediaType {
+pub struct CssPageAtRule {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssMediaType {
+impl CssPageAtRule {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -3991,16 +3874,24 @@ impl CssMediaType {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssMediaTypeFields {
-        CssMediaTypeFields {
-            value: self.value(),
+    pub fn as_fields(&self) -> CssPageAtRuleFields {
+        CssPageAtRuleFields {
+            page_token: self.page_token(),
+            selectors: self.selectors(),
+            block: self.block(),
         }
     }
-    pub fn value(&self) -> SyntaxResult<CssIdentifier> {
-        support::required_node(&self.syntax, 0usize)
+    pub fn page_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 0usize)
+    }
+    pub fn selectors(&self) -> CssPageSelectorList {
+        support::list(&self.syntax, 1usize)
+    }
+    pub fn block(&self) -> SyntaxResult<AnyCssPageAtRuleBlock> {
+        support::required_node(&self.syntax, 2usize)
     }
 }
-impl Serialize for CssMediaType {
+impl Serialize for CssPageAtRule {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -4009,14 +3900,16 @@ impl Serialize for CssMediaType {
     }
 }
 #[derive(Serialize)]
-pub struct CssMediaTypeFields {
-    pub value: SyntaxResult<CssIdentifier>,
+pub struct CssPageAtRuleFields {
+    pub page_token: SyntaxResult<SyntaxToken>,
+    pub selectors: CssPageSelectorList,
+    pub block: SyntaxResult<AnyCssPageAtRuleBlock>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssMediaTypeQuery {
+pub struct CssPageAtRuleBlock {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssMediaTypeQuery {
+impl CssPageAtRuleBlock {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -4026,20 +3919,24 @@ impl CssMediaTypeQuery {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssMediaTypeQueryFields {
-        CssMediaTypeQueryFields {
-            modifier: self.modifier(),
-            ty: self.ty(),
+    pub fn as_fields(&self) -> CssPageAtRuleBlockFields {
+        CssPageAtRuleBlockFields {
+            l_curly_token: self.l_curly_token(),
+            items: self.items(),
+            r_curly_token: self.r_curly_token(),
         }
     }
-    pub fn modifier(&self) -> Option<SyntaxToken> {
-        support::token(&self.syntax, 0usize)
+    pub fn l_curly_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 0usize)
     }
-    pub fn ty(&self) -> SyntaxResult<CssMediaType> {
-        support::required_node(&self.syntax, 1usize)
+    pub fn items(&self) -> CssPageAtRuleItemList {
+        support::list(&self.syntax, 1usize)
+    }
+    pub fn r_curly_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 2usize)
     }
 }
-impl Serialize for CssMediaTypeQuery {
+impl Serialize for CssPageAtRuleBlock {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -4048,15 +3945,16 @@ impl Serialize for CssMediaTypeQuery {
     }
 }
 #[derive(Serialize)]
-pub struct CssMediaTypeQueryFields {
-    pub modifier: Option<SyntaxToken>,
-    pub ty: SyntaxResult<CssMediaType>,
+pub struct CssPageAtRuleBlockFields {
+    pub l_curly_token: SyntaxResult<SyntaxToken>,
+    pub items: CssPageAtRuleItemList,
+    pub r_curly_token: SyntaxResult<SyntaxToken>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssMetavariable {
+pub struct CssPageSelector {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssMetavariable {
+impl CssPageSelector {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -4066,16 +3964,20 @@ impl CssMetavariable {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssMetavariableFields {
-        CssMetavariableFields {
-            value_token: self.value_token(),
+    pub fn as_fields(&self) -> CssPageSelectorFields {
+        CssPageSelectorFields {
+            ty: self.ty(),
+            pseudos: self.pseudos(),
         }
     }
-    pub fn value_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 0usize)
+    pub fn ty(&self) -> Option<CssCustomIdentifier> {
+        support::node(&self.syntax, 0usize)
+    }
+    pub fn pseudos(&self) -> CssPageSelectorPseudoList {
+        support::list(&self.syntax, 1usize)
     }
 }
-impl Serialize for CssMetavariable {
+impl Serialize for CssPageSelector {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -4084,14 +3986,15 @@ impl Serialize for CssMetavariable {
     }
 }
 #[derive(Serialize)]
-pub struct CssMetavariableFields {
-    pub value_token: SyntaxResult<SyntaxToken>,
+pub struct CssPageSelectorFields {
+    pub ty: Option<CssCustomIdentifier>,
+    pub pseudos: CssPageSelectorPseudoList,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssNamedNamespacePrefix {
+pub struct CssPageSelectorPseudo {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssNamedNamespacePrefix {
+impl CssPageSelectorPseudo {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -4101,14 +4004,20 @@ impl CssNamedNamespacePrefix {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssNamedNamespacePrefixFields {
-        CssNamedNamespacePrefixFields { name: self.name() }
+    pub fn as_fields(&self) -> CssPageSelectorPseudoFields {
+        CssPageSelectorPseudoFields {
+            colon_token: self.colon_token(),
+            selector: self.selector(),
+        }
     }
-    pub fn name(&self) -> SyntaxResult<CssIdentifier> {
-        support::required_node(&self.syntax, 0usize)
+    pub fn colon_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 0usize)
+    }
+    pub fn selector(&self) -> SyntaxResult<CssIdentifier> {
+        support::required_node(&self.syntax, 1usize)
     }
 }
-impl Serialize for CssNamedNamespacePrefix {
+impl Serialize for CssPageSelectorPseudo {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -4117,14 +4026,15 @@ impl Serialize for CssNamedNamespacePrefix {
     }
 }
 #[derive(Serialize)]
-pub struct CssNamedNamespacePrefixFields {
-    pub name: SyntaxResult<CssIdentifier>,
+pub struct CssPageSelectorPseudoFields {
+    pub colon_token: SyntaxResult<SyntaxToken>,
+    pub selector: SyntaxResult<CssIdentifier>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssNamespace {
+pub struct CssParameter {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssNamespace {
+impl CssParameter {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -4134,20 +4044,16 @@ impl CssNamespace {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssNamespaceFields {
-        CssNamespaceFields {
-            prefix: self.prefix(),
-            bitwise_or_token: self.bitwise_or_token(),
+    pub fn as_fields(&self) -> CssParameterFields {
+        CssParameterFields {
+            any_css_expression: self.any_css_expression(),
         }
     }
-    pub fn prefix(&self) -> Option<AnyCssNamespacePrefix> {
-        support::node(&self.syntax, 0usize)
-    }
-    pub fn bitwise_or_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 1usize)
+    pub fn any_css_expression(&self) -> SyntaxResult<AnyCssExpression> {
+        support::required_node(&self.syntax, 0usize)
     }
 }
-impl Serialize for CssNamespace {
+impl Serialize for CssParameter {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -4156,15 +4062,14 @@ impl Serialize for CssNamespace {
     }
 }
 #[derive(Serialize)]
-pub struct CssNamespaceFields {
-    pub prefix: Option<AnyCssNamespacePrefix>,
-    pub bitwise_or_token: SyntaxResult<SyntaxToken>,
+pub struct CssParameterFields {
+    pub any_css_expression: SyntaxResult<AnyCssExpression>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssNamespaceAtRule {
+pub struct CssParenthesizedExpression {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssNamespaceAtRule {
+impl CssParenthesizedExpression {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -4174,28 +4079,24 @@ impl CssNamespaceAtRule {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssNamespaceAtRuleFields {
-        CssNamespaceAtRuleFields {
-            namespace_token: self.namespace_token(),
-            prefix: self.prefix(),
-            url: self.url(),
-            semicolon_token: self.semicolon_token(),
+    pub fn as_fields(&self) -> CssParenthesizedExpressionFields {
+        CssParenthesizedExpressionFields {
+            l_paren_token: self.l_paren_token(),
+            expression: self.expression(),
+            r_paren_token: self.r_paren_token(),
         }
     }
-    pub fn namespace_token(&self) -> SyntaxResult<SyntaxToken> {
+    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
         support::required_token(&self.syntax, 0usize)
     }
-    pub fn prefix(&self) -> Option<CssIdentifier> {
+    pub fn expression(&self) -> Option<AnyCssExpression> {
         support::node(&self.syntax, 1usize)
     }
-    pub fn url(&self) -> SyntaxResult<AnyCssNamespaceUrl> {
-        support::required_node(&self.syntax, 2usize)
-    }
-    pub fn semicolon_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 3usize)
+    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 2usize)
     }
 }
-impl Serialize for CssNamespaceAtRule {
+impl Serialize for CssParenthesizedExpression {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -4204,17 +4105,16 @@ impl Serialize for CssNamespaceAtRule {
     }
 }
 #[derive(Serialize)]
-pub struct CssNamespaceAtRuleFields {
-    pub namespace_token: SyntaxResult<SyntaxToken>,
-    pub prefix: Option<CssIdentifier>,
-    pub url: SyntaxResult<AnyCssNamespaceUrl>,
-    pub semicolon_token: SyntaxResult<SyntaxToken>,
+pub struct CssParenthesizedExpressionFields {
+    pub l_paren_token: SyntaxResult<SyntaxToken>,
+    pub expression: Option<AnyCssExpression>,
+    pub r_paren_token: SyntaxResult<SyntaxToken>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssNestedQualifiedRule {
+pub struct CssPercentage {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssNestedQualifiedRule {
+impl CssPercentage {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -4224,20 +4124,20 @@ impl CssNestedQualifiedRule {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssNestedQualifiedRuleFields {
-        CssNestedQualifiedRuleFields {
-            prelude: self.prelude(),
-            block: self.block(),
+    pub fn as_fields(&self) -> CssPercentageFields {
+        CssPercentageFields {
+            value_token: self.value_token(),
+            percent_token: self.percent_token(),
         }
     }
-    pub fn prelude(&self) -> CssRelativeSelectorList {
-        support::list(&self.syntax, 0usize)
+    pub fn value_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 0usize)
     }
-    pub fn block(&self) -> SyntaxResult<AnyCssDeclarationOrRuleBlock> {
-        support::required_node(&self.syntax, 1usize)
+    pub fn percent_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 1usize)
     }
 }
-impl Serialize for CssNestedQualifiedRule {
+impl Serialize for CssPercentage {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -4246,15 +4146,15 @@ impl Serialize for CssNestedQualifiedRule {
     }
 }
 #[derive(Serialize)]
-pub struct CssNestedQualifiedRuleFields {
-    pub prelude: CssRelativeSelectorList,
-    pub block: SyntaxResult<AnyCssDeclarationOrRuleBlock>,
+pub struct CssPercentageFields {
+    pub value_token: SyntaxResult<SyntaxToken>,
+    pub percent_token: SyntaxResult<SyntaxToken>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssNestedSelector {
+pub struct CssPositionTryAtRule {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssNestedSelector {
+impl CssPositionTryAtRule {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -4264,16 +4164,20 @@ impl CssNestedSelector {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssNestedSelectorFields {
-        CssNestedSelectorFields {
-            amp_token: self.amp_token(),
+    pub fn as_fields(&self) -> CssPositionTryAtRuleFields {
+        CssPositionTryAtRuleFields {
+            declarator: self.declarator(),
+            block: self.block(),
         }
     }
-    pub fn amp_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 0usize)
+    pub fn declarator(&self) -> SyntaxResult<CssPositionTryAtRuleDeclarator> {
+        support::required_node(&self.syntax, 0usize)
+    }
+    pub fn block(&self) -> SyntaxResult<AnyCssDeclarationBlock> {
+        support::required_node(&self.syntax, 1usize)
     }
 }
-impl Serialize for CssNestedSelector {
+impl Serialize for CssPositionTryAtRule {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -4282,14 +4186,15 @@ impl Serialize for CssNestedSelector {
     }
 }
 #[derive(Serialize)]
-pub struct CssNestedSelectorFields {
-    pub amp_token: SyntaxResult<SyntaxToken>,
+pub struct CssPositionTryAtRuleFields {
+    pub declarator: SyntaxResult<CssPositionTryAtRuleDeclarator>,
+    pub block: SyntaxResult<AnyCssDeclarationBlock>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssNthOffset {
+pub struct CssPositionTryAtRuleDeclarator {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssNthOffset {
+impl CssPositionTryAtRuleDeclarator {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -4299,20 +4204,20 @@ impl CssNthOffset {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssNthOffsetFields {
-        CssNthOffsetFields {
-            sign: self.sign(),
-            value: self.value(),
+    pub fn as_fields(&self) -> CssPositionTryAtRuleDeclaratorFields {
+        CssPositionTryAtRuleDeclaratorFields {
+            position_try_token: self.position_try_token(),
+            name: self.name(),
         }
     }
-    pub fn sign(&self) -> SyntaxResult<SyntaxToken> {
+    pub fn position_try_token(&self) -> SyntaxResult<SyntaxToken> {
         support::required_token(&self.syntax, 0usize)
     }
-    pub fn value(&self) -> SyntaxResult<CssNumber> {
+    pub fn name(&self) -> SyntaxResult<CssDashedIdentifier> {
         support::required_node(&self.syntax, 1usize)
     }
 }
-impl Serialize for CssNthOffset {
+impl Serialize for CssPositionTryAtRuleDeclarator {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -4321,15 +4226,15 @@ impl Serialize for CssNthOffset {
     }
 }
 #[derive(Serialize)]
-pub struct CssNthOffsetFields {
-    pub sign: SyntaxResult<SyntaxToken>,
-    pub value: SyntaxResult<CssNumber>,
+pub struct CssPositionTryAtRuleDeclaratorFields {
+    pub position_try_token: SyntaxResult<SyntaxToken>,
+    pub name: SyntaxResult<CssDashedIdentifier>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssNumber {
+pub struct CssPropertyAtRule {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssNumber {
+impl CssPropertyAtRule {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -4339,16 +4244,20 @@ impl CssNumber {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssNumberFields {
-        CssNumberFields {
-            value_token: self.value_token(),
+    pub fn as_fields(&self) -> CssPropertyAtRuleFields {
+        CssPropertyAtRuleFields {
+            declarator: self.declarator(),
+            block: self.block(),
         }
     }
-    pub fn value_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 0usize)
+    pub fn declarator(&self) -> SyntaxResult<CssPropertyAtRuleDeclarator> {
+        support::required_node(&self.syntax, 0usize)
+    }
+    pub fn block(&self) -> SyntaxResult<AnyCssDeclarationBlock> {
+        support::required_node(&self.syntax, 1usize)
     }
 }
-impl Serialize for CssNumber {
+impl Serialize for CssPropertyAtRule {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -4357,14 +4266,15 @@ impl Serialize for CssNumber {
     }
 }
 #[derive(Serialize)]
-pub struct CssNumberFields {
-    pub value_token: SyntaxResult<SyntaxToken>,
+pub struct CssPropertyAtRuleFields {
+    pub declarator: SyntaxResult<CssPropertyAtRuleDeclarator>,
+    pub block: SyntaxResult<AnyCssDeclarationBlock>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssPageAtRule {
+pub struct CssPropertyAtRuleDeclarator {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssPageAtRule {
+impl CssPropertyAtRuleDeclarator {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -4374,24 +4284,20 @@ impl CssPageAtRule {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssPageAtRuleFields {
-        CssPageAtRuleFields {
-            page_token: self.page_token(),
-            selectors: self.selectors(),
-            block: self.block(),
+    pub fn as_fields(&self) -> CssPropertyAtRuleDeclaratorFields {
+        CssPropertyAtRuleDeclaratorFields {
+            property_token: self.property_token(),
+            name: self.name(),
         }
     }
-    pub fn page_token(&self) -> SyntaxResult<SyntaxToken> {
+    pub fn property_token(&self) -> SyntaxResult<SyntaxToken> {
         support::required_token(&self.syntax, 0usize)
     }
-    pub fn selectors(&self) -> CssPageSelectorList {
-        support::list(&self.syntax, 1usize)
-    }
-    pub fn block(&self) -> SyntaxResult<AnyCssPageAtRuleBlock> {
-        support::required_node(&self.syntax, 2usize)
+    pub fn name(&self) -> SyntaxResult<CssDashedIdentifier> {
+        support::required_node(&self.syntax, 1usize)
     }
 }
-impl Serialize for CssPageAtRule {
+impl Serialize for CssPropertyAtRuleDeclarator {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -4400,16 +4306,15 @@ impl Serialize for CssPageAtRule {
     }
 }
 #[derive(Serialize)]
-pub struct CssPageAtRuleFields {
-    pub page_token: SyntaxResult<SyntaxToken>,
-    pub selectors: CssPageSelectorList,
-    pub block: SyntaxResult<AnyCssPageAtRuleBlock>,
+pub struct CssPropertyAtRuleDeclaratorFields {
+    pub property_token: SyntaxResult<SyntaxToken>,
+    pub name: SyntaxResult<CssDashedIdentifier>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssPageAtRuleBlock {
+pub struct CssPseudoClassFunctionCompoundSelector {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssPageAtRuleBlock {
+impl CssPseudoClassFunctionCompoundSelector {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -4419,24 +4324,28 @@ impl CssPageAtRuleBlock {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssPageAtRuleBlockFields {
-        CssPageAtRuleBlockFields {
-            l_curly_token: self.l_curly_token(),
-            items: self.items(),
-            r_curly_token: self.r_curly_token(),
+    pub fn as_fields(&self) -> CssPseudoClassFunctionCompoundSelectorFields {
+        CssPseudoClassFunctionCompoundSelectorFields {
+            name: self.name(),
+            l_paren_token: self.l_paren_token(),
+            selector: self.selector(),
+            r_paren_token: self.r_paren_token(),
         }
     }
-    pub fn l_curly_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 0usize)
+    pub fn name(&self) -> SyntaxResult<CssIdentifier> {
+        support::required_node(&self.syntax, 0usize)
     }
-    pub fn items(&self) -> CssPageAtRuleItemList {
-        support::list(&self.syntax, 1usize)
+    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 1usize)
     }
-    pub fn r_curly_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 2usize)
+    pub fn selector(&self) -> SyntaxResult<AnyCssCompoundSelector> {
+        support::required_node(&self.syntax, 2usize)
+    }
+    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 3usize)
     }
 }
-impl Serialize for CssPageAtRuleBlock {
+impl Serialize for CssPseudoClassFunctionCompoundSelector {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -4445,16 +4354,17 @@ impl Serialize for CssPageAtRuleBlock {
     }
 }
 #[derive(Serialize)]
-pub struct CssPageAtRuleBlockFields {
-    pub l_curly_token: SyntaxResult<SyntaxToken>,
-    pub items: CssPageAtRuleItemList,
-    pub r_curly_token: SyntaxResult<SyntaxToken>,
+pub struct CssPseudoClassFunctionCompoundSelectorFields {
+    pub name: SyntaxResult<CssIdentifier>,
+    pub l_paren_token: SyntaxResult<SyntaxToken>,
+    pub selector: SyntaxResult<AnyCssCompoundSelector>,
+    pub r_paren_token: SyntaxResult<SyntaxToken>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssPageSelector {
+pub struct CssPseudoClassFunctionCompoundSelectorList {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssPageSelector {
+impl CssPseudoClassFunctionCompoundSelectorList {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -4464,20 +4374,28 @@ impl CssPageSelector {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssPageSelectorFields {
-        CssPageSelectorFields {
-            ty: self.ty(),
-            pseudos: self.pseudos(),
+    pub fn as_fields(&self) -> CssPseudoClassFunctionCompoundSelectorListFields {
+        CssPseudoClassFunctionCompoundSelectorListFields {
+            name: self.name(),
+            l_paren_token: self.l_paren_token(),
+            compound_selectors: self.compound_selectors(),
+            r_paren_token: self.r_paren_token(),
         }
     }
-    pub fn ty(&self) -> Option<CssCustomIdentifier> {
-        support::node(&self.syntax, 0usize)
+    pub fn name(&self) -> SyntaxResult<CssIdentifier> {
+        support::required_node(&self.syntax, 0usize)
     }
-    pub fn pseudos(&self) -> CssPageSelectorPseudoList {
-        support::list(&self.syntax, 1usize)
+    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 1usize)
+    }
+    pub fn compound_selectors(&self) -> CssCompoundSelectorList {
+        support::list(&self.syntax, 2usize)
+    }
+    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 3usize)
     }
 }
-impl Serialize for CssPageSelector {
+impl Serialize for CssPseudoClassFunctionCompoundSelectorList {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -4486,15 +4404,17 @@ impl Serialize for CssPageSelector {
     }
 }
 #[derive(Serialize)]
-pub struct CssPageSelectorFields {
-    pub ty: Option<CssCustomIdentifier>,
-    pub pseudos: CssPageSelectorPseudoList,
+pub struct CssPseudoClassFunctionCompoundSelectorListFields {
+    pub name: SyntaxResult<CssIdentifier>,
+    pub l_paren_token: SyntaxResult<SyntaxToken>,
+    pub compound_selectors: CssCompoundSelectorList,
+    pub r_paren_token: SyntaxResult<SyntaxToken>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssPageSelectorPseudo {
+pub struct CssPseudoClassFunctionCustomIdentifier {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssPageSelectorPseudo {
+impl CssPseudoClassFunctionCustomIdentifier {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -4504,20 +4424,28 @@ impl CssPageSelectorPseudo {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssPageSelectorPseudoFields {
-        CssPageSelectorPseudoFields {
-            colon_token: self.colon_token(),
-            selector: self.selector(),
+    pub fn as_fields(&self) -> CssPseudoClassFunctionCustomIdentifierFields {
+        CssPseudoClassFunctionCustomIdentifierFields {
+            name: self.name(),
+            l_paren_token: self.l_paren_token(),
+            ident: self.ident(),
+            r_paren_token: self.r_paren_token(),
         }
     }
-    pub fn colon_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 0usize)
+    pub fn name(&self) -> SyntaxResult<CssIdentifier> {
+        support::required_node(&self.syntax, 0usize)
     }
-    pub fn selector(&self) -> SyntaxResult<CssIdentifier> {
-        support::required_node(&self.syntax, 1usize)
+    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 1usize)
+    }
+    pub fn ident(&self) -> SyntaxResult<CssCustomIdentifier> {
+        support::required_node(&self.syntax, 2usize)
+    }
+    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 3usize)
     }
 }
-impl Serialize for CssPageSelectorPseudo {
+impl Serialize for CssPseudoClassFunctionCustomIdentifier {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -4526,15 +4454,17 @@ impl Serialize for CssPageSelectorPseudo {
     }
 }
 #[derive(Serialize)]
-pub struct CssPageSelectorPseudoFields {
-    pub colon_token: SyntaxResult<SyntaxToken>,
-    pub selector: SyntaxResult<CssIdentifier>,
+pub struct CssPseudoClassFunctionCustomIdentifierFields {
+    pub name: SyntaxResult<CssIdentifier>,
+    pub l_paren_token: SyntaxResult<SyntaxToken>,
+    pub ident: SyntaxResult<CssCustomIdentifier>,
+    pub r_paren_token: SyntaxResult<SyntaxToken>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssParameter {
+pub struct CssPseudoClassFunctionCustomIdentifierList {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssParameter {
+impl CssPseudoClassFunctionCustomIdentifierList {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -4544,16 +4474,28 @@ impl CssParameter {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssParameterFields {
-        CssParameterFields {
-            any_css_expression: self.any_css_expression(),
+    pub fn as_fields(&self) -> CssPseudoClassFunctionCustomIdentifierListFields {
+        CssPseudoClassFunctionCustomIdentifierListFields {
+            name: self.name(),
+            l_paren_token: self.l_paren_token(),
+            items: self.items(),
+            r_paren_token: self.r_paren_token(),
         }
     }
-    pub fn any_css_expression(&self) -> SyntaxResult<AnyCssExpression> {
+    pub fn name(&self) -> SyntaxResult<CssIdentifier> {
         support::required_node(&self.syntax, 0usize)
     }
+    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 1usize)
+    }
+    pub fn items(&self) -> CssCustomIdentifierList {
+        support::list(&self.syntax, 2usize)
+    }
+    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 3usize)
+    }
 }
-impl Serialize for CssParameter {
+impl Serialize for CssPseudoClassFunctionCustomIdentifierList {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -4562,14 +4504,17 @@ impl Serialize for CssParameter {
     }
 }
 #[derive(Serialize)]
-pub struct CssParameterFields {
-    pub any_css_expression: SyntaxResult<AnyCssExpression>,
+pub struct CssPseudoClassFunctionCustomIdentifierListFields {
+    pub name: SyntaxResult<CssIdentifier>,
+    pub l_paren_token: SyntaxResult<SyntaxToken>,
+    pub items: CssCustomIdentifierList,
+    pub r_paren_token: SyntaxResult<SyntaxToken>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssParenthesizedExpression {
+pub struct CssPseudoClassFunctionIdentifier {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssParenthesizedExpression {
+impl CssPseudoClassFunctionIdentifier {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -4579,24 +4524,28 @@ impl CssParenthesizedExpression {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssParenthesizedExpressionFields {
-        CssParenthesizedExpressionFields {
+    pub fn as_fields(&self) -> CssPseudoClassFunctionIdentifierFields {
+        CssPseudoClassFunctionIdentifierFields {
+            name: self.name(),
             l_paren_token: self.l_paren_token(),
-            expression: self.expression(),
+            ident: self.ident(),
             r_paren_token: self.r_paren_token(),
         }
     }
+    pub fn name(&self) -> SyntaxResult<CssIdentifier> {
+        support::required_node(&self.syntax, 0usize)
+    }
     pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 0usize)
+        support::required_token(&self.syntax, 1usize)
     }
-    pub fn expression(&self) -> Option<AnyCssExpression> {
-        support::node(&self.syntax, 1usize)
+    pub fn ident(&self) -> SyntaxResult<CssIdentifier> {
+        support::required_node(&self.syntax, 2usize)
     }
     pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 2usize)
+        support::required_token(&self.syntax, 3usize)
     }
 }
-impl Serialize for CssParenthesizedExpression {
+impl Serialize for CssPseudoClassFunctionIdentifier {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -4605,16 +4554,17 @@ impl Serialize for CssParenthesizedExpression {
     }
 }
 #[derive(Serialize)]
-pub struct CssParenthesizedExpressionFields {
+pub struct CssPseudoClassFunctionIdentifierFields {
+    pub name: SyntaxResult<CssIdentifier>,
     pub l_paren_token: SyntaxResult<SyntaxToken>,
-    pub expression: Option<AnyCssExpression>,
+    pub ident: SyntaxResult<CssIdentifier>,
     pub r_paren_token: SyntaxResult<SyntaxToken>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssPercentage {
+pub struct CssPseudoClassFunctionNth {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssPercentage {
+impl CssPseudoClassFunctionNth {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -4624,60 +4574,28 @@ impl CssPercentage {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssPercentageFields {
-        CssPercentageFields {
-            value_token: self.value_token(),
-            percent_token: self.percent_token(),
+    pub fn as_fields(&self) -> CssPseudoClassFunctionNthFields {
+        CssPseudoClassFunctionNthFields {
+            name: self.name(),
+            l_paren_token: self.l_paren_token(),
+            selector: self.selector(),
+            r_paren_token: self.r_paren_token(),
         }
     }
-    pub fn value_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 0usize)
+    pub fn name(&self) -> SyntaxResult<CssIdentifier> {
+        support::required_node(&self.syntax, 0usize)
     }
-    pub fn percent_token(&self) -> SyntaxResult<SyntaxToken> {
+    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
         support::required_token(&self.syntax, 1usize)
     }
-}
-impl Serialize for CssPercentage {
-    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
-    where
-        S: Serializer,
-    {
-        self.as_fields().serialize(serializer)
-    }
-}
-#[derive(Serialize)]
-pub struct CssPercentageFields {
-    pub value_token: SyntaxResult<SyntaxToken>,
-    pub percent_token: SyntaxResult<SyntaxToken>,
-}
-#[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssPositionTryAtRule {
-    pub(crate) syntax: SyntaxNode,
-}
-impl CssPositionTryAtRule {
-    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
-    #[doc = r""]
-    #[doc = r" # Safety"]
-    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
-    #[doc = r" or a match on [SyntaxNode::kind]"]
-    #[inline]
-    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
-        Self { syntax }
-    }
-    pub fn as_fields(&self) -> CssPositionTryAtRuleFields {
-        CssPositionTryAtRuleFields {
-            declarator: self.declarator(),
-            block: self.block(),
-        }
-    }
-    pub fn declarator(&self) -> SyntaxResult<CssPositionTryAtRuleDeclarator> {
-        support::required_node(&self.syntax, 0usize)
+    pub fn selector(&self) -> SyntaxResult<AnyCssPseudoClassNthSelector> {
+        support::required_node(&self.syntax, 2usize)
     }
-    pub fn block(&self) -> SyntaxResult<AnyCssDeclarationBlock> {
-        support::required_node(&self.syntax, 1usize)
+    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 3usize)
     }
 }
-impl Serialize for CssPositionTryAtRule {
+impl Serialize for CssPseudoClassFunctionNth {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -4686,15 +4604,17 @@ impl Serialize for CssPositionTryAtRule {
     }
 }
 #[derive(Serialize)]
-pub struct CssPositionTryAtRuleFields {
-    pub declarator: SyntaxResult<CssPositionTryAtRuleDeclarator>,
-    pub block: SyntaxResult<AnyCssDeclarationBlock>,
+pub struct CssPseudoClassFunctionNthFields {
+    pub name: SyntaxResult<CssIdentifier>,
+    pub l_paren_token: SyntaxResult<SyntaxToken>,
+    pub selector: SyntaxResult<AnyCssPseudoClassNthSelector>,
+    pub r_paren_token: SyntaxResult<SyntaxToken>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssPositionTryAtRuleDeclarator {
+pub struct CssPseudoClassFunctionRelativeSelectorList {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssPositionTryAtRuleDeclarator {
+impl CssPseudoClassFunctionRelativeSelectorList {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -4704,60 +4624,28 @@ impl CssPositionTryAtRuleDeclarator {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssPositionTryAtRuleDeclaratorFields {
-        CssPositionTryAtRuleDeclaratorFields {
-            position_try_token: self.position_try_token(),
+    pub fn as_fields(&self) -> CssPseudoClassFunctionRelativeSelectorListFields {
+        CssPseudoClassFunctionRelativeSelectorListFields {
             name: self.name(),
+            l_paren_token: self.l_paren_token(),
+            relative_selectors: self.relative_selectors(),
+            r_paren_token: self.r_paren_token(),
         }
     }
-    pub fn position_try_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 0usize)
-    }
-    pub fn name(&self) -> SyntaxResult<CssDashedIdentifier> {
-        support::required_node(&self.syntax, 1usize)
-    }
-}
-impl Serialize for CssPositionTryAtRuleDeclarator {
-    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
-    where
-        S: Serializer,
-    {
-        self.as_fields().serialize(serializer)
-    }
-}
-#[derive(Serialize)]
-pub struct CssPositionTryAtRuleDeclaratorFields {
-    pub position_try_token: SyntaxResult<SyntaxToken>,
-    pub name: SyntaxResult<CssDashedIdentifier>,
-}
-#[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssPropertyAtRule {
-    pub(crate) syntax: SyntaxNode,
-}
-impl CssPropertyAtRule {
-    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
-    #[doc = r""]
-    #[doc = r" # Safety"]
-    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
-    #[doc = r" or a match on [SyntaxNode::kind]"]
-    #[inline]
-    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
-        Self { syntax }
+    pub fn name(&self) -> SyntaxResult<CssIdentifier> {
+        support::required_node(&self.syntax, 0usize)
     }
-    pub fn as_fields(&self) -> CssPropertyAtRuleFields {
-        CssPropertyAtRuleFields {
-            declarator: self.declarator(),
-            block: self.block(),
-        }
+    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 1usize)
     }
-    pub fn declarator(&self) -> SyntaxResult<CssPropertyAtRuleDeclarator> {
-        support::required_node(&self.syntax, 0usize)
+    pub fn relative_selectors(&self) -> CssRelativeSelectorList {
+        support::list(&self.syntax, 2usize)
     }
-    pub fn block(&self) -> SyntaxResult<AnyCssDeclarationBlock> {
-        support::required_node(&self.syntax, 1usize)
+    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 3usize)
     }
 }
-impl Serialize for CssPropertyAtRule {
+impl Serialize for CssPseudoClassFunctionRelativeSelectorList {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -4766,15 +4654,17 @@ impl Serialize for CssPropertyAtRule {
     }
 }
 #[derive(Serialize)]
-pub struct CssPropertyAtRuleFields {
-    pub declarator: SyntaxResult<CssPropertyAtRuleDeclarator>,
-    pub block: SyntaxResult<AnyCssDeclarationBlock>,
+pub struct CssPseudoClassFunctionRelativeSelectorListFields {
+    pub name: SyntaxResult<CssIdentifier>,
+    pub l_paren_token: SyntaxResult<SyntaxToken>,
+    pub relative_selectors: CssRelativeSelectorList,
+    pub r_paren_token: SyntaxResult<SyntaxToken>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssPropertyAtRuleDeclarator {
+pub struct CssPseudoClassFunctionSelector {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssPropertyAtRuleDeclarator {
+impl CssPseudoClassFunctionSelector {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -4784,20 +4674,28 @@ impl CssPropertyAtRuleDeclarator {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssPropertyAtRuleDeclaratorFields {
-        CssPropertyAtRuleDeclaratorFields {
-            property_token: self.property_token(),
+    pub fn as_fields(&self) -> CssPseudoClassFunctionSelectorFields {
+        CssPseudoClassFunctionSelectorFields {
             name: self.name(),
+            l_paren_token: self.l_paren_token(),
+            selector: self.selector(),
+            r_paren_token: self.r_paren_token(),
         }
     }
-    pub fn property_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 0usize)
+    pub fn name(&self) -> SyntaxResult<CssIdentifier> {
+        support::required_node(&self.syntax, 0usize)
     }
-    pub fn name(&self) -> SyntaxResult<CssDashedIdentifier> {
-        support::required_node(&self.syntax, 1usize)
+    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 1usize)
+    }
+    pub fn selector(&self) -> SyntaxResult<AnyCssSelector> {
+        support::required_node(&self.syntax, 2usize)
+    }
+    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 3usize)
     }
 }
-impl Serialize for CssPropertyAtRuleDeclarator {
+impl Serialize for CssPseudoClassFunctionSelector {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -4806,15 +4704,17 @@ impl Serialize for CssPropertyAtRuleDeclarator {
     }
 }
 #[derive(Serialize)]
-pub struct CssPropertyAtRuleDeclaratorFields {
-    pub property_token: SyntaxResult<SyntaxToken>,
-    pub name: SyntaxResult<CssDashedIdentifier>,
+pub struct CssPseudoClassFunctionSelectorFields {
+    pub name: SyntaxResult<CssIdentifier>,
+    pub l_paren_token: SyntaxResult<SyntaxToken>,
+    pub selector: SyntaxResult<AnyCssSelector>,
+    pub r_paren_token: SyntaxResult<SyntaxToken>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssPseudoClassFunctionCompoundSelector {
+pub struct CssPseudoClassFunctionSelectorList {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssPseudoClassFunctionCompoundSelector {
+impl CssPseudoClassFunctionSelectorList {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -4824,11 +4724,11 @@ impl CssPseudoClassFunctionCompoundSelector {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssPseudoClassFunctionCompoundSelectorFields {
-        CssPseudoClassFunctionCompoundSelectorFields {
+    pub fn as_fields(&self) -> CssPseudoClassFunctionSelectorListFields {
+        CssPseudoClassFunctionSelectorListFields {
             name: self.name(),
             l_paren_token: self.l_paren_token(),
-            selector: self.selector(),
+            selectors: self.selectors(),
             r_paren_token: self.r_paren_token(),
         }
     }
@@ -4838,14 +4738,14 @@ impl CssPseudoClassFunctionCompoundSelector {
     pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
         support::required_token(&self.syntax, 1usize)
     }
-    pub fn selector(&self) -> SyntaxResult<AnyCssCompoundSelector> {
-        support::required_node(&self.syntax, 2usize)
+    pub fn selectors(&self) -> CssSelectorList {
+        support::list(&self.syntax, 2usize)
     }
     pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
         support::required_token(&self.syntax, 3usize)
     }
 }
-impl Serialize for CssPseudoClassFunctionCompoundSelector {
+impl Serialize for CssPseudoClassFunctionSelectorList {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -4854,17 +4754,17 @@ impl Serialize for CssPseudoClassFunctionCompoundSelector {
     }
 }
 #[derive(Serialize)]
-pub struct CssPseudoClassFunctionCompoundSelectorFields {
+pub struct CssPseudoClassFunctionSelectorListFields {
     pub name: SyntaxResult<CssIdentifier>,
     pub l_paren_token: SyntaxResult<SyntaxToken>,
-    pub selector: SyntaxResult<AnyCssCompoundSelector>,
+    pub selectors: CssSelectorList,
     pub r_paren_token: SyntaxResult<SyntaxToken>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssPseudoClassFunctionCompoundSelectorList {
+pub struct CssPseudoClassFunctionValueList {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssPseudoClassFunctionCompoundSelectorList {
+impl CssPseudoClassFunctionValueList {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -4874,11 +4774,11 @@ impl CssPseudoClassFunctionCompoundSelectorList {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssPseudoClassFunctionCompoundSelectorListFields {
-        CssPseudoClassFunctionCompoundSelectorListFields {
+    pub fn as_fields(&self) -> CssPseudoClassFunctionValueListFields {
+        CssPseudoClassFunctionValueListFields {
             name: self.name(),
             l_paren_token: self.l_paren_token(),
-            compound_selectors: self.compound_selectors(),
+            values: self.values(),
             r_paren_token: self.r_paren_token(),
         }
     }
@@ -4888,14 +4788,14 @@ impl CssPseudoClassFunctionCompoundSelectorList {
     pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
         support::required_token(&self.syntax, 1usize)
     }
-    pub fn compound_selectors(&self) -> CssCompoundSelectorList {
+    pub fn values(&self) -> CssPseudoValueList {
         support::list(&self.syntax, 2usize)
     }
     pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
         support::required_token(&self.syntax, 3usize)
     }
 }
-impl Serialize for CssPseudoClassFunctionCompoundSelectorList {
+impl Serialize for CssPseudoClassFunctionValueList {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -4904,17 +4804,17 @@ impl Serialize for CssPseudoClassFunctionCompoundSelectorList {
     }
 }
 #[derive(Serialize)]
-pub struct CssPseudoClassFunctionCompoundSelectorListFields {
+pub struct CssPseudoClassFunctionValueListFields {
     pub name: SyntaxResult<CssIdentifier>,
     pub l_paren_token: SyntaxResult<SyntaxToken>,
-    pub compound_selectors: CssCompoundSelectorList,
+    pub values: CssPseudoValueList,
     pub r_paren_token: SyntaxResult<SyntaxToken>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssPseudoClassFunctionCustomIdentifier {
+pub struct CssPseudoClassIdentifier {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssPseudoClassFunctionCustomIdentifier {
+impl CssPseudoClassIdentifier {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -4924,28 +4824,14 @@ impl CssPseudoClassFunctionCustomIdentifier {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssPseudoClassFunctionCustomIdentifierFields {
-        CssPseudoClassFunctionCustomIdentifierFields {
-            name: self.name(),
-            l_paren_token: self.l_paren_token(),
-            ident: self.ident(),
-            r_paren_token: self.r_paren_token(),
-        }
+    pub fn as_fields(&self) -> CssPseudoClassIdentifierFields {
+        CssPseudoClassIdentifierFields { name: self.name() }
     }
     pub fn name(&self) -> SyntaxResult<CssIdentifier> {
         support::required_node(&self.syntax, 0usize)
     }
-    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 1usize)
-    }
-    pub fn ident(&self) -> SyntaxResult<CssCustomIdentifier> {
-        support::required_node(&self.syntax, 2usize)
-    }
-    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 3usize)
-    }
 }
-impl Serialize for CssPseudoClassFunctionCustomIdentifier {
+impl Serialize for CssPseudoClassIdentifier {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -4954,17 +4840,14 @@ impl Serialize for CssPseudoClassFunctionCustomIdentifier {
     }
 }
 #[derive(Serialize)]
-pub struct CssPseudoClassFunctionCustomIdentifierFields {
+pub struct CssPseudoClassIdentifierFields {
     pub name: SyntaxResult<CssIdentifier>,
-    pub l_paren_token: SyntaxResult<SyntaxToken>,
-    pub ident: SyntaxResult<CssCustomIdentifier>,
-    pub r_paren_token: SyntaxResult<SyntaxToken>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssPseudoClassFunctionCustomIdentifierList {
+pub struct CssPseudoClassNth {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssPseudoClassFunctionCustomIdentifierList {
+impl CssPseudoClassNth {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -4974,28 +4857,28 @@ impl CssPseudoClassFunctionCustomIdentifierList {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssPseudoClassFunctionCustomIdentifierListFields {
-        CssPseudoClassFunctionCustomIdentifierListFields {
-            name: self.name(),
-            l_paren_token: self.l_paren_token(),
-            items: self.items(),
-            r_paren_token: self.r_paren_token(),
+    pub fn as_fields(&self) -> CssPseudoClassNthFields {
+        CssPseudoClassNthFields {
+            sign: self.sign(),
+            value: self.value(),
+            symbol_token: self.symbol_token(),
+            offset: self.offset(),
         }
     }
-    pub fn name(&self) -> SyntaxResult<CssIdentifier> {
-        support::required_node(&self.syntax, 0usize)
+    pub fn sign(&self) -> Option<SyntaxToken> {
+        support::token(&self.syntax, 0usize)
     }
-    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 1usize)
+    pub fn value(&self) -> Option<CssNumber> {
+        support::node(&self.syntax, 1usize)
     }
-    pub fn items(&self) -> CssCustomIdentifierList {
-        support::list(&self.syntax, 2usize)
+    pub fn symbol_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 2usize)
     }
-    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 3usize)
+    pub fn offset(&self) -> Option<CssNthOffset> {
+        support::node(&self.syntax, 3usize)
     }
 }
-impl Serialize for CssPseudoClassFunctionCustomIdentifierList {
+impl Serialize for CssPseudoClassNth {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -5004,17 +4887,17 @@ impl Serialize for CssPseudoClassFunctionCustomIdentifierList {
     }
 }
 #[derive(Serialize)]
-pub struct CssPseudoClassFunctionCustomIdentifierListFields {
-    pub name: SyntaxResult<CssIdentifier>,
-    pub l_paren_token: SyntaxResult<SyntaxToken>,
-    pub items: CssCustomIdentifierList,
-    pub r_paren_token: SyntaxResult<SyntaxToken>,
+pub struct CssPseudoClassNthFields {
+    pub sign: Option<SyntaxToken>,
+    pub value: Option<CssNumber>,
+    pub symbol_token: SyntaxResult<SyntaxToken>,
+    pub offset: Option<CssNthOffset>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssPseudoClassFunctionIdentifier {
+pub struct CssPseudoClassNthIdentifier {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssPseudoClassFunctionIdentifier {
+impl CssPseudoClassNthIdentifier {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -5024,28 +4907,55 @@ impl CssPseudoClassFunctionIdentifier {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssPseudoClassFunctionIdentifierFields {
-        CssPseudoClassFunctionIdentifierFields {
-            name: self.name(),
-            l_paren_token: self.l_paren_token(),
-            ident: self.ident(),
-            r_paren_token: self.r_paren_token(),
+    pub fn as_fields(&self) -> CssPseudoClassNthIdentifierFields {
+        CssPseudoClassNthIdentifierFields {
+            value: self.value(),
         }
     }
-    pub fn name(&self) -> SyntaxResult<CssIdentifier> {
-        support::required_node(&self.syntax, 0usize)
+    pub fn value(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 0usize)
     }
-    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 1usize)
+}
+impl Serialize for CssPseudoClassNthIdentifier {
+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
+    where
+        S: Serializer,
+    {
+        self.as_fields().serialize(serializer)
     }
-    pub fn ident(&self) -> SyntaxResult<CssIdentifier> {
-        support::required_node(&self.syntax, 2usize)
+}
+#[derive(Serialize)]
+pub struct CssPseudoClassNthIdentifierFields {
+    pub value: SyntaxResult<SyntaxToken>,
+}
+#[derive(Clone, PartialEq, Eq, Hash)]
+pub struct CssPseudoClassNthNumber {
+    pub(crate) syntax: SyntaxNode,
+}
+impl CssPseudoClassNthNumber {
+    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
+    #[doc = r""]
+    #[doc = r" # Safety"]
+    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
+    #[doc = r" or a match on [SyntaxNode::kind]"]
+    #[inline]
+    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
+        Self { syntax }
     }
-    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 3usize)
+    pub fn as_fields(&self) -> CssPseudoClassNthNumberFields {
+        CssPseudoClassNthNumberFields {
+            sign: self.sign(),
+            value: self.value(),
+        }
+    }
+    pub fn sign(&self) -> Option<SyntaxToken> {
+        support::token(&self.syntax, 0usize)
+    }
+    pub fn value(&self) -> SyntaxResult<CssNumber> {
+        support::required_node(&self.syntax, 1usize)
     }
 }
-impl Serialize for CssPseudoClassFunctionIdentifier {
+impl Serialize for CssPseudoClassNthNumber {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -5054,17 +4964,15 @@ impl Serialize for CssPseudoClassFunctionIdentifier {
     }
 }
 #[derive(Serialize)]
-pub struct CssPseudoClassFunctionIdentifierFields {
-    pub name: SyntaxResult<CssIdentifier>,
-    pub l_paren_token: SyntaxResult<SyntaxToken>,
-    pub ident: SyntaxResult<CssIdentifier>,
-    pub r_paren_token: SyntaxResult<SyntaxToken>,
+pub struct CssPseudoClassNthNumberFields {
+    pub sign: Option<SyntaxToken>,
+    pub value: SyntaxResult<CssNumber>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssPseudoClassFunctionNth {
+pub struct CssPseudoClassNthSelector {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssPseudoClassFunctionNth {
+impl CssPseudoClassNthSelector {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -5074,28 +4982,20 @@ impl CssPseudoClassFunctionNth {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssPseudoClassFunctionNthFields {
-        CssPseudoClassFunctionNthFields {
-            name: self.name(),
-            l_paren_token: self.l_paren_token(),
-            selector: self.selector(),
-            r_paren_token: self.r_paren_token(),
+    pub fn as_fields(&self) -> CssPseudoClassNthSelectorFields {
+        CssPseudoClassNthSelectorFields {
+            nth: self.nth(),
+            of_selector: self.of_selector(),
         }
     }
-    pub fn name(&self) -> SyntaxResult<CssIdentifier> {
+    pub fn nth(&self) -> SyntaxResult<AnyCssPseudoClassNth> {
         support::required_node(&self.syntax, 0usize)
     }
-    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 1usize)
-    }
-    pub fn selector(&self) -> SyntaxResult<AnyCssPseudoClassNthSelector> {
-        support::required_node(&self.syntax, 2usize)
-    }
-    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 3usize)
+    pub fn of_selector(&self) -> Option<CssPseudoClassOfNthSelector> {
+        support::node(&self.syntax, 1usize)
     }
 }
-impl Serialize for CssPseudoClassFunctionNth {
+impl Serialize for CssPseudoClassNthSelector {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -5104,17 +5004,15 @@ impl Serialize for CssPseudoClassFunctionNth {
     }
 }
 #[derive(Serialize)]
-pub struct CssPseudoClassFunctionNthFields {
-    pub name: SyntaxResult<CssIdentifier>,
-    pub l_paren_token: SyntaxResult<SyntaxToken>,
-    pub selector: SyntaxResult<AnyCssPseudoClassNthSelector>,
-    pub r_paren_token: SyntaxResult<SyntaxToken>,
+pub struct CssPseudoClassNthSelectorFields {
+    pub nth: SyntaxResult<AnyCssPseudoClassNth>,
+    pub of_selector: Option<CssPseudoClassOfNthSelector>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssPseudoClassFunctionRelativeSelectorList {
+pub struct CssPseudoClassOfNthSelector {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssPseudoClassFunctionRelativeSelectorList {
+impl CssPseudoClassOfNthSelector {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -5124,28 +5022,20 @@ impl CssPseudoClassFunctionRelativeSelectorList {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssPseudoClassFunctionRelativeSelectorListFields {
-        CssPseudoClassFunctionRelativeSelectorListFields {
-            name: self.name(),
-            l_paren_token: self.l_paren_token(),
-            relative_selectors: self.relative_selectors(),
-            r_paren_token: self.r_paren_token(),
+    pub fn as_fields(&self) -> CssPseudoClassOfNthSelectorFields {
+        CssPseudoClassOfNthSelectorFields {
+            of_token: self.of_token(),
+            selectors: self.selectors(),
         }
     }
-    pub fn name(&self) -> SyntaxResult<CssIdentifier> {
-        support::required_node(&self.syntax, 0usize)
-    }
-    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 1usize)
-    }
-    pub fn relative_selectors(&self) -> CssRelativeSelectorList {
-        support::list(&self.syntax, 2usize)
+    pub fn of_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 0usize)
     }
-    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 3usize)
+    pub fn selectors(&self) -> CssSelectorList {
+        support::list(&self.syntax, 1usize)
     }
 }
-impl Serialize for CssPseudoClassFunctionRelativeSelectorList {
+impl Serialize for CssPseudoClassOfNthSelector {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -5154,17 +5044,15 @@ impl Serialize for CssPseudoClassFunctionRelativeSelectorList {
     }
 }
 #[derive(Serialize)]
-pub struct CssPseudoClassFunctionRelativeSelectorListFields {
-    pub name: SyntaxResult<CssIdentifier>,
-    pub l_paren_token: SyntaxResult<SyntaxToken>,
-    pub relative_selectors: CssRelativeSelectorList,
-    pub r_paren_token: SyntaxResult<SyntaxToken>,
+pub struct CssPseudoClassOfNthSelectorFields {
+    pub of_token: SyntaxResult<SyntaxToken>,
+    pub selectors: CssSelectorList,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssPseudoClassFunctionSelector {
+pub struct CssPseudoClassSelector {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssPseudoClassFunctionSelector {
+impl CssPseudoClassSelector {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -5174,28 +5062,20 @@ impl CssPseudoClassFunctionSelector {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssPseudoClassFunctionSelectorFields {
-        CssPseudoClassFunctionSelectorFields {
-            name: self.name(),
-            l_paren_token: self.l_paren_token(),
-            selector: self.selector(),
-            r_paren_token: self.r_paren_token(),
+    pub fn as_fields(&self) -> CssPseudoClassSelectorFields {
+        CssPseudoClassSelectorFields {
+            colon_token: self.colon_token(),
+            class: self.class(),
         }
     }
-    pub fn name(&self) -> SyntaxResult<CssIdentifier> {
-        support::required_node(&self.syntax, 0usize)
-    }
-    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 1usize)
-    }
-    pub fn selector(&self) -> SyntaxResult<AnyCssSelector> {
-        support::required_node(&self.syntax, 2usize)
+    pub fn colon_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 0usize)
     }
-    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 3usize)
+    pub fn class(&self) -> SyntaxResult<AnyCssPseudoClass> {
+        support::required_node(&self.syntax, 1usize)
     }
 }
-impl Serialize for CssPseudoClassFunctionSelector {
+impl Serialize for CssPseudoClassSelector {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -5204,17 +5084,15 @@ impl Serialize for CssPseudoClassFunctionSelector {
     }
 }
 #[derive(Serialize)]
-pub struct CssPseudoClassFunctionSelectorFields {
-    pub name: SyntaxResult<CssIdentifier>,
-    pub l_paren_token: SyntaxResult<SyntaxToken>,
-    pub selector: SyntaxResult<AnyCssSelector>,
-    pub r_paren_token: SyntaxResult<SyntaxToken>,
+pub struct CssPseudoClassSelectorFields {
+    pub colon_token: SyntaxResult<SyntaxToken>,
+    pub class: SyntaxResult<AnyCssPseudoClass>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssPseudoClassFunctionSelectorList {
+pub struct CssPseudoElementFunction {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssPseudoClassFunctionSelectorList {
+impl CssPseudoElementFunction {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -5224,11 +5102,11 @@ impl CssPseudoClassFunctionSelectorList {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssPseudoClassFunctionSelectorListFields {
-        CssPseudoClassFunctionSelectorListFields {
+    pub fn as_fields(&self) -> CssPseudoElementFunctionFields {
+        CssPseudoElementFunctionFields {
             name: self.name(),
             l_paren_token: self.l_paren_token(),
-            selectors: self.selectors(),
+            items: self.items(),
             r_paren_token: self.r_paren_token(),
         }
     }
@@ -5238,14 +5116,14 @@ impl CssPseudoClassFunctionSelectorList {
     pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
         support::required_token(&self.syntax, 1usize)
     }
-    pub fn selectors(&self) -> CssSelectorList {
+    pub fn items(&self) -> CssPseudoElementFunctionParameterList {
         support::list(&self.syntax, 2usize)
     }
     pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
         support::required_token(&self.syntax, 3usize)
     }
 }
-impl Serialize for CssPseudoClassFunctionSelectorList {
+impl Serialize for CssPseudoElementFunction {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -5254,17 +5132,17 @@ impl Serialize for CssPseudoClassFunctionSelectorList {
     }
 }
 #[derive(Serialize)]
-pub struct CssPseudoClassFunctionSelectorListFields {
+pub struct CssPseudoElementFunctionFields {
     pub name: SyntaxResult<CssIdentifier>,
     pub l_paren_token: SyntaxResult<SyntaxToken>,
-    pub selectors: CssSelectorList,
+    pub items: CssPseudoElementFunctionParameterList,
     pub r_paren_token: SyntaxResult<SyntaxToken>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssPseudoClassFunctionValueList {
+pub struct CssPseudoElementFunctionCustomIdentifier {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssPseudoClassFunctionValueList {
+impl CssPseudoElementFunctionCustomIdentifier {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -5274,11 +5152,11 @@ impl CssPseudoClassFunctionValueList {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssPseudoClassFunctionValueListFields {
-        CssPseudoClassFunctionValueListFields {
+    pub fn as_fields(&self) -> CssPseudoElementFunctionCustomIdentifierFields {
+        CssPseudoElementFunctionCustomIdentifierFields {
             name: self.name(),
             l_paren_token: self.l_paren_token(),
-            values: self.values(),
+            ident: self.ident(),
             r_paren_token: self.r_paren_token(),
         }
     }
@@ -5288,14 +5166,14 @@ impl CssPseudoClassFunctionValueList {
     pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
         support::required_token(&self.syntax, 1usize)
     }
-    pub fn values(&self) -> CssPseudoValueList {
-        support::list(&self.syntax, 2usize)
+    pub fn ident(&self) -> SyntaxResult<CssCustomIdentifier> {
+        support::required_node(&self.syntax, 2usize)
     }
     pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
         support::required_token(&self.syntax, 3usize)
     }
 }
-impl Serialize for CssPseudoClassFunctionValueList {
+impl Serialize for CssPseudoElementFunctionCustomIdentifier {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -5304,17 +5182,17 @@ impl Serialize for CssPseudoClassFunctionValueList {
     }
 }
 #[derive(Serialize)]
-pub struct CssPseudoClassFunctionValueListFields {
+pub struct CssPseudoElementFunctionCustomIdentifierFields {
     pub name: SyntaxResult<CssIdentifier>,
     pub l_paren_token: SyntaxResult<SyntaxToken>,
-    pub values: CssPseudoValueList,
+    pub ident: SyntaxResult<CssCustomIdentifier>,
     pub r_paren_token: SyntaxResult<SyntaxToken>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssPseudoClassIdentifier {
+pub struct CssPseudoElementFunctionSelector {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssPseudoClassIdentifier {
+impl CssPseudoElementFunctionSelector {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -5324,14 +5202,28 @@ impl CssPseudoClassIdentifier {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssPseudoClassIdentifierFields {
-        CssPseudoClassIdentifierFields { name: self.name() }
+    pub fn as_fields(&self) -> CssPseudoElementFunctionSelectorFields {
+        CssPseudoElementFunctionSelectorFields {
+            name: self.name(),
+            l_paren_token: self.l_paren_token(),
+            selector: self.selector(),
+            r_paren_token: self.r_paren_token(),
+        }
     }
     pub fn name(&self) -> SyntaxResult<CssIdentifier> {
         support::required_node(&self.syntax, 0usize)
     }
+    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 1usize)
+    }
+    pub fn selector(&self) -> SyntaxResult<AnyCssSelector> {
+        support::required_node(&self.syntax, 2usize)
+    }
+    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 3usize)
+    }
 }
-impl Serialize for CssPseudoClassIdentifier {
+impl Serialize for CssPseudoElementFunctionSelector {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -5340,14 +5232,17 @@ impl Serialize for CssPseudoClassIdentifier {
     }
 }
 #[derive(Serialize)]
-pub struct CssPseudoClassIdentifierFields {
+pub struct CssPseudoElementFunctionSelectorFields {
     pub name: SyntaxResult<CssIdentifier>,
+    pub l_paren_token: SyntaxResult<SyntaxToken>,
+    pub selector: SyntaxResult<AnyCssSelector>,
+    pub r_paren_token: SyntaxResult<SyntaxToken>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssPseudoClassNth {
+pub struct CssPseudoElementIdentifier {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssPseudoClassNth {
+impl CssPseudoElementIdentifier {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -5357,28 +5252,14 @@ impl CssPseudoClassNth {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssPseudoClassNthFields {
-        CssPseudoClassNthFields {
-            sign: self.sign(),
-            value: self.value(),
-            symbol_token: self.symbol_token(),
-            offset: self.offset(),
-        }
-    }
-    pub fn sign(&self) -> Option<SyntaxToken> {
-        support::token(&self.syntax, 0usize)
-    }
-    pub fn value(&self) -> Option<CssNumber> {
-        support::node(&self.syntax, 1usize)
-    }
-    pub fn symbol_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 2usize)
+    pub fn as_fields(&self) -> CssPseudoElementIdentifierFields {
+        CssPseudoElementIdentifierFields { name: self.name() }
     }
-    pub fn offset(&self) -> Option<CssNthOffset> {
-        support::node(&self.syntax, 3usize)
+    pub fn name(&self) -> SyntaxResult<CssIdentifier> {
+        support::required_node(&self.syntax, 0usize)
     }
 }
-impl Serialize for CssPseudoClassNth {
+impl Serialize for CssPseudoElementIdentifier {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -5387,17 +5268,14 @@ impl Serialize for CssPseudoClassNth {
     }
 }
 #[derive(Serialize)]
-pub struct CssPseudoClassNthFields {
-    pub sign: Option<SyntaxToken>,
-    pub value: Option<CssNumber>,
-    pub symbol_token: SyntaxResult<SyntaxToken>,
-    pub offset: Option<CssNthOffset>,
+pub struct CssPseudoElementIdentifierFields {
+    pub name: SyntaxResult<CssIdentifier>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssPseudoClassNthIdentifier {
+pub struct CssPseudoElementSelector {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssPseudoClassNthIdentifier {
+impl CssPseudoElementSelector {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -5407,16 +5285,20 @@ impl CssPseudoClassNthIdentifier {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssPseudoClassNthIdentifierFields {
-        CssPseudoClassNthIdentifierFields {
-            value: self.value(),
+    pub fn as_fields(&self) -> CssPseudoElementSelectorFields {
+        CssPseudoElementSelectorFields {
+            double_colon_token: self.double_colon_token(),
+            element: self.element(),
         }
     }
-    pub fn value(&self) -> SyntaxResult<SyntaxToken> {
+    pub fn double_colon_token(&self) -> SyntaxResult<SyntaxToken> {
         support::required_token(&self.syntax, 0usize)
     }
+    pub fn element(&self) -> SyntaxResult<AnyCssPseudoElement> {
+        support::required_node(&self.syntax, 1usize)
+    }
 }
-impl Serialize for CssPseudoClassNthIdentifier {
+impl Serialize for CssPseudoElementSelector {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -5425,14 +5307,15 @@ impl Serialize for CssPseudoClassNthIdentifier {
     }
 }
 #[derive(Serialize)]
-pub struct CssPseudoClassNthIdentifierFields {
-    pub value: SyntaxResult<SyntaxToken>,
+pub struct CssPseudoElementSelectorFields {
+    pub double_colon_token: SyntaxResult<SyntaxToken>,
+    pub element: SyntaxResult<AnyCssPseudoElement>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssPseudoClassNthNumber {
+pub struct CssQualifiedRule {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssPseudoClassNthNumber {
+impl CssQualifiedRule {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -5442,20 +5325,20 @@ impl CssPseudoClassNthNumber {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssPseudoClassNthNumberFields {
-        CssPseudoClassNthNumberFields {
-            sign: self.sign(),
-            value: self.value(),
+    pub fn as_fields(&self) -> CssQualifiedRuleFields {
+        CssQualifiedRuleFields {
+            prelude: self.prelude(),
+            block: self.block(),
         }
     }
-    pub fn sign(&self) -> Option<SyntaxToken> {
-        support::token(&self.syntax, 0usize)
+    pub fn prelude(&self) -> CssSelectorList {
+        support::list(&self.syntax, 0usize)
     }
-    pub fn value(&self) -> SyntaxResult<CssNumber> {
+    pub fn block(&self) -> SyntaxResult<AnyCssDeclarationOrRuleBlock> {
         support::required_node(&self.syntax, 1usize)
     }
 }
-impl Serialize for CssPseudoClassNthNumber {
+impl Serialize for CssQualifiedRule {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -5464,15 +5347,15 @@ impl Serialize for CssPseudoClassNthNumber {
     }
 }
 #[derive(Serialize)]
-pub struct CssPseudoClassNthNumberFields {
-    pub sign: Option<SyntaxToken>,
-    pub value: SyntaxResult<CssNumber>,
+pub struct CssQualifiedRuleFields {
+    pub prelude: CssSelectorList,
+    pub block: SyntaxResult<AnyCssDeclarationOrRuleBlock>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssPseudoClassNthSelector {
+pub struct CssQueryFeatureBoolean {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssPseudoClassNthSelector {
+impl CssQueryFeatureBoolean {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -5482,20 +5365,14 @@ impl CssPseudoClassNthSelector {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssPseudoClassNthSelectorFields {
-        CssPseudoClassNthSelectorFields {
-            nth: self.nth(),
-            of_selector: self.of_selector(),
-        }
+    pub fn as_fields(&self) -> CssQueryFeatureBooleanFields {
+        CssQueryFeatureBooleanFields { name: self.name() }
     }
-    pub fn nth(&self) -> SyntaxResult<AnyCssPseudoClassNth> {
+    pub fn name(&self) -> SyntaxResult<CssIdentifier> {
         support::required_node(&self.syntax, 0usize)
     }
-    pub fn of_selector(&self) -> Option<CssPseudoClassOfNthSelector> {
-        support::node(&self.syntax, 1usize)
-    }
 }
-impl Serialize for CssPseudoClassNthSelector {
+impl Serialize for CssQueryFeatureBoolean {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -5504,15 +5381,14 @@ impl Serialize for CssPseudoClassNthSelector {
     }
 }
 #[derive(Serialize)]
-pub struct CssPseudoClassNthSelectorFields {
-    pub nth: SyntaxResult<AnyCssPseudoClassNth>,
-    pub of_selector: Option<CssPseudoClassOfNthSelector>,
+pub struct CssQueryFeatureBooleanFields {
+    pub name: SyntaxResult<CssIdentifier>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssPseudoClassOfNthSelector {
+pub struct CssQueryFeaturePlain {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssPseudoClassOfNthSelector {
+impl CssQueryFeaturePlain {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -5522,20 +5398,24 @@ impl CssPseudoClassOfNthSelector {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssPseudoClassOfNthSelectorFields {
-        CssPseudoClassOfNthSelectorFields {
-            of_token: self.of_token(),
-            selectors: self.selectors(),
+    pub fn as_fields(&self) -> CssQueryFeaturePlainFields {
+        CssQueryFeaturePlainFields {
+            name: self.name(),
+            colon_token: self.colon_token(),
+            value: self.value(),
         }
     }
-    pub fn of_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 0usize)
+    pub fn name(&self) -> SyntaxResult<CssIdentifier> {
+        support::required_node(&self.syntax, 0usize)
     }
-    pub fn selectors(&self) -> CssSelectorList {
-        support::list(&self.syntax, 1usize)
+    pub fn colon_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 1usize)
+    }
+    pub fn value(&self) -> SyntaxResult<AnyCssQueryFeatureValue> {
+        support::required_node(&self.syntax, 2usize)
     }
 }
-impl Serialize for CssPseudoClassOfNthSelector {
+impl Serialize for CssQueryFeaturePlain {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -5544,15 +5424,16 @@ impl Serialize for CssPseudoClassOfNthSelector {
     }
 }
 #[derive(Serialize)]
-pub struct CssPseudoClassOfNthSelectorFields {
-    pub of_token: SyntaxResult<SyntaxToken>,
-    pub selectors: CssSelectorList,
+pub struct CssQueryFeaturePlainFields {
+    pub name: SyntaxResult<CssIdentifier>,
+    pub colon_token: SyntaxResult<SyntaxToken>,
+    pub value: SyntaxResult<AnyCssQueryFeatureValue>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssPseudoClassSelector {
+pub struct CssQueryFeatureRange {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssPseudoClassSelector {
+impl CssQueryFeatureRange {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -5562,20 +5443,24 @@ impl CssPseudoClassSelector {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssPseudoClassSelectorFields {
-        CssPseudoClassSelectorFields {
-            colon_token: self.colon_token(),
-            class: self.class(),
+    pub fn as_fields(&self) -> CssQueryFeatureRangeFields {
+        CssQueryFeatureRangeFields {
+            left: self.left(),
+            comparison: self.comparison(),
+            right: self.right(),
         }
     }
-    pub fn colon_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 0usize)
+    pub fn left(&self) -> SyntaxResult<CssIdentifier> {
+        support::required_node(&self.syntax, 0usize)
     }
-    pub fn class(&self) -> SyntaxResult<AnyCssPseudoClass> {
+    pub fn comparison(&self) -> SyntaxResult<CssQueryFeatureRangeComparison> {
         support::required_node(&self.syntax, 1usize)
     }
+    pub fn right(&self) -> SyntaxResult<AnyCssQueryFeatureValue> {
+        support::required_node(&self.syntax, 2usize)
+    }
 }
-impl Serialize for CssPseudoClassSelector {
+impl Serialize for CssQueryFeatureRange {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -5584,15 +5469,16 @@ impl Serialize for CssPseudoClassSelector {
     }
 }
 #[derive(Serialize)]
-pub struct CssPseudoClassSelectorFields {
-    pub colon_token: SyntaxResult<SyntaxToken>,
-    pub class: SyntaxResult<AnyCssPseudoClass>,
+pub struct CssQueryFeatureRangeFields {
+    pub left: SyntaxResult<CssIdentifier>,
+    pub comparison: SyntaxResult<CssQueryFeatureRangeComparison>,
+    pub right: SyntaxResult<AnyCssQueryFeatureValue>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssPseudoElementFunction {
+pub struct CssQueryFeatureRangeComparison {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssPseudoElementFunction {
+impl CssQueryFeatureRangeComparison {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -5602,28 +5488,16 @@ impl CssPseudoElementFunction {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssPseudoElementFunctionFields {
-        CssPseudoElementFunctionFields {
-            name: self.name(),
-            l_paren_token: self.l_paren_token(),
-            items: self.items(),
-            r_paren_token: self.r_paren_token(),
+    pub fn as_fields(&self) -> CssQueryFeatureRangeComparisonFields {
+        CssQueryFeatureRangeComparisonFields {
+            operator: self.operator(),
         }
     }
-    pub fn name(&self) -> SyntaxResult<CssIdentifier> {
-        support::required_node(&self.syntax, 0usize)
-    }
-    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 1usize)
-    }
-    pub fn items(&self) -> CssPseudoElementFunctionParameterList {
-        support::list(&self.syntax, 2usize)
-    }
-    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 3usize)
+    pub fn operator(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 0usize)
     }
 }
-impl Serialize for CssPseudoElementFunction {
+impl Serialize for CssQueryFeatureRangeComparison {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -5632,17 +5506,14 @@ impl Serialize for CssPseudoElementFunction {
     }
 }
 #[derive(Serialize)]
-pub struct CssPseudoElementFunctionFields {
-    pub name: SyntaxResult<CssIdentifier>,
-    pub l_paren_token: SyntaxResult<SyntaxToken>,
-    pub items: CssPseudoElementFunctionParameterList,
-    pub r_paren_token: SyntaxResult<SyntaxToken>,
+pub struct CssQueryFeatureRangeComparisonFields {
+    pub operator: SyntaxResult<SyntaxToken>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssPseudoElementFunctionCustomIdentifier {
+pub struct CssQueryFeatureRangeInterval {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssPseudoElementFunctionCustomIdentifier {
+impl CssQueryFeatureRangeInterval {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -5652,28 +5523,32 @@ impl CssPseudoElementFunctionCustomIdentifier {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssPseudoElementFunctionCustomIdentifierFields {
-        CssPseudoElementFunctionCustomIdentifierFields {
+    pub fn as_fields(&self) -> CssQueryFeatureRangeIntervalFields {
+        CssQueryFeatureRangeIntervalFields {
+            left: self.left(),
+            left_comparison: self.left_comparison(),
             name: self.name(),
-            l_paren_token: self.l_paren_token(),
-            ident: self.ident(),
-            r_paren_token: self.r_paren_token(),
+            right_comparison: self.right_comparison(),
+            right: self.right(),
         }
     }
-    pub fn name(&self) -> SyntaxResult<CssIdentifier> {
+    pub fn left(&self) -> SyntaxResult<AnyCssQueryFeatureValue> {
         support::required_node(&self.syntax, 0usize)
     }
-    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 1usize)
+    pub fn left_comparison(&self) -> SyntaxResult<CssQueryFeatureRangeComparison> {
+        support::required_node(&self.syntax, 1usize)
     }
-    pub fn ident(&self) -> SyntaxResult<CssCustomIdentifier> {
+    pub fn name(&self) -> SyntaxResult<CssIdentifier> {
         support::required_node(&self.syntax, 2usize)
     }
-    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 3usize)
+    pub fn right_comparison(&self) -> SyntaxResult<CssQueryFeatureRangeComparison> {
+        support::required_node(&self.syntax, 3usize)
+    }
+    pub fn right(&self) -> SyntaxResult<AnyCssQueryFeatureValue> {
+        support::required_node(&self.syntax, 4usize)
     }
 }
-impl Serialize for CssPseudoElementFunctionCustomIdentifier {
+impl Serialize for CssQueryFeatureRangeInterval {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -5682,17 +5557,18 @@ impl Serialize for CssPseudoElementFunctionCustomIdentifier {
     }
 }
 #[derive(Serialize)]
-pub struct CssPseudoElementFunctionCustomIdentifierFields {
+pub struct CssQueryFeatureRangeIntervalFields {
+    pub left: SyntaxResult<AnyCssQueryFeatureValue>,
+    pub left_comparison: SyntaxResult<CssQueryFeatureRangeComparison>,
     pub name: SyntaxResult<CssIdentifier>,
-    pub l_paren_token: SyntaxResult<SyntaxToken>,
-    pub ident: SyntaxResult<CssCustomIdentifier>,
-    pub r_paren_token: SyntaxResult<SyntaxToken>,
+    pub right_comparison: SyntaxResult<CssQueryFeatureRangeComparison>,
+    pub right: SyntaxResult<AnyCssQueryFeatureValue>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssPseudoElementFunctionSelector {
+pub struct CssQueryFeatureReverseRange {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssPseudoElementFunctionSelector {
+impl CssQueryFeatureReverseRange {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -5702,28 +5578,24 @@ impl CssPseudoElementFunctionSelector {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssPseudoElementFunctionSelectorFields {
-        CssPseudoElementFunctionSelectorFields {
-            name: self.name(),
-            l_paren_token: self.l_paren_token(),
-            selector: self.selector(),
-            r_paren_token: self.r_paren_token(),
+    pub fn as_fields(&self) -> CssQueryFeatureReverseRangeFields {
+        CssQueryFeatureReverseRangeFields {
+            left: self.left(),
+            comparison: self.comparison(),
+            right: self.right(),
         }
     }
-    pub fn name(&self) -> SyntaxResult<CssIdentifier> {
+    pub fn left(&self) -> SyntaxResult<AnyCssQueryFeatureValue> {
         support::required_node(&self.syntax, 0usize)
     }
-    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 1usize)
+    pub fn comparison(&self) -> SyntaxResult<CssQueryFeatureRangeComparison> {
+        support::required_node(&self.syntax, 1usize)
     }
-    pub fn selector(&self) -> SyntaxResult<AnyCssSelector> {
+    pub fn right(&self) -> SyntaxResult<CssIdentifier> {
         support::required_node(&self.syntax, 2usize)
     }
-    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 3usize)
-    }
 }
-impl Serialize for CssPseudoElementFunctionSelector {
+impl Serialize for CssQueryFeatureReverseRange {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -5732,17 +5604,16 @@ impl Serialize for CssPseudoElementFunctionSelector {
     }
 }
 #[derive(Serialize)]
-pub struct CssPseudoElementFunctionSelectorFields {
-    pub name: SyntaxResult<CssIdentifier>,
-    pub l_paren_token: SyntaxResult<SyntaxToken>,
-    pub selector: SyntaxResult<AnyCssSelector>,
-    pub r_paren_token: SyntaxResult<SyntaxToken>,
+pub struct CssQueryFeatureReverseRangeFields {
+    pub left: SyntaxResult<AnyCssQueryFeatureValue>,
+    pub comparison: SyntaxResult<CssQueryFeatureRangeComparison>,
+    pub right: SyntaxResult<CssIdentifier>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssPseudoElementIdentifier {
+pub struct CssRatio {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssPseudoElementIdentifier {
+impl CssRatio {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -5752,14 +5623,24 @@ impl CssPseudoElementIdentifier {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssPseudoElementIdentifierFields {
-        CssPseudoElementIdentifierFields { name: self.name() }
+    pub fn as_fields(&self) -> CssRatioFields {
+        CssRatioFields {
+            numerator: self.numerator(),
+            slash_token: self.slash_token(),
+            denominator: self.denominator(),
+        }
     }
-    pub fn name(&self) -> SyntaxResult<CssIdentifier> {
+    pub fn numerator(&self) -> SyntaxResult<CssNumber> {
         support::required_node(&self.syntax, 0usize)
     }
+    pub fn slash_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 1usize)
+    }
+    pub fn denominator(&self) -> SyntaxResult<CssNumber> {
+        support::required_node(&self.syntax, 2usize)
+    }
 }
-impl Serialize for CssPseudoElementIdentifier {
+impl Serialize for CssRatio {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -5768,14 +5649,16 @@ impl Serialize for CssPseudoElementIdentifier {
     }
 }
 #[derive(Serialize)]
-pub struct CssPseudoElementIdentifierFields {
-    pub name: SyntaxResult<CssIdentifier>,
+pub struct CssRatioFields {
+    pub numerator: SyntaxResult<CssNumber>,
+    pub slash_token: SyntaxResult<SyntaxToken>,
+    pub denominator: SyntaxResult<CssNumber>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssPseudoElementSelector {
+pub struct CssRegularDimension {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssPseudoElementSelector {
+impl CssRegularDimension {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -5785,20 +5668,20 @@ impl CssPseudoElementSelector {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssPseudoElementSelectorFields {
-        CssPseudoElementSelectorFields {
-            double_colon_token: self.double_colon_token(),
-            element: self.element(),
+    pub fn as_fields(&self) -> CssRegularDimensionFields {
+        CssRegularDimensionFields {
+            value_token: self.value_token(),
+            unit_token: self.unit_token(),
         }
     }
-    pub fn double_colon_token(&self) -> SyntaxResult<SyntaxToken> {
+    pub fn value_token(&self) -> SyntaxResult<SyntaxToken> {
         support::required_token(&self.syntax, 0usize)
     }
-    pub fn element(&self) -> SyntaxResult<AnyCssPseudoElement> {
-        support::required_node(&self.syntax, 1usize)
+    pub fn unit_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 1usize)
     }
 }
-impl Serialize for CssPseudoElementSelector {
+impl Serialize for CssRegularDimension {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -5807,15 +5690,15 @@ impl Serialize for CssPseudoElementSelector {
     }
 }
 #[derive(Serialize)]
-pub struct CssPseudoElementSelectorFields {
-    pub double_colon_token: SyntaxResult<SyntaxToken>,
-    pub element: SyntaxResult<AnyCssPseudoElement>,
+pub struct CssRegularDimensionFields {
+    pub value_token: SyntaxResult<SyntaxToken>,
+    pub unit_token: SyntaxResult<SyntaxToken>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssQualifiedRule {
+pub struct CssRelativeSelector {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssQualifiedRule {
+impl CssRelativeSelector {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -5825,20 +5708,20 @@ impl CssQualifiedRule {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssQualifiedRuleFields {
-        CssQualifiedRuleFields {
-            prelude: self.prelude(),
-            block: self.block(),
+    pub fn as_fields(&self) -> CssRelativeSelectorFields {
+        CssRelativeSelectorFields {
+            combinator: self.combinator(),
+            selector: self.selector(),
         }
     }
-    pub fn prelude(&self) -> CssSelectorList {
-        support::list(&self.syntax, 0usize)
+    pub fn combinator(&self) -> Option<SyntaxToken> {
+        support::token(&self.syntax, 0usize)
     }
-    pub fn block(&self) -> SyntaxResult<AnyCssDeclarationOrRuleBlock> {
+    pub fn selector(&self) -> SyntaxResult<AnyCssSelector> {
         support::required_node(&self.syntax, 1usize)
     }
 }
-impl Serialize for CssQualifiedRule {
+impl Serialize for CssRelativeSelector {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -5847,15 +5730,15 @@ impl Serialize for CssQualifiedRule {
     }
 }
 #[derive(Serialize)]
-pub struct CssQualifiedRuleFields {
-    pub prelude: CssSelectorList,
-    pub block: SyntaxResult<AnyCssDeclarationOrRuleBlock>,
+pub struct CssRelativeSelectorFields {
+    pub combinator: Option<SyntaxToken>,
+    pub selector: SyntaxResult<AnyCssSelector>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssQueryFeatureBoolean {
+pub struct CssRoot {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssQueryFeatureBoolean {
+impl CssRoot {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -5865,14 +5748,24 @@ impl CssQueryFeatureBoolean {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssQueryFeatureBooleanFields {
-        CssQueryFeatureBooleanFields { name: self.name() }
+    pub fn as_fields(&self) -> CssRootFields {
+        CssRootFields {
+            bom_token: self.bom_token(),
+            rules: self.rules(),
+            eof_token: self.eof_token(),
+        }
     }
-    pub fn name(&self) -> SyntaxResult<CssIdentifier> {
-        support::required_node(&self.syntax, 0usize)
+    pub fn bom_token(&self) -> Option<SyntaxToken> {
+        support::token(&self.syntax, 0usize)
+    }
+    pub fn rules(&self) -> CssRuleList {
+        support::list(&self.syntax, 1usize)
+    }
+    pub fn eof_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 2usize)
     }
 }
-impl Serialize for CssQueryFeatureBoolean {
+impl Serialize for CssRoot {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -5881,14 +5774,16 @@ impl Serialize for CssQueryFeatureBoolean {
     }
 }
 #[derive(Serialize)]
-pub struct CssQueryFeatureBooleanFields {
-    pub name: SyntaxResult<CssIdentifier>,
+pub struct CssRootFields {
+    pub bom_token: Option<SyntaxToken>,
+    pub rules: CssRuleList,
+    pub eof_token: SyntaxResult<SyntaxToken>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssQueryFeaturePlain {
+pub struct CssRuleBlock {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssQueryFeaturePlain {
+impl CssRuleBlock {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -5898,24 +5793,24 @@ impl CssQueryFeaturePlain {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssQueryFeaturePlainFields {
-        CssQueryFeaturePlainFields {
-            name: self.name(),
-            colon_token: self.colon_token(),
-            value: self.value(),
+    pub fn as_fields(&self) -> CssRuleBlockFields {
+        CssRuleBlockFields {
+            l_curly_token: self.l_curly_token(),
+            rules: self.rules(),
+            r_curly_token: self.r_curly_token(),
         }
     }
-    pub fn name(&self) -> SyntaxResult<CssIdentifier> {
-        support::required_node(&self.syntax, 0usize)
+    pub fn l_curly_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 0usize)
     }
-    pub fn colon_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 1usize)
+    pub fn rules(&self) -> CssRuleList {
+        support::list(&self.syntax, 1usize)
     }
-    pub fn value(&self) -> SyntaxResult<AnyCssQueryFeatureValue> {
-        support::required_node(&self.syntax, 2usize)
+    pub fn r_curly_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 2usize)
     }
 }
-impl Serialize for CssQueryFeaturePlain {
+impl Serialize for CssRuleBlock {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -5924,16 +5819,16 @@ impl Serialize for CssQueryFeaturePlain {
     }
 }
 #[derive(Serialize)]
-pub struct CssQueryFeaturePlainFields {
-    pub name: SyntaxResult<CssIdentifier>,
-    pub colon_token: SyntaxResult<SyntaxToken>,
-    pub value: SyntaxResult<AnyCssQueryFeatureValue>,
+pub struct CssRuleBlockFields {
+    pub l_curly_token: SyntaxResult<SyntaxToken>,
+    pub rules: CssRuleList,
+    pub r_curly_token: SyntaxResult<SyntaxToken>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssQueryFeatureRange {
+pub struct CssScopeAtRule {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssQueryFeatureRange {
+impl CssScopeAtRule {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -5943,24 +5838,20 @@ impl CssQueryFeatureRange {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssQueryFeatureRangeFields {
-        CssQueryFeatureRangeFields {
-            left: self.left(),
-            comparison: self.comparison(),
-            right: self.right(),
+    pub fn as_fields(&self) -> CssScopeAtRuleFields {
+        CssScopeAtRuleFields {
+            declarator: self.declarator(),
+            block: self.block(),
         }
     }
-    pub fn left(&self) -> SyntaxResult<CssIdentifier> {
+    pub fn declarator(&self) -> SyntaxResult<CssScopeAtRuleDeclarator> {
         support::required_node(&self.syntax, 0usize)
     }
-    pub fn comparison(&self) -> SyntaxResult<CssQueryFeatureRangeComparison> {
+    pub fn block(&self) -> SyntaxResult<AnyCssConditionalBlock> {
         support::required_node(&self.syntax, 1usize)
     }
-    pub fn right(&self) -> SyntaxResult<AnyCssQueryFeatureValue> {
-        support::required_node(&self.syntax, 2usize)
-    }
 }
-impl Serialize for CssQueryFeatureRange {
+impl Serialize for CssScopeAtRule {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -5969,16 +5860,15 @@ impl Serialize for CssQueryFeatureRange {
     }
 }
 #[derive(Serialize)]
-pub struct CssQueryFeatureRangeFields {
-    pub left: SyntaxResult<CssIdentifier>,
-    pub comparison: SyntaxResult<CssQueryFeatureRangeComparison>,
-    pub right: SyntaxResult<AnyCssQueryFeatureValue>,
+pub struct CssScopeAtRuleFields {
+    pub declarator: SyntaxResult<CssScopeAtRuleDeclarator>,
+    pub block: SyntaxResult<AnyCssConditionalBlock>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssQueryFeatureRangeComparison {
+pub struct CssScopeAtRuleDeclarator {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssQueryFeatureRangeComparison {
+impl CssScopeAtRuleDeclarator {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -5988,16 +5878,20 @@ impl CssQueryFeatureRangeComparison {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssQueryFeatureRangeComparisonFields {
-        CssQueryFeatureRangeComparisonFields {
-            operator: self.operator(),
+    pub fn as_fields(&self) -> CssScopeAtRuleDeclaratorFields {
+        CssScopeAtRuleDeclaratorFields {
+            scope_token: self.scope_token(),
+            range: self.range(),
         }
     }
-    pub fn operator(&self) -> SyntaxResult<SyntaxToken> {
+    pub fn scope_token(&self) -> SyntaxResult<SyntaxToken> {
         support::required_token(&self.syntax, 0usize)
     }
+    pub fn range(&self) -> Option<AnyCssScopeRange> {
+        support::node(&self.syntax, 1usize)
+    }
 }
-impl Serialize for CssQueryFeatureRangeComparison {
+impl Serialize for CssScopeAtRuleDeclarator {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -6006,14 +5900,15 @@ impl Serialize for CssQueryFeatureRangeComparison {
     }
 }
 #[derive(Serialize)]
-pub struct CssQueryFeatureRangeComparisonFields {
-    pub operator: SyntaxResult<SyntaxToken>,
+pub struct CssScopeAtRuleDeclaratorFields {
+    pub scope_token: SyntaxResult<SyntaxToken>,
+    pub range: Option<AnyCssScopeRange>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssQueryFeatureRangeInterval {
+pub struct CssScopeEdge {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssQueryFeatureRangeInterval {
+impl CssScopeEdge {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -6023,32 +5918,24 @@ impl CssQueryFeatureRangeInterval {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssQueryFeatureRangeIntervalFields {
-        CssQueryFeatureRangeIntervalFields {
-            left: self.left(),
-            left_comparison: self.left_comparison(),
-            name: self.name(),
-            right_comparison: self.right_comparison(),
-            right: self.right(),
+    pub fn as_fields(&self) -> CssScopeEdgeFields {
+        CssScopeEdgeFields {
+            l_paren_token: self.l_paren_token(),
+            selectors: self.selectors(),
+            r_paren_token: self.r_paren_token(),
         }
     }
-    pub fn left(&self) -> SyntaxResult<AnyCssQueryFeatureValue> {
-        support::required_node(&self.syntax, 0usize)
-    }
-    pub fn left_comparison(&self) -> SyntaxResult<CssQueryFeatureRangeComparison> {
-        support::required_node(&self.syntax, 1usize)
-    }
-    pub fn name(&self) -> SyntaxResult<CssIdentifier> {
-        support::required_node(&self.syntax, 2usize)
+    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 0usize)
     }
-    pub fn right_comparison(&self) -> SyntaxResult<CssQueryFeatureRangeComparison> {
-        support::required_node(&self.syntax, 3usize)
+    pub fn selectors(&self) -> CssSelectorList {
+        support::list(&self.syntax, 1usize)
     }
-    pub fn right(&self) -> SyntaxResult<AnyCssQueryFeatureValue> {
-        support::required_node(&self.syntax, 4usize)
+    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 2usize)
     }
 }
-impl Serialize for CssQueryFeatureRangeInterval {
+impl Serialize for CssScopeEdge {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -6057,18 +5944,16 @@ impl Serialize for CssQueryFeatureRangeInterval {
     }
 }
 #[derive(Serialize)]
-pub struct CssQueryFeatureRangeIntervalFields {
-    pub left: SyntaxResult<AnyCssQueryFeatureValue>,
-    pub left_comparison: SyntaxResult<CssQueryFeatureRangeComparison>,
-    pub name: SyntaxResult<CssIdentifier>,
-    pub right_comparison: SyntaxResult<CssQueryFeatureRangeComparison>,
-    pub right: SyntaxResult<AnyCssQueryFeatureValue>,
+pub struct CssScopeEdgeFields {
+    pub l_paren_token: SyntaxResult<SyntaxToken>,
+    pub selectors: CssSelectorList,
+    pub r_paren_token: SyntaxResult<SyntaxToken>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssQueryFeatureReverseRange {
+pub struct CssScopeRangeEnd {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssQueryFeatureReverseRange {
+impl CssScopeRangeEnd {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -6078,24 +5963,20 @@ impl CssQueryFeatureReverseRange {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssQueryFeatureReverseRangeFields {
-        CssQueryFeatureReverseRangeFields {
-            left: self.left(),
-            comparison: self.comparison(),
-            right: self.right(),
+    pub fn as_fields(&self) -> CssScopeRangeEndFields {
+        CssScopeRangeEndFields {
+            to_token: self.to_token(),
+            end: self.end(),
         }
     }
-    pub fn left(&self) -> SyntaxResult<AnyCssQueryFeatureValue> {
-        support::required_node(&self.syntax, 0usize)
+    pub fn to_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 0usize)
     }
-    pub fn comparison(&self) -> SyntaxResult<CssQueryFeatureRangeComparison> {
+    pub fn end(&self) -> SyntaxResult<CssScopeEdge> {
         support::required_node(&self.syntax, 1usize)
     }
-    pub fn right(&self) -> SyntaxResult<CssIdentifier> {
-        support::required_node(&self.syntax, 2usize)
-    }
 }
-impl Serialize for CssQueryFeatureReverseRange {
+impl Serialize for CssScopeRangeEnd {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -6104,16 +5985,15 @@ impl Serialize for CssQueryFeatureReverseRange {
     }
 }
 #[derive(Serialize)]
-pub struct CssQueryFeatureReverseRangeFields {
-    pub left: SyntaxResult<AnyCssQueryFeatureValue>,
-    pub comparison: SyntaxResult<CssQueryFeatureRangeComparison>,
-    pub right: SyntaxResult<CssIdentifier>,
+pub struct CssScopeRangeEndFields {
+    pub to_token: SyntaxResult<SyntaxToken>,
+    pub end: SyntaxResult<CssScopeEdge>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssRatio {
+pub struct CssScopeRangeInterval {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssRatio {
+impl CssScopeRangeInterval {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -6123,24 +6003,24 @@ impl CssRatio {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssRatioFields {
-        CssRatioFields {
-            numerator: self.numerator(),
-            slash_token: self.slash_token(),
-            denominator: self.denominator(),
+    pub fn as_fields(&self) -> CssScopeRangeIntervalFields {
+        CssScopeRangeIntervalFields {
+            start: self.start(),
+            to_token: self.to_token(),
+            end: self.end(),
         }
     }
-    pub fn numerator(&self) -> SyntaxResult<CssNumber> {
+    pub fn start(&self) -> SyntaxResult<CssScopeEdge> {
         support::required_node(&self.syntax, 0usize)
     }
-    pub fn slash_token(&self) -> SyntaxResult<SyntaxToken> {
+    pub fn to_token(&self) -> SyntaxResult<SyntaxToken> {
         support::required_token(&self.syntax, 1usize)
     }
-    pub fn denominator(&self) -> SyntaxResult<CssNumber> {
+    pub fn end(&self) -> SyntaxResult<CssScopeEdge> {
         support::required_node(&self.syntax, 2usize)
     }
 }
-impl Serialize for CssRatio {
+impl Serialize for CssScopeRangeInterval {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -6149,16 +6029,16 @@ impl Serialize for CssRatio {
     }
 }
 #[derive(Serialize)]
-pub struct CssRatioFields {
-    pub numerator: SyntaxResult<CssNumber>,
-    pub slash_token: SyntaxResult<SyntaxToken>,
-    pub denominator: SyntaxResult<CssNumber>,
+pub struct CssScopeRangeIntervalFields {
+    pub start: SyntaxResult<CssScopeEdge>,
+    pub to_token: SyntaxResult<SyntaxToken>,
+    pub end: SyntaxResult<CssScopeEdge>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssRegularDimension {
+pub struct CssScopeRangeStart {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssRegularDimension {
+impl CssScopeRangeStart {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -6168,20 +6048,16 @@ impl CssRegularDimension {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssRegularDimensionFields {
-        CssRegularDimensionFields {
-            value_token: self.value_token(),
-            unit_token: self.unit_token(),
+    pub fn as_fields(&self) -> CssScopeRangeStartFields {
+        CssScopeRangeStartFields {
+            start: self.start(),
         }
     }
-    pub fn value_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 0usize)
-    }
-    pub fn unit_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 1usize)
+    pub fn start(&self) -> SyntaxResult<CssScopeEdge> {
+        support::required_node(&self.syntax, 0usize)
     }
 }
-impl Serialize for CssRegularDimension {
+impl Serialize for CssScopeRangeStart {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -6190,15 +6066,14 @@ impl Serialize for CssRegularDimension {
     }
 }
 #[derive(Serialize)]
-pub struct CssRegularDimensionFields {
-    pub value_token: SyntaxResult<SyntaxToken>,
-    pub unit_token: SyntaxResult<SyntaxToken>,
+pub struct CssScopeRangeStartFields {
+    pub start: SyntaxResult<CssScopeEdge>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssRelativeSelector {
+pub struct CssStartingStyleAtRule {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssRelativeSelector {
+impl CssStartingStyleAtRule {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -6208,20 +6083,20 @@ impl CssRelativeSelector {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssRelativeSelectorFields {
-        CssRelativeSelectorFields {
-            combinator: self.combinator(),
-            selector: self.selector(),
+    pub fn as_fields(&self) -> CssStartingStyleAtRuleFields {
+        CssStartingStyleAtRuleFields {
+            declarator: self.declarator(),
+            block: self.block(),
         }
     }
-    pub fn combinator(&self) -> Option<SyntaxToken> {
-        support::token(&self.syntax, 0usize)
+    pub fn declarator(&self) -> SyntaxResult<CssStartingStyleAtRuleDeclarator> {
+        support::required_node(&self.syntax, 0usize)
     }
-    pub fn selector(&self) -> SyntaxResult<AnyCssSelector> {
+    pub fn block(&self) -> SyntaxResult<AnyCssConditionalBlock> {
         support::required_node(&self.syntax, 1usize)
     }
 }
-impl Serialize for CssRelativeSelector {
+impl Serialize for CssStartingStyleAtRule {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -6230,15 +6105,15 @@ impl Serialize for CssRelativeSelector {
     }
 }
 #[derive(Serialize)]
-pub struct CssRelativeSelectorFields {
-    pub combinator: Option<SyntaxToken>,
-    pub selector: SyntaxResult<AnyCssSelector>,
+pub struct CssStartingStyleAtRuleFields {
+    pub declarator: SyntaxResult<CssStartingStyleAtRuleDeclarator>,
+    pub block: SyntaxResult<AnyCssConditionalBlock>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssRoot {
+pub struct CssStartingStyleAtRuleDeclarator {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssRoot {
+impl CssStartingStyleAtRuleDeclarator {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -6248,24 +6123,16 @@ impl CssRoot {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssRootFields {
-        CssRootFields {
-            bom_token: self.bom_token(),
-            rules: self.rules(),
-            eof_token: self.eof_token(),
+    pub fn as_fields(&self) -> CssStartingStyleAtRuleDeclaratorFields {
+        CssStartingStyleAtRuleDeclaratorFields {
+            starting_style_token: self.starting_style_token(),
         }
     }
-    pub fn bom_token(&self) -> Option<SyntaxToken> {
-        support::token(&self.syntax, 0usize)
-    }
-    pub fn rules(&self) -> CssRuleList {
-        support::list(&self.syntax, 1usize)
-    }
-    pub fn eof_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 2usize)
+    pub fn starting_style_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 0usize)
     }
 }
-impl Serialize for CssRoot {
+impl Serialize for CssStartingStyleAtRuleDeclarator {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -6274,16 +6141,14 @@ impl Serialize for CssRoot {
     }
 }
 #[derive(Serialize)]
-pub struct CssRootFields {
-    pub bom_token: Option<SyntaxToken>,
-    pub rules: CssRuleList,
-    pub eof_token: SyntaxResult<SyntaxToken>,
+pub struct CssStartingStyleAtRuleDeclaratorFields {
+    pub starting_style_token: SyntaxResult<SyntaxToken>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssRuleBlock {
+pub struct CssString {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssRuleBlock {
+impl CssString {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -6293,24 +6158,16 @@ impl CssRuleBlock {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssRuleBlockFields {
-        CssRuleBlockFields {
-            l_curly_token: self.l_curly_token(),
-            rules: self.rules(),
-            r_curly_token: self.r_curly_token(),
+    pub fn as_fields(&self) -> CssStringFields {
+        CssStringFields {
+            value_token: self.value_token(),
         }
     }
-    pub fn l_curly_token(&self) -> SyntaxResult<SyntaxToken> {
+    pub fn value_token(&self) -> SyntaxResult<SyntaxToken> {
         support::required_token(&self.syntax, 0usize)
     }
-    pub fn rules(&self) -> CssRuleList {
-        support::list(&self.syntax, 1usize)
-    }
-    pub fn r_curly_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 2usize)
-    }
 }
-impl Serialize for CssRuleBlock {
+impl Serialize for CssString {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -6319,16 +6176,14 @@ impl Serialize for CssRuleBlock {
     }
 }
 #[derive(Serialize)]
-pub struct CssRuleBlockFields {
-    pub l_curly_token: SyntaxResult<SyntaxToken>,
-    pub rules: CssRuleList,
-    pub r_curly_token: SyntaxResult<SyntaxToken>,
+pub struct CssStringFields {
+    pub value_token: SyntaxResult<SyntaxToken>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssScopeAtRule {
+pub struct CssSupportsAndCondition {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssScopeAtRule {
+impl CssSupportsAndCondition {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -6338,20 +6193,24 @@ impl CssScopeAtRule {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssScopeAtRuleFields {
-        CssScopeAtRuleFields {
-            declarator: self.declarator(),
-            block: self.block(),
+    pub fn as_fields(&self) -> CssSupportsAndConditionFields {
+        CssSupportsAndConditionFields {
+            left: self.left(),
+            and_token: self.and_token(),
+            right: self.right(),
         }
     }
-    pub fn declarator(&self) -> SyntaxResult<CssScopeAtRuleDeclarator> {
+    pub fn left(&self) -> SyntaxResult<AnyCssSupportsInParens> {
         support::required_node(&self.syntax, 0usize)
     }
-    pub fn block(&self) -> SyntaxResult<AnyCssConditionalBlock> {
-        support::required_node(&self.syntax, 1usize)
+    pub fn and_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 1usize)
+    }
+    pub fn right(&self) -> SyntaxResult<AnyCssSupportsAndCombinableCondition> {
+        support::required_node(&self.syntax, 2usize)
     }
 }
-impl Serialize for CssScopeAtRule {
+impl Serialize for CssSupportsAndCondition {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -6360,15 +6219,16 @@ impl Serialize for CssScopeAtRule {
     }
 }
 #[derive(Serialize)]
-pub struct CssScopeAtRuleFields {
-    pub declarator: SyntaxResult<CssScopeAtRuleDeclarator>,
-    pub block: SyntaxResult<AnyCssConditionalBlock>,
+pub struct CssSupportsAndConditionFields {
+    pub left: SyntaxResult<AnyCssSupportsInParens>,
+    pub and_token: SyntaxResult<SyntaxToken>,
+    pub right: SyntaxResult<AnyCssSupportsAndCombinableCondition>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssScopeAtRuleDeclarator {
+pub struct CssSupportsAtRule {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssScopeAtRuleDeclarator {
+impl CssSupportsAtRule {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -6378,20 +6238,60 @@ impl CssScopeAtRuleDeclarator {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssScopeAtRuleDeclaratorFields {
-        CssScopeAtRuleDeclaratorFields {
-            scope_token: self.scope_token(),
-            range: self.range(),
+    pub fn as_fields(&self) -> CssSupportsAtRuleFields {
+        CssSupportsAtRuleFields {
+            declarator: self.declarator(),
+            block: self.block(),
         }
     }
-    pub fn scope_token(&self) -> SyntaxResult<SyntaxToken> {
+    pub fn declarator(&self) -> SyntaxResult<CssSupportsAtRuleDeclarator> {
+        support::required_node(&self.syntax, 0usize)
+    }
+    pub fn block(&self) -> SyntaxResult<AnyCssConditionalBlock> {
+        support::required_node(&self.syntax, 1usize)
+    }
+}
+impl Serialize for CssSupportsAtRule {
+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
+    where
+        S: Serializer,
+    {
+        self.as_fields().serialize(serializer)
+    }
+}
+#[derive(Serialize)]
+pub struct CssSupportsAtRuleFields {
+    pub declarator: SyntaxResult<CssSupportsAtRuleDeclarator>,
+    pub block: SyntaxResult<AnyCssConditionalBlock>,
+}
+#[derive(Clone, PartialEq, Eq, Hash)]
+pub struct CssSupportsAtRuleDeclarator {
+    pub(crate) syntax: SyntaxNode,
+}
+impl CssSupportsAtRuleDeclarator {
+    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
+    #[doc = r""]
+    #[doc = r" # Safety"]
+    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
+    #[doc = r" or a match on [SyntaxNode::kind]"]
+    #[inline]
+    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
+        Self { syntax }
+    }
+    pub fn as_fields(&self) -> CssSupportsAtRuleDeclaratorFields {
+        CssSupportsAtRuleDeclaratorFields {
+            supports_token: self.supports_token(),
+            condition: self.condition(),
+        }
+    }
+    pub fn supports_token(&self) -> SyntaxResult<SyntaxToken> {
         support::required_token(&self.syntax, 0usize)
     }
-    pub fn range(&self) -> Option<AnyCssScopeRange> {
-        support::node(&self.syntax, 1usize)
+    pub fn condition(&self) -> SyntaxResult<AnyCssSupportsCondition> {
+        support::required_node(&self.syntax, 1usize)
     }
 }
-impl Serialize for CssScopeAtRuleDeclarator {
+impl Serialize for CssSupportsAtRuleDeclarator {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -6400,15 +6300,15 @@ impl Serialize for CssScopeAtRuleDeclarator {
     }
 }
 #[derive(Serialize)]
-pub struct CssScopeAtRuleDeclaratorFields {
-    pub scope_token: SyntaxResult<SyntaxToken>,
-    pub range: Option<AnyCssScopeRange>,
+pub struct CssSupportsAtRuleDeclaratorFields {
+    pub supports_token: SyntaxResult<SyntaxToken>,
+    pub condition: SyntaxResult<AnyCssSupportsCondition>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssScopeEdge {
+pub struct CssSupportsConditionInParens {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssScopeEdge {
+impl CssSupportsConditionInParens {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -6418,24 +6318,24 @@ impl CssScopeEdge {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssScopeEdgeFields {
-        CssScopeEdgeFields {
+    pub fn as_fields(&self) -> CssSupportsConditionInParensFields {
+        CssSupportsConditionInParensFields {
             l_paren_token: self.l_paren_token(),
-            selectors: self.selectors(),
+            condition: self.condition(),
             r_paren_token: self.r_paren_token(),
         }
     }
     pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
         support::required_token(&self.syntax, 0usize)
     }
-    pub fn selectors(&self) -> CssSelectorList {
-        support::list(&self.syntax, 1usize)
+    pub fn condition(&self) -> SyntaxResult<AnyCssSupportsCondition> {
+        support::required_node(&self.syntax, 1usize)
     }
     pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
         support::required_token(&self.syntax, 2usize)
     }
 }
-impl Serialize for CssScopeEdge {
+impl Serialize for CssSupportsConditionInParens {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -6444,16 +6344,16 @@ impl Serialize for CssScopeEdge {
     }
 }
 #[derive(Serialize)]
-pub struct CssScopeEdgeFields {
+pub struct CssSupportsConditionInParensFields {
     pub l_paren_token: SyntaxResult<SyntaxToken>,
-    pub selectors: CssSelectorList,
+    pub condition: SyntaxResult<AnyCssSupportsCondition>,
     pub r_paren_token: SyntaxResult<SyntaxToken>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssScopeRangeEnd {
+pub struct CssSupportsFeatureDeclaration {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssScopeRangeEnd {
+impl CssSupportsFeatureDeclaration {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -6463,20 +6363,24 @@ impl CssScopeRangeEnd {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssScopeRangeEndFields {
-        CssScopeRangeEndFields {
-            to_token: self.to_token(),
-            end: self.end(),
+    pub fn as_fields(&self) -> CssSupportsFeatureDeclarationFields {
+        CssSupportsFeatureDeclarationFields {
+            l_paren_token: self.l_paren_token(),
+            declaration: self.declaration(),
+            r_paren_token: self.r_paren_token(),
         }
     }
-    pub fn to_token(&self) -> SyntaxResult<SyntaxToken> {
+    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
         support::required_token(&self.syntax, 0usize)
     }
-    pub fn end(&self) -> SyntaxResult<CssScopeEdge> {
+    pub fn declaration(&self) -> SyntaxResult<CssDeclaration> {
         support::required_node(&self.syntax, 1usize)
     }
+    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 2usize)
+    }
 }
-impl Serialize for CssScopeRangeEnd {
+impl Serialize for CssSupportsFeatureDeclaration {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -6485,15 +6389,16 @@ impl Serialize for CssScopeRangeEnd {
     }
 }
 #[derive(Serialize)]
-pub struct CssScopeRangeEndFields {
-    pub to_token: SyntaxResult<SyntaxToken>,
-    pub end: SyntaxResult<CssScopeEdge>,
+pub struct CssSupportsFeatureDeclarationFields {
+    pub l_paren_token: SyntaxResult<SyntaxToken>,
+    pub declaration: SyntaxResult<CssDeclaration>,
+    pub r_paren_token: SyntaxResult<SyntaxToken>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssScopeRangeInterval {
+pub struct CssSupportsFeatureSelector {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssScopeRangeInterval {
+impl CssSupportsFeatureSelector {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -6503,24 +6408,28 @@ impl CssScopeRangeInterval {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssScopeRangeIntervalFields {
-        CssScopeRangeIntervalFields {
-            start: self.start(),
-            to_token: self.to_token(),
-            end: self.end(),
+    pub fn as_fields(&self) -> CssSupportsFeatureSelectorFields {
+        CssSupportsFeatureSelectorFields {
+            selector_token: self.selector_token(),
+            l_paren_token: self.l_paren_token(),
+            selector: self.selector(),
+            r_paren_token: self.r_paren_token(),
         }
     }
-    pub fn start(&self) -> SyntaxResult<CssScopeEdge> {
-        support::required_node(&self.syntax, 0usize)
+    pub fn selector_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 0usize)
     }
-    pub fn to_token(&self) -> SyntaxResult<SyntaxToken> {
+    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
         support::required_token(&self.syntax, 1usize)
     }
-    pub fn end(&self) -> SyntaxResult<CssScopeEdge> {
+    pub fn selector(&self) -> SyntaxResult<AnyCssSelector> {
         support::required_node(&self.syntax, 2usize)
     }
+    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 3usize)
+    }
 }
-impl Serialize for CssScopeRangeInterval {
+impl Serialize for CssSupportsFeatureSelector {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -6529,16 +6438,17 @@ impl Serialize for CssScopeRangeInterval {
     }
 }
 #[derive(Serialize)]
-pub struct CssScopeRangeIntervalFields {
-    pub start: SyntaxResult<CssScopeEdge>,
-    pub to_token: SyntaxResult<SyntaxToken>,
-    pub end: SyntaxResult<CssScopeEdge>,
+pub struct CssSupportsFeatureSelectorFields {
+    pub selector_token: SyntaxResult<SyntaxToken>,
+    pub l_paren_token: SyntaxResult<SyntaxToken>,
+    pub selector: SyntaxResult<AnyCssSelector>,
+    pub r_paren_token: SyntaxResult<SyntaxToken>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssScopeRangeStart {
+pub struct CssSupportsNotCondition {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssScopeRangeStart {
+impl CssSupportsNotCondition {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -6548,16 +6458,20 @@ impl CssScopeRangeStart {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssScopeRangeStartFields {
-        CssScopeRangeStartFields {
-            start: self.start(),
+    pub fn as_fields(&self) -> CssSupportsNotConditionFields {
+        CssSupportsNotConditionFields {
+            not_token: self.not_token(),
+            query: self.query(),
         }
     }
-    pub fn start(&self) -> SyntaxResult<CssScopeEdge> {
-        support::required_node(&self.syntax, 0usize)
+    pub fn not_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 0usize)
+    }
+    pub fn query(&self) -> SyntaxResult<AnyCssSupportsInParens> {
+        support::required_node(&self.syntax, 1usize)
     }
 }
-impl Serialize for CssScopeRangeStart {
+impl Serialize for CssSupportsNotCondition {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -6566,14 +6480,15 @@ impl Serialize for CssScopeRangeStart {
     }
 }
 #[derive(Serialize)]
-pub struct CssScopeRangeStartFields {
-    pub start: SyntaxResult<CssScopeEdge>,
+pub struct CssSupportsNotConditionFields {
+    pub not_token: SyntaxResult<SyntaxToken>,
+    pub query: SyntaxResult<AnyCssSupportsInParens>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssStartingStyleAtRule {
+pub struct CssSupportsOrCondition {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssStartingStyleAtRule {
+impl CssSupportsOrCondition {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -6583,20 +6498,24 @@ impl CssStartingStyleAtRule {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssStartingStyleAtRuleFields {
-        CssStartingStyleAtRuleFields {
-            declarator: self.declarator(),
-            block: self.block(),
+    pub fn as_fields(&self) -> CssSupportsOrConditionFields {
+        CssSupportsOrConditionFields {
+            left: self.left(),
+            or_token: self.or_token(),
+            right: self.right(),
         }
     }
-    pub fn declarator(&self) -> SyntaxResult<CssStartingStyleAtRuleDeclarator> {
+    pub fn left(&self) -> SyntaxResult<AnyCssSupportsInParens> {
         support::required_node(&self.syntax, 0usize)
     }
-    pub fn block(&self) -> SyntaxResult<AnyCssConditionalBlock> {
-        support::required_node(&self.syntax, 1usize)
+    pub fn or_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 1usize)
+    }
+    pub fn right(&self) -> SyntaxResult<AnyCssSupportsOrCombinableCondition> {
+        support::required_node(&self.syntax, 2usize)
     }
 }
-impl Serialize for CssStartingStyleAtRule {
+impl Serialize for CssSupportsOrCondition {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -6605,15 +6524,16 @@ impl Serialize for CssStartingStyleAtRule {
     }
 }
 #[derive(Serialize)]
-pub struct CssStartingStyleAtRuleFields {
-    pub declarator: SyntaxResult<CssStartingStyleAtRuleDeclarator>,
-    pub block: SyntaxResult<AnyCssConditionalBlock>,
+pub struct CssSupportsOrConditionFields {
+    pub left: SyntaxResult<AnyCssSupportsInParens>,
+    pub or_token: SyntaxResult<SyntaxToken>,
+    pub right: SyntaxResult<AnyCssSupportsOrCombinableCondition>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssStartingStyleAtRuleDeclarator {
+pub struct CssTypeSelector {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssStartingStyleAtRuleDeclarator {
+impl CssTypeSelector {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -6623,16 +6543,20 @@ impl CssStartingStyleAtRuleDeclarator {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssStartingStyleAtRuleDeclaratorFields {
-        CssStartingStyleAtRuleDeclaratorFields {
-            starting_style_token: self.starting_style_token(),
+    pub fn as_fields(&self) -> CssTypeSelectorFields {
+        CssTypeSelectorFields {
+            namespace: self.namespace(),
+            ident: self.ident(),
         }
     }
-    pub fn starting_style_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 0usize)
+    pub fn namespace(&self) -> Option<CssNamespace> {
+        support::node(&self.syntax, 0usize)
+    }
+    pub fn ident(&self) -> SyntaxResult<CssIdentifier> {
+        support::required_node(&self.syntax, 1usize)
     }
 }
-impl Serialize for CssStartingStyleAtRuleDeclarator {
+impl Serialize for CssTypeSelector {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -6641,14 +6565,15 @@ impl Serialize for CssStartingStyleAtRuleDeclarator {
     }
 }
 #[derive(Serialize)]
-pub struct CssStartingStyleAtRuleDeclaratorFields {
-    pub starting_style_token: SyntaxResult<SyntaxToken>,
+pub struct CssTypeSelectorFields {
+    pub namespace: Option<CssNamespace>,
+    pub ident: SyntaxResult<CssIdentifier>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssString {
+pub struct CssUnicodeCodepoint {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssString {
+impl CssUnicodeCodepoint {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -6658,8 +6583,8 @@ impl CssString {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssStringFields {
-        CssStringFields {
+    pub fn as_fields(&self) -> CssUnicodeCodepointFields {
+        CssUnicodeCodepointFields {
             value_token: self.value_token(),
         }
     }
@@ -6667,7 +6592,7 @@ impl CssString {
         support::required_token(&self.syntax, 0usize)
     }
 }
-impl Serialize for CssString {
+impl Serialize for CssUnicodeCodepoint {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -6676,14 +6601,14 @@ impl Serialize for CssString {
     }
 }
 #[derive(Serialize)]
-pub struct CssStringFields {
+pub struct CssUnicodeCodepointFields {
     pub value_token: SyntaxResult<SyntaxToken>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssSupportsAndCondition {
+pub struct CssUnicodeRange {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssSupportsAndCondition {
+impl CssUnicodeRange {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -6693,24 +6618,20 @@ impl CssSupportsAndCondition {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssSupportsAndConditionFields {
-        CssSupportsAndConditionFields {
-            left: self.left(),
-            and_token: self.and_token(),
-            right: self.right(),
+    pub fn as_fields(&self) -> CssUnicodeRangeFields {
+        CssUnicodeRangeFields {
+            prefix_token: self.prefix_token(),
+            value: self.value(),
         }
     }
-    pub fn left(&self) -> SyntaxResult<AnyCssSupportsInParens> {
-        support::required_node(&self.syntax, 0usize)
+    pub fn prefix_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 0usize)
     }
-    pub fn and_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 1usize)
-    }
-    pub fn right(&self) -> SyntaxResult<AnyCssSupportsAndCombinableCondition> {
-        support::required_node(&self.syntax, 2usize)
+    pub fn value(&self) -> SyntaxResult<AnyCssUnicodeValue> {
+        support::required_node(&self.syntax, 1usize)
     }
 }
-impl Serialize for CssSupportsAndCondition {
+impl Serialize for CssUnicodeRange {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -6719,16 +6640,15 @@ impl Serialize for CssSupportsAndCondition {
     }
 }
 #[derive(Serialize)]
-pub struct CssSupportsAndConditionFields {
-    pub left: SyntaxResult<AnyCssSupportsInParens>,
-    pub and_token: SyntaxResult<SyntaxToken>,
-    pub right: SyntaxResult<AnyCssSupportsAndCombinableCondition>,
+pub struct CssUnicodeRangeFields {
+    pub prefix_token: SyntaxResult<SyntaxToken>,
+    pub value: SyntaxResult<AnyCssUnicodeValue>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssSupportsAtRule {
+pub struct CssUnicodeRangeInterval {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssSupportsAtRule {
+impl CssUnicodeRangeInterval {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -6738,20 +6658,24 @@ impl CssSupportsAtRule {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssSupportsAtRuleFields {
-        CssSupportsAtRuleFields {
-            declarator: self.declarator(),
-            block: self.block(),
+    pub fn as_fields(&self) -> CssUnicodeRangeIntervalFields {
+        CssUnicodeRangeIntervalFields {
+            start: self.start(),
+            minus_token: self.minus_token(),
+            end: self.end(),
         }
     }
-    pub fn declarator(&self) -> SyntaxResult<CssSupportsAtRuleDeclarator> {
+    pub fn start(&self) -> SyntaxResult<CssUnicodeCodepoint> {
         support::required_node(&self.syntax, 0usize)
     }
-    pub fn block(&self) -> SyntaxResult<AnyCssConditionalBlock> {
-        support::required_node(&self.syntax, 1usize)
+    pub fn minus_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 1usize)
+    }
+    pub fn end(&self) -> SyntaxResult<CssUnicodeCodepoint> {
+        support::required_node(&self.syntax, 2usize)
     }
 }
-impl Serialize for CssSupportsAtRule {
+impl Serialize for CssUnicodeRangeInterval {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -6760,15 +6684,16 @@ impl Serialize for CssSupportsAtRule {
     }
 }
 #[derive(Serialize)]
-pub struct CssSupportsAtRuleFields {
-    pub declarator: SyntaxResult<CssSupportsAtRuleDeclarator>,
-    pub block: SyntaxResult<AnyCssConditionalBlock>,
+pub struct CssUnicodeRangeIntervalFields {
+    pub start: SyntaxResult<CssUnicodeCodepoint>,
+    pub minus_token: SyntaxResult<SyntaxToken>,
+    pub end: SyntaxResult<CssUnicodeCodepoint>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssSupportsAtRuleDeclarator {
+pub struct CssUnicodeRangeWildcard {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssSupportsAtRuleDeclarator {
+impl CssUnicodeRangeWildcard {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -6778,20 +6703,16 @@ impl CssSupportsAtRuleDeclarator {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssSupportsAtRuleDeclaratorFields {
-        CssSupportsAtRuleDeclaratorFields {
-            supports_token: self.supports_token(),
-            condition: self.condition(),
+    pub fn as_fields(&self) -> CssUnicodeRangeWildcardFields {
+        CssUnicodeRangeWildcardFields {
+            value_token: self.value_token(),
         }
     }
-    pub fn supports_token(&self) -> SyntaxResult<SyntaxToken> {
+    pub fn value_token(&self) -> SyntaxResult<SyntaxToken> {
         support::required_token(&self.syntax, 0usize)
     }
-    pub fn condition(&self) -> SyntaxResult<AnyCssSupportsCondition> {
-        support::required_node(&self.syntax, 1usize)
-    }
 }
-impl Serialize for CssSupportsAtRuleDeclarator {
+impl Serialize for CssUnicodeRangeWildcard {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -6800,15 +6721,14 @@ impl Serialize for CssSupportsAtRuleDeclarator {
     }
 }
 #[derive(Serialize)]
-pub struct CssSupportsAtRuleDeclaratorFields {
-    pub supports_token: SyntaxResult<SyntaxToken>,
-    pub condition: SyntaxResult<AnyCssSupportsCondition>,
+pub struct CssUnicodeRangeWildcardFields {
+    pub value_token: SyntaxResult<SyntaxToken>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssSupportsConditionInParens {
+pub struct CssUniversalNamespacePrefix {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssSupportsConditionInParens {
+impl CssUniversalNamespacePrefix {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -6818,24 +6738,16 @@ impl CssSupportsConditionInParens {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssSupportsConditionInParensFields {
-        CssSupportsConditionInParensFields {
-            l_paren_token: self.l_paren_token(),
-            condition: self.condition(),
-            r_paren_token: self.r_paren_token(),
+    pub fn as_fields(&self) -> CssUniversalNamespacePrefixFields {
+        CssUniversalNamespacePrefixFields {
+            star_token: self.star_token(),
         }
     }
-    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
+    pub fn star_token(&self) -> SyntaxResult<SyntaxToken> {
         support::required_token(&self.syntax, 0usize)
     }
-    pub fn condition(&self) -> SyntaxResult<AnyCssSupportsCondition> {
-        support::required_node(&self.syntax, 1usize)
-    }
-    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 2usize)
-    }
 }
-impl Serialize for CssSupportsConditionInParens {
+impl Serialize for CssUniversalNamespacePrefix {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -6844,16 +6756,14 @@ impl Serialize for CssSupportsConditionInParens {
     }
 }
 #[derive(Serialize)]
-pub struct CssSupportsConditionInParensFields {
-    pub l_paren_token: SyntaxResult<SyntaxToken>,
-    pub condition: SyntaxResult<AnyCssSupportsCondition>,
-    pub r_paren_token: SyntaxResult<SyntaxToken>,
+pub struct CssUniversalNamespacePrefixFields {
+    pub star_token: SyntaxResult<SyntaxToken>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssSupportsFeatureDeclaration {
+pub struct CssUniversalSelector {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssSupportsFeatureDeclaration {
+impl CssUniversalSelector {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -6863,24 +6773,20 @@ impl CssSupportsFeatureDeclaration {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssSupportsFeatureDeclarationFields {
-        CssSupportsFeatureDeclarationFields {
-            l_paren_token: self.l_paren_token(),
-            declaration: self.declaration(),
-            r_paren_token: self.r_paren_token(),
+    pub fn as_fields(&self) -> CssUniversalSelectorFields {
+        CssUniversalSelectorFields {
+            namespace: self.namespace(),
+            star_token: self.star_token(),
         }
     }
-    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 0usize)
-    }
-    pub fn declaration(&self) -> SyntaxResult<CssDeclaration> {
-        support::required_node(&self.syntax, 1usize)
+    pub fn namespace(&self) -> Option<CssNamespace> {
+        support::node(&self.syntax, 0usize)
     }
-    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 2usize)
+    pub fn star_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 1usize)
     }
 }
-impl Serialize for CssSupportsFeatureDeclaration {
+impl Serialize for CssUniversalSelector {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -6889,16 +6795,15 @@ impl Serialize for CssSupportsFeatureDeclaration {
     }
 }
 #[derive(Serialize)]
-pub struct CssSupportsFeatureDeclarationFields {
-    pub l_paren_token: SyntaxResult<SyntaxToken>,
-    pub declaration: SyntaxResult<CssDeclaration>,
-    pub r_paren_token: SyntaxResult<SyntaxToken>,
+pub struct CssUniversalSelectorFields {
+    pub namespace: Option<CssNamespace>,
+    pub star_token: SyntaxResult<SyntaxToken>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssSupportsFeatureSelector {
+pub struct CssUnknownBlockAtRule {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssSupportsFeatureSelector {
+impl CssUnknownBlockAtRule {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -6908,28 +6813,24 @@ impl CssSupportsFeatureSelector {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssSupportsFeatureSelectorFields {
-        CssSupportsFeatureSelectorFields {
-            selector_token: self.selector_token(),
-            l_paren_token: self.l_paren_token(),
-            selector: self.selector(),
-            r_paren_token: self.r_paren_token(),
+    pub fn as_fields(&self) -> CssUnknownBlockAtRuleFields {
+        CssUnknownBlockAtRuleFields {
+            name: self.name(),
+            components: self.components(),
+            block: self.block(),
         }
     }
-    pub fn selector_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 0usize)
+    pub fn name(&self) -> SyntaxResult<CssIdentifier> {
+        support::required_node(&self.syntax, 0usize)
     }
-    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 1usize)
+    pub fn components(&self) -> SyntaxResult<CssUnknownAtRuleComponentList> {
+        support::required_node(&self.syntax, 1usize)
     }
-    pub fn selector(&self) -> SyntaxResult<AnyCssSelector> {
+    pub fn block(&self) -> SyntaxResult<AnyCssDeclarationOrRuleBlock> {
         support::required_node(&self.syntax, 2usize)
     }
-    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 3usize)
-    }
 }
-impl Serialize for CssSupportsFeatureSelector {
+impl Serialize for CssUnknownBlockAtRule {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -6938,17 +6839,16 @@ impl Serialize for CssSupportsFeatureSelector {
     }
 }
 #[derive(Serialize)]
-pub struct CssSupportsFeatureSelectorFields {
-    pub selector_token: SyntaxResult<SyntaxToken>,
-    pub l_paren_token: SyntaxResult<SyntaxToken>,
-    pub selector: SyntaxResult<AnyCssSelector>,
-    pub r_paren_token: SyntaxResult<SyntaxToken>,
+pub struct CssUnknownBlockAtRuleFields {
+    pub name: SyntaxResult<CssIdentifier>,
+    pub components: SyntaxResult<CssUnknownAtRuleComponentList>,
+    pub block: SyntaxResult<AnyCssDeclarationOrRuleBlock>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssSupportsNotCondition {
+pub struct CssUnknownDimension {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssSupportsNotCondition {
+impl CssUnknownDimension {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -6958,20 +6858,20 @@ impl CssSupportsNotCondition {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssSupportsNotConditionFields {
-        CssSupportsNotConditionFields {
-            not_token: self.not_token(),
-            query: self.query(),
+    pub fn as_fields(&self) -> CssUnknownDimensionFields {
+        CssUnknownDimensionFields {
+            value_token: self.value_token(),
+            unit_token: self.unit_token(),
         }
     }
-    pub fn not_token(&self) -> SyntaxResult<SyntaxToken> {
+    pub fn value_token(&self) -> SyntaxResult<SyntaxToken> {
         support::required_token(&self.syntax, 0usize)
     }
-    pub fn query(&self) -> SyntaxResult<AnyCssSupportsInParens> {
-        support::required_node(&self.syntax, 1usize)
+    pub fn unit_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 1usize)
     }
 }
-impl Serialize for CssSupportsNotCondition {
+impl Serialize for CssUnknownDimension {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -6980,15 +6880,15 @@ impl Serialize for CssSupportsNotCondition {
     }
 }
 #[derive(Serialize)]
-pub struct CssSupportsNotConditionFields {
-    pub not_token: SyntaxResult<SyntaxToken>,
-    pub query: SyntaxResult<AnyCssSupportsInParens>,
+pub struct CssUnknownDimensionFields {
+    pub value_token: SyntaxResult<SyntaxToken>,
+    pub unit_token: SyntaxResult<SyntaxToken>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssSupportsOrCondition {
+pub struct CssUnknownValueAtRule {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssSupportsOrCondition {
+impl CssUnknownValueAtRule {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -6998,24 +6898,24 @@ impl CssSupportsOrCondition {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssSupportsOrConditionFields {
-        CssSupportsOrConditionFields {
-            left: self.left(),
-            or_token: self.or_token(),
-            right: self.right(),
+    pub fn as_fields(&self) -> CssUnknownValueAtRuleFields {
+        CssUnknownValueAtRuleFields {
+            name: self.name(),
+            components: self.components(),
+            semicolon_token: self.semicolon_token(),
         }
     }
-    pub fn left(&self) -> SyntaxResult<AnyCssSupportsInParens> {
+    pub fn name(&self) -> SyntaxResult<CssIdentifier> {
         support::required_node(&self.syntax, 0usize)
     }
-    pub fn or_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 1usize)
+    pub fn components(&self) -> SyntaxResult<CssUnknownAtRuleComponentList> {
+        support::required_node(&self.syntax, 1usize)
     }
-    pub fn right(&self) -> SyntaxResult<AnyCssSupportsOrCombinableCondition> {
-        support::required_node(&self.syntax, 2usize)
+    pub fn semicolon_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 2usize)
     }
 }
-impl Serialize for CssSupportsOrCondition {
+impl Serialize for CssUnknownValueAtRule {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -7024,16 +6924,16 @@ impl Serialize for CssSupportsOrCondition {
     }
 }
 #[derive(Serialize)]
-pub struct CssSupportsOrConditionFields {
-    pub left: SyntaxResult<AnyCssSupportsInParens>,
-    pub or_token: SyntaxResult<SyntaxToken>,
-    pub right: SyntaxResult<AnyCssSupportsOrCombinableCondition>,
+pub struct CssUnknownValueAtRuleFields {
+    pub name: SyntaxResult<CssIdentifier>,
+    pub components: SyntaxResult<CssUnknownAtRuleComponentList>,
+    pub semicolon_token: SyntaxResult<SyntaxToken>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssTypeSelector {
+pub struct CssUrlFunction {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssTypeSelector {
+impl CssUrlFunction {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -7043,37 +6943,52 @@ impl CssTypeSelector {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssTypeSelectorFields {
-        CssTypeSelectorFields {
-            namespace: self.namespace(),
-            ident: self.ident(),
+    pub fn as_fields(&self) -> CssUrlFunctionFields {
+        CssUrlFunctionFields {
+            name: self.name(),
+            l_paren_token: self.l_paren_token(),
+            value: self.value(),
+            modifiers: self.modifiers(),
+            r_paren_token: self.r_paren_token(),
         }
     }
-    pub fn namespace(&self) -> Option<CssNamespace> {
-        support::node(&self.syntax, 0usize)
+    pub fn name(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 0usize)
     }
-    pub fn ident(&self) -> SyntaxResult<CssIdentifier> {
-        support::required_node(&self.syntax, 1usize)
+    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 1usize)
     }
-}
-impl Serialize for CssTypeSelector {
-    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
-    where
-        S: Serializer,
-    {
-        self.as_fields().serialize(serializer)
+    pub fn value(&self) -> Option<AnyCssUrlValue> {
+        support::node(&self.syntax, 2usize)
+    }
+    pub fn modifiers(&self) -> CssUrlModifierList {
+        support::list(&self.syntax, 3usize)
+    }
+    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 4usize)
+    }
+}
+impl Serialize for CssUrlFunction {
+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
+    where
+        S: Serializer,
+    {
+        self.as_fields().serialize(serializer)
     }
 }
 #[derive(Serialize)]
-pub struct CssTypeSelectorFields {
-    pub namespace: Option<CssNamespace>,
-    pub ident: SyntaxResult<CssIdentifier>,
+pub struct CssUrlFunctionFields {
+    pub name: SyntaxResult<SyntaxToken>,
+    pub l_paren_token: SyntaxResult<SyntaxToken>,
+    pub value: Option<AnyCssUrlValue>,
+    pub modifiers: CssUrlModifierList,
+    pub r_paren_token: SyntaxResult<SyntaxToken>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssUnicodeCodepoint {
+pub struct CssUrlValueRaw {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssUnicodeCodepoint {
+impl CssUrlValueRaw {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -7083,8 +6998,8 @@ impl CssUnicodeCodepoint {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssUnicodeCodepointFields {
-        CssUnicodeCodepointFields {
+    pub fn as_fields(&self) -> CssUrlValueRawFields {
+        CssUrlValueRawFields {
             value_token: self.value_token(),
         }
     }
@@ -7092,7 +7007,7 @@ impl CssUnicodeCodepoint {
         support::required_token(&self.syntax, 0usize)
     }
 }
-impl Serialize for CssUnicodeCodepoint {
+impl Serialize for CssUrlValueRaw {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -7101,14 +7016,14 @@ impl Serialize for CssUnicodeCodepoint {
     }
 }
 #[derive(Serialize)]
-pub struct CssUnicodeCodepointFields {
+pub struct CssUrlValueRawFields {
     pub value_token: SyntaxResult<SyntaxToken>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssUnicodeRange {
+pub struct CssValueAtRule {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssUnicodeRange {
+impl CssValueAtRule {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -7118,20 +7033,24 @@ impl CssUnicodeRange {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssUnicodeRangeFields {
-        CssUnicodeRangeFields {
-            prefix_token: self.prefix_token(),
-            value: self.value(),
+    pub fn as_fields(&self) -> CssValueAtRuleFields {
+        CssValueAtRuleFields {
+            value_token: self.value_token(),
+            clause: self.clause(),
+            semicolon_token: self.semicolon_token(),
         }
     }
-    pub fn prefix_token(&self) -> SyntaxResult<SyntaxToken> {
+    pub fn value_token(&self) -> SyntaxResult<SyntaxToken> {
         support::required_token(&self.syntax, 0usize)
     }
-    pub fn value(&self) -> SyntaxResult<AnyCssUnicodeValue> {
+    pub fn clause(&self) -> SyntaxResult<AnyCssValueAtRuleClause> {
         support::required_node(&self.syntax, 1usize)
     }
+    pub fn semicolon_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 2usize)
+    }
 }
-impl Serialize for CssUnicodeRange {
+impl Serialize for CssValueAtRule {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -7140,15 +7059,16 @@ impl Serialize for CssUnicodeRange {
     }
 }
 #[derive(Serialize)]
-pub struct CssUnicodeRangeFields {
-    pub prefix_token: SyntaxResult<SyntaxToken>,
-    pub value: SyntaxResult<AnyCssUnicodeValue>,
+pub struct CssValueAtRuleFields {
+    pub value_token: SyntaxResult<SyntaxToken>,
+    pub clause: SyntaxResult<AnyCssValueAtRuleClause>,
+    pub semicolon_token: SyntaxResult<SyntaxToken>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssUnicodeRangeInterval {
+pub struct CssValueAtRuleDeclarationClause {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssUnicodeRangeInterval {
+impl CssValueAtRuleDeclarationClause {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -7158,24 +7078,16 @@ impl CssUnicodeRangeInterval {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssUnicodeRangeIntervalFields {
-        CssUnicodeRangeIntervalFields {
-            start: self.start(),
-            minus_token: self.minus_token(),
-            end: self.end(),
+    pub fn as_fields(&self) -> CssValueAtRuleDeclarationClauseFields {
+        CssValueAtRuleDeclarationClauseFields {
+            properties: self.properties(),
         }
     }
-    pub fn start(&self) -> SyntaxResult<CssUnicodeCodepoint> {
-        support::required_node(&self.syntax, 0usize)
-    }
-    pub fn minus_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 1usize)
-    }
-    pub fn end(&self) -> SyntaxResult<CssUnicodeCodepoint> {
-        support::required_node(&self.syntax, 2usize)
+    pub fn properties(&self) -> CssValueAtRulePropertyList {
+        support::list(&self.syntax, 0usize)
     }
 }
-impl Serialize for CssUnicodeRangeInterval {
+impl Serialize for CssValueAtRuleDeclarationClause {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -7184,16 +7096,14 @@ impl Serialize for CssUnicodeRangeInterval {
     }
 }
 #[derive(Serialize)]
-pub struct CssUnicodeRangeIntervalFields {
-    pub start: SyntaxResult<CssUnicodeCodepoint>,
-    pub minus_token: SyntaxResult<SyntaxToken>,
-    pub end: SyntaxResult<CssUnicodeCodepoint>,
+pub struct CssValueAtRuleDeclarationClauseFields {
+    pub properties: CssValueAtRulePropertyList,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssUnicodeRangeWildcard {
+pub struct CssValueAtRuleGenericProperty {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssUnicodeRangeWildcard {
+impl CssValueAtRuleGenericProperty {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -7203,16 +7113,24 @@ impl CssUnicodeRangeWildcard {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssUnicodeRangeWildcardFields {
-        CssUnicodeRangeWildcardFields {
-            value_token: self.value_token(),
+    pub fn as_fields(&self) -> CssValueAtRuleGenericPropertyFields {
+        CssValueAtRuleGenericPropertyFields {
+            name: self.name(),
+            colon_token: self.colon_token(),
+            value: self.value(),
         }
     }
-    pub fn value_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 0usize)
+    pub fn name(&self) -> SyntaxResult<AnyCssDeclarationName> {
+        support::required_node(&self.syntax, 0usize)
+    }
+    pub fn colon_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 1usize)
+    }
+    pub fn value(&self) -> SyntaxResult<CssValueAtRuleGenericValue> {
+        support::required_node(&self.syntax, 2usize)
     }
 }
-impl Serialize for CssUnicodeRangeWildcard {
+impl Serialize for CssValueAtRuleGenericProperty {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -7221,14 +7139,16 @@ impl Serialize for CssUnicodeRangeWildcard {
     }
 }
 #[derive(Serialize)]
-pub struct CssUnicodeRangeWildcardFields {
-    pub value_token: SyntaxResult<SyntaxToken>,
+pub struct CssValueAtRuleGenericPropertyFields {
+    pub name: SyntaxResult<AnyCssDeclarationName>,
+    pub colon_token: SyntaxResult<SyntaxToken>,
+    pub value: SyntaxResult<CssValueAtRuleGenericValue>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssUniversalNamespacePrefix {
+pub struct CssValueAtRuleImportClause {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssUniversalNamespacePrefix {
+impl CssValueAtRuleImportClause {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -7238,16 +7158,24 @@ impl CssUniversalNamespacePrefix {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssUniversalNamespacePrefixFields {
-        CssUniversalNamespacePrefixFields {
-            star_token: self.star_token(),
+    pub fn as_fields(&self) -> CssValueAtRuleImportClauseFields {
+        CssValueAtRuleImportClauseFields {
+            specifiers: self.specifiers(),
+            from_token: self.from_token(),
+            source: self.source(),
         }
     }
-    pub fn star_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 0usize)
+    pub fn specifiers(&self) -> CssValueAtRuleImportSpecifierList {
+        support::list(&self.syntax, 0usize)
+    }
+    pub fn from_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 1usize)
+    }
+    pub fn source(&self) -> SyntaxResult<AnyCssValueAtRuleImportSource> {
+        support::required_node(&self.syntax, 2usize)
     }
 }
-impl Serialize for CssUniversalNamespacePrefix {
+impl Serialize for CssValueAtRuleImportClause {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -7256,14 +7184,16 @@ impl Serialize for CssUniversalNamespacePrefix {
     }
 }
 #[derive(Serialize)]
-pub struct CssUniversalNamespacePrefixFields {
-    pub star_token: SyntaxResult<SyntaxToken>,
+pub struct CssValueAtRuleImportClauseFields {
+    pub specifiers: CssValueAtRuleImportSpecifierList,
+    pub from_token: SyntaxResult<SyntaxToken>,
+    pub source: SyntaxResult<AnyCssValueAtRuleImportSource>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssUniversalSelector {
+pub struct CssValueAtRuleImportSpecifier {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssUniversalSelector {
+impl CssValueAtRuleImportSpecifier {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -7273,20 +7203,14 @@ impl CssUniversalSelector {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssUniversalSelectorFields {
-        CssUniversalSelectorFields {
-            namespace: self.namespace(),
-            star_token: self.star_token(),
-        }
-    }
-    pub fn namespace(&self) -> Option<CssNamespace> {
-        support::node(&self.syntax, 0usize)
+    pub fn as_fields(&self) -> CssValueAtRuleImportSpecifierFields {
+        CssValueAtRuleImportSpecifierFields { name: self.name() }
     }
-    pub fn star_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 1usize)
+    pub fn name(&self) -> SyntaxResult<CssIdentifier> {
+        support::required_node(&self.syntax, 0usize)
     }
 }
-impl Serialize for CssUniversalSelector {
+impl Serialize for CssValueAtRuleImportSpecifier {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -7295,15 +7219,14 @@ impl Serialize for CssUniversalSelector {
     }
 }
 #[derive(Serialize)]
-pub struct CssUniversalSelectorFields {
-    pub namespace: Option<CssNamespace>,
-    pub star_token: SyntaxResult<SyntaxToken>,
+pub struct CssValueAtRuleImportSpecifierFields {
+    pub name: SyntaxResult<CssIdentifier>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssUnknownBlockAtRule {
+pub struct CssValueAtRuleNamedImportSpecifier {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssUnknownBlockAtRule {
+impl CssValueAtRuleNamedImportSpecifier {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -7313,24 +7236,24 @@ impl CssUnknownBlockAtRule {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssUnknownBlockAtRuleFields {
-        CssUnknownBlockAtRuleFields {
+    pub fn as_fields(&self) -> CssValueAtRuleNamedImportSpecifierFields {
+        CssValueAtRuleNamedImportSpecifierFields {
             name: self.name(),
-            components: self.components(),
-            block: self.block(),
+            as_token: self.as_token(),
+            local_name: self.local_name(),
         }
     }
     pub fn name(&self) -> SyntaxResult<CssIdentifier> {
         support::required_node(&self.syntax, 0usize)
     }
-    pub fn components(&self) -> SyntaxResult<CssUnknownAtRuleComponentList> {
-        support::required_node(&self.syntax, 1usize)
+    pub fn as_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 1usize)
     }
-    pub fn block(&self) -> SyntaxResult<AnyCssDeclarationOrRuleBlock> {
+    pub fn local_name(&self) -> SyntaxResult<CssIdentifier> {
         support::required_node(&self.syntax, 2usize)
     }
 }
-impl Serialize for CssUnknownBlockAtRule {
+impl Serialize for CssValueAtRuleNamedImportSpecifier {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -7339,16 +7262,16 @@ impl Serialize for CssUnknownBlockAtRule {
     }
 }
 #[derive(Serialize)]
-pub struct CssUnknownBlockAtRuleFields {
+pub struct CssValueAtRuleNamedImportSpecifierFields {
     pub name: SyntaxResult<CssIdentifier>,
-    pub components: SyntaxResult<CssUnknownAtRuleComponentList>,
-    pub block: SyntaxResult<AnyCssDeclarationOrRuleBlock>,
+    pub as_token: SyntaxResult<SyntaxToken>,
+    pub local_name: SyntaxResult<CssIdentifier>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssUnknownDimension {
+pub struct CssViewTransitionAtRule {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssUnknownDimension {
+impl CssViewTransitionAtRule {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -7358,20 +7281,20 @@ impl CssUnknownDimension {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssUnknownDimensionFields {
-        CssUnknownDimensionFields {
-            value_token: self.value_token(),
-            unit_token: self.unit_token(),
+    pub fn as_fields(&self) -> CssViewTransitionAtRuleFields {
+        CssViewTransitionAtRuleFields {
+            declarator: self.declarator(),
+            block: self.block(),
         }
     }
-    pub fn value_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 0usize)
+    pub fn declarator(&self) -> SyntaxResult<CssViewTransitionAtRuleDeclarator> {
+        support::required_node(&self.syntax, 0usize)
     }
-    pub fn unit_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 1usize)
+    pub fn block(&self) -> SyntaxResult<AnyCssDeclarationBlock> {
+        support::required_node(&self.syntax, 1usize)
     }
 }
-impl Serialize for CssUnknownDimension {
+impl Serialize for CssViewTransitionAtRule {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -7380,15 +7303,15 @@ impl Serialize for CssUnknownDimension {
     }
 }
 #[derive(Serialize)]
-pub struct CssUnknownDimensionFields {
-    pub value_token: SyntaxResult<SyntaxToken>,
-    pub unit_token: SyntaxResult<SyntaxToken>,
+pub struct CssViewTransitionAtRuleFields {
+    pub declarator: SyntaxResult<CssViewTransitionAtRuleDeclarator>,
+    pub block: SyntaxResult<AnyCssDeclarationBlock>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssUnknownValueAtRule {
+pub struct CssViewTransitionAtRuleDeclarator {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssUnknownValueAtRule {
+impl CssViewTransitionAtRuleDeclarator {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -7398,24 +7321,16 @@ impl CssUnknownValueAtRule {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssUnknownValueAtRuleFields {
-        CssUnknownValueAtRuleFields {
-            name: self.name(),
-            components: self.components(),
-            semicolon_token: self.semicolon_token(),
+    pub fn as_fields(&self) -> CssViewTransitionAtRuleDeclaratorFields {
+        CssViewTransitionAtRuleDeclaratorFields {
+            view_transition_token: self.view_transition_token(),
         }
     }
-    pub fn name(&self) -> SyntaxResult<CssIdentifier> {
-        support::required_node(&self.syntax, 0usize)
-    }
-    pub fn components(&self) -> SyntaxResult<CssUnknownAtRuleComponentList> {
-        support::required_node(&self.syntax, 1usize)
-    }
-    pub fn semicolon_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 2usize)
+    pub fn view_transition_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 0usize)
     }
 }
-impl Serialize for CssUnknownValueAtRule {
+impl Serialize for CssViewTransitionAtRuleDeclarator {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -7424,16 +7339,14 @@ impl Serialize for CssUnknownValueAtRule {
     }
 }
 #[derive(Serialize)]
-pub struct CssUnknownValueAtRuleFields {
-    pub name: SyntaxResult<CssIdentifier>,
-    pub components: SyntaxResult<CssUnknownAtRuleComponentList>,
-    pub semicolon_token: SyntaxResult<SyntaxToken>,
+pub struct CssViewTransitionAtRuleDeclaratorFields {
+    pub view_transition_token: SyntaxResult<SyntaxToken>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssUrlFunction {
+pub struct TwApplyAtRule {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssUrlFunction {
+impl TwApplyAtRule {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -7443,32 +7356,24 @@ impl CssUrlFunction {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssUrlFunctionFields {
-        CssUrlFunctionFields {
-            name: self.name(),
-            l_paren_token: self.l_paren_token(),
-            value: self.value(),
-            modifiers: self.modifiers(),
-            r_paren_token: self.r_paren_token(),
+    pub fn as_fields(&self) -> TwApplyAtRuleFields {
+        TwApplyAtRuleFields {
+            apply_token: self.apply_token(),
+            classes: self.classes(),
+            semicolon_token: self.semicolon_token(),
         }
     }
-    pub fn name(&self) -> SyntaxResult<SyntaxToken> {
+    pub fn apply_token(&self) -> SyntaxResult<SyntaxToken> {
         support::required_token(&self.syntax, 0usize)
     }
-    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 1usize)
-    }
-    pub fn value(&self) -> Option<AnyCssUrlValue> {
-        support::node(&self.syntax, 2usize)
-    }
-    pub fn modifiers(&self) -> CssUrlModifierList {
-        support::list(&self.syntax, 3usize)
+    pub fn classes(&self) -> TwApplyClassList {
+        support::list(&self.syntax, 1usize)
     }
-    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 4usize)
+    pub fn semicolon_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 2usize)
     }
 }
-impl Serialize for CssUrlFunction {
+impl Serialize for TwApplyAtRule {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -7477,18 +7382,16 @@ impl Serialize for CssUrlFunction {
     }
 }
 #[derive(Serialize)]
-pub struct CssUrlFunctionFields {
-    pub name: SyntaxResult<SyntaxToken>,
-    pub l_paren_token: SyntaxResult<SyntaxToken>,
-    pub value: Option<AnyCssUrlValue>,
-    pub modifiers: CssUrlModifierList,
-    pub r_paren_token: SyntaxResult<SyntaxToken>,
+pub struct TwApplyAtRuleFields {
+    pub apply_token: SyntaxResult<SyntaxToken>,
+    pub classes: TwApplyClassList,
+    pub semicolon_token: SyntaxResult<SyntaxToken>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssUrlValueRaw {
+pub struct TwConfigAtRule {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssUrlValueRaw {
+impl TwConfigAtRule {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -7498,16 +7401,24 @@ impl CssUrlValueRaw {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssUrlValueRawFields {
-        CssUrlValueRawFields {
-            value_token: self.value_token(),
+    pub fn as_fields(&self) -> TwConfigAtRuleFields {
+        TwConfigAtRuleFields {
+            config_token: self.config_token(),
+            path: self.path(),
+            semicolon_token: self.semicolon_token(),
         }
     }
-    pub fn value_token(&self) -> SyntaxResult<SyntaxToken> {
+    pub fn config_token(&self) -> SyntaxResult<SyntaxToken> {
         support::required_token(&self.syntax, 0usize)
     }
+    pub fn path(&self) -> SyntaxResult<CssString> {
+        support::required_node(&self.syntax, 1usize)
+    }
+    pub fn semicolon_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 2usize)
+    }
 }
-impl Serialize for CssUrlValueRaw {
+impl Serialize for TwConfigAtRule {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -7516,14 +7427,16 @@ impl Serialize for CssUrlValueRaw {
     }
 }
 #[derive(Serialize)]
-pub struct CssUrlValueRawFields {
-    pub value_token: SyntaxResult<SyntaxToken>,
+pub struct TwConfigAtRuleFields {
+    pub config_token: SyntaxResult<SyntaxToken>,
+    pub path: SyntaxResult<CssString>,
+    pub semicolon_token: SyntaxResult<SyntaxToken>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssValueAtRule {
+pub struct TwCustomVariantAtRule {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssValueAtRule {
+impl TwCustomVariantAtRule {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -7533,24 +7446,24 @@ impl CssValueAtRule {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssValueAtRuleFields {
-        CssValueAtRuleFields {
-            value_token: self.value_token(),
-            clause: self.clause(),
-            semicolon_token: self.semicolon_token(),
+    pub fn as_fields(&self) -> TwCustomVariantAtRuleFields {
+        TwCustomVariantAtRuleFields {
+            custom_variant_token: self.custom_variant_token(),
+            name: self.name(),
+            selector: self.selector(),
         }
     }
-    pub fn value_token(&self) -> SyntaxResult<SyntaxToken> {
+    pub fn custom_variant_token(&self) -> SyntaxResult<SyntaxToken> {
         support::required_token(&self.syntax, 0usize)
     }
-    pub fn clause(&self) -> SyntaxResult<AnyCssValueAtRuleClause> {
+    pub fn name(&self) -> SyntaxResult<CssIdentifier> {
         support::required_node(&self.syntax, 1usize)
     }
-    pub fn semicolon_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 2usize)
+    pub fn selector(&self) -> SyntaxResult<AnyTwCustomVariantSelector> {
+        support::required_node(&self.syntax, 2usize)
     }
 }
-impl Serialize for CssValueAtRule {
+impl Serialize for TwCustomVariantAtRule {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -7559,16 +7472,16 @@ impl Serialize for CssValueAtRule {
     }
 }
 #[derive(Serialize)]
-pub struct CssValueAtRuleFields {
-    pub value_token: SyntaxResult<SyntaxToken>,
-    pub clause: SyntaxResult<AnyCssValueAtRuleClause>,
-    pub semicolon_token: SyntaxResult<SyntaxToken>,
+pub struct TwCustomVariantAtRuleFields {
+    pub custom_variant_token: SyntaxResult<SyntaxToken>,
+    pub name: SyntaxResult<CssIdentifier>,
+    pub selector: SyntaxResult<AnyTwCustomVariantSelector>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssValueAtRuleDeclarationClause {
+pub struct TwCustomVariantShorthand {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssValueAtRuleDeclarationClause {
+impl TwCustomVariantShorthand {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -7578,16 +7491,28 @@ impl CssValueAtRuleDeclarationClause {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssValueAtRuleDeclarationClauseFields {
-        CssValueAtRuleDeclarationClauseFields {
-            properties: self.properties(),
+    pub fn as_fields(&self) -> TwCustomVariantShorthandFields {
+        TwCustomVariantShorthandFields {
+            l_paren_token: self.l_paren_token(),
+            selector: self.selector(),
+            r_paren_token: self.r_paren_token(),
+            semicolon_token: self.semicolon_token(),
         }
     }
-    pub fn properties(&self) -> CssValueAtRulePropertyList {
-        support::list(&self.syntax, 0usize)
+    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 0usize)
+    }
+    pub fn selector(&self) -> SyntaxResult<AnyTwCustomVariantShorthand> {
+        support::required_node(&self.syntax, 1usize)
+    }
+    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 2usize)
+    }
+    pub fn semicolon_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 3usize)
     }
 }
-impl Serialize for CssValueAtRuleDeclarationClause {
+impl Serialize for TwCustomVariantShorthand {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -7596,14 +7521,17 @@ impl Serialize for CssValueAtRuleDeclarationClause {
     }
 }
 #[derive(Serialize)]
-pub struct CssValueAtRuleDeclarationClauseFields {
-    pub properties: CssValueAtRulePropertyList,
+pub struct TwCustomVariantShorthandFields {
+    pub l_paren_token: SyntaxResult<SyntaxToken>,
+    pub selector: SyntaxResult<AnyTwCustomVariantShorthand>,
+    pub r_paren_token: SyntaxResult<SyntaxToken>,
+    pub semicolon_token: SyntaxResult<SyntaxToken>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssValueAtRuleGenericProperty {
+pub struct TwFunctionalUtilityName {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssValueAtRuleGenericProperty {
+impl TwFunctionalUtilityName {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -7613,24 +7541,24 @@ impl CssValueAtRuleGenericProperty {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssValueAtRuleGenericPropertyFields {
-        CssValueAtRuleGenericPropertyFields {
-            name: self.name(),
-            colon_token: self.colon_token(),
-            value: self.value(),
+    pub fn as_fields(&self) -> TwFunctionalUtilityNameFields {
+        TwFunctionalUtilityNameFields {
+            identifier: self.identifier(),
+            minus_token: self.minus_token(),
+            star_token: self.star_token(),
         }
     }
-    pub fn name(&self) -> SyntaxResult<AnyCssDeclarationName> {
+    pub fn identifier(&self) -> SyntaxResult<CssIdentifier> {
         support::required_node(&self.syntax, 0usize)
     }
-    pub fn colon_token(&self) -> SyntaxResult<SyntaxToken> {
+    pub fn minus_token(&self) -> SyntaxResult<SyntaxToken> {
         support::required_token(&self.syntax, 1usize)
     }
-    pub fn value(&self) -> SyntaxResult<CssValueAtRuleGenericValue> {
-        support::required_node(&self.syntax, 2usize)
+    pub fn star_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 2usize)
     }
 }
-impl Serialize for CssValueAtRuleGenericProperty {
+impl Serialize for TwFunctionalUtilityName {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -7639,16 +7567,16 @@ impl Serialize for CssValueAtRuleGenericProperty {
     }
 }
 #[derive(Serialize)]
-pub struct CssValueAtRuleGenericPropertyFields {
-    pub name: SyntaxResult<AnyCssDeclarationName>,
-    pub colon_token: SyntaxResult<SyntaxToken>,
-    pub value: SyntaxResult<CssValueAtRuleGenericValue>,
+pub struct TwFunctionalUtilityNameFields {
+    pub identifier: SyntaxResult<CssIdentifier>,
+    pub minus_token: SyntaxResult<SyntaxToken>,
+    pub star_token: SyntaxResult<SyntaxToken>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssValueAtRuleImportClause {
+pub struct TwPluginAtRule {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssValueAtRuleImportClause {
+impl TwPluginAtRule {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -7658,24 +7586,28 @@ impl CssValueAtRuleImportClause {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssValueAtRuleImportClauseFields {
-        CssValueAtRuleImportClauseFields {
-            specifiers: self.specifiers(),
-            from_token: self.from_token(),
-            source: self.source(),
+    pub fn as_fields(&self) -> TwPluginAtRuleFields {
+        TwPluginAtRuleFields {
+            plugin_token: self.plugin_token(),
+            name: self.name(),
+            block: self.block(),
+            semicolon_token: self.semicolon_token(),
         }
     }
-    pub fn specifiers(&self) -> CssValueAtRuleImportSpecifierList {
-        support::list(&self.syntax, 0usize)
+    pub fn plugin_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 0usize)
     }
-    pub fn from_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 1usize)
+    pub fn name(&self) -> SyntaxResult<CssString> {
+        support::required_node(&self.syntax, 1usize)
     }
-    pub fn source(&self) -> SyntaxResult<AnyCssValueAtRuleImportSource> {
-        support::required_node(&self.syntax, 2usize)
+    pub fn block(&self) -> Option<AnyCssDeclarationBlock> {
+        support::node(&self.syntax, 2usize)
+    }
+    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
+        support::token(&self.syntax, 3usize)
     }
 }
-impl Serialize for CssValueAtRuleImportClause {
+impl Serialize for TwPluginAtRule {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -7684,16 +7616,17 @@ impl Serialize for CssValueAtRuleImportClause {
     }
 }
 #[derive(Serialize)]
-pub struct CssValueAtRuleImportClauseFields {
-    pub specifiers: CssValueAtRuleImportSpecifierList,
-    pub from_token: SyntaxResult<SyntaxToken>,
-    pub source: SyntaxResult<AnyCssValueAtRuleImportSource>,
+pub struct TwPluginAtRuleFields {
+    pub plugin_token: SyntaxResult<SyntaxToken>,
+    pub name: SyntaxResult<CssString>,
+    pub block: Option<AnyCssDeclarationBlock>,
+    pub semicolon_token: Option<SyntaxToken>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssValueAtRuleImportSpecifier {
+pub struct TwReferenceAtRule {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssValueAtRuleImportSpecifier {
+impl TwReferenceAtRule {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -7703,14 +7636,24 @@ impl CssValueAtRuleImportSpecifier {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssValueAtRuleImportSpecifierFields {
-        CssValueAtRuleImportSpecifierFields { name: self.name() }
+    pub fn as_fields(&self) -> TwReferenceAtRuleFields {
+        TwReferenceAtRuleFields {
+            reference_token: self.reference_token(),
+            path: self.path(),
+            semicolon_token: self.semicolon_token(),
+        }
     }
-    pub fn name(&self) -> SyntaxResult<CssIdentifier> {
-        support::required_node(&self.syntax, 0usize)
+    pub fn reference_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 0usize)
+    }
+    pub fn path(&self) -> SyntaxResult<CssString> {
+        support::required_node(&self.syntax, 1usize)
+    }
+    pub fn semicolon_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 2usize)
     }
 }
-impl Serialize for CssValueAtRuleImportSpecifier {
+impl Serialize for TwReferenceAtRule {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -7719,14 +7662,16 @@ impl Serialize for CssValueAtRuleImportSpecifier {
     }
 }
 #[derive(Serialize)]
-pub struct CssValueAtRuleImportSpecifierFields {
-    pub name: SyntaxResult<CssIdentifier>,
+pub struct TwReferenceAtRuleFields {
+    pub reference_token: SyntaxResult<SyntaxToken>,
+    pub path: SyntaxResult<CssString>,
+    pub semicolon_token: SyntaxResult<SyntaxToken>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssValueAtRuleNamedImportSpecifier {
+pub struct TwSlotAtRule {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssValueAtRuleNamedImportSpecifier {
+impl TwSlotAtRule {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -7736,24 +7681,20 @@ impl CssValueAtRuleNamedImportSpecifier {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssValueAtRuleNamedImportSpecifierFields {
-        CssValueAtRuleNamedImportSpecifierFields {
-            name: self.name(),
-            as_token: self.as_token(),
-            local_name: self.local_name(),
+    pub fn as_fields(&self) -> TwSlotAtRuleFields {
+        TwSlotAtRuleFields {
+            slot_token: self.slot_token(),
+            semicolon_token: self.semicolon_token(),
         }
     }
-    pub fn name(&self) -> SyntaxResult<CssIdentifier> {
-        support::required_node(&self.syntax, 0usize)
+    pub fn slot_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 0usize)
     }
-    pub fn as_token(&self) -> SyntaxResult<SyntaxToken> {
+    pub fn semicolon_token(&self) -> SyntaxResult<SyntaxToken> {
         support::required_token(&self.syntax, 1usize)
     }
-    pub fn local_name(&self) -> SyntaxResult<CssIdentifier> {
-        support::required_node(&self.syntax, 2usize)
-    }
 }
-impl Serialize for CssValueAtRuleNamedImportSpecifier {
+impl Serialize for TwSlotAtRule {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -7762,16 +7703,15 @@ impl Serialize for CssValueAtRuleNamedImportSpecifier {
     }
 }
 #[derive(Serialize)]
-pub struct CssValueAtRuleNamedImportSpecifierFields {
-    pub name: SyntaxResult<CssIdentifier>,
-    pub as_token: SyntaxResult<SyntaxToken>,
-    pub local_name: SyntaxResult<CssIdentifier>,
+pub struct TwSlotAtRuleFields {
+    pub slot_token: SyntaxResult<SyntaxToken>,
+    pub semicolon_token: SyntaxResult<SyntaxToken>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssViewTransitionAtRule {
+pub struct TwSourceAtRule {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssViewTransitionAtRule {
+impl TwSourceAtRule {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -7781,20 +7721,28 @@ impl CssViewTransitionAtRule {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssViewTransitionAtRuleFields {
-        CssViewTransitionAtRuleFields {
-            declarator: self.declarator(),
-            block: self.block(),
+    pub fn as_fields(&self) -> TwSourceAtRuleFields {
+        TwSourceAtRuleFields {
+            source_token: self.source_token(),
+            not_token: self.not_token(),
+            source: self.source(),
+            semicolon_token: self.semicolon_token(),
         }
     }
-    pub fn declarator(&self) -> SyntaxResult<CssViewTransitionAtRuleDeclarator> {
-        support::required_node(&self.syntax, 0usize)
+    pub fn source_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 0usize)
     }
-    pub fn block(&self) -> SyntaxResult<AnyCssDeclarationBlock> {
-        support::required_node(&self.syntax, 1usize)
+    pub fn not_token(&self) -> Option<SyntaxToken> {
+        support::token(&self.syntax, 1usize)
+    }
+    pub fn source(&self) -> SyntaxResult<AnyTwSource> {
+        support::required_node(&self.syntax, 2usize)
+    }
+    pub fn semicolon_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 3usize)
     }
 }
-impl Serialize for CssViewTransitionAtRule {
+impl Serialize for TwSourceAtRule {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -7803,15 +7751,17 @@ impl Serialize for CssViewTransitionAtRule {
     }
 }
 #[derive(Serialize)]
-pub struct CssViewTransitionAtRuleFields {
-    pub declarator: SyntaxResult<CssViewTransitionAtRuleDeclarator>,
-    pub block: SyntaxResult<AnyCssDeclarationBlock>,
+pub struct TwSourceAtRuleFields {
+    pub source_token: SyntaxResult<SyntaxToken>,
+    pub not_token: Option<SyntaxToken>,
+    pub source: SyntaxResult<AnyTwSource>,
+    pub semicolon_token: SyntaxResult<SyntaxToken>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct CssViewTransitionAtRuleDeclarator {
+pub struct TwSourceInline {
     pub(crate) syntax: SyntaxNode,
 }
-impl CssViewTransitionAtRuleDeclarator {
+impl TwSourceInline {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -7821,16 +7771,28 @@ impl CssViewTransitionAtRuleDeclarator {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> CssViewTransitionAtRuleDeclaratorFields {
-        CssViewTransitionAtRuleDeclaratorFields {
-            view_transition_token: self.view_transition_token(),
+    pub fn as_fields(&self) -> TwSourceInlineFields {
+        TwSourceInlineFields {
+            inline_token: self.inline_token(),
+            l_paren_token: self.l_paren_token(),
+            content: self.content(),
+            r_paren_token: self.r_paren_token(),
         }
     }
-    pub fn view_transition_token(&self) -> SyntaxResult<SyntaxToken> {
+    pub fn inline_token(&self) -> SyntaxResult<SyntaxToken> {
         support::required_token(&self.syntax, 0usize)
     }
+    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 1usize)
+    }
+    pub fn content(&self) -> SyntaxResult<CssString> {
+        support::required_node(&self.syntax, 2usize)
+    }
+    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 3usize)
+    }
 }
-impl Serialize for CssViewTransitionAtRuleDeclarator {
+impl Serialize for TwSourceInline {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -7839,14 +7801,17 @@ impl Serialize for CssViewTransitionAtRuleDeclarator {
     }
 }
 #[derive(Serialize)]
-pub struct CssViewTransitionAtRuleDeclaratorFields {
-    pub view_transition_token: SyntaxResult<SyntaxToken>,
+pub struct TwSourceInlineFields {
+    pub inline_token: SyntaxResult<SyntaxToken>,
+    pub l_paren_token: SyntaxResult<SyntaxToken>,
+    pub content: SyntaxResult<CssString>,
+    pub r_paren_token: SyntaxResult<SyntaxToken>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct TwApplyAtRule {
+pub struct TwThemeAtRule {
     pub(crate) syntax: SyntaxNode,
 }
-impl TwApplyAtRule {
+impl TwThemeAtRule {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -7856,24 +7821,24 @@ impl TwApplyAtRule {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> TwApplyAtRuleFields {
-        TwApplyAtRuleFields {
-            apply_token: self.apply_token(),
-            classes: self.classes(),
-            semicolon_token: self.semicolon_token(),
+    pub fn as_fields(&self) -> TwThemeAtRuleFields {
+        TwThemeAtRuleFields {
+            theme_token: self.theme_token(),
+            name: self.name(),
+            block: self.block(),
         }
     }
-    pub fn apply_token(&self) -> SyntaxResult<SyntaxToken> {
+    pub fn theme_token(&self) -> SyntaxResult<SyntaxToken> {
         support::required_token(&self.syntax, 0usize)
     }
-    pub fn classes(&self) -> TwApplyClassList {
-        support::list(&self.syntax, 1usize)
+    pub fn name(&self) -> Option<CssIdentifier> {
+        support::node(&self.syntax, 1usize)
     }
-    pub fn semicolon_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 2usize)
+    pub fn block(&self) -> SyntaxResult<AnyCssDeclarationOrRuleBlock> {
+        support::required_node(&self.syntax, 2usize)
     }
 }
-impl Serialize for TwApplyAtRule {
+impl Serialize for TwThemeAtRule {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -7882,16 +7847,16 @@ impl Serialize for TwApplyAtRule {
     }
 }
 #[derive(Serialize)]
-pub struct TwApplyAtRuleFields {
-    pub apply_token: SyntaxResult<SyntaxToken>,
-    pub classes: TwApplyClassList,
-    pub semicolon_token: SyntaxResult<SyntaxToken>,
+pub struct TwThemeAtRuleFields {
+    pub theme_token: SyntaxResult<SyntaxToken>,
+    pub name: Option<CssIdentifier>,
+    pub block: SyntaxResult<AnyCssDeclarationOrRuleBlock>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct TwConfigAtRule {
+pub struct TwUtilityAtRule {
     pub(crate) syntax: SyntaxNode,
 }
-impl TwConfigAtRule {
+impl TwUtilityAtRule {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -7901,24 +7866,24 @@ impl TwConfigAtRule {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> TwConfigAtRuleFields {
-        TwConfigAtRuleFields {
-            config_token: self.config_token(),
-            path: self.path(),
-            semicolon_token: self.semicolon_token(),
+    pub fn as_fields(&self) -> TwUtilityAtRuleFields {
+        TwUtilityAtRuleFields {
+            utility_token: self.utility_token(),
+            name: self.name(),
+            block: self.block(),
         }
     }
-    pub fn config_token(&self) -> SyntaxResult<SyntaxToken> {
+    pub fn utility_token(&self) -> SyntaxResult<SyntaxToken> {
         support::required_token(&self.syntax, 0usize)
     }
-    pub fn path(&self) -> SyntaxResult<CssString> {
+    pub fn name(&self) -> SyntaxResult<AnyTwUtilityName> {
         support::required_node(&self.syntax, 1usize)
     }
-    pub fn semicolon_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 2usize)
+    pub fn block(&self) -> SyntaxResult<AnyCssDeclarationOrRuleBlock> {
+        support::required_node(&self.syntax, 2usize)
     }
 }
-impl Serialize for TwConfigAtRule {
+impl Serialize for TwUtilityAtRule {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -7927,16 +7892,16 @@ impl Serialize for TwConfigAtRule {
     }
 }
 #[derive(Serialize)]
-pub struct TwConfigAtRuleFields {
-    pub config_token: SyntaxResult<SyntaxToken>,
-    pub path: SyntaxResult<CssString>,
-    pub semicolon_token: SyntaxResult<SyntaxToken>,
+pub struct TwUtilityAtRuleFields {
+    pub utility_token: SyntaxResult<SyntaxToken>,
+    pub name: SyntaxResult<AnyTwUtilityName>,
+    pub block: SyntaxResult<AnyCssDeclarationOrRuleBlock>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct TwCustomVariantAtRule {
+pub struct TwValueThemeReference {
     pub(crate) syntax: SyntaxNode,
 }
-impl TwCustomVariantAtRule {
+impl TwValueThemeReference {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -7946,24 +7911,24 @@ impl TwCustomVariantAtRule {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> TwCustomVariantAtRuleFields {
-        TwCustomVariantAtRuleFields {
-            custom_variant_token: self.custom_variant_token(),
-            name: self.name(),
-            selector: self.selector(),
+    pub fn as_fields(&self) -> TwValueThemeReferenceFields {
+        TwValueThemeReferenceFields {
+            reference: self.reference(),
+            minus_token: self.minus_token(),
+            star_token: self.star_token(),
         }
     }
-    pub fn custom_variant_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 0usize)
+    pub fn reference(&self) -> SyntaxResult<CssDashedIdentifier> {
+        support::required_node(&self.syntax, 0usize)
     }
-    pub fn name(&self) -> SyntaxResult<CssIdentifier> {
-        support::required_node(&self.syntax, 1usize)
+    pub fn minus_token(&self) -> Option<SyntaxToken> {
+        support::token(&self.syntax, 1usize)
     }
-    pub fn selector(&self) -> SyntaxResult<AnyTwCustomVariantSelector> {
-        support::required_node(&self.syntax, 2usize)
+    pub fn star_token(&self) -> SyntaxResult<SyntaxToken> {
+        support::required_token(&self.syntax, 2usize)
     }
 }
-impl Serialize for TwCustomVariantAtRule {
+impl Serialize for TwValueThemeReference {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -7972,16 +7937,16 @@ impl Serialize for TwCustomVariantAtRule {
     }
 }
 #[derive(Serialize)]
-pub struct TwCustomVariantAtRuleFields {
-    pub custom_variant_token: SyntaxResult<SyntaxToken>,
-    pub name: SyntaxResult<CssIdentifier>,
-    pub selector: SyntaxResult<AnyTwCustomVariantSelector>,
+pub struct TwValueThemeReferenceFields {
+    pub reference: SyntaxResult<CssDashedIdentifier>,
+    pub minus_token: Option<SyntaxToken>,
+    pub star_token: SyntaxResult<SyntaxToken>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct TwCustomVariantShorthand {
+pub struct TwVariantAtRule {
     pub(crate) syntax: SyntaxNode,
 }
-impl TwCustomVariantShorthand {
+impl TwVariantAtRule {
     #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
     #[doc = r""]
     #[doc = r" # Safety"]
@@ -7991,28 +7956,24 @@ impl TwCustomVariantShorthand {
     pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
         Self { syntax }
     }
-    pub fn as_fields(&self) -> TwCustomVariantShorthandFields {
-        TwCustomVariantShorthandFields {
-            l_paren_token: self.l_paren_token(),
-            selector: self.selector(),
-            r_paren_token: self.r_paren_token(),
-            semicolon_token: self.semicolon_token(),
+    pub fn as_fields(&self) -> TwVariantAtRuleFields {
+        TwVariantAtRuleFields {
+            variant_token: self.variant_token(),
+            name: self.name(),
+            block: self.block(),
         }
     }
-    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
+    pub fn variant_token(&self) -> SyntaxResult<SyntaxToken> {
         support::required_token(&self.syntax, 0usize)
     }
-    pub fn selector(&self) -> SyntaxResult<AnyTwCustomVariantShorthand> {
+    pub fn name(&self) -> SyntaxResult<CssIdentifier> {
         support::required_node(&self.syntax, 1usize)
     }
-    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 2usize)
-    }
-    pub fn semicolon_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 3usize)
+    pub fn block(&self) -> SyntaxResult<AnyCssDeclarationOrRuleBlock> {
+        support::required_node(&self.syntax, 2usize)
     }
 }
-impl Serialize for TwCustomVariantShorthand {
+impl Serialize for TwVariantAtRule {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -8021,880 +7982,810 @@ impl Serialize for TwCustomVariantShorthand {
     }
 }
 #[derive(Serialize)]
-pub struct TwCustomVariantShorthandFields {
-    pub l_paren_token: SyntaxResult<SyntaxToken>,
-    pub selector: SyntaxResult<AnyTwCustomVariantShorthand>,
-    pub r_paren_token: SyntaxResult<SyntaxToken>,
-    pub semicolon_token: SyntaxResult<SyntaxToken>,
-}
-#[derive(Clone, PartialEq, Eq, Hash)]
-pub struct TwFunctionalUtilityName {
-    pub(crate) syntax: SyntaxNode,
+pub struct TwVariantAtRuleFields {
+    pub variant_token: SyntaxResult<SyntaxToken>,
+    pub name: SyntaxResult<CssIdentifier>,
+    pub block: SyntaxResult<AnyCssDeclarationOrRuleBlock>,
 }
-impl TwFunctionalUtilityName {
-    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
-    #[doc = r""]
-    #[doc = r" # Safety"]
-    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
-    #[doc = r" or a match on [SyntaxNode::kind]"]
-    #[inline]
-    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
-        Self { syntax }
-    }
-    pub fn as_fields(&self) -> TwFunctionalUtilityNameFields {
-        TwFunctionalUtilityNameFields {
-            identifier: self.identifier(),
-            minus_token: self.minus_token(),
-            star_token: self.star_token(),
-        }
-    }
-    pub fn identifier(&self) -> SyntaxResult<CssIdentifier> {
-        support::required_node(&self.syntax, 0usize)
-    }
-    pub fn minus_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 1usize)
+#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
+pub enum AnyCssAtRule {
+    CssBogusAtRule(CssBogusAtRule),
+    CssCharsetAtRule(CssCharsetAtRule),
+    CssColorProfileAtRule(CssColorProfileAtRule),
+    CssContainerAtRule(CssContainerAtRule),
+    CssCounterStyleAtRule(CssCounterStyleAtRule),
+    CssDocumentAtRule(CssDocumentAtRule),
+    CssFontFaceAtRule(CssFontFaceAtRule),
+    CssFontFeatureValuesAtRule(CssFontFeatureValuesAtRule),
+    CssFontPaletteValuesAtRule(CssFontPaletteValuesAtRule),
+    CssImportAtRule(CssImportAtRule),
+    CssKeyframesAtRule(CssKeyframesAtRule),
+    CssLayerAtRule(CssLayerAtRule),
+    CssMediaAtRule(CssMediaAtRule),
+    CssNamespaceAtRule(CssNamespaceAtRule),
+    CssPageAtRule(CssPageAtRule),
+    CssPositionTryAtRule(CssPositionTryAtRule),
+    CssPropertyAtRule(CssPropertyAtRule),
+    CssScopeAtRule(CssScopeAtRule),
+    CssStartingStyleAtRule(CssStartingStyleAtRule),
+    CssSupportsAtRule(CssSupportsAtRule),
+    CssUnknownBlockAtRule(CssUnknownBlockAtRule),
+    CssUnknownValueAtRule(CssUnknownValueAtRule),
+    CssValueAtRule(CssValueAtRule),
+    CssViewTransitionAtRule(CssViewTransitionAtRule),
+    TwApplyAtRule(TwApplyAtRule),
+    TwConfigAtRule(TwConfigAtRule),
+    TwCustomVariantAtRule(TwCustomVariantAtRule),
+    TwPluginAtRule(TwPluginAtRule),
+    TwReferenceAtRule(TwReferenceAtRule),
+    TwSlotAtRule(TwSlotAtRule),
+    TwSourceAtRule(TwSourceAtRule),
+    TwThemeAtRule(TwThemeAtRule),
+    TwUtilityAtRule(TwUtilityAtRule),
+    TwVariantAtRule(TwVariantAtRule),
+}
+impl AnyCssAtRule {
+    pub fn as_css_bogus_at_rule(&self) -> Option<&CssBogusAtRule> {
+        match &self {
+            Self::CssBogusAtRule(item) => Some(item),
+            _ => None,
+        }
     }
-    pub fn star_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 2usize)
+    pub fn as_css_charset_at_rule(&self) -> Option<&CssCharsetAtRule> {
+        match &self {
+            Self::CssCharsetAtRule(item) => Some(item),
+            _ => None,
+        }
     }
-}
-impl Serialize for TwFunctionalUtilityName {
-    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
-    where
-        S: Serializer,
-    {
-        self.as_fields().serialize(serializer)
+    pub fn as_css_color_profile_at_rule(&self) -> Option<&CssColorProfileAtRule> {
+        match &self {
+            Self::CssColorProfileAtRule(item) => Some(item),
+            _ => None,
+        }
     }
-}
-#[derive(Serialize)]
-pub struct TwFunctionalUtilityNameFields {
-    pub identifier: SyntaxResult<CssIdentifier>,
-    pub minus_token: SyntaxResult<SyntaxToken>,
-    pub star_token: SyntaxResult<SyntaxToken>,
-}
-#[derive(Clone, PartialEq, Eq, Hash)]
-pub struct TwPluginAtRule {
-    pub(crate) syntax: SyntaxNode,
-}
-impl TwPluginAtRule {
-    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
-    #[doc = r""]
-    #[doc = r" # Safety"]
-    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
-    #[doc = r" or a match on [SyntaxNode::kind]"]
-    #[inline]
-    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
-        Self { syntax }
+    pub fn as_css_container_at_rule(&self) -> Option<&CssContainerAtRule> {
+        match &self {
+            Self::CssContainerAtRule(item) => Some(item),
+            _ => None,
+        }
     }
-    pub fn as_fields(&self) -> TwPluginAtRuleFields {
-        TwPluginAtRuleFields {
-            plugin_token: self.plugin_token(),
-            name: self.name(),
-            block: self.block(),
-            semicolon_token: self.semicolon_token(),
+    pub fn as_css_counter_style_at_rule(&self) -> Option<&CssCounterStyleAtRule> {
+        match &self {
+            Self::CssCounterStyleAtRule(item) => Some(item),
+            _ => None,
         }
     }
-    pub fn plugin_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 0usize)
+    pub fn as_css_document_at_rule(&self) -> Option<&CssDocumentAtRule> {
+        match &self {
+            Self::CssDocumentAtRule(item) => Some(item),
+            _ => None,
+        }
     }
-    pub fn name(&self) -> SyntaxResult<CssString> {
-        support::required_node(&self.syntax, 1usize)
+    pub fn as_css_font_face_at_rule(&self) -> Option<&CssFontFaceAtRule> {
+        match &self {
+            Self::CssFontFaceAtRule(item) => Some(item),
+            _ => None,
+        }
     }
-    pub fn block(&self) -> Option<AnyCssDeclarationBlock> {
-        support::node(&self.syntax, 2usize)
+    pub fn as_css_font_feature_values_at_rule(&self) -> Option<&CssFontFeatureValuesAtRule> {
+        match &self {
+            Self::CssFontFeatureValuesAtRule(item) => Some(item),
+            _ => None,
+        }
     }
-    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
-        support::token(&self.syntax, 3usize)
+    pub fn as_css_font_palette_values_at_rule(&self) -> Option<&CssFontPaletteValuesAtRule> {
+        match &self {
+            Self::CssFontPaletteValuesAtRule(item) => Some(item),
+            _ => None,
+        }
     }
-}
-impl Serialize for TwPluginAtRule {
-    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
-    where
-        S: Serializer,
-    {
-        self.as_fields().serialize(serializer)
+    pub fn as_css_import_at_rule(&self) -> Option<&CssImportAtRule> {
+        match &self {
+            Self::CssImportAtRule(item) => Some(item),
+            _ => None,
+        }
     }
-}
-#[derive(Serialize)]
-pub struct TwPluginAtRuleFields {
-    pub plugin_token: SyntaxResult<SyntaxToken>,
-    pub name: SyntaxResult<CssString>,
-    pub block: Option<AnyCssDeclarationBlock>,
-    pub semicolon_token: Option<SyntaxToken>,
-}
-#[derive(Clone, PartialEq, Eq, Hash)]
-pub struct TwReferenceAtRule {
-    pub(crate) syntax: SyntaxNode,
-}
-impl TwReferenceAtRule {
-    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
-    #[doc = r""]
-    #[doc = r" # Safety"]
-    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
-    #[doc = r" or a match on [SyntaxNode::kind]"]
-    #[inline]
-    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
-        Self { syntax }
+    pub fn as_css_keyframes_at_rule(&self) -> Option<&CssKeyframesAtRule> {
+        match &self {
+            Self::CssKeyframesAtRule(item) => Some(item),
+            _ => None,
+        }
     }
-    pub fn as_fields(&self) -> TwReferenceAtRuleFields {
-        TwReferenceAtRuleFields {
-            reference_token: self.reference_token(),
-            path: self.path(),
-            semicolon_token: self.semicolon_token(),
+    pub fn as_css_layer_at_rule(&self) -> Option<&CssLayerAtRule> {
+        match &self {
+            Self::CssLayerAtRule(item) => Some(item),
+            _ => None,
         }
     }
-    pub fn reference_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 0usize)
+    pub fn as_css_media_at_rule(&self) -> Option<&CssMediaAtRule> {
+        match &self {
+            Self::CssMediaAtRule(item) => Some(item),
+            _ => None,
+        }
     }
-    pub fn path(&self) -> SyntaxResult<CssString> {
-        support::required_node(&self.syntax, 1usize)
+    pub fn as_css_namespace_at_rule(&self) -> Option<&CssNamespaceAtRule> {
+        match &self {
+            Self::CssNamespaceAtRule(item) => Some(item),
+            _ => None,
+        }
     }
-    pub fn semicolon_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 2usize)
+    pub fn as_css_page_at_rule(&self) -> Option<&CssPageAtRule> {
+        match &self {
+            Self::CssPageAtRule(item) => Some(item),
+            _ => None,
+        }
     }
-}
-impl Serialize for TwReferenceAtRule {
-    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
-    where
-        S: Serializer,
-    {
-        self.as_fields().serialize(serializer)
+    pub fn as_css_position_try_at_rule(&self) -> Option<&CssPositionTryAtRule> {
+        match &self {
+            Self::CssPositionTryAtRule(item) => Some(item),
+            _ => None,
+        }
     }
-}
-#[derive(Serialize)]
-pub struct TwReferenceAtRuleFields {
-    pub reference_token: SyntaxResult<SyntaxToken>,
-    pub path: SyntaxResult<CssString>,
-    pub semicolon_token: SyntaxResult<SyntaxToken>,
-}
-#[derive(Clone, PartialEq, Eq, Hash)]
-pub struct TwSlotAtRule {
-    pub(crate) syntax: SyntaxNode,
-}
-impl TwSlotAtRule {
-    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
-    #[doc = r""]
-    #[doc = r" # Safety"]
-    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
-    #[doc = r" or a match on [SyntaxNode::kind]"]
-    #[inline]
-    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
-        Self { syntax }
+    pub fn as_css_property_at_rule(&self) -> Option<&CssPropertyAtRule> {
+        match &self {
+            Self::CssPropertyAtRule(item) => Some(item),
+            _ => None,
+        }
     }
-    pub fn as_fields(&self) -> TwSlotAtRuleFields {
-        TwSlotAtRuleFields {
-            slot_token: self.slot_token(),
-            semicolon_token: self.semicolon_token(),
+    pub fn as_css_scope_at_rule(&self) -> Option<&CssScopeAtRule> {
+        match &self {
+            Self::CssScopeAtRule(item) => Some(item),
+            _ => None,
         }
     }
-    pub fn slot_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 0usize)
+    pub fn as_css_starting_style_at_rule(&self) -> Option<&CssStartingStyleAtRule> {
+        match &self {
+            Self::CssStartingStyleAtRule(item) => Some(item),
+            _ => None,
+        }
     }
-    pub fn semicolon_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 1usize)
+    pub fn as_css_supports_at_rule(&self) -> Option<&CssSupportsAtRule> {
+        match &self {
+            Self::CssSupportsAtRule(item) => Some(item),
+            _ => None,
+        }
     }
-}
-impl Serialize for TwSlotAtRule {
-    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
-    where
-        S: Serializer,
-    {
-        self.as_fields().serialize(serializer)
-    }
-}
-#[derive(Serialize)]
-pub struct TwSlotAtRuleFields {
-    pub slot_token: SyntaxResult<SyntaxToken>,
-    pub semicolon_token: SyntaxResult<SyntaxToken>,
-}
-#[derive(Clone, PartialEq, Eq, Hash)]
-pub struct TwSourceAtRule {
-    pub(crate) syntax: SyntaxNode,
-}
-impl TwSourceAtRule {
-    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
-    #[doc = r""]
-    #[doc = r" # Safety"]
-    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
-    #[doc = r" or a match on [SyntaxNode::kind]"]
-    #[inline]
-    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
-        Self { syntax }
+    pub fn as_css_unknown_block_at_rule(&self) -> Option<&CssUnknownBlockAtRule> {
+        match &self {
+            Self::CssUnknownBlockAtRule(item) => Some(item),
+            _ => None,
+        }
     }
-    pub fn as_fields(&self) -> TwSourceAtRuleFields {
-        TwSourceAtRuleFields {
-            source_token: self.source_token(),
-            not_token: self.not_token(),
-            source: self.source(),
-            semicolon_token: self.semicolon_token(),
+    pub fn as_css_unknown_value_at_rule(&self) -> Option<&CssUnknownValueAtRule> {
+        match &self {
+            Self::CssUnknownValueAtRule(item) => Some(item),
+            _ => None,
         }
     }
-    pub fn source_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 0usize)
+    pub fn as_css_value_at_rule(&self) -> Option<&CssValueAtRule> {
+        match &self {
+            Self::CssValueAtRule(item) => Some(item),
+            _ => None,
+        }
     }
-    pub fn not_token(&self) -> Option<SyntaxToken> {
-        support::token(&self.syntax, 1usize)
+    pub fn as_css_view_transition_at_rule(&self) -> Option<&CssViewTransitionAtRule> {
+        match &self {
+            Self::CssViewTransitionAtRule(item) => Some(item),
+            _ => None,
+        }
     }
-    pub fn source(&self) -> SyntaxResult<AnyTwSource> {
-        support::required_node(&self.syntax, 2usize)
+    pub fn as_tw_apply_at_rule(&self) -> Option<&TwApplyAtRule> {
+        match &self {
+            Self::TwApplyAtRule(item) => Some(item),
+            _ => None,
+        }
     }
-    pub fn semicolon_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 3usize)
+    pub fn as_tw_config_at_rule(&self) -> Option<&TwConfigAtRule> {
+        match &self {
+            Self::TwConfigAtRule(item) => Some(item),
+            _ => None,
+        }
     }
-}
-impl Serialize for TwSourceAtRule {
-    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
-    where
-        S: Serializer,
-    {
-        self.as_fields().serialize(serializer)
+    pub fn as_tw_custom_variant_at_rule(&self) -> Option<&TwCustomVariantAtRule> {
+        match &self {
+            Self::TwCustomVariantAtRule(item) => Some(item),
+            _ => None,
+        }
     }
-}
-#[derive(Serialize)]
-pub struct TwSourceAtRuleFields {
-    pub source_token: SyntaxResult<SyntaxToken>,
-    pub not_token: Option<SyntaxToken>,
-    pub source: SyntaxResult<AnyTwSource>,
-    pub semicolon_token: SyntaxResult<SyntaxToken>,
-}
-#[derive(Clone, PartialEq, Eq, Hash)]
-pub struct TwSourceInline {
-    pub(crate) syntax: SyntaxNode,
-}
-impl TwSourceInline {
-    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
-    #[doc = r""]
-    #[doc = r" # Safety"]
-    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
-    #[doc = r" or a match on [SyntaxNode::kind]"]
-    #[inline]
-    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
-        Self { syntax }
+    pub fn as_tw_plugin_at_rule(&self) -> Option<&TwPluginAtRule> {
+        match &self {
+            Self::TwPluginAtRule(item) => Some(item),
+            _ => None,
+        }
     }
-    pub fn as_fields(&self) -> TwSourceInlineFields {
-        TwSourceInlineFields {
-            inline_token: self.inline_token(),
-            l_paren_token: self.l_paren_token(),
-            content: self.content(),
-            r_paren_token: self.r_paren_token(),
+    pub fn as_tw_reference_at_rule(&self) -> Option<&TwReferenceAtRule> {
+        match &self {
+            Self::TwReferenceAtRule(item) => Some(item),
+            _ => None,
         }
     }
-    pub fn inline_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 0usize)
+    pub fn as_tw_slot_at_rule(&self) -> Option<&TwSlotAtRule> {
+        match &self {
+            Self::TwSlotAtRule(item) => Some(item),
+            _ => None,
+        }
     }
-    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 1usize)
+    pub fn as_tw_source_at_rule(&self) -> Option<&TwSourceAtRule> {
+        match &self {
+            Self::TwSourceAtRule(item) => Some(item),
+            _ => None,
+        }
     }
-    pub fn content(&self) -> SyntaxResult<CssString> {
-        support::required_node(&self.syntax, 2usize)
+    pub fn as_tw_theme_at_rule(&self) -> Option<&TwThemeAtRule> {
+        match &self {
+            Self::TwThemeAtRule(item) => Some(item),
+            _ => None,
+        }
     }
-    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 3usize)
+    pub fn as_tw_utility_at_rule(&self) -> Option<&TwUtilityAtRule> {
+        match &self {
+            Self::TwUtilityAtRule(item) => Some(item),
+            _ => None,
+        }
     }
-}
-impl Serialize for TwSourceInline {
-    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
-    where
-        S: Serializer,
-    {
-        self.as_fields().serialize(serializer)
+    pub fn as_tw_variant_at_rule(&self) -> Option<&TwVariantAtRule> {
+        match &self {
+            Self::TwVariantAtRule(item) => Some(item),
+            _ => None,
+        }
     }
 }
-#[derive(Serialize)]
-pub struct TwSourceInlineFields {
-    pub inline_token: SyntaxResult<SyntaxToken>,
-    pub l_paren_token: SyntaxResult<SyntaxToken>,
-    pub content: SyntaxResult<CssString>,
-    pub r_paren_token: SyntaxResult<SyntaxToken>,
-}
-#[derive(Clone, PartialEq, Eq, Hash)]
-pub struct TwThemeAtRule {
-    pub(crate) syntax: SyntaxNode,
+#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
+pub enum AnyCssAtRuleDeclarator {
+    CssColorProfileAtRuleDeclarator(CssColorProfileAtRuleDeclarator),
+    CssContainerAtRuleDeclarator(CssContainerAtRuleDeclarator),
+    CssCounterStyleAtRuleDeclarator(CssCounterStyleAtRuleDeclarator),
+    CssFontFaceAtRuleDeclarator(CssFontFaceAtRuleDeclarator),
+    CssFontPaletteValuesAtRuleDeclarator(CssFontPaletteValuesAtRuleDeclarator),
+    CssMediaAtRuleDeclarator(CssMediaAtRuleDeclarator),
+    CssPositionTryAtRuleDeclarator(CssPositionTryAtRuleDeclarator),
+    CssPropertyAtRuleDeclarator(CssPropertyAtRuleDeclarator),
+    CssScopeAtRuleDeclarator(CssScopeAtRuleDeclarator),
+    CssStartingStyleAtRuleDeclarator(CssStartingStyleAtRuleDeclarator),
+    CssSupportsAtRuleDeclarator(CssSupportsAtRuleDeclarator),
+    CssViewTransitionAtRuleDeclarator(CssViewTransitionAtRuleDeclarator),
 }
-impl TwThemeAtRule {
-    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
-    #[doc = r""]
-    #[doc = r" # Safety"]
-    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
-    #[doc = r" or a match on [SyntaxNode::kind]"]
-    #[inline]
-    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
-        Self { syntax }
+impl AnyCssAtRuleDeclarator {
+    pub fn as_css_color_profile_at_rule_declarator(
+        &self,
+    ) -> Option<&CssColorProfileAtRuleDeclarator> {
+        match &self {
+            Self::CssColorProfileAtRuleDeclarator(item) => Some(item),
+            _ => None,
+        }
     }
-    pub fn as_fields(&self) -> TwThemeAtRuleFields {
-        TwThemeAtRuleFields {
-            theme_token: self.theme_token(),
-            name: self.name(),
-            block: self.block(),
+    pub fn as_css_container_at_rule_declarator(&self) -> Option<&CssContainerAtRuleDeclarator> {
+        match &self {
+            Self::CssContainerAtRuleDeclarator(item) => Some(item),
+            _ => None,
         }
     }
-    pub fn theme_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 0usize)
+    pub fn as_css_counter_style_at_rule_declarator(
+        &self,
+    ) -> Option<&CssCounterStyleAtRuleDeclarator> {
+        match &self {
+            Self::CssCounterStyleAtRuleDeclarator(item) => Some(item),
+            _ => None,
+        }
     }
-    pub fn name(&self) -> Option<CssIdentifier> {
-        support::node(&self.syntax, 1usize)
+    pub fn as_css_font_face_at_rule_declarator(&self) -> Option<&CssFontFaceAtRuleDeclarator> {
+        match &self {
+            Self::CssFontFaceAtRuleDeclarator(item) => Some(item),
+            _ => None,
+        }
     }
-    pub fn block(&self) -> SyntaxResult<AnyCssDeclarationOrRuleBlock> {
-        support::required_node(&self.syntax, 2usize)
+    pub fn as_css_font_palette_values_at_rule_declarator(
+        &self,
+    ) -> Option<&CssFontPaletteValuesAtRuleDeclarator> {
+        match &self {
+            Self::CssFontPaletteValuesAtRuleDeclarator(item) => Some(item),
+            _ => None,
+        }
     }
-}
-impl Serialize for TwThemeAtRule {
-    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
-    where
-        S: Serializer,
-    {
-        self.as_fields().serialize(serializer)
+    pub fn as_css_media_at_rule_declarator(&self) -> Option<&CssMediaAtRuleDeclarator> {
+        match &self {
+            Self::CssMediaAtRuleDeclarator(item) => Some(item),
+            _ => None,
+        }
     }
-}
-#[derive(Serialize)]
-pub struct TwThemeAtRuleFields {
-    pub theme_token: SyntaxResult<SyntaxToken>,
-    pub name: Option<CssIdentifier>,
-    pub block: SyntaxResult<AnyCssDeclarationOrRuleBlock>,
-}
-#[derive(Clone, PartialEq, Eq, Hash)]
-pub struct TwUtilityAtRule {
-    pub(crate) syntax: SyntaxNode,
-}
-impl TwUtilityAtRule {
-    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
-    #[doc = r""]
-    #[doc = r" # Safety"]
-    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
-    #[doc = r" or a match on [SyntaxNode::kind]"]
-    #[inline]
-    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
-        Self { syntax }
-    }
-    pub fn as_fields(&self) -> TwUtilityAtRuleFields {
-        TwUtilityAtRuleFields {
-            utility_token: self.utility_token(),
-            name: self.name(),
-            block: self.block(),
-        }
-    }
-    pub fn utility_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 0usize)
-    }
-    pub fn name(&self) -> SyntaxResult<AnyTwUtilityName> {
-        support::required_node(&self.syntax, 1usize)
-    }
-    pub fn block(&self) -> SyntaxResult<AnyCssDeclarationOrRuleBlock> {
-        support::required_node(&self.syntax, 2usize)
-    }
-}
-impl Serialize for TwUtilityAtRule {
-    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
-    where
-        S: Serializer,
-    {
-        self.as_fields().serialize(serializer)
-    }
-}
-#[derive(Serialize)]
-pub struct TwUtilityAtRuleFields {
-    pub utility_token: SyntaxResult<SyntaxToken>,
-    pub name: SyntaxResult<AnyTwUtilityName>,
-    pub block: SyntaxResult<AnyCssDeclarationOrRuleBlock>,
-}
-#[derive(Clone, PartialEq, Eq, Hash)]
-pub struct TwValueThemeReference {
-    pub(crate) syntax: SyntaxNode,
-}
-impl TwValueThemeReference {
-    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
-    #[doc = r""]
-    #[doc = r" # Safety"]
-    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
-    #[doc = r" or a match on [SyntaxNode::kind]"]
-    #[inline]
-    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
-        Self { syntax }
-    }
-    pub fn as_fields(&self) -> TwValueThemeReferenceFields {
-        TwValueThemeReferenceFields {
-            reference: self.reference(),
-            minus_token: self.minus_token(),
-            star_token: self.star_token(),
-        }
-    }
-    pub fn reference(&self) -> SyntaxResult<CssDashedIdentifier> {
-        support::required_node(&self.syntax, 0usize)
-    }
-    pub fn minus_token(&self) -> Option<SyntaxToken> {
-        support::token(&self.syntax, 1usize)
-    }
-    pub fn star_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 2usize)
-    }
-}
-impl Serialize for TwValueThemeReference {
-    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
-    where
-        S: Serializer,
-    {
-        self.as_fields().serialize(serializer)
-    }
-}
-#[derive(Serialize)]
-pub struct TwValueThemeReferenceFields {
-    pub reference: SyntaxResult<CssDashedIdentifier>,
-    pub minus_token: Option<SyntaxToken>,
-    pub star_token: SyntaxResult<SyntaxToken>,
-}
-#[derive(Clone, PartialEq, Eq, Hash)]
-pub struct TwVariantAtRule {
-    pub(crate) syntax: SyntaxNode,
-}
-impl TwVariantAtRule {
-    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
-    #[doc = r""]
-    #[doc = r" # Safety"]
-    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
-    #[doc = r" or a match on [SyntaxNode::kind]"]
-    #[inline]
-    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
-        Self { syntax }
-    }
-    pub fn as_fields(&self) -> TwVariantAtRuleFields {
-        TwVariantAtRuleFields {
-            variant_token: self.variant_token(),
-            name: self.name(),
-            block: self.block(),
-        }
-    }
-    pub fn variant_token(&self) -> SyntaxResult<SyntaxToken> {
-        support::required_token(&self.syntax, 0usize)
-    }
-    pub fn name(&self) -> SyntaxResult<CssIdentifier> {
-        support::required_node(&self.syntax, 1usize)
-    }
-    pub fn block(&self) -> SyntaxResult<AnyCssDeclarationOrRuleBlock> {
-        support::required_node(&self.syntax, 2usize)
-    }
-}
-impl Serialize for TwVariantAtRule {
-    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
-    where
-        S: Serializer,
-    {
-        self.as_fields().serialize(serializer)
-    }
-}
-#[derive(Serialize)]
-pub struct TwVariantAtRuleFields {
-    pub variant_token: SyntaxResult<SyntaxToken>,
-    pub name: SyntaxResult<CssIdentifier>,
-    pub block: SyntaxResult<AnyCssDeclarationOrRuleBlock>,
-}
-#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssAtRule {
-    CssBogusAtRule(CssBogusAtRule),
-    CssCharsetAtRule(CssCharsetAtRule),
-    CssColorProfileAtRule(CssColorProfileAtRule),
-    CssContainerAtRule(CssContainerAtRule),
-    CssCounterStyleAtRule(CssCounterStyleAtRule),
-    CssDocumentAtRule(CssDocumentAtRule),
-    CssFontFaceAtRule(CssFontFaceAtRule),
-    CssFontFeatureValuesAtRule(CssFontFeatureValuesAtRule),
-    CssFontPaletteValuesAtRule(CssFontPaletteValuesAtRule),
-    CssImportAtRule(CssImportAtRule),
-    CssKeyframesAtRule(CssKeyframesAtRule),
-    CssLayerAtRule(CssLayerAtRule),
-    CssMediaAtRule(CssMediaAtRule),
-    CssNamespaceAtRule(CssNamespaceAtRule),
-    CssPageAtRule(CssPageAtRule),
-    CssPositionTryAtRule(CssPositionTryAtRule),
-    CssPropertyAtRule(CssPropertyAtRule),
-    CssScopeAtRule(CssScopeAtRule),
-    CssStartingStyleAtRule(CssStartingStyleAtRule),
-    CssSupportsAtRule(CssSupportsAtRule),
-    CssUnknownBlockAtRule(CssUnknownBlockAtRule),
-    CssUnknownValueAtRule(CssUnknownValueAtRule),
-    CssValueAtRule(CssValueAtRule),
-    CssViewTransitionAtRule(CssViewTransitionAtRule),
-    TwApplyAtRule(TwApplyAtRule),
-    TwConfigAtRule(TwConfigAtRule),
-    TwCustomVariantAtRule(TwCustomVariantAtRule),
-    TwPluginAtRule(TwPluginAtRule),
-    TwReferenceAtRule(TwReferenceAtRule),
-    TwSlotAtRule(TwSlotAtRule),
-    TwSourceAtRule(TwSourceAtRule),
-    TwThemeAtRule(TwThemeAtRule),
-    TwUtilityAtRule(TwUtilityAtRule),
-    TwVariantAtRule(TwVariantAtRule),
-}
-impl AnyCssAtRule {
-    pub fn as_css_bogus_at_rule(&self) -> Option<&CssBogusAtRule> {
+    pub fn as_css_position_try_at_rule_declarator(
+        &self,
+    ) -> Option<&CssPositionTryAtRuleDeclarator> {
         match &self {
-            Self::CssBogusAtRule(item) => Some(item),
+            Self::CssPositionTryAtRuleDeclarator(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_charset_at_rule(&self) -> Option<&CssCharsetAtRule> {
+    pub fn as_css_property_at_rule_declarator(&self) -> Option<&CssPropertyAtRuleDeclarator> {
         match &self {
-            Self::CssCharsetAtRule(item) => Some(item),
+            Self::CssPropertyAtRuleDeclarator(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_color_profile_at_rule(&self) -> Option<&CssColorProfileAtRule> {
+    pub fn as_css_scope_at_rule_declarator(&self) -> Option<&CssScopeAtRuleDeclarator> {
         match &self {
-            Self::CssColorProfileAtRule(item) => Some(item),
+            Self::CssScopeAtRuleDeclarator(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_container_at_rule(&self) -> Option<&CssContainerAtRule> {
+    pub fn as_css_starting_style_at_rule_declarator(
+        &self,
+    ) -> Option<&CssStartingStyleAtRuleDeclarator> {
         match &self {
-            Self::CssContainerAtRule(item) => Some(item),
+            Self::CssStartingStyleAtRuleDeclarator(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_counter_style_at_rule(&self) -> Option<&CssCounterStyleAtRule> {
+    pub fn as_css_supports_at_rule_declarator(&self) -> Option<&CssSupportsAtRuleDeclarator> {
         match &self {
-            Self::CssCounterStyleAtRule(item) => Some(item),
+            Self::CssSupportsAtRuleDeclarator(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_document_at_rule(&self) -> Option<&CssDocumentAtRule> {
+    pub fn as_css_view_transition_at_rule_declarator(
+        &self,
+    ) -> Option<&CssViewTransitionAtRuleDeclarator> {
         match &self {
-            Self::CssDocumentAtRule(item) => Some(item),
+            Self::CssViewTransitionAtRuleDeclarator(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_font_face_at_rule(&self) -> Option<&CssFontFaceAtRule> {
+}
+#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
+pub enum AnyCssAttributeMatcherValue {
+    CssIdentifier(CssIdentifier),
+    CssString(CssString),
+}
+impl AnyCssAttributeMatcherValue {
+    pub fn as_css_identifier(&self) -> Option<&CssIdentifier> {
         match &self {
-            Self::CssFontFaceAtRule(item) => Some(item),
+            Self::CssIdentifier(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_font_feature_values_at_rule(&self) -> Option<&CssFontFeatureValuesAtRule> {
+    pub fn as_css_string(&self) -> Option<&CssString> {
         match &self {
-            Self::CssFontFeatureValuesAtRule(item) => Some(item),
+            Self::CssString(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_font_palette_values_at_rule(&self) -> Option<&CssFontPaletteValuesAtRule> {
+}
+#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
+pub enum AnyCssComposesImportSource {
+    CssIdentifier(CssIdentifier),
+    CssString(CssString),
+}
+impl AnyCssComposesImportSource {
+    pub fn as_css_identifier(&self) -> Option<&CssIdentifier> {
         match &self {
-            Self::CssFontPaletteValuesAtRule(item) => Some(item),
+            Self::CssIdentifier(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_import_at_rule(&self) -> Option<&CssImportAtRule> {
+    pub fn as_css_string(&self) -> Option<&CssString> {
         match &self {
-            Self::CssImportAtRule(item) => Some(item),
+            Self::CssString(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_keyframes_at_rule(&self) -> Option<&CssKeyframesAtRule> {
+}
+#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
+pub enum AnyCssCompoundSelector {
+    CssBogusSelector(CssBogusSelector),
+    CssCompoundSelector(CssCompoundSelector),
+}
+impl AnyCssCompoundSelector {
+    pub fn as_css_bogus_selector(&self) -> Option<&CssBogusSelector> {
         match &self {
-            Self::CssKeyframesAtRule(item) => Some(item),
+            Self::CssBogusSelector(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_layer_at_rule(&self) -> Option<&CssLayerAtRule> {
+    pub fn as_css_compound_selector(&self) -> Option<&CssCompoundSelector> {
         match &self {
-            Self::CssLayerAtRule(item) => Some(item),
+            Self::CssCompoundSelector(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_media_at_rule(&self) -> Option<&CssMediaAtRule> {
+}
+#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
+pub enum AnyCssConditionalBlock {
+    CssBogusBlock(CssBogusBlock),
+    CssDeclarationOrRuleBlock(CssDeclarationOrRuleBlock),
+    CssRuleBlock(CssRuleBlock),
+}
+impl AnyCssConditionalBlock {
+    pub fn as_css_bogus_block(&self) -> Option<&CssBogusBlock> {
         match &self {
-            Self::CssMediaAtRule(item) => Some(item),
+            Self::CssBogusBlock(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_namespace_at_rule(&self) -> Option<&CssNamespaceAtRule> {
+    pub fn as_css_declaration_or_rule_block(&self) -> Option<&CssDeclarationOrRuleBlock> {
         match &self {
-            Self::CssNamespaceAtRule(item) => Some(item),
+            Self::CssDeclarationOrRuleBlock(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_page_at_rule(&self) -> Option<&CssPageAtRule> {
+    pub fn as_css_rule_block(&self) -> Option<&CssRuleBlock> {
         match &self {
-            Self::CssPageAtRule(item) => Some(item),
+            Self::CssRuleBlock(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_position_try_at_rule(&self) -> Option<&CssPositionTryAtRule> {
+}
+#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
+pub enum AnyCssContainerAndCombinableQuery {
+    AnyCssContainerQueryInParens(AnyCssContainerQueryInParens),
+    CssContainerAndQuery(CssContainerAndQuery),
+}
+impl AnyCssContainerAndCombinableQuery {
+    pub fn as_any_css_container_query_in_parens(&self) -> Option<&AnyCssContainerQueryInParens> {
         match &self {
-            Self::CssPositionTryAtRule(item) => Some(item),
+            Self::AnyCssContainerQueryInParens(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_property_at_rule(&self) -> Option<&CssPropertyAtRule> {
+    pub fn as_css_container_and_query(&self) -> Option<&CssContainerAndQuery> {
         match &self {
-            Self::CssPropertyAtRule(item) => Some(item),
+            Self::CssContainerAndQuery(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_scope_at_rule(&self) -> Option<&CssScopeAtRule> {
+}
+#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
+pub enum AnyCssContainerOrCombinableQuery {
+    AnyCssContainerQueryInParens(AnyCssContainerQueryInParens),
+    CssContainerOrQuery(CssContainerOrQuery),
+}
+impl AnyCssContainerOrCombinableQuery {
+    pub fn as_any_css_container_query_in_parens(&self) -> Option<&AnyCssContainerQueryInParens> {
         match &self {
-            Self::CssScopeAtRule(item) => Some(item),
+            Self::AnyCssContainerQueryInParens(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_starting_style_at_rule(&self) -> Option<&CssStartingStyleAtRule> {
+    pub fn as_css_container_or_query(&self) -> Option<&CssContainerOrQuery> {
         match &self {
-            Self::CssStartingStyleAtRule(item) => Some(item),
+            Self::CssContainerOrQuery(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_supports_at_rule(&self) -> Option<&CssSupportsAtRule> {
+}
+#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
+pub enum AnyCssContainerQuery {
+    AnyCssContainerQueryInParens(AnyCssContainerQueryInParens),
+    CssContainerAndQuery(CssContainerAndQuery),
+    CssContainerNotQuery(CssContainerNotQuery),
+    CssContainerOrQuery(CssContainerOrQuery),
+}
+impl AnyCssContainerQuery {
+    pub fn as_any_css_container_query_in_parens(&self) -> Option<&AnyCssContainerQueryInParens> {
         match &self {
-            Self::CssSupportsAtRule(item) => Some(item),
+            Self::AnyCssContainerQueryInParens(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_unknown_block_at_rule(&self) -> Option<&CssUnknownBlockAtRule> {
+    pub fn as_css_container_and_query(&self) -> Option<&CssContainerAndQuery> {
         match &self {
-            Self::CssUnknownBlockAtRule(item) => Some(item),
+            Self::CssContainerAndQuery(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_unknown_value_at_rule(&self) -> Option<&CssUnknownValueAtRule> {
+    pub fn as_css_container_not_query(&self) -> Option<&CssContainerNotQuery> {
         match &self {
-            Self::CssUnknownValueAtRule(item) => Some(item),
+            Self::CssContainerNotQuery(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_value_at_rule(&self) -> Option<&CssValueAtRule> {
+    pub fn as_css_container_or_query(&self) -> Option<&CssContainerOrQuery> {
         match &self {
-            Self::CssValueAtRule(item) => Some(item),
+            Self::CssContainerOrQuery(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_view_transition_at_rule(&self) -> Option<&CssViewTransitionAtRule> {
+}
+#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
+pub enum AnyCssContainerQueryInParens {
+    CssContainerQueryInParens(CssContainerQueryInParens),
+    CssContainerSizeFeatureInParens(CssContainerSizeFeatureInParens),
+    CssContainerStyleQueryInParens(CssContainerStyleQueryInParens),
+}
+impl AnyCssContainerQueryInParens {
+    pub fn as_css_container_query_in_parens(&self) -> Option<&CssContainerQueryInParens> {
         match &self {
-            Self::CssViewTransitionAtRule(item) => Some(item),
+            Self::CssContainerQueryInParens(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_tw_apply_at_rule(&self) -> Option<&TwApplyAtRule> {
+    pub fn as_css_container_size_feature_in_parens(
+        &self,
+    ) -> Option<&CssContainerSizeFeatureInParens> {
         match &self {
-            Self::TwApplyAtRule(item) => Some(item),
+            Self::CssContainerSizeFeatureInParens(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_tw_config_at_rule(&self) -> Option<&TwConfigAtRule> {
+    pub fn as_css_container_style_query_in_parens(
+        &self,
+    ) -> Option<&CssContainerStyleQueryInParens> {
         match &self {
-            Self::TwConfigAtRule(item) => Some(item),
+            Self::CssContainerStyleQueryInParens(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_tw_custom_variant_at_rule(&self) -> Option<&TwCustomVariantAtRule> {
+}
+#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
+pub enum AnyCssContainerStyleAndCombinableQuery {
+    CssContainerStyleAndQuery(CssContainerStyleAndQuery),
+    CssContainerStyleInParens(CssContainerStyleInParens),
+}
+impl AnyCssContainerStyleAndCombinableQuery {
+    pub fn as_css_container_style_and_query(&self) -> Option<&CssContainerStyleAndQuery> {
         match &self {
-            Self::TwCustomVariantAtRule(item) => Some(item),
+            Self::CssContainerStyleAndQuery(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_tw_plugin_at_rule(&self) -> Option<&TwPluginAtRule> {
+    pub fn as_css_container_style_in_parens(&self) -> Option<&CssContainerStyleInParens> {
         match &self {
-            Self::TwPluginAtRule(item) => Some(item),
+            Self::CssContainerStyleInParens(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_tw_reference_at_rule(&self) -> Option<&TwReferenceAtRule> {
+}
+#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
+pub enum AnyCssContainerStyleInParens {
+    AnyCssContainerStyleQuery(AnyCssContainerStyleQuery),
+    CssDeclaration(CssDeclaration),
+}
+impl AnyCssContainerStyleInParens {
+    pub fn as_any_css_container_style_query(&self) -> Option<&AnyCssContainerStyleQuery> {
         match &self {
-            Self::TwReferenceAtRule(item) => Some(item),
+            Self::AnyCssContainerStyleQuery(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_tw_slot_at_rule(&self) -> Option<&TwSlotAtRule> {
+    pub fn as_css_declaration(&self) -> Option<&CssDeclaration> {
         match &self {
-            Self::TwSlotAtRule(item) => Some(item),
+            Self::CssDeclaration(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_tw_source_at_rule(&self) -> Option<&TwSourceAtRule> {
+}
+#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
+pub enum AnyCssContainerStyleOrCombinableQuery {
+    CssContainerStyleInParens(CssContainerStyleInParens),
+    CssContainerStyleOrQuery(CssContainerStyleOrQuery),
+}
+impl AnyCssContainerStyleOrCombinableQuery {
+    pub fn as_css_container_style_in_parens(&self) -> Option<&CssContainerStyleInParens> {
         match &self {
-            Self::TwSourceAtRule(item) => Some(item),
+            Self::CssContainerStyleInParens(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_tw_theme_at_rule(&self) -> Option<&TwThemeAtRule> {
+    pub fn as_css_container_style_or_query(&self) -> Option<&CssContainerStyleOrQuery> {
         match &self {
-            Self::TwThemeAtRule(item) => Some(item),
+            Self::CssContainerStyleOrQuery(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_tw_utility_at_rule(&self) -> Option<&TwUtilityAtRule> {
+}
+#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
+pub enum AnyCssContainerStyleQuery {
+    CssContainerStyleAndQuery(CssContainerStyleAndQuery),
+    CssContainerStyleInParens(CssContainerStyleInParens),
+    CssContainerStyleNotQuery(CssContainerStyleNotQuery),
+    CssContainerStyleOrQuery(CssContainerStyleOrQuery),
+    CssDeclaration(CssDeclaration),
+}
+impl AnyCssContainerStyleQuery {
+    pub fn as_css_container_style_and_query(&self) -> Option<&CssContainerStyleAndQuery> {
         match &self {
-            Self::TwUtilityAtRule(item) => Some(item),
+            Self::CssContainerStyleAndQuery(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_tw_variant_at_rule(&self) -> Option<&TwVariantAtRule> {
+    pub fn as_css_container_style_in_parens(&self) -> Option<&CssContainerStyleInParens> {
         match &self {
-            Self::TwVariantAtRule(item) => Some(item),
+            Self::CssContainerStyleInParens(item) => Some(item),
             _ => None,
         }
     }
-}
-#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssAtRuleDeclarator {
-    CssColorProfileAtRuleDeclarator(CssColorProfileAtRuleDeclarator),
-    CssContainerAtRuleDeclarator(CssContainerAtRuleDeclarator),
-    CssCounterStyleAtRuleDeclarator(CssCounterStyleAtRuleDeclarator),
-    CssFontFaceAtRuleDeclarator(CssFontFaceAtRuleDeclarator),
-    CssFontPaletteValuesAtRuleDeclarator(CssFontPaletteValuesAtRuleDeclarator),
-    CssMediaAtRuleDeclarator(CssMediaAtRuleDeclarator),
-    CssPositionTryAtRuleDeclarator(CssPositionTryAtRuleDeclarator),
-    CssPropertyAtRuleDeclarator(CssPropertyAtRuleDeclarator),
-    CssScopeAtRuleDeclarator(CssScopeAtRuleDeclarator),
-    CssStartingStyleAtRuleDeclarator(CssStartingStyleAtRuleDeclarator),
-    CssSupportsAtRuleDeclarator(CssSupportsAtRuleDeclarator),
-    CssViewTransitionAtRuleDeclarator(CssViewTransitionAtRuleDeclarator),
-}
-impl AnyCssAtRuleDeclarator {
-    pub fn as_css_color_profile_at_rule_declarator(
-        &self,
-    ) -> Option<&CssColorProfileAtRuleDeclarator> {
+    pub fn as_css_container_style_not_query(&self) -> Option<&CssContainerStyleNotQuery> {
         match &self {
-            Self::CssColorProfileAtRuleDeclarator(item) => Some(item),
+            Self::CssContainerStyleNotQuery(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_container_at_rule_declarator(&self) -> Option<&CssContainerAtRuleDeclarator> {
+    pub fn as_css_container_style_or_query(&self) -> Option<&CssContainerStyleOrQuery> {
         match &self {
-            Self::CssContainerAtRuleDeclarator(item) => Some(item),
+            Self::CssContainerStyleOrQuery(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_counter_style_at_rule_declarator(
-        &self,
-    ) -> Option<&CssCounterStyleAtRuleDeclarator> {
+    pub fn as_css_declaration(&self) -> Option<&CssDeclaration> {
         match &self {
-            Self::CssCounterStyleAtRuleDeclarator(item) => Some(item),
+            Self::CssDeclaration(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_font_face_at_rule_declarator(&self) -> Option<&CssFontFaceAtRuleDeclarator> {
+}
+#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
+pub enum AnyCssCustomIdentifier {
+    CssBogusCustomIdentifier(CssBogusCustomIdentifier),
+    CssCustomIdentifier(CssCustomIdentifier),
+}
+impl AnyCssCustomIdentifier {
+    pub fn as_css_bogus_custom_identifier(&self) -> Option<&CssBogusCustomIdentifier> {
         match &self {
-            Self::CssFontFaceAtRuleDeclarator(item) => Some(item),
+            Self::CssBogusCustomIdentifier(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_font_palette_values_at_rule_declarator(
-        &self,
-    ) -> Option<&CssFontPaletteValuesAtRuleDeclarator> {
+    pub fn as_css_custom_identifier(&self) -> Option<&CssCustomIdentifier> {
         match &self {
-            Self::CssFontPaletteValuesAtRuleDeclarator(item) => Some(item),
+            Self::CssCustomIdentifier(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_media_at_rule_declarator(&self) -> Option<&CssMediaAtRuleDeclarator> {
+}
+#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
+pub enum AnyCssDeclaration {
+    CssDeclarationWithSemicolon(CssDeclarationWithSemicolon),
+    CssEmptyDeclaration(CssEmptyDeclaration),
+}
+impl AnyCssDeclaration {
+    pub fn as_css_declaration_with_semicolon(&self) -> Option<&CssDeclarationWithSemicolon> {
         match &self {
-            Self::CssMediaAtRuleDeclarator(item) => Some(item),
+            Self::CssDeclarationWithSemicolon(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_position_try_at_rule_declarator(
-        &self,
-    ) -> Option<&CssPositionTryAtRuleDeclarator> {
+    pub fn as_css_empty_declaration(&self) -> Option<&CssEmptyDeclaration> {
         match &self {
-            Self::CssPositionTryAtRuleDeclarator(item) => Some(item),
+            Self::CssEmptyDeclaration(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_property_at_rule_declarator(&self) -> Option<&CssPropertyAtRuleDeclarator> {
+}
+#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
+pub enum AnyCssDeclarationBlock {
+    CssBogusBlock(CssBogusBlock),
+    CssDeclarationBlock(CssDeclarationBlock),
+}
+impl AnyCssDeclarationBlock {
+    pub fn as_css_bogus_block(&self) -> Option<&CssBogusBlock> {
         match &self {
-            Self::CssPropertyAtRuleDeclarator(item) => Some(item),
+            Self::CssBogusBlock(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_scope_at_rule_declarator(&self) -> Option<&CssScopeAtRuleDeclarator> {
+    pub fn as_css_declaration_block(&self) -> Option<&CssDeclarationBlock> {
         match &self {
-            Self::CssScopeAtRuleDeclarator(item) => Some(item),
+            Self::CssDeclarationBlock(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_starting_style_at_rule_declarator(
-        &self,
-    ) -> Option<&CssStartingStyleAtRuleDeclarator> {
+}
+#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
+pub enum AnyCssDeclarationName {
+    CssDashedIdentifier(CssDashedIdentifier),
+    CssIdentifier(CssIdentifier),
+    TwValueThemeReference(TwValueThemeReference),
+}
+impl AnyCssDeclarationName {
+    pub fn as_css_dashed_identifier(&self) -> Option<&CssDashedIdentifier> {
         match &self {
-            Self::CssStartingStyleAtRuleDeclarator(item) => Some(item),
+            Self::CssDashedIdentifier(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_supports_at_rule_declarator(&self) -> Option<&CssSupportsAtRuleDeclarator> {
+    pub fn as_css_identifier(&self) -> Option<&CssIdentifier> {
         match &self {
-            Self::CssSupportsAtRuleDeclarator(item) => Some(item),
+            Self::CssIdentifier(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_view_transition_at_rule_declarator(
-        &self,
-    ) -> Option<&CssViewTransitionAtRuleDeclarator> {
+    pub fn as_tw_value_theme_reference(&self) -> Option<&TwValueThemeReference> {
         match &self {
-            Self::CssViewTransitionAtRuleDeclarator(item) => Some(item),
+            Self::TwValueThemeReference(item) => Some(item),
             _ => None,
         }
     }
 }
 #[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssAttributeMatcherValue {
-    CssIdentifier(CssIdentifier),
-    CssString(CssString),
+pub enum AnyCssDeclarationOrAtRule {
+    CssAtRule(CssAtRule),
+    CssDeclarationWithSemicolon(CssDeclarationWithSemicolon),
+    CssEmptyDeclaration(CssEmptyDeclaration),
 }
-impl AnyCssAttributeMatcherValue {
-    pub fn as_css_identifier(&self) -> Option<&CssIdentifier> {
+impl AnyCssDeclarationOrAtRule {
+    pub fn as_css_at_rule(&self) -> Option<&CssAtRule> {
         match &self {
-            Self::CssIdentifier(item) => Some(item),
+            Self::CssAtRule(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_string(&self) -> Option<&CssString> {
+    pub fn as_css_declaration_with_semicolon(&self) -> Option<&CssDeclarationWithSemicolon> {
         match &self {
-            Self::CssString(item) => Some(item),
+            Self::CssDeclarationWithSemicolon(item) => Some(item),
+            _ => None,
+        }
+    }
+    pub fn as_css_empty_declaration(&self) -> Option<&CssEmptyDeclaration> {
+        match &self {
+            Self::CssEmptyDeclaration(item) => Some(item),
             _ => None,
         }
     }
 }
 #[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssComposesImportSource {
-    CssIdentifier(CssIdentifier),
-    CssString(CssString),
+pub enum AnyCssDeclarationOrAtRuleBlock {
+    CssBogusBlock(CssBogusBlock),
+    CssDeclarationOrAtRuleBlock(CssDeclarationOrAtRuleBlock),
 }
-impl AnyCssComposesImportSource {
-    pub fn as_css_identifier(&self) -> Option<&CssIdentifier> {
+impl AnyCssDeclarationOrAtRuleBlock {
+    pub fn as_css_bogus_block(&self) -> Option<&CssBogusBlock> {
         match &self {
-            Self::CssIdentifier(item) => Some(item),
+            Self::CssBogusBlock(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_string(&self) -> Option<&CssString> {
+    pub fn as_css_declaration_or_at_rule_block(&self) -> Option<&CssDeclarationOrAtRuleBlock> {
         match &self {
-            Self::CssString(item) => Some(item),
+            Self::CssDeclarationOrAtRuleBlock(item) => Some(item),
             _ => None,
         }
     }
 }
 #[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssCompoundSelector {
-    CssBogusSelector(CssBogusSelector),
-    CssCompoundSelector(CssCompoundSelector),
+pub enum AnyCssDeclarationOrRule {
+    AnyCssRule(AnyCssRule),
+    CssBogus(CssBogus),
+    CssDeclarationWithSemicolon(CssDeclarationWithSemicolon),
+    CssEmptyDeclaration(CssEmptyDeclaration),
+    CssMetavariable(CssMetavariable),
 }
-impl AnyCssCompoundSelector {
-    pub fn as_css_bogus_selector(&self) -> Option<&CssBogusSelector> {
+impl AnyCssDeclarationOrRule {
+    pub fn as_any_css_rule(&self) -> Option<&AnyCssRule> {
         match &self {
-            Self::CssBogusSelector(item) => Some(item),
+            Self::AnyCssRule(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_compound_selector(&self) -> Option<&CssCompoundSelector> {
+    pub fn as_css_bogus(&self) -> Option<&CssBogus> {
         match &self {
-            Self::CssCompoundSelector(item) => Some(item),
+            Self::CssBogus(item) => Some(item),
+            _ => None,
+        }
+    }
+    pub fn as_css_declaration_with_semicolon(&self) -> Option<&CssDeclarationWithSemicolon> {
+        match &self {
+            Self::CssDeclarationWithSemicolon(item) => Some(item),
+            _ => None,
+        }
+    }
+    pub fn as_css_empty_declaration(&self) -> Option<&CssEmptyDeclaration> {
+        match &self {
+            Self::CssEmptyDeclaration(item) => Some(item),
+            _ => None,
+        }
+    }
+    pub fn as_css_metavariable(&self) -> Option<&CssMetavariable> {
+        match &self {
+            Self::CssMetavariable(item) => Some(item),
             _ => None,
         }
     }
 }
 #[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssConditionalBlock {
+pub enum AnyCssDeclarationOrRuleBlock {
     CssBogusBlock(CssBogusBlock),
     CssDeclarationOrRuleBlock(CssDeclarationOrRuleBlock),
-    CssRuleBlock(CssRuleBlock),
 }
-impl AnyCssConditionalBlock {
+impl AnyCssDeclarationOrRuleBlock {
     pub fn as_css_bogus_block(&self) -> Option<&CssBogusBlock> {
         match &self {
             Self::CssBogusBlock(item) => Some(item),
@@ -8907,558 +8798,596 @@ impl AnyCssConditionalBlock {
             _ => None,
         }
     }
-    pub fn as_css_rule_block(&self) -> Option<&CssRuleBlock> {
+}
+#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
+pub enum AnyCssDimension {
+    CssPercentage(CssPercentage),
+    CssRegularDimension(CssRegularDimension),
+    CssUnknownDimension(CssUnknownDimension),
+}
+impl AnyCssDimension {
+    pub fn as_css_percentage(&self) -> Option<&CssPercentage> {
         match &self {
-            Self::CssRuleBlock(item) => Some(item),
+            Self::CssPercentage(item) => Some(item),
             _ => None,
         }
     }
-}
-#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssContainerAndCombinableQuery {
-    AnyCssContainerQueryInParens(AnyCssContainerQueryInParens),
-    CssContainerAndQuery(CssContainerAndQuery),
-}
-impl AnyCssContainerAndCombinableQuery {
-    pub fn as_any_css_container_query_in_parens(&self) -> Option<&AnyCssContainerQueryInParens> {
+    pub fn as_css_regular_dimension(&self) -> Option<&CssRegularDimension> {
         match &self {
-            Self::AnyCssContainerQueryInParens(item) => Some(item),
+            Self::CssRegularDimension(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_container_and_query(&self) -> Option<&CssContainerAndQuery> {
+    pub fn as_css_unknown_dimension(&self) -> Option<&CssUnknownDimension> {
         match &self {
-            Self::CssContainerAndQuery(item) => Some(item),
+            Self::CssUnknownDimension(item) => Some(item),
             _ => None,
         }
     }
 }
 #[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssContainerOrCombinableQuery {
-    AnyCssContainerQueryInParens(AnyCssContainerQueryInParens),
-    CssContainerOrQuery(CssContainerOrQuery),
+pub enum AnyCssDocumentMatcher {
+    CssBogusDocumentMatcher(CssBogusDocumentMatcher),
+    CssDocumentCustomMatcher(CssDocumentCustomMatcher),
+    CssUrlFunction(CssUrlFunction),
 }
-impl AnyCssContainerOrCombinableQuery {
-    pub fn as_any_css_container_query_in_parens(&self) -> Option<&AnyCssContainerQueryInParens> {
+impl AnyCssDocumentMatcher {
+    pub fn as_css_bogus_document_matcher(&self) -> Option<&CssBogusDocumentMatcher> {
         match &self {
-            Self::AnyCssContainerQueryInParens(item) => Some(item),
+            Self::CssBogusDocumentMatcher(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_container_or_query(&self) -> Option<&CssContainerOrQuery> {
+    pub fn as_css_document_custom_matcher(&self) -> Option<&CssDocumentCustomMatcher> {
         match &self {
-            Self::CssContainerOrQuery(item) => Some(item),
+            Self::CssDocumentCustomMatcher(item) => Some(item),
             _ => None,
         }
     }
-}
-#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssContainerQuery {
-    AnyCssContainerQueryInParens(AnyCssContainerQueryInParens),
-    CssContainerAndQuery(CssContainerAndQuery),
-    CssContainerNotQuery(CssContainerNotQuery),
-    CssContainerOrQuery(CssContainerOrQuery),
-}
-impl AnyCssContainerQuery {
-    pub fn as_any_css_container_query_in_parens(&self) -> Option<&AnyCssContainerQueryInParens> {
+    pub fn as_css_url_function(&self) -> Option<&CssUrlFunction> {
         match &self {
-            Self::AnyCssContainerQueryInParens(item) => Some(item),
+            Self::CssUrlFunction(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_container_and_query(&self) -> Option<&CssContainerAndQuery> {
+}
+#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
+pub enum AnyCssExpression {
+    CssBinaryExpression(CssBinaryExpression),
+    CssListOfComponentValuesExpression(CssListOfComponentValuesExpression),
+    CssParenthesizedExpression(CssParenthesizedExpression),
+}
+impl AnyCssExpression {
+    pub fn as_css_binary_expression(&self) -> Option<&CssBinaryExpression> {
         match &self {
-            Self::CssContainerAndQuery(item) => Some(item),
+            Self::CssBinaryExpression(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_container_not_query(&self) -> Option<&CssContainerNotQuery> {
+    pub fn as_css_list_of_component_values_expression(
+        &self,
+    ) -> Option<&CssListOfComponentValuesExpression> {
         match &self {
-            Self::CssContainerNotQuery(item) => Some(item),
+            Self::CssListOfComponentValuesExpression(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_container_or_query(&self) -> Option<&CssContainerOrQuery> {
+    pub fn as_css_parenthesized_expression(&self) -> Option<&CssParenthesizedExpression> {
         match &self {
-            Self::CssContainerOrQuery(item) => Some(item),
+            Self::CssParenthesizedExpression(item) => Some(item),
             _ => None,
         }
     }
 }
 #[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssContainerQueryInParens {
-    CssContainerQueryInParens(CssContainerQueryInParens),
-    CssContainerSizeFeatureInParens(CssContainerSizeFeatureInParens),
-    CssContainerStyleQueryInParens(CssContainerStyleQueryInParens),
+pub enum AnyCssFontFamilyName {
+    CssBogusFontFamilyName(CssBogusFontFamilyName),
+    CssFontFamilyName(CssFontFamilyName),
+    CssString(CssString),
 }
-impl AnyCssContainerQueryInParens {
-    pub fn as_css_container_query_in_parens(&self) -> Option<&CssContainerQueryInParens> {
+impl AnyCssFontFamilyName {
+    pub fn as_css_bogus_font_family_name(&self) -> Option<&CssBogusFontFamilyName> {
         match &self {
-            Self::CssContainerQueryInParens(item) => Some(item),
+            Self::CssBogusFontFamilyName(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_container_size_feature_in_parens(
-        &self,
-    ) -> Option<&CssContainerSizeFeatureInParens> {
+    pub fn as_css_font_family_name(&self) -> Option<&CssFontFamilyName> {
         match &self {
-            Self::CssContainerSizeFeatureInParens(item) => Some(item),
+            Self::CssFontFamilyName(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_container_style_query_in_parens(
-        &self,
-    ) -> Option<&CssContainerStyleQueryInParens> {
+    pub fn as_css_string(&self) -> Option<&CssString> {
         match &self {
-            Self::CssContainerStyleQueryInParens(item) => Some(item),
+            Self::CssString(item) => Some(item),
             _ => None,
         }
     }
 }
 #[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssContainerStyleAndCombinableQuery {
-    CssContainerStyleAndQuery(CssContainerStyleAndQuery),
-    CssContainerStyleInParens(CssContainerStyleInParens),
+pub enum AnyCssFontFeatureValuesBlock {
+    CssBogusBlock(CssBogusBlock),
+    CssFontFeatureValuesBlock(CssFontFeatureValuesBlock),
 }
-impl AnyCssContainerStyleAndCombinableQuery {
-    pub fn as_css_container_style_and_query(&self) -> Option<&CssContainerStyleAndQuery> {
+impl AnyCssFontFeatureValuesBlock {
+    pub fn as_css_bogus_block(&self) -> Option<&CssBogusBlock> {
         match &self {
-            Self::CssContainerStyleAndQuery(item) => Some(item),
+            Self::CssBogusBlock(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_container_style_in_parens(&self) -> Option<&CssContainerStyleInParens> {
+    pub fn as_css_font_feature_values_block(&self) -> Option<&CssFontFeatureValuesBlock> {
         match &self {
-            Self::CssContainerStyleInParens(item) => Some(item),
+            Self::CssFontFeatureValuesBlock(item) => Some(item),
             _ => None,
         }
     }
 }
 #[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssContainerStyleInParens {
-    AnyCssContainerStyleQuery(AnyCssContainerStyleQuery),
-    CssDeclaration(CssDeclaration),
+pub enum AnyCssFontFeatureValuesItem {
+    CssBogusFontFeatureValuesItem(CssBogusFontFeatureValuesItem),
+    CssFontFeatureValuesItem(CssFontFeatureValuesItem),
 }
-impl AnyCssContainerStyleInParens {
-    pub fn as_any_css_container_style_query(&self) -> Option<&AnyCssContainerStyleQuery> {
+impl AnyCssFontFeatureValuesItem {
+    pub fn as_css_bogus_font_feature_values_item(&self) -> Option<&CssBogusFontFeatureValuesItem> {
         match &self {
-            Self::AnyCssContainerStyleQuery(item) => Some(item),
+            Self::CssBogusFontFeatureValuesItem(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_declaration(&self) -> Option<&CssDeclaration> {
+    pub fn as_css_font_feature_values_item(&self) -> Option<&CssFontFeatureValuesItem> {
         match &self {
-            Self::CssDeclaration(item) => Some(item),
+            Self::CssFontFeatureValuesItem(item) => Some(item),
             _ => None,
         }
     }
 }
 #[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssContainerStyleOrCombinableQuery {
-    CssContainerStyleInParens(CssContainerStyleInParens),
-    CssContainerStyleOrQuery(CssContainerStyleOrQuery),
+pub enum AnyCssFunction {
+    CssFunction(CssFunction),
+    CssUrlFunction(CssUrlFunction),
 }
-impl AnyCssContainerStyleOrCombinableQuery {
-    pub fn as_css_container_style_in_parens(&self) -> Option<&CssContainerStyleInParens> {
+impl AnyCssFunction {
+    pub fn as_css_function(&self) -> Option<&CssFunction> {
         match &self {
-            Self::CssContainerStyleInParens(item) => Some(item),
+            Self::CssFunction(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_container_style_or_query(&self) -> Option<&CssContainerStyleOrQuery> {
+    pub fn as_css_url_function(&self) -> Option<&CssUrlFunction> {
         match &self {
-            Self::CssContainerStyleOrQuery(item) => Some(item),
+            Self::CssUrlFunction(item) => Some(item),
             _ => None,
         }
     }
 }
 #[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssContainerStyleQuery {
-    CssContainerStyleAndQuery(CssContainerStyleAndQuery),
-    CssContainerStyleInParens(CssContainerStyleInParens),
-    CssContainerStyleNotQuery(CssContainerStyleNotQuery),
-    CssContainerStyleOrQuery(CssContainerStyleOrQuery),
-    CssDeclaration(CssDeclaration),
+pub enum AnyCssGenericComponentValue {
+    AnyCssValue(AnyCssValue),
+    CssGenericDelimiter(CssGenericDelimiter),
 }
-impl AnyCssContainerStyleQuery {
-    pub fn as_css_container_style_and_query(&self) -> Option<&CssContainerStyleAndQuery> {
+impl AnyCssGenericComponentValue {
+    pub fn as_any_css_value(&self) -> Option<&AnyCssValue> {
         match &self {
-            Self::CssContainerStyleAndQuery(item) => Some(item),
+            Self::AnyCssValue(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_container_style_in_parens(&self) -> Option<&CssContainerStyleInParens> {
+    pub fn as_css_generic_delimiter(&self) -> Option<&CssGenericDelimiter> {
         match &self {
-            Self::CssContainerStyleInParens(item) => Some(item),
+            Self::CssGenericDelimiter(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_container_style_not_query(&self) -> Option<&CssContainerStyleNotQuery> {
-        match &self {
-            Self::CssContainerStyleNotQuery(item) => Some(item),
-            _ => None,
-        }
-    }
-    pub fn as_css_container_style_or_query(&self) -> Option<&CssContainerStyleOrQuery> {
+}
+#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
+pub enum AnyCssImportLayer {
+    CssImportAnonymousLayer(CssImportAnonymousLayer),
+    CssImportNamedLayer(CssImportNamedLayer),
+}
+impl AnyCssImportLayer {
+    pub fn as_css_import_anonymous_layer(&self) -> Option<&CssImportAnonymousLayer> {
         match &self {
-            Self::CssContainerStyleOrQuery(item) => Some(item),
+            Self::CssImportAnonymousLayer(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_declaration(&self) -> Option<&CssDeclaration> {
+    pub fn as_css_import_named_layer(&self) -> Option<&CssImportNamedLayer> {
         match &self {
-            Self::CssDeclaration(item) => Some(item),
+            Self::CssImportNamedLayer(item) => Some(item),
             _ => None,
         }
     }
 }
 #[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssCustomIdentifier {
-    CssBogusCustomIdentifier(CssBogusCustomIdentifier),
-    CssCustomIdentifier(CssCustomIdentifier),
+pub enum AnyCssImportSupportsCondition {
+    AnyCssSupportsCondition(AnyCssSupportsCondition),
+    CssDeclaration(CssDeclaration),
 }
-impl AnyCssCustomIdentifier {
-    pub fn as_css_bogus_custom_identifier(&self) -> Option<&CssBogusCustomIdentifier> {
+impl AnyCssImportSupportsCondition {
+    pub fn as_any_css_supports_condition(&self) -> Option<&AnyCssSupportsCondition> {
         match &self {
-            Self::CssBogusCustomIdentifier(item) => Some(item),
+            Self::AnyCssSupportsCondition(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_custom_identifier(&self) -> Option<&CssCustomIdentifier> {
+    pub fn as_css_declaration(&self) -> Option<&CssDeclaration> {
         match &self {
-            Self::CssCustomIdentifier(item) => Some(item),
+            Self::CssDeclaration(item) => Some(item),
             _ => None,
         }
     }
 }
 #[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssDeclaration {
-    CssDeclarationWithSemicolon(CssDeclarationWithSemicolon),
-    CssEmptyDeclaration(CssEmptyDeclaration),
+pub enum AnyCssImportUrl {
+    CssString(CssString),
+    CssUrlFunction(CssUrlFunction),
 }
-impl AnyCssDeclaration {
-    pub fn as_css_declaration_with_semicolon(&self) -> Option<&CssDeclarationWithSemicolon> {
+impl AnyCssImportUrl {
+    pub fn as_css_string(&self) -> Option<&CssString> {
         match &self {
-            Self::CssDeclarationWithSemicolon(item) => Some(item),
+            Self::CssString(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_empty_declaration(&self) -> Option<&CssEmptyDeclaration> {
+    pub fn as_css_url_function(&self) -> Option<&CssUrlFunction> {
         match &self {
-            Self::CssEmptyDeclaration(item) => Some(item),
+            Self::CssUrlFunction(item) => Some(item),
             _ => None,
         }
     }
 }
 #[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssDeclarationBlock {
+pub enum AnyCssKeyframesBlock {
     CssBogusBlock(CssBogusBlock),
-    CssDeclarationBlock(CssDeclarationBlock),
+    CssKeyframesBlock(CssKeyframesBlock),
 }
-impl AnyCssDeclarationBlock {
+impl AnyCssKeyframesBlock {
     pub fn as_css_bogus_block(&self) -> Option<&CssBogusBlock> {
         match &self {
             Self::CssBogusBlock(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_declaration_block(&self) -> Option<&CssDeclarationBlock> {
+    pub fn as_css_keyframes_block(&self) -> Option<&CssKeyframesBlock> {
         match &self {
-            Self::CssDeclarationBlock(item) => Some(item),
+            Self::CssKeyframesBlock(item) => Some(item),
             _ => None,
         }
     }
 }
 #[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssDeclarationName {
-    CssDashedIdentifier(CssDashedIdentifier),
-    CssIdentifier(CssIdentifier),
-    TwValueThemeReference(TwValueThemeReference),
+pub enum AnyCssKeyframesIdentifier {
+    CssCustomIdentifier(CssCustomIdentifier),
+    CssString(CssString),
 }
-impl AnyCssDeclarationName {
-    pub fn as_css_dashed_identifier(&self) -> Option<&CssDashedIdentifier> {
+impl AnyCssKeyframesIdentifier {
+    pub fn as_css_custom_identifier(&self) -> Option<&CssCustomIdentifier> {
         match &self {
-            Self::CssDashedIdentifier(item) => Some(item),
+            Self::CssCustomIdentifier(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_identifier(&self) -> Option<&CssIdentifier> {
+    pub fn as_css_string(&self) -> Option<&CssString> {
         match &self {
-            Self::CssIdentifier(item) => Some(item),
+            Self::CssString(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_tw_value_theme_reference(&self) -> Option<&TwValueThemeReference> {
+}
+#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
+pub enum AnyCssKeyframesItem {
+    CssBogusKeyframesItem(CssBogusKeyframesItem),
+    CssKeyframesItem(CssKeyframesItem),
+}
+impl AnyCssKeyframesItem {
+    pub fn as_css_bogus_keyframes_item(&self) -> Option<&CssBogusKeyframesItem> {
         match &self {
-            Self::TwValueThemeReference(item) => Some(item),
+            Self::CssBogusKeyframesItem(item) => Some(item),
+            _ => None,
+        }
+    }
+    pub fn as_css_keyframes_item(&self) -> Option<&CssKeyframesItem> {
+        match &self {
+            Self::CssKeyframesItem(item) => Some(item),
             _ => None,
         }
     }
 }
 #[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssDeclarationOrAtRule {
-    CssAtRule(CssAtRule),
-    CssDeclarationWithSemicolon(CssDeclarationWithSemicolon),
-    CssEmptyDeclaration(CssEmptyDeclaration),
+pub enum AnyCssKeyframesName {
+    AnyCssKeyframesIdentifier(AnyCssKeyframesIdentifier),
+    CssBogusKeyframesName(CssBogusKeyframesName),
+    CssKeyframesScopedName(CssKeyframesScopedName),
 }
-impl AnyCssDeclarationOrAtRule {
-    pub fn as_css_at_rule(&self) -> Option<&CssAtRule> {
+impl AnyCssKeyframesName {
+    pub fn as_any_css_keyframes_identifier(&self) -> Option<&AnyCssKeyframesIdentifier> {
         match &self {
-            Self::CssAtRule(item) => Some(item),
+            Self::AnyCssKeyframesIdentifier(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_declaration_with_semicolon(&self) -> Option<&CssDeclarationWithSemicolon> {
+    pub fn as_css_bogus_keyframes_name(&self) -> Option<&CssBogusKeyframesName> {
         match &self {
-            Self::CssDeclarationWithSemicolon(item) => Some(item),
+            Self::CssBogusKeyframesName(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_empty_declaration(&self) -> Option<&CssEmptyDeclaration> {
+    pub fn as_css_keyframes_scoped_name(&self) -> Option<&CssKeyframesScopedName> {
         match &self {
-            Self::CssEmptyDeclaration(item) => Some(item),
+            Self::CssKeyframesScopedName(item) => Some(item),
             _ => None,
         }
     }
 }
 #[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssDeclarationOrAtRuleBlock {
-    CssBogusBlock(CssBogusBlock),
-    CssDeclarationOrAtRuleBlock(CssDeclarationOrAtRuleBlock),
+pub enum AnyCssKeyframesScope {
+    CssKeyframesScopeFunction(CssKeyframesScopeFunction),
+    CssKeyframesScopePrefix(CssKeyframesScopePrefix),
 }
-impl AnyCssDeclarationOrAtRuleBlock {
-    pub fn as_css_bogus_block(&self) -> Option<&CssBogusBlock> {
+impl AnyCssKeyframesScope {
+    pub fn as_css_keyframes_scope_function(&self) -> Option<&CssKeyframesScopeFunction> {
         match &self {
-            Self::CssBogusBlock(item) => Some(item),
+            Self::CssKeyframesScopeFunction(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_declaration_or_at_rule_block(&self) -> Option<&CssDeclarationOrAtRuleBlock> {
+    pub fn as_css_keyframes_scope_prefix(&self) -> Option<&CssKeyframesScopePrefix> {
         match &self {
-            Self::CssDeclarationOrAtRuleBlock(item) => Some(item),
+            Self::CssKeyframesScopePrefix(item) => Some(item),
             _ => None,
         }
     }
 }
 #[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssDeclarationOrRule {
-    AnyCssRule(AnyCssRule),
-    CssBogus(CssBogus),
-    CssDeclarationWithSemicolon(CssDeclarationWithSemicolon),
-    CssEmptyDeclaration(CssEmptyDeclaration),
-    CssMetavariable(CssMetavariable),
+pub enum AnyCssKeyframesSelector {
+    CssBogusSelector(CssBogusSelector),
+    CssKeyframesIdentSelector(CssKeyframesIdentSelector),
+    CssKeyframesPercentageSelector(CssKeyframesPercentageSelector),
 }
-impl AnyCssDeclarationOrRule {
-    pub fn as_any_css_rule(&self) -> Option<&AnyCssRule> {
+impl AnyCssKeyframesSelector {
+    pub fn as_css_bogus_selector(&self) -> Option<&CssBogusSelector> {
         match &self {
-            Self::AnyCssRule(item) => Some(item),
+            Self::CssBogusSelector(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_bogus(&self) -> Option<&CssBogus> {
+    pub fn as_css_keyframes_ident_selector(&self) -> Option<&CssKeyframesIdentSelector> {
         match &self {
-            Self::CssBogus(item) => Some(item),
+            Self::CssKeyframesIdentSelector(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_declaration_with_semicolon(&self) -> Option<&CssDeclarationWithSemicolon> {
+    pub fn as_css_keyframes_percentage_selector(&self) -> Option<&CssKeyframesPercentageSelector> {
         match &self {
-            Self::CssDeclarationWithSemicolon(item) => Some(item),
+            Self::CssKeyframesPercentageSelector(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_empty_declaration(&self) -> Option<&CssEmptyDeclaration> {
+}
+#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
+pub enum AnyCssLayer {
+    CssBogusLayer(CssBogusLayer),
+    CssLayerDeclaration(CssLayerDeclaration),
+    CssLayerReference(CssLayerReference),
+}
+impl AnyCssLayer {
+    pub fn as_css_bogus_layer(&self) -> Option<&CssBogusLayer> {
         match &self {
-            Self::CssEmptyDeclaration(item) => Some(item),
+            Self::CssBogusLayer(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_metavariable(&self) -> Option<&CssMetavariable> {
+    pub fn as_css_layer_declaration(&self) -> Option<&CssLayerDeclaration> {
         match &self {
-            Self::CssMetavariable(item) => Some(item),
+            Self::CssLayerDeclaration(item) => Some(item),
+            _ => None,
+        }
+    }
+    pub fn as_css_layer_reference(&self) -> Option<&CssLayerReference> {
+        match &self {
+            Self::CssLayerReference(item) => Some(item),
             _ => None,
         }
     }
 }
 #[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssDeclarationOrRuleBlock {
-    CssBogusBlock(CssBogusBlock),
-    CssDeclarationOrRuleBlock(CssDeclarationOrRuleBlock),
+pub enum AnyCssMediaAndCombinableCondition {
+    AnyCssMediaInParens(AnyCssMediaInParens),
+    CssMediaAndCondition(CssMediaAndCondition),
 }
-impl AnyCssDeclarationOrRuleBlock {
-    pub fn as_css_bogus_block(&self) -> Option<&CssBogusBlock> {
+impl AnyCssMediaAndCombinableCondition {
+    pub fn as_any_css_media_in_parens(&self) -> Option<&AnyCssMediaInParens> {
         match &self {
-            Self::CssBogusBlock(item) => Some(item),
+            Self::AnyCssMediaInParens(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_declaration_or_rule_block(&self) -> Option<&CssDeclarationOrRuleBlock> {
+    pub fn as_css_media_and_condition(&self) -> Option<&CssMediaAndCondition> {
         match &self {
-            Self::CssDeclarationOrRuleBlock(item) => Some(item),
+            Self::CssMediaAndCondition(item) => Some(item),
             _ => None,
         }
     }
 }
 #[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssDimension {
-    CssPercentage(CssPercentage),
-    CssRegularDimension(CssRegularDimension),
-    CssUnknownDimension(CssUnknownDimension),
+pub enum AnyCssMediaCondition {
+    AnyCssMediaInParens(AnyCssMediaInParens),
+    CssMediaAndCondition(CssMediaAndCondition),
+    CssMediaNotCondition(CssMediaNotCondition),
+    CssMediaOrCondition(CssMediaOrCondition),
 }
-impl AnyCssDimension {
-    pub fn as_css_percentage(&self) -> Option<&CssPercentage> {
+impl AnyCssMediaCondition {
+    pub fn as_any_css_media_in_parens(&self) -> Option<&AnyCssMediaInParens> {
         match &self {
-            Self::CssPercentage(item) => Some(item),
+            Self::AnyCssMediaInParens(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_regular_dimension(&self) -> Option<&CssRegularDimension> {
+    pub fn as_css_media_and_condition(&self) -> Option<&CssMediaAndCondition> {
         match &self {
-            Self::CssRegularDimension(item) => Some(item),
+            Self::CssMediaAndCondition(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_unknown_dimension(&self) -> Option<&CssUnknownDimension> {
+    pub fn as_css_media_not_condition(&self) -> Option<&CssMediaNotCondition> {
         match &self {
-            Self::CssUnknownDimension(item) => Some(item),
+            Self::CssMediaNotCondition(item) => Some(item),
             _ => None,
         }
     }
-}
-#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssDocumentMatcher {
-    CssBogusDocumentMatcher(CssBogusDocumentMatcher),
-    CssDocumentCustomMatcher(CssDocumentCustomMatcher),
-    CssUrlFunction(CssUrlFunction),
-}
-impl AnyCssDocumentMatcher {
-    pub fn as_css_bogus_document_matcher(&self) -> Option<&CssBogusDocumentMatcher> {
+    pub fn as_css_media_or_condition(&self) -> Option<&CssMediaOrCondition> {
         match &self {
-            Self::CssBogusDocumentMatcher(item) => Some(item),
+            Self::CssMediaOrCondition(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_document_custom_matcher(&self) -> Option<&CssDocumentCustomMatcher> {
+}
+#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
+pub enum AnyCssMediaInParens {
+    CssMediaConditionInParens(CssMediaConditionInParens),
+    CssMediaFeatureInParens(CssMediaFeatureInParens),
+}
+impl AnyCssMediaInParens {
+    pub fn as_css_media_condition_in_parens(&self) -> Option<&CssMediaConditionInParens> {
         match &self {
-            Self::CssDocumentCustomMatcher(item) => Some(item),
+            Self::CssMediaConditionInParens(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_url_function(&self) -> Option<&CssUrlFunction> {
+    pub fn as_css_media_feature_in_parens(&self) -> Option<&CssMediaFeatureInParens> {
         match &self {
-            Self::CssUrlFunction(item) => Some(item),
+            Self::CssMediaFeatureInParens(item) => Some(item),
             _ => None,
         }
     }
 }
 #[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssExpression {
-    CssBinaryExpression(CssBinaryExpression),
-    CssListOfComponentValuesExpression(CssListOfComponentValuesExpression),
-    CssParenthesizedExpression(CssParenthesizedExpression),
+pub enum AnyCssMediaOrCombinableCondition {
+    AnyCssMediaInParens(AnyCssMediaInParens),
+    CssMediaOrCondition(CssMediaOrCondition),
 }
-impl AnyCssExpression {
-    pub fn as_css_binary_expression(&self) -> Option<&CssBinaryExpression> {
+impl AnyCssMediaOrCombinableCondition {
+    pub fn as_any_css_media_in_parens(&self) -> Option<&AnyCssMediaInParens> {
         match &self {
-            Self::CssBinaryExpression(item) => Some(item),
+            Self::AnyCssMediaInParens(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_list_of_component_values_expression(
-        &self,
-    ) -> Option<&CssListOfComponentValuesExpression> {
+    pub fn as_css_media_or_condition(&self) -> Option<&CssMediaOrCondition> {
         match &self {
-            Self::CssListOfComponentValuesExpression(item) => Some(item),
+            Self::CssMediaOrCondition(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_parenthesized_expression(&self) -> Option<&CssParenthesizedExpression> {
+}
+#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
+pub enum AnyCssMediaQuery {
+    AnyCssMediaTypeQuery(AnyCssMediaTypeQuery),
+    CssBogusMediaQuery(CssBogusMediaQuery),
+    CssMediaConditionQuery(CssMediaConditionQuery),
+    CssMetavariable(CssMetavariable),
+}
+impl AnyCssMediaQuery {
+    pub fn as_any_css_media_type_query(&self) -> Option<&AnyCssMediaTypeQuery> {
         match &self {
-            Self::CssParenthesizedExpression(item) => Some(item),
+            Self::AnyCssMediaTypeQuery(item) => Some(item),
             _ => None,
         }
     }
-}
-#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssFontFamilyName {
-    CssBogusFontFamilyName(CssBogusFontFamilyName),
-    CssFontFamilyName(CssFontFamilyName),
-    CssString(CssString),
-}
-impl AnyCssFontFamilyName {
-    pub fn as_css_bogus_font_family_name(&self) -> Option<&CssBogusFontFamilyName> {
+    pub fn as_css_bogus_media_query(&self) -> Option<&CssBogusMediaQuery> {
         match &self {
-            Self::CssBogusFontFamilyName(item) => Some(item),
+            Self::CssBogusMediaQuery(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_font_family_name(&self) -> Option<&CssFontFamilyName> {
+    pub fn as_css_media_condition_query(&self) -> Option<&CssMediaConditionQuery> {
         match &self {
-            Self::CssFontFamilyName(item) => Some(item),
+            Self::CssMediaConditionQuery(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_string(&self) -> Option<&CssString> {
+    pub fn as_css_metavariable(&self) -> Option<&CssMetavariable> {
         match &self {
-            Self::CssString(item) => Some(item),
+            Self::CssMetavariable(item) => Some(item),
             _ => None,
         }
     }
 }
 #[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssFontFeatureValuesBlock {
-    CssBogusBlock(CssBogusBlock),
-    CssFontFeatureValuesBlock(CssFontFeatureValuesBlock),
+pub enum AnyCssMediaTypeCondition {
+    AnyCssMediaInParens(AnyCssMediaInParens),
+    CssMediaAndCondition(CssMediaAndCondition),
+    CssMediaNotCondition(CssMediaNotCondition),
 }
-impl AnyCssFontFeatureValuesBlock {
-    pub fn as_css_bogus_block(&self) -> Option<&CssBogusBlock> {
+impl AnyCssMediaTypeCondition {
+    pub fn as_any_css_media_in_parens(&self) -> Option<&AnyCssMediaInParens> {
         match &self {
-            Self::CssBogusBlock(item) => Some(item),
+            Self::AnyCssMediaInParens(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_font_feature_values_block(&self) -> Option<&CssFontFeatureValuesBlock> {
+    pub fn as_css_media_and_condition(&self) -> Option<&CssMediaAndCondition> {
         match &self {
-            Self::CssFontFeatureValuesBlock(item) => Some(item),
+            Self::CssMediaAndCondition(item) => Some(item),
+            _ => None,
+        }
+    }
+    pub fn as_css_media_not_condition(&self) -> Option<&CssMediaNotCondition> {
+        match &self {
+            Self::CssMediaNotCondition(item) => Some(item),
             _ => None,
         }
     }
 }
 #[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssFontFeatureValuesItem {
-    CssBogusFontFeatureValuesItem(CssBogusFontFeatureValuesItem),
-    CssFontFeatureValuesItem(CssFontFeatureValuesItem),
+pub enum AnyCssMediaTypeQuery {
+    CssMediaAndTypeQuery(CssMediaAndTypeQuery),
+    CssMediaTypeQuery(CssMediaTypeQuery),
 }
-impl AnyCssFontFeatureValuesItem {
-    pub fn as_css_bogus_font_feature_values_item(&self) -> Option<&CssBogusFontFeatureValuesItem> {
+impl AnyCssMediaTypeQuery {
+    pub fn as_css_media_and_type_query(&self) -> Option<&CssMediaAndTypeQuery> {
         match &self {
-            Self::CssBogusFontFeatureValuesItem(item) => Some(item),
+            Self::CssMediaAndTypeQuery(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_font_feature_values_item(&self) -> Option<&CssFontFeatureValuesItem> {
+    pub fn as_css_media_type_query(&self) -> Option<&CssMediaTypeQuery> {
         match &self {
-            Self::CssFontFeatureValuesItem(item) => Some(item),
+            Self::CssMediaTypeQuery(item) => Some(item),
             _ => None,
         }
     }
 }
 #[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssFunction {
-    CssFunction(CssFunction),
-    CssIfFunction(CssIfFunction),
-    CssUrlFunction(CssUrlFunction),
+pub enum AnyCssNamespacePrefix {
+    CssNamedNamespacePrefix(CssNamedNamespacePrefix),
+    CssUniversalNamespacePrefix(CssUniversalNamespacePrefix),
 }
-impl AnyCssFunction {
-    pub fn as_css_function(&self) -> Option<&CssFunction> {
+impl AnyCssNamespacePrefix {
+    pub fn as_css_named_namespace_prefix(&self) -> Option<&CssNamedNamespacePrefix> {
         match &self {
-            Self::CssFunction(item) => Some(item),
+            Self::CssNamedNamespacePrefix(item) => Some(item),
+            _ => None,
+        }
+    }
+    pub fn as_css_universal_namespace_prefix(&self) -> Option<&CssUniversalNamespacePrefix> {
+        match &self {
+            Self::CssUniversalNamespacePrefix(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_if_function(&self) -> Option<&CssIfFunction> {
+}
+#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
+pub enum AnyCssNamespaceUrl {
+    CssString(CssString),
+    CssUrlFunction(CssUrlFunction),
+}
+impl AnyCssNamespaceUrl {
+    pub fn as_css_string(&self) -> Option<&CssString> {
         match &self {
-            Self::CssIfFunction(item) => Some(item),
+            Self::CssString(item) => Some(item),
             _ => None,
         }
     }
@@ -9470,544 +9399,541 @@ impl AnyCssFunction {
     }
 }
 #[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssGenericComponentValue {
-    AnyCssValue(AnyCssValue),
-    CssGenericDelimiter(CssGenericDelimiter),
+pub enum AnyCssPageAtRuleBlock {
+    CssBogusBlock(CssBogusBlock),
+    CssPageAtRuleBlock(CssPageAtRuleBlock),
 }
-impl AnyCssGenericComponentValue {
-    pub fn as_any_css_value(&self) -> Option<&AnyCssValue> {
+impl AnyCssPageAtRuleBlock {
+    pub fn as_css_bogus_block(&self) -> Option<&CssBogusBlock> {
         match &self {
-            Self::AnyCssValue(item) => Some(item),
+            Self::CssBogusBlock(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_generic_delimiter(&self) -> Option<&CssGenericDelimiter> {
+    pub fn as_css_page_at_rule_block(&self) -> Option<&CssPageAtRuleBlock> {
         match &self {
-            Self::CssGenericDelimiter(item) => Some(item),
+            Self::CssPageAtRuleBlock(item) => Some(item),
             _ => None,
         }
     }
 }
 #[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssIfBranch {
-    CssBogusIfBranch(CssBogusIfBranch),
-    CssIfBranch(CssIfBranch),
+pub enum AnyCssPageAtRuleItem {
+    CssAtRule(CssAtRule),
+    CssDeclarationWithSemicolon(CssDeclarationWithSemicolon),
+    CssEmptyDeclaration(CssEmptyDeclaration),
+    CssMarginAtRule(CssMarginAtRule),
 }
-impl AnyCssIfBranch {
-    pub fn as_css_bogus_if_branch(&self) -> Option<&CssBogusIfBranch> {
+impl AnyCssPageAtRuleItem {
+    pub fn as_css_at_rule(&self) -> Option<&CssAtRule> {
         match &self {
-            Self::CssBogusIfBranch(item) => Some(item),
+            Self::CssAtRule(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_if_branch(&self) -> Option<&CssIfBranch> {
+    pub fn as_css_declaration_with_semicolon(&self) -> Option<&CssDeclarationWithSemicolon> {
         match &self {
-            Self::CssIfBranch(item) => Some(item),
+            Self::CssDeclarationWithSemicolon(item) => Some(item),
             _ => None,
         }
     }
-}
-#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssIfCondition {
-    AnyCssIfTestBooleanExpr(AnyCssIfTestBooleanExpr),
-    CssElseKeyword(CssElseKeyword),
-}
-impl AnyCssIfCondition {
-    pub fn as_any_css_if_test_boolean_expr(&self) -> Option<&AnyCssIfTestBooleanExpr> {
+    pub fn as_css_empty_declaration(&self) -> Option<&CssEmptyDeclaration> {
         match &self {
-            Self::AnyCssIfTestBooleanExpr(item) => Some(item),
+            Self::CssEmptyDeclaration(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_else_keyword(&self) -> Option<&CssElseKeyword> {
+    pub fn as_css_margin_at_rule(&self) -> Option<&CssMarginAtRule> {
         match &self {
-            Self::CssElseKeyword(item) => Some(item),
+            Self::CssMarginAtRule(item) => Some(item),
             _ => None,
         }
     }
 }
 #[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssIfMediaTestQuery {
-    AnyCssMediaCondition(AnyCssMediaCondition),
-    AnyCssQueryFeature(AnyCssQueryFeature),
+pub enum AnyCssPageSelector {
+    CssBogusSelector(CssBogusSelector),
+    CssPageSelector(CssPageSelector),
 }
-impl AnyCssIfMediaTestQuery {
-    pub fn as_any_css_media_condition(&self) -> Option<&AnyCssMediaCondition> {
+impl AnyCssPageSelector {
+    pub fn as_css_bogus_selector(&self) -> Option<&CssBogusSelector> {
         match &self {
-            Self::AnyCssMediaCondition(item) => Some(item),
+            Self::CssBogusSelector(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_any_css_query_feature(&self) -> Option<&AnyCssQueryFeature> {
+    pub fn as_css_page_selector(&self) -> Option<&CssPageSelector> {
         match &self {
-            Self::AnyCssQueryFeature(item) => Some(item),
+            Self::CssPageSelector(item) => Some(item),
             _ => None,
         }
     }
 }
 #[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssIfSupportsTestCondition {
-    AnyCssImportSupportsCondition(AnyCssImportSupportsCondition),
-    CssIfSupportsIdentifierTest(CssIfSupportsIdentifierTest),
+pub enum AnyCssPageSelectorPseudo {
+    CssBogusPageSelectorPseudo(CssBogusPageSelectorPseudo),
+    CssPageSelectorPseudo(CssPageSelectorPseudo),
 }
-impl AnyCssIfSupportsTestCondition {
-    pub fn as_any_css_import_supports_condition(&self) -> Option<&AnyCssImportSupportsCondition> {
+impl AnyCssPageSelectorPseudo {
+    pub fn as_css_bogus_page_selector_pseudo(&self) -> Option<&CssBogusPageSelectorPseudo> {
         match &self {
-            Self::AnyCssImportSupportsCondition(item) => Some(item),
+            Self::CssBogusPageSelectorPseudo(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_if_supports_identifier_test(&self) -> Option<&CssIfSupportsIdentifierTest> {
+    pub fn as_css_page_selector_pseudo(&self) -> Option<&CssPageSelectorPseudo> {
         match &self {
-            Self::CssIfSupportsIdentifierTest(item) => Some(item),
+            Self::CssPageSelectorPseudo(item) => Some(item),
             _ => None,
         }
     }
 }
 #[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssIfTest {
-    CssBogusIfTest(CssBogusIfTest),
-    CssIfMediaTest(CssIfMediaTest),
-    CssIfStyleTest(CssIfStyleTest),
-    CssIfSupportsTest(CssIfSupportsTest),
+pub enum AnyCssProperty {
+    CssBogusProperty(CssBogusProperty),
+    CssComposesProperty(CssComposesProperty),
+    CssGenericProperty(CssGenericProperty),
 }
-impl AnyCssIfTest {
-    pub fn as_css_bogus_if_test(&self) -> Option<&CssBogusIfTest> {
+impl AnyCssProperty {
+    pub fn as_css_bogus_property(&self) -> Option<&CssBogusProperty> {
         match &self {
-            Self::CssBogusIfTest(item) => Some(item),
+            Self::CssBogusProperty(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_if_media_test(&self) -> Option<&CssIfMediaTest> {
+    pub fn as_css_composes_property(&self) -> Option<&CssComposesProperty> {
         match &self {
-            Self::CssIfMediaTest(item) => Some(item),
+            Self::CssComposesProperty(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_if_style_test(&self) -> Option<&CssIfStyleTest> {
+    pub fn as_css_generic_property(&self) -> Option<&CssGenericProperty> {
         match &self {
-            Self::CssIfStyleTest(item) => Some(item),
+            Self::CssGenericProperty(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_if_supports_test(&self) -> Option<&CssIfSupportsTest> {
+}
+#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
+pub enum AnyCssPseudoClass {
+    CssBogusPseudoClass(CssBogusPseudoClass),
+    CssPseudoClassFunctionCompoundSelector(CssPseudoClassFunctionCompoundSelector),
+    CssPseudoClassFunctionCompoundSelectorList(CssPseudoClassFunctionCompoundSelectorList),
+    CssPseudoClassFunctionCustomIdentifier(CssPseudoClassFunctionCustomIdentifier),
+    CssPseudoClassFunctionCustomIdentifierList(CssPseudoClassFunctionCustomIdentifierList),
+    CssPseudoClassFunctionIdentifier(CssPseudoClassFunctionIdentifier),
+    CssPseudoClassFunctionNth(CssPseudoClassFunctionNth),
+    CssPseudoClassFunctionRelativeSelectorList(CssPseudoClassFunctionRelativeSelectorList),
+    CssPseudoClassFunctionSelector(CssPseudoClassFunctionSelector),
+    CssPseudoClassFunctionSelectorList(CssPseudoClassFunctionSelectorList),
+    CssPseudoClassFunctionValueList(CssPseudoClassFunctionValueList),
+    CssPseudoClassIdentifier(CssPseudoClassIdentifier),
+}
+impl AnyCssPseudoClass {
+    pub fn as_css_bogus_pseudo_class(&self) -> Option<&CssBogusPseudoClass> {
         match &self {
-            Self::CssIfSupportsTest(item) => Some(item),
+            Self::CssBogusPseudoClass(item) => Some(item),
             _ => None,
         }
     }
-}
-#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssIfTestBooleanAndCombinableExpr {
-    AnyCssIfTestBooleanExprGroup(AnyCssIfTestBooleanExprGroup),
-    CssIfTestBooleanAndExpr(CssIfTestBooleanAndExpr),
-}
-impl AnyCssIfTestBooleanAndCombinableExpr {
-    pub fn as_any_css_if_test_boolean_expr_group(&self) -> Option<&AnyCssIfTestBooleanExprGroup> {
+    pub fn as_css_pseudo_class_function_compound_selector(
+        &self,
+    ) -> Option<&CssPseudoClassFunctionCompoundSelector> {
         match &self {
-            Self::AnyCssIfTestBooleanExprGroup(item) => Some(item),
+            Self::CssPseudoClassFunctionCompoundSelector(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_if_test_boolean_and_expr(&self) -> Option<&CssIfTestBooleanAndExpr> {
+    pub fn as_css_pseudo_class_function_compound_selector_list(
+        &self,
+    ) -> Option<&CssPseudoClassFunctionCompoundSelectorList> {
         match &self {
-            Self::CssIfTestBooleanAndExpr(item) => Some(item),
+            Self::CssPseudoClassFunctionCompoundSelectorList(item) => Some(item),
             _ => None,
         }
     }
-}
-#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssIfTestBooleanExpr {
-    AnyCssIfTestBooleanAndCombinableExpr(AnyCssIfTestBooleanAndCombinableExpr),
-    AnyCssIfTestBooleanOrCombinableExpr(AnyCssIfTestBooleanOrCombinableExpr),
-    CssIfTestBooleanNotExpr(CssIfTestBooleanNotExpr),
-}
-impl AnyCssIfTestBooleanExpr {
-    pub fn as_any_css_if_test_boolean_and_combinable_expr(
+    pub fn as_css_pseudo_class_function_custom_identifier(
         &self,
-    ) -> Option<&AnyCssIfTestBooleanAndCombinableExpr> {
+    ) -> Option<&CssPseudoClassFunctionCustomIdentifier> {
         match &self {
-            Self::AnyCssIfTestBooleanAndCombinableExpr(item) => Some(item),
+            Self::CssPseudoClassFunctionCustomIdentifier(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_any_css_if_test_boolean_or_combinable_expr(
+    pub fn as_css_pseudo_class_function_custom_identifier_list(
         &self,
-    ) -> Option<&AnyCssIfTestBooleanOrCombinableExpr> {
+    ) -> Option<&CssPseudoClassFunctionCustomIdentifierList> {
         match &self {
-            Self::AnyCssIfTestBooleanOrCombinableExpr(item) => Some(item),
+            Self::CssPseudoClassFunctionCustomIdentifierList(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_if_test_boolean_not_expr(&self) -> Option<&CssIfTestBooleanNotExpr> {
+    pub fn as_css_pseudo_class_function_identifier(
+        &self,
+    ) -> Option<&CssPseudoClassFunctionIdentifier> {
         match &self {
-            Self::CssIfTestBooleanNotExpr(item) => Some(item),
+            Self::CssPseudoClassFunctionIdentifier(item) => Some(item),
             _ => None,
         }
     }
-}
-#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssIfTestBooleanExprGroup {
-    AnyCssIfTest(AnyCssIfTest),
-    CssIfTestBooleanExprInParens(CssIfTestBooleanExprInParens),
-}
-impl AnyCssIfTestBooleanExprGroup {
-    pub fn as_any_css_if_test(&self) -> Option<&AnyCssIfTest> {
+    pub fn as_css_pseudo_class_function_nth(&self) -> Option<&CssPseudoClassFunctionNth> {
         match &self {
-            Self::AnyCssIfTest(item) => Some(item),
+            Self::CssPseudoClassFunctionNth(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_if_test_boolean_expr_in_parens(&self) -> Option<&CssIfTestBooleanExprInParens> {
+    pub fn as_css_pseudo_class_function_relative_selector_list(
+        &self,
+    ) -> Option<&CssPseudoClassFunctionRelativeSelectorList> {
         match &self {
-            Self::CssIfTestBooleanExprInParens(item) => Some(item),
+            Self::CssPseudoClassFunctionRelativeSelectorList(item) => Some(item),
             _ => None,
         }
     }
-}
-#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssIfTestBooleanOrCombinableExpr {
-    AnyCssIfTestBooleanExprGroup(AnyCssIfTestBooleanExprGroup),
-    CssIfTestBooleanOrExpr(CssIfTestBooleanOrExpr),
-}
-impl AnyCssIfTestBooleanOrCombinableExpr {
-    pub fn as_any_css_if_test_boolean_expr_group(&self) -> Option<&AnyCssIfTestBooleanExprGroup> {
+    pub fn as_css_pseudo_class_function_selector(&self) -> Option<&CssPseudoClassFunctionSelector> {
         match &self {
-            Self::AnyCssIfTestBooleanExprGroup(item) => Some(item),
+            Self::CssPseudoClassFunctionSelector(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_if_test_boolean_or_expr(&self) -> Option<&CssIfTestBooleanOrExpr> {
+    pub fn as_css_pseudo_class_function_selector_list(
+        &self,
+    ) -> Option<&CssPseudoClassFunctionSelectorList> {
         match &self {
-            Self::CssIfTestBooleanOrExpr(item) => Some(item),
+            Self::CssPseudoClassFunctionSelectorList(item) => Some(item),
             _ => None,
         }
     }
-}
-#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssImportLayer {
-    CssImportAnonymousLayer(CssImportAnonymousLayer),
-    CssImportNamedLayer(CssImportNamedLayer),
-}
-impl AnyCssImportLayer {
-    pub fn as_css_import_anonymous_layer(&self) -> Option<&CssImportAnonymousLayer> {
+    pub fn as_css_pseudo_class_function_value_list(
+        &self,
+    ) -> Option<&CssPseudoClassFunctionValueList> {
         match &self {
-            Self::CssImportAnonymousLayer(item) => Some(item),
+            Self::CssPseudoClassFunctionValueList(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_import_named_layer(&self) -> Option<&CssImportNamedLayer> {
+    pub fn as_css_pseudo_class_identifier(&self) -> Option<&CssPseudoClassIdentifier> {
         match &self {
-            Self::CssImportNamedLayer(item) => Some(item),
+            Self::CssPseudoClassIdentifier(item) => Some(item),
             _ => None,
         }
     }
 }
 #[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssImportSupportsCondition {
-    AnyCssSupportsCondition(AnyCssSupportsCondition),
-    CssDeclaration(CssDeclaration),
+pub enum AnyCssPseudoClassNth {
+    CssPseudoClassNth(CssPseudoClassNth),
+    CssPseudoClassNthIdentifier(CssPseudoClassNthIdentifier),
+    CssPseudoClassNthNumber(CssPseudoClassNthNumber),
 }
-impl AnyCssImportSupportsCondition {
-    pub fn as_any_css_supports_condition(&self) -> Option<&AnyCssSupportsCondition> {
+impl AnyCssPseudoClassNth {
+    pub fn as_css_pseudo_class_nth(&self) -> Option<&CssPseudoClassNth> {
         match &self {
-            Self::AnyCssSupportsCondition(item) => Some(item),
+            Self::CssPseudoClassNth(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_declaration(&self) -> Option<&CssDeclaration> {
+    pub fn as_css_pseudo_class_nth_identifier(&self) -> Option<&CssPseudoClassNthIdentifier> {
         match &self {
-            Self::CssDeclaration(item) => Some(item),
+            Self::CssPseudoClassNthIdentifier(item) => Some(item),
+            _ => None,
+        }
+    }
+    pub fn as_css_pseudo_class_nth_number(&self) -> Option<&CssPseudoClassNthNumber> {
+        match &self {
+            Self::CssPseudoClassNthNumber(item) => Some(item),
             _ => None,
         }
     }
 }
 #[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssImportUrl {
-    CssString(CssString),
-    CssUrlFunction(CssUrlFunction),
+pub enum AnyCssPseudoClassNthSelector {
+    CssBogusSelector(CssBogusSelector),
+    CssPseudoClassNthSelector(CssPseudoClassNthSelector),
 }
-impl AnyCssImportUrl {
-    pub fn as_css_string(&self) -> Option<&CssString> {
+impl AnyCssPseudoClassNthSelector {
+    pub fn as_css_bogus_selector(&self) -> Option<&CssBogusSelector> {
         match &self {
-            Self::CssString(item) => Some(item),
+            Self::CssBogusSelector(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_url_function(&self) -> Option<&CssUrlFunction> {
+    pub fn as_css_pseudo_class_nth_selector(&self) -> Option<&CssPseudoClassNthSelector> {
         match &self {
-            Self::CssUrlFunction(item) => Some(item),
+            Self::CssPseudoClassNthSelector(item) => Some(item),
             _ => None,
         }
     }
 }
 #[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssKeyframesBlock {
-    CssBogusBlock(CssBogusBlock),
-    CssKeyframesBlock(CssKeyframesBlock),
+pub enum AnyCssPseudoElement {
+    CssBogusPseudoElement(CssBogusPseudoElement),
+    CssPseudoElementFunction(CssPseudoElementFunction),
+    CssPseudoElementFunctionCustomIdentifier(CssPseudoElementFunctionCustomIdentifier),
+    CssPseudoElementFunctionSelector(CssPseudoElementFunctionSelector),
+    CssPseudoElementIdentifier(CssPseudoElementIdentifier),
 }
-impl AnyCssKeyframesBlock {
-    pub fn as_css_bogus_block(&self) -> Option<&CssBogusBlock> {
+impl AnyCssPseudoElement {
+    pub fn as_css_bogus_pseudo_element(&self) -> Option<&CssBogusPseudoElement> {
         match &self {
-            Self::CssBogusBlock(item) => Some(item),
+            Self::CssBogusPseudoElement(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_keyframes_block(&self) -> Option<&CssKeyframesBlock> {
+    pub fn as_css_pseudo_element_function(&self) -> Option<&CssPseudoElementFunction> {
         match &self {
-            Self::CssKeyframesBlock(item) => Some(item),
+            Self::CssPseudoElementFunction(item) => Some(item),
             _ => None,
         }
     }
-}
-#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssKeyframesIdentifier {
-    CssCustomIdentifier(CssCustomIdentifier),
-    CssString(CssString),
-}
-impl AnyCssKeyframesIdentifier {
-    pub fn as_css_custom_identifier(&self) -> Option<&CssCustomIdentifier> {
+    pub fn as_css_pseudo_element_function_custom_identifier(
+        &self,
+    ) -> Option<&CssPseudoElementFunctionCustomIdentifier> {
         match &self {
-            Self::CssCustomIdentifier(item) => Some(item),
+            Self::CssPseudoElementFunctionCustomIdentifier(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_string(&self) -> Option<&CssString> {
+    pub fn as_css_pseudo_element_function_selector(
+        &self,
+    ) -> Option<&CssPseudoElementFunctionSelector> {
         match &self {
-            Self::CssString(item) => Some(item),
+            Self::CssPseudoElementFunctionSelector(item) => Some(item),
+            _ => None,
+        }
+    }
+    pub fn as_css_pseudo_element_identifier(&self) -> Option<&CssPseudoElementIdentifier> {
+        match &self {
+            Self::CssPseudoElementIdentifier(item) => Some(item),
             _ => None,
         }
     }
 }
 #[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssKeyframesItem {
-    CssBogusKeyframesItem(CssBogusKeyframesItem),
-    CssKeyframesItem(CssKeyframesItem),
+pub enum AnyCssPseudoValue {
+    CssIdentifier(CssIdentifier),
+    CssString(CssString),
 }
-impl AnyCssKeyframesItem {
-    pub fn as_css_bogus_keyframes_item(&self) -> Option<&CssBogusKeyframesItem> {
+impl AnyCssPseudoValue {
+    pub fn as_css_identifier(&self) -> Option<&CssIdentifier> {
         match &self {
-            Self::CssBogusKeyframesItem(item) => Some(item),
+            Self::CssIdentifier(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_keyframes_item(&self) -> Option<&CssKeyframesItem> {
+    pub fn as_css_string(&self) -> Option<&CssString> {
         match &self {
-            Self::CssKeyframesItem(item) => Some(item),
+            Self::CssString(item) => Some(item),
             _ => None,
         }
     }
 }
 #[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssKeyframesName {
-    AnyCssKeyframesIdentifier(AnyCssKeyframesIdentifier),
-    CssBogusKeyframesName(CssBogusKeyframesName),
-    CssKeyframesScopedName(CssKeyframesScopedName),
+pub enum AnyCssQueryFeature {
+    CssQueryFeatureBoolean(CssQueryFeatureBoolean),
+    CssQueryFeaturePlain(CssQueryFeaturePlain),
+    CssQueryFeatureRange(CssQueryFeatureRange),
+    CssQueryFeatureRangeInterval(CssQueryFeatureRangeInterval),
+    CssQueryFeatureReverseRange(CssQueryFeatureReverseRange),
 }
-impl AnyCssKeyframesName {
-    pub fn as_any_css_keyframes_identifier(&self) -> Option<&AnyCssKeyframesIdentifier> {
+impl AnyCssQueryFeature {
+    pub fn as_css_query_feature_boolean(&self) -> Option<&CssQueryFeatureBoolean> {
         match &self {
-            Self::AnyCssKeyframesIdentifier(item) => Some(item),
+            Self::CssQueryFeatureBoolean(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_bogus_keyframes_name(&self) -> Option<&CssBogusKeyframesName> {
+    pub fn as_css_query_feature_plain(&self) -> Option<&CssQueryFeaturePlain> {
         match &self {
-            Self::CssBogusKeyframesName(item) => Some(item),
+            Self::CssQueryFeaturePlain(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_keyframes_scoped_name(&self) -> Option<&CssKeyframesScopedName> {
+    pub fn as_css_query_feature_range(&self) -> Option<&CssQueryFeatureRange> {
         match &self {
-            Self::CssKeyframesScopedName(item) => Some(item),
+            Self::CssQueryFeatureRange(item) => Some(item),
             _ => None,
         }
     }
-}
-#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssKeyframesScope {
-    CssKeyframesScopeFunction(CssKeyframesScopeFunction),
-    CssKeyframesScopePrefix(CssKeyframesScopePrefix),
-}
-impl AnyCssKeyframesScope {
-    pub fn as_css_keyframes_scope_function(&self) -> Option<&CssKeyframesScopeFunction> {
+    pub fn as_css_query_feature_range_interval(&self) -> Option<&CssQueryFeatureRangeInterval> {
         match &self {
-            Self::CssKeyframesScopeFunction(item) => Some(item),
+            Self::CssQueryFeatureRangeInterval(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_keyframes_scope_prefix(&self) -> Option<&CssKeyframesScopePrefix> {
+    pub fn as_css_query_feature_reverse_range(&self) -> Option<&CssQueryFeatureReverseRange> {
         match &self {
-            Self::CssKeyframesScopePrefix(item) => Some(item),
+            Self::CssQueryFeatureReverseRange(item) => Some(item),
             _ => None,
         }
     }
 }
 #[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssKeyframesSelector {
-    CssBogusSelector(CssBogusSelector),
-    CssKeyframesIdentSelector(CssKeyframesIdentSelector),
-    CssKeyframesPercentageSelector(CssKeyframesPercentageSelector),
+pub enum AnyCssQueryFeatureValue {
+    AnyCssDimension(AnyCssDimension),
+    AnyCssFunction(AnyCssFunction),
+    CssIdentifier(CssIdentifier),
+    CssNumber(CssNumber),
+    CssRatio(CssRatio),
 }
-impl AnyCssKeyframesSelector {
-    pub fn as_css_bogus_selector(&self) -> Option<&CssBogusSelector> {
-        match &self {
-            Self::CssBogusSelector(item) => Some(item),
-            _ => None,
-        }
-    }
-    pub fn as_css_keyframes_ident_selector(&self) -> Option<&CssKeyframesIdentSelector> {
+impl AnyCssQueryFeatureValue {
+    pub fn as_any_css_dimension(&self) -> Option<&AnyCssDimension> {
         match &self {
-            Self::CssKeyframesIdentSelector(item) => Some(item),
+            Self::AnyCssDimension(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_keyframes_percentage_selector(&self) -> Option<&CssKeyframesPercentageSelector> {
+    pub fn as_any_css_function(&self) -> Option<&AnyCssFunction> {
         match &self {
-            Self::CssKeyframesPercentageSelector(item) => Some(item),
+            Self::AnyCssFunction(item) => Some(item),
             _ => None,
         }
     }
-}
-#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssLayer {
-    CssBogusLayer(CssBogusLayer),
-    CssLayerDeclaration(CssLayerDeclaration),
-    CssLayerReference(CssLayerReference),
-}
-impl AnyCssLayer {
-    pub fn as_css_bogus_layer(&self) -> Option<&CssBogusLayer> {
+    pub fn as_css_identifier(&self) -> Option<&CssIdentifier> {
         match &self {
-            Self::CssBogusLayer(item) => Some(item),
+            Self::CssIdentifier(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_layer_declaration(&self) -> Option<&CssLayerDeclaration> {
+    pub fn as_css_number(&self) -> Option<&CssNumber> {
         match &self {
-            Self::CssLayerDeclaration(item) => Some(item),
+            Self::CssNumber(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_layer_reference(&self) -> Option<&CssLayerReference> {
+    pub fn as_css_ratio(&self) -> Option<&CssRatio> {
         match &self {
-            Self::CssLayerReference(item) => Some(item),
+            Self::CssRatio(item) => Some(item),
             _ => None,
         }
     }
 }
 #[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssMediaAndCombinableCondition {
-    AnyCssMediaInParens(AnyCssMediaInParens),
-    CssMediaAndCondition(CssMediaAndCondition),
+pub enum AnyCssRelativeSelector {
+    CssBogusSelector(CssBogusSelector),
+    CssRelativeSelector(CssRelativeSelector),
 }
-impl AnyCssMediaAndCombinableCondition {
-    pub fn as_any_css_media_in_parens(&self) -> Option<&AnyCssMediaInParens> {
+impl AnyCssRelativeSelector {
+    pub fn as_css_bogus_selector(&self) -> Option<&CssBogusSelector> {
         match &self {
-            Self::AnyCssMediaInParens(item) => Some(item),
+            Self::CssBogusSelector(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_media_and_condition(&self) -> Option<&CssMediaAndCondition> {
+    pub fn as_css_relative_selector(&self) -> Option<&CssRelativeSelector> {
         match &self {
-            Self::CssMediaAndCondition(item) => Some(item),
+            Self::CssRelativeSelector(item) => Some(item),
             _ => None,
         }
     }
 }
 #[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssMediaCondition {
-    AnyCssMediaInParens(AnyCssMediaInParens),
-    CssMediaAndCondition(CssMediaAndCondition),
-    CssMediaNotCondition(CssMediaNotCondition),
-    CssMediaOrCondition(CssMediaOrCondition),
+pub enum AnyCssRule {
+    CssAtRule(CssAtRule),
+    CssBogusRule(CssBogusRule),
+    CssNestedQualifiedRule(CssNestedQualifiedRule),
+    CssQualifiedRule(CssQualifiedRule),
 }
-impl AnyCssMediaCondition {
-    pub fn as_any_css_media_in_parens(&self) -> Option<&AnyCssMediaInParens> {
+impl AnyCssRule {
+    pub fn as_css_at_rule(&self) -> Option<&CssAtRule> {
         match &self {
-            Self::AnyCssMediaInParens(item) => Some(item),
+            Self::CssAtRule(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_media_and_condition(&self) -> Option<&CssMediaAndCondition> {
+    pub fn as_css_bogus_rule(&self) -> Option<&CssBogusRule> {
         match &self {
-            Self::CssMediaAndCondition(item) => Some(item),
+            Self::CssBogusRule(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_media_not_condition(&self) -> Option<&CssMediaNotCondition> {
+    pub fn as_css_nested_qualified_rule(&self) -> Option<&CssNestedQualifiedRule> {
         match &self {
-            Self::CssMediaNotCondition(item) => Some(item),
+            Self::CssNestedQualifiedRule(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_media_or_condition(&self) -> Option<&CssMediaOrCondition> {
+    pub fn as_css_qualified_rule(&self) -> Option<&CssQualifiedRule> {
         match &self {
-            Self::CssMediaOrCondition(item) => Some(item),
+            Self::CssQualifiedRule(item) => Some(item),
             _ => None,
         }
     }
 }
 #[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssMediaInParens {
-    CssMediaConditionInParens(CssMediaConditionInParens),
-    CssMediaFeatureInParens(CssMediaFeatureInParens),
+pub enum AnyCssRuleBlock {
+    CssBogusBlock(CssBogusBlock),
+    CssRuleBlock(CssRuleBlock),
 }
-impl AnyCssMediaInParens {
-    pub fn as_css_media_condition_in_parens(&self) -> Option<&CssMediaConditionInParens> {
+impl AnyCssRuleBlock {
+    pub fn as_css_bogus_block(&self) -> Option<&CssBogusBlock> {
         match &self {
-            Self::CssMediaConditionInParens(item) => Some(item),
+            Self::CssBogusBlock(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_media_feature_in_parens(&self) -> Option<&CssMediaFeatureInParens> {
+    pub fn as_css_rule_block(&self) -> Option<&CssRuleBlock> {
         match &self {
-            Self::CssMediaFeatureInParens(item) => Some(item),
+            Self::CssRuleBlock(item) => Some(item),
             _ => None,
         }
     }
 }
 #[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssMediaOrCombinableCondition {
-    AnyCssMediaInParens(AnyCssMediaInParens),
-    CssMediaOrCondition(CssMediaOrCondition),
+pub enum AnyCssScopeRange {
+    CssBogusScopeRange(CssBogusScopeRange),
+    CssScopeRangeEnd(CssScopeRangeEnd),
+    CssScopeRangeInterval(CssScopeRangeInterval),
+    CssScopeRangeStart(CssScopeRangeStart),
 }
-impl AnyCssMediaOrCombinableCondition {
-    pub fn as_any_css_media_in_parens(&self) -> Option<&AnyCssMediaInParens> {
+impl AnyCssScopeRange {
+    pub fn as_css_bogus_scope_range(&self) -> Option<&CssBogusScopeRange> {
         match &self {
-            Self::AnyCssMediaInParens(item) => Some(item),
+            Self::CssBogusScopeRange(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_media_or_condition(&self) -> Option<&CssMediaOrCondition> {
+    pub fn as_css_scope_range_end(&self) -> Option<&CssScopeRangeEnd> {
         match &self {
-            Self::CssMediaOrCondition(item) => Some(item),
+            Self::CssScopeRangeEnd(item) => Some(item),
             _ => None,
         }
     }
-}
-#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssMediaQuery {
-    AnyCssMediaTypeQuery(AnyCssMediaTypeQuery),
-    CssBogusMediaQuery(CssBogusMediaQuery),
-    CssMediaConditionQuery(CssMediaConditionQuery),
+    pub fn as_css_scope_range_interval(&self) -> Option<&CssScopeRangeInterval> {
+        match &self {
+            Self::CssScopeRangeInterval(item) => Some(item),
+            _ => None,
+        }
+    }
+    pub fn as_css_scope_range_start(&self) -> Option<&CssScopeRangeStart> {
+        match &self {
+            Self::CssScopeRangeStart(item) => Some(item),
+            _ => None,
+        }
+    }
+}
+#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
+pub enum AnyCssSelector {
+    CssBogusSelector(CssBogusSelector),
+    CssComplexSelector(CssComplexSelector),
+    CssCompoundSelector(CssCompoundSelector),
     CssMetavariable(CssMetavariable),
 }
-impl AnyCssMediaQuery {
-    pub fn as_any_css_media_type_query(&self) -> Option<&AnyCssMediaTypeQuery> {
+impl AnyCssSelector {
+    pub fn as_css_bogus_selector(&self) -> Option<&CssBogusSelector> {
         match &self {
-            Self::AnyCssMediaTypeQuery(item) => Some(item),
+            Self::CssBogusSelector(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_bogus_media_query(&self) -> Option<&CssBogusMediaQuery> {
+    pub fn as_css_complex_selector(&self) -> Option<&CssComplexSelector> {
         match &self {
-            Self::CssBogusMediaQuery(item) => Some(item),
+            Self::CssComplexSelector(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_media_condition_query(&self) -> Option<&CssMediaConditionQuery> {
+    pub fn as_css_compound_selector(&self) -> Option<&CssCompoundSelector> {
         match &self {
-            Self::CssMediaConditionQuery(item) => Some(item),
+            Self::CssCompoundSelector(item) => Some(item),
             _ => None,
         }
     }
@@ -10019,404 +9945,383 @@ impl AnyCssMediaQuery {
     }
 }
 #[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssMediaTypeCondition {
-    AnyCssMediaInParens(AnyCssMediaInParens),
-    CssMediaAndCondition(CssMediaAndCondition),
-    CssMediaNotCondition(CssMediaNotCondition),
+pub enum AnyCssSimpleSelector {
+    CssTypeSelector(CssTypeSelector),
+    CssUniversalSelector(CssUniversalSelector),
 }
-impl AnyCssMediaTypeCondition {
-    pub fn as_any_css_media_in_parens(&self) -> Option<&AnyCssMediaInParens> {
-        match &self {
-            Self::AnyCssMediaInParens(item) => Some(item),
-            _ => None,
-        }
-    }
-    pub fn as_css_media_and_condition(&self) -> Option<&CssMediaAndCondition> {
+impl AnyCssSimpleSelector {
+    pub fn as_css_type_selector(&self) -> Option<&CssTypeSelector> {
         match &self {
-            Self::CssMediaAndCondition(item) => Some(item),
+            Self::CssTypeSelector(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_media_not_condition(&self) -> Option<&CssMediaNotCondition> {
+    pub fn as_css_universal_selector(&self) -> Option<&CssUniversalSelector> {
         match &self {
-            Self::CssMediaNotCondition(item) => Some(item),
+            Self::CssUniversalSelector(item) => Some(item),
             _ => None,
         }
     }
 }
 #[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssMediaTypeQuery {
-    CssMediaAndTypeQuery(CssMediaAndTypeQuery),
-    CssMediaTypeQuery(CssMediaTypeQuery),
+pub enum AnyCssSubSelector {
+    CssAttributeSelector(CssAttributeSelector),
+    CssBogusSubSelector(CssBogusSubSelector),
+    CssClassSelector(CssClassSelector),
+    CssIdSelector(CssIdSelector),
+    CssPseudoClassSelector(CssPseudoClassSelector),
+    CssPseudoElementSelector(CssPseudoElementSelector),
 }
-impl AnyCssMediaTypeQuery {
-    pub fn as_css_media_and_type_query(&self) -> Option<&CssMediaAndTypeQuery> {
+impl AnyCssSubSelector {
+    pub fn as_css_attribute_selector(&self) -> Option<&CssAttributeSelector> {
         match &self {
-            Self::CssMediaAndTypeQuery(item) => Some(item),
+            Self::CssAttributeSelector(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_media_type_query(&self) -> Option<&CssMediaTypeQuery> {
+    pub fn as_css_bogus_sub_selector(&self) -> Option<&CssBogusSubSelector> {
         match &self {
-            Self::CssMediaTypeQuery(item) => Some(item),
+            Self::CssBogusSubSelector(item) => Some(item),
             _ => None,
         }
     }
-}
-#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssNamespacePrefix {
-    CssNamedNamespacePrefix(CssNamedNamespacePrefix),
-    CssUniversalNamespacePrefix(CssUniversalNamespacePrefix),
-}
-impl AnyCssNamespacePrefix {
-    pub fn as_css_named_namespace_prefix(&self) -> Option<&CssNamedNamespacePrefix> {
+    pub fn as_css_class_selector(&self) -> Option<&CssClassSelector> {
         match &self {
-            Self::CssNamedNamespacePrefix(item) => Some(item),
+            Self::CssClassSelector(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_universal_namespace_prefix(&self) -> Option<&CssUniversalNamespacePrefix> {
+    pub fn as_css_id_selector(&self) -> Option<&CssIdSelector> {
         match &self {
-            Self::CssUniversalNamespacePrefix(item) => Some(item),
+            Self::CssIdSelector(item) => Some(item),
             _ => None,
         }
     }
-}
-#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssNamespaceUrl {
-    CssString(CssString),
-    CssUrlFunction(CssUrlFunction),
-}
-impl AnyCssNamespaceUrl {
-    pub fn as_css_string(&self) -> Option<&CssString> {
+    pub fn as_css_pseudo_class_selector(&self) -> Option<&CssPseudoClassSelector> {
         match &self {
-            Self::CssString(item) => Some(item),
+            Self::CssPseudoClassSelector(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_url_function(&self) -> Option<&CssUrlFunction> {
+    pub fn as_css_pseudo_element_selector(&self) -> Option<&CssPseudoElementSelector> {
         match &self {
-            Self::CssUrlFunction(item) => Some(item),
+            Self::CssPseudoElementSelector(item) => Some(item),
             _ => None,
         }
     }
 }
 #[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssPageAtRuleBlock {
-    CssBogusBlock(CssBogusBlock),
-    CssPageAtRuleBlock(CssPageAtRuleBlock),
+pub enum AnyCssSupportsAndCombinableCondition {
+    AnyCssSupportsInParens(AnyCssSupportsInParens),
+    CssSupportsAndCondition(CssSupportsAndCondition),
 }
-impl AnyCssPageAtRuleBlock {
-    pub fn as_css_bogus_block(&self) -> Option<&CssBogusBlock> {
+impl AnyCssSupportsAndCombinableCondition {
+    pub fn as_any_css_supports_in_parens(&self) -> Option<&AnyCssSupportsInParens> {
         match &self {
-            Self::CssBogusBlock(item) => Some(item),
+            Self::AnyCssSupportsInParens(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_page_at_rule_block(&self) -> Option<&CssPageAtRuleBlock> {
+    pub fn as_css_supports_and_condition(&self) -> Option<&CssSupportsAndCondition> {
         match &self {
-            Self::CssPageAtRuleBlock(item) => Some(item),
+            Self::CssSupportsAndCondition(item) => Some(item),
             _ => None,
         }
     }
 }
 #[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssPageAtRuleItem {
-    CssAtRule(CssAtRule),
-    CssDeclarationWithSemicolon(CssDeclarationWithSemicolon),
-    CssEmptyDeclaration(CssEmptyDeclaration),
-    CssMarginAtRule(CssMarginAtRule),
+pub enum AnyCssSupportsCondition {
+    AnyCssSupportsInParens(AnyCssSupportsInParens),
+    CssBogusSupportsCondition(CssBogusSupportsCondition),
+    CssSupportsAndCondition(CssSupportsAndCondition),
+    CssSupportsNotCondition(CssSupportsNotCondition),
+    CssSupportsOrCondition(CssSupportsOrCondition),
 }
-impl AnyCssPageAtRuleItem {
-    pub fn as_css_at_rule(&self) -> Option<&CssAtRule> {
+impl AnyCssSupportsCondition {
+    pub fn as_any_css_supports_in_parens(&self) -> Option<&AnyCssSupportsInParens> {
         match &self {
-            Self::CssAtRule(item) => Some(item),
+            Self::AnyCssSupportsInParens(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_declaration_with_semicolon(&self) -> Option<&CssDeclarationWithSemicolon> {
+    pub fn as_css_bogus_supports_condition(&self) -> Option<&CssBogusSupportsCondition> {
         match &self {
-            Self::CssDeclarationWithSemicolon(item) => Some(item),
+            Self::CssBogusSupportsCondition(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_empty_declaration(&self) -> Option<&CssEmptyDeclaration> {
+    pub fn as_css_supports_and_condition(&self) -> Option<&CssSupportsAndCondition> {
         match &self {
-            Self::CssEmptyDeclaration(item) => Some(item),
+            Self::CssSupportsAndCondition(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_margin_at_rule(&self) -> Option<&CssMarginAtRule> {
+    pub fn as_css_supports_not_condition(&self) -> Option<&CssSupportsNotCondition> {
         match &self {
-            Self::CssMarginAtRule(item) => Some(item),
+            Self::CssSupportsNotCondition(item) => Some(item),
+            _ => None,
+        }
+    }
+    pub fn as_css_supports_or_condition(&self) -> Option<&CssSupportsOrCondition> {
+        match &self {
+            Self::CssSupportsOrCondition(item) => Some(item),
             _ => None,
         }
     }
 }
 #[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssPageSelector {
-    CssBogusSelector(CssBogusSelector),
-    CssPageSelector(CssPageSelector),
+pub enum AnyCssSupportsInParens {
+    AnyCssValue(AnyCssValue),
+    CssSupportsConditionInParens(CssSupportsConditionInParens),
+    CssSupportsFeatureDeclaration(CssSupportsFeatureDeclaration),
+    CssSupportsFeatureSelector(CssSupportsFeatureSelector),
 }
-impl AnyCssPageSelector {
-    pub fn as_css_bogus_selector(&self) -> Option<&CssBogusSelector> {
+impl AnyCssSupportsInParens {
+    pub fn as_any_css_value(&self) -> Option<&AnyCssValue> {
         match &self {
-            Self::CssBogusSelector(item) => Some(item),
+            Self::AnyCssValue(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_page_selector(&self) -> Option<&CssPageSelector> {
+    pub fn as_css_supports_condition_in_parens(&self) -> Option<&CssSupportsConditionInParens> {
         match &self {
-            Self::CssPageSelector(item) => Some(item),
+            Self::CssSupportsConditionInParens(item) => Some(item),
             _ => None,
         }
     }
-}
-#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssPageSelectorPseudo {
-    CssBogusPageSelectorPseudo(CssBogusPageSelectorPseudo),
-    CssPageSelectorPseudo(CssPageSelectorPseudo),
-}
-impl AnyCssPageSelectorPseudo {
-    pub fn as_css_bogus_page_selector_pseudo(&self) -> Option<&CssBogusPageSelectorPseudo> {
+    pub fn as_css_supports_feature_declaration(&self) -> Option<&CssSupportsFeatureDeclaration> {
         match &self {
-            Self::CssBogusPageSelectorPseudo(item) => Some(item),
+            Self::CssSupportsFeatureDeclaration(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_page_selector_pseudo(&self) -> Option<&CssPageSelectorPseudo> {
+    pub fn as_css_supports_feature_selector(&self) -> Option<&CssSupportsFeatureSelector> {
         match &self {
-            Self::CssPageSelectorPseudo(item) => Some(item),
+            Self::CssSupportsFeatureSelector(item) => Some(item),
             _ => None,
         }
     }
 }
 #[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssProperty {
-    CssBogusProperty(CssBogusProperty),
-    CssComposesProperty(CssComposesProperty),
-    CssGenericProperty(CssGenericProperty),
+pub enum AnyCssSupportsOrCombinableCondition {
+    AnyCssSupportsInParens(AnyCssSupportsInParens),
+    CssSupportsOrCondition(CssSupportsOrCondition),
 }
-impl AnyCssProperty {
-    pub fn as_css_bogus_property(&self) -> Option<&CssBogusProperty> {
-        match &self {
-            Self::CssBogusProperty(item) => Some(item),
-            _ => None,
-        }
-    }
-    pub fn as_css_composes_property(&self) -> Option<&CssComposesProperty> {
+impl AnyCssSupportsOrCombinableCondition {
+    pub fn as_any_css_supports_in_parens(&self) -> Option<&AnyCssSupportsInParens> {
         match &self {
-            Self::CssComposesProperty(item) => Some(item),
+            Self::AnyCssSupportsInParens(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_generic_property(&self) -> Option<&CssGenericProperty> {
+    pub fn as_css_supports_or_condition(&self) -> Option<&CssSupportsOrCondition> {
         match &self {
-            Self::CssGenericProperty(item) => Some(item),
+            Self::CssSupportsOrCondition(item) => Some(item),
             _ => None,
         }
     }
 }
 #[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssPseudoClass {
-    CssBogusPseudoClass(CssBogusPseudoClass),
-    CssPseudoClassFunctionCompoundSelector(CssPseudoClassFunctionCompoundSelector),
-    CssPseudoClassFunctionCompoundSelectorList(CssPseudoClassFunctionCompoundSelectorList),
-    CssPseudoClassFunctionCustomIdentifier(CssPseudoClassFunctionCustomIdentifier),
-    CssPseudoClassFunctionCustomIdentifierList(CssPseudoClassFunctionCustomIdentifierList),
-    CssPseudoClassFunctionIdentifier(CssPseudoClassFunctionIdentifier),
-    CssPseudoClassFunctionNth(CssPseudoClassFunctionNth),
-    CssPseudoClassFunctionRelativeSelectorList(CssPseudoClassFunctionRelativeSelectorList),
-    CssPseudoClassFunctionSelector(CssPseudoClassFunctionSelector),
-    CssPseudoClassFunctionSelectorList(CssPseudoClassFunctionSelectorList),
-    CssPseudoClassFunctionValueList(CssPseudoClassFunctionValueList),
-    CssPseudoClassIdentifier(CssPseudoClassIdentifier),
+pub enum AnyCssUnicodeValue {
+    CssBogusUnicodeRangeValue(CssBogusUnicodeRangeValue),
+    CssUnicodeCodepoint(CssUnicodeCodepoint),
+    CssUnicodeRangeInterval(CssUnicodeRangeInterval),
+    CssUnicodeRangeWildcard(CssUnicodeRangeWildcard),
 }
-impl AnyCssPseudoClass {
-    pub fn as_css_bogus_pseudo_class(&self) -> Option<&CssBogusPseudoClass> {
+impl AnyCssUnicodeValue {
+    pub fn as_css_bogus_unicode_range_value(&self) -> Option<&CssBogusUnicodeRangeValue> {
         match &self {
-            Self::CssBogusPseudoClass(item) => Some(item),
+            Self::CssBogusUnicodeRangeValue(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_pseudo_class_function_compound_selector(
-        &self,
-    ) -> Option<&CssPseudoClassFunctionCompoundSelector> {
+    pub fn as_css_unicode_codepoint(&self) -> Option<&CssUnicodeCodepoint> {
         match &self {
-            Self::CssPseudoClassFunctionCompoundSelector(item) => Some(item),
+            Self::CssUnicodeCodepoint(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_pseudo_class_function_compound_selector_list(
-        &self,
-    ) -> Option<&CssPseudoClassFunctionCompoundSelectorList> {
+    pub fn as_css_unicode_range_interval(&self) -> Option<&CssUnicodeRangeInterval> {
         match &self {
-            Self::CssPseudoClassFunctionCompoundSelectorList(item) => Some(item),
+            Self::CssUnicodeRangeInterval(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_pseudo_class_function_custom_identifier(
-        &self,
-    ) -> Option<&CssPseudoClassFunctionCustomIdentifier> {
+    pub fn as_css_unicode_range_wildcard(&self) -> Option<&CssUnicodeRangeWildcard> {
         match &self {
-            Self::CssPseudoClassFunctionCustomIdentifier(item) => Some(item),
+            Self::CssUnicodeRangeWildcard(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_pseudo_class_function_custom_identifier_list(
-        &self,
-    ) -> Option<&CssPseudoClassFunctionCustomIdentifierList> {
+}
+#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
+pub enum AnyCssUrlModifier {
+    CssBogusUrlModifier(CssBogusUrlModifier),
+    CssFunction(CssFunction),
+    CssIdentifier(CssIdentifier),
+}
+impl AnyCssUrlModifier {
+    pub fn as_css_bogus_url_modifier(&self) -> Option<&CssBogusUrlModifier> {
         match &self {
-            Self::CssPseudoClassFunctionCustomIdentifierList(item) => Some(item),
+            Self::CssBogusUrlModifier(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_pseudo_class_function_identifier(
-        &self,
-    ) -> Option<&CssPseudoClassFunctionIdentifier> {
+    pub fn as_css_function(&self) -> Option<&CssFunction> {
         match &self {
-            Self::CssPseudoClassFunctionIdentifier(item) => Some(item),
+            Self::CssFunction(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_pseudo_class_function_nth(&self) -> Option<&CssPseudoClassFunctionNth> {
+    pub fn as_css_identifier(&self) -> Option<&CssIdentifier> {
         match &self {
-            Self::CssPseudoClassFunctionNth(item) => Some(item),
+            Self::CssIdentifier(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_pseudo_class_function_relative_selector_list(
-        &self,
-    ) -> Option<&CssPseudoClassFunctionRelativeSelectorList> {
+}
+#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
+pub enum AnyCssUrlValue {
+    CssString(CssString),
+    CssUrlValueRaw(CssUrlValueRaw),
+}
+impl AnyCssUrlValue {
+    pub fn as_css_string(&self) -> Option<&CssString> {
         match &self {
-            Self::CssPseudoClassFunctionRelativeSelectorList(item) => Some(item),
+            Self::CssString(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_pseudo_class_function_selector(&self) -> Option<&CssPseudoClassFunctionSelector> {
+    pub fn as_css_url_value_raw(&self) -> Option<&CssUrlValueRaw> {
         match &self {
-            Self::CssPseudoClassFunctionSelector(item) => Some(item),
+            Self::CssUrlValueRaw(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_pseudo_class_function_selector_list(
-        &self,
-    ) -> Option<&CssPseudoClassFunctionSelectorList> {
+}
+#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
+pub enum AnyCssValue {
+    AnyCssDimension(AnyCssDimension),
+    AnyCssFunction(AnyCssFunction),
+    CssBracketedValue(CssBracketedValue),
+    CssColor(CssColor),
+    CssCustomIdentifier(CssCustomIdentifier),
+    CssDashedIdentifier(CssDashedIdentifier),
+    CssIdentifier(CssIdentifier),
+    CssMetavariable(CssMetavariable),
+    CssNumber(CssNumber),
+    CssRatio(CssRatio),
+    CssString(CssString),
+    CssUnicodeRange(CssUnicodeRange),
+    TwValueThemeReference(TwValueThemeReference),
+}
+impl AnyCssValue {
+    pub fn as_any_css_dimension(&self) -> Option<&AnyCssDimension> {
         match &self {
-            Self::CssPseudoClassFunctionSelectorList(item) => Some(item),
+            Self::AnyCssDimension(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_pseudo_class_function_value_list(
-        &self,
-    ) -> Option<&CssPseudoClassFunctionValueList> {
+    pub fn as_any_css_function(&self) -> Option<&AnyCssFunction> {
         match &self {
-            Self::CssPseudoClassFunctionValueList(item) => Some(item),
+            Self::AnyCssFunction(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_pseudo_class_identifier(&self) -> Option<&CssPseudoClassIdentifier> {
+    pub fn as_css_bracketed_value(&self) -> Option<&CssBracketedValue> {
         match &self {
-            Self::CssPseudoClassIdentifier(item) => Some(item),
+            Self::CssBracketedValue(item) => Some(item),
             _ => None,
         }
     }
-}
-#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssPseudoClassNth {
-    CssPseudoClassNth(CssPseudoClassNth),
-    CssPseudoClassNthIdentifier(CssPseudoClassNthIdentifier),
-    CssPseudoClassNthNumber(CssPseudoClassNthNumber),
-}
-impl AnyCssPseudoClassNth {
-    pub fn as_css_pseudo_class_nth(&self) -> Option<&CssPseudoClassNth> {
+    pub fn as_css_color(&self) -> Option<&CssColor> {
         match &self {
-            Self::CssPseudoClassNth(item) => Some(item),
+            Self::CssColor(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_pseudo_class_nth_identifier(&self) -> Option<&CssPseudoClassNthIdentifier> {
+    pub fn as_css_custom_identifier(&self) -> Option<&CssCustomIdentifier> {
         match &self {
-            Self::CssPseudoClassNthIdentifier(item) => Some(item),
+            Self::CssCustomIdentifier(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_pseudo_class_nth_number(&self) -> Option<&CssPseudoClassNthNumber> {
+    pub fn as_css_dashed_identifier(&self) -> Option<&CssDashedIdentifier> {
         match &self {
-            Self::CssPseudoClassNthNumber(item) => Some(item),
+            Self::CssDashedIdentifier(item) => Some(item),
             _ => None,
         }
     }
-}
-#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssPseudoClassNthSelector {
-    CssBogusSelector(CssBogusSelector),
-    CssPseudoClassNthSelector(CssPseudoClassNthSelector),
-}
-impl AnyCssPseudoClassNthSelector {
-    pub fn as_css_bogus_selector(&self) -> Option<&CssBogusSelector> {
+    pub fn as_css_identifier(&self) -> Option<&CssIdentifier> {
         match &self {
-            Self::CssBogusSelector(item) => Some(item),
+            Self::CssIdentifier(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_pseudo_class_nth_selector(&self) -> Option<&CssPseudoClassNthSelector> {
+    pub fn as_css_metavariable(&self) -> Option<&CssMetavariable> {
         match &self {
-            Self::CssPseudoClassNthSelector(item) => Some(item),
+            Self::CssMetavariable(item) => Some(item),
             _ => None,
         }
     }
-}
-#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssPseudoElement {
-    CssBogusPseudoElement(CssBogusPseudoElement),
-    CssPseudoElementFunction(CssPseudoElementFunction),
-    CssPseudoElementFunctionCustomIdentifier(CssPseudoElementFunctionCustomIdentifier),
-    CssPseudoElementFunctionSelector(CssPseudoElementFunctionSelector),
-    CssPseudoElementIdentifier(CssPseudoElementIdentifier),
-}
-impl AnyCssPseudoElement {
-    pub fn as_css_bogus_pseudo_element(&self) -> Option<&CssBogusPseudoElement> {
+    pub fn as_css_number(&self) -> Option<&CssNumber> {
         match &self {
-            Self::CssBogusPseudoElement(item) => Some(item),
+            Self::CssNumber(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_pseudo_element_function(&self) -> Option<&CssPseudoElementFunction> {
+    pub fn as_css_ratio(&self) -> Option<&CssRatio> {
         match &self {
-            Self::CssPseudoElementFunction(item) => Some(item),
+            Self::CssRatio(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_pseudo_element_function_custom_identifier(
-        &self,
-    ) -> Option<&CssPseudoElementFunctionCustomIdentifier> {
+    pub fn as_css_string(&self) -> Option<&CssString> {
         match &self {
-            Self::CssPseudoElementFunctionCustomIdentifier(item) => Some(item),
+            Self::CssString(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_pseudo_element_function_selector(
+    pub fn as_css_unicode_range(&self) -> Option<&CssUnicodeRange> {
+        match &self {
+            Self::CssUnicodeRange(item) => Some(item),
+            _ => None,
+        }
+    }
+    pub fn as_tw_value_theme_reference(&self) -> Option<&TwValueThemeReference> {
+        match &self {
+            Self::TwValueThemeReference(item) => Some(item),
+            _ => None,
+        }
+    }
+}
+#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
+pub enum AnyCssValueAtRuleClause {
+    CssValueAtRuleDeclarationClause(CssValueAtRuleDeclarationClause),
+    CssValueAtRuleImportClause(CssValueAtRuleImportClause),
+}
+impl AnyCssValueAtRuleClause {
+    pub fn as_css_value_at_rule_declaration_clause(
         &self,
-    ) -> Option<&CssPseudoElementFunctionSelector> {
+    ) -> Option<&CssValueAtRuleDeclarationClause> {
         match &self {
-            Self::CssPseudoElementFunctionSelector(item) => Some(item),
+            Self::CssValueAtRuleDeclarationClause(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_pseudo_element_identifier(&self) -> Option<&CssPseudoElementIdentifier> {
+    pub fn as_css_value_at_rule_import_clause(&self) -> Option<&CssValueAtRuleImportClause> {
         match &self {
-            Self::CssPseudoElementIdentifier(item) => Some(item),
+            Self::CssValueAtRuleImportClause(item) => Some(item),
             _ => None,
         }
     }
 }
 #[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssPseudoValue {
+pub enum AnyCssValueAtRuleImportSource {
     CssIdentifier(CssIdentifier),
     CssString(CssString),
 }
-impl AnyCssPseudoValue {
+impl AnyCssValueAtRuleImportSource {
     pub fn as_css_identifier(&self) -> Option<&CssIdentifier> {
         match &self {
             Self::CssIdentifier(item) => Some(item),
@@ -10431,735 +10336,636 @@ impl AnyCssPseudoValue {
     }
 }
 #[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssQueryFeature {
-    CssQueryFeatureBoolean(CssQueryFeatureBoolean),
-    CssQueryFeaturePlain(CssQueryFeaturePlain),
-    CssQueryFeatureRange(CssQueryFeatureRange),
-    CssQueryFeatureRangeInterval(CssQueryFeatureRangeInterval),
-    CssQueryFeatureReverseRange(CssQueryFeatureReverseRange),
+pub enum AnyCssValueAtRuleImportSpecifier {
+    CssValueAtRuleImportSpecifier(CssValueAtRuleImportSpecifier),
+    CssValueAtRuleNamedImportSpecifier(CssValueAtRuleNamedImportSpecifier),
 }
-impl AnyCssQueryFeature {
-    pub fn as_css_query_feature_boolean(&self) -> Option<&CssQueryFeatureBoolean> {
+impl AnyCssValueAtRuleImportSpecifier {
+    pub fn as_css_value_at_rule_import_specifier(&self) -> Option<&CssValueAtRuleImportSpecifier> {
         match &self {
-            Self::CssQueryFeatureBoolean(item) => Some(item),
+            Self::CssValueAtRuleImportSpecifier(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_query_feature_plain(&self) -> Option<&CssQueryFeaturePlain> {
+    pub fn as_css_value_at_rule_named_import_specifier(
+        &self,
+    ) -> Option<&CssValueAtRuleNamedImportSpecifier> {
         match &self {
-            Self::CssQueryFeaturePlain(item) => Some(item),
+            Self::CssValueAtRuleNamedImportSpecifier(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_query_feature_range(&self) -> Option<&CssQueryFeatureRange> {
+}
+#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
+pub enum AnyCssValueAtRuleProperty {
+    CssBogusProperty(CssBogusProperty),
+    CssValueAtRuleGenericProperty(CssValueAtRuleGenericProperty),
+}
+impl AnyCssValueAtRuleProperty {
+    pub fn as_css_bogus_property(&self) -> Option<&CssBogusProperty> {
         match &self {
-            Self::CssQueryFeatureRange(item) => Some(item),
+            Self::CssBogusProperty(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_query_feature_range_interval(&self) -> Option<&CssQueryFeatureRangeInterval> {
+    pub fn as_css_value_at_rule_generic_property(&self) -> Option<&CssValueAtRuleGenericProperty> {
         match &self {
-            Self::CssQueryFeatureRangeInterval(item) => Some(item),
+            Self::CssValueAtRuleGenericProperty(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_query_feature_reverse_range(&self) -> Option<&CssQueryFeatureReverseRange> {
+}
+#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
+pub enum AnyTwCustomVariantSelector {
+    AnyCssRuleBlock(AnyCssRuleBlock),
+    TwCustomVariantShorthand(TwCustomVariantShorthand),
+}
+impl AnyTwCustomVariantSelector {
+    pub fn as_any_css_rule_block(&self) -> Option<&AnyCssRuleBlock> {
         match &self {
-            Self::CssQueryFeatureReverseRange(item) => Some(item),
+            Self::AnyCssRuleBlock(item) => Some(item),
             _ => None,
         }
     }
-}
-#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssQueryFeatureValue {
-    AnyCssDimension(AnyCssDimension),
-    AnyCssFunction(AnyCssFunction),
-    CssIdentifier(CssIdentifier),
-    CssNumber(CssNumber),
-    CssRatio(CssRatio),
-}
-impl AnyCssQueryFeatureValue {
-    pub fn as_any_css_dimension(&self) -> Option<&AnyCssDimension> {
+    pub fn as_tw_custom_variant_shorthand(&self) -> Option<&TwCustomVariantShorthand> {
         match &self {
-            Self::AnyCssDimension(item) => Some(item),
+            Self::TwCustomVariantShorthand(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_any_css_function(&self) -> Option<&AnyCssFunction> {
+}
+#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
+pub enum AnyTwCustomVariantShorthand {
+    CssAtRuleDeclarator(CssAtRuleDeclarator),
+    CssSelectorList(CssSelectorList),
+}
+impl AnyTwCustomVariantShorthand {
+    pub fn as_css_at_rule_declarator(&self) -> Option<&CssAtRuleDeclarator> {
         match &self {
-            Self::AnyCssFunction(item) => Some(item),
+            Self::CssAtRuleDeclarator(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_identifier(&self) -> Option<&CssIdentifier> {
+    pub fn as_css_selector_list(&self) -> Option<&CssSelectorList> {
         match &self {
-            Self::CssIdentifier(item) => Some(item),
+            Self::CssSelectorList(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_number(&self) -> Option<&CssNumber> {
+}
+#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
+pub enum AnyTwSource {
+    CssString(CssString),
+    TwSourceInline(TwSourceInline),
+}
+impl AnyTwSource {
+    pub fn as_css_string(&self) -> Option<&CssString> {
         match &self {
-            Self::CssNumber(item) => Some(item),
+            Self::CssString(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_ratio(&self) -> Option<&CssRatio> {
+    pub fn as_tw_source_inline(&self) -> Option<&TwSourceInline> {
         match &self {
-            Self::CssRatio(item) => Some(item),
+            Self::TwSourceInline(item) => Some(item),
             _ => None,
         }
     }
 }
 #[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssRelativeSelector {
-    CssBogusSelector(CssBogusSelector),
-    CssRelativeSelector(CssRelativeSelector),
+pub enum AnyTwUtilityName {
+    CssIdentifier(CssIdentifier),
+    TwFunctionalUtilityName(TwFunctionalUtilityName),
 }
-impl AnyCssRelativeSelector {
-    pub fn as_css_bogus_selector(&self) -> Option<&CssBogusSelector> {
+impl AnyTwUtilityName {
+    pub fn as_css_identifier(&self) -> Option<&CssIdentifier> {
         match &self {
-            Self::CssBogusSelector(item) => Some(item),
+            Self::CssIdentifier(item) => Some(item),
             _ => None,
         }
     }
-    pub fn as_css_relative_selector(&self) -> Option<&CssRelativeSelector> {
+    pub fn as_tw_functional_utility_name(&self) -> Option<&TwFunctionalUtilityName> {
         match &self {
-            Self::CssRelativeSelector(item) => Some(item),
+            Self::TwFunctionalUtilityName(item) => Some(item),
             _ => None,
         }
     }
 }
-#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssRule {
-    CssAtRule(CssAtRule),
-    CssBogusRule(CssBogusRule),
-    CssNestedQualifiedRule(CssNestedQualifiedRule),
-    CssQualifiedRule(CssQualifiedRule),
-}
-impl AnyCssRule {
-    pub fn as_css_at_rule(&self) -> Option<&CssAtRule> {
-        match &self {
-            Self::CssAtRule(item) => Some(item),
-            _ => None,
-        }
+impl AstNode for CssAtRule {
+    type Language = Language;
+    const KIND_SET: SyntaxKindSet<Language> =
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_AT_RULE as u16));
+    fn can_cast(kind: SyntaxKind) -> bool {
+        kind == CSS_AT_RULE
     }
-    pub fn as_css_bogus_rule(&self) -> Option<&CssBogusRule> {
-        match &self {
-            Self::CssBogusRule(item) => Some(item),
-            _ => None,
+    fn cast(syntax: SyntaxNode) -> Option<Self> {
+        if Self::can_cast(syntax.kind()) {
+            Some(Self { syntax })
+        } else {
+            None
         }
     }
-    pub fn as_css_nested_qualified_rule(&self) -> Option<&CssNestedQualifiedRule> {
-        match &self {
-            Self::CssNestedQualifiedRule(item) => Some(item),
-            _ => None,
-        }
+    fn syntax(&self) -> &SyntaxNode {
+        &self.syntax
     }
-    pub fn as_css_qualified_rule(&self) -> Option<&CssQualifiedRule> {
-        match &self {
-            Self::CssQualifiedRule(item) => Some(item),
-            _ => None,
-        }
+    fn into_syntax(self) -> SyntaxNode {
+        self.syntax
     }
 }
-#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssRuleBlock {
-    CssBogusBlock(CssBogusBlock),
-    CssRuleBlock(CssRuleBlock),
-}
-impl AnyCssRuleBlock {
-    pub fn as_css_bogus_block(&self) -> Option<&CssBogusBlock> {
-        match &self {
-            Self::CssBogusBlock(item) => Some(item),
-            _ => None,
-        }
+impl std::fmt::Debug for CssAtRule {
+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+        thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
+        let current_depth = DEPTH.get();
+        let result = if current_depth < 16 {
+            DEPTH.set(current_depth + 1);
+            f.debug_struct("CssAtRule")
+                .field("at_token", &support::DebugSyntaxResult(self.at_token()))
+                .field("rule", &support::DebugSyntaxResult(self.rule()))
+                .finish()
+        } else {
+            f.debug_struct("CssAtRule").finish()
+        };
+        DEPTH.set(current_depth);
+        result
     }
-    pub fn as_css_rule_block(&self) -> Option<&CssRuleBlock> {
-        match &self {
-            Self::CssRuleBlock(item) => Some(item),
-            _ => None,
-        }
+}
+impl From<CssAtRule> for SyntaxNode {
+    fn from(n: CssAtRule) -> Self {
+        n.syntax
     }
 }
-#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssScopeRange {
-    CssBogusScopeRange(CssBogusScopeRange),
-    CssScopeRangeEnd(CssScopeRangeEnd),
-    CssScopeRangeInterval(CssScopeRangeInterval),
-    CssScopeRangeStart(CssScopeRangeStart),
+impl From<CssAtRule> for SyntaxElement {
+    fn from(n: CssAtRule) -> Self {
+        n.syntax.into()
+    }
 }
-impl AnyCssScopeRange {
-    pub fn as_css_bogus_scope_range(&self) -> Option<&CssBogusScopeRange> {
-        match &self {
-            Self::CssBogusScopeRange(item) => Some(item),
-            _ => None,
-        }
+impl AstNode for CssAtRuleDeclarator {
+    type Language = Language;
+    const KIND_SET: SyntaxKindSet<Language> =
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_AT_RULE_DECLARATOR as u16));
+    fn can_cast(kind: SyntaxKind) -> bool {
+        kind == CSS_AT_RULE_DECLARATOR
     }
-    pub fn as_css_scope_range_end(&self) -> Option<&CssScopeRangeEnd> {
-        match &self {
-            Self::CssScopeRangeEnd(item) => Some(item),
-            _ => None,
+    fn cast(syntax: SyntaxNode) -> Option<Self> {
+        if Self::can_cast(syntax.kind()) {
+            Some(Self { syntax })
+        } else {
+            None
         }
     }
-    pub fn as_css_scope_range_interval(&self) -> Option<&CssScopeRangeInterval> {
-        match &self {
-            Self::CssScopeRangeInterval(item) => Some(item),
-            _ => None,
-        }
+    fn syntax(&self) -> &SyntaxNode {
+        &self.syntax
     }
-    pub fn as_css_scope_range_start(&self) -> Option<&CssScopeRangeStart> {
-        match &self {
-            Self::CssScopeRangeStart(item) => Some(item),
-            _ => None,
-        }
+    fn into_syntax(self) -> SyntaxNode {
+        self.syntax
     }
 }
-#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssSelector {
-    CssBogusSelector(CssBogusSelector),
-    CssComplexSelector(CssComplexSelector),
-    CssCompoundSelector(CssCompoundSelector),
-    CssMetavariable(CssMetavariable),
+impl std::fmt::Debug for CssAtRuleDeclarator {
+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+        thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
+        let current_depth = DEPTH.get();
+        let result = if current_depth < 16 {
+            DEPTH.set(current_depth + 1);
+            f.debug_struct("CssAtRuleDeclarator")
+                .field("at_token", &support::DebugSyntaxResult(self.at_token()))
+                .field("declarator", &support::DebugSyntaxResult(self.declarator()))
+                .finish()
+        } else {
+            f.debug_struct("CssAtRuleDeclarator").finish()
+        };
+        DEPTH.set(current_depth);
+        result
+    }
 }
-impl AnyCssSelector {
-    pub fn as_css_bogus_selector(&self) -> Option<&CssBogusSelector> {
-        match &self {
-            Self::CssBogusSelector(item) => Some(item),
-            _ => None,
-        }
+impl From<CssAtRuleDeclarator> for SyntaxNode {
+    fn from(n: CssAtRuleDeclarator) -> Self {
+        n.syntax
     }
-    pub fn as_css_complex_selector(&self) -> Option<&CssComplexSelector> {
-        match &self {
-            Self::CssComplexSelector(item) => Some(item),
-            _ => None,
-        }
+}
+impl From<CssAtRuleDeclarator> for SyntaxElement {
+    fn from(n: CssAtRuleDeclarator) -> Self {
+        n.syntax.into()
     }
-    pub fn as_css_compound_selector(&self) -> Option<&CssCompoundSelector> {
-        match &self {
-            Self::CssCompoundSelector(item) => Some(item),
-            _ => None,
-        }
+}
+impl AstNode for CssAttributeMatcher {
+    type Language = Language;
+    const KIND_SET: SyntaxKindSet<Language> =
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_ATTRIBUTE_MATCHER as u16));
+    fn can_cast(kind: SyntaxKind) -> bool {
+        kind == CSS_ATTRIBUTE_MATCHER
     }
-    pub fn as_css_metavariable(&self) -> Option<&CssMetavariable> {
-        match &self {
-            Self::CssMetavariable(item) => Some(item),
-            _ => None,
+    fn cast(syntax: SyntaxNode) -> Option<Self> {
+        if Self::can_cast(syntax.kind()) {
+            Some(Self { syntax })
+        } else {
+            None
         }
     }
-}
-#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssSimpleSelector {
-    CssTypeSelector(CssTypeSelector),
-    CssUniversalSelector(CssUniversalSelector),
-}
-impl AnyCssSimpleSelector {
-    pub fn as_css_type_selector(&self) -> Option<&CssTypeSelector> {
-        match &self {
-            Self::CssTypeSelector(item) => Some(item),
-            _ => None,
-        }
+    fn syntax(&self) -> &SyntaxNode {
+        &self.syntax
     }
-    pub fn as_css_universal_selector(&self) -> Option<&CssUniversalSelector> {
-        match &self {
-            Self::CssUniversalSelector(item) => Some(item),
-            _ => None,
-        }
+    fn into_syntax(self) -> SyntaxNode {
+        self.syntax
     }
 }
-#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssSubSelector {
-    CssAttributeSelector(CssAttributeSelector),
-    CssBogusSubSelector(CssBogusSubSelector),
-    CssClassSelector(CssClassSelector),
-    CssIdSelector(CssIdSelector),
-    CssPseudoClassSelector(CssPseudoClassSelector),
-    CssPseudoElementSelector(CssPseudoElementSelector),
+impl std::fmt::Debug for CssAttributeMatcher {
+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+        thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
+        let current_depth = DEPTH.get();
+        let result = if current_depth < 16 {
+            DEPTH.set(current_depth + 1);
+            f.debug_struct("CssAttributeMatcher")
+                .field("operator", &support::DebugSyntaxResult(self.operator()))
+                .field("value", &support::DebugSyntaxResult(self.value()))
+                .field("modifier", &support::DebugOptionalElement(self.modifier()))
+                .finish()
+        } else {
+            f.debug_struct("CssAttributeMatcher").finish()
+        };
+        DEPTH.set(current_depth);
+        result
+    }
 }
-impl AnyCssSubSelector {
-    pub fn as_css_attribute_selector(&self) -> Option<&CssAttributeSelector> {
-        match &self {
-            Self::CssAttributeSelector(item) => Some(item),
-            _ => None,
-        }
+impl From<CssAttributeMatcher> for SyntaxNode {
+    fn from(n: CssAttributeMatcher) -> Self {
+        n.syntax
     }
-    pub fn as_css_bogus_sub_selector(&self) -> Option<&CssBogusSubSelector> {
-        match &self {
-            Self::CssBogusSubSelector(item) => Some(item),
-            _ => None,
-        }
+}
+impl From<CssAttributeMatcher> for SyntaxElement {
+    fn from(n: CssAttributeMatcher) -> Self {
+        n.syntax.into()
     }
-    pub fn as_css_class_selector(&self) -> Option<&CssClassSelector> {
-        match &self {
-            Self::CssClassSelector(item) => Some(item),
-            _ => None,
-        }
+}
+impl AstNode for CssAttributeMatcherValue {
+    type Language = Language;
+    const KIND_SET: SyntaxKindSet<Language> =
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_ATTRIBUTE_MATCHER_VALUE as u16));
+    fn can_cast(kind: SyntaxKind) -> bool {
+        kind == CSS_ATTRIBUTE_MATCHER_VALUE
     }
-    pub fn as_css_id_selector(&self) -> Option<&CssIdSelector> {
-        match &self {
-            Self::CssIdSelector(item) => Some(item),
-            _ => None,
+    fn cast(syntax: SyntaxNode) -> Option<Self> {
+        if Self::can_cast(syntax.kind()) {
+            Some(Self { syntax })
+        } else {
+            None
         }
     }
-    pub fn as_css_pseudo_class_selector(&self) -> Option<&CssPseudoClassSelector> {
-        match &self {
-            Self::CssPseudoClassSelector(item) => Some(item),
-            _ => None,
-        }
+    fn syntax(&self) -> &SyntaxNode {
+        &self.syntax
     }
-    pub fn as_css_pseudo_element_selector(&self) -> Option<&CssPseudoElementSelector> {
-        match &self {
-            Self::CssPseudoElementSelector(item) => Some(item),
-            _ => None,
-        }
+    fn into_syntax(self) -> SyntaxNode {
+        self.syntax
     }
 }
-#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssSupportsAndCombinableCondition {
-    AnyCssSupportsInParens(AnyCssSupportsInParens),
-    CssSupportsAndCondition(CssSupportsAndCondition),
-}
-impl AnyCssSupportsAndCombinableCondition {
-    pub fn as_any_css_supports_in_parens(&self) -> Option<&AnyCssSupportsInParens> {
-        match &self {
-            Self::AnyCssSupportsInParens(item) => Some(item),
-            _ => None,
-        }
+impl std::fmt::Debug for CssAttributeMatcherValue {
+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+        thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
+        let current_depth = DEPTH.get();
+        let result = if current_depth < 16 {
+            DEPTH.set(current_depth + 1);
+            f.debug_struct("CssAttributeMatcherValue")
+                .field("name", &support::DebugSyntaxResult(self.name()))
+                .finish()
+        } else {
+            f.debug_struct("CssAttributeMatcherValue").finish()
+        };
+        DEPTH.set(current_depth);
+        result
     }
-    pub fn as_css_supports_and_condition(&self) -> Option<&CssSupportsAndCondition> {
-        match &self {
-            Self::CssSupportsAndCondition(item) => Some(item),
-            _ => None,
-        }
+}
+impl From<CssAttributeMatcherValue> for SyntaxNode {
+    fn from(n: CssAttributeMatcherValue) -> Self {
+        n.syntax
     }
 }
-#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssSupportsCondition {
-    AnyCssSupportsInParens(AnyCssSupportsInParens),
-    CssBogusSupportsCondition(CssBogusSupportsCondition),
-    CssSupportsAndCondition(CssSupportsAndCondition),
-    CssSupportsNotCondition(CssSupportsNotCondition),
-    CssSupportsOrCondition(CssSupportsOrCondition),
+impl From<CssAttributeMatcherValue> for SyntaxElement {
+    fn from(n: CssAttributeMatcherValue) -> Self {
+        n.syntax.into()
+    }
 }
-impl AnyCssSupportsCondition {
-    pub fn as_any_css_supports_in_parens(&self) -> Option<&AnyCssSupportsInParens> {
-        match &self {
-            Self::AnyCssSupportsInParens(item) => Some(item),
-            _ => None,
-        }
+impl AstNode for CssAttributeName {
+    type Language = Language;
+    const KIND_SET: SyntaxKindSet<Language> =
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_ATTRIBUTE_NAME as u16));
+    fn can_cast(kind: SyntaxKind) -> bool {
+        kind == CSS_ATTRIBUTE_NAME
     }
-    pub fn as_css_bogus_supports_condition(&self) -> Option<&CssBogusSupportsCondition> {
-        match &self {
-            Self::CssBogusSupportsCondition(item) => Some(item),
-            _ => None,
+    fn cast(syntax: SyntaxNode) -> Option<Self> {
+        if Self::can_cast(syntax.kind()) {
+            Some(Self { syntax })
+        } else {
+            None
         }
     }
-    pub fn as_css_supports_and_condition(&self) -> Option<&CssSupportsAndCondition> {
-        match &self {
-            Self::CssSupportsAndCondition(item) => Some(item),
-            _ => None,
-        }
+    fn syntax(&self) -> &SyntaxNode {
+        &self.syntax
     }
-    pub fn as_css_supports_not_condition(&self) -> Option<&CssSupportsNotCondition> {
-        match &self {
-            Self::CssSupportsNotCondition(item) => Some(item),
-            _ => None,
-        }
+    fn into_syntax(self) -> SyntaxNode {
+        self.syntax
     }
-    pub fn as_css_supports_or_condition(&self) -> Option<&CssSupportsOrCondition> {
-        match &self {
-            Self::CssSupportsOrCondition(item) => Some(item),
-            _ => None,
-        }
+}
+impl std::fmt::Debug for CssAttributeName {
+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+        thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
+        let current_depth = DEPTH.get();
+        let result = if current_depth < 16 {
+            DEPTH.set(current_depth + 1);
+            f.debug_struct("CssAttributeName")
+                .field(
+                    "namespace",
+                    &support::DebugOptionalElement(self.namespace()),
+                )
+                .field("name", &support::DebugSyntaxResult(self.name()))
+                .finish()
+        } else {
+            f.debug_struct("CssAttributeName").finish()
+        };
+        DEPTH.set(current_depth);
+        result
     }
 }
-#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssSupportsInParens {
-    AnyCssValue(AnyCssValue),
-    CssSupportsConditionInParens(CssSupportsConditionInParens),
-    CssSupportsFeatureDeclaration(CssSupportsFeatureDeclaration),
-    CssSupportsFeatureSelector(CssSupportsFeatureSelector),
+impl From<CssAttributeName> for SyntaxNode {
+    fn from(n: CssAttributeName) -> Self {
+        n.syntax
+    }
 }
-impl AnyCssSupportsInParens {
-    pub fn as_any_css_value(&self) -> Option<&AnyCssValue> {
-        match &self {
-            Self::AnyCssValue(item) => Some(item),
-            _ => None,
-        }
+impl From<CssAttributeName> for SyntaxElement {
+    fn from(n: CssAttributeName) -> Self {
+        n.syntax.into()
     }
-    pub fn as_css_supports_condition_in_parens(&self) -> Option<&CssSupportsConditionInParens> {
-        match &self {
-            Self::CssSupportsConditionInParens(item) => Some(item),
-            _ => None,
-        }
+}
+impl AstNode for CssAttributeSelector {
+    type Language = Language;
+    const KIND_SET: SyntaxKindSet<Language> =
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_ATTRIBUTE_SELECTOR as u16));
+    fn can_cast(kind: SyntaxKind) -> bool {
+        kind == CSS_ATTRIBUTE_SELECTOR
     }
-    pub fn as_css_supports_feature_declaration(&self) -> Option<&CssSupportsFeatureDeclaration> {
-        match &self {
-            Self::CssSupportsFeatureDeclaration(item) => Some(item),
-            _ => None,
+    fn cast(syntax: SyntaxNode) -> Option<Self> {
+        if Self::can_cast(syntax.kind()) {
+            Some(Self { syntax })
+        } else {
+            None
         }
     }
-    pub fn as_css_supports_feature_selector(&self) -> Option<&CssSupportsFeatureSelector> {
-        match &self {
-            Self::CssSupportsFeatureSelector(item) => Some(item),
-            _ => None,
-        }
+    fn syntax(&self) -> &SyntaxNode {
+        &self.syntax
     }
-}
-#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssSupportsOrCombinableCondition {
-    AnyCssSupportsInParens(AnyCssSupportsInParens),
-    CssSupportsOrCondition(CssSupportsOrCondition),
-}
-impl AnyCssSupportsOrCombinableCondition {
-    pub fn as_any_css_supports_in_parens(&self) -> Option<&AnyCssSupportsInParens> {
-        match &self {
-            Self::AnyCssSupportsInParens(item) => Some(item),
-            _ => None,
-        }
+    fn into_syntax(self) -> SyntaxNode {
+        self.syntax
     }
-    pub fn as_css_supports_or_condition(&self) -> Option<&CssSupportsOrCondition> {
-        match &self {
-            Self::CssSupportsOrCondition(item) => Some(item),
-            _ => None,
-        }
+}
+impl std::fmt::Debug for CssAttributeSelector {
+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+        thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
+        let current_depth = DEPTH.get();
+        let result = if current_depth < 16 {
+            DEPTH.set(current_depth + 1);
+            f.debug_struct("CssAttributeSelector")
+                .field(
+                    "l_brack_token",
+                    &support::DebugSyntaxResult(self.l_brack_token()),
+                )
+                .field("name", &support::DebugSyntaxResult(self.name()))
+                .field("matcher", &support::DebugOptionalElement(self.matcher()))
+                .field(
+                    "r_brack_token",
+                    &support::DebugSyntaxResult(self.r_brack_token()),
+                )
+                .finish()
+        } else {
+            f.debug_struct("CssAttributeSelector").finish()
+        };
+        DEPTH.set(current_depth);
+        result
     }
 }
-#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssUnicodeValue {
-    CssBogusUnicodeRangeValue(CssBogusUnicodeRangeValue),
-    CssUnicodeCodepoint(CssUnicodeCodepoint),
-    CssUnicodeRangeInterval(CssUnicodeRangeInterval),
-    CssUnicodeRangeWildcard(CssUnicodeRangeWildcard),
+impl From<CssAttributeSelector> for SyntaxNode {
+    fn from(n: CssAttributeSelector) -> Self {
+        n.syntax
+    }
 }
-impl AnyCssUnicodeValue {
-    pub fn as_css_bogus_unicode_range_value(&self) -> Option<&CssBogusUnicodeRangeValue> {
-        match &self {
-            Self::CssBogusUnicodeRangeValue(item) => Some(item),
-            _ => None,
-        }
+impl From<CssAttributeSelector> for SyntaxElement {
+    fn from(n: CssAttributeSelector) -> Self {
+        n.syntax.into()
     }
-    pub fn as_css_unicode_codepoint(&self) -> Option<&CssUnicodeCodepoint> {
-        match &self {
-            Self::CssUnicodeCodepoint(item) => Some(item),
-            _ => None,
-        }
+}
+impl AstNode for CssBinaryExpression {
+    type Language = Language;
+    const KIND_SET: SyntaxKindSet<Language> =
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_BINARY_EXPRESSION as u16));
+    fn can_cast(kind: SyntaxKind) -> bool {
+        kind == CSS_BINARY_EXPRESSION
     }
-    pub fn as_css_unicode_range_interval(&self) -> Option<&CssUnicodeRangeInterval> {
-        match &self {
-            Self::CssUnicodeRangeInterval(item) => Some(item),
-            _ => None,
+    fn cast(syntax: SyntaxNode) -> Option<Self> {
+        if Self::can_cast(syntax.kind()) {
+            Some(Self { syntax })
+        } else {
+            None
         }
     }
-    pub fn as_css_unicode_range_wildcard(&self) -> Option<&CssUnicodeRangeWildcard> {
-        match &self {
-            Self::CssUnicodeRangeWildcard(item) => Some(item),
-            _ => None,
-        }
+    fn syntax(&self) -> &SyntaxNode {
+        &self.syntax
+    }
+    fn into_syntax(self) -> SyntaxNode {
+        self.syntax
     }
 }
-#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssUrlModifier {
-    CssBogusUrlModifier(CssBogusUrlModifier),
-    CssFunction(CssFunction),
-    CssIdentifier(CssIdentifier),
+impl std::fmt::Debug for CssBinaryExpression {
+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+        thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
+        let current_depth = DEPTH.get();
+        let result = if current_depth < 16 {
+            DEPTH.set(current_depth + 1);
+            f.debug_struct("CssBinaryExpression")
+                .field("left", &support::DebugSyntaxResult(self.left()))
+                .field(
+                    "operator_token",
+                    &support::DebugSyntaxResult(self.operator_token()),
+                )
+                .field("right", &support::DebugSyntaxResult(self.right()))
+                .finish()
+        } else {
+            f.debug_struct("CssBinaryExpression").finish()
+        };
+        DEPTH.set(current_depth);
+        result
+    }
 }
-impl AnyCssUrlModifier {
-    pub fn as_css_bogus_url_modifier(&self) -> Option<&CssBogusUrlModifier> {
-        match &self {
-            Self::CssBogusUrlModifier(item) => Some(item),
-            _ => None,
-        }
+impl From<CssBinaryExpression> for SyntaxNode {
+    fn from(n: CssBinaryExpression) -> Self {
+        n.syntax
     }
-    pub fn as_css_function(&self) -> Option<&CssFunction> {
-        match &self {
-            Self::CssFunction(item) => Some(item),
-            _ => None,
-        }
+}
+impl From<CssBinaryExpression> for SyntaxElement {
+    fn from(n: CssBinaryExpression) -> Self {
+        n.syntax.into()
     }
-    pub fn as_css_identifier(&self) -> Option<&CssIdentifier> {
-        match &self {
-            Self::CssIdentifier(item) => Some(item),
-            _ => None,
+}
+impl AstNode for CssBracketedValue {
+    type Language = Language;
+    const KIND_SET: SyntaxKindSet<Language> =
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_BRACKETED_VALUE as u16));
+    fn can_cast(kind: SyntaxKind) -> bool {
+        kind == CSS_BRACKETED_VALUE
+    }
+    fn cast(syntax: SyntaxNode) -> Option<Self> {
+        if Self::can_cast(syntax.kind()) {
+            Some(Self { syntax })
+        } else {
+            None
         }
     }
+    fn syntax(&self) -> &SyntaxNode {
+        &self.syntax
+    }
+    fn into_syntax(self) -> SyntaxNode {
+        self.syntax
+    }
 }
-#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssUrlValue {
-    CssString(CssString),
-    CssUrlValueRaw(CssUrlValueRaw),
-}
-impl AnyCssUrlValue {
-    pub fn as_css_string(&self) -> Option<&CssString> {
-        match &self {
-            Self::CssString(item) => Some(item),
-            _ => None,
-        }
+impl std::fmt::Debug for CssBracketedValue {
+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+        thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
+        let current_depth = DEPTH.get();
+        let result = if current_depth < 16 {
+            DEPTH.set(current_depth + 1);
+            f.debug_struct("CssBracketedValue")
+                .field(
+                    "l_brack_token",
+                    &support::DebugSyntaxResult(self.l_brack_token()),
+                )
+                .field("items", &self.items())
+                .field(
+                    "r_brack_token",
+                    &support::DebugSyntaxResult(self.r_brack_token()),
+                )
+                .finish()
+        } else {
+            f.debug_struct("CssBracketedValue").finish()
+        };
+        DEPTH.set(current_depth);
+        result
     }
-    pub fn as_css_url_value_raw(&self) -> Option<&CssUrlValueRaw> {
-        match &self {
-            Self::CssUrlValueRaw(item) => Some(item),
-            _ => None,
-        }
+}
+impl From<CssBracketedValue> for SyntaxNode {
+    fn from(n: CssBracketedValue) -> Self {
+        n.syntax
     }
 }
-#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssValue {
-    AnyCssDimension(AnyCssDimension),
-    AnyCssFunction(AnyCssFunction),
-    CssBracketedValue(CssBracketedValue),
-    CssColor(CssColor),
-    CssCustomIdentifier(CssCustomIdentifier),
-    CssDashedIdentifier(CssDashedIdentifier),
-    CssIdentifier(CssIdentifier),
-    CssMetavariable(CssMetavariable),
-    CssNumber(CssNumber),
-    CssRatio(CssRatio),
-    CssString(CssString),
-    CssUnicodeRange(CssUnicodeRange),
-    TwValueThemeReference(TwValueThemeReference),
+impl From<CssBracketedValue> for SyntaxElement {
+    fn from(n: CssBracketedValue) -> Self {
+        n.syntax.into()
+    }
 }
-impl AnyCssValue {
-    pub fn as_any_css_dimension(&self) -> Option<&AnyCssDimension> {
-        match &self {
-            Self::AnyCssDimension(item) => Some(item),
-            _ => None,
-        }
+impl AstNode for CssCharsetAtRule {
+    type Language = Language;
+    const KIND_SET: SyntaxKindSet<Language> =
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_CHARSET_AT_RULE as u16));
+    fn can_cast(kind: SyntaxKind) -> bool {
+        kind == CSS_CHARSET_AT_RULE
     }
-    pub fn as_any_css_function(&self) -> Option<&AnyCssFunction> {
-        match &self {
-            Self::AnyCssFunction(item) => Some(item),
-            _ => None,
+    fn cast(syntax: SyntaxNode) -> Option<Self> {
+        if Self::can_cast(syntax.kind()) {
+            Some(Self { syntax })
+        } else {
+            None
         }
     }
-    pub fn as_css_bracketed_value(&self) -> Option<&CssBracketedValue> {
-        match &self {
-            Self::CssBracketedValue(item) => Some(item),
-            _ => None,
-        }
+    fn syntax(&self) -> &SyntaxNode {
+        &self.syntax
     }
-    pub fn as_css_color(&self) -> Option<&CssColor> {
-        match &self {
-            Self::CssColor(item) => Some(item),
-            _ => None,
-        }
+    fn into_syntax(self) -> SyntaxNode {
+        self.syntax
     }
-    pub fn as_css_custom_identifier(&self) -> Option<&CssCustomIdentifier> {
-        match &self {
-            Self::CssCustomIdentifier(item) => Some(item),
-            _ => None,
-        }
+}
+impl std::fmt::Debug for CssCharsetAtRule {
+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+        thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
+        let current_depth = DEPTH.get();
+        let result = if current_depth < 16 {
+            DEPTH.set(current_depth + 1);
+            f.debug_struct("CssCharsetAtRule")
+                .field(
+                    "charset_token",
+                    &support::DebugSyntaxResult(self.charset_token()),
+                )
+                .field("encoding", &support::DebugSyntaxResult(self.encoding()))
+                .field(
+                    "semicolon_token",
+                    &support::DebugSyntaxResult(self.semicolon_token()),
+                )
+                .finish()
+        } else {
+            f.debug_struct("CssCharsetAtRule").finish()
+        };
+        DEPTH.set(current_depth);
+        result
     }
-    pub fn as_css_dashed_identifier(&self) -> Option<&CssDashedIdentifier> {
-        match &self {
-            Self::CssDashedIdentifier(item) => Some(item),
-            _ => None,
-        }
+}
+impl From<CssCharsetAtRule> for SyntaxNode {
+    fn from(n: CssCharsetAtRule) -> Self {
+        n.syntax
     }
-    pub fn as_css_identifier(&self) -> Option<&CssIdentifier> {
-        match &self {
-            Self::CssIdentifier(item) => Some(item),
-            _ => None,
-        }
+}
+impl From<CssCharsetAtRule> for SyntaxElement {
+    fn from(n: CssCharsetAtRule) -> Self {
+        n.syntax.into()
     }
-    pub fn as_css_metavariable(&self) -> Option<&CssMetavariable> {
-        match &self {
-            Self::CssMetavariable(item) => Some(item),
-            _ => None,
+}
+impl AstNode for CssClassSelector {
+    type Language = Language;
+    const KIND_SET: SyntaxKindSet<Language> =
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_CLASS_SELECTOR as u16));
+    fn can_cast(kind: SyntaxKind) -> bool {
+        kind == CSS_CLASS_SELECTOR
+    }
+    fn cast(syntax: SyntaxNode) -> Option<Self> {
+        if Self::can_cast(syntax.kind()) {
+            Some(Self { syntax })
+        } else {
+            None
         }
     }
-    pub fn as_css_number(&self) -> Option<&CssNumber> {
-        match &self {
-            Self::CssNumber(item) => Some(item),
-            _ => None,
-        }
-    }
-    pub fn as_css_ratio(&self) -> Option<&CssRatio> {
-        match &self {
-            Self::CssRatio(item) => Some(item),
-            _ => None,
-        }
-    }
-    pub fn as_css_string(&self) -> Option<&CssString> {
-        match &self {
-            Self::CssString(item) => Some(item),
-            _ => None,
-        }
-    }
-    pub fn as_css_unicode_range(&self) -> Option<&CssUnicodeRange> {
-        match &self {
-            Self::CssUnicodeRange(item) => Some(item),
-            _ => None,
-        }
-    }
-    pub fn as_tw_value_theme_reference(&self) -> Option<&TwValueThemeReference> {
-        match &self {
-            Self::TwValueThemeReference(item) => Some(item),
-            _ => None,
-        }
-    }
-}
-#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssValueAtRuleClause {
-    CssValueAtRuleDeclarationClause(CssValueAtRuleDeclarationClause),
-    CssValueAtRuleImportClause(CssValueAtRuleImportClause),
-}
-impl AnyCssValueAtRuleClause {
-    pub fn as_css_value_at_rule_declaration_clause(
-        &self,
-    ) -> Option<&CssValueAtRuleDeclarationClause> {
-        match &self {
-            Self::CssValueAtRuleDeclarationClause(item) => Some(item),
-            _ => None,
-        }
-    }
-    pub fn as_css_value_at_rule_import_clause(&self) -> Option<&CssValueAtRuleImportClause> {
-        match &self {
-            Self::CssValueAtRuleImportClause(item) => Some(item),
-            _ => None,
-        }
-    }
-}
-#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssValueAtRuleImportSource {
-    CssIdentifier(CssIdentifier),
-    CssString(CssString),
-}
-impl AnyCssValueAtRuleImportSource {
-    pub fn as_css_identifier(&self) -> Option<&CssIdentifier> {
-        match &self {
-            Self::CssIdentifier(item) => Some(item),
-            _ => None,
-        }
-    }
-    pub fn as_css_string(&self) -> Option<&CssString> {
-        match &self {
-            Self::CssString(item) => Some(item),
-            _ => None,
-        }
-    }
-}
-#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssValueAtRuleImportSpecifier {
-    CssValueAtRuleImportSpecifier(CssValueAtRuleImportSpecifier),
-    CssValueAtRuleNamedImportSpecifier(CssValueAtRuleNamedImportSpecifier),
-}
-impl AnyCssValueAtRuleImportSpecifier {
-    pub fn as_css_value_at_rule_import_specifier(&self) -> Option<&CssValueAtRuleImportSpecifier> {
-        match &self {
-            Self::CssValueAtRuleImportSpecifier(item) => Some(item),
-            _ => None,
-        }
-    }
-    pub fn as_css_value_at_rule_named_import_specifier(
-        &self,
-    ) -> Option<&CssValueAtRuleNamedImportSpecifier> {
-        match &self {
-            Self::CssValueAtRuleNamedImportSpecifier(item) => Some(item),
-            _ => None,
-        }
-    }
-}
-#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyCssValueAtRuleProperty {
-    CssBogusProperty(CssBogusProperty),
-    CssValueAtRuleGenericProperty(CssValueAtRuleGenericProperty),
-}
-impl AnyCssValueAtRuleProperty {
-    pub fn as_css_bogus_property(&self) -> Option<&CssBogusProperty> {
-        match &self {
-            Self::CssBogusProperty(item) => Some(item),
-            _ => None,
-        }
-    }
-    pub fn as_css_value_at_rule_generic_property(&self) -> Option<&CssValueAtRuleGenericProperty> {
-        match &self {
-            Self::CssValueAtRuleGenericProperty(item) => Some(item),
-            _ => None,
-        }
-    }
-}
-#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyTwCustomVariantSelector {
-    AnyCssRuleBlock(AnyCssRuleBlock),
-    TwCustomVariantShorthand(TwCustomVariantShorthand),
-}
-impl AnyTwCustomVariantSelector {
-    pub fn as_any_css_rule_block(&self) -> Option<&AnyCssRuleBlock> {
-        match &self {
-            Self::AnyCssRuleBlock(item) => Some(item),
-            _ => None,
-        }
+    fn syntax(&self) -> &SyntaxNode {
+        &self.syntax
     }
-    pub fn as_tw_custom_variant_shorthand(&self) -> Option<&TwCustomVariantShorthand> {
-        match &self {
-            Self::TwCustomVariantShorthand(item) => Some(item),
-            _ => None,
-        }
+    fn into_syntax(self) -> SyntaxNode {
+        self.syntax
     }
 }
-#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyTwCustomVariantShorthand {
-    CssAtRuleDeclarator(CssAtRuleDeclarator),
-    CssSelectorList(CssSelectorList),
-}
-impl AnyTwCustomVariantShorthand {
-    pub fn as_css_at_rule_declarator(&self) -> Option<&CssAtRuleDeclarator> {
-        match &self {
-            Self::CssAtRuleDeclarator(item) => Some(item),
-            _ => None,
-        }
-    }
-    pub fn as_css_selector_list(&self) -> Option<&CssSelectorList> {
-        match &self {
-            Self::CssSelectorList(item) => Some(item),
-            _ => None,
-        }
+impl std::fmt::Debug for CssClassSelector {
+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+        thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
+        let current_depth = DEPTH.get();
+        let result = if current_depth < 16 {
+            DEPTH.set(current_depth + 1);
+            f.debug_struct("CssClassSelector")
+                .field("dot_token", &support::DebugSyntaxResult(self.dot_token()))
+                .field("name", &support::DebugSyntaxResult(self.name()))
+                .finish()
+        } else {
+            f.debug_struct("CssClassSelector").finish()
+        };
+        DEPTH.set(current_depth);
+        result
     }
 }
-#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyTwSource {
-    CssString(CssString),
-    TwSourceInline(TwSourceInline),
-}
-impl AnyTwSource {
-    pub fn as_css_string(&self) -> Option<&CssString> {
-        match &self {
-            Self::CssString(item) => Some(item),
-            _ => None,
-        }
-    }
-    pub fn as_tw_source_inline(&self) -> Option<&TwSourceInline> {
-        match &self {
-            Self::TwSourceInline(item) => Some(item),
-            _ => None,
-        }
+impl From<CssClassSelector> for SyntaxNode {
+    fn from(n: CssClassSelector) -> Self {
+        n.syntax
     }
 }
-#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub enum AnyTwUtilityName {
-    CssIdentifier(CssIdentifier),
-    TwFunctionalUtilityName(TwFunctionalUtilityName),
-}
-impl AnyTwUtilityName {
-    pub fn as_css_identifier(&self) -> Option<&CssIdentifier> {
-        match &self {
-            Self::CssIdentifier(item) => Some(item),
-            _ => None,
-        }
-    }
-    pub fn as_tw_functional_utility_name(&self) -> Option<&TwFunctionalUtilityName> {
-        match &self {
-            Self::TwFunctionalUtilityName(item) => Some(item),
-            _ => None,
-        }
+impl From<CssClassSelector> for SyntaxElement {
+    fn from(n: CssClassSelector) -> Self {
+        n.syntax.into()
     }
 }
-impl AstNode for CssAtRule {
+impl AstNode for CssColor {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_AT_RULE as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_COLOR as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_AT_RULE
+        kind == CSS_COLOR
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -11175,39 +10981,42 @@ impl AstNode for CssAtRule {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssAtRule {
+impl std::fmt::Debug for CssColor {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssAtRule")
-                .field("at_token", &support::DebugSyntaxResult(self.at_token()))
-                .field("rule", &support::DebugSyntaxResult(self.rule()))
+            f.debug_struct("CssColor")
+                .field("hash_token", &support::DebugSyntaxResult(self.hash_token()))
+                .field(
+                    "value_token",
+                    &support::DebugSyntaxResult(self.value_token()),
+                )
                 .finish()
         } else {
-            f.debug_struct("CssAtRule").finish()
+            f.debug_struct("CssColor").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssAtRule> for SyntaxNode {
-    fn from(n: CssAtRule) -> Self {
+impl From<CssColor> for SyntaxNode {
+    fn from(n: CssColor) -> Self {
         n.syntax
     }
 }
-impl From<CssAtRule> for SyntaxElement {
-    fn from(n: CssAtRule) -> Self {
+impl From<CssColor> for SyntaxElement {
+    fn from(n: CssColor) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssAtRuleDeclarator {
+impl AstNode for CssColorProfileAtRule {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_AT_RULE_DECLARATOR as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_COLOR_PROFILE_AT_RULE as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_AT_RULE_DECLARATOR
+        kind == CSS_COLOR_PROFILE_AT_RULE
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -11223,39 +11032,39 @@ impl AstNode for CssAtRuleDeclarator {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssAtRuleDeclarator {
+impl std::fmt::Debug for CssColorProfileAtRule {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssAtRuleDeclarator")
-                .field("at_token", &support::DebugSyntaxResult(self.at_token()))
+            f.debug_struct("CssColorProfileAtRule")
                 .field("declarator", &support::DebugSyntaxResult(self.declarator()))
+                .field("block", &support::DebugSyntaxResult(self.block()))
                 .finish()
         } else {
-            f.debug_struct("CssAtRuleDeclarator").finish()
+            f.debug_struct("CssColorProfileAtRule").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssAtRuleDeclarator> for SyntaxNode {
-    fn from(n: CssAtRuleDeclarator) -> Self {
+impl From<CssColorProfileAtRule> for SyntaxNode {
+    fn from(n: CssColorProfileAtRule) -> Self {
         n.syntax
     }
 }
-impl From<CssAtRuleDeclarator> for SyntaxElement {
-    fn from(n: CssAtRuleDeclarator) -> Self {
+impl From<CssColorProfileAtRule> for SyntaxElement {
+    fn from(n: CssColorProfileAtRule) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssAttributeMatcher {
+impl AstNode for CssColorProfileAtRuleDeclarator {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_ATTRIBUTE_MATCHER as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_COLOR_PROFILE_AT_RULE_DECLARATOR as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_ATTRIBUTE_MATCHER
+        kind == CSS_COLOR_PROFILE_AT_RULE_DECLARATOR
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -11271,40 +11080,42 @@ impl AstNode for CssAttributeMatcher {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssAttributeMatcher {
+impl std::fmt::Debug for CssColorProfileAtRuleDeclarator {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssAttributeMatcher")
-                .field("operator", &support::DebugSyntaxResult(self.operator()))
-                .field("value", &support::DebugSyntaxResult(self.value()))
-                .field("modifier", &support::DebugOptionalElement(self.modifier()))
+            f.debug_struct("CssColorProfileAtRuleDeclarator")
+                .field(
+                    "color_profile_token",
+                    &support::DebugSyntaxResult(self.color_profile_token()),
+                )
+                .field("name", &support::DebugSyntaxResult(self.name()))
                 .finish()
         } else {
-            f.debug_struct("CssAttributeMatcher").finish()
+            f.debug_struct("CssColorProfileAtRuleDeclarator").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssAttributeMatcher> for SyntaxNode {
-    fn from(n: CssAttributeMatcher) -> Self {
+impl From<CssColorProfileAtRuleDeclarator> for SyntaxNode {
+    fn from(n: CssColorProfileAtRuleDeclarator) -> Self {
         n.syntax
     }
 }
-impl From<CssAttributeMatcher> for SyntaxElement {
-    fn from(n: CssAttributeMatcher) -> Self {
+impl From<CssColorProfileAtRuleDeclarator> for SyntaxElement {
+    fn from(n: CssColorProfileAtRuleDeclarator) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssAttributeMatcherValue {
+impl AstNode for CssComplexSelector {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_ATTRIBUTE_MATCHER_VALUE as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_COMPLEX_SELECTOR as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_ATTRIBUTE_MATCHER_VALUE
+        kind == CSS_COMPLEX_SELECTOR
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -11320,38 +11131,40 @@ impl AstNode for CssAttributeMatcherValue {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssAttributeMatcherValue {
+impl std::fmt::Debug for CssComplexSelector {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssAttributeMatcherValue")
-                .field("name", &support::DebugSyntaxResult(self.name()))
+            f.debug_struct("CssComplexSelector")
+                .field("left", &support::DebugSyntaxResult(self.left()))
+                .field("combinator", &support::DebugSyntaxResult(self.combinator()))
+                .field("right", &support::DebugSyntaxResult(self.right()))
                 .finish()
         } else {
-            f.debug_struct("CssAttributeMatcherValue").finish()
+            f.debug_struct("CssComplexSelector").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssAttributeMatcherValue> for SyntaxNode {
-    fn from(n: CssAttributeMatcherValue) -> Self {
+impl From<CssComplexSelector> for SyntaxNode {
+    fn from(n: CssComplexSelector) -> Self {
         n.syntax
     }
 }
-impl From<CssAttributeMatcherValue> for SyntaxElement {
-    fn from(n: CssAttributeMatcherValue) -> Self {
+impl From<CssComplexSelector> for SyntaxElement {
+    fn from(n: CssComplexSelector) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssAttributeName {
+impl AstNode for CssComposesImportSpecifier {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_ATTRIBUTE_NAME as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_COMPOSES_IMPORT_SPECIFIER as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_ATTRIBUTE_NAME
+        kind == CSS_COMPOSES_IMPORT_SPECIFIER
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -11367,42 +11180,39 @@ impl AstNode for CssAttributeName {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssAttributeName {
+impl std::fmt::Debug for CssComposesImportSpecifier {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssAttributeName")
-                .field(
-                    "namespace",
-                    &support::DebugOptionalElement(self.namespace()),
-                )
-                .field("name", &support::DebugSyntaxResult(self.name()))
+            f.debug_struct("CssComposesImportSpecifier")
+                .field("from_token", &support::DebugSyntaxResult(self.from_token()))
+                .field("source", &support::DebugSyntaxResult(self.source()))
                 .finish()
         } else {
-            f.debug_struct("CssAttributeName").finish()
+            f.debug_struct("CssComposesImportSpecifier").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssAttributeName> for SyntaxNode {
-    fn from(n: CssAttributeName) -> Self {
+impl From<CssComposesImportSpecifier> for SyntaxNode {
+    fn from(n: CssComposesImportSpecifier) -> Self {
         n.syntax
     }
 }
-impl From<CssAttributeName> for SyntaxElement {
-    fn from(n: CssAttributeName) -> Self {
+impl From<CssComposesImportSpecifier> for SyntaxElement {
+    fn from(n: CssComposesImportSpecifier) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssAttributeSelector {
+impl AstNode for CssComposesProperty {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_ATTRIBUTE_SELECTOR as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_COMPOSES_PROPERTY as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_ATTRIBUTE_SELECTOR
+        kind == CSS_COMPOSES_PROPERTY
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -11418,47 +11228,43 @@ impl AstNode for CssAttributeSelector {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssAttributeSelector {
+impl std::fmt::Debug for CssComposesProperty {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssAttributeSelector")
-                .field(
-                    "l_brack_token",
-                    &support::DebugSyntaxResult(self.l_brack_token()),
-                )
+            f.debug_struct("CssComposesProperty")
                 .field("name", &support::DebugSyntaxResult(self.name()))
-                .field("matcher", &support::DebugOptionalElement(self.matcher()))
                 .field(
-                    "r_brack_token",
-                    &support::DebugSyntaxResult(self.r_brack_token()),
+                    "colon_token",
+                    &support::DebugSyntaxResult(self.colon_token()),
                 )
+                .field("value", &support::DebugSyntaxResult(self.value()))
                 .finish()
         } else {
-            f.debug_struct("CssAttributeSelector").finish()
+            f.debug_struct("CssComposesProperty").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssAttributeSelector> for SyntaxNode {
-    fn from(n: CssAttributeSelector) -> Self {
+impl From<CssComposesProperty> for SyntaxNode {
+    fn from(n: CssComposesProperty) -> Self {
         n.syntax
     }
 }
-impl From<CssAttributeSelector> for SyntaxElement {
-    fn from(n: CssAttributeSelector) -> Self {
+impl From<CssComposesProperty> for SyntaxElement {
+    fn from(n: CssComposesProperty) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssBinaryExpression {
+impl AstNode for CssComposesPropertyValue {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_BINARY_EXPRESSION as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_COMPOSES_PROPERTY_VALUE as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_BINARY_EXPRESSION
+        kind == CSS_COMPOSES_PROPERTY_VALUE
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -11474,43 +11280,42 @@ impl AstNode for CssBinaryExpression {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssBinaryExpression {
+impl std::fmt::Debug for CssComposesPropertyValue {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssBinaryExpression")
-                .field("left", &support::DebugSyntaxResult(self.left()))
+            f.debug_struct("CssComposesPropertyValue")
+                .field("classes", &self.classes())
                 .field(
-                    "operator_token",
-                    &support::DebugSyntaxResult(self.operator_token()),
+                    "specifier",
+                    &support::DebugOptionalElement(self.specifier()),
                 )
-                .field("right", &support::DebugSyntaxResult(self.right()))
                 .finish()
         } else {
-            f.debug_struct("CssBinaryExpression").finish()
+            f.debug_struct("CssComposesPropertyValue").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssBinaryExpression> for SyntaxNode {
-    fn from(n: CssBinaryExpression) -> Self {
+impl From<CssComposesPropertyValue> for SyntaxNode {
+    fn from(n: CssComposesPropertyValue) -> Self {
         n.syntax
     }
 }
-impl From<CssBinaryExpression> for SyntaxElement {
-    fn from(n: CssBinaryExpression) -> Self {
+impl From<CssComposesPropertyValue> for SyntaxElement {
+    fn from(n: CssComposesPropertyValue) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssBracketedValue {
+impl AstNode for CssCompoundSelector {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_BRACKETED_VALUE as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_COMPOUND_SELECTOR as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_BRACKETED_VALUE
+        kind == CSS_COMPOUND_SELECTOR
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -11526,46 +11331,43 @@ impl AstNode for CssBracketedValue {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssBracketedValue {
+impl std::fmt::Debug for CssCompoundSelector {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssBracketedValue")
-                .field(
-                    "l_brack_token",
-                    &support::DebugSyntaxResult(self.l_brack_token()),
-                )
-                .field("items", &self.items())
+            f.debug_struct("CssCompoundSelector")
+                .field("nesting_selectors", &self.nesting_selectors())
                 .field(
-                    "r_brack_token",
-                    &support::DebugSyntaxResult(self.r_brack_token()),
+                    "simple_selector",
+                    &support::DebugOptionalElement(self.simple_selector()),
                 )
+                .field("sub_selectors", &self.sub_selectors())
                 .finish()
         } else {
-            f.debug_struct("CssBracketedValue").finish()
+            f.debug_struct("CssCompoundSelector").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssBracketedValue> for SyntaxNode {
-    fn from(n: CssBracketedValue) -> Self {
+impl From<CssCompoundSelector> for SyntaxNode {
+    fn from(n: CssCompoundSelector) -> Self {
         n.syntax
     }
 }
-impl From<CssBracketedValue> for SyntaxElement {
-    fn from(n: CssBracketedValue) -> Self {
+impl From<CssCompoundSelector> for SyntaxElement {
+    fn from(n: CssCompoundSelector) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssCharsetAtRule {
+impl AstNode for CssContainerAndQuery {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_CHARSET_AT_RULE as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_CONTAINER_AND_QUERY as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_CHARSET_AT_RULE
+        kind == CSS_CONTAINER_AND_QUERY
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -11581,46 +11383,40 @@ impl AstNode for CssCharsetAtRule {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssCharsetAtRule {
+impl std::fmt::Debug for CssContainerAndQuery {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssCharsetAtRule")
-                .field(
-                    "charset_token",
-                    &support::DebugSyntaxResult(self.charset_token()),
-                )
-                .field("encoding", &support::DebugSyntaxResult(self.encoding()))
-                .field(
-                    "semicolon_token",
-                    &support::DebugSyntaxResult(self.semicolon_token()),
-                )
+            f.debug_struct("CssContainerAndQuery")
+                .field("left", &support::DebugSyntaxResult(self.left()))
+                .field("and_token", &support::DebugSyntaxResult(self.and_token()))
+                .field("right", &support::DebugSyntaxResult(self.right()))
                 .finish()
         } else {
-            f.debug_struct("CssCharsetAtRule").finish()
+            f.debug_struct("CssContainerAndQuery").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssCharsetAtRule> for SyntaxNode {
-    fn from(n: CssCharsetAtRule) -> Self {
+impl From<CssContainerAndQuery> for SyntaxNode {
+    fn from(n: CssContainerAndQuery) -> Self {
         n.syntax
     }
 }
-impl From<CssCharsetAtRule> for SyntaxElement {
-    fn from(n: CssCharsetAtRule) -> Self {
+impl From<CssContainerAndQuery> for SyntaxElement {
+    fn from(n: CssContainerAndQuery) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssClassSelector {
+impl AstNode for CssContainerAtRule {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_CLASS_SELECTOR as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_CONTAINER_AT_RULE as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_CLASS_SELECTOR
+        kind == CSS_CONTAINER_AT_RULE
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -11636,39 +11432,39 @@ impl AstNode for CssClassSelector {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssClassSelector {
+impl std::fmt::Debug for CssContainerAtRule {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssClassSelector")
-                .field("dot_token", &support::DebugSyntaxResult(self.dot_token()))
-                .field("name", &support::DebugSyntaxResult(self.name()))
+            f.debug_struct("CssContainerAtRule")
+                .field("declarator", &support::DebugSyntaxResult(self.declarator()))
+                .field("block", &support::DebugSyntaxResult(self.block()))
                 .finish()
         } else {
-            f.debug_struct("CssClassSelector").finish()
+            f.debug_struct("CssContainerAtRule").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssClassSelector> for SyntaxNode {
-    fn from(n: CssClassSelector) -> Self {
+impl From<CssContainerAtRule> for SyntaxNode {
+    fn from(n: CssContainerAtRule) -> Self {
         n.syntax
     }
 }
-impl From<CssClassSelector> for SyntaxElement {
-    fn from(n: CssClassSelector) -> Self {
+impl From<CssContainerAtRule> for SyntaxElement {
+    fn from(n: CssContainerAtRule) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssColor {
+impl AstNode for CssContainerAtRuleDeclarator {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_COLOR as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_CONTAINER_AT_RULE_DECLARATOR as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_COLOR
+        kind == CSS_CONTAINER_AT_RULE_DECLARATOR
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -11684,42 +11480,43 @@ impl AstNode for CssColor {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssColor {
+impl std::fmt::Debug for CssContainerAtRuleDeclarator {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssColor")
-                .field("hash_token", &support::DebugSyntaxResult(self.hash_token()))
+            f.debug_struct("CssContainerAtRuleDeclarator")
                 .field(
-                    "value_token",
-                    &support::DebugSyntaxResult(self.value_token()),
+                    "container_token",
+                    &support::DebugSyntaxResult(self.container_token()),
                 )
+                .field("name", &support::DebugOptionalElement(self.name()))
+                .field("query", &support::DebugSyntaxResult(self.query()))
                 .finish()
         } else {
-            f.debug_struct("CssColor").finish()
+            f.debug_struct("CssContainerAtRuleDeclarator").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssColor> for SyntaxNode {
-    fn from(n: CssColor) -> Self {
+impl From<CssContainerAtRuleDeclarator> for SyntaxNode {
+    fn from(n: CssContainerAtRuleDeclarator) -> Self {
         n.syntax
     }
 }
-impl From<CssColor> for SyntaxElement {
-    fn from(n: CssColor) -> Self {
+impl From<CssContainerAtRuleDeclarator> for SyntaxElement {
+    fn from(n: CssContainerAtRuleDeclarator) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssColorProfileAtRule {
+impl AstNode for CssContainerNotQuery {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_COLOR_PROFILE_AT_RULE as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_CONTAINER_NOT_QUERY as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_COLOR_PROFILE_AT_RULE
+        kind == CSS_CONTAINER_NOT_QUERY
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -11735,39 +11532,39 @@ impl AstNode for CssColorProfileAtRule {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssColorProfileAtRule {
+impl std::fmt::Debug for CssContainerNotQuery {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssColorProfileAtRule")
-                .field("declarator", &support::DebugSyntaxResult(self.declarator()))
-                .field("block", &support::DebugSyntaxResult(self.block()))
+            f.debug_struct("CssContainerNotQuery")
+                .field("not_token", &support::DebugSyntaxResult(self.not_token()))
+                .field("query", &support::DebugSyntaxResult(self.query()))
                 .finish()
         } else {
-            f.debug_struct("CssColorProfileAtRule").finish()
+            f.debug_struct("CssContainerNotQuery").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssColorProfileAtRule> for SyntaxNode {
-    fn from(n: CssColorProfileAtRule) -> Self {
+impl From<CssContainerNotQuery> for SyntaxNode {
+    fn from(n: CssContainerNotQuery) -> Self {
         n.syntax
     }
 }
-impl From<CssColorProfileAtRule> for SyntaxElement {
-    fn from(n: CssColorProfileAtRule) -> Self {
+impl From<CssContainerNotQuery> for SyntaxElement {
+    fn from(n: CssContainerNotQuery) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssColorProfileAtRuleDeclarator {
+impl AstNode for CssContainerOrQuery {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_COLOR_PROFILE_AT_RULE_DECLARATOR as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_CONTAINER_OR_QUERY as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_COLOR_PROFILE_AT_RULE_DECLARATOR
+        kind == CSS_CONTAINER_OR_QUERY
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -11783,42 +11580,40 @@ impl AstNode for CssColorProfileAtRuleDeclarator {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssColorProfileAtRuleDeclarator {
+impl std::fmt::Debug for CssContainerOrQuery {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssColorProfileAtRuleDeclarator")
-                .field(
-                    "color_profile_token",
-                    &support::DebugSyntaxResult(self.color_profile_token()),
-                )
-                .field("name", &support::DebugSyntaxResult(self.name()))
+            f.debug_struct("CssContainerOrQuery")
+                .field("left", &support::DebugSyntaxResult(self.left()))
+                .field("or_token", &support::DebugSyntaxResult(self.or_token()))
+                .field("right", &support::DebugSyntaxResult(self.right()))
                 .finish()
         } else {
-            f.debug_struct("CssColorProfileAtRuleDeclarator").finish()
+            f.debug_struct("CssContainerOrQuery").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssColorProfileAtRuleDeclarator> for SyntaxNode {
-    fn from(n: CssColorProfileAtRuleDeclarator) -> Self {
+impl From<CssContainerOrQuery> for SyntaxNode {
+    fn from(n: CssContainerOrQuery) -> Self {
         n.syntax
     }
 }
-impl From<CssColorProfileAtRuleDeclarator> for SyntaxElement {
-    fn from(n: CssColorProfileAtRuleDeclarator) -> Self {
+impl From<CssContainerOrQuery> for SyntaxElement {
+    fn from(n: CssContainerOrQuery) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssComplexSelector {
+impl AstNode for CssContainerQueryInParens {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_COMPLEX_SELECTOR as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_CONTAINER_QUERY_IN_PARENS as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_COMPLEX_SELECTOR
+        kind == CSS_CONTAINER_QUERY_IN_PARENS
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -11834,40 +11629,46 @@ impl AstNode for CssComplexSelector {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssComplexSelector {
+impl std::fmt::Debug for CssContainerQueryInParens {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssComplexSelector")
-                .field("left", &support::DebugSyntaxResult(self.left()))
-                .field("combinator", &support::DebugSyntaxResult(self.combinator()))
-                .field("right", &support::DebugSyntaxResult(self.right()))
+            f.debug_struct("CssContainerQueryInParens")
+                .field(
+                    "l_paren_token",
+                    &support::DebugSyntaxResult(self.l_paren_token()),
+                )
+                .field("query", &support::DebugSyntaxResult(self.query()))
+                .field(
+                    "r_paren_token",
+                    &support::DebugSyntaxResult(self.r_paren_token()),
+                )
                 .finish()
         } else {
-            f.debug_struct("CssComplexSelector").finish()
+            f.debug_struct("CssContainerQueryInParens").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssComplexSelector> for SyntaxNode {
-    fn from(n: CssComplexSelector) -> Self {
+impl From<CssContainerQueryInParens> for SyntaxNode {
+    fn from(n: CssContainerQueryInParens) -> Self {
         n.syntax
     }
 }
-impl From<CssComplexSelector> for SyntaxElement {
-    fn from(n: CssComplexSelector) -> Self {
+impl From<CssContainerQueryInParens> for SyntaxElement {
+    fn from(n: CssContainerQueryInParens) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssComposesImportSpecifier {
+impl AstNode for CssContainerSizeFeatureInParens {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_COMPOSES_IMPORT_SPECIFIER as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_CONTAINER_SIZE_FEATURE_IN_PARENS as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_COMPOSES_IMPORT_SPECIFIER
+        kind == CSS_CONTAINER_SIZE_FEATURE_IN_PARENS
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -11883,39 +11684,46 @@ impl AstNode for CssComposesImportSpecifier {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssComposesImportSpecifier {
+impl std::fmt::Debug for CssContainerSizeFeatureInParens {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssComposesImportSpecifier")
-                .field("from_token", &support::DebugSyntaxResult(self.from_token()))
-                .field("source", &support::DebugSyntaxResult(self.source()))
+            f.debug_struct("CssContainerSizeFeatureInParens")
+                .field(
+                    "l_paren_token",
+                    &support::DebugSyntaxResult(self.l_paren_token()),
+                )
+                .field("feature", &support::DebugSyntaxResult(self.feature()))
+                .field(
+                    "r_paren_token",
+                    &support::DebugSyntaxResult(self.r_paren_token()),
+                )
                 .finish()
         } else {
-            f.debug_struct("CssComposesImportSpecifier").finish()
+            f.debug_struct("CssContainerSizeFeatureInParens").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssComposesImportSpecifier> for SyntaxNode {
-    fn from(n: CssComposesImportSpecifier) -> Self {
+impl From<CssContainerSizeFeatureInParens> for SyntaxNode {
+    fn from(n: CssContainerSizeFeatureInParens) -> Self {
         n.syntax
     }
 }
-impl From<CssComposesImportSpecifier> for SyntaxElement {
-    fn from(n: CssComposesImportSpecifier) -> Self {
+impl From<CssContainerSizeFeatureInParens> for SyntaxElement {
+    fn from(n: CssContainerSizeFeatureInParens) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssComposesProperty {
+impl AstNode for CssContainerStyleAndQuery {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_COMPOSES_PROPERTY as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_CONTAINER_STYLE_AND_QUERY as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_COMPOSES_PROPERTY
+        kind == CSS_CONTAINER_STYLE_AND_QUERY
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -11931,43 +11739,40 @@ impl AstNode for CssComposesProperty {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssComposesProperty {
+impl std::fmt::Debug for CssContainerStyleAndQuery {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssComposesProperty")
-                .field("name", &support::DebugSyntaxResult(self.name()))
-                .field(
-                    "colon_token",
-                    &support::DebugSyntaxResult(self.colon_token()),
-                )
-                .field("value", &support::DebugSyntaxResult(self.value()))
+            f.debug_struct("CssContainerStyleAndQuery")
+                .field("left", &support::DebugSyntaxResult(self.left()))
+                .field("and_token", &support::DebugSyntaxResult(self.and_token()))
+                .field("right", &support::DebugSyntaxResult(self.right()))
                 .finish()
         } else {
-            f.debug_struct("CssComposesProperty").finish()
+            f.debug_struct("CssContainerStyleAndQuery").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssComposesProperty> for SyntaxNode {
-    fn from(n: CssComposesProperty) -> Self {
+impl From<CssContainerStyleAndQuery> for SyntaxNode {
+    fn from(n: CssContainerStyleAndQuery) -> Self {
         n.syntax
     }
 }
-impl From<CssComposesProperty> for SyntaxElement {
-    fn from(n: CssComposesProperty) -> Self {
+impl From<CssContainerStyleAndQuery> for SyntaxElement {
+    fn from(n: CssContainerStyleAndQuery) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssComposesPropertyValue {
+impl AstNode for CssContainerStyleInParens {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_COMPOSES_PROPERTY_VALUE as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_CONTAINER_STYLE_IN_PARENS as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_COMPOSES_PROPERTY_VALUE
+        kind == CSS_CONTAINER_STYLE_IN_PARENS
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -11983,42 +11788,46 @@ impl AstNode for CssComposesPropertyValue {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssComposesPropertyValue {
+impl std::fmt::Debug for CssContainerStyleInParens {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssComposesPropertyValue")
-                .field("classes", &self.classes())
+            f.debug_struct("CssContainerStyleInParens")
                 .field(
-                    "specifier",
-                    &support::DebugOptionalElement(self.specifier()),
+                    "l_paren_token",
+                    &support::DebugSyntaxResult(self.l_paren_token()),
+                )
+                .field("query", &support::DebugSyntaxResult(self.query()))
+                .field(
+                    "r_paren_token",
+                    &support::DebugSyntaxResult(self.r_paren_token()),
                 )
                 .finish()
         } else {
-            f.debug_struct("CssComposesPropertyValue").finish()
+            f.debug_struct("CssContainerStyleInParens").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssComposesPropertyValue> for SyntaxNode {
-    fn from(n: CssComposesPropertyValue) -> Self {
+impl From<CssContainerStyleInParens> for SyntaxNode {
+    fn from(n: CssContainerStyleInParens) -> Self {
         n.syntax
     }
 }
-impl From<CssComposesPropertyValue> for SyntaxElement {
-    fn from(n: CssComposesPropertyValue) -> Self {
+impl From<CssContainerStyleInParens> for SyntaxElement {
+    fn from(n: CssContainerStyleInParens) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssCompoundSelector {
+impl AstNode for CssContainerStyleNotQuery {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_COMPOUND_SELECTOR as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_CONTAINER_STYLE_NOT_QUERY as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_COMPOUND_SELECTOR
+        kind == CSS_CONTAINER_STYLE_NOT_QUERY
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -12034,43 +11843,39 @@ impl AstNode for CssCompoundSelector {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssCompoundSelector {
+impl std::fmt::Debug for CssContainerStyleNotQuery {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssCompoundSelector")
-                .field("nesting_selectors", &self.nesting_selectors())
-                .field(
-                    "simple_selector",
-                    &support::DebugOptionalElement(self.simple_selector()),
-                )
-                .field("sub_selectors", &self.sub_selectors())
+            f.debug_struct("CssContainerStyleNotQuery")
+                .field("not_token", &support::DebugSyntaxResult(self.not_token()))
+                .field("query", &support::DebugSyntaxResult(self.query()))
                 .finish()
         } else {
-            f.debug_struct("CssCompoundSelector").finish()
+            f.debug_struct("CssContainerStyleNotQuery").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssCompoundSelector> for SyntaxNode {
-    fn from(n: CssCompoundSelector) -> Self {
+impl From<CssContainerStyleNotQuery> for SyntaxNode {
+    fn from(n: CssContainerStyleNotQuery) -> Self {
         n.syntax
     }
 }
-impl From<CssCompoundSelector> for SyntaxElement {
-    fn from(n: CssCompoundSelector) -> Self {
+impl From<CssContainerStyleNotQuery> for SyntaxElement {
+    fn from(n: CssContainerStyleNotQuery) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssContainerAndQuery {
+impl AstNode for CssContainerStyleOrQuery {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_CONTAINER_AND_QUERY as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_CONTAINER_STYLE_OR_QUERY as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_CONTAINER_AND_QUERY
+        kind == CSS_CONTAINER_STYLE_OR_QUERY
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -12086,40 +11891,40 @@ impl AstNode for CssContainerAndQuery {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssContainerAndQuery {
+impl std::fmt::Debug for CssContainerStyleOrQuery {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssContainerAndQuery")
+            f.debug_struct("CssContainerStyleOrQuery")
                 .field("left", &support::DebugSyntaxResult(self.left()))
-                .field("and_token", &support::DebugSyntaxResult(self.and_token()))
+                .field("or_token", &support::DebugSyntaxResult(self.or_token()))
                 .field("right", &support::DebugSyntaxResult(self.right()))
                 .finish()
         } else {
-            f.debug_struct("CssContainerAndQuery").finish()
+            f.debug_struct("CssContainerStyleOrQuery").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssContainerAndQuery> for SyntaxNode {
-    fn from(n: CssContainerAndQuery) -> Self {
+impl From<CssContainerStyleOrQuery> for SyntaxNode {
+    fn from(n: CssContainerStyleOrQuery) -> Self {
         n.syntax
     }
 }
-impl From<CssContainerAndQuery> for SyntaxElement {
-    fn from(n: CssContainerAndQuery) -> Self {
+impl From<CssContainerStyleOrQuery> for SyntaxElement {
+    fn from(n: CssContainerStyleOrQuery) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssContainerAtRule {
+impl AstNode for CssContainerStyleQueryInParens {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_CONTAINER_AT_RULE as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_CONTAINER_STYLE_QUERY_IN_PARENS as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_CONTAINER_AT_RULE
+        kind == CSS_CONTAINER_STYLE_QUERY_IN_PARENS
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -12135,39 +11940,50 @@ impl AstNode for CssContainerAtRule {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssContainerAtRule {
+impl std::fmt::Debug for CssContainerStyleQueryInParens {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssContainerAtRule")
-                .field("declarator", &support::DebugSyntaxResult(self.declarator()))
-                .field("block", &support::DebugSyntaxResult(self.block()))
+            f.debug_struct("CssContainerStyleQueryInParens")
+                .field(
+                    "style_token",
+                    &support::DebugSyntaxResult(self.style_token()),
+                )
+                .field(
+                    "l_paren_token",
+                    &support::DebugSyntaxResult(self.l_paren_token()),
+                )
+                .field("query", &support::DebugSyntaxResult(self.query()))
+                .field(
+                    "r_paren_token",
+                    &support::DebugSyntaxResult(self.r_paren_token()),
+                )
                 .finish()
         } else {
-            f.debug_struct("CssContainerAtRule").finish()
+            f.debug_struct("CssContainerStyleQueryInParens").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssContainerAtRule> for SyntaxNode {
-    fn from(n: CssContainerAtRule) -> Self {
+impl From<CssContainerStyleQueryInParens> for SyntaxNode {
+    fn from(n: CssContainerStyleQueryInParens) -> Self {
         n.syntax
     }
 }
-impl From<CssContainerAtRule> for SyntaxElement {
-    fn from(n: CssContainerAtRule) -> Self {
+impl From<CssContainerStyleQueryInParens> for SyntaxElement {
+    fn from(n: CssContainerStyleQueryInParens) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssContainerAtRuleDeclarator {
+impl AstNode for CssCounterStyleAtRule {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_CONTAINER_AT_RULE_DECLARATOR as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_COUNTER_STYLE_AT_RULE as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_CONTAINER_AT_RULE_DECLARATOR
+        kind == CSS_COUNTER_STYLE_AT_RULE
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -12183,43 +11999,39 @@ impl AstNode for CssContainerAtRuleDeclarator {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssContainerAtRuleDeclarator {
+impl std::fmt::Debug for CssCounterStyleAtRule {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssContainerAtRuleDeclarator")
-                .field(
-                    "container_token",
-                    &support::DebugSyntaxResult(self.container_token()),
-                )
-                .field("name", &support::DebugOptionalElement(self.name()))
-                .field("query", &support::DebugSyntaxResult(self.query()))
+            f.debug_struct("CssCounterStyleAtRule")
+                .field("declarator", &support::DebugSyntaxResult(self.declarator()))
+                .field("block", &support::DebugSyntaxResult(self.block()))
                 .finish()
         } else {
-            f.debug_struct("CssContainerAtRuleDeclarator").finish()
+            f.debug_struct("CssCounterStyleAtRule").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssContainerAtRuleDeclarator> for SyntaxNode {
-    fn from(n: CssContainerAtRuleDeclarator) -> Self {
+impl From<CssCounterStyleAtRule> for SyntaxNode {
+    fn from(n: CssCounterStyleAtRule) -> Self {
         n.syntax
     }
 }
-impl From<CssContainerAtRuleDeclarator> for SyntaxElement {
-    fn from(n: CssContainerAtRuleDeclarator) -> Self {
+impl From<CssCounterStyleAtRule> for SyntaxElement {
+    fn from(n: CssCounterStyleAtRule) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssContainerNotQuery {
+impl AstNode for CssCounterStyleAtRuleDeclarator {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_CONTAINER_NOT_QUERY as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_COUNTER_STYLE_AT_RULE_DECLARATOR as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_CONTAINER_NOT_QUERY
+        kind == CSS_COUNTER_STYLE_AT_RULE_DECLARATOR
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -12235,39 +12047,42 @@ impl AstNode for CssContainerNotQuery {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssContainerNotQuery {
+impl std::fmt::Debug for CssCounterStyleAtRuleDeclarator {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssContainerNotQuery")
-                .field("not_token", &support::DebugSyntaxResult(self.not_token()))
-                .field("query", &support::DebugSyntaxResult(self.query()))
+            f.debug_struct("CssCounterStyleAtRuleDeclarator")
+                .field(
+                    "counter_style_token",
+                    &support::DebugSyntaxResult(self.counter_style_token()),
+                )
+                .field("name", &support::DebugSyntaxResult(self.name()))
                 .finish()
         } else {
-            f.debug_struct("CssContainerNotQuery").finish()
+            f.debug_struct("CssCounterStyleAtRuleDeclarator").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssContainerNotQuery> for SyntaxNode {
-    fn from(n: CssContainerNotQuery) -> Self {
+impl From<CssCounterStyleAtRuleDeclarator> for SyntaxNode {
+    fn from(n: CssCounterStyleAtRuleDeclarator) -> Self {
         n.syntax
     }
 }
-impl From<CssContainerNotQuery> for SyntaxElement {
-    fn from(n: CssContainerNotQuery) -> Self {
+impl From<CssCounterStyleAtRuleDeclarator> for SyntaxElement {
+    fn from(n: CssCounterStyleAtRuleDeclarator) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssContainerOrQuery {
+impl AstNode for CssCustomIdentifier {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_CONTAINER_OR_QUERY as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_CUSTOM_IDENTIFIER as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_CONTAINER_OR_QUERY
+        kind == CSS_CUSTOM_IDENTIFIER
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -12283,40 +12098,41 @@ impl AstNode for CssContainerOrQuery {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssContainerOrQuery {
+impl std::fmt::Debug for CssCustomIdentifier {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssContainerOrQuery")
-                .field("left", &support::DebugSyntaxResult(self.left()))
-                .field("or_token", &support::DebugSyntaxResult(self.or_token()))
-                .field("right", &support::DebugSyntaxResult(self.right()))
+            f.debug_struct("CssCustomIdentifier")
+                .field(
+                    "value_token",
+                    &support::DebugSyntaxResult(self.value_token()),
+                )
                 .finish()
         } else {
-            f.debug_struct("CssContainerOrQuery").finish()
+            f.debug_struct("CssCustomIdentifier").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssContainerOrQuery> for SyntaxNode {
-    fn from(n: CssContainerOrQuery) -> Self {
+impl From<CssCustomIdentifier> for SyntaxNode {
+    fn from(n: CssCustomIdentifier) -> Self {
         n.syntax
     }
 }
-impl From<CssContainerOrQuery> for SyntaxElement {
-    fn from(n: CssContainerOrQuery) -> Self {
+impl From<CssCustomIdentifier> for SyntaxElement {
+    fn from(n: CssCustomIdentifier) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssContainerQueryInParens {
+impl AstNode for CssDashedIdentifier {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_CONTAINER_QUERY_IN_PARENS as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_DASHED_IDENTIFIER as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_CONTAINER_QUERY_IN_PARENS
+        kind == CSS_DASHED_IDENTIFIER
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -12332,46 +12148,41 @@ impl AstNode for CssContainerQueryInParens {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssContainerQueryInParens {
+impl std::fmt::Debug for CssDashedIdentifier {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssContainerQueryInParens")
-                .field(
-                    "l_paren_token",
-                    &support::DebugSyntaxResult(self.l_paren_token()),
-                )
-                .field("query", &support::DebugSyntaxResult(self.query()))
+            f.debug_struct("CssDashedIdentifier")
                 .field(
-                    "r_paren_token",
-                    &support::DebugSyntaxResult(self.r_paren_token()),
+                    "value_token",
+                    &support::DebugSyntaxResult(self.value_token()),
                 )
                 .finish()
         } else {
-            f.debug_struct("CssContainerQueryInParens").finish()
+            f.debug_struct("CssDashedIdentifier").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssContainerQueryInParens> for SyntaxNode {
-    fn from(n: CssContainerQueryInParens) -> Self {
+impl From<CssDashedIdentifier> for SyntaxNode {
+    fn from(n: CssDashedIdentifier) -> Self {
         n.syntax
     }
 }
-impl From<CssContainerQueryInParens> for SyntaxElement {
-    fn from(n: CssContainerQueryInParens) -> Self {
+impl From<CssDashedIdentifier> for SyntaxElement {
+    fn from(n: CssDashedIdentifier) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssContainerSizeFeatureInParens {
+impl AstNode for CssDeclaration {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_CONTAINER_SIZE_FEATURE_IN_PARENS as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_DECLARATION as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_CONTAINER_SIZE_FEATURE_IN_PARENS
+        kind == CSS_DECLARATION
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -12387,46 +12198,42 @@ impl AstNode for CssContainerSizeFeatureInParens {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssContainerSizeFeatureInParens {
+impl std::fmt::Debug for CssDeclaration {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssContainerSizeFeatureInParens")
-                .field(
-                    "l_paren_token",
-                    &support::DebugSyntaxResult(self.l_paren_token()),
-                )
-                .field("feature", &support::DebugSyntaxResult(self.feature()))
+            f.debug_struct("CssDeclaration")
+                .field("property", &support::DebugSyntaxResult(self.property()))
                 .field(
-                    "r_paren_token",
-                    &support::DebugSyntaxResult(self.r_paren_token()),
+                    "important",
+                    &support::DebugOptionalElement(self.important()),
                 )
                 .finish()
         } else {
-            f.debug_struct("CssContainerSizeFeatureInParens").finish()
+            f.debug_struct("CssDeclaration").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssContainerSizeFeatureInParens> for SyntaxNode {
-    fn from(n: CssContainerSizeFeatureInParens) -> Self {
+impl From<CssDeclaration> for SyntaxNode {
+    fn from(n: CssDeclaration) -> Self {
         n.syntax
     }
 }
-impl From<CssContainerSizeFeatureInParens> for SyntaxElement {
-    fn from(n: CssContainerSizeFeatureInParens) -> Self {
+impl From<CssDeclaration> for SyntaxElement {
+    fn from(n: CssDeclaration) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssContainerStyleAndQuery {
+impl AstNode for CssDeclarationBlock {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_CONTAINER_STYLE_AND_QUERY as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_DECLARATION_BLOCK as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_CONTAINER_STYLE_AND_QUERY
+        kind == CSS_DECLARATION_BLOCK
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -12442,40 +12249,46 @@ impl AstNode for CssContainerStyleAndQuery {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssContainerStyleAndQuery {
+impl std::fmt::Debug for CssDeclarationBlock {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssContainerStyleAndQuery")
-                .field("left", &support::DebugSyntaxResult(self.left()))
-                .field("and_token", &support::DebugSyntaxResult(self.and_token()))
-                .field("right", &support::DebugSyntaxResult(self.right()))
+            f.debug_struct("CssDeclarationBlock")
+                .field(
+                    "l_curly_token",
+                    &support::DebugSyntaxResult(self.l_curly_token()),
+                )
+                .field("declarations", &self.declarations())
+                .field(
+                    "r_curly_token",
+                    &support::DebugSyntaxResult(self.r_curly_token()),
+                )
                 .finish()
         } else {
-            f.debug_struct("CssContainerStyleAndQuery").finish()
+            f.debug_struct("CssDeclarationBlock").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssContainerStyleAndQuery> for SyntaxNode {
-    fn from(n: CssContainerStyleAndQuery) -> Self {
+impl From<CssDeclarationBlock> for SyntaxNode {
+    fn from(n: CssDeclarationBlock) -> Self {
         n.syntax
     }
 }
-impl From<CssContainerStyleAndQuery> for SyntaxElement {
-    fn from(n: CssContainerStyleAndQuery) -> Self {
+impl From<CssDeclarationBlock> for SyntaxElement {
+    fn from(n: CssDeclarationBlock) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssContainerStyleInParens {
+impl AstNode for CssDeclarationImportant {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_CONTAINER_STYLE_IN_PARENS as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_DECLARATION_IMPORTANT as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_CONTAINER_STYLE_IN_PARENS
+        kind == CSS_DECLARATION_IMPORTANT
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -12491,46 +12304,42 @@ impl AstNode for CssContainerStyleInParens {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssContainerStyleInParens {
+impl std::fmt::Debug for CssDeclarationImportant {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssContainerStyleInParens")
-                .field(
-                    "l_paren_token",
-                    &support::DebugSyntaxResult(self.l_paren_token()),
-                )
-                .field("query", &support::DebugSyntaxResult(self.query()))
+            f.debug_struct("CssDeclarationImportant")
+                .field("excl_token", &support::DebugSyntaxResult(self.excl_token()))
                 .field(
-                    "r_paren_token",
-                    &support::DebugSyntaxResult(self.r_paren_token()),
+                    "important_token",
+                    &support::DebugSyntaxResult(self.important_token()),
                 )
                 .finish()
         } else {
-            f.debug_struct("CssContainerStyleInParens").finish()
+            f.debug_struct("CssDeclarationImportant").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssContainerStyleInParens> for SyntaxNode {
-    fn from(n: CssContainerStyleInParens) -> Self {
+impl From<CssDeclarationImportant> for SyntaxNode {
+    fn from(n: CssDeclarationImportant) -> Self {
         n.syntax
     }
 }
-impl From<CssContainerStyleInParens> for SyntaxElement {
-    fn from(n: CssContainerStyleInParens) -> Self {
+impl From<CssDeclarationImportant> for SyntaxElement {
+    fn from(n: CssDeclarationImportant) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssContainerStyleNotQuery {
+impl AstNode for CssDeclarationOrAtRuleBlock {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_CONTAINER_STYLE_NOT_QUERY as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_DECLARATION_OR_AT_RULE_BLOCK as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_CONTAINER_STYLE_NOT_QUERY
+        kind == CSS_DECLARATION_OR_AT_RULE_BLOCK
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -12546,39 +12355,46 @@ impl AstNode for CssContainerStyleNotQuery {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssContainerStyleNotQuery {
+impl std::fmt::Debug for CssDeclarationOrAtRuleBlock {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssContainerStyleNotQuery")
-                .field("not_token", &support::DebugSyntaxResult(self.not_token()))
-                .field("query", &support::DebugSyntaxResult(self.query()))
+            f.debug_struct("CssDeclarationOrAtRuleBlock")
+                .field(
+                    "l_curly_token",
+                    &support::DebugSyntaxResult(self.l_curly_token()),
+                )
+                .field("items", &self.items())
+                .field(
+                    "r_curly_token",
+                    &support::DebugSyntaxResult(self.r_curly_token()),
+                )
                 .finish()
         } else {
-            f.debug_struct("CssContainerStyleNotQuery").finish()
+            f.debug_struct("CssDeclarationOrAtRuleBlock").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssContainerStyleNotQuery> for SyntaxNode {
-    fn from(n: CssContainerStyleNotQuery) -> Self {
+impl From<CssDeclarationOrAtRuleBlock> for SyntaxNode {
+    fn from(n: CssDeclarationOrAtRuleBlock) -> Self {
         n.syntax
     }
 }
-impl From<CssContainerStyleNotQuery> for SyntaxElement {
-    fn from(n: CssContainerStyleNotQuery) -> Self {
+impl From<CssDeclarationOrAtRuleBlock> for SyntaxElement {
+    fn from(n: CssDeclarationOrAtRuleBlock) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssContainerStyleOrQuery {
+impl AstNode for CssDeclarationOrRuleBlock {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_CONTAINER_STYLE_OR_QUERY as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_DECLARATION_OR_RULE_BLOCK as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_CONTAINER_STYLE_OR_QUERY
+        kind == CSS_DECLARATION_OR_RULE_BLOCK
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -12594,40 +12410,46 @@ impl AstNode for CssContainerStyleOrQuery {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssContainerStyleOrQuery {
+impl std::fmt::Debug for CssDeclarationOrRuleBlock {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssContainerStyleOrQuery")
-                .field("left", &support::DebugSyntaxResult(self.left()))
-                .field("or_token", &support::DebugSyntaxResult(self.or_token()))
-                .field("right", &support::DebugSyntaxResult(self.right()))
+            f.debug_struct("CssDeclarationOrRuleBlock")
+                .field(
+                    "l_curly_token",
+                    &support::DebugSyntaxResult(self.l_curly_token()),
+                )
+                .field("items", &self.items())
+                .field(
+                    "r_curly_token",
+                    &support::DebugSyntaxResult(self.r_curly_token()),
+                )
                 .finish()
         } else {
-            f.debug_struct("CssContainerStyleOrQuery").finish()
+            f.debug_struct("CssDeclarationOrRuleBlock").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssContainerStyleOrQuery> for SyntaxNode {
-    fn from(n: CssContainerStyleOrQuery) -> Self {
+impl From<CssDeclarationOrRuleBlock> for SyntaxNode {
+    fn from(n: CssDeclarationOrRuleBlock) -> Self {
         n.syntax
     }
 }
-impl From<CssContainerStyleOrQuery> for SyntaxElement {
-    fn from(n: CssContainerStyleOrQuery) -> Self {
+impl From<CssDeclarationOrRuleBlock> for SyntaxElement {
+    fn from(n: CssDeclarationOrRuleBlock) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssContainerStyleQueryInParens {
+impl AstNode for CssDeclarationWithSemicolon {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_CONTAINER_STYLE_QUERY_IN_PARENS as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_DECLARATION_WITH_SEMICOLON as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_CONTAINER_STYLE_QUERY_IN_PARENS
+        kind == CSS_DECLARATION_WITH_SEMICOLON
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -12643,50 +12465,45 @@ impl AstNode for CssContainerStyleQueryInParens {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssContainerStyleQueryInParens {
+impl std::fmt::Debug for CssDeclarationWithSemicolon {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssContainerStyleQueryInParens")
-                .field(
-                    "style_token",
-                    &support::DebugSyntaxResult(self.style_token()),
-                )
+            f.debug_struct("CssDeclarationWithSemicolon")
                 .field(
-                    "l_paren_token",
-                    &support::DebugSyntaxResult(self.l_paren_token()),
+                    "declaration",
+                    &support::DebugSyntaxResult(self.declaration()),
                 )
-                .field("query", &support::DebugSyntaxResult(self.query()))
                 .field(
-                    "r_paren_token",
-                    &support::DebugSyntaxResult(self.r_paren_token()),
+                    "semicolon_token",
+                    &support::DebugOptionalElement(self.semicolon_token()),
                 )
                 .finish()
         } else {
-            f.debug_struct("CssContainerStyleQueryInParens").finish()
+            f.debug_struct("CssDeclarationWithSemicolon").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssContainerStyleQueryInParens> for SyntaxNode {
-    fn from(n: CssContainerStyleQueryInParens) -> Self {
+impl From<CssDeclarationWithSemicolon> for SyntaxNode {
+    fn from(n: CssDeclarationWithSemicolon) -> Self {
         n.syntax
     }
 }
-impl From<CssContainerStyleQueryInParens> for SyntaxElement {
-    fn from(n: CssContainerStyleQueryInParens) -> Self {
+impl From<CssDeclarationWithSemicolon> for SyntaxElement {
+    fn from(n: CssDeclarationWithSemicolon) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssCounterStyleAtRule {
+impl AstNode for CssDocumentAtRule {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_COUNTER_STYLE_AT_RULE as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_DOCUMENT_AT_RULE as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_COUNTER_STYLE_AT_RULE
+        kind == CSS_DOCUMENT_AT_RULE
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -12702,39 +12519,43 @@ impl AstNode for CssCounterStyleAtRule {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssCounterStyleAtRule {
+impl std::fmt::Debug for CssDocumentAtRule {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssCounterStyleAtRule")
-                .field("declarator", &support::DebugSyntaxResult(self.declarator()))
+            f.debug_struct("CssDocumentAtRule")
+                .field(
+                    "document_token",
+                    &support::DebugSyntaxResult(self.document_token()),
+                )
+                .field("matchers", &self.matchers())
                 .field("block", &support::DebugSyntaxResult(self.block()))
                 .finish()
         } else {
-            f.debug_struct("CssCounterStyleAtRule").finish()
+            f.debug_struct("CssDocumentAtRule").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssCounterStyleAtRule> for SyntaxNode {
-    fn from(n: CssCounterStyleAtRule) -> Self {
+impl From<CssDocumentAtRule> for SyntaxNode {
+    fn from(n: CssDocumentAtRule) -> Self {
         n.syntax
     }
 }
-impl From<CssCounterStyleAtRule> for SyntaxElement {
-    fn from(n: CssCounterStyleAtRule) -> Self {
+impl From<CssDocumentAtRule> for SyntaxElement {
+    fn from(n: CssDocumentAtRule) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssCounterStyleAtRuleDeclarator {
+impl AstNode for CssDocumentCustomMatcher {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_COUNTER_STYLE_AT_RULE_DECLARATOR as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_DOCUMENT_CUSTOM_MATCHER as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_COUNTER_STYLE_AT_RULE_DECLARATOR
+        kind == CSS_DOCUMENT_CUSTOM_MATCHER
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -12750,42 +12571,47 @@ impl AstNode for CssCounterStyleAtRuleDeclarator {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssCounterStyleAtRuleDeclarator {
+impl std::fmt::Debug for CssDocumentCustomMatcher {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssCounterStyleAtRuleDeclarator")
+            f.debug_struct("CssDocumentCustomMatcher")
+                .field("name", &support::DebugSyntaxResult(self.name()))
                 .field(
-                    "counter_style_token",
-                    &support::DebugSyntaxResult(self.counter_style_token()),
+                    "l_paren_token",
+                    &support::DebugSyntaxResult(self.l_paren_token()),
+                )
+                .field("value", &support::DebugOptionalElement(self.value()))
+                .field(
+                    "r_paren_token",
+                    &support::DebugSyntaxResult(self.r_paren_token()),
                 )
-                .field("name", &support::DebugSyntaxResult(self.name()))
                 .finish()
         } else {
-            f.debug_struct("CssCounterStyleAtRuleDeclarator").finish()
+            f.debug_struct("CssDocumentCustomMatcher").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssCounterStyleAtRuleDeclarator> for SyntaxNode {
-    fn from(n: CssCounterStyleAtRuleDeclarator) -> Self {
+impl From<CssDocumentCustomMatcher> for SyntaxNode {
+    fn from(n: CssDocumentCustomMatcher) -> Self {
         n.syntax
     }
 }
-impl From<CssCounterStyleAtRuleDeclarator> for SyntaxElement {
-    fn from(n: CssCounterStyleAtRuleDeclarator) -> Self {
+impl From<CssDocumentCustomMatcher> for SyntaxElement {
+    fn from(n: CssDocumentCustomMatcher) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssCustomIdentifier {
+impl AstNode for CssEmptyDeclaration {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_CUSTOM_IDENTIFIER as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_EMPTY_DECLARATION as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_CUSTOM_IDENTIFIER
+        kind == CSS_EMPTY_DECLARATION
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -12801,41 +12627,41 @@ impl AstNode for CssCustomIdentifier {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssCustomIdentifier {
+impl std::fmt::Debug for CssEmptyDeclaration {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssCustomIdentifier")
+            f.debug_struct("CssEmptyDeclaration")
                 .field(
-                    "value_token",
-                    &support::DebugSyntaxResult(self.value_token()),
+                    "semicolon_token",
+                    &support::DebugSyntaxResult(self.semicolon_token()),
                 )
                 .finish()
         } else {
-            f.debug_struct("CssCustomIdentifier").finish()
+            f.debug_struct("CssEmptyDeclaration").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssCustomIdentifier> for SyntaxNode {
-    fn from(n: CssCustomIdentifier) -> Self {
+impl From<CssEmptyDeclaration> for SyntaxNode {
+    fn from(n: CssEmptyDeclaration) -> Self {
         n.syntax
     }
 }
-impl From<CssCustomIdentifier> for SyntaxElement {
-    fn from(n: CssCustomIdentifier) -> Self {
+impl From<CssEmptyDeclaration> for SyntaxElement {
+    fn from(n: CssEmptyDeclaration) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssDashedIdentifier {
+impl AstNode for CssFontFaceAtRule {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_DASHED_IDENTIFIER as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_FONT_FACE_AT_RULE as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_DASHED_IDENTIFIER
+        kind == CSS_FONT_FACE_AT_RULE
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -12851,41 +12677,39 @@ impl AstNode for CssDashedIdentifier {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssDashedIdentifier {
+impl std::fmt::Debug for CssFontFaceAtRule {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssDashedIdentifier")
-                .field(
-                    "value_token",
-                    &support::DebugSyntaxResult(self.value_token()),
-                )
+            f.debug_struct("CssFontFaceAtRule")
+                .field("declarator", &support::DebugSyntaxResult(self.declarator()))
+                .field("block", &support::DebugSyntaxResult(self.block()))
                 .finish()
         } else {
-            f.debug_struct("CssDashedIdentifier").finish()
+            f.debug_struct("CssFontFaceAtRule").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssDashedIdentifier> for SyntaxNode {
-    fn from(n: CssDashedIdentifier) -> Self {
+impl From<CssFontFaceAtRule> for SyntaxNode {
+    fn from(n: CssFontFaceAtRule) -> Self {
         n.syntax
     }
 }
-impl From<CssDashedIdentifier> for SyntaxElement {
-    fn from(n: CssDashedIdentifier) -> Self {
+impl From<CssFontFaceAtRule> for SyntaxElement {
+    fn from(n: CssFontFaceAtRule) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssDeclaration {
+impl AstNode for CssFontFaceAtRuleDeclarator {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_DECLARATION as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_FONT_FACE_AT_RULE_DECLARATOR as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_DECLARATION
+        kind == CSS_FONT_FACE_AT_RULE_DECLARATOR
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -12901,42 +12725,41 @@ impl AstNode for CssDeclaration {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssDeclaration {
+impl std::fmt::Debug for CssFontFaceAtRuleDeclarator {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssDeclaration")
-                .field("property", &support::DebugSyntaxResult(self.property()))
+            f.debug_struct("CssFontFaceAtRuleDeclarator")
                 .field(
-                    "important",
-                    &support::DebugOptionalElement(self.important()),
+                    "font_face_token",
+                    &support::DebugSyntaxResult(self.font_face_token()),
                 )
                 .finish()
         } else {
-            f.debug_struct("CssDeclaration").finish()
+            f.debug_struct("CssFontFaceAtRuleDeclarator").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssDeclaration> for SyntaxNode {
-    fn from(n: CssDeclaration) -> Self {
+impl From<CssFontFaceAtRuleDeclarator> for SyntaxNode {
+    fn from(n: CssFontFaceAtRuleDeclarator) -> Self {
         n.syntax
     }
 }
-impl From<CssDeclaration> for SyntaxElement {
-    fn from(n: CssDeclaration) -> Self {
+impl From<CssFontFaceAtRuleDeclarator> for SyntaxElement {
+    fn from(n: CssFontFaceAtRuleDeclarator) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssDeclarationBlock {
+impl AstNode for CssFontFamilyName {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_DECLARATION_BLOCK as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_FONT_FAMILY_NAME as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_DECLARATION_BLOCK
+        kind == CSS_FONT_FAMILY_NAME
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -12952,46 +12775,38 @@ impl AstNode for CssDeclarationBlock {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssDeclarationBlock {
+impl std::fmt::Debug for CssFontFamilyName {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssDeclarationBlock")
-                .field(
-                    "l_curly_token",
-                    &support::DebugSyntaxResult(self.l_curly_token()),
-                )
-                .field("declarations", &self.declarations())
-                .field(
-                    "r_curly_token",
-                    &support::DebugSyntaxResult(self.r_curly_token()),
-                )
+            f.debug_struct("CssFontFamilyName")
+                .field("names", &self.names())
                 .finish()
         } else {
-            f.debug_struct("CssDeclarationBlock").finish()
+            f.debug_struct("CssFontFamilyName").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssDeclarationBlock> for SyntaxNode {
-    fn from(n: CssDeclarationBlock) -> Self {
+impl From<CssFontFamilyName> for SyntaxNode {
+    fn from(n: CssFontFamilyName) -> Self {
         n.syntax
     }
 }
-impl From<CssDeclarationBlock> for SyntaxElement {
-    fn from(n: CssDeclarationBlock) -> Self {
+impl From<CssFontFamilyName> for SyntaxElement {
+    fn from(n: CssFontFamilyName) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssDeclarationImportant {
+impl AstNode for CssFontFeatureValuesAtRule {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_DECLARATION_IMPORTANT as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_FONT_FEATURE_VALUES_AT_RULE as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_DECLARATION_IMPORTANT
+        kind == CSS_FONT_FEATURE_VALUES_AT_RULE
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -13007,42 +12822,43 @@ impl AstNode for CssDeclarationImportant {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssDeclarationImportant {
+impl std::fmt::Debug for CssFontFeatureValuesAtRule {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssDeclarationImportant")
-                .field("excl_token", &support::DebugSyntaxResult(self.excl_token()))
+            f.debug_struct("CssFontFeatureValuesAtRule")
                 .field(
-                    "important_token",
-                    &support::DebugSyntaxResult(self.important_token()),
+                    "font_feature_values_token",
+                    &support::DebugSyntaxResult(self.font_feature_values_token()),
                 )
+                .field("names", &self.names())
+                .field("block", &support::DebugSyntaxResult(self.block()))
                 .finish()
         } else {
-            f.debug_struct("CssDeclarationImportant").finish()
+            f.debug_struct("CssFontFeatureValuesAtRule").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssDeclarationImportant> for SyntaxNode {
-    fn from(n: CssDeclarationImportant) -> Self {
+impl From<CssFontFeatureValuesAtRule> for SyntaxNode {
+    fn from(n: CssFontFeatureValuesAtRule) -> Self {
         n.syntax
     }
 }
-impl From<CssDeclarationImportant> for SyntaxElement {
-    fn from(n: CssDeclarationImportant) -> Self {
+impl From<CssFontFeatureValuesAtRule> for SyntaxElement {
+    fn from(n: CssFontFeatureValuesAtRule) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssDeclarationOrAtRuleBlock {
+impl AstNode for CssFontFeatureValuesBlock {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_DECLARATION_OR_AT_RULE_BLOCK as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_FONT_FEATURE_VALUES_BLOCK as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_DECLARATION_OR_AT_RULE_BLOCK
+        kind == CSS_FONT_FEATURE_VALUES_BLOCK
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -13058,13 +12874,13 @@ impl AstNode for CssDeclarationOrAtRuleBlock {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssDeclarationOrAtRuleBlock {
+impl std::fmt::Debug for CssFontFeatureValuesBlock {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssDeclarationOrAtRuleBlock")
+            f.debug_struct("CssFontFeatureValuesBlock")
                 .field(
                     "l_curly_token",
                     &support::DebugSyntaxResult(self.l_curly_token()),
@@ -13076,28 +12892,28 @@ impl std::fmt::Debug for CssDeclarationOrAtRuleBlock {
                 )
                 .finish()
         } else {
-            f.debug_struct("CssDeclarationOrAtRuleBlock").finish()
+            f.debug_struct("CssFontFeatureValuesBlock").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssDeclarationOrAtRuleBlock> for SyntaxNode {
-    fn from(n: CssDeclarationOrAtRuleBlock) -> Self {
+impl From<CssFontFeatureValuesBlock> for SyntaxNode {
+    fn from(n: CssFontFeatureValuesBlock) -> Self {
         n.syntax
     }
 }
-impl From<CssDeclarationOrAtRuleBlock> for SyntaxElement {
-    fn from(n: CssDeclarationOrAtRuleBlock) -> Self {
+impl From<CssFontFeatureValuesBlock> for SyntaxElement {
+    fn from(n: CssFontFeatureValuesBlock) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssDeclarationOrRuleBlock {
+impl AstNode for CssFontFeatureValuesItem {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_DECLARATION_OR_RULE_BLOCK as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_FONT_FEATURE_VALUES_ITEM as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_DECLARATION_OR_RULE_BLOCK
+        kind == CSS_FONT_FEATURE_VALUES_ITEM
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -13113,46 +12929,40 @@ impl AstNode for CssDeclarationOrRuleBlock {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssDeclarationOrRuleBlock {
+impl std::fmt::Debug for CssFontFeatureValuesItem {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssDeclarationOrRuleBlock")
-                .field(
-                    "l_curly_token",
-                    &support::DebugSyntaxResult(self.l_curly_token()),
-                )
-                .field("items", &self.items())
-                .field(
-                    "r_curly_token",
-                    &support::DebugSyntaxResult(self.r_curly_token()),
-                )
+            f.debug_struct("CssFontFeatureValuesItem")
+                .field("at_token", &support::DebugSyntaxResult(self.at_token()))
+                .field("name", &support::DebugSyntaxResult(self.name()))
+                .field("block", &support::DebugSyntaxResult(self.block()))
                 .finish()
         } else {
-            f.debug_struct("CssDeclarationOrRuleBlock").finish()
+            f.debug_struct("CssFontFeatureValuesItem").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssDeclarationOrRuleBlock> for SyntaxNode {
-    fn from(n: CssDeclarationOrRuleBlock) -> Self {
+impl From<CssFontFeatureValuesItem> for SyntaxNode {
+    fn from(n: CssFontFeatureValuesItem) -> Self {
         n.syntax
     }
 }
-impl From<CssDeclarationOrRuleBlock> for SyntaxElement {
-    fn from(n: CssDeclarationOrRuleBlock) -> Self {
+impl From<CssFontFeatureValuesItem> for SyntaxElement {
+    fn from(n: CssFontFeatureValuesItem) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssDeclarationWithSemicolon {
+impl AstNode for CssFontPaletteValuesAtRule {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_DECLARATION_WITH_SEMICOLON as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_FONT_PALETTE_VALUES_AT_RULE as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_DECLARATION_WITH_SEMICOLON
+        kind == CSS_FONT_PALETTE_VALUES_AT_RULE
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -13168,45 +12978,40 @@ impl AstNode for CssDeclarationWithSemicolon {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssDeclarationWithSemicolon {
+impl std::fmt::Debug for CssFontPaletteValuesAtRule {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssDeclarationWithSemicolon")
-                .field(
-                    "declaration",
-                    &support::DebugSyntaxResult(self.declaration()),
-                )
-                .field(
-                    "semicolon_token",
-                    &support::DebugOptionalElement(self.semicolon_token()),
-                )
+            f.debug_struct("CssFontPaletteValuesAtRule")
+                .field("declarator", &support::DebugSyntaxResult(self.declarator()))
+                .field("block", &support::DebugSyntaxResult(self.block()))
                 .finish()
         } else {
-            f.debug_struct("CssDeclarationWithSemicolon").finish()
+            f.debug_struct("CssFontPaletteValuesAtRule").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssDeclarationWithSemicolon> for SyntaxNode {
-    fn from(n: CssDeclarationWithSemicolon) -> Self {
+impl From<CssFontPaletteValuesAtRule> for SyntaxNode {
+    fn from(n: CssFontPaletteValuesAtRule) -> Self {
         n.syntax
     }
 }
-impl From<CssDeclarationWithSemicolon> for SyntaxElement {
-    fn from(n: CssDeclarationWithSemicolon) -> Self {
+impl From<CssFontPaletteValuesAtRule> for SyntaxElement {
+    fn from(n: CssFontPaletteValuesAtRule) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssDocumentAtRule {
+impl AstNode for CssFontPaletteValuesAtRuleDeclarator {
     type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_DOCUMENT_AT_RULE as u16));
+    const KIND_SET: SyntaxKindSet<Language> = SyntaxKindSet::from_raw(RawSyntaxKind(
+        CSS_FONT_PALETTE_VALUES_AT_RULE_DECLARATOR as u16,
+    ));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_DOCUMENT_AT_RULE
+        kind == CSS_FONT_PALETTE_VALUES_AT_RULE_DECLARATOR
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -13222,43 +13027,43 @@ impl AstNode for CssDocumentAtRule {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssDocumentAtRule {
+impl std::fmt::Debug for CssFontPaletteValuesAtRuleDeclarator {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssDocumentAtRule")
+            f.debug_struct("CssFontPaletteValuesAtRuleDeclarator")
                 .field(
-                    "document_token",
-                    &support::DebugSyntaxResult(self.document_token()),
+                    "font_palette_values_token",
+                    &support::DebugSyntaxResult(self.font_palette_values_token()),
                 )
-                .field("matchers", &self.matchers())
-                .field("block", &support::DebugSyntaxResult(self.block()))
+                .field("name", &support::DebugSyntaxResult(self.name()))
                 .finish()
         } else {
-            f.debug_struct("CssDocumentAtRule").finish()
+            f.debug_struct("CssFontPaletteValuesAtRuleDeclarator")
+                .finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssDocumentAtRule> for SyntaxNode {
-    fn from(n: CssDocumentAtRule) -> Self {
+impl From<CssFontPaletteValuesAtRuleDeclarator> for SyntaxNode {
+    fn from(n: CssFontPaletteValuesAtRuleDeclarator) -> Self {
         n.syntax
     }
 }
-impl From<CssDocumentAtRule> for SyntaxElement {
-    fn from(n: CssDocumentAtRule) -> Self {
+impl From<CssFontPaletteValuesAtRuleDeclarator> for SyntaxElement {
+    fn from(n: CssFontPaletteValuesAtRuleDeclarator) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssDocumentCustomMatcher {
+impl AstNode for CssFunction {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_DOCUMENT_CUSTOM_MATCHER as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_FUNCTION as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_DOCUMENT_CUSTOM_MATCHER
+        kind == CSS_FUNCTION
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -13274,47 +13079,47 @@ impl AstNode for CssDocumentCustomMatcher {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssDocumentCustomMatcher {
+impl std::fmt::Debug for CssFunction {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssDocumentCustomMatcher")
+            f.debug_struct("CssFunction")
                 .field("name", &support::DebugSyntaxResult(self.name()))
                 .field(
                     "l_paren_token",
                     &support::DebugSyntaxResult(self.l_paren_token()),
                 )
-                .field("value", &support::DebugOptionalElement(self.value()))
+                .field("items", &self.items())
                 .field(
                     "r_paren_token",
                     &support::DebugSyntaxResult(self.r_paren_token()),
                 )
                 .finish()
         } else {
-            f.debug_struct("CssDocumentCustomMatcher").finish()
+            f.debug_struct("CssFunction").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssDocumentCustomMatcher> for SyntaxNode {
-    fn from(n: CssDocumentCustomMatcher) -> Self {
+impl From<CssFunction> for SyntaxNode {
+    fn from(n: CssFunction) -> Self {
         n.syntax
     }
 }
-impl From<CssDocumentCustomMatcher> for SyntaxElement {
-    fn from(n: CssDocumentCustomMatcher) -> Self {
+impl From<CssFunction> for SyntaxElement {
+    fn from(n: CssFunction) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssElseKeyword {
+impl AstNode for CssGenericDelimiter {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_ELSE_KEYWORD as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_GENERIC_DELIMITER as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_ELSE_KEYWORD
+        kind == CSS_GENERIC_DELIMITER
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -13330,38 +13135,38 @@ impl AstNode for CssElseKeyword {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssElseKeyword {
+impl std::fmt::Debug for CssGenericDelimiter {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssElseKeyword")
-                .field("else_token", &support::DebugSyntaxResult(self.else_token()))
+            f.debug_struct("CssGenericDelimiter")
+                .field("value", &support::DebugSyntaxResult(self.value()))
                 .finish()
         } else {
-            f.debug_struct("CssElseKeyword").finish()
+            f.debug_struct("CssGenericDelimiter").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssElseKeyword> for SyntaxNode {
-    fn from(n: CssElseKeyword) -> Self {
+impl From<CssGenericDelimiter> for SyntaxNode {
+    fn from(n: CssGenericDelimiter) -> Self {
         n.syntax
     }
 }
-impl From<CssElseKeyword> for SyntaxElement {
-    fn from(n: CssElseKeyword) -> Self {
+impl From<CssGenericDelimiter> for SyntaxElement {
+    fn from(n: CssGenericDelimiter) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssEmptyDeclaration {
+impl AstNode for CssGenericProperty {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_EMPTY_DECLARATION as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_GENERIC_PROPERTY as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_EMPTY_DECLARATION
+        kind == CSS_GENERIC_PROPERTY
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -13377,41 +13182,43 @@ impl AstNode for CssEmptyDeclaration {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssEmptyDeclaration {
+impl std::fmt::Debug for CssGenericProperty {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssEmptyDeclaration")
+            f.debug_struct("CssGenericProperty")
+                .field("name", &support::DebugSyntaxResult(self.name()))
                 .field(
-                    "semicolon_token",
-                    &support::DebugSyntaxResult(self.semicolon_token()),
+                    "colon_token",
+                    &support::DebugSyntaxResult(self.colon_token()),
                 )
+                .field("value", &self.value())
                 .finish()
         } else {
-            f.debug_struct("CssEmptyDeclaration").finish()
+            f.debug_struct("CssGenericProperty").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssEmptyDeclaration> for SyntaxNode {
-    fn from(n: CssEmptyDeclaration) -> Self {
+impl From<CssGenericProperty> for SyntaxNode {
+    fn from(n: CssGenericProperty) -> Self {
         n.syntax
     }
 }
-impl From<CssEmptyDeclaration> for SyntaxElement {
-    fn from(n: CssEmptyDeclaration) -> Self {
+impl From<CssGenericProperty> for SyntaxElement {
+    fn from(n: CssGenericProperty) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssFontFaceAtRule {
+impl AstNode for CssIdSelector {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_FONT_FACE_AT_RULE as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_ID_SELECTOR as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_FONT_FACE_AT_RULE
+        kind == CSS_ID_SELECTOR
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -13427,39 +13234,39 @@ impl AstNode for CssFontFaceAtRule {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssFontFaceAtRule {
+impl std::fmt::Debug for CssIdSelector {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssFontFaceAtRule")
-                .field("declarator", &support::DebugSyntaxResult(self.declarator()))
-                .field("block", &support::DebugSyntaxResult(self.block()))
+            f.debug_struct("CssIdSelector")
+                .field("hash_token", &support::DebugSyntaxResult(self.hash_token()))
+                .field("name", &support::DebugSyntaxResult(self.name()))
                 .finish()
         } else {
-            f.debug_struct("CssFontFaceAtRule").finish()
+            f.debug_struct("CssIdSelector").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssFontFaceAtRule> for SyntaxNode {
-    fn from(n: CssFontFaceAtRule) -> Self {
+impl From<CssIdSelector> for SyntaxNode {
+    fn from(n: CssIdSelector) -> Self {
         n.syntax
     }
 }
-impl From<CssFontFaceAtRule> for SyntaxElement {
-    fn from(n: CssFontFaceAtRule) -> Self {
+impl From<CssIdSelector> for SyntaxElement {
+    fn from(n: CssIdSelector) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssFontFaceAtRuleDeclarator {
+impl AstNode for CssIdentifier {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_FONT_FACE_AT_RULE_DECLARATOR as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_IDENTIFIER as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_FONT_FACE_AT_RULE_DECLARATOR
+        kind == CSS_IDENTIFIER
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -13475,41 +13282,41 @@ impl AstNode for CssFontFaceAtRuleDeclarator {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssFontFaceAtRuleDeclarator {
+impl std::fmt::Debug for CssIdentifier {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssFontFaceAtRuleDeclarator")
+            f.debug_struct("CssIdentifier")
                 .field(
-                    "font_face_token",
-                    &support::DebugSyntaxResult(self.font_face_token()),
+                    "value_token",
+                    &support::DebugSyntaxResult(self.value_token()),
                 )
                 .finish()
         } else {
-            f.debug_struct("CssFontFaceAtRuleDeclarator").finish()
+            f.debug_struct("CssIdentifier").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssFontFaceAtRuleDeclarator> for SyntaxNode {
-    fn from(n: CssFontFaceAtRuleDeclarator) -> Self {
+impl From<CssIdentifier> for SyntaxNode {
+    fn from(n: CssIdentifier) -> Self {
         n.syntax
     }
 }
-impl From<CssFontFaceAtRuleDeclarator> for SyntaxElement {
-    fn from(n: CssFontFaceAtRuleDeclarator) -> Self {
+impl From<CssIdentifier> for SyntaxElement {
+    fn from(n: CssIdentifier) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssFontFamilyName {
+impl AstNode for CssImportAnonymousLayer {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_FONT_FAMILY_NAME as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_IMPORT_ANONYMOUS_LAYER as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_FONT_FAMILY_NAME
+        kind == CSS_IMPORT_ANONYMOUS_LAYER
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -13525,38 +13332,41 @@ impl AstNode for CssFontFamilyName {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssFontFamilyName {
+impl std::fmt::Debug for CssImportAnonymousLayer {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssFontFamilyName")
-                .field("names", &self.names())
+            f.debug_struct("CssImportAnonymousLayer")
+                .field(
+                    "layer_token",
+                    &support::DebugSyntaxResult(self.layer_token()),
+                )
                 .finish()
         } else {
-            f.debug_struct("CssFontFamilyName").finish()
+            f.debug_struct("CssImportAnonymousLayer").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssFontFamilyName> for SyntaxNode {
-    fn from(n: CssFontFamilyName) -> Self {
+impl From<CssImportAnonymousLayer> for SyntaxNode {
+    fn from(n: CssImportAnonymousLayer) -> Self {
         n.syntax
     }
 }
-impl From<CssFontFamilyName> for SyntaxElement {
-    fn from(n: CssFontFamilyName) -> Self {
+impl From<CssImportAnonymousLayer> for SyntaxElement {
+    fn from(n: CssImportAnonymousLayer) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssFontFeatureValuesAtRule {
+impl AstNode for CssImportAtRule {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_FONT_FEATURE_VALUES_AT_RULE as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_IMPORT_AT_RULE as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_FONT_FEATURE_VALUES_AT_RULE
+        kind == CSS_IMPORT_AT_RULE
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -13572,43 +13382,49 @@ impl AstNode for CssFontFeatureValuesAtRule {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssFontFeatureValuesAtRule {
+impl std::fmt::Debug for CssImportAtRule {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssFontFeatureValuesAtRule")
+            f.debug_struct("CssImportAtRule")
                 .field(
-                    "font_feature_values_token",
-                    &support::DebugSyntaxResult(self.font_feature_values_token()),
+                    "import_token",
+                    &support::DebugSyntaxResult(self.import_token()),
+                )
+                .field("url", &support::DebugSyntaxResult(self.url()))
+                .field("layer", &support::DebugOptionalElement(self.layer()))
+                .field("supports", &support::DebugOptionalElement(self.supports()))
+                .field("media", &self.media())
+                .field(
+                    "semicolon_token",
+                    &support::DebugSyntaxResult(self.semicolon_token()),
                 )
-                .field("names", &self.names())
-                .field("block", &support::DebugSyntaxResult(self.block()))
                 .finish()
         } else {
-            f.debug_struct("CssFontFeatureValuesAtRule").finish()
+            f.debug_struct("CssImportAtRule").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssFontFeatureValuesAtRule> for SyntaxNode {
-    fn from(n: CssFontFeatureValuesAtRule) -> Self {
+impl From<CssImportAtRule> for SyntaxNode {
+    fn from(n: CssImportAtRule) -> Self {
         n.syntax
     }
 }
-impl From<CssFontFeatureValuesAtRule> for SyntaxElement {
-    fn from(n: CssFontFeatureValuesAtRule) -> Self {
+impl From<CssImportAtRule> for SyntaxElement {
+    fn from(n: CssImportAtRule) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssFontFeatureValuesBlock {
+impl AstNode for CssImportNamedLayer {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_FONT_FEATURE_VALUES_BLOCK as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_IMPORT_NAMED_LAYER as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_FONT_FEATURE_VALUES_BLOCK
+        kind == CSS_IMPORT_NAMED_LAYER
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -13624,46 +13440,50 @@ impl AstNode for CssFontFeatureValuesBlock {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssFontFeatureValuesBlock {
+impl std::fmt::Debug for CssImportNamedLayer {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssFontFeatureValuesBlock")
+            f.debug_struct("CssImportNamedLayer")
                 .field(
-                    "l_curly_token",
-                    &support::DebugSyntaxResult(self.l_curly_token()),
+                    "layer_token",
+                    &support::DebugSyntaxResult(self.layer_token()),
                 )
-                .field("items", &self.items())
                 .field(
-                    "r_curly_token",
-                    &support::DebugSyntaxResult(self.r_curly_token()),
+                    "l_paren_token",
+                    &support::DebugSyntaxResult(self.l_paren_token()),
+                )
+                .field("name", &self.name())
+                .field(
+                    "r_paren_token",
+                    &support::DebugSyntaxResult(self.r_paren_token()),
                 )
                 .finish()
         } else {
-            f.debug_struct("CssFontFeatureValuesBlock").finish()
+            f.debug_struct("CssImportNamedLayer").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssFontFeatureValuesBlock> for SyntaxNode {
-    fn from(n: CssFontFeatureValuesBlock) -> Self {
+impl From<CssImportNamedLayer> for SyntaxNode {
+    fn from(n: CssImportNamedLayer) -> Self {
         n.syntax
     }
 }
-impl From<CssFontFeatureValuesBlock> for SyntaxElement {
-    fn from(n: CssFontFeatureValuesBlock) -> Self {
+impl From<CssImportNamedLayer> for SyntaxElement {
+    fn from(n: CssImportNamedLayer) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssFontFeatureValuesItem {
+impl AstNode for CssImportSupports {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_FONT_FEATURE_VALUES_ITEM as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_IMPORT_SUPPORTS as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_FONT_FEATURE_VALUES_ITEM
+        kind == CSS_IMPORT_SUPPORTS
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -13679,40 +13499,50 @@ impl AstNode for CssFontFeatureValuesItem {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssFontFeatureValuesItem {
+impl std::fmt::Debug for CssImportSupports {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssFontFeatureValuesItem")
-                .field("at_token", &support::DebugSyntaxResult(self.at_token()))
-                .field("name", &support::DebugSyntaxResult(self.name()))
-                .field("block", &support::DebugSyntaxResult(self.block()))
+            f.debug_struct("CssImportSupports")
+                .field(
+                    "supports_token",
+                    &support::DebugSyntaxResult(self.supports_token()),
+                )
+                .field(
+                    "l_paren_token",
+                    &support::DebugSyntaxResult(self.l_paren_token()),
+                )
+                .field("condition", &support::DebugSyntaxResult(self.condition()))
+                .field(
+                    "r_paren_token",
+                    &support::DebugSyntaxResult(self.r_paren_token()),
+                )
                 .finish()
         } else {
-            f.debug_struct("CssFontFeatureValuesItem").finish()
+            f.debug_struct("CssImportSupports").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssFontFeatureValuesItem> for SyntaxNode {
-    fn from(n: CssFontFeatureValuesItem) -> Self {
+impl From<CssImportSupports> for SyntaxNode {
+    fn from(n: CssImportSupports) -> Self {
         n.syntax
     }
 }
-impl From<CssFontFeatureValuesItem> for SyntaxElement {
-    fn from(n: CssFontFeatureValuesItem) -> Self {
+impl From<CssImportSupports> for SyntaxElement {
+    fn from(n: CssImportSupports) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssFontPaletteValuesAtRule {
+impl AstNode for CssKeyframesAtRule {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_FONT_PALETTE_VALUES_AT_RULE as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_KEYFRAMES_AT_RULE as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_FONT_PALETTE_VALUES_AT_RULE
+        kind == CSS_KEYFRAMES_AT_RULE
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -13728,40 +13558,43 @@ impl AstNode for CssFontPaletteValuesAtRule {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssFontPaletteValuesAtRule {
+impl std::fmt::Debug for CssKeyframesAtRule {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssFontPaletteValuesAtRule")
-                .field("declarator", &support::DebugSyntaxResult(self.declarator()))
+            f.debug_struct("CssKeyframesAtRule")
+                .field(
+                    "keyframes_token",
+                    &support::DebugSyntaxResult(self.keyframes_token()),
+                )
+                .field("name", &support::DebugSyntaxResult(self.name()))
                 .field("block", &support::DebugSyntaxResult(self.block()))
                 .finish()
         } else {
-            f.debug_struct("CssFontPaletteValuesAtRule").finish()
+            f.debug_struct("CssKeyframesAtRule").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssFontPaletteValuesAtRule> for SyntaxNode {
-    fn from(n: CssFontPaletteValuesAtRule) -> Self {
+impl From<CssKeyframesAtRule> for SyntaxNode {
+    fn from(n: CssKeyframesAtRule) -> Self {
         n.syntax
     }
 }
-impl From<CssFontPaletteValuesAtRule> for SyntaxElement {
-    fn from(n: CssFontPaletteValuesAtRule) -> Self {
+impl From<CssKeyframesAtRule> for SyntaxElement {
+    fn from(n: CssKeyframesAtRule) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssFontPaletteValuesAtRuleDeclarator {
+impl AstNode for CssKeyframesBlock {
     type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> = SyntaxKindSet::from_raw(RawSyntaxKind(
-        CSS_FONT_PALETTE_VALUES_AT_RULE_DECLARATOR as u16,
-    ));
+    const KIND_SET: SyntaxKindSet<Language> =
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_KEYFRAMES_BLOCK as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_FONT_PALETTE_VALUES_AT_RULE_DECLARATOR
+        kind == CSS_KEYFRAMES_BLOCK
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -13777,43 +13610,46 @@ impl AstNode for CssFontPaletteValuesAtRuleDeclarator {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssFontPaletteValuesAtRuleDeclarator {
+impl std::fmt::Debug for CssKeyframesBlock {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssFontPaletteValuesAtRuleDeclarator")
+            f.debug_struct("CssKeyframesBlock")
                 .field(
-                    "font_palette_values_token",
-                    &support::DebugSyntaxResult(self.font_palette_values_token()),
+                    "l_curly_token",
+                    &support::DebugSyntaxResult(self.l_curly_token()),
+                )
+                .field("items", &self.items())
+                .field(
+                    "r_curly_token",
+                    &support::DebugSyntaxResult(self.r_curly_token()),
                 )
-                .field("name", &support::DebugSyntaxResult(self.name()))
                 .finish()
         } else {
-            f.debug_struct("CssFontPaletteValuesAtRuleDeclarator")
-                .finish()
+            f.debug_struct("CssKeyframesBlock").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssFontPaletteValuesAtRuleDeclarator> for SyntaxNode {
-    fn from(n: CssFontPaletteValuesAtRuleDeclarator) -> Self {
+impl From<CssKeyframesBlock> for SyntaxNode {
+    fn from(n: CssKeyframesBlock) -> Self {
         n.syntax
     }
 }
-impl From<CssFontPaletteValuesAtRuleDeclarator> for SyntaxElement {
-    fn from(n: CssFontPaletteValuesAtRuleDeclarator) -> Self {
+impl From<CssKeyframesBlock> for SyntaxElement {
+    fn from(n: CssKeyframesBlock) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssFunction {
+impl AstNode for CssKeyframesIdentSelector {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_FUNCTION as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_KEYFRAMES_IDENT_SELECTOR as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_FUNCTION
+        kind == CSS_KEYFRAMES_IDENT_SELECTOR
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -13829,47 +13665,38 @@ impl AstNode for CssFunction {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssFunction {
+impl std::fmt::Debug for CssKeyframesIdentSelector {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssFunction")
-                .field("name", &support::DebugSyntaxResult(self.name()))
-                .field(
-                    "l_paren_token",
-                    &support::DebugSyntaxResult(self.l_paren_token()),
-                )
-                .field("items", &self.items())
-                .field(
-                    "r_paren_token",
-                    &support::DebugSyntaxResult(self.r_paren_token()),
-                )
+            f.debug_struct("CssKeyframesIdentSelector")
+                .field("selector", &support::DebugSyntaxResult(self.selector()))
                 .finish()
         } else {
-            f.debug_struct("CssFunction").finish()
+            f.debug_struct("CssKeyframesIdentSelector").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssFunction> for SyntaxNode {
-    fn from(n: CssFunction) -> Self {
+impl From<CssKeyframesIdentSelector> for SyntaxNode {
+    fn from(n: CssKeyframesIdentSelector) -> Self {
         n.syntax
     }
 }
-impl From<CssFunction> for SyntaxElement {
-    fn from(n: CssFunction) -> Self {
+impl From<CssKeyframesIdentSelector> for SyntaxElement {
+    fn from(n: CssKeyframesIdentSelector) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssGenericDelimiter {
+impl AstNode for CssKeyframesItem {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_GENERIC_DELIMITER as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_KEYFRAMES_ITEM as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_GENERIC_DELIMITER
+        kind == CSS_KEYFRAMES_ITEM
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -13885,38 +13712,39 @@ impl AstNode for CssGenericDelimiter {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssGenericDelimiter {
+impl std::fmt::Debug for CssKeyframesItem {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssGenericDelimiter")
-                .field("value", &support::DebugSyntaxResult(self.value()))
+            f.debug_struct("CssKeyframesItem")
+                .field("selectors", &self.selectors())
+                .field("block", &support::DebugSyntaxResult(self.block()))
                 .finish()
         } else {
-            f.debug_struct("CssGenericDelimiter").finish()
+            f.debug_struct("CssKeyframesItem").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssGenericDelimiter> for SyntaxNode {
-    fn from(n: CssGenericDelimiter) -> Self {
+impl From<CssKeyframesItem> for SyntaxNode {
+    fn from(n: CssKeyframesItem) -> Self {
         n.syntax
     }
 }
-impl From<CssGenericDelimiter> for SyntaxElement {
-    fn from(n: CssGenericDelimiter) -> Self {
+impl From<CssKeyframesItem> for SyntaxElement {
+    fn from(n: CssKeyframesItem) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssGenericProperty {
+impl AstNode for CssKeyframesPercentageSelector {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_GENERIC_PROPERTY as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_KEYFRAMES_PERCENTAGE_SELECTOR as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_GENERIC_PROPERTY
+        kind == CSS_KEYFRAMES_PERCENTAGE_SELECTOR
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -13932,43 +13760,38 @@ impl AstNode for CssGenericProperty {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssGenericProperty {
+impl std::fmt::Debug for CssKeyframesPercentageSelector {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssGenericProperty")
-                .field("name", &support::DebugSyntaxResult(self.name()))
-                .field(
-                    "colon_token",
-                    &support::DebugSyntaxResult(self.colon_token()),
-                )
-                .field("value", &self.value())
+            f.debug_struct("CssKeyframesPercentageSelector")
+                .field("selector", &support::DebugSyntaxResult(self.selector()))
                 .finish()
         } else {
-            f.debug_struct("CssGenericProperty").finish()
+            f.debug_struct("CssKeyframesPercentageSelector").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssGenericProperty> for SyntaxNode {
-    fn from(n: CssGenericProperty) -> Self {
+impl From<CssKeyframesPercentageSelector> for SyntaxNode {
+    fn from(n: CssKeyframesPercentageSelector) -> Self {
         n.syntax
     }
 }
-impl From<CssGenericProperty> for SyntaxElement {
-    fn from(n: CssGenericProperty) -> Self {
+impl From<CssKeyframesPercentageSelector> for SyntaxElement {
+    fn from(n: CssKeyframesPercentageSelector) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssIdSelector {
+impl AstNode for CssKeyframesScopeFunction {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_ID_SELECTOR as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_KEYFRAMES_SCOPE_FUNCTION as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_ID_SELECTOR
+        kind == CSS_KEYFRAMES_SCOPE_FUNCTION
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -13984,39 +13807,47 @@ impl AstNode for CssIdSelector {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssIdSelector {
+impl std::fmt::Debug for CssKeyframesScopeFunction {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssIdSelector")
-                .field("hash_token", &support::DebugSyntaxResult(self.hash_token()))
+            f.debug_struct("CssKeyframesScopeFunction")
+                .field("scope", &support::DebugSyntaxResult(self.scope()))
+                .field(
+                    "l_paren_token",
+                    &support::DebugSyntaxResult(self.l_paren_token()),
+                )
                 .field("name", &support::DebugSyntaxResult(self.name()))
+                .field(
+                    "r_paren_token",
+                    &support::DebugSyntaxResult(self.r_paren_token()),
+                )
                 .finish()
         } else {
-            f.debug_struct("CssIdSelector").finish()
+            f.debug_struct("CssKeyframesScopeFunction").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssIdSelector> for SyntaxNode {
-    fn from(n: CssIdSelector) -> Self {
+impl From<CssKeyframesScopeFunction> for SyntaxNode {
+    fn from(n: CssKeyframesScopeFunction) -> Self {
         n.syntax
     }
 }
-impl From<CssIdSelector> for SyntaxElement {
-    fn from(n: CssIdSelector) -> Self {
+impl From<CssKeyframesScopeFunction> for SyntaxElement {
+    fn from(n: CssKeyframesScopeFunction) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssIdentifier {
+impl AstNode for CssKeyframesScopePrefix {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_IDENTIFIER as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_KEYFRAMES_SCOPE_PREFIX as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_IDENTIFIER
+        kind == CSS_KEYFRAMES_SCOPE_PREFIX
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -14032,41 +13863,39 @@ impl AstNode for CssIdentifier {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssIdentifier {
+impl std::fmt::Debug for CssKeyframesScopePrefix {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssIdentifier")
-                .field(
-                    "value_token",
-                    &support::DebugSyntaxResult(self.value_token()),
-                )
+            f.debug_struct("CssKeyframesScopePrefix")
+                .field("scope", &support::DebugSyntaxResult(self.scope()))
+                .field("name", &support::DebugSyntaxResult(self.name()))
                 .finish()
         } else {
-            f.debug_struct("CssIdentifier").finish()
+            f.debug_struct("CssKeyframesScopePrefix").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssIdentifier> for SyntaxNode {
-    fn from(n: CssIdentifier) -> Self {
+impl From<CssKeyframesScopePrefix> for SyntaxNode {
+    fn from(n: CssKeyframesScopePrefix) -> Self {
         n.syntax
     }
 }
-impl From<CssIdentifier> for SyntaxElement {
-    fn from(n: CssIdentifier) -> Self {
+impl From<CssKeyframesScopePrefix> for SyntaxElement {
+    fn from(n: CssKeyframesScopePrefix) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssIfBranch {
+impl AstNode for CssKeyframesScopedName {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_IF_BRANCH as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_KEYFRAMES_SCOPED_NAME as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_IF_BRANCH
+        kind == CSS_KEYFRAMES_SCOPED_NAME
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -14082,43 +13911,42 @@ impl AstNode for CssIfBranch {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssIfBranch {
+impl std::fmt::Debug for CssKeyframesScopedName {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssIfBranch")
-                .field("condition", &support::DebugSyntaxResult(self.condition()))
+            f.debug_struct("CssKeyframesScopedName")
                 .field(
                     "colon_token",
                     &support::DebugSyntaxResult(self.colon_token()),
                 )
-                .field("value", &self.value())
+                .field("scope", &support::DebugSyntaxResult(self.scope()))
                 .finish()
         } else {
-            f.debug_struct("CssIfBranch").finish()
+            f.debug_struct("CssKeyframesScopedName").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssIfBranch> for SyntaxNode {
-    fn from(n: CssIfBranch) -> Self {
+impl From<CssKeyframesScopedName> for SyntaxNode {
+    fn from(n: CssKeyframesScopedName) -> Self {
         n.syntax
     }
 }
-impl From<CssIfBranch> for SyntaxElement {
-    fn from(n: CssIfBranch) -> Self {
+impl From<CssKeyframesScopedName> for SyntaxElement {
+    fn from(n: CssKeyframesScopedName) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssIfFunction {
+impl AstNode for CssLayerAtRule {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_IF_FUNCTION as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_LAYER_AT_RULE as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_IF_FUNCTION
+        kind == CSS_LAYER_AT_RULE
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -14134,47 +13962,42 @@ impl AstNode for CssIfFunction {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssIfFunction {
+impl std::fmt::Debug for CssLayerAtRule {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssIfFunction")
-                .field("if_token", &support::DebugSyntaxResult(self.if_token()))
-                .field(
-                    "l_paren_token",
-                    &support::DebugSyntaxResult(self.l_paren_token()),
-                )
-                .field("css_if_branch_list", &self.css_if_branch_list())
+            f.debug_struct("CssLayerAtRule")
                 .field(
-                    "r_paren_token",
-                    &support::DebugSyntaxResult(self.r_paren_token()),
+                    "layer_token",
+                    &support::DebugSyntaxResult(self.layer_token()),
                 )
+                .field("layer", &support::DebugSyntaxResult(self.layer()))
                 .finish()
         } else {
-            f.debug_struct("CssIfFunction").finish()
+            f.debug_struct("CssLayerAtRule").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssIfFunction> for SyntaxNode {
-    fn from(n: CssIfFunction) -> Self {
+impl From<CssLayerAtRule> for SyntaxNode {
+    fn from(n: CssLayerAtRule) -> Self {
         n.syntax
     }
 }
-impl From<CssIfFunction> for SyntaxElement {
-    fn from(n: CssIfFunction) -> Self {
+impl From<CssLayerAtRule> for SyntaxElement {
+    fn from(n: CssLayerAtRule) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssIfMediaTest {
+impl AstNode for CssLayerDeclaration {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_IF_MEDIA_TEST as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_LAYER_DECLARATION as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_IF_MEDIA_TEST
+        kind == CSS_LAYER_DECLARATION
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -14190,50 +14013,39 @@ impl AstNode for CssIfMediaTest {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssIfMediaTest {
+impl std::fmt::Debug for CssLayerDeclaration {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssIfMediaTest")
-                .field(
-                    "media_token",
-                    &support::DebugSyntaxResult(self.media_token()),
-                )
-                .field(
-                    "l_paren_token",
-                    &support::DebugSyntaxResult(self.l_paren_token()),
-                )
-                .field("test", &support::DebugSyntaxResult(self.test()))
-                .field(
-                    "r_paren_token",
-                    &support::DebugSyntaxResult(self.r_paren_token()),
-                )
+            f.debug_struct("CssLayerDeclaration")
+                .field("references", &self.references())
+                .field("block", &support::DebugSyntaxResult(self.block()))
                 .finish()
         } else {
-            f.debug_struct("CssIfMediaTest").finish()
+            f.debug_struct("CssLayerDeclaration").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssIfMediaTest> for SyntaxNode {
-    fn from(n: CssIfMediaTest) -> Self {
+impl From<CssLayerDeclaration> for SyntaxNode {
+    fn from(n: CssLayerDeclaration) -> Self {
         n.syntax
     }
 }
-impl From<CssIfMediaTest> for SyntaxElement {
-    fn from(n: CssIfMediaTest) -> Self {
+impl From<CssLayerDeclaration> for SyntaxElement {
+    fn from(n: CssLayerDeclaration) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssIfStyleTest {
+impl AstNode for CssLayerReference {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_IF_STYLE_TEST as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_LAYER_REFERENCE as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_IF_STYLE_TEST
+        kind == CSS_LAYER_REFERENCE
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -14249,50 +14061,43 @@ impl AstNode for CssIfStyleTest {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssIfStyleTest {
+impl std::fmt::Debug for CssLayerReference {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssIfStyleTest")
-                .field(
-                    "style_token",
-                    &support::DebugSyntaxResult(self.style_token()),
-                )
-                .field(
-                    "l_paren_token",
-                    &support::DebugSyntaxResult(self.l_paren_token()),
-                )
-                .field("test", &support::DebugSyntaxResult(self.test()))
+            f.debug_struct("CssLayerReference")
+                .field("references", &self.references())
                 .field(
-                    "r_paren_token",
-                    &support::DebugSyntaxResult(self.r_paren_token()),
+                    "semicolon_token",
+                    &support::DebugSyntaxResult(self.semicolon_token()),
                 )
                 .finish()
         } else {
-            f.debug_struct("CssIfStyleTest").finish()
+            f.debug_struct("CssLayerReference").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssIfStyleTest> for SyntaxNode {
-    fn from(n: CssIfStyleTest) -> Self {
+impl From<CssLayerReference> for SyntaxNode {
+    fn from(n: CssLayerReference) -> Self {
         n.syntax
     }
 }
-impl From<CssIfStyleTest> for SyntaxElement {
-    fn from(n: CssIfStyleTest) -> Self {
+impl From<CssLayerReference> for SyntaxElement {
+    fn from(n: CssLayerReference) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssIfSupportsIdentifierTest {
+impl AstNode for CssListOfComponentValuesExpression {
     type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_IF_SUPPORTS_IDENTIFIER_TEST as u16));
+    const KIND_SET: SyntaxKindSet<Language> = SyntaxKindSet::from_raw(RawSyntaxKind(
+        CSS_LIST_OF_COMPONENT_VALUES_EXPRESSION as u16,
+    ));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_IF_SUPPORTS_IDENTIFIER_TEST
+        kind == CSS_LIST_OF_COMPONENT_VALUES_EXPRESSION
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -14308,43 +14113,39 @@ impl AstNode for CssIfSupportsIdentifierTest {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssIfSupportsIdentifierTest {
+impl std::fmt::Debug for CssListOfComponentValuesExpression {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssIfSupportsIdentifierTest")
-                .field("ident", &support::DebugSyntaxResult(self.ident()))
-                .field(
-                    "colon_token",
-                    &support::DebugSyntaxResult(self.colon_token()),
-                )
-                .field("value", &support::DebugSyntaxResult(self.value()))
+            f.debug_struct("CssListOfComponentValuesExpression")
+                .field("css_component_value_list", &self.css_component_value_list())
                 .finish()
         } else {
-            f.debug_struct("CssIfSupportsIdentifierTest").finish()
+            f.debug_struct("CssListOfComponentValuesExpression")
+                .finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssIfSupportsIdentifierTest> for SyntaxNode {
-    fn from(n: CssIfSupportsIdentifierTest) -> Self {
+impl From<CssListOfComponentValuesExpression> for SyntaxNode {
+    fn from(n: CssListOfComponentValuesExpression) -> Self {
         n.syntax
     }
 }
-impl From<CssIfSupportsIdentifierTest> for SyntaxElement {
-    fn from(n: CssIfSupportsIdentifierTest) -> Self {
+impl From<CssListOfComponentValuesExpression> for SyntaxElement {
+    fn from(n: CssListOfComponentValuesExpression) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssIfSupportsTest {
+impl AstNode for CssMarginAtRule {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_IF_SUPPORTS_TEST as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_MARGIN_AT_RULE as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_IF_SUPPORTS_TEST
+        kind == CSS_MARGIN_AT_RULE
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -14360,50 +14161,40 @@ impl AstNode for CssIfSupportsTest {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssIfSupportsTest {
+impl std::fmt::Debug for CssMarginAtRule {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssIfSupportsTest")
-                .field(
-                    "supports_token",
-                    &support::DebugSyntaxResult(self.supports_token()),
-                )
-                .field(
-                    "l_paren_token",
-                    &support::DebugSyntaxResult(self.l_paren_token()),
-                )
-                .field("test", &support::DebugSyntaxResult(self.test()))
-                .field(
-                    "r_paren_token",
-                    &support::DebugSyntaxResult(self.r_paren_token()),
-                )
+            f.debug_struct("CssMarginAtRule")
+                .field("at_token", &support::DebugSyntaxResult(self.at_token()))
+                .field("name", &support::DebugSyntaxResult(self.name()))
+                .field("block", &support::DebugSyntaxResult(self.block()))
                 .finish()
         } else {
-            f.debug_struct("CssIfSupportsTest").finish()
+            f.debug_struct("CssMarginAtRule").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssIfSupportsTest> for SyntaxNode {
-    fn from(n: CssIfSupportsTest) -> Self {
+impl From<CssMarginAtRule> for SyntaxNode {
+    fn from(n: CssMarginAtRule) -> Self {
         n.syntax
     }
 }
-impl From<CssIfSupportsTest> for SyntaxElement {
-    fn from(n: CssIfSupportsTest) -> Self {
+impl From<CssMarginAtRule> for SyntaxElement {
+    fn from(n: CssMarginAtRule) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssIfTestBooleanAndExpr {
+impl AstNode for CssMediaAndCondition {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_IF_TEST_BOOLEAN_AND_EXPR as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_MEDIA_AND_CONDITION as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_IF_TEST_BOOLEAN_AND_EXPR
+        kind == CSS_MEDIA_AND_CONDITION
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -14419,40 +14210,40 @@ impl AstNode for CssIfTestBooleanAndExpr {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssIfTestBooleanAndExpr {
+impl std::fmt::Debug for CssMediaAndCondition {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssIfTestBooleanAndExpr")
+            f.debug_struct("CssMediaAndCondition")
                 .field("left", &support::DebugSyntaxResult(self.left()))
                 .field("and_token", &support::DebugSyntaxResult(self.and_token()))
                 .field("right", &support::DebugSyntaxResult(self.right()))
                 .finish()
         } else {
-            f.debug_struct("CssIfTestBooleanAndExpr").finish()
+            f.debug_struct("CssMediaAndCondition").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssIfTestBooleanAndExpr> for SyntaxNode {
-    fn from(n: CssIfTestBooleanAndExpr) -> Self {
+impl From<CssMediaAndCondition> for SyntaxNode {
+    fn from(n: CssMediaAndCondition) -> Self {
         n.syntax
     }
 }
-impl From<CssIfTestBooleanAndExpr> for SyntaxElement {
-    fn from(n: CssIfTestBooleanAndExpr) -> Self {
+impl From<CssMediaAndCondition> for SyntaxElement {
+    fn from(n: CssMediaAndCondition) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssIfTestBooleanExprInParens {
+impl AstNode for CssMediaAndTypeQuery {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_IF_TEST_BOOLEAN_EXPR_IN_PARENS as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_MEDIA_AND_TYPE_QUERY as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_IF_TEST_BOOLEAN_EXPR_IN_PARENS
+        kind == CSS_MEDIA_AND_TYPE_QUERY
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -14468,46 +14259,40 @@ impl AstNode for CssIfTestBooleanExprInParens {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssIfTestBooleanExprInParens {
+impl std::fmt::Debug for CssMediaAndTypeQuery {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssIfTestBooleanExprInParens")
-                .field(
-                    "l_paren_token",
-                    &support::DebugSyntaxResult(self.l_paren_token()),
-                )
-                .field("expression", &support::DebugSyntaxResult(self.expression()))
-                .field(
-                    "r_paren_token",
-                    &support::DebugSyntaxResult(self.r_paren_token()),
-                )
+            f.debug_struct("CssMediaAndTypeQuery")
+                .field("left", &support::DebugSyntaxResult(self.left()))
+                .field("and_token", &support::DebugSyntaxResult(self.and_token()))
+                .field("right", &support::DebugSyntaxResult(self.right()))
                 .finish()
         } else {
-            f.debug_struct("CssIfTestBooleanExprInParens").finish()
+            f.debug_struct("CssMediaAndTypeQuery").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssIfTestBooleanExprInParens> for SyntaxNode {
-    fn from(n: CssIfTestBooleanExprInParens) -> Self {
+impl From<CssMediaAndTypeQuery> for SyntaxNode {
+    fn from(n: CssMediaAndTypeQuery) -> Self {
         n.syntax
     }
 }
-impl From<CssIfTestBooleanExprInParens> for SyntaxElement {
-    fn from(n: CssIfTestBooleanExprInParens) -> Self {
+impl From<CssMediaAndTypeQuery> for SyntaxElement {
+    fn from(n: CssMediaAndTypeQuery) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssIfTestBooleanNotExpr {
+impl AstNode for CssMediaAtRule {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_IF_TEST_BOOLEAN_NOT_EXPR as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_MEDIA_AT_RULE as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_IF_TEST_BOOLEAN_NOT_EXPR
+        kind == CSS_MEDIA_AT_RULE
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -14523,39 +14308,39 @@ impl AstNode for CssIfTestBooleanNotExpr {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssIfTestBooleanNotExpr {
+impl std::fmt::Debug for CssMediaAtRule {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssIfTestBooleanNotExpr")
-                .field("not_token", &support::DebugSyntaxResult(self.not_token()))
-                .field("expression", &support::DebugSyntaxResult(self.expression()))
+            f.debug_struct("CssMediaAtRule")
+                .field("declarator", &support::DebugSyntaxResult(self.declarator()))
+                .field("block", &support::DebugSyntaxResult(self.block()))
                 .finish()
         } else {
-            f.debug_struct("CssIfTestBooleanNotExpr").finish()
+            f.debug_struct("CssMediaAtRule").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssIfTestBooleanNotExpr> for SyntaxNode {
-    fn from(n: CssIfTestBooleanNotExpr) -> Self {
+impl From<CssMediaAtRule> for SyntaxNode {
+    fn from(n: CssMediaAtRule) -> Self {
         n.syntax
     }
 }
-impl From<CssIfTestBooleanNotExpr> for SyntaxElement {
-    fn from(n: CssIfTestBooleanNotExpr) -> Self {
+impl From<CssMediaAtRule> for SyntaxElement {
+    fn from(n: CssMediaAtRule) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssIfTestBooleanOrExpr {
+impl AstNode for CssMediaAtRuleDeclarator {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_IF_TEST_BOOLEAN_OR_EXPR as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_MEDIA_AT_RULE_DECLARATOR as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_IF_TEST_BOOLEAN_OR_EXPR
+        kind == CSS_MEDIA_AT_RULE_DECLARATOR
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -14571,40 +14356,42 @@ impl AstNode for CssIfTestBooleanOrExpr {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssIfTestBooleanOrExpr {
+impl std::fmt::Debug for CssMediaAtRuleDeclarator {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssIfTestBooleanOrExpr")
-                .field("left", &support::DebugSyntaxResult(self.left()))
-                .field("or_token", &support::DebugSyntaxResult(self.or_token()))
-                .field("right", &support::DebugSyntaxResult(self.right()))
+            f.debug_struct("CssMediaAtRuleDeclarator")
+                .field(
+                    "media_token",
+                    &support::DebugSyntaxResult(self.media_token()),
+                )
+                .field("queries", &self.queries())
                 .finish()
         } else {
-            f.debug_struct("CssIfTestBooleanOrExpr").finish()
+            f.debug_struct("CssMediaAtRuleDeclarator").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssIfTestBooleanOrExpr> for SyntaxNode {
-    fn from(n: CssIfTestBooleanOrExpr) -> Self {
+impl From<CssMediaAtRuleDeclarator> for SyntaxNode {
+    fn from(n: CssMediaAtRuleDeclarator) -> Self {
         n.syntax
     }
 }
-impl From<CssIfTestBooleanOrExpr> for SyntaxElement {
-    fn from(n: CssIfTestBooleanOrExpr) -> Self {
+impl From<CssMediaAtRuleDeclarator> for SyntaxElement {
+    fn from(n: CssMediaAtRuleDeclarator) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssImportAnonymousLayer {
+impl AstNode for CssMediaConditionInParens {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_IMPORT_ANONYMOUS_LAYER as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_MEDIA_CONDITION_IN_PARENS as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_IMPORT_ANONYMOUS_LAYER
+        kind == CSS_MEDIA_CONDITION_IN_PARENS
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -14620,41 +14407,46 @@ impl AstNode for CssImportAnonymousLayer {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssImportAnonymousLayer {
+impl std::fmt::Debug for CssMediaConditionInParens {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssImportAnonymousLayer")
+            f.debug_struct("CssMediaConditionInParens")
                 .field(
-                    "layer_token",
-                    &support::DebugSyntaxResult(self.layer_token()),
+                    "l_paren_token",
+                    &support::DebugSyntaxResult(self.l_paren_token()),
+                )
+                .field("condition", &support::DebugSyntaxResult(self.condition()))
+                .field(
+                    "r_paren_token",
+                    &support::DebugSyntaxResult(self.r_paren_token()),
                 )
                 .finish()
         } else {
-            f.debug_struct("CssImportAnonymousLayer").finish()
+            f.debug_struct("CssMediaConditionInParens").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssImportAnonymousLayer> for SyntaxNode {
-    fn from(n: CssImportAnonymousLayer) -> Self {
+impl From<CssMediaConditionInParens> for SyntaxNode {
+    fn from(n: CssMediaConditionInParens) -> Self {
         n.syntax
     }
 }
-impl From<CssImportAnonymousLayer> for SyntaxElement {
-    fn from(n: CssImportAnonymousLayer) -> Self {
+impl From<CssMediaConditionInParens> for SyntaxElement {
+    fn from(n: CssMediaConditionInParens) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssImportAtRule {
+impl AstNode for CssMediaConditionQuery {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_IMPORT_AT_RULE as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_MEDIA_CONDITION_QUERY as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_IMPORT_AT_RULE
+        kind == CSS_MEDIA_CONDITION_QUERY
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -14670,49 +14462,38 @@ impl AstNode for CssImportAtRule {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssImportAtRule {
+impl std::fmt::Debug for CssMediaConditionQuery {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssImportAtRule")
-                .field(
-                    "import_token",
-                    &support::DebugSyntaxResult(self.import_token()),
-                )
-                .field("url", &support::DebugSyntaxResult(self.url()))
-                .field("layer", &support::DebugOptionalElement(self.layer()))
-                .field("supports", &support::DebugOptionalElement(self.supports()))
-                .field("media", &self.media())
-                .field(
-                    "semicolon_token",
-                    &support::DebugSyntaxResult(self.semicolon_token()),
-                )
+            f.debug_struct("CssMediaConditionQuery")
+                .field("condition", &support::DebugSyntaxResult(self.condition()))
                 .finish()
         } else {
-            f.debug_struct("CssImportAtRule").finish()
+            f.debug_struct("CssMediaConditionQuery").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssImportAtRule> for SyntaxNode {
-    fn from(n: CssImportAtRule) -> Self {
+impl From<CssMediaConditionQuery> for SyntaxNode {
+    fn from(n: CssMediaConditionQuery) -> Self {
         n.syntax
     }
 }
-impl From<CssImportAtRule> for SyntaxElement {
-    fn from(n: CssImportAtRule) -> Self {
+impl From<CssMediaConditionQuery> for SyntaxElement {
+    fn from(n: CssMediaConditionQuery) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssImportNamedLayer {
+impl AstNode for CssMediaFeatureInParens {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_IMPORT_NAMED_LAYER as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_MEDIA_FEATURE_IN_PARENS as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_IMPORT_NAMED_LAYER
+        kind == CSS_MEDIA_FEATURE_IN_PARENS
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -14728,50 +14509,46 @@ impl AstNode for CssImportNamedLayer {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssImportNamedLayer {
+impl std::fmt::Debug for CssMediaFeatureInParens {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssImportNamedLayer")
-                .field(
-                    "layer_token",
-                    &support::DebugSyntaxResult(self.layer_token()),
-                )
+            f.debug_struct("CssMediaFeatureInParens")
                 .field(
                     "l_paren_token",
                     &support::DebugSyntaxResult(self.l_paren_token()),
                 )
-                .field("name", &self.name())
+                .field("feature", &support::DebugSyntaxResult(self.feature()))
                 .field(
                     "r_paren_token",
                     &support::DebugSyntaxResult(self.r_paren_token()),
                 )
                 .finish()
         } else {
-            f.debug_struct("CssImportNamedLayer").finish()
+            f.debug_struct("CssMediaFeatureInParens").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssImportNamedLayer> for SyntaxNode {
-    fn from(n: CssImportNamedLayer) -> Self {
+impl From<CssMediaFeatureInParens> for SyntaxNode {
+    fn from(n: CssMediaFeatureInParens) -> Self {
         n.syntax
     }
 }
-impl From<CssImportNamedLayer> for SyntaxElement {
-    fn from(n: CssImportNamedLayer) -> Self {
+impl From<CssMediaFeatureInParens> for SyntaxElement {
+    fn from(n: CssMediaFeatureInParens) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssImportSupports {
+impl AstNode for CssMediaNotCondition {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_IMPORT_SUPPORTS as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_MEDIA_NOT_CONDITION as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_IMPORT_SUPPORTS
+        kind == CSS_MEDIA_NOT_CONDITION
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -14787,50 +14564,39 @@ impl AstNode for CssImportSupports {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssImportSupports {
+impl std::fmt::Debug for CssMediaNotCondition {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssImportSupports")
-                .field(
-                    "supports_token",
-                    &support::DebugSyntaxResult(self.supports_token()),
-                )
-                .field(
-                    "l_paren_token",
-                    &support::DebugSyntaxResult(self.l_paren_token()),
-                )
+            f.debug_struct("CssMediaNotCondition")
+                .field("not_token", &support::DebugSyntaxResult(self.not_token()))
                 .field("condition", &support::DebugSyntaxResult(self.condition()))
-                .field(
-                    "r_paren_token",
-                    &support::DebugSyntaxResult(self.r_paren_token()),
-                )
                 .finish()
         } else {
-            f.debug_struct("CssImportSupports").finish()
+            f.debug_struct("CssMediaNotCondition").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssImportSupports> for SyntaxNode {
-    fn from(n: CssImportSupports) -> Self {
+impl From<CssMediaNotCondition> for SyntaxNode {
+    fn from(n: CssMediaNotCondition) -> Self {
         n.syntax
     }
 }
-impl From<CssImportSupports> for SyntaxElement {
-    fn from(n: CssImportSupports) -> Self {
+impl From<CssMediaNotCondition> for SyntaxElement {
+    fn from(n: CssMediaNotCondition) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssKeyframesAtRule {
+impl AstNode for CssMediaOrCondition {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_KEYFRAMES_AT_RULE as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_MEDIA_OR_CONDITION as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_KEYFRAMES_AT_RULE
+        kind == CSS_MEDIA_OR_CONDITION
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -14846,43 +14612,40 @@ impl AstNode for CssKeyframesAtRule {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssKeyframesAtRule {
+impl std::fmt::Debug for CssMediaOrCondition {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssKeyframesAtRule")
-                .field(
-                    "keyframes_token",
-                    &support::DebugSyntaxResult(self.keyframes_token()),
-                )
-                .field("name", &support::DebugSyntaxResult(self.name()))
-                .field("block", &support::DebugSyntaxResult(self.block()))
+            f.debug_struct("CssMediaOrCondition")
+                .field("left", &support::DebugSyntaxResult(self.left()))
+                .field("or_token", &support::DebugSyntaxResult(self.or_token()))
+                .field("right", &support::DebugSyntaxResult(self.right()))
                 .finish()
         } else {
-            f.debug_struct("CssKeyframesAtRule").finish()
+            f.debug_struct("CssMediaOrCondition").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssKeyframesAtRule> for SyntaxNode {
-    fn from(n: CssKeyframesAtRule) -> Self {
+impl From<CssMediaOrCondition> for SyntaxNode {
+    fn from(n: CssMediaOrCondition) -> Self {
         n.syntax
     }
 }
-impl From<CssKeyframesAtRule> for SyntaxElement {
-    fn from(n: CssKeyframesAtRule) -> Self {
+impl From<CssMediaOrCondition> for SyntaxElement {
+    fn from(n: CssMediaOrCondition) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssKeyframesBlock {
+impl AstNode for CssMediaType {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_KEYFRAMES_BLOCK as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_MEDIA_TYPE as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_KEYFRAMES_BLOCK
+        kind == CSS_MEDIA_TYPE
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -14898,46 +14661,38 @@ impl AstNode for CssKeyframesBlock {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssKeyframesBlock {
+impl std::fmt::Debug for CssMediaType {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssKeyframesBlock")
-                .field(
-                    "l_curly_token",
-                    &support::DebugSyntaxResult(self.l_curly_token()),
-                )
-                .field("items", &self.items())
-                .field(
-                    "r_curly_token",
-                    &support::DebugSyntaxResult(self.r_curly_token()),
-                )
+            f.debug_struct("CssMediaType")
+                .field("value", &support::DebugSyntaxResult(self.value()))
                 .finish()
         } else {
-            f.debug_struct("CssKeyframesBlock").finish()
+            f.debug_struct("CssMediaType").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssKeyframesBlock> for SyntaxNode {
-    fn from(n: CssKeyframesBlock) -> Self {
+impl From<CssMediaType> for SyntaxNode {
+    fn from(n: CssMediaType) -> Self {
         n.syntax
     }
 }
-impl From<CssKeyframesBlock> for SyntaxElement {
-    fn from(n: CssKeyframesBlock) -> Self {
+impl From<CssMediaType> for SyntaxElement {
+    fn from(n: CssMediaType) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssKeyframesIdentSelector {
+impl AstNode for CssMediaTypeQuery {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_KEYFRAMES_IDENT_SELECTOR as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_MEDIA_TYPE_QUERY as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_KEYFRAMES_IDENT_SELECTOR
+        kind == CSS_MEDIA_TYPE_QUERY
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -14953,38 +14708,39 @@ impl AstNode for CssKeyframesIdentSelector {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssKeyframesIdentSelector {
+impl std::fmt::Debug for CssMediaTypeQuery {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssKeyframesIdentSelector")
-                .field("selector", &support::DebugSyntaxResult(self.selector()))
+            f.debug_struct("CssMediaTypeQuery")
+                .field("modifier", &support::DebugOptionalElement(self.modifier()))
+                .field("ty", &support::DebugSyntaxResult(self.ty()))
                 .finish()
         } else {
-            f.debug_struct("CssKeyframesIdentSelector").finish()
+            f.debug_struct("CssMediaTypeQuery").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssKeyframesIdentSelector> for SyntaxNode {
-    fn from(n: CssKeyframesIdentSelector) -> Self {
+impl From<CssMediaTypeQuery> for SyntaxNode {
+    fn from(n: CssMediaTypeQuery) -> Self {
         n.syntax
     }
 }
-impl From<CssKeyframesIdentSelector> for SyntaxElement {
-    fn from(n: CssKeyframesIdentSelector) -> Self {
+impl From<CssMediaTypeQuery> for SyntaxElement {
+    fn from(n: CssMediaTypeQuery) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssKeyframesItem {
+impl AstNode for CssMetavariable {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_KEYFRAMES_ITEM as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_METAVARIABLE as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_KEYFRAMES_ITEM
+        kind == CSS_METAVARIABLE
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -15000,39 +14756,41 @@ impl AstNode for CssKeyframesItem {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssKeyframesItem {
+impl std::fmt::Debug for CssMetavariable {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssKeyframesItem")
-                .field("selectors", &self.selectors())
-                .field("block", &support::DebugSyntaxResult(self.block()))
+            f.debug_struct("CssMetavariable")
+                .field(
+                    "value_token",
+                    &support::DebugSyntaxResult(self.value_token()),
+                )
                 .finish()
         } else {
-            f.debug_struct("CssKeyframesItem").finish()
+            f.debug_struct("CssMetavariable").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssKeyframesItem> for SyntaxNode {
-    fn from(n: CssKeyframesItem) -> Self {
+impl From<CssMetavariable> for SyntaxNode {
+    fn from(n: CssMetavariable) -> Self {
         n.syntax
     }
 }
-impl From<CssKeyframesItem> for SyntaxElement {
-    fn from(n: CssKeyframesItem) -> Self {
+impl From<CssMetavariable> for SyntaxElement {
+    fn from(n: CssMetavariable) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssKeyframesPercentageSelector {
+impl AstNode for CssNamedNamespacePrefix {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_KEYFRAMES_PERCENTAGE_SELECTOR as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_NAMED_NAMESPACE_PREFIX as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_KEYFRAMES_PERCENTAGE_SELECTOR
+        kind == CSS_NAMED_NAMESPACE_PREFIX
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -15048,38 +14806,38 @@ impl AstNode for CssKeyframesPercentageSelector {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssKeyframesPercentageSelector {
+impl std::fmt::Debug for CssNamedNamespacePrefix {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssKeyframesPercentageSelector")
-                .field("selector", &support::DebugSyntaxResult(self.selector()))
+            f.debug_struct("CssNamedNamespacePrefix")
+                .field("name", &support::DebugSyntaxResult(self.name()))
                 .finish()
         } else {
-            f.debug_struct("CssKeyframesPercentageSelector").finish()
+            f.debug_struct("CssNamedNamespacePrefix").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssKeyframesPercentageSelector> for SyntaxNode {
-    fn from(n: CssKeyframesPercentageSelector) -> Self {
+impl From<CssNamedNamespacePrefix> for SyntaxNode {
+    fn from(n: CssNamedNamespacePrefix) -> Self {
         n.syntax
     }
 }
-impl From<CssKeyframesPercentageSelector> for SyntaxElement {
-    fn from(n: CssKeyframesPercentageSelector) -> Self {
+impl From<CssNamedNamespacePrefix> for SyntaxElement {
+    fn from(n: CssNamedNamespacePrefix) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssKeyframesScopeFunction {
+impl AstNode for CssNamespace {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_KEYFRAMES_SCOPE_FUNCTION as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_NAMESPACE as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_KEYFRAMES_SCOPE_FUNCTION
+        kind == CSS_NAMESPACE
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -15095,47 +14853,42 @@ impl AstNode for CssKeyframesScopeFunction {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssKeyframesScopeFunction {
+impl std::fmt::Debug for CssNamespace {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssKeyframesScopeFunction")
-                .field("scope", &support::DebugSyntaxResult(self.scope()))
-                .field(
-                    "l_paren_token",
-                    &support::DebugSyntaxResult(self.l_paren_token()),
-                )
-                .field("name", &support::DebugSyntaxResult(self.name()))
+            f.debug_struct("CssNamespace")
+                .field("prefix", &support::DebugOptionalElement(self.prefix()))
                 .field(
-                    "r_paren_token",
-                    &support::DebugSyntaxResult(self.r_paren_token()),
+                    "bitwise_or_token",
+                    &support::DebugSyntaxResult(self.bitwise_or_token()),
                 )
                 .finish()
         } else {
-            f.debug_struct("CssKeyframesScopeFunction").finish()
+            f.debug_struct("CssNamespace").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssKeyframesScopeFunction> for SyntaxNode {
-    fn from(n: CssKeyframesScopeFunction) -> Self {
+impl From<CssNamespace> for SyntaxNode {
+    fn from(n: CssNamespace) -> Self {
         n.syntax
     }
 }
-impl From<CssKeyframesScopeFunction> for SyntaxElement {
-    fn from(n: CssKeyframesScopeFunction) -> Self {
+impl From<CssNamespace> for SyntaxElement {
+    fn from(n: CssNamespace) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssKeyframesScopePrefix {
+impl AstNode for CssNamespaceAtRule {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_KEYFRAMES_SCOPE_PREFIX as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_NAMESPACE_AT_RULE as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_KEYFRAMES_SCOPE_PREFIX
+        kind == CSS_NAMESPACE_AT_RULE
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -15151,39 +14904,47 @@ impl AstNode for CssKeyframesScopePrefix {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssKeyframesScopePrefix {
+impl std::fmt::Debug for CssNamespaceAtRule {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssKeyframesScopePrefix")
-                .field("scope", &support::DebugSyntaxResult(self.scope()))
-                .field("name", &support::DebugSyntaxResult(self.name()))
+            f.debug_struct("CssNamespaceAtRule")
+                .field(
+                    "namespace_token",
+                    &support::DebugSyntaxResult(self.namespace_token()),
+                )
+                .field("prefix", &support::DebugOptionalElement(self.prefix()))
+                .field("url", &support::DebugSyntaxResult(self.url()))
+                .field(
+                    "semicolon_token",
+                    &support::DebugSyntaxResult(self.semicolon_token()),
+                )
                 .finish()
         } else {
-            f.debug_struct("CssKeyframesScopePrefix").finish()
+            f.debug_struct("CssNamespaceAtRule").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssKeyframesScopePrefix> for SyntaxNode {
-    fn from(n: CssKeyframesScopePrefix) -> Self {
+impl From<CssNamespaceAtRule> for SyntaxNode {
+    fn from(n: CssNamespaceAtRule) -> Self {
         n.syntax
     }
 }
-impl From<CssKeyframesScopePrefix> for SyntaxElement {
-    fn from(n: CssKeyframesScopePrefix) -> Self {
+impl From<CssNamespaceAtRule> for SyntaxElement {
+    fn from(n: CssNamespaceAtRule) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssKeyframesScopedName {
+impl AstNode for CssNestedQualifiedRule {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_KEYFRAMES_SCOPED_NAME as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_NESTED_QUALIFIED_RULE as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_KEYFRAMES_SCOPED_NAME
+        kind == CSS_NESTED_QUALIFIED_RULE
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -15199,42 +14960,39 @@ impl AstNode for CssKeyframesScopedName {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssKeyframesScopedName {
+impl std::fmt::Debug for CssNestedQualifiedRule {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssKeyframesScopedName")
-                .field(
-                    "colon_token",
-                    &support::DebugSyntaxResult(self.colon_token()),
-                )
-                .field("scope", &support::DebugSyntaxResult(self.scope()))
+            f.debug_struct("CssNestedQualifiedRule")
+                .field("prelude", &self.prelude())
+                .field("block", &support::DebugSyntaxResult(self.block()))
                 .finish()
         } else {
-            f.debug_struct("CssKeyframesScopedName").finish()
+            f.debug_struct("CssNestedQualifiedRule").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssKeyframesScopedName> for SyntaxNode {
-    fn from(n: CssKeyframesScopedName) -> Self {
+impl From<CssNestedQualifiedRule> for SyntaxNode {
+    fn from(n: CssNestedQualifiedRule) -> Self {
         n.syntax
     }
 }
-impl From<CssKeyframesScopedName> for SyntaxElement {
-    fn from(n: CssKeyframesScopedName) -> Self {
+impl From<CssNestedQualifiedRule> for SyntaxElement {
+    fn from(n: CssNestedQualifiedRule) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssLayerAtRule {
+impl AstNode for CssNestedSelector {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_LAYER_AT_RULE as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_NESTED_SELECTOR as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_LAYER_AT_RULE
+        kind == CSS_NESTED_SELECTOR
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -15250,42 +15008,38 @@ impl AstNode for CssLayerAtRule {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssLayerAtRule {
+impl std::fmt::Debug for CssNestedSelector {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssLayerAtRule")
-                .field(
-                    "layer_token",
-                    &support::DebugSyntaxResult(self.layer_token()),
-                )
-                .field("layer", &support::DebugSyntaxResult(self.layer()))
+            f.debug_struct("CssNestedSelector")
+                .field("amp_token", &support::DebugSyntaxResult(self.amp_token()))
                 .finish()
         } else {
-            f.debug_struct("CssLayerAtRule").finish()
+            f.debug_struct("CssNestedSelector").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssLayerAtRule> for SyntaxNode {
-    fn from(n: CssLayerAtRule) -> Self {
+impl From<CssNestedSelector> for SyntaxNode {
+    fn from(n: CssNestedSelector) -> Self {
         n.syntax
     }
 }
-impl From<CssLayerAtRule> for SyntaxElement {
-    fn from(n: CssLayerAtRule) -> Self {
+impl From<CssNestedSelector> for SyntaxElement {
+    fn from(n: CssNestedSelector) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssLayerDeclaration {
+impl AstNode for CssNthOffset {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_LAYER_DECLARATION as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_NTH_OFFSET as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_LAYER_DECLARATION
+        kind == CSS_NTH_OFFSET
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -15301,39 +15055,39 @@ impl AstNode for CssLayerDeclaration {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssLayerDeclaration {
+impl std::fmt::Debug for CssNthOffset {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssLayerDeclaration")
-                .field("references", &self.references())
-                .field("block", &support::DebugSyntaxResult(self.block()))
+            f.debug_struct("CssNthOffset")
+                .field("sign", &support::DebugSyntaxResult(self.sign()))
+                .field("value", &support::DebugSyntaxResult(self.value()))
                 .finish()
         } else {
-            f.debug_struct("CssLayerDeclaration").finish()
+            f.debug_struct("CssNthOffset").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssLayerDeclaration> for SyntaxNode {
-    fn from(n: CssLayerDeclaration) -> Self {
+impl From<CssNthOffset> for SyntaxNode {
+    fn from(n: CssNthOffset) -> Self {
         n.syntax
     }
 }
-impl From<CssLayerDeclaration> for SyntaxElement {
-    fn from(n: CssLayerDeclaration) -> Self {
+impl From<CssNthOffset> for SyntaxElement {
+    fn from(n: CssNthOffset) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssLayerReference {
+impl AstNode for CssNumber {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_LAYER_REFERENCE as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_NUMBER as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_LAYER_REFERENCE
+        kind == CSS_NUMBER
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -15349,43 +15103,41 @@ impl AstNode for CssLayerReference {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssLayerReference {
+impl std::fmt::Debug for CssNumber {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssLayerReference")
-                .field("references", &self.references())
+            f.debug_struct("CssNumber")
                 .field(
-                    "semicolon_token",
-                    &support::DebugSyntaxResult(self.semicolon_token()),
+                    "value_token",
+                    &support::DebugSyntaxResult(self.value_token()),
                 )
                 .finish()
         } else {
-            f.debug_struct("CssLayerReference").finish()
+            f.debug_struct("CssNumber").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssLayerReference> for SyntaxNode {
-    fn from(n: CssLayerReference) -> Self {
+impl From<CssNumber> for SyntaxNode {
+    fn from(n: CssNumber) -> Self {
         n.syntax
     }
 }
-impl From<CssLayerReference> for SyntaxElement {
-    fn from(n: CssLayerReference) -> Self {
+impl From<CssNumber> for SyntaxElement {
+    fn from(n: CssNumber) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssListOfComponentValuesExpression {
+impl AstNode for CssPageAtRule {
     type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> = SyntaxKindSet::from_raw(RawSyntaxKind(
-        CSS_LIST_OF_COMPONENT_VALUES_EXPRESSION as u16,
-    ));
+    const KIND_SET: SyntaxKindSet<Language> =
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_PAGE_AT_RULE as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_LIST_OF_COMPONENT_VALUES_EXPRESSION
+        kind == CSS_PAGE_AT_RULE
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -15401,39 +15153,40 @@ impl AstNode for CssListOfComponentValuesExpression {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssListOfComponentValuesExpression {
+impl std::fmt::Debug for CssPageAtRule {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssListOfComponentValuesExpression")
-                .field("css_component_value_list", &self.css_component_value_list())
+            f.debug_struct("CssPageAtRule")
+                .field("page_token", &support::DebugSyntaxResult(self.page_token()))
+                .field("selectors", &self.selectors())
+                .field("block", &support::DebugSyntaxResult(self.block()))
                 .finish()
         } else {
-            f.debug_struct("CssListOfComponentValuesExpression")
-                .finish()
+            f.debug_struct("CssPageAtRule").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssListOfComponentValuesExpression> for SyntaxNode {
-    fn from(n: CssListOfComponentValuesExpression) -> Self {
+impl From<CssPageAtRule> for SyntaxNode {
+    fn from(n: CssPageAtRule) -> Self {
         n.syntax
     }
 }
-impl From<CssListOfComponentValuesExpression> for SyntaxElement {
-    fn from(n: CssListOfComponentValuesExpression) -> Self {
+impl From<CssPageAtRule> for SyntaxElement {
+    fn from(n: CssPageAtRule) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssMarginAtRule {
+impl AstNode for CssPageAtRuleBlock {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_MARGIN_AT_RULE as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_PAGE_AT_RULE_BLOCK as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_MARGIN_AT_RULE
+        kind == CSS_PAGE_AT_RULE_BLOCK
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -15449,40 +15202,46 @@ impl AstNode for CssMarginAtRule {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssMarginAtRule {
+impl std::fmt::Debug for CssPageAtRuleBlock {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssMarginAtRule")
-                .field("at_token", &support::DebugSyntaxResult(self.at_token()))
-                .field("name", &support::DebugSyntaxResult(self.name()))
-                .field("block", &support::DebugSyntaxResult(self.block()))
+            f.debug_struct("CssPageAtRuleBlock")
+                .field(
+                    "l_curly_token",
+                    &support::DebugSyntaxResult(self.l_curly_token()),
+                )
+                .field("items", &self.items())
+                .field(
+                    "r_curly_token",
+                    &support::DebugSyntaxResult(self.r_curly_token()),
+                )
                 .finish()
         } else {
-            f.debug_struct("CssMarginAtRule").finish()
+            f.debug_struct("CssPageAtRuleBlock").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssMarginAtRule> for SyntaxNode {
-    fn from(n: CssMarginAtRule) -> Self {
+impl From<CssPageAtRuleBlock> for SyntaxNode {
+    fn from(n: CssPageAtRuleBlock) -> Self {
         n.syntax
     }
 }
-impl From<CssMarginAtRule> for SyntaxElement {
-    fn from(n: CssMarginAtRule) -> Self {
+impl From<CssPageAtRuleBlock> for SyntaxElement {
+    fn from(n: CssPageAtRuleBlock) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssMediaAndCondition {
+impl AstNode for CssPageSelector {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_MEDIA_AND_CONDITION as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_PAGE_SELECTOR as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_MEDIA_AND_CONDITION
+        kind == CSS_PAGE_SELECTOR
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -15498,40 +15257,39 @@ impl AstNode for CssMediaAndCondition {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssMediaAndCondition {
+impl std::fmt::Debug for CssPageSelector {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssMediaAndCondition")
-                .field("left", &support::DebugSyntaxResult(self.left()))
-                .field("and_token", &support::DebugSyntaxResult(self.and_token()))
-                .field("right", &support::DebugSyntaxResult(self.right()))
+            f.debug_struct("CssPageSelector")
+                .field("ty", &support::DebugOptionalElement(self.ty()))
+                .field("pseudos", &self.pseudos())
                 .finish()
         } else {
-            f.debug_struct("CssMediaAndCondition").finish()
+            f.debug_struct("CssPageSelector").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssMediaAndCondition> for SyntaxNode {
-    fn from(n: CssMediaAndCondition) -> Self {
+impl From<CssPageSelector> for SyntaxNode {
+    fn from(n: CssPageSelector) -> Self {
         n.syntax
     }
 }
-impl From<CssMediaAndCondition> for SyntaxElement {
-    fn from(n: CssMediaAndCondition) -> Self {
+impl From<CssPageSelector> for SyntaxElement {
+    fn from(n: CssPageSelector) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssMediaAndTypeQuery {
+impl AstNode for CssPageSelectorPseudo {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_MEDIA_AND_TYPE_QUERY as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_PAGE_SELECTOR_PSEUDO as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_MEDIA_AND_TYPE_QUERY
+        kind == CSS_PAGE_SELECTOR_PSEUDO
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -15547,40 +15305,42 @@ impl AstNode for CssMediaAndTypeQuery {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssMediaAndTypeQuery {
+impl std::fmt::Debug for CssPageSelectorPseudo {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssMediaAndTypeQuery")
-                .field("left", &support::DebugSyntaxResult(self.left()))
-                .field("and_token", &support::DebugSyntaxResult(self.and_token()))
-                .field("right", &support::DebugSyntaxResult(self.right()))
+            f.debug_struct("CssPageSelectorPseudo")
+                .field(
+                    "colon_token",
+                    &support::DebugSyntaxResult(self.colon_token()),
+                )
+                .field("selector", &support::DebugSyntaxResult(self.selector()))
                 .finish()
         } else {
-            f.debug_struct("CssMediaAndTypeQuery").finish()
+            f.debug_struct("CssPageSelectorPseudo").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssMediaAndTypeQuery> for SyntaxNode {
-    fn from(n: CssMediaAndTypeQuery) -> Self {
+impl From<CssPageSelectorPseudo> for SyntaxNode {
+    fn from(n: CssPageSelectorPseudo) -> Self {
         n.syntax
     }
 }
-impl From<CssMediaAndTypeQuery> for SyntaxElement {
-    fn from(n: CssMediaAndTypeQuery) -> Self {
+impl From<CssPageSelectorPseudo> for SyntaxElement {
+    fn from(n: CssPageSelectorPseudo) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssMediaAtRule {
+impl AstNode for CssParameter {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_MEDIA_AT_RULE as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_PARAMETER as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_MEDIA_AT_RULE
+        kind == CSS_PARAMETER
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -15596,39 +15356,41 @@ impl AstNode for CssMediaAtRule {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssMediaAtRule {
+impl std::fmt::Debug for CssParameter {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssMediaAtRule")
-                .field("declarator", &support::DebugSyntaxResult(self.declarator()))
-                .field("block", &support::DebugSyntaxResult(self.block()))
+            f.debug_struct("CssParameter")
+                .field(
+                    "any_css_expression",
+                    &support::DebugSyntaxResult(self.any_css_expression()),
+                )
                 .finish()
         } else {
-            f.debug_struct("CssMediaAtRule").finish()
+            f.debug_struct("CssParameter").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssMediaAtRule> for SyntaxNode {
-    fn from(n: CssMediaAtRule) -> Self {
+impl From<CssParameter> for SyntaxNode {
+    fn from(n: CssParameter) -> Self {
         n.syntax
     }
 }
-impl From<CssMediaAtRule> for SyntaxElement {
-    fn from(n: CssMediaAtRule) -> Self {
+impl From<CssParameter> for SyntaxElement {
+    fn from(n: CssParameter) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssMediaAtRuleDeclarator {
+impl AstNode for CssParenthesizedExpression {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_MEDIA_AT_RULE_DECLARATOR as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_PARENTHESIZED_EXPRESSION as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_MEDIA_AT_RULE_DECLARATOR
+        kind == CSS_PARENTHESIZED_EXPRESSION
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -15644,42 +15406,49 @@ impl AstNode for CssMediaAtRuleDeclarator {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssMediaAtRuleDeclarator {
+impl std::fmt::Debug for CssParenthesizedExpression {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssMediaAtRuleDeclarator")
+            f.debug_struct("CssParenthesizedExpression")
                 .field(
-                    "media_token",
-                    &support::DebugSyntaxResult(self.media_token()),
+                    "l_paren_token",
+                    &support::DebugSyntaxResult(self.l_paren_token()),
+                )
+                .field(
+                    "expression",
+                    &support::DebugOptionalElement(self.expression()),
+                )
+                .field(
+                    "r_paren_token",
+                    &support::DebugSyntaxResult(self.r_paren_token()),
                 )
-                .field("queries", &self.queries())
                 .finish()
         } else {
-            f.debug_struct("CssMediaAtRuleDeclarator").finish()
+            f.debug_struct("CssParenthesizedExpression").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssMediaAtRuleDeclarator> for SyntaxNode {
-    fn from(n: CssMediaAtRuleDeclarator) -> Self {
+impl From<CssParenthesizedExpression> for SyntaxNode {
+    fn from(n: CssParenthesizedExpression) -> Self {
         n.syntax
     }
 }
-impl From<CssMediaAtRuleDeclarator> for SyntaxElement {
-    fn from(n: CssMediaAtRuleDeclarator) -> Self {
+impl From<CssParenthesizedExpression> for SyntaxElement {
+    fn from(n: CssParenthesizedExpression) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssMediaConditionInParens {
+impl AstNode for CssPercentage {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_MEDIA_CONDITION_IN_PARENS as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_PERCENTAGE as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_MEDIA_CONDITION_IN_PARENS
+        kind == CSS_PERCENTAGE
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -15695,46 +15464,45 @@ impl AstNode for CssMediaConditionInParens {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssMediaConditionInParens {
+impl std::fmt::Debug for CssPercentage {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssMediaConditionInParens")
+            f.debug_struct("CssPercentage")
                 .field(
-                    "l_paren_token",
-                    &support::DebugSyntaxResult(self.l_paren_token()),
+                    "value_token",
+                    &support::DebugSyntaxResult(self.value_token()),
                 )
-                .field("condition", &support::DebugSyntaxResult(self.condition()))
                 .field(
-                    "r_paren_token",
-                    &support::DebugSyntaxResult(self.r_paren_token()),
+                    "percent_token",
+                    &support::DebugSyntaxResult(self.percent_token()),
                 )
                 .finish()
         } else {
-            f.debug_struct("CssMediaConditionInParens").finish()
+            f.debug_struct("CssPercentage").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssMediaConditionInParens> for SyntaxNode {
-    fn from(n: CssMediaConditionInParens) -> Self {
+impl From<CssPercentage> for SyntaxNode {
+    fn from(n: CssPercentage) -> Self {
         n.syntax
     }
 }
-impl From<CssMediaConditionInParens> for SyntaxElement {
-    fn from(n: CssMediaConditionInParens) -> Self {
+impl From<CssPercentage> for SyntaxElement {
+    fn from(n: CssPercentage) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssMediaConditionQuery {
+impl AstNode for CssPositionTryAtRule {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_MEDIA_CONDITION_QUERY as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_POSITION_TRY_AT_RULE as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_MEDIA_CONDITION_QUERY
+        kind == CSS_POSITION_TRY_AT_RULE
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -15750,38 +15518,39 @@ impl AstNode for CssMediaConditionQuery {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssMediaConditionQuery {
+impl std::fmt::Debug for CssPositionTryAtRule {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssMediaConditionQuery")
-                .field("condition", &support::DebugSyntaxResult(self.condition()))
+            f.debug_struct("CssPositionTryAtRule")
+                .field("declarator", &support::DebugSyntaxResult(self.declarator()))
+                .field("block", &support::DebugSyntaxResult(self.block()))
                 .finish()
         } else {
-            f.debug_struct("CssMediaConditionQuery").finish()
+            f.debug_struct("CssPositionTryAtRule").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssMediaConditionQuery> for SyntaxNode {
-    fn from(n: CssMediaConditionQuery) -> Self {
+impl From<CssPositionTryAtRule> for SyntaxNode {
+    fn from(n: CssPositionTryAtRule) -> Self {
         n.syntax
     }
 }
-impl From<CssMediaConditionQuery> for SyntaxElement {
-    fn from(n: CssMediaConditionQuery) -> Self {
+impl From<CssPositionTryAtRule> for SyntaxElement {
+    fn from(n: CssPositionTryAtRule) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssMediaFeatureInParens {
+impl AstNode for CssPositionTryAtRuleDeclarator {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_MEDIA_FEATURE_IN_PARENS as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_POSITION_TRY_AT_RULE_DECLARATOR as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_MEDIA_FEATURE_IN_PARENS
+        kind == CSS_POSITION_TRY_AT_RULE_DECLARATOR
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -15797,46 +15566,42 @@ impl AstNode for CssMediaFeatureInParens {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssMediaFeatureInParens {
+impl std::fmt::Debug for CssPositionTryAtRuleDeclarator {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssMediaFeatureInParens")
-                .field(
-                    "l_paren_token",
-                    &support::DebugSyntaxResult(self.l_paren_token()),
-                )
-                .field("feature", &support::DebugSyntaxResult(self.feature()))
+            f.debug_struct("CssPositionTryAtRuleDeclarator")
                 .field(
-                    "r_paren_token",
-                    &support::DebugSyntaxResult(self.r_paren_token()),
+                    "position_try_token",
+                    &support::DebugSyntaxResult(self.position_try_token()),
                 )
+                .field("name", &support::DebugSyntaxResult(self.name()))
                 .finish()
         } else {
-            f.debug_struct("CssMediaFeatureInParens").finish()
+            f.debug_struct("CssPositionTryAtRuleDeclarator").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssMediaFeatureInParens> for SyntaxNode {
-    fn from(n: CssMediaFeatureInParens) -> Self {
+impl From<CssPositionTryAtRuleDeclarator> for SyntaxNode {
+    fn from(n: CssPositionTryAtRuleDeclarator) -> Self {
         n.syntax
     }
 }
-impl From<CssMediaFeatureInParens> for SyntaxElement {
-    fn from(n: CssMediaFeatureInParens) -> Self {
+impl From<CssPositionTryAtRuleDeclarator> for SyntaxElement {
+    fn from(n: CssPositionTryAtRuleDeclarator) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssMediaNotCondition {
+impl AstNode for CssPropertyAtRule {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_MEDIA_NOT_CONDITION as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_PROPERTY_AT_RULE as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_MEDIA_NOT_CONDITION
+        kind == CSS_PROPERTY_AT_RULE
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -15852,39 +15617,39 @@ impl AstNode for CssMediaNotCondition {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssMediaNotCondition {
+impl std::fmt::Debug for CssPropertyAtRule {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssMediaNotCondition")
-                .field("not_token", &support::DebugSyntaxResult(self.not_token()))
-                .field("condition", &support::DebugSyntaxResult(self.condition()))
+            f.debug_struct("CssPropertyAtRule")
+                .field("declarator", &support::DebugSyntaxResult(self.declarator()))
+                .field("block", &support::DebugSyntaxResult(self.block()))
                 .finish()
         } else {
-            f.debug_struct("CssMediaNotCondition").finish()
+            f.debug_struct("CssPropertyAtRule").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssMediaNotCondition> for SyntaxNode {
-    fn from(n: CssMediaNotCondition) -> Self {
+impl From<CssPropertyAtRule> for SyntaxNode {
+    fn from(n: CssPropertyAtRule) -> Self {
         n.syntax
     }
 }
-impl From<CssMediaNotCondition> for SyntaxElement {
-    fn from(n: CssMediaNotCondition) -> Self {
+impl From<CssPropertyAtRule> for SyntaxElement {
+    fn from(n: CssPropertyAtRule) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssMediaOrCondition {
+impl AstNode for CssPropertyAtRuleDeclarator {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_MEDIA_OR_CONDITION as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_PROPERTY_AT_RULE_DECLARATOR as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_MEDIA_OR_CONDITION
+        kind == CSS_PROPERTY_AT_RULE_DECLARATOR
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -15900,40 +15665,43 @@ impl AstNode for CssMediaOrCondition {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssMediaOrCondition {
+impl std::fmt::Debug for CssPropertyAtRuleDeclarator {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssMediaOrCondition")
-                .field("left", &support::DebugSyntaxResult(self.left()))
-                .field("or_token", &support::DebugSyntaxResult(self.or_token()))
-                .field("right", &support::DebugSyntaxResult(self.right()))
+            f.debug_struct("CssPropertyAtRuleDeclarator")
+                .field(
+                    "property_token",
+                    &support::DebugSyntaxResult(self.property_token()),
+                )
+                .field("name", &support::DebugSyntaxResult(self.name()))
                 .finish()
         } else {
-            f.debug_struct("CssMediaOrCondition").finish()
+            f.debug_struct("CssPropertyAtRuleDeclarator").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssMediaOrCondition> for SyntaxNode {
-    fn from(n: CssMediaOrCondition) -> Self {
+impl From<CssPropertyAtRuleDeclarator> for SyntaxNode {
+    fn from(n: CssPropertyAtRuleDeclarator) -> Self {
         n.syntax
     }
 }
-impl From<CssMediaOrCondition> for SyntaxElement {
-    fn from(n: CssMediaOrCondition) -> Self {
+impl From<CssPropertyAtRuleDeclarator> for SyntaxElement {
+    fn from(n: CssPropertyAtRuleDeclarator) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssMediaType {
+impl AstNode for CssPseudoClassFunctionCompoundSelector {
     type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_MEDIA_TYPE as u16));
+    const KIND_SET: SyntaxKindSet<Language> = SyntaxKindSet::from_raw(RawSyntaxKind(
+        CSS_PSEUDO_CLASS_FUNCTION_COMPOUND_SELECTOR as u16,
+    ));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_MEDIA_TYPE
+        kind == CSS_PSEUDO_CLASS_FUNCTION_COMPOUND_SELECTOR
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -15949,38 +15717,49 @@ impl AstNode for CssMediaType {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssMediaType {
+impl std::fmt::Debug for CssPseudoClassFunctionCompoundSelector {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssMediaType")
-                .field("value", &support::DebugSyntaxResult(self.value()))
+            f.debug_struct("CssPseudoClassFunctionCompoundSelector")
+                .field("name", &support::DebugSyntaxResult(self.name()))
+                .field(
+                    "l_paren_token",
+                    &support::DebugSyntaxResult(self.l_paren_token()),
+                )
+                .field("selector", &support::DebugSyntaxResult(self.selector()))
+                .field(
+                    "r_paren_token",
+                    &support::DebugSyntaxResult(self.r_paren_token()),
+                )
                 .finish()
         } else {
-            f.debug_struct("CssMediaType").finish()
+            f.debug_struct("CssPseudoClassFunctionCompoundSelector")
+                .finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssMediaType> for SyntaxNode {
-    fn from(n: CssMediaType) -> Self {
+impl From<CssPseudoClassFunctionCompoundSelector> for SyntaxNode {
+    fn from(n: CssPseudoClassFunctionCompoundSelector) -> Self {
         n.syntax
     }
 }
-impl From<CssMediaType> for SyntaxElement {
-    fn from(n: CssMediaType) -> Self {
+impl From<CssPseudoClassFunctionCompoundSelector> for SyntaxElement {
+    fn from(n: CssPseudoClassFunctionCompoundSelector) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssMediaTypeQuery {
+impl AstNode for CssPseudoClassFunctionCompoundSelectorList {
     type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_MEDIA_TYPE_QUERY as u16));
+    const KIND_SET: SyntaxKindSet<Language> = SyntaxKindSet::from_raw(RawSyntaxKind(
+        CSS_PSEUDO_CLASS_FUNCTION_COMPOUND_SELECTOR_LIST as u16,
+    ));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_MEDIA_TYPE_QUERY
+        kind == CSS_PSEUDO_CLASS_FUNCTION_COMPOUND_SELECTOR_LIST
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -15996,39 +15775,49 @@ impl AstNode for CssMediaTypeQuery {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssMediaTypeQuery {
+impl std::fmt::Debug for CssPseudoClassFunctionCompoundSelectorList {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssMediaTypeQuery")
-                .field("modifier", &support::DebugOptionalElement(self.modifier()))
-                .field("ty", &support::DebugSyntaxResult(self.ty()))
+            f.debug_struct("CssPseudoClassFunctionCompoundSelectorList")
+                .field("name", &support::DebugSyntaxResult(self.name()))
+                .field(
+                    "l_paren_token",
+                    &support::DebugSyntaxResult(self.l_paren_token()),
+                )
+                .field("compound_selectors", &self.compound_selectors())
+                .field(
+                    "r_paren_token",
+                    &support::DebugSyntaxResult(self.r_paren_token()),
+                )
                 .finish()
         } else {
-            f.debug_struct("CssMediaTypeQuery").finish()
+            f.debug_struct("CssPseudoClassFunctionCompoundSelectorList")
+                .finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssMediaTypeQuery> for SyntaxNode {
-    fn from(n: CssMediaTypeQuery) -> Self {
+impl From<CssPseudoClassFunctionCompoundSelectorList> for SyntaxNode {
+    fn from(n: CssPseudoClassFunctionCompoundSelectorList) -> Self {
         n.syntax
     }
 }
-impl From<CssMediaTypeQuery> for SyntaxElement {
-    fn from(n: CssMediaTypeQuery) -> Self {
+impl From<CssPseudoClassFunctionCompoundSelectorList> for SyntaxElement {
+    fn from(n: CssPseudoClassFunctionCompoundSelectorList) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssMetavariable {
+impl AstNode for CssPseudoClassFunctionCustomIdentifier {
     type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_METAVARIABLE as u16));
+    const KIND_SET: SyntaxKindSet<Language> = SyntaxKindSet::from_raw(RawSyntaxKind(
+        CSS_PSEUDO_CLASS_FUNCTION_CUSTOM_IDENTIFIER as u16,
+    ));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_METAVARIABLE
+        kind == CSS_PSEUDO_CLASS_FUNCTION_CUSTOM_IDENTIFIER
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -16044,41 +15833,49 @@ impl AstNode for CssMetavariable {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssMetavariable {
+impl std::fmt::Debug for CssPseudoClassFunctionCustomIdentifier {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssMetavariable")
+            f.debug_struct("CssPseudoClassFunctionCustomIdentifier")
+                .field("name", &support::DebugSyntaxResult(self.name()))
                 .field(
-                    "value_token",
-                    &support::DebugSyntaxResult(self.value_token()),
+                    "l_paren_token",
+                    &support::DebugSyntaxResult(self.l_paren_token()),
+                )
+                .field("ident", &support::DebugSyntaxResult(self.ident()))
+                .field(
+                    "r_paren_token",
+                    &support::DebugSyntaxResult(self.r_paren_token()),
                 )
                 .finish()
         } else {
-            f.debug_struct("CssMetavariable").finish()
+            f.debug_struct("CssPseudoClassFunctionCustomIdentifier")
+                .finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssMetavariable> for SyntaxNode {
-    fn from(n: CssMetavariable) -> Self {
+impl From<CssPseudoClassFunctionCustomIdentifier> for SyntaxNode {
+    fn from(n: CssPseudoClassFunctionCustomIdentifier) -> Self {
         n.syntax
     }
 }
-impl From<CssMetavariable> for SyntaxElement {
-    fn from(n: CssMetavariable) -> Self {
+impl From<CssPseudoClassFunctionCustomIdentifier> for SyntaxElement {
+    fn from(n: CssPseudoClassFunctionCustomIdentifier) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssNamedNamespacePrefix {
+impl AstNode for CssPseudoClassFunctionCustomIdentifierList {
     type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_NAMED_NAMESPACE_PREFIX as u16));
+    const KIND_SET: SyntaxKindSet<Language> = SyntaxKindSet::from_raw(RawSyntaxKind(
+        CSS_PSEUDO_CLASS_FUNCTION_CUSTOM_IDENTIFIER_LIST as u16,
+    ));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_NAMED_NAMESPACE_PREFIX
+        kind == CSS_PSEUDO_CLASS_FUNCTION_CUSTOM_IDENTIFIER_LIST
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -16094,38 +15891,48 @@ impl AstNode for CssNamedNamespacePrefix {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssNamedNamespacePrefix {
+impl std::fmt::Debug for CssPseudoClassFunctionCustomIdentifierList {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssNamedNamespacePrefix")
+            f.debug_struct("CssPseudoClassFunctionCustomIdentifierList")
                 .field("name", &support::DebugSyntaxResult(self.name()))
+                .field(
+                    "l_paren_token",
+                    &support::DebugSyntaxResult(self.l_paren_token()),
+                )
+                .field("items", &self.items())
+                .field(
+                    "r_paren_token",
+                    &support::DebugSyntaxResult(self.r_paren_token()),
+                )
                 .finish()
         } else {
-            f.debug_struct("CssNamedNamespacePrefix").finish()
+            f.debug_struct("CssPseudoClassFunctionCustomIdentifierList")
+                .finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssNamedNamespacePrefix> for SyntaxNode {
-    fn from(n: CssNamedNamespacePrefix) -> Self {
+impl From<CssPseudoClassFunctionCustomIdentifierList> for SyntaxNode {
+    fn from(n: CssPseudoClassFunctionCustomIdentifierList) -> Self {
         n.syntax
     }
 }
-impl From<CssNamedNamespacePrefix> for SyntaxElement {
-    fn from(n: CssNamedNamespacePrefix) -> Self {
+impl From<CssPseudoClassFunctionCustomIdentifierList> for SyntaxElement {
+    fn from(n: CssPseudoClassFunctionCustomIdentifierList) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssNamespace {
+impl AstNode for CssPseudoClassFunctionIdentifier {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_NAMESPACE as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_PSEUDO_CLASS_FUNCTION_IDENTIFIER as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_NAMESPACE
+        kind == CSS_PSEUDO_CLASS_FUNCTION_IDENTIFIER
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -16141,42 +15948,47 @@ impl AstNode for CssNamespace {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssNamespace {
+impl std::fmt::Debug for CssPseudoClassFunctionIdentifier {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssNamespace")
-                .field("prefix", &support::DebugOptionalElement(self.prefix()))
+            f.debug_struct("CssPseudoClassFunctionIdentifier")
+                .field("name", &support::DebugSyntaxResult(self.name()))
                 .field(
-                    "bitwise_or_token",
-                    &support::DebugSyntaxResult(self.bitwise_or_token()),
+                    "l_paren_token",
+                    &support::DebugSyntaxResult(self.l_paren_token()),
+                )
+                .field("ident", &support::DebugSyntaxResult(self.ident()))
+                .field(
+                    "r_paren_token",
+                    &support::DebugSyntaxResult(self.r_paren_token()),
                 )
                 .finish()
         } else {
-            f.debug_struct("CssNamespace").finish()
+            f.debug_struct("CssPseudoClassFunctionIdentifier").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssNamespace> for SyntaxNode {
-    fn from(n: CssNamespace) -> Self {
+impl From<CssPseudoClassFunctionIdentifier> for SyntaxNode {
+    fn from(n: CssPseudoClassFunctionIdentifier) -> Self {
         n.syntax
     }
 }
-impl From<CssNamespace> for SyntaxElement {
-    fn from(n: CssNamespace) -> Self {
+impl From<CssPseudoClassFunctionIdentifier> for SyntaxElement {
+    fn from(n: CssPseudoClassFunctionIdentifier) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssNamespaceAtRule {
+impl AstNode for CssPseudoClassFunctionNth {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_NAMESPACE_AT_RULE as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_PSEUDO_CLASS_FUNCTION_NTH as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_NAMESPACE_AT_RULE
+        kind == CSS_PSEUDO_CLASS_FUNCTION_NTH
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -16192,47 +16004,48 @@ impl AstNode for CssNamespaceAtRule {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssNamespaceAtRule {
+impl std::fmt::Debug for CssPseudoClassFunctionNth {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssNamespaceAtRule")
+            f.debug_struct("CssPseudoClassFunctionNth")
+                .field("name", &support::DebugSyntaxResult(self.name()))
                 .field(
-                    "namespace_token",
-                    &support::DebugSyntaxResult(self.namespace_token()),
+                    "l_paren_token",
+                    &support::DebugSyntaxResult(self.l_paren_token()),
                 )
-                .field("prefix", &support::DebugOptionalElement(self.prefix()))
-                .field("url", &support::DebugSyntaxResult(self.url()))
+                .field("selector", &support::DebugSyntaxResult(self.selector()))
                 .field(
-                    "semicolon_token",
-                    &support::DebugSyntaxResult(self.semicolon_token()),
+                    "r_paren_token",
+                    &support::DebugSyntaxResult(self.r_paren_token()),
                 )
                 .finish()
         } else {
-            f.debug_struct("CssNamespaceAtRule").finish()
+            f.debug_struct("CssPseudoClassFunctionNth").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssNamespaceAtRule> for SyntaxNode {
-    fn from(n: CssNamespaceAtRule) -> Self {
+impl From<CssPseudoClassFunctionNth> for SyntaxNode {
+    fn from(n: CssPseudoClassFunctionNth) -> Self {
         n.syntax
     }
 }
-impl From<CssNamespaceAtRule> for SyntaxElement {
-    fn from(n: CssNamespaceAtRule) -> Self {
+impl From<CssPseudoClassFunctionNth> for SyntaxElement {
+    fn from(n: CssPseudoClassFunctionNth) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssNestedQualifiedRule {
+impl AstNode for CssPseudoClassFunctionRelativeSelectorList {
     type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_NESTED_QUALIFIED_RULE as u16));
+    const KIND_SET: SyntaxKindSet<Language> = SyntaxKindSet::from_raw(RawSyntaxKind(
+        CSS_PSEUDO_CLASS_FUNCTION_RELATIVE_SELECTOR_LIST as u16,
+    ));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_NESTED_QUALIFIED_RULE
+        kind == CSS_PSEUDO_CLASS_FUNCTION_RELATIVE_SELECTOR_LIST
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -16248,39 +16061,48 @@ impl AstNode for CssNestedQualifiedRule {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssNestedQualifiedRule {
+impl std::fmt::Debug for CssPseudoClassFunctionRelativeSelectorList {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssNestedQualifiedRule")
-                .field("prelude", &self.prelude())
-                .field("block", &support::DebugSyntaxResult(self.block()))
+            f.debug_struct("CssPseudoClassFunctionRelativeSelectorList")
+                .field("name", &support::DebugSyntaxResult(self.name()))
+                .field(
+                    "l_paren_token",
+                    &support::DebugSyntaxResult(self.l_paren_token()),
+                )
+                .field("relative_selectors", &self.relative_selectors())
+                .field(
+                    "r_paren_token",
+                    &support::DebugSyntaxResult(self.r_paren_token()),
+                )
                 .finish()
         } else {
-            f.debug_struct("CssNestedQualifiedRule").finish()
+            f.debug_struct("CssPseudoClassFunctionRelativeSelectorList")
+                .finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssNestedQualifiedRule> for SyntaxNode {
-    fn from(n: CssNestedQualifiedRule) -> Self {
+impl From<CssPseudoClassFunctionRelativeSelectorList> for SyntaxNode {
+    fn from(n: CssPseudoClassFunctionRelativeSelectorList) -> Self {
         n.syntax
     }
 }
-impl From<CssNestedQualifiedRule> for SyntaxElement {
-    fn from(n: CssNestedQualifiedRule) -> Self {
+impl From<CssPseudoClassFunctionRelativeSelectorList> for SyntaxElement {
+    fn from(n: CssPseudoClassFunctionRelativeSelectorList) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssNestedSelector {
+impl AstNode for CssPseudoClassFunctionSelector {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_NESTED_SELECTOR as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_PSEUDO_CLASS_FUNCTION_SELECTOR as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_NESTED_SELECTOR
+        kind == CSS_PSEUDO_CLASS_FUNCTION_SELECTOR
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -16296,38 +16118,48 @@ impl AstNode for CssNestedSelector {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssNestedSelector {
+impl std::fmt::Debug for CssPseudoClassFunctionSelector {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssNestedSelector")
-                .field("amp_token", &support::DebugSyntaxResult(self.amp_token()))
+            f.debug_struct("CssPseudoClassFunctionSelector")
+                .field("name", &support::DebugSyntaxResult(self.name()))
+                .field(
+                    "l_paren_token",
+                    &support::DebugSyntaxResult(self.l_paren_token()),
+                )
+                .field("selector", &support::DebugSyntaxResult(self.selector()))
+                .field(
+                    "r_paren_token",
+                    &support::DebugSyntaxResult(self.r_paren_token()),
+                )
                 .finish()
         } else {
-            f.debug_struct("CssNestedSelector").finish()
+            f.debug_struct("CssPseudoClassFunctionSelector").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssNestedSelector> for SyntaxNode {
-    fn from(n: CssNestedSelector) -> Self {
+impl From<CssPseudoClassFunctionSelector> for SyntaxNode {
+    fn from(n: CssPseudoClassFunctionSelector) -> Self {
         n.syntax
     }
 }
-impl From<CssNestedSelector> for SyntaxElement {
-    fn from(n: CssNestedSelector) -> Self {
+impl From<CssPseudoClassFunctionSelector> for SyntaxElement {
+    fn from(n: CssPseudoClassFunctionSelector) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssNthOffset {
+impl AstNode for CssPseudoClassFunctionSelectorList {
     type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_NTH_OFFSET as u16));
+    const KIND_SET: SyntaxKindSet<Language> = SyntaxKindSet::from_raw(RawSyntaxKind(
+        CSS_PSEUDO_CLASS_FUNCTION_SELECTOR_LIST as u16,
+    ));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_NTH_OFFSET
+        kind == CSS_PSEUDO_CLASS_FUNCTION_SELECTOR_LIST
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -16343,39 +16175,48 @@ impl AstNode for CssNthOffset {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssNthOffset {
+impl std::fmt::Debug for CssPseudoClassFunctionSelectorList {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssNthOffset")
-                .field("sign", &support::DebugSyntaxResult(self.sign()))
-                .field("value", &support::DebugSyntaxResult(self.value()))
+            f.debug_struct("CssPseudoClassFunctionSelectorList")
+                .field("name", &support::DebugSyntaxResult(self.name()))
+                .field(
+                    "l_paren_token",
+                    &support::DebugSyntaxResult(self.l_paren_token()),
+                )
+                .field("selectors", &self.selectors())
+                .field(
+                    "r_paren_token",
+                    &support::DebugSyntaxResult(self.r_paren_token()),
+                )
                 .finish()
         } else {
-            f.debug_struct("CssNthOffset").finish()
+            f.debug_struct("CssPseudoClassFunctionSelectorList")
+                .finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssNthOffset> for SyntaxNode {
-    fn from(n: CssNthOffset) -> Self {
+impl From<CssPseudoClassFunctionSelectorList> for SyntaxNode {
+    fn from(n: CssPseudoClassFunctionSelectorList) -> Self {
         n.syntax
     }
 }
-impl From<CssNthOffset> for SyntaxElement {
-    fn from(n: CssNthOffset) -> Self {
+impl From<CssPseudoClassFunctionSelectorList> for SyntaxElement {
+    fn from(n: CssPseudoClassFunctionSelectorList) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssNumber {
+impl AstNode for CssPseudoClassFunctionValueList {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_NUMBER as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_PSEUDO_CLASS_FUNCTION_VALUE_LIST as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_NUMBER
+        kind == CSS_PSEUDO_CLASS_FUNCTION_VALUE_LIST
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -16391,41 +16232,47 @@ impl AstNode for CssNumber {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssNumber {
+impl std::fmt::Debug for CssPseudoClassFunctionValueList {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssNumber")
+            f.debug_struct("CssPseudoClassFunctionValueList")
+                .field("name", &support::DebugSyntaxResult(self.name()))
                 .field(
-                    "value_token",
-                    &support::DebugSyntaxResult(self.value_token()),
+                    "l_paren_token",
+                    &support::DebugSyntaxResult(self.l_paren_token()),
+                )
+                .field("values", &self.values())
+                .field(
+                    "r_paren_token",
+                    &support::DebugSyntaxResult(self.r_paren_token()),
                 )
                 .finish()
         } else {
-            f.debug_struct("CssNumber").finish()
+            f.debug_struct("CssPseudoClassFunctionValueList").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssNumber> for SyntaxNode {
-    fn from(n: CssNumber) -> Self {
+impl From<CssPseudoClassFunctionValueList> for SyntaxNode {
+    fn from(n: CssPseudoClassFunctionValueList) -> Self {
         n.syntax
     }
 }
-impl From<CssNumber> for SyntaxElement {
-    fn from(n: CssNumber) -> Self {
+impl From<CssPseudoClassFunctionValueList> for SyntaxElement {
+    fn from(n: CssPseudoClassFunctionValueList) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssPageAtRule {
+impl AstNode for CssPseudoClassIdentifier {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_PAGE_AT_RULE as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_PSEUDO_CLASS_IDENTIFIER as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_PAGE_AT_RULE
+        kind == CSS_PSEUDO_CLASS_IDENTIFIER
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -16441,40 +16288,38 @@ impl AstNode for CssPageAtRule {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssPageAtRule {
+impl std::fmt::Debug for CssPseudoClassIdentifier {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssPageAtRule")
-                .field("page_token", &support::DebugSyntaxResult(self.page_token()))
-                .field("selectors", &self.selectors())
-                .field("block", &support::DebugSyntaxResult(self.block()))
+            f.debug_struct("CssPseudoClassIdentifier")
+                .field("name", &support::DebugSyntaxResult(self.name()))
                 .finish()
         } else {
-            f.debug_struct("CssPageAtRule").finish()
+            f.debug_struct("CssPseudoClassIdentifier").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssPageAtRule> for SyntaxNode {
-    fn from(n: CssPageAtRule) -> Self {
+impl From<CssPseudoClassIdentifier> for SyntaxNode {
+    fn from(n: CssPseudoClassIdentifier) -> Self {
         n.syntax
     }
 }
-impl From<CssPageAtRule> for SyntaxElement {
-    fn from(n: CssPageAtRule) -> Self {
+impl From<CssPseudoClassIdentifier> for SyntaxElement {
+    fn from(n: CssPseudoClassIdentifier) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssPageAtRuleBlock {
+impl AstNode for CssPseudoClassNth {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_PAGE_AT_RULE_BLOCK as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_PSEUDO_CLASS_NTH as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_PAGE_AT_RULE_BLOCK
+        kind == CSS_PSEUDO_CLASS_NTH
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -16490,46 +16335,44 @@ impl AstNode for CssPageAtRuleBlock {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssPageAtRuleBlock {
+impl std::fmt::Debug for CssPseudoClassNth {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssPageAtRuleBlock")
-                .field(
-                    "l_curly_token",
-                    &support::DebugSyntaxResult(self.l_curly_token()),
-                )
-                .field("items", &self.items())
+            f.debug_struct("CssPseudoClassNth")
+                .field("sign", &support::DebugOptionalElement(self.sign()))
+                .field("value", &support::DebugOptionalElement(self.value()))
                 .field(
-                    "r_curly_token",
-                    &support::DebugSyntaxResult(self.r_curly_token()),
+                    "symbol_token",
+                    &support::DebugSyntaxResult(self.symbol_token()),
                 )
+                .field("offset", &support::DebugOptionalElement(self.offset()))
                 .finish()
         } else {
-            f.debug_struct("CssPageAtRuleBlock").finish()
+            f.debug_struct("CssPseudoClassNth").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssPageAtRuleBlock> for SyntaxNode {
-    fn from(n: CssPageAtRuleBlock) -> Self {
+impl From<CssPseudoClassNth> for SyntaxNode {
+    fn from(n: CssPseudoClassNth) -> Self {
         n.syntax
     }
 }
-impl From<CssPageAtRuleBlock> for SyntaxElement {
-    fn from(n: CssPageAtRuleBlock) -> Self {
+impl From<CssPseudoClassNth> for SyntaxElement {
+    fn from(n: CssPseudoClassNth) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssPageSelector {
+impl AstNode for CssPseudoClassNthIdentifier {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_PAGE_SELECTOR as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_PSEUDO_CLASS_NTH_IDENTIFIER as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_PAGE_SELECTOR
+        kind == CSS_PSEUDO_CLASS_NTH_IDENTIFIER
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -16545,39 +16388,38 @@ impl AstNode for CssPageSelector {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssPageSelector {
+impl std::fmt::Debug for CssPseudoClassNthIdentifier {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssPageSelector")
-                .field("ty", &support::DebugOptionalElement(self.ty()))
-                .field("pseudos", &self.pseudos())
+            f.debug_struct("CssPseudoClassNthIdentifier")
+                .field("value", &support::DebugSyntaxResult(self.value()))
                 .finish()
         } else {
-            f.debug_struct("CssPageSelector").finish()
+            f.debug_struct("CssPseudoClassNthIdentifier").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssPageSelector> for SyntaxNode {
-    fn from(n: CssPageSelector) -> Self {
+impl From<CssPseudoClassNthIdentifier> for SyntaxNode {
+    fn from(n: CssPseudoClassNthIdentifier) -> Self {
         n.syntax
     }
 }
-impl From<CssPageSelector> for SyntaxElement {
-    fn from(n: CssPageSelector) -> Self {
+impl From<CssPseudoClassNthIdentifier> for SyntaxElement {
+    fn from(n: CssPseudoClassNthIdentifier) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssPageSelectorPseudo {
+impl AstNode for CssPseudoClassNthNumber {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_PAGE_SELECTOR_PSEUDO as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_PSEUDO_CLASS_NTH_NUMBER as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_PAGE_SELECTOR_PSEUDO
+        kind == CSS_PSEUDO_CLASS_NTH_NUMBER
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -16593,42 +16435,39 @@ impl AstNode for CssPageSelectorPseudo {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssPageSelectorPseudo {
+impl std::fmt::Debug for CssPseudoClassNthNumber {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssPageSelectorPseudo")
-                .field(
-                    "colon_token",
-                    &support::DebugSyntaxResult(self.colon_token()),
-                )
-                .field("selector", &support::DebugSyntaxResult(self.selector()))
+            f.debug_struct("CssPseudoClassNthNumber")
+                .field("sign", &support::DebugOptionalElement(self.sign()))
+                .field("value", &support::DebugSyntaxResult(self.value()))
                 .finish()
         } else {
-            f.debug_struct("CssPageSelectorPseudo").finish()
+            f.debug_struct("CssPseudoClassNthNumber").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssPageSelectorPseudo> for SyntaxNode {
-    fn from(n: CssPageSelectorPseudo) -> Self {
+impl From<CssPseudoClassNthNumber> for SyntaxNode {
+    fn from(n: CssPseudoClassNthNumber) -> Self {
         n.syntax
     }
 }
-impl From<CssPageSelectorPseudo> for SyntaxElement {
-    fn from(n: CssPageSelectorPseudo) -> Self {
+impl From<CssPseudoClassNthNumber> for SyntaxElement {
+    fn from(n: CssPseudoClassNthNumber) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssParameter {
+impl AstNode for CssPseudoClassNthSelector {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_PARAMETER as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_PSEUDO_CLASS_NTH_SELECTOR as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_PARAMETER
+        kind == CSS_PSEUDO_CLASS_NTH_SELECTOR
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -16644,41 +16483,42 @@ impl AstNode for CssParameter {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssParameter {
+impl std::fmt::Debug for CssPseudoClassNthSelector {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssParameter")
+            f.debug_struct("CssPseudoClassNthSelector")
+                .field("nth", &support::DebugSyntaxResult(self.nth()))
                 .field(
-                    "any_css_expression",
-                    &support::DebugSyntaxResult(self.any_css_expression()),
+                    "of_selector",
+                    &support::DebugOptionalElement(self.of_selector()),
                 )
                 .finish()
         } else {
-            f.debug_struct("CssParameter").finish()
+            f.debug_struct("CssPseudoClassNthSelector").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssParameter> for SyntaxNode {
-    fn from(n: CssParameter) -> Self {
+impl From<CssPseudoClassNthSelector> for SyntaxNode {
+    fn from(n: CssPseudoClassNthSelector) -> Self {
         n.syntax
     }
 }
-impl From<CssParameter> for SyntaxElement {
-    fn from(n: CssParameter) -> Self {
+impl From<CssPseudoClassNthSelector> for SyntaxElement {
+    fn from(n: CssPseudoClassNthSelector) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssParenthesizedExpression {
+impl AstNode for CssPseudoClassOfNthSelector {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_PARENTHESIZED_EXPRESSION as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_PSEUDO_CLASS_OF_NTH_SELECTOR as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_PARENTHESIZED_EXPRESSION
+        kind == CSS_PSEUDO_CLASS_OF_NTH_SELECTOR
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -16694,49 +16534,39 @@ impl AstNode for CssParenthesizedExpression {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssParenthesizedExpression {
+impl std::fmt::Debug for CssPseudoClassOfNthSelector {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssParenthesizedExpression")
-                .field(
-                    "l_paren_token",
-                    &support::DebugSyntaxResult(self.l_paren_token()),
-                )
-                .field(
-                    "expression",
-                    &support::DebugOptionalElement(self.expression()),
-                )
-                .field(
-                    "r_paren_token",
-                    &support::DebugSyntaxResult(self.r_paren_token()),
-                )
+            f.debug_struct("CssPseudoClassOfNthSelector")
+                .field("of_token", &support::DebugSyntaxResult(self.of_token()))
+                .field("selectors", &self.selectors())
                 .finish()
         } else {
-            f.debug_struct("CssParenthesizedExpression").finish()
+            f.debug_struct("CssPseudoClassOfNthSelector").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssParenthesizedExpression> for SyntaxNode {
-    fn from(n: CssParenthesizedExpression) -> Self {
+impl From<CssPseudoClassOfNthSelector> for SyntaxNode {
+    fn from(n: CssPseudoClassOfNthSelector) -> Self {
         n.syntax
     }
 }
-impl From<CssParenthesizedExpression> for SyntaxElement {
-    fn from(n: CssParenthesizedExpression) -> Self {
+impl From<CssPseudoClassOfNthSelector> for SyntaxElement {
+    fn from(n: CssPseudoClassOfNthSelector) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssPercentage {
+impl AstNode for CssPseudoClassSelector {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_PERCENTAGE as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_PSEUDO_CLASS_SELECTOR as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_PERCENTAGE
+        kind == CSS_PSEUDO_CLASS_SELECTOR
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -16752,45 +16582,42 @@ impl AstNode for CssPercentage {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssPercentage {
+impl std::fmt::Debug for CssPseudoClassSelector {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssPercentage")
-                .field(
-                    "value_token",
-                    &support::DebugSyntaxResult(self.value_token()),
-                )
+            f.debug_struct("CssPseudoClassSelector")
                 .field(
-                    "percent_token",
-                    &support::DebugSyntaxResult(self.percent_token()),
+                    "colon_token",
+                    &support::DebugSyntaxResult(self.colon_token()),
                 )
+                .field("class", &support::DebugSyntaxResult(self.class()))
                 .finish()
         } else {
-            f.debug_struct("CssPercentage").finish()
+            f.debug_struct("CssPseudoClassSelector").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssPercentage> for SyntaxNode {
-    fn from(n: CssPercentage) -> Self {
+impl From<CssPseudoClassSelector> for SyntaxNode {
+    fn from(n: CssPseudoClassSelector) -> Self {
         n.syntax
     }
 }
-impl From<CssPercentage> for SyntaxElement {
-    fn from(n: CssPercentage) -> Self {
+impl From<CssPseudoClassSelector> for SyntaxElement {
+    fn from(n: CssPseudoClassSelector) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssPositionTryAtRule {
+impl AstNode for CssPseudoElementFunction {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_POSITION_TRY_AT_RULE as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_PSEUDO_ELEMENT_FUNCTION as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_POSITION_TRY_AT_RULE
+        kind == CSS_PSEUDO_ELEMENT_FUNCTION
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -16806,39 +16633,48 @@ impl AstNode for CssPositionTryAtRule {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssPositionTryAtRule {
+impl std::fmt::Debug for CssPseudoElementFunction {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssPositionTryAtRule")
-                .field("declarator", &support::DebugSyntaxResult(self.declarator()))
-                .field("block", &support::DebugSyntaxResult(self.block()))
+            f.debug_struct("CssPseudoElementFunction")
+                .field("name", &support::DebugSyntaxResult(self.name()))
+                .field(
+                    "l_paren_token",
+                    &support::DebugSyntaxResult(self.l_paren_token()),
+                )
+                .field("items", &self.items())
+                .field(
+                    "r_paren_token",
+                    &support::DebugSyntaxResult(self.r_paren_token()),
+                )
                 .finish()
         } else {
-            f.debug_struct("CssPositionTryAtRule").finish()
+            f.debug_struct("CssPseudoElementFunction").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssPositionTryAtRule> for SyntaxNode {
-    fn from(n: CssPositionTryAtRule) -> Self {
+impl From<CssPseudoElementFunction> for SyntaxNode {
+    fn from(n: CssPseudoElementFunction) -> Self {
         n.syntax
     }
 }
-impl From<CssPositionTryAtRule> for SyntaxElement {
-    fn from(n: CssPositionTryAtRule) -> Self {
+impl From<CssPseudoElementFunction> for SyntaxElement {
+    fn from(n: CssPseudoElementFunction) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssPositionTryAtRuleDeclarator {
+impl AstNode for CssPseudoElementFunctionCustomIdentifier {
     type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_POSITION_TRY_AT_RULE_DECLARATOR as u16));
+    const KIND_SET: SyntaxKindSet<Language> = SyntaxKindSet::from_raw(RawSyntaxKind(
+        CSS_PSEUDO_ELEMENT_FUNCTION_CUSTOM_IDENTIFIER as u16,
+    ));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_POSITION_TRY_AT_RULE_DECLARATOR
+        kind == CSS_PSEUDO_ELEMENT_FUNCTION_CUSTOM_IDENTIFIER
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -16854,42 +16690,48 @@ impl AstNode for CssPositionTryAtRuleDeclarator {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssPositionTryAtRuleDeclarator {
+impl std::fmt::Debug for CssPseudoElementFunctionCustomIdentifier {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssPositionTryAtRuleDeclarator")
+            f.debug_struct("CssPseudoElementFunctionCustomIdentifier")
+                .field("name", &support::DebugSyntaxResult(self.name()))
                 .field(
-                    "position_try_token",
-                    &support::DebugSyntaxResult(self.position_try_token()),
+                    "l_paren_token",
+                    &support::DebugSyntaxResult(self.l_paren_token()),
+                )
+                .field("ident", &support::DebugSyntaxResult(self.ident()))
+                .field(
+                    "r_paren_token",
+                    &support::DebugSyntaxResult(self.r_paren_token()),
                 )
-                .field("name", &support::DebugSyntaxResult(self.name()))
                 .finish()
         } else {
-            f.debug_struct("CssPositionTryAtRuleDeclarator").finish()
+            f.debug_struct("CssPseudoElementFunctionCustomIdentifier")
+                .finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssPositionTryAtRuleDeclarator> for SyntaxNode {
-    fn from(n: CssPositionTryAtRuleDeclarator) -> Self {
+impl From<CssPseudoElementFunctionCustomIdentifier> for SyntaxNode {
+    fn from(n: CssPseudoElementFunctionCustomIdentifier) -> Self {
         n.syntax
     }
 }
-impl From<CssPositionTryAtRuleDeclarator> for SyntaxElement {
-    fn from(n: CssPositionTryAtRuleDeclarator) -> Self {
+impl From<CssPseudoElementFunctionCustomIdentifier> for SyntaxElement {
+    fn from(n: CssPseudoElementFunctionCustomIdentifier) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssPropertyAtRule {
+impl AstNode for CssPseudoElementFunctionSelector {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_PROPERTY_AT_RULE as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_PSEUDO_ELEMENT_FUNCTION_SELECTOR as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_PROPERTY_AT_RULE
+        kind == CSS_PSEUDO_ELEMENT_FUNCTION_SELECTOR
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -16905,39 +16747,47 @@ impl AstNode for CssPropertyAtRule {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssPropertyAtRule {
+impl std::fmt::Debug for CssPseudoElementFunctionSelector {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssPropertyAtRule")
-                .field("declarator", &support::DebugSyntaxResult(self.declarator()))
-                .field("block", &support::DebugSyntaxResult(self.block()))
+            f.debug_struct("CssPseudoElementFunctionSelector")
+                .field("name", &support::DebugSyntaxResult(self.name()))
+                .field(
+                    "l_paren_token",
+                    &support::DebugSyntaxResult(self.l_paren_token()),
+                )
+                .field("selector", &support::DebugSyntaxResult(self.selector()))
+                .field(
+                    "r_paren_token",
+                    &support::DebugSyntaxResult(self.r_paren_token()),
+                )
                 .finish()
         } else {
-            f.debug_struct("CssPropertyAtRule").finish()
+            f.debug_struct("CssPseudoElementFunctionSelector").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssPropertyAtRule> for SyntaxNode {
-    fn from(n: CssPropertyAtRule) -> Self {
+impl From<CssPseudoElementFunctionSelector> for SyntaxNode {
+    fn from(n: CssPseudoElementFunctionSelector) -> Self {
         n.syntax
     }
 }
-impl From<CssPropertyAtRule> for SyntaxElement {
-    fn from(n: CssPropertyAtRule) -> Self {
+impl From<CssPseudoElementFunctionSelector> for SyntaxElement {
+    fn from(n: CssPseudoElementFunctionSelector) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssPropertyAtRuleDeclarator {
+impl AstNode for CssPseudoElementIdentifier {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_PROPERTY_AT_RULE_DECLARATOR as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_PSEUDO_ELEMENT_IDENTIFIER as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_PROPERTY_AT_RULE_DECLARATOR
+        kind == CSS_PSEUDO_ELEMENT_IDENTIFIER
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -16953,43 +16803,38 @@ impl AstNode for CssPropertyAtRuleDeclarator {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssPropertyAtRuleDeclarator {
+impl std::fmt::Debug for CssPseudoElementIdentifier {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssPropertyAtRuleDeclarator")
-                .field(
-                    "property_token",
-                    &support::DebugSyntaxResult(self.property_token()),
-                )
+            f.debug_struct("CssPseudoElementIdentifier")
                 .field("name", &support::DebugSyntaxResult(self.name()))
                 .finish()
         } else {
-            f.debug_struct("CssPropertyAtRuleDeclarator").finish()
+            f.debug_struct("CssPseudoElementIdentifier").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssPropertyAtRuleDeclarator> for SyntaxNode {
-    fn from(n: CssPropertyAtRuleDeclarator) -> Self {
+impl From<CssPseudoElementIdentifier> for SyntaxNode {
+    fn from(n: CssPseudoElementIdentifier) -> Self {
         n.syntax
     }
 }
-impl From<CssPropertyAtRuleDeclarator> for SyntaxElement {
-    fn from(n: CssPropertyAtRuleDeclarator) -> Self {
+impl From<CssPseudoElementIdentifier> for SyntaxElement {
+    fn from(n: CssPseudoElementIdentifier) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssPseudoClassFunctionCompoundSelector {
+impl AstNode for CssPseudoElementSelector {
     type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> = SyntaxKindSet::from_raw(RawSyntaxKind(
-        CSS_PSEUDO_CLASS_FUNCTION_COMPOUND_SELECTOR as u16,
-    ));
+    const KIND_SET: SyntaxKindSet<Language> =
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_PSEUDO_ELEMENT_SELECTOR as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_PSEUDO_CLASS_FUNCTION_COMPOUND_SELECTOR
+        kind == CSS_PSEUDO_ELEMENT_SELECTOR
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -17005,49 +16850,42 @@ impl AstNode for CssPseudoClassFunctionCompoundSelector {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssPseudoClassFunctionCompoundSelector {
+impl std::fmt::Debug for CssPseudoElementSelector {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssPseudoClassFunctionCompoundSelector")
-                .field("name", &support::DebugSyntaxResult(self.name()))
-                .field(
-                    "l_paren_token",
-                    &support::DebugSyntaxResult(self.l_paren_token()),
-                )
-                .field("selector", &support::DebugSyntaxResult(self.selector()))
+            f.debug_struct("CssPseudoElementSelector")
                 .field(
-                    "r_paren_token",
-                    &support::DebugSyntaxResult(self.r_paren_token()),
+                    "double_colon_token",
+                    &support::DebugSyntaxResult(self.double_colon_token()),
                 )
+                .field("element", &support::DebugSyntaxResult(self.element()))
                 .finish()
         } else {
-            f.debug_struct("CssPseudoClassFunctionCompoundSelector")
-                .finish()
+            f.debug_struct("CssPseudoElementSelector").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssPseudoClassFunctionCompoundSelector> for SyntaxNode {
-    fn from(n: CssPseudoClassFunctionCompoundSelector) -> Self {
+impl From<CssPseudoElementSelector> for SyntaxNode {
+    fn from(n: CssPseudoElementSelector) -> Self {
         n.syntax
     }
 }
-impl From<CssPseudoClassFunctionCompoundSelector> for SyntaxElement {
-    fn from(n: CssPseudoClassFunctionCompoundSelector) -> Self {
+impl From<CssPseudoElementSelector> for SyntaxElement {
+    fn from(n: CssPseudoElementSelector) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssPseudoClassFunctionCompoundSelectorList {
+impl AstNode for CssQualifiedRule {
     type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> = SyntaxKindSet::from_raw(RawSyntaxKind(
-        CSS_PSEUDO_CLASS_FUNCTION_COMPOUND_SELECTOR_LIST as u16,
-    ));
+    const KIND_SET: SyntaxKindSet<Language> =
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_QUALIFIED_RULE as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_PSEUDO_CLASS_FUNCTION_COMPOUND_SELECTOR_LIST
+        kind == CSS_QUALIFIED_RULE
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -17063,49 +16901,39 @@ impl AstNode for CssPseudoClassFunctionCompoundSelectorList {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssPseudoClassFunctionCompoundSelectorList {
+impl std::fmt::Debug for CssQualifiedRule {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssPseudoClassFunctionCompoundSelectorList")
-                .field("name", &support::DebugSyntaxResult(self.name()))
-                .field(
-                    "l_paren_token",
-                    &support::DebugSyntaxResult(self.l_paren_token()),
-                )
-                .field("compound_selectors", &self.compound_selectors())
-                .field(
-                    "r_paren_token",
-                    &support::DebugSyntaxResult(self.r_paren_token()),
-                )
+            f.debug_struct("CssQualifiedRule")
+                .field("prelude", &self.prelude())
+                .field("block", &support::DebugSyntaxResult(self.block()))
                 .finish()
         } else {
-            f.debug_struct("CssPseudoClassFunctionCompoundSelectorList")
-                .finish()
+            f.debug_struct("CssQualifiedRule").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssPseudoClassFunctionCompoundSelectorList> for SyntaxNode {
-    fn from(n: CssPseudoClassFunctionCompoundSelectorList) -> Self {
+impl From<CssQualifiedRule> for SyntaxNode {
+    fn from(n: CssQualifiedRule) -> Self {
         n.syntax
     }
 }
-impl From<CssPseudoClassFunctionCompoundSelectorList> for SyntaxElement {
-    fn from(n: CssPseudoClassFunctionCompoundSelectorList) -> Self {
+impl From<CssQualifiedRule> for SyntaxElement {
+    fn from(n: CssQualifiedRule) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssPseudoClassFunctionCustomIdentifier {
+impl AstNode for CssQueryFeatureBoolean {
     type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> = SyntaxKindSet::from_raw(RawSyntaxKind(
-        CSS_PSEUDO_CLASS_FUNCTION_CUSTOM_IDENTIFIER as u16,
-    ));
+    const KIND_SET: SyntaxKindSet<Language> =
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_QUERY_FEATURE_BOOLEAN as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_PSEUDO_CLASS_FUNCTION_CUSTOM_IDENTIFIER
+        kind == CSS_QUERY_FEATURE_BOOLEAN
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -17121,49 +16949,38 @@ impl AstNode for CssPseudoClassFunctionCustomIdentifier {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssPseudoClassFunctionCustomIdentifier {
+impl std::fmt::Debug for CssQueryFeatureBoolean {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssPseudoClassFunctionCustomIdentifier")
+            f.debug_struct("CssQueryFeatureBoolean")
                 .field("name", &support::DebugSyntaxResult(self.name()))
-                .field(
-                    "l_paren_token",
-                    &support::DebugSyntaxResult(self.l_paren_token()),
-                )
-                .field("ident", &support::DebugSyntaxResult(self.ident()))
-                .field(
-                    "r_paren_token",
-                    &support::DebugSyntaxResult(self.r_paren_token()),
-                )
                 .finish()
         } else {
-            f.debug_struct("CssPseudoClassFunctionCustomIdentifier")
-                .finish()
+            f.debug_struct("CssQueryFeatureBoolean").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssPseudoClassFunctionCustomIdentifier> for SyntaxNode {
-    fn from(n: CssPseudoClassFunctionCustomIdentifier) -> Self {
+impl From<CssQueryFeatureBoolean> for SyntaxNode {
+    fn from(n: CssQueryFeatureBoolean) -> Self {
         n.syntax
     }
 }
-impl From<CssPseudoClassFunctionCustomIdentifier> for SyntaxElement {
-    fn from(n: CssPseudoClassFunctionCustomIdentifier) -> Self {
+impl From<CssQueryFeatureBoolean> for SyntaxElement {
+    fn from(n: CssQueryFeatureBoolean) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssPseudoClassFunctionCustomIdentifierList {
+impl AstNode for CssQueryFeaturePlain {
     type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> = SyntaxKindSet::from_raw(RawSyntaxKind(
-        CSS_PSEUDO_CLASS_FUNCTION_CUSTOM_IDENTIFIER_LIST as u16,
-    ));
+    const KIND_SET: SyntaxKindSet<Language> =
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_QUERY_FEATURE_PLAIN as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_PSEUDO_CLASS_FUNCTION_CUSTOM_IDENTIFIER_LIST
+        kind == CSS_QUERY_FEATURE_PLAIN
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -17179,48 +16996,43 @@ impl AstNode for CssPseudoClassFunctionCustomIdentifierList {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssPseudoClassFunctionCustomIdentifierList {
+impl std::fmt::Debug for CssQueryFeaturePlain {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssPseudoClassFunctionCustomIdentifierList")
+            f.debug_struct("CssQueryFeaturePlain")
                 .field("name", &support::DebugSyntaxResult(self.name()))
                 .field(
-                    "l_paren_token",
-                    &support::DebugSyntaxResult(self.l_paren_token()),
-                )
-                .field("items", &self.items())
-                .field(
-                    "r_paren_token",
-                    &support::DebugSyntaxResult(self.r_paren_token()),
+                    "colon_token",
+                    &support::DebugSyntaxResult(self.colon_token()),
                 )
+                .field("value", &support::DebugSyntaxResult(self.value()))
                 .finish()
         } else {
-            f.debug_struct("CssPseudoClassFunctionCustomIdentifierList")
-                .finish()
+            f.debug_struct("CssQueryFeaturePlain").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssPseudoClassFunctionCustomIdentifierList> for SyntaxNode {
-    fn from(n: CssPseudoClassFunctionCustomIdentifierList) -> Self {
+impl From<CssQueryFeaturePlain> for SyntaxNode {
+    fn from(n: CssQueryFeaturePlain) -> Self {
         n.syntax
     }
 }
-impl From<CssPseudoClassFunctionCustomIdentifierList> for SyntaxElement {
-    fn from(n: CssPseudoClassFunctionCustomIdentifierList) -> Self {
+impl From<CssQueryFeaturePlain> for SyntaxElement {
+    fn from(n: CssQueryFeaturePlain) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssPseudoClassFunctionIdentifier {
+impl AstNode for CssQueryFeatureRange {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_PSEUDO_CLASS_FUNCTION_IDENTIFIER as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_QUERY_FEATURE_RANGE as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_PSEUDO_CLASS_FUNCTION_IDENTIFIER
+        kind == CSS_QUERY_FEATURE_RANGE
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -17236,47 +17048,40 @@ impl AstNode for CssPseudoClassFunctionIdentifier {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssPseudoClassFunctionIdentifier {
+impl std::fmt::Debug for CssQueryFeatureRange {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssPseudoClassFunctionIdentifier")
-                .field("name", &support::DebugSyntaxResult(self.name()))
-                .field(
-                    "l_paren_token",
-                    &support::DebugSyntaxResult(self.l_paren_token()),
-                )
-                .field("ident", &support::DebugSyntaxResult(self.ident()))
-                .field(
-                    "r_paren_token",
-                    &support::DebugSyntaxResult(self.r_paren_token()),
-                )
+            f.debug_struct("CssQueryFeatureRange")
+                .field("left", &support::DebugSyntaxResult(self.left()))
+                .field("comparison", &support::DebugSyntaxResult(self.comparison()))
+                .field("right", &support::DebugSyntaxResult(self.right()))
                 .finish()
         } else {
-            f.debug_struct("CssPseudoClassFunctionIdentifier").finish()
+            f.debug_struct("CssQueryFeatureRange").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssPseudoClassFunctionIdentifier> for SyntaxNode {
-    fn from(n: CssPseudoClassFunctionIdentifier) -> Self {
+impl From<CssQueryFeatureRange> for SyntaxNode {
+    fn from(n: CssQueryFeatureRange) -> Self {
         n.syntax
     }
 }
-impl From<CssPseudoClassFunctionIdentifier> for SyntaxElement {
-    fn from(n: CssPseudoClassFunctionIdentifier) -> Self {
+impl From<CssQueryFeatureRange> for SyntaxElement {
+    fn from(n: CssQueryFeatureRange) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssPseudoClassFunctionNth {
+impl AstNode for CssQueryFeatureRangeComparison {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_PSEUDO_CLASS_FUNCTION_NTH as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_QUERY_FEATURE_RANGE_COMPARISON as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_PSEUDO_CLASS_FUNCTION_NTH
+        kind == CSS_QUERY_FEATURE_RANGE_COMPARISON
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -17292,48 +17097,38 @@ impl AstNode for CssPseudoClassFunctionNth {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssPseudoClassFunctionNth {
+impl std::fmt::Debug for CssQueryFeatureRangeComparison {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssPseudoClassFunctionNth")
-                .field("name", &support::DebugSyntaxResult(self.name()))
-                .field(
-                    "l_paren_token",
-                    &support::DebugSyntaxResult(self.l_paren_token()),
-                )
-                .field("selector", &support::DebugSyntaxResult(self.selector()))
-                .field(
-                    "r_paren_token",
-                    &support::DebugSyntaxResult(self.r_paren_token()),
-                )
+            f.debug_struct("CssQueryFeatureRangeComparison")
+                .field("operator", &support::DebugSyntaxResult(self.operator()))
                 .finish()
         } else {
-            f.debug_struct("CssPseudoClassFunctionNth").finish()
+            f.debug_struct("CssQueryFeatureRangeComparison").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssPseudoClassFunctionNth> for SyntaxNode {
-    fn from(n: CssPseudoClassFunctionNth) -> Self {
+impl From<CssQueryFeatureRangeComparison> for SyntaxNode {
+    fn from(n: CssQueryFeatureRangeComparison) -> Self {
         n.syntax
     }
 }
-impl From<CssPseudoClassFunctionNth> for SyntaxElement {
-    fn from(n: CssPseudoClassFunctionNth) -> Self {
+impl From<CssQueryFeatureRangeComparison> for SyntaxElement {
+    fn from(n: CssQueryFeatureRangeComparison) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssPseudoClassFunctionRelativeSelectorList {
+impl AstNode for CssQueryFeatureRangeInterval {
     type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> = SyntaxKindSet::from_raw(RawSyntaxKind(
-        CSS_PSEUDO_CLASS_FUNCTION_RELATIVE_SELECTOR_LIST as u16,
-    ));
+    const KIND_SET: SyntaxKindSet<Language> =
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_QUERY_FEATURE_RANGE_INTERVAL as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_PSEUDO_CLASS_FUNCTION_RELATIVE_SELECTOR_LIST
+        kind == CSS_QUERY_FEATURE_RANGE_INTERVAL
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -17349,48 +17144,48 @@ impl AstNode for CssPseudoClassFunctionRelativeSelectorList {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssPseudoClassFunctionRelativeSelectorList {
+impl std::fmt::Debug for CssQueryFeatureRangeInterval {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssPseudoClassFunctionRelativeSelectorList")
-                .field("name", &support::DebugSyntaxResult(self.name()))
+            f.debug_struct("CssQueryFeatureRangeInterval")
+                .field("left", &support::DebugSyntaxResult(self.left()))
                 .field(
-                    "l_paren_token",
-                    &support::DebugSyntaxResult(self.l_paren_token()),
+                    "left_comparison",
+                    &support::DebugSyntaxResult(self.left_comparison()),
                 )
-                .field("relative_selectors", &self.relative_selectors())
+                .field("name", &support::DebugSyntaxResult(self.name()))
                 .field(
-                    "r_paren_token",
-                    &support::DebugSyntaxResult(self.r_paren_token()),
+                    "right_comparison",
+                    &support::DebugSyntaxResult(self.right_comparison()),
                 )
+                .field("right", &support::DebugSyntaxResult(self.right()))
                 .finish()
         } else {
-            f.debug_struct("CssPseudoClassFunctionRelativeSelectorList")
-                .finish()
+            f.debug_struct("CssQueryFeatureRangeInterval").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssPseudoClassFunctionRelativeSelectorList> for SyntaxNode {
-    fn from(n: CssPseudoClassFunctionRelativeSelectorList) -> Self {
+impl From<CssQueryFeatureRangeInterval> for SyntaxNode {
+    fn from(n: CssQueryFeatureRangeInterval) -> Self {
         n.syntax
     }
 }
-impl From<CssPseudoClassFunctionRelativeSelectorList> for SyntaxElement {
-    fn from(n: CssPseudoClassFunctionRelativeSelectorList) -> Self {
+impl From<CssQueryFeatureRangeInterval> for SyntaxElement {
+    fn from(n: CssQueryFeatureRangeInterval) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssPseudoClassFunctionSelector {
+impl AstNode for CssQueryFeatureReverseRange {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_PSEUDO_CLASS_FUNCTION_SELECTOR as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_QUERY_FEATURE_REVERSE_RANGE as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_PSEUDO_CLASS_FUNCTION_SELECTOR
+        kind == CSS_QUERY_FEATURE_REVERSE_RANGE
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -17406,48 +17201,40 @@ impl AstNode for CssPseudoClassFunctionSelector {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssPseudoClassFunctionSelector {
+impl std::fmt::Debug for CssQueryFeatureReverseRange {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssPseudoClassFunctionSelector")
-                .field("name", &support::DebugSyntaxResult(self.name()))
-                .field(
-                    "l_paren_token",
-                    &support::DebugSyntaxResult(self.l_paren_token()),
-                )
-                .field("selector", &support::DebugSyntaxResult(self.selector()))
-                .field(
-                    "r_paren_token",
-                    &support::DebugSyntaxResult(self.r_paren_token()),
-                )
+            f.debug_struct("CssQueryFeatureReverseRange")
+                .field("left", &support::DebugSyntaxResult(self.left()))
+                .field("comparison", &support::DebugSyntaxResult(self.comparison()))
+                .field("right", &support::DebugSyntaxResult(self.right()))
                 .finish()
         } else {
-            f.debug_struct("CssPseudoClassFunctionSelector").finish()
+            f.debug_struct("CssQueryFeatureReverseRange").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssPseudoClassFunctionSelector> for SyntaxNode {
-    fn from(n: CssPseudoClassFunctionSelector) -> Self {
+impl From<CssQueryFeatureReverseRange> for SyntaxNode {
+    fn from(n: CssQueryFeatureReverseRange) -> Self {
         n.syntax
     }
 }
-impl From<CssPseudoClassFunctionSelector> for SyntaxElement {
-    fn from(n: CssPseudoClassFunctionSelector) -> Self {
+impl From<CssQueryFeatureReverseRange> for SyntaxElement {
+    fn from(n: CssQueryFeatureReverseRange) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssPseudoClassFunctionSelectorList {
+impl AstNode for CssRatio {
     type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> = SyntaxKindSet::from_raw(RawSyntaxKind(
-        CSS_PSEUDO_CLASS_FUNCTION_SELECTOR_LIST as u16,
-    ));
+    const KIND_SET: SyntaxKindSet<Language> =
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_RATIO as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_PSEUDO_CLASS_FUNCTION_SELECTOR_LIST
+        kind == CSS_RATIO
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -17463,48 +17250,46 @@ impl AstNode for CssPseudoClassFunctionSelectorList {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssPseudoClassFunctionSelectorList {
+impl std::fmt::Debug for CssRatio {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssPseudoClassFunctionSelectorList")
-                .field("name", &support::DebugSyntaxResult(self.name()))
+            f.debug_struct("CssRatio")
+                .field("numerator", &support::DebugSyntaxResult(self.numerator()))
                 .field(
-                    "l_paren_token",
-                    &support::DebugSyntaxResult(self.l_paren_token()),
+                    "slash_token",
+                    &support::DebugSyntaxResult(self.slash_token()),
                 )
-                .field("selectors", &self.selectors())
                 .field(
-                    "r_paren_token",
-                    &support::DebugSyntaxResult(self.r_paren_token()),
+                    "denominator",
+                    &support::DebugSyntaxResult(self.denominator()),
                 )
                 .finish()
         } else {
-            f.debug_struct("CssPseudoClassFunctionSelectorList")
-                .finish()
+            f.debug_struct("CssRatio").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssPseudoClassFunctionSelectorList> for SyntaxNode {
-    fn from(n: CssPseudoClassFunctionSelectorList) -> Self {
+impl From<CssRatio> for SyntaxNode {
+    fn from(n: CssRatio) -> Self {
         n.syntax
     }
 }
-impl From<CssPseudoClassFunctionSelectorList> for SyntaxElement {
-    fn from(n: CssPseudoClassFunctionSelectorList) -> Self {
+impl From<CssRatio> for SyntaxElement {
+    fn from(n: CssRatio) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssPseudoClassFunctionValueList {
+impl AstNode for CssRegularDimension {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_PSEUDO_CLASS_FUNCTION_VALUE_LIST as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_REGULAR_DIMENSION as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_PSEUDO_CLASS_FUNCTION_VALUE_LIST
+        kind == CSS_REGULAR_DIMENSION
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -17520,47 +17305,42 @@ impl AstNode for CssPseudoClassFunctionValueList {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssPseudoClassFunctionValueList {
+impl std::fmt::Debug for CssRegularDimension {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssPseudoClassFunctionValueList")
-                .field("name", &support::DebugSyntaxResult(self.name()))
-                .field(
-                    "l_paren_token",
-                    &support::DebugSyntaxResult(self.l_paren_token()),
-                )
-                .field("values", &self.values())
+            f.debug_struct("CssRegularDimension")
                 .field(
-                    "r_paren_token",
-                    &support::DebugSyntaxResult(self.r_paren_token()),
+                    "value_token",
+                    &support::DebugSyntaxResult(self.value_token()),
                 )
+                .field("unit_token", &support::DebugSyntaxResult(self.unit_token()))
                 .finish()
         } else {
-            f.debug_struct("CssPseudoClassFunctionValueList").finish()
+            f.debug_struct("CssRegularDimension").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssPseudoClassFunctionValueList> for SyntaxNode {
-    fn from(n: CssPseudoClassFunctionValueList) -> Self {
+impl From<CssRegularDimension> for SyntaxNode {
+    fn from(n: CssRegularDimension) -> Self {
         n.syntax
     }
 }
-impl From<CssPseudoClassFunctionValueList> for SyntaxElement {
-    fn from(n: CssPseudoClassFunctionValueList) -> Self {
+impl From<CssRegularDimension> for SyntaxElement {
+    fn from(n: CssRegularDimension) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssPseudoClassIdentifier {
+impl AstNode for CssRelativeSelector {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_PSEUDO_CLASS_IDENTIFIER as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_RELATIVE_SELECTOR as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_PSEUDO_CLASS_IDENTIFIER
+        kind == CSS_RELATIVE_SELECTOR
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -17576,38 +17356,42 @@ impl AstNode for CssPseudoClassIdentifier {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssPseudoClassIdentifier {
+impl std::fmt::Debug for CssRelativeSelector {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssPseudoClassIdentifier")
-                .field("name", &support::DebugSyntaxResult(self.name()))
+            f.debug_struct("CssRelativeSelector")
+                .field(
+                    "combinator",
+                    &support::DebugOptionalElement(self.combinator()),
+                )
+                .field("selector", &support::DebugSyntaxResult(self.selector()))
                 .finish()
         } else {
-            f.debug_struct("CssPseudoClassIdentifier").finish()
+            f.debug_struct("CssRelativeSelector").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssPseudoClassIdentifier> for SyntaxNode {
-    fn from(n: CssPseudoClassIdentifier) -> Self {
+impl From<CssRelativeSelector> for SyntaxNode {
+    fn from(n: CssRelativeSelector) -> Self {
         n.syntax
     }
 }
-impl From<CssPseudoClassIdentifier> for SyntaxElement {
-    fn from(n: CssPseudoClassIdentifier) -> Self {
+impl From<CssRelativeSelector> for SyntaxElement {
+    fn from(n: CssRelativeSelector) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssPseudoClassNth {
+impl AstNode for CssRoot {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_PSEUDO_CLASS_NTH as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_ROOT as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_PSEUDO_CLASS_NTH
+        kind == CSS_ROOT
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -17623,44 +17407,43 @@ impl AstNode for CssPseudoClassNth {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssPseudoClassNth {
+impl std::fmt::Debug for CssRoot {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssPseudoClassNth")
-                .field("sign", &support::DebugOptionalElement(self.sign()))
-                .field("value", &support::DebugOptionalElement(self.value()))
+            f.debug_struct("CssRoot")
                 .field(
-                    "symbol_token",
-                    &support::DebugSyntaxResult(self.symbol_token()),
+                    "bom_token",
+                    &support::DebugOptionalElement(self.bom_token()),
                 )
-                .field("offset", &support::DebugOptionalElement(self.offset()))
+                .field("rules", &self.rules())
+                .field("eof_token", &support::DebugSyntaxResult(self.eof_token()))
                 .finish()
         } else {
-            f.debug_struct("CssPseudoClassNth").finish()
+            f.debug_struct("CssRoot").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssPseudoClassNth> for SyntaxNode {
-    fn from(n: CssPseudoClassNth) -> Self {
+impl From<CssRoot> for SyntaxNode {
+    fn from(n: CssRoot) -> Self {
         n.syntax
     }
 }
-impl From<CssPseudoClassNth> for SyntaxElement {
-    fn from(n: CssPseudoClassNth) -> Self {
+impl From<CssRoot> for SyntaxElement {
+    fn from(n: CssRoot) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssPseudoClassNthIdentifier {
+impl AstNode for CssRuleBlock {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_PSEUDO_CLASS_NTH_IDENTIFIER as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_RULE_BLOCK as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_PSEUDO_CLASS_NTH_IDENTIFIER
+        kind == CSS_RULE_BLOCK
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -17676,38 +17459,46 @@ impl AstNode for CssPseudoClassNthIdentifier {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssPseudoClassNthIdentifier {
+impl std::fmt::Debug for CssRuleBlock {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssPseudoClassNthIdentifier")
-                .field("value", &support::DebugSyntaxResult(self.value()))
+            f.debug_struct("CssRuleBlock")
+                .field(
+                    "l_curly_token",
+                    &support::DebugSyntaxResult(self.l_curly_token()),
+                )
+                .field("rules", &self.rules())
+                .field(
+                    "r_curly_token",
+                    &support::DebugSyntaxResult(self.r_curly_token()),
+                )
                 .finish()
         } else {
-            f.debug_struct("CssPseudoClassNthIdentifier").finish()
+            f.debug_struct("CssRuleBlock").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssPseudoClassNthIdentifier> for SyntaxNode {
-    fn from(n: CssPseudoClassNthIdentifier) -> Self {
+impl From<CssRuleBlock> for SyntaxNode {
+    fn from(n: CssRuleBlock) -> Self {
         n.syntax
     }
 }
-impl From<CssPseudoClassNthIdentifier> for SyntaxElement {
-    fn from(n: CssPseudoClassNthIdentifier) -> Self {
+impl From<CssRuleBlock> for SyntaxElement {
+    fn from(n: CssRuleBlock) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssPseudoClassNthNumber {
+impl AstNode for CssScopeAtRule {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_PSEUDO_CLASS_NTH_NUMBER as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_SCOPE_AT_RULE as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_PSEUDO_CLASS_NTH_NUMBER
+        kind == CSS_SCOPE_AT_RULE
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -17723,39 +17514,39 @@ impl AstNode for CssPseudoClassNthNumber {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssPseudoClassNthNumber {
+impl std::fmt::Debug for CssScopeAtRule {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssPseudoClassNthNumber")
-                .field("sign", &support::DebugOptionalElement(self.sign()))
-                .field("value", &support::DebugSyntaxResult(self.value()))
+            f.debug_struct("CssScopeAtRule")
+                .field("declarator", &support::DebugSyntaxResult(self.declarator()))
+                .field("block", &support::DebugSyntaxResult(self.block()))
                 .finish()
         } else {
-            f.debug_struct("CssPseudoClassNthNumber").finish()
+            f.debug_struct("CssScopeAtRule").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssPseudoClassNthNumber> for SyntaxNode {
-    fn from(n: CssPseudoClassNthNumber) -> Self {
+impl From<CssScopeAtRule> for SyntaxNode {
+    fn from(n: CssScopeAtRule) -> Self {
         n.syntax
     }
 }
-impl From<CssPseudoClassNthNumber> for SyntaxElement {
-    fn from(n: CssPseudoClassNthNumber) -> Self {
+impl From<CssScopeAtRule> for SyntaxElement {
+    fn from(n: CssScopeAtRule) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssPseudoClassNthSelector {
+impl AstNode for CssScopeAtRuleDeclarator {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_PSEUDO_CLASS_NTH_SELECTOR as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_SCOPE_AT_RULE_DECLARATOR as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_PSEUDO_CLASS_NTH_SELECTOR
+        kind == CSS_SCOPE_AT_RULE_DECLARATOR
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -17771,42 +17562,42 @@ impl AstNode for CssPseudoClassNthSelector {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssPseudoClassNthSelector {
+impl std::fmt::Debug for CssScopeAtRuleDeclarator {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssPseudoClassNthSelector")
-                .field("nth", &support::DebugSyntaxResult(self.nth()))
+            f.debug_struct("CssScopeAtRuleDeclarator")
                 .field(
-                    "of_selector",
-                    &support::DebugOptionalElement(self.of_selector()),
+                    "scope_token",
+                    &support::DebugSyntaxResult(self.scope_token()),
                 )
+                .field("range", &support::DebugOptionalElement(self.range()))
                 .finish()
         } else {
-            f.debug_struct("CssPseudoClassNthSelector").finish()
+            f.debug_struct("CssScopeAtRuleDeclarator").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssPseudoClassNthSelector> for SyntaxNode {
-    fn from(n: CssPseudoClassNthSelector) -> Self {
+impl From<CssScopeAtRuleDeclarator> for SyntaxNode {
+    fn from(n: CssScopeAtRuleDeclarator) -> Self {
         n.syntax
     }
 }
-impl From<CssPseudoClassNthSelector> for SyntaxElement {
-    fn from(n: CssPseudoClassNthSelector) -> Self {
+impl From<CssScopeAtRuleDeclarator> for SyntaxElement {
+    fn from(n: CssScopeAtRuleDeclarator) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssPseudoClassOfNthSelector {
+impl AstNode for CssScopeEdge {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_PSEUDO_CLASS_OF_NTH_SELECTOR as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_SCOPE_EDGE as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_PSEUDO_CLASS_OF_NTH_SELECTOR
+        kind == CSS_SCOPE_EDGE
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -17822,39 +17613,46 @@ impl AstNode for CssPseudoClassOfNthSelector {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssPseudoClassOfNthSelector {
+impl std::fmt::Debug for CssScopeEdge {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssPseudoClassOfNthSelector")
-                .field("of_token", &support::DebugSyntaxResult(self.of_token()))
-                .field("selectors", &self.selectors())
-                .finish()
-        } else {
-            f.debug_struct("CssPseudoClassOfNthSelector").finish()
+            f.debug_struct("CssScopeEdge")
+                .field(
+                    "l_paren_token",
+                    &support::DebugSyntaxResult(self.l_paren_token()),
+                )
+                .field("selectors", &self.selectors())
+                .field(
+                    "r_paren_token",
+                    &support::DebugSyntaxResult(self.r_paren_token()),
+                )
+                .finish()
+        } else {
+            f.debug_struct("CssScopeEdge").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssPseudoClassOfNthSelector> for SyntaxNode {
-    fn from(n: CssPseudoClassOfNthSelector) -> Self {
+impl From<CssScopeEdge> for SyntaxNode {
+    fn from(n: CssScopeEdge) -> Self {
         n.syntax
     }
 }
-impl From<CssPseudoClassOfNthSelector> for SyntaxElement {
-    fn from(n: CssPseudoClassOfNthSelector) -> Self {
+impl From<CssScopeEdge> for SyntaxElement {
+    fn from(n: CssScopeEdge) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssPseudoClassSelector {
+impl AstNode for CssScopeRangeEnd {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_PSEUDO_CLASS_SELECTOR as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_SCOPE_RANGE_END as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_PSEUDO_CLASS_SELECTOR
+        kind == CSS_SCOPE_RANGE_END
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -17870,42 +17668,39 @@ impl AstNode for CssPseudoClassSelector {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssPseudoClassSelector {
+impl std::fmt::Debug for CssScopeRangeEnd {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssPseudoClassSelector")
-                .field(
-                    "colon_token",
-                    &support::DebugSyntaxResult(self.colon_token()),
-                )
-                .field("class", &support::DebugSyntaxResult(self.class()))
+            f.debug_struct("CssScopeRangeEnd")
+                .field("to_token", &support::DebugSyntaxResult(self.to_token()))
+                .field("end", &support::DebugSyntaxResult(self.end()))
                 .finish()
         } else {
-            f.debug_struct("CssPseudoClassSelector").finish()
+            f.debug_struct("CssScopeRangeEnd").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssPseudoClassSelector> for SyntaxNode {
-    fn from(n: CssPseudoClassSelector) -> Self {
+impl From<CssScopeRangeEnd> for SyntaxNode {
+    fn from(n: CssScopeRangeEnd) -> Self {
         n.syntax
     }
 }
-impl From<CssPseudoClassSelector> for SyntaxElement {
-    fn from(n: CssPseudoClassSelector) -> Self {
+impl From<CssScopeRangeEnd> for SyntaxElement {
+    fn from(n: CssScopeRangeEnd) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssPseudoElementFunction {
+impl AstNode for CssScopeRangeInterval {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_PSEUDO_ELEMENT_FUNCTION as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_SCOPE_RANGE_INTERVAL as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_PSEUDO_ELEMENT_FUNCTION
+        kind == CSS_SCOPE_RANGE_INTERVAL
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -17921,48 +17716,40 @@ impl AstNode for CssPseudoElementFunction {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssPseudoElementFunction {
+impl std::fmt::Debug for CssScopeRangeInterval {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssPseudoElementFunction")
-                .field("name", &support::DebugSyntaxResult(self.name()))
-                .field(
-                    "l_paren_token",
-                    &support::DebugSyntaxResult(self.l_paren_token()),
-                )
-                .field("items", &self.items())
-                .field(
-                    "r_paren_token",
-                    &support::DebugSyntaxResult(self.r_paren_token()),
-                )
+            f.debug_struct("CssScopeRangeInterval")
+                .field("start", &support::DebugSyntaxResult(self.start()))
+                .field("to_token", &support::DebugSyntaxResult(self.to_token()))
+                .field("end", &support::DebugSyntaxResult(self.end()))
                 .finish()
         } else {
-            f.debug_struct("CssPseudoElementFunction").finish()
+            f.debug_struct("CssScopeRangeInterval").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssPseudoElementFunction> for SyntaxNode {
-    fn from(n: CssPseudoElementFunction) -> Self {
+impl From<CssScopeRangeInterval> for SyntaxNode {
+    fn from(n: CssScopeRangeInterval) -> Self {
         n.syntax
     }
 }
-impl From<CssPseudoElementFunction> for SyntaxElement {
-    fn from(n: CssPseudoElementFunction) -> Self {
+impl From<CssScopeRangeInterval> for SyntaxElement {
+    fn from(n: CssScopeRangeInterval) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssPseudoElementFunctionCustomIdentifier {
+impl AstNode for CssScopeRangeStart {
     type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> = SyntaxKindSet::from_raw(RawSyntaxKind(
-        CSS_PSEUDO_ELEMENT_FUNCTION_CUSTOM_IDENTIFIER as u16,
-    ));
+    const KIND_SET: SyntaxKindSet<Language> =
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_SCOPE_RANGE_START as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_PSEUDO_ELEMENT_FUNCTION_CUSTOM_IDENTIFIER
+        kind == CSS_SCOPE_RANGE_START
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -17978,48 +17765,38 @@ impl AstNode for CssPseudoElementFunctionCustomIdentifier {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssPseudoElementFunctionCustomIdentifier {
+impl std::fmt::Debug for CssScopeRangeStart {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssPseudoElementFunctionCustomIdentifier")
-                .field("name", &support::DebugSyntaxResult(self.name()))
-                .field(
-                    "l_paren_token",
-                    &support::DebugSyntaxResult(self.l_paren_token()),
-                )
-                .field("ident", &support::DebugSyntaxResult(self.ident()))
-                .field(
-                    "r_paren_token",
-                    &support::DebugSyntaxResult(self.r_paren_token()),
-                )
+            f.debug_struct("CssScopeRangeStart")
+                .field("start", &support::DebugSyntaxResult(self.start()))
                 .finish()
         } else {
-            f.debug_struct("CssPseudoElementFunctionCustomIdentifier")
-                .finish()
+            f.debug_struct("CssScopeRangeStart").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssPseudoElementFunctionCustomIdentifier> for SyntaxNode {
-    fn from(n: CssPseudoElementFunctionCustomIdentifier) -> Self {
+impl From<CssScopeRangeStart> for SyntaxNode {
+    fn from(n: CssScopeRangeStart) -> Self {
         n.syntax
     }
 }
-impl From<CssPseudoElementFunctionCustomIdentifier> for SyntaxElement {
-    fn from(n: CssPseudoElementFunctionCustomIdentifier) -> Self {
+impl From<CssScopeRangeStart> for SyntaxElement {
+    fn from(n: CssScopeRangeStart) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssPseudoElementFunctionSelector {
+impl AstNode for CssStartingStyleAtRule {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_PSEUDO_ELEMENT_FUNCTION_SELECTOR as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_STARTING_STYLE_AT_RULE as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_PSEUDO_ELEMENT_FUNCTION_SELECTOR
+        kind == CSS_STARTING_STYLE_AT_RULE
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -18035,47 +17812,39 @@ impl AstNode for CssPseudoElementFunctionSelector {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssPseudoElementFunctionSelector {
+impl std::fmt::Debug for CssStartingStyleAtRule {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssPseudoElementFunctionSelector")
-                .field("name", &support::DebugSyntaxResult(self.name()))
-                .field(
-                    "l_paren_token",
-                    &support::DebugSyntaxResult(self.l_paren_token()),
-                )
-                .field("selector", &support::DebugSyntaxResult(self.selector()))
-                .field(
-                    "r_paren_token",
-                    &support::DebugSyntaxResult(self.r_paren_token()),
-                )
+            f.debug_struct("CssStartingStyleAtRule")
+                .field("declarator", &support::DebugSyntaxResult(self.declarator()))
+                .field("block", &support::DebugSyntaxResult(self.block()))
                 .finish()
         } else {
-            f.debug_struct("CssPseudoElementFunctionSelector").finish()
+            f.debug_struct("CssStartingStyleAtRule").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssPseudoElementFunctionSelector> for SyntaxNode {
-    fn from(n: CssPseudoElementFunctionSelector) -> Self {
+impl From<CssStartingStyleAtRule> for SyntaxNode {
+    fn from(n: CssStartingStyleAtRule) -> Self {
         n.syntax
     }
 }
-impl From<CssPseudoElementFunctionSelector> for SyntaxElement {
-    fn from(n: CssPseudoElementFunctionSelector) -> Self {
+impl From<CssStartingStyleAtRule> for SyntaxElement {
+    fn from(n: CssStartingStyleAtRule) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssPseudoElementIdentifier {
+impl AstNode for CssStartingStyleAtRuleDeclarator {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_PSEUDO_ELEMENT_IDENTIFIER as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_STARTING_STYLE_AT_RULE_DECLARATOR as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_PSEUDO_ELEMENT_IDENTIFIER
+        kind == CSS_STARTING_STYLE_AT_RULE_DECLARATOR
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -18091,38 +17860,41 @@ impl AstNode for CssPseudoElementIdentifier {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssPseudoElementIdentifier {
+impl std::fmt::Debug for CssStartingStyleAtRuleDeclarator {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssPseudoElementIdentifier")
-                .field("name", &support::DebugSyntaxResult(self.name()))
+            f.debug_struct("CssStartingStyleAtRuleDeclarator")
+                .field(
+                    "starting_style_token",
+                    &support::DebugSyntaxResult(self.starting_style_token()),
+                )
                 .finish()
         } else {
-            f.debug_struct("CssPseudoElementIdentifier").finish()
+            f.debug_struct("CssStartingStyleAtRuleDeclarator").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssPseudoElementIdentifier> for SyntaxNode {
-    fn from(n: CssPseudoElementIdentifier) -> Self {
+impl From<CssStartingStyleAtRuleDeclarator> for SyntaxNode {
+    fn from(n: CssStartingStyleAtRuleDeclarator) -> Self {
         n.syntax
     }
 }
-impl From<CssPseudoElementIdentifier> for SyntaxElement {
-    fn from(n: CssPseudoElementIdentifier) -> Self {
+impl From<CssStartingStyleAtRuleDeclarator> for SyntaxElement {
+    fn from(n: CssStartingStyleAtRuleDeclarator) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssPseudoElementSelector {
+impl AstNode for CssString {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_PSEUDO_ELEMENT_SELECTOR as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_STRING as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_PSEUDO_ELEMENT_SELECTOR
+        kind == CSS_STRING
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -18138,42 +17910,41 @@ impl AstNode for CssPseudoElementSelector {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssPseudoElementSelector {
+impl std::fmt::Debug for CssString {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssPseudoElementSelector")
+            f.debug_struct("CssString")
                 .field(
-                    "double_colon_token",
-                    &support::DebugSyntaxResult(self.double_colon_token()),
+                    "value_token",
+                    &support::DebugSyntaxResult(self.value_token()),
                 )
-                .field("element", &support::DebugSyntaxResult(self.element()))
                 .finish()
         } else {
-            f.debug_struct("CssPseudoElementSelector").finish()
+            f.debug_struct("CssString").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssPseudoElementSelector> for SyntaxNode {
-    fn from(n: CssPseudoElementSelector) -> Self {
+impl From<CssString> for SyntaxNode {
+    fn from(n: CssString) -> Self {
         n.syntax
     }
 }
-impl From<CssPseudoElementSelector> for SyntaxElement {
-    fn from(n: CssPseudoElementSelector) -> Self {
+impl From<CssString> for SyntaxElement {
+    fn from(n: CssString) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssQualifiedRule {
+impl AstNode for CssSupportsAndCondition {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_QUALIFIED_RULE as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_SUPPORTS_AND_CONDITION as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_QUALIFIED_RULE
+        kind == CSS_SUPPORTS_AND_CONDITION
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -18189,39 +17960,40 @@ impl AstNode for CssQualifiedRule {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssQualifiedRule {
+impl std::fmt::Debug for CssSupportsAndCondition {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssQualifiedRule")
-                .field("prelude", &self.prelude())
-                .field("block", &support::DebugSyntaxResult(self.block()))
+            f.debug_struct("CssSupportsAndCondition")
+                .field("left", &support::DebugSyntaxResult(self.left()))
+                .field("and_token", &support::DebugSyntaxResult(self.and_token()))
+                .field("right", &support::DebugSyntaxResult(self.right()))
                 .finish()
         } else {
-            f.debug_struct("CssQualifiedRule").finish()
+            f.debug_struct("CssSupportsAndCondition").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssQualifiedRule> for SyntaxNode {
-    fn from(n: CssQualifiedRule) -> Self {
+impl From<CssSupportsAndCondition> for SyntaxNode {
+    fn from(n: CssSupportsAndCondition) -> Self {
         n.syntax
     }
 }
-impl From<CssQualifiedRule> for SyntaxElement {
-    fn from(n: CssQualifiedRule) -> Self {
+impl From<CssSupportsAndCondition> for SyntaxElement {
+    fn from(n: CssSupportsAndCondition) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssQueryFeatureBoolean {
+impl AstNode for CssSupportsAtRule {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_QUERY_FEATURE_BOOLEAN as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_SUPPORTS_AT_RULE as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_QUERY_FEATURE_BOOLEAN
+        kind == CSS_SUPPORTS_AT_RULE
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -18237,38 +18009,39 @@ impl AstNode for CssQueryFeatureBoolean {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssQueryFeatureBoolean {
+impl std::fmt::Debug for CssSupportsAtRule {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssQueryFeatureBoolean")
-                .field("name", &support::DebugSyntaxResult(self.name()))
+            f.debug_struct("CssSupportsAtRule")
+                .field("declarator", &support::DebugSyntaxResult(self.declarator()))
+                .field("block", &support::DebugSyntaxResult(self.block()))
                 .finish()
         } else {
-            f.debug_struct("CssQueryFeatureBoolean").finish()
+            f.debug_struct("CssSupportsAtRule").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssQueryFeatureBoolean> for SyntaxNode {
-    fn from(n: CssQueryFeatureBoolean) -> Self {
+impl From<CssSupportsAtRule> for SyntaxNode {
+    fn from(n: CssSupportsAtRule) -> Self {
         n.syntax
     }
 }
-impl From<CssQueryFeatureBoolean> for SyntaxElement {
-    fn from(n: CssQueryFeatureBoolean) -> Self {
+impl From<CssSupportsAtRule> for SyntaxElement {
+    fn from(n: CssSupportsAtRule) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssQueryFeaturePlain {
+impl AstNode for CssSupportsAtRuleDeclarator {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_QUERY_FEATURE_PLAIN as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_SUPPORTS_AT_RULE_DECLARATOR as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_QUERY_FEATURE_PLAIN
+        kind == CSS_SUPPORTS_AT_RULE_DECLARATOR
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -18284,43 +18057,42 @@ impl AstNode for CssQueryFeaturePlain {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssQueryFeaturePlain {
+impl std::fmt::Debug for CssSupportsAtRuleDeclarator {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssQueryFeaturePlain")
-                .field("name", &support::DebugSyntaxResult(self.name()))
+            f.debug_struct("CssSupportsAtRuleDeclarator")
                 .field(
-                    "colon_token",
-                    &support::DebugSyntaxResult(self.colon_token()),
+                    "supports_token",
+                    &support::DebugSyntaxResult(self.supports_token()),
                 )
-                .field("value", &support::DebugSyntaxResult(self.value()))
+                .field("condition", &support::DebugSyntaxResult(self.condition()))
                 .finish()
         } else {
-            f.debug_struct("CssQueryFeaturePlain").finish()
+            f.debug_struct("CssSupportsAtRuleDeclarator").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssQueryFeaturePlain> for SyntaxNode {
-    fn from(n: CssQueryFeaturePlain) -> Self {
+impl From<CssSupportsAtRuleDeclarator> for SyntaxNode {
+    fn from(n: CssSupportsAtRuleDeclarator) -> Self {
         n.syntax
     }
 }
-impl From<CssQueryFeaturePlain> for SyntaxElement {
-    fn from(n: CssQueryFeaturePlain) -> Self {
+impl From<CssSupportsAtRuleDeclarator> for SyntaxElement {
+    fn from(n: CssSupportsAtRuleDeclarator) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssQueryFeatureRange {
+impl AstNode for CssSupportsConditionInParens {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_QUERY_FEATURE_RANGE as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_SUPPORTS_CONDITION_IN_PARENS as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_QUERY_FEATURE_RANGE
+        kind == CSS_SUPPORTS_CONDITION_IN_PARENS
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -18336,40 +18108,46 @@ impl AstNode for CssQueryFeatureRange {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssQueryFeatureRange {
+impl std::fmt::Debug for CssSupportsConditionInParens {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssQueryFeatureRange")
-                .field("left", &support::DebugSyntaxResult(self.left()))
-                .field("comparison", &support::DebugSyntaxResult(self.comparison()))
-                .field("right", &support::DebugSyntaxResult(self.right()))
+            f.debug_struct("CssSupportsConditionInParens")
+                .field(
+                    "l_paren_token",
+                    &support::DebugSyntaxResult(self.l_paren_token()),
+                )
+                .field("condition", &support::DebugSyntaxResult(self.condition()))
+                .field(
+                    "r_paren_token",
+                    &support::DebugSyntaxResult(self.r_paren_token()),
+                )
                 .finish()
         } else {
-            f.debug_struct("CssQueryFeatureRange").finish()
+            f.debug_struct("CssSupportsConditionInParens").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssQueryFeatureRange> for SyntaxNode {
-    fn from(n: CssQueryFeatureRange) -> Self {
+impl From<CssSupportsConditionInParens> for SyntaxNode {
+    fn from(n: CssSupportsConditionInParens) -> Self {
         n.syntax
     }
 }
-impl From<CssQueryFeatureRange> for SyntaxElement {
-    fn from(n: CssQueryFeatureRange) -> Self {
+impl From<CssSupportsConditionInParens> for SyntaxElement {
+    fn from(n: CssSupportsConditionInParens) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssQueryFeatureRangeComparison {
+impl AstNode for CssSupportsFeatureDeclaration {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_QUERY_FEATURE_RANGE_COMPARISON as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_SUPPORTS_FEATURE_DECLARATION as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_QUERY_FEATURE_RANGE_COMPARISON
+        kind == CSS_SUPPORTS_FEATURE_DECLARATION
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -18385,38 +18163,49 @@ impl AstNode for CssQueryFeatureRangeComparison {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssQueryFeatureRangeComparison {
+impl std::fmt::Debug for CssSupportsFeatureDeclaration {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssQueryFeatureRangeComparison")
-                .field("operator", &support::DebugSyntaxResult(self.operator()))
+            f.debug_struct("CssSupportsFeatureDeclaration")
+                .field(
+                    "l_paren_token",
+                    &support::DebugSyntaxResult(self.l_paren_token()),
+                )
+                .field(
+                    "declaration",
+                    &support::DebugSyntaxResult(self.declaration()),
+                )
+                .field(
+                    "r_paren_token",
+                    &support::DebugSyntaxResult(self.r_paren_token()),
+                )
                 .finish()
         } else {
-            f.debug_struct("CssQueryFeatureRangeComparison").finish()
+            f.debug_struct("CssSupportsFeatureDeclaration").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssQueryFeatureRangeComparison> for SyntaxNode {
-    fn from(n: CssQueryFeatureRangeComparison) -> Self {
+impl From<CssSupportsFeatureDeclaration> for SyntaxNode {
+    fn from(n: CssSupportsFeatureDeclaration) -> Self {
         n.syntax
     }
 }
-impl From<CssQueryFeatureRangeComparison> for SyntaxElement {
-    fn from(n: CssQueryFeatureRangeComparison) -> Self {
+impl From<CssSupportsFeatureDeclaration> for SyntaxElement {
+    fn from(n: CssSupportsFeatureDeclaration) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssQueryFeatureRangeInterval {
+impl AstNode for CssSupportsFeatureSelector {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_QUERY_FEATURE_RANGE_INTERVAL as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_SUPPORTS_FEATURE_SELECTOR as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_QUERY_FEATURE_RANGE_INTERVAL
+        kind == CSS_SUPPORTS_FEATURE_SELECTOR
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -18432,48 +18221,50 @@ impl AstNode for CssQueryFeatureRangeInterval {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssQueryFeatureRangeInterval {
+impl std::fmt::Debug for CssSupportsFeatureSelector {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssQueryFeatureRangeInterval")
-                .field("left", &support::DebugSyntaxResult(self.left()))
+            f.debug_struct("CssSupportsFeatureSelector")
                 .field(
-                    "left_comparison",
-                    &support::DebugSyntaxResult(self.left_comparison()),
+                    "selector_token",
+                    &support::DebugSyntaxResult(self.selector_token()),
                 )
-                .field("name", &support::DebugSyntaxResult(self.name()))
                 .field(
-                    "right_comparison",
-                    &support::DebugSyntaxResult(self.right_comparison()),
+                    "l_paren_token",
+                    &support::DebugSyntaxResult(self.l_paren_token()),
+                )
+                .field("selector", &support::DebugSyntaxResult(self.selector()))
+                .field(
+                    "r_paren_token",
+                    &support::DebugSyntaxResult(self.r_paren_token()),
                 )
-                .field("right", &support::DebugSyntaxResult(self.right()))
                 .finish()
         } else {
-            f.debug_struct("CssQueryFeatureRangeInterval").finish()
+            f.debug_struct("CssSupportsFeatureSelector").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssQueryFeatureRangeInterval> for SyntaxNode {
-    fn from(n: CssQueryFeatureRangeInterval) -> Self {
+impl From<CssSupportsFeatureSelector> for SyntaxNode {
+    fn from(n: CssSupportsFeatureSelector) -> Self {
         n.syntax
     }
 }
-impl From<CssQueryFeatureRangeInterval> for SyntaxElement {
-    fn from(n: CssQueryFeatureRangeInterval) -> Self {
+impl From<CssSupportsFeatureSelector> for SyntaxElement {
+    fn from(n: CssSupportsFeatureSelector) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssQueryFeatureReverseRange {
+impl AstNode for CssSupportsNotCondition {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_QUERY_FEATURE_REVERSE_RANGE as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_SUPPORTS_NOT_CONDITION as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_QUERY_FEATURE_REVERSE_RANGE
+        kind == CSS_SUPPORTS_NOT_CONDITION
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -18489,40 +18280,39 @@ impl AstNode for CssQueryFeatureReverseRange {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssQueryFeatureReverseRange {
+impl std::fmt::Debug for CssSupportsNotCondition {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssQueryFeatureReverseRange")
-                .field("left", &support::DebugSyntaxResult(self.left()))
-                .field("comparison", &support::DebugSyntaxResult(self.comparison()))
-                .field("right", &support::DebugSyntaxResult(self.right()))
+            f.debug_struct("CssSupportsNotCondition")
+                .field("not_token", &support::DebugSyntaxResult(self.not_token()))
+                .field("query", &support::DebugSyntaxResult(self.query()))
                 .finish()
         } else {
-            f.debug_struct("CssQueryFeatureReverseRange").finish()
+            f.debug_struct("CssSupportsNotCondition").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssQueryFeatureReverseRange> for SyntaxNode {
-    fn from(n: CssQueryFeatureReverseRange) -> Self {
+impl From<CssSupportsNotCondition> for SyntaxNode {
+    fn from(n: CssSupportsNotCondition) -> Self {
         n.syntax
     }
 }
-impl From<CssQueryFeatureReverseRange> for SyntaxElement {
-    fn from(n: CssQueryFeatureReverseRange) -> Self {
+impl From<CssSupportsNotCondition> for SyntaxElement {
+    fn from(n: CssSupportsNotCondition) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssRatio {
+impl AstNode for CssSupportsOrCondition {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_RATIO as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_SUPPORTS_OR_CONDITION as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_RATIO
+        kind == CSS_SUPPORTS_OR_CONDITION
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -18538,46 +18328,40 @@ impl AstNode for CssRatio {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssRatio {
+impl std::fmt::Debug for CssSupportsOrCondition {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssRatio")
-                .field("numerator", &support::DebugSyntaxResult(self.numerator()))
-                .field(
-                    "slash_token",
-                    &support::DebugSyntaxResult(self.slash_token()),
-                )
-                .field(
-                    "denominator",
-                    &support::DebugSyntaxResult(self.denominator()),
-                )
+            f.debug_struct("CssSupportsOrCondition")
+                .field("left", &support::DebugSyntaxResult(self.left()))
+                .field("or_token", &support::DebugSyntaxResult(self.or_token()))
+                .field("right", &support::DebugSyntaxResult(self.right()))
                 .finish()
         } else {
-            f.debug_struct("CssRatio").finish()
+            f.debug_struct("CssSupportsOrCondition").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssRatio> for SyntaxNode {
-    fn from(n: CssRatio) -> Self {
+impl From<CssSupportsOrCondition> for SyntaxNode {
+    fn from(n: CssSupportsOrCondition) -> Self {
         n.syntax
     }
 }
-impl From<CssRatio> for SyntaxElement {
-    fn from(n: CssRatio) -> Self {
+impl From<CssSupportsOrCondition> for SyntaxElement {
+    fn from(n: CssSupportsOrCondition) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssRegularDimension {
+impl AstNode for CssTypeSelector {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_REGULAR_DIMENSION as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_TYPE_SELECTOR as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_REGULAR_DIMENSION
+        kind == CSS_TYPE_SELECTOR
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -18593,42 +18377,42 @@ impl AstNode for CssRegularDimension {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssRegularDimension {
+impl std::fmt::Debug for CssTypeSelector {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssRegularDimension")
+            f.debug_struct("CssTypeSelector")
                 .field(
-                    "value_token",
-                    &support::DebugSyntaxResult(self.value_token()),
+                    "namespace",
+                    &support::DebugOptionalElement(self.namespace()),
                 )
-                .field("unit_token", &support::DebugSyntaxResult(self.unit_token()))
+                .field("ident", &support::DebugSyntaxResult(self.ident()))
                 .finish()
         } else {
-            f.debug_struct("CssRegularDimension").finish()
+            f.debug_struct("CssTypeSelector").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssRegularDimension> for SyntaxNode {
-    fn from(n: CssRegularDimension) -> Self {
+impl From<CssTypeSelector> for SyntaxNode {
+    fn from(n: CssTypeSelector) -> Self {
         n.syntax
     }
 }
-impl From<CssRegularDimension> for SyntaxElement {
-    fn from(n: CssRegularDimension) -> Self {
+impl From<CssTypeSelector> for SyntaxElement {
+    fn from(n: CssTypeSelector) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssRelativeSelector {
+impl AstNode for CssUnicodeCodepoint {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_RELATIVE_SELECTOR as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_UNICODE_CODEPOINT as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_RELATIVE_SELECTOR
+        kind == CSS_UNICODE_CODEPOINT
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -18644,42 +18428,41 @@ impl AstNode for CssRelativeSelector {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssRelativeSelector {
+impl std::fmt::Debug for CssUnicodeCodepoint {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssRelativeSelector")
+            f.debug_struct("CssUnicodeCodepoint")
                 .field(
-                    "combinator",
-                    &support::DebugOptionalElement(self.combinator()),
+                    "value_token",
+                    &support::DebugSyntaxResult(self.value_token()),
                 )
-                .field("selector", &support::DebugSyntaxResult(self.selector()))
                 .finish()
         } else {
-            f.debug_struct("CssRelativeSelector").finish()
+            f.debug_struct("CssUnicodeCodepoint").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssRelativeSelector> for SyntaxNode {
-    fn from(n: CssRelativeSelector) -> Self {
+impl From<CssUnicodeCodepoint> for SyntaxNode {
+    fn from(n: CssUnicodeCodepoint) -> Self {
         n.syntax
     }
 }
-impl From<CssRelativeSelector> for SyntaxElement {
-    fn from(n: CssRelativeSelector) -> Self {
+impl From<CssUnicodeCodepoint> for SyntaxElement {
+    fn from(n: CssUnicodeCodepoint) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssRoot {
+impl AstNode for CssUnicodeRange {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_ROOT as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_UNICODE_RANGE as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_ROOT
+        kind == CSS_UNICODE_RANGE
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -18695,43 +18478,42 @@ impl AstNode for CssRoot {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssRoot {
+impl std::fmt::Debug for CssUnicodeRange {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssRoot")
+            f.debug_struct("CssUnicodeRange")
                 .field(
-                    "bom_token",
-                    &support::DebugOptionalElement(self.bom_token()),
+                    "prefix_token",
+                    &support::DebugSyntaxResult(self.prefix_token()),
                 )
-                .field("rules", &self.rules())
-                .field("eof_token", &support::DebugSyntaxResult(self.eof_token()))
+                .field("value", &support::DebugSyntaxResult(self.value()))
                 .finish()
         } else {
-            f.debug_struct("CssRoot").finish()
+            f.debug_struct("CssUnicodeRange").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssRoot> for SyntaxNode {
-    fn from(n: CssRoot) -> Self {
+impl From<CssUnicodeRange> for SyntaxNode {
+    fn from(n: CssUnicodeRange) -> Self {
         n.syntax
     }
 }
-impl From<CssRoot> for SyntaxElement {
-    fn from(n: CssRoot) -> Self {
+impl From<CssUnicodeRange> for SyntaxElement {
+    fn from(n: CssUnicodeRange) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssRuleBlock {
+impl AstNode for CssUnicodeRangeInterval {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_RULE_BLOCK as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_UNICODE_RANGE_INTERVAL as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_RULE_BLOCK
+        kind == CSS_UNICODE_RANGE_INTERVAL
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -18747,46 +18529,43 @@ impl AstNode for CssRuleBlock {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssRuleBlock {
+impl std::fmt::Debug for CssUnicodeRangeInterval {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssRuleBlock")
-                .field(
-                    "l_curly_token",
-                    &support::DebugSyntaxResult(self.l_curly_token()),
-                )
-                .field("rules", &self.rules())
+            f.debug_struct("CssUnicodeRangeInterval")
+                .field("start", &support::DebugSyntaxResult(self.start()))
                 .field(
-                    "r_curly_token",
-                    &support::DebugSyntaxResult(self.r_curly_token()),
+                    "minus_token",
+                    &support::DebugSyntaxResult(self.minus_token()),
                 )
+                .field("end", &support::DebugSyntaxResult(self.end()))
                 .finish()
         } else {
-            f.debug_struct("CssRuleBlock").finish()
+            f.debug_struct("CssUnicodeRangeInterval").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssRuleBlock> for SyntaxNode {
-    fn from(n: CssRuleBlock) -> Self {
+impl From<CssUnicodeRangeInterval> for SyntaxNode {
+    fn from(n: CssUnicodeRangeInterval) -> Self {
         n.syntax
     }
 }
-impl From<CssRuleBlock> for SyntaxElement {
-    fn from(n: CssRuleBlock) -> Self {
+impl From<CssUnicodeRangeInterval> for SyntaxElement {
+    fn from(n: CssUnicodeRangeInterval) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssScopeAtRule {
+impl AstNode for CssUnicodeRangeWildcard {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_SCOPE_AT_RULE as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_UNICODE_RANGE_WILDCARD as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_SCOPE_AT_RULE
+        kind == CSS_UNICODE_RANGE_WILDCARD
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -18802,39 +18581,41 @@ impl AstNode for CssScopeAtRule {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssScopeAtRule {
+impl std::fmt::Debug for CssUnicodeRangeWildcard {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssScopeAtRule")
-                .field("declarator", &support::DebugSyntaxResult(self.declarator()))
-                .field("block", &support::DebugSyntaxResult(self.block()))
+            f.debug_struct("CssUnicodeRangeWildcard")
+                .field(
+                    "value_token",
+                    &support::DebugSyntaxResult(self.value_token()),
+                )
                 .finish()
         } else {
-            f.debug_struct("CssScopeAtRule").finish()
+            f.debug_struct("CssUnicodeRangeWildcard").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssScopeAtRule> for SyntaxNode {
-    fn from(n: CssScopeAtRule) -> Self {
+impl From<CssUnicodeRangeWildcard> for SyntaxNode {
+    fn from(n: CssUnicodeRangeWildcard) -> Self {
         n.syntax
     }
 }
-impl From<CssScopeAtRule> for SyntaxElement {
-    fn from(n: CssScopeAtRule) -> Self {
+impl From<CssUnicodeRangeWildcard> for SyntaxElement {
+    fn from(n: CssUnicodeRangeWildcard) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssScopeAtRuleDeclarator {
+impl AstNode for CssUniversalNamespacePrefix {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_SCOPE_AT_RULE_DECLARATOR as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_UNIVERSAL_NAMESPACE_PREFIX as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_SCOPE_AT_RULE_DECLARATOR
+        kind == CSS_UNIVERSAL_NAMESPACE_PREFIX
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -18850,42 +18631,38 @@ impl AstNode for CssScopeAtRuleDeclarator {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssScopeAtRuleDeclarator {
+impl std::fmt::Debug for CssUniversalNamespacePrefix {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssScopeAtRuleDeclarator")
-                .field(
-                    "scope_token",
-                    &support::DebugSyntaxResult(self.scope_token()),
-                )
-                .field("range", &support::DebugOptionalElement(self.range()))
+            f.debug_struct("CssUniversalNamespacePrefix")
+                .field("star_token", &support::DebugSyntaxResult(self.star_token()))
                 .finish()
         } else {
-            f.debug_struct("CssScopeAtRuleDeclarator").finish()
+            f.debug_struct("CssUniversalNamespacePrefix").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssScopeAtRuleDeclarator> for SyntaxNode {
-    fn from(n: CssScopeAtRuleDeclarator) -> Self {
+impl From<CssUniversalNamespacePrefix> for SyntaxNode {
+    fn from(n: CssUniversalNamespacePrefix) -> Self {
         n.syntax
     }
 }
-impl From<CssScopeAtRuleDeclarator> for SyntaxElement {
-    fn from(n: CssScopeAtRuleDeclarator) -> Self {
+impl From<CssUniversalNamespacePrefix> for SyntaxElement {
+    fn from(n: CssUniversalNamespacePrefix) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssScopeEdge {
+impl AstNode for CssUniversalSelector {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_SCOPE_EDGE as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_UNIVERSAL_SELECTOR as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_SCOPE_EDGE
+        kind == CSS_UNIVERSAL_SELECTOR
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -18901,46 +18678,42 @@ impl AstNode for CssScopeEdge {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssScopeEdge {
+impl std::fmt::Debug for CssUniversalSelector {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssScopeEdge")
-                .field(
-                    "l_paren_token",
-                    &support::DebugSyntaxResult(self.l_paren_token()),
-                )
-                .field("selectors", &self.selectors())
+            f.debug_struct("CssUniversalSelector")
                 .field(
-                    "r_paren_token",
-                    &support::DebugSyntaxResult(self.r_paren_token()),
+                    "namespace",
+                    &support::DebugOptionalElement(self.namespace()),
                 )
+                .field("star_token", &support::DebugSyntaxResult(self.star_token()))
                 .finish()
         } else {
-            f.debug_struct("CssScopeEdge").finish()
+            f.debug_struct("CssUniversalSelector").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssScopeEdge> for SyntaxNode {
-    fn from(n: CssScopeEdge) -> Self {
+impl From<CssUniversalSelector> for SyntaxNode {
+    fn from(n: CssUniversalSelector) -> Self {
         n.syntax
     }
 }
-impl From<CssScopeEdge> for SyntaxElement {
-    fn from(n: CssScopeEdge) -> Self {
+impl From<CssUniversalSelector> for SyntaxElement {
+    fn from(n: CssUniversalSelector) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssScopeRangeEnd {
+impl AstNode for CssUnknownBlockAtRule {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_SCOPE_RANGE_END as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_UNKNOWN_BLOCK_AT_RULE as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_SCOPE_RANGE_END
+        kind == CSS_UNKNOWN_BLOCK_AT_RULE
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -18956,39 +18729,40 @@ impl AstNode for CssScopeRangeEnd {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssScopeRangeEnd {
+impl std::fmt::Debug for CssUnknownBlockAtRule {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssScopeRangeEnd")
-                .field("to_token", &support::DebugSyntaxResult(self.to_token()))
-                .field("end", &support::DebugSyntaxResult(self.end()))
+            f.debug_struct("CssUnknownBlockAtRule")
+                .field("name", &support::DebugSyntaxResult(self.name()))
+                .field("components", &support::DebugSyntaxResult(self.components()))
+                .field("block", &support::DebugSyntaxResult(self.block()))
                 .finish()
         } else {
-            f.debug_struct("CssScopeRangeEnd").finish()
+            f.debug_struct("CssUnknownBlockAtRule").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssScopeRangeEnd> for SyntaxNode {
-    fn from(n: CssScopeRangeEnd) -> Self {
+impl From<CssUnknownBlockAtRule> for SyntaxNode {
+    fn from(n: CssUnknownBlockAtRule) -> Self {
         n.syntax
     }
 }
-impl From<CssScopeRangeEnd> for SyntaxElement {
-    fn from(n: CssScopeRangeEnd) -> Self {
+impl From<CssUnknownBlockAtRule> for SyntaxElement {
+    fn from(n: CssUnknownBlockAtRule) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssScopeRangeInterval {
+impl AstNode for CssUnknownDimension {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_SCOPE_RANGE_INTERVAL as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_UNKNOWN_DIMENSION as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_SCOPE_RANGE_INTERVAL
+        kind == CSS_UNKNOWN_DIMENSION
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -19004,40 +18778,42 @@ impl AstNode for CssScopeRangeInterval {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssScopeRangeInterval {
+impl std::fmt::Debug for CssUnknownDimension {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssScopeRangeInterval")
-                .field("start", &support::DebugSyntaxResult(self.start()))
-                .field("to_token", &support::DebugSyntaxResult(self.to_token()))
-                .field("end", &support::DebugSyntaxResult(self.end()))
+            f.debug_struct("CssUnknownDimension")
+                .field(
+                    "value_token",
+                    &support::DebugSyntaxResult(self.value_token()),
+                )
+                .field("unit_token", &support::DebugSyntaxResult(self.unit_token()))
                 .finish()
         } else {
-            f.debug_struct("CssScopeRangeInterval").finish()
+            f.debug_struct("CssUnknownDimension").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssScopeRangeInterval> for SyntaxNode {
-    fn from(n: CssScopeRangeInterval) -> Self {
+impl From<CssUnknownDimension> for SyntaxNode {
+    fn from(n: CssUnknownDimension) -> Self {
         n.syntax
     }
 }
-impl From<CssScopeRangeInterval> for SyntaxElement {
-    fn from(n: CssScopeRangeInterval) -> Self {
+impl From<CssUnknownDimension> for SyntaxElement {
+    fn from(n: CssUnknownDimension) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssScopeRangeStart {
+impl AstNode for CssUnknownValueAtRule {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_SCOPE_RANGE_START as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_UNKNOWN_VALUE_AT_RULE as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_SCOPE_RANGE_START
+        kind == CSS_UNKNOWN_VALUE_AT_RULE
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -19053,38 +18829,43 @@ impl AstNode for CssScopeRangeStart {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssScopeRangeStart {
+impl std::fmt::Debug for CssUnknownValueAtRule {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssScopeRangeStart")
-                .field("start", &support::DebugSyntaxResult(self.start()))
+            f.debug_struct("CssUnknownValueAtRule")
+                .field("name", &support::DebugSyntaxResult(self.name()))
+                .field("components", &support::DebugSyntaxResult(self.components()))
+                .field(
+                    "semicolon_token",
+                    &support::DebugSyntaxResult(self.semicolon_token()),
+                )
                 .finish()
         } else {
-            f.debug_struct("CssScopeRangeStart").finish()
+            f.debug_struct("CssUnknownValueAtRule").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssScopeRangeStart> for SyntaxNode {
-    fn from(n: CssScopeRangeStart) -> Self {
+impl From<CssUnknownValueAtRule> for SyntaxNode {
+    fn from(n: CssUnknownValueAtRule) -> Self {
         n.syntax
     }
 }
-impl From<CssScopeRangeStart> for SyntaxElement {
-    fn from(n: CssScopeRangeStart) -> Self {
+impl From<CssUnknownValueAtRule> for SyntaxElement {
+    fn from(n: CssUnknownValueAtRule) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssStartingStyleAtRule {
+impl AstNode for CssUrlFunction {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_STARTING_STYLE_AT_RULE as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_URL_FUNCTION as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_STARTING_STYLE_AT_RULE
+        kind == CSS_URL_FUNCTION
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -19100,39 +18881,48 @@ impl AstNode for CssStartingStyleAtRule {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssStartingStyleAtRule {
+impl std::fmt::Debug for CssUrlFunction {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssStartingStyleAtRule")
-                .field("declarator", &support::DebugSyntaxResult(self.declarator()))
-                .field("block", &support::DebugSyntaxResult(self.block()))
+            f.debug_struct("CssUrlFunction")
+                .field("name", &support::DebugSyntaxResult(self.name()))
+                .field(
+                    "l_paren_token",
+                    &support::DebugSyntaxResult(self.l_paren_token()),
+                )
+                .field("value", &support::DebugOptionalElement(self.value()))
+                .field("modifiers", &self.modifiers())
+                .field(
+                    "r_paren_token",
+                    &support::DebugSyntaxResult(self.r_paren_token()),
+                )
                 .finish()
         } else {
-            f.debug_struct("CssStartingStyleAtRule").finish()
+            f.debug_struct("CssUrlFunction").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssStartingStyleAtRule> for SyntaxNode {
-    fn from(n: CssStartingStyleAtRule) -> Self {
+impl From<CssUrlFunction> for SyntaxNode {
+    fn from(n: CssUrlFunction) -> Self {
         n.syntax
     }
 }
-impl From<CssStartingStyleAtRule> for SyntaxElement {
-    fn from(n: CssStartingStyleAtRule) -> Self {
+impl From<CssUrlFunction> for SyntaxElement {
+    fn from(n: CssUrlFunction) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssStartingStyleAtRuleDeclarator {
+impl AstNode for CssUrlValueRaw {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_STARTING_STYLE_AT_RULE_DECLARATOR as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_URL_VALUE_RAW as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_STARTING_STYLE_AT_RULE_DECLARATOR
+        kind == CSS_URL_VALUE_RAW
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -19148,41 +18938,41 @@ impl AstNode for CssStartingStyleAtRuleDeclarator {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssStartingStyleAtRuleDeclarator {
+impl std::fmt::Debug for CssUrlValueRaw {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssStartingStyleAtRuleDeclarator")
+            f.debug_struct("CssUrlValueRaw")
                 .field(
-                    "starting_style_token",
-                    &support::DebugSyntaxResult(self.starting_style_token()),
+                    "value_token",
+                    &support::DebugSyntaxResult(self.value_token()),
                 )
                 .finish()
         } else {
-            f.debug_struct("CssStartingStyleAtRuleDeclarator").finish()
+            f.debug_struct("CssUrlValueRaw").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssStartingStyleAtRuleDeclarator> for SyntaxNode {
-    fn from(n: CssStartingStyleAtRuleDeclarator) -> Self {
+impl From<CssUrlValueRaw> for SyntaxNode {
+    fn from(n: CssUrlValueRaw) -> Self {
         n.syntax
     }
 }
-impl From<CssStartingStyleAtRuleDeclarator> for SyntaxElement {
-    fn from(n: CssStartingStyleAtRuleDeclarator) -> Self {
+impl From<CssUrlValueRaw> for SyntaxElement {
+    fn from(n: CssUrlValueRaw) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssString {
+impl AstNode for CssValueAtRule {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_STRING as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_VALUE_AT_RULE as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_STRING
+        kind == CSS_VALUE_AT_RULE
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -19198,41 +18988,46 @@ impl AstNode for CssString {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssString {
+impl std::fmt::Debug for CssValueAtRule {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssString")
+            f.debug_struct("CssValueAtRule")
                 .field(
                     "value_token",
                     &support::DebugSyntaxResult(self.value_token()),
                 )
+                .field("clause", &support::DebugSyntaxResult(self.clause()))
+                .field(
+                    "semicolon_token",
+                    &support::DebugSyntaxResult(self.semicolon_token()),
+                )
                 .finish()
         } else {
-            f.debug_struct("CssString").finish()
+            f.debug_struct("CssValueAtRule").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssString> for SyntaxNode {
-    fn from(n: CssString) -> Self {
+impl From<CssValueAtRule> for SyntaxNode {
+    fn from(n: CssValueAtRule) -> Self {
         n.syntax
     }
 }
-impl From<CssString> for SyntaxElement {
-    fn from(n: CssString) -> Self {
+impl From<CssValueAtRule> for SyntaxElement {
+    fn from(n: CssValueAtRule) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssSupportsAndCondition {
+impl AstNode for CssValueAtRuleDeclarationClause {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_SUPPORTS_AND_CONDITION as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_VALUE_AT_RULE_DECLARATION_CLAUSE as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_SUPPORTS_AND_CONDITION
+        kind == CSS_VALUE_AT_RULE_DECLARATION_CLAUSE
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -19248,40 +19043,38 @@ impl AstNode for CssSupportsAndCondition {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssSupportsAndCondition {
+impl std::fmt::Debug for CssValueAtRuleDeclarationClause {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssSupportsAndCondition")
-                .field("left", &support::DebugSyntaxResult(self.left()))
-                .field("and_token", &support::DebugSyntaxResult(self.and_token()))
-                .field("right", &support::DebugSyntaxResult(self.right()))
+            f.debug_struct("CssValueAtRuleDeclarationClause")
+                .field("properties", &self.properties())
                 .finish()
         } else {
-            f.debug_struct("CssSupportsAndCondition").finish()
+            f.debug_struct("CssValueAtRuleDeclarationClause").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssSupportsAndCondition> for SyntaxNode {
-    fn from(n: CssSupportsAndCondition) -> Self {
+impl From<CssValueAtRuleDeclarationClause> for SyntaxNode {
+    fn from(n: CssValueAtRuleDeclarationClause) -> Self {
         n.syntax
     }
 }
-impl From<CssSupportsAndCondition> for SyntaxElement {
-    fn from(n: CssSupportsAndCondition) -> Self {
+impl From<CssValueAtRuleDeclarationClause> for SyntaxElement {
+    fn from(n: CssValueAtRuleDeclarationClause) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssSupportsAtRule {
+impl AstNode for CssValueAtRuleGenericProperty {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_SUPPORTS_AT_RULE as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_VALUE_AT_RULE_GENERIC_PROPERTY as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_SUPPORTS_AT_RULE
+        kind == CSS_VALUE_AT_RULE_GENERIC_PROPERTY
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -19297,39 +19090,43 @@ impl AstNode for CssSupportsAtRule {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssSupportsAtRule {
+impl std::fmt::Debug for CssValueAtRuleGenericProperty {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssSupportsAtRule")
-                .field("declarator", &support::DebugSyntaxResult(self.declarator()))
-                .field("block", &support::DebugSyntaxResult(self.block()))
+            f.debug_struct("CssValueAtRuleGenericProperty")
+                .field("name", &support::DebugSyntaxResult(self.name()))
+                .field(
+                    "colon_token",
+                    &support::DebugSyntaxResult(self.colon_token()),
+                )
+                .field("value", &support::DebugSyntaxResult(self.value()))
                 .finish()
         } else {
-            f.debug_struct("CssSupportsAtRule").finish()
+            f.debug_struct("CssValueAtRuleGenericProperty").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssSupportsAtRule> for SyntaxNode {
-    fn from(n: CssSupportsAtRule) -> Self {
+impl From<CssValueAtRuleGenericProperty> for SyntaxNode {
+    fn from(n: CssValueAtRuleGenericProperty) -> Self {
         n.syntax
     }
 }
-impl From<CssSupportsAtRule> for SyntaxElement {
-    fn from(n: CssSupportsAtRule) -> Self {
+impl From<CssValueAtRuleGenericProperty> for SyntaxElement {
+    fn from(n: CssValueAtRuleGenericProperty) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssSupportsAtRuleDeclarator {
+impl AstNode for CssValueAtRuleImportClause {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_SUPPORTS_AT_RULE_DECLARATOR as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_VALUE_AT_RULE_IMPORT_CLAUSE as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_SUPPORTS_AT_RULE_DECLARATOR
+        kind == CSS_VALUE_AT_RULE_IMPORT_CLAUSE
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -19345,42 +19142,40 @@ impl AstNode for CssSupportsAtRuleDeclarator {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssSupportsAtRuleDeclarator {
+impl std::fmt::Debug for CssValueAtRuleImportClause {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssSupportsAtRuleDeclarator")
-                .field(
-                    "supports_token",
-                    &support::DebugSyntaxResult(self.supports_token()),
-                )
-                .field("condition", &support::DebugSyntaxResult(self.condition()))
+            f.debug_struct("CssValueAtRuleImportClause")
+                .field("specifiers", &self.specifiers())
+                .field("from_token", &support::DebugSyntaxResult(self.from_token()))
+                .field("source", &support::DebugSyntaxResult(self.source()))
                 .finish()
         } else {
-            f.debug_struct("CssSupportsAtRuleDeclarator").finish()
+            f.debug_struct("CssValueAtRuleImportClause").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssSupportsAtRuleDeclarator> for SyntaxNode {
-    fn from(n: CssSupportsAtRuleDeclarator) -> Self {
+impl From<CssValueAtRuleImportClause> for SyntaxNode {
+    fn from(n: CssValueAtRuleImportClause) -> Self {
         n.syntax
     }
 }
-impl From<CssSupportsAtRuleDeclarator> for SyntaxElement {
-    fn from(n: CssSupportsAtRuleDeclarator) -> Self {
+impl From<CssValueAtRuleImportClause> for SyntaxElement {
+    fn from(n: CssValueAtRuleImportClause) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssSupportsConditionInParens {
+impl AstNode for CssValueAtRuleImportSpecifier {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_SUPPORTS_CONDITION_IN_PARENS as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_VALUE_AT_RULE_IMPORT_SPECIFIER as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_SUPPORTS_CONDITION_IN_PARENS
+        kind == CSS_VALUE_AT_RULE_IMPORT_SPECIFIER
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -19396,46 +19191,39 @@ impl AstNode for CssSupportsConditionInParens {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssSupportsConditionInParens {
+impl std::fmt::Debug for CssValueAtRuleImportSpecifier {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssSupportsConditionInParens")
-                .field(
-                    "l_paren_token",
-                    &support::DebugSyntaxResult(self.l_paren_token()),
-                )
-                .field("condition", &support::DebugSyntaxResult(self.condition()))
-                .field(
-                    "r_paren_token",
-                    &support::DebugSyntaxResult(self.r_paren_token()),
-                )
+            f.debug_struct("CssValueAtRuleImportSpecifier")
+                .field("name", &support::DebugSyntaxResult(self.name()))
                 .finish()
         } else {
-            f.debug_struct("CssSupportsConditionInParens").finish()
+            f.debug_struct("CssValueAtRuleImportSpecifier").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssSupportsConditionInParens> for SyntaxNode {
-    fn from(n: CssSupportsConditionInParens) -> Self {
+impl From<CssValueAtRuleImportSpecifier> for SyntaxNode {
+    fn from(n: CssValueAtRuleImportSpecifier) -> Self {
         n.syntax
     }
 }
-impl From<CssSupportsConditionInParens> for SyntaxElement {
-    fn from(n: CssSupportsConditionInParens) -> Self {
+impl From<CssValueAtRuleImportSpecifier> for SyntaxElement {
+    fn from(n: CssValueAtRuleImportSpecifier) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssSupportsFeatureDeclaration {
+impl AstNode for CssValueAtRuleNamedImportSpecifier {
     type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_SUPPORTS_FEATURE_DECLARATION as u16));
+    const KIND_SET: SyntaxKindSet<Language> = SyntaxKindSet::from_raw(RawSyntaxKind(
+        CSS_VALUE_AT_RULE_NAMED_IMPORT_SPECIFIER as u16,
+    ));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_SUPPORTS_FEATURE_DECLARATION
+        kind == CSS_VALUE_AT_RULE_NAMED_IMPORT_SPECIFIER
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -19451,49 +19239,41 @@ impl AstNode for CssSupportsFeatureDeclaration {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssSupportsFeatureDeclaration {
+impl std::fmt::Debug for CssValueAtRuleNamedImportSpecifier {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssSupportsFeatureDeclaration")
-                .field(
-                    "l_paren_token",
-                    &support::DebugSyntaxResult(self.l_paren_token()),
-                )
-                .field(
-                    "declaration",
-                    &support::DebugSyntaxResult(self.declaration()),
-                )
-                .field(
-                    "r_paren_token",
-                    &support::DebugSyntaxResult(self.r_paren_token()),
-                )
+            f.debug_struct("CssValueAtRuleNamedImportSpecifier")
+                .field("name", &support::DebugSyntaxResult(self.name()))
+                .field("as_token", &support::DebugSyntaxResult(self.as_token()))
+                .field("local_name", &support::DebugSyntaxResult(self.local_name()))
                 .finish()
         } else {
-            f.debug_struct("CssSupportsFeatureDeclaration").finish()
+            f.debug_struct("CssValueAtRuleNamedImportSpecifier")
+                .finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssSupportsFeatureDeclaration> for SyntaxNode {
-    fn from(n: CssSupportsFeatureDeclaration) -> Self {
+impl From<CssValueAtRuleNamedImportSpecifier> for SyntaxNode {
+    fn from(n: CssValueAtRuleNamedImportSpecifier) -> Self {
         n.syntax
     }
 }
-impl From<CssSupportsFeatureDeclaration> for SyntaxElement {
-    fn from(n: CssSupportsFeatureDeclaration) -> Self {
+impl From<CssValueAtRuleNamedImportSpecifier> for SyntaxElement {
+    fn from(n: CssValueAtRuleNamedImportSpecifier) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssSupportsFeatureSelector {
+impl AstNode for CssViewTransitionAtRule {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_SUPPORTS_FEATURE_SELECTOR as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_VIEW_TRANSITION_AT_RULE as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_SUPPORTS_FEATURE_SELECTOR
+        kind == CSS_VIEW_TRANSITION_AT_RULE
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -19509,50 +19289,39 @@ impl AstNode for CssSupportsFeatureSelector {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssSupportsFeatureSelector {
+impl std::fmt::Debug for CssViewTransitionAtRule {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssSupportsFeatureSelector")
-                .field(
-                    "selector_token",
-                    &support::DebugSyntaxResult(self.selector_token()),
-                )
-                .field(
-                    "l_paren_token",
-                    &support::DebugSyntaxResult(self.l_paren_token()),
-                )
-                .field("selector", &support::DebugSyntaxResult(self.selector()))
-                .field(
-                    "r_paren_token",
-                    &support::DebugSyntaxResult(self.r_paren_token()),
-                )
+            f.debug_struct("CssViewTransitionAtRule")
+                .field("declarator", &support::DebugSyntaxResult(self.declarator()))
+                .field("block", &support::DebugSyntaxResult(self.block()))
                 .finish()
         } else {
-            f.debug_struct("CssSupportsFeatureSelector").finish()
+            f.debug_struct("CssViewTransitionAtRule").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssSupportsFeatureSelector> for SyntaxNode {
-    fn from(n: CssSupportsFeatureSelector) -> Self {
+impl From<CssViewTransitionAtRule> for SyntaxNode {
+    fn from(n: CssViewTransitionAtRule) -> Self {
         n.syntax
     }
 }
-impl From<CssSupportsFeatureSelector> for SyntaxElement {
-    fn from(n: CssSupportsFeatureSelector) -> Self {
+impl From<CssViewTransitionAtRule> for SyntaxElement {
+    fn from(n: CssViewTransitionAtRule) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssSupportsNotCondition {
+impl AstNode for CssViewTransitionAtRuleDeclarator {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_SUPPORTS_NOT_CONDITION as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_VIEW_TRANSITION_AT_RULE_DECLARATOR as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_SUPPORTS_NOT_CONDITION
+        kind == CSS_VIEW_TRANSITION_AT_RULE_DECLARATOR
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -19568,39 +19337,41 @@ impl AstNode for CssSupportsNotCondition {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssSupportsNotCondition {
+impl std::fmt::Debug for CssViewTransitionAtRuleDeclarator {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssSupportsNotCondition")
-                .field("not_token", &support::DebugSyntaxResult(self.not_token()))
-                .field("query", &support::DebugSyntaxResult(self.query()))
+            f.debug_struct("CssViewTransitionAtRuleDeclarator")
+                .field(
+                    "view_transition_token",
+                    &support::DebugSyntaxResult(self.view_transition_token()),
+                )
                 .finish()
         } else {
-            f.debug_struct("CssSupportsNotCondition").finish()
+            f.debug_struct("CssViewTransitionAtRuleDeclarator").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssSupportsNotCondition> for SyntaxNode {
-    fn from(n: CssSupportsNotCondition) -> Self {
+impl From<CssViewTransitionAtRuleDeclarator> for SyntaxNode {
+    fn from(n: CssViewTransitionAtRuleDeclarator) -> Self {
         n.syntax
     }
 }
-impl From<CssSupportsNotCondition> for SyntaxElement {
-    fn from(n: CssSupportsNotCondition) -> Self {
+impl From<CssViewTransitionAtRuleDeclarator> for SyntaxElement {
+    fn from(n: CssViewTransitionAtRuleDeclarator) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssSupportsOrCondition {
+impl AstNode for TwApplyAtRule {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_SUPPORTS_OR_CONDITION as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(TW_APPLY_AT_RULE as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_SUPPORTS_OR_CONDITION
+        kind == TW_APPLY_AT_RULE
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -19616,40 +19387,46 @@ impl AstNode for CssSupportsOrCondition {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssSupportsOrCondition {
+impl std::fmt::Debug for TwApplyAtRule {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssSupportsOrCondition")
-                .field("left", &support::DebugSyntaxResult(self.left()))
-                .field("or_token", &support::DebugSyntaxResult(self.or_token()))
-                .field("right", &support::DebugSyntaxResult(self.right()))
+            f.debug_struct("TwApplyAtRule")
+                .field(
+                    "apply_token",
+                    &support::DebugSyntaxResult(self.apply_token()),
+                )
+                .field("classes", &self.classes())
+                .field(
+                    "semicolon_token",
+                    &support::DebugSyntaxResult(self.semicolon_token()),
+                )
                 .finish()
         } else {
-            f.debug_struct("CssSupportsOrCondition").finish()
+            f.debug_struct("TwApplyAtRule").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssSupportsOrCondition> for SyntaxNode {
-    fn from(n: CssSupportsOrCondition) -> Self {
+impl From<TwApplyAtRule> for SyntaxNode {
+    fn from(n: TwApplyAtRule) -> Self {
         n.syntax
     }
 }
-impl From<CssSupportsOrCondition> for SyntaxElement {
-    fn from(n: CssSupportsOrCondition) -> Self {
+impl From<TwApplyAtRule> for SyntaxElement {
+    fn from(n: TwApplyAtRule) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssTypeSelector {
+impl AstNode for TwConfigAtRule {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_TYPE_SELECTOR as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(TW_CONFIG_AT_RULE as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_TYPE_SELECTOR
+        kind == TW_CONFIG_AT_RULE
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -19665,42 +19442,46 @@ impl AstNode for CssTypeSelector {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssTypeSelector {
+impl std::fmt::Debug for TwConfigAtRule {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssTypeSelector")
+            f.debug_struct("TwConfigAtRule")
                 .field(
-                    "namespace",
-                    &support::DebugOptionalElement(self.namespace()),
+                    "config_token",
+                    &support::DebugSyntaxResult(self.config_token()),
+                )
+                .field("path", &support::DebugSyntaxResult(self.path()))
+                .field(
+                    "semicolon_token",
+                    &support::DebugSyntaxResult(self.semicolon_token()),
                 )
-                .field("ident", &support::DebugSyntaxResult(self.ident()))
                 .finish()
         } else {
-            f.debug_struct("CssTypeSelector").finish()
+            f.debug_struct("TwConfigAtRule").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssTypeSelector> for SyntaxNode {
-    fn from(n: CssTypeSelector) -> Self {
+impl From<TwConfigAtRule> for SyntaxNode {
+    fn from(n: TwConfigAtRule) -> Self {
         n.syntax
     }
 }
-impl From<CssTypeSelector> for SyntaxElement {
-    fn from(n: CssTypeSelector) -> Self {
+impl From<TwConfigAtRule> for SyntaxElement {
+    fn from(n: TwConfigAtRule) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssUnicodeCodepoint {
+impl AstNode for TwCustomVariantAtRule {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_UNICODE_CODEPOINT as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(TW_CUSTOM_VARIANT_AT_RULE as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_UNICODE_CODEPOINT
+        kind == TW_CUSTOM_VARIANT_AT_RULE
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -19716,41 +19497,43 @@ impl AstNode for CssUnicodeCodepoint {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssUnicodeCodepoint {
+impl std::fmt::Debug for TwCustomVariantAtRule {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssUnicodeCodepoint")
+            f.debug_struct("TwCustomVariantAtRule")
                 .field(
-                    "value_token",
-                    &support::DebugSyntaxResult(self.value_token()),
+                    "custom_variant_token",
+                    &support::DebugSyntaxResult(self.custom_variant_token()),
                 )
+                .field("name", &support::DebugSyntaxResult(self.name()))
+                .field("selector", &support::DebugSyntaxResult(self.selector()))
                 .finish()
         } else {
-            f.debug_struct("CssUnicodeCodepoint").finish()
+            f.debug_struct("TwCustomVariantAtRule").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssUnicodeCodepoint> for SyntaxNode {
-    fn from(n: CssUnicodeCodepoint) -> Self {
+impl From<TwCustomVariantAtRule> for SyntaxNode {
+    fn from(n: TwCustomVariantAtRule) -> Self {
         n.syntax
     }
 }
-impl From<CssUnicodeCodepoint> for SyntaxElement {
-    fn from(n: CssUnicodeCodepoint) -> Self {
+impl From<TwCustomVariantAtRule> for SyntaxElement {
+    fn from(n: TwCustomVariantAtRule) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssUnicodeRange {
+impl AstNode for TwCustomVariantShorthand {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_UNICODE_RANGE as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(TW_CUSTOM_VARIANT_SHORTHAND as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_UNICODE_RANGE
+        kind == TW_CUSTOM_VARIANT_SHORTHAND
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -19766,42 +19549,50 @@ impl AstNode for CssUnicodeRange {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssUnicodeRange {
+impl std::fmt::Debug for TwCustomVariantShorthand {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssUnicodeRange")
+            f.debug_struct("TwCustomVariantShorthand")
                 .field(
-                    "prefix_token",
-                    &support::DebugSyntaxResult(self.prefix_token()),
+                    "l_paren_token",
+                    &support::DebugSyntaxResult(self.l_paren_token()),
+                )
+                .field("selector", &support::DebugSyntaxResult(self.selector()))
+                .field(
+                    "r_paren_token",
+                    &support::DebugSyntaxResult(self.r_paren_token()),
+                )
+                .field(
+                    "semicolon_token",
+                    &support::DebugSyntaxResult(self.semicolon_token()),
                 )
-                .field("value", &support::DebugSyntaxResult(self.value()))
                 .finish()
         } else {
-            f.debug_struct("CssUnicodeRange").finish()
+            f.debug_struct("TwCustomVariantShorthand").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssUnicodeRange> for SyntaxNode {
-    fn from(n: CssUnicodeRange) -> Self {
+impl From<TwCustomVariantShorthand> for SyntaxNode {
+    fn from(n: TwCustomVariantShorthand) -> Self {
         n.syntax
     }
 }
-impl From<CssUnicodeRange> for SyntaxElement {
-    fn from(n: CssUnicodeRange) -> Self {
+impl From<TwCustomVariantShorthand> for SyntaxElement {
+    fn from(n: TwCustomVariantShorthand) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssUnicodeRangeInterval {
+impl AstNode for TwFunctionalUtilityName {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_UNICODE_RANGE_INTERVAL as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(TW_FUNCTIONAL_UTILITY_NAME as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_UNICODE_RANGE_INTERVAL
+        kind == TW_FUNCTIONAL_UTILITY_NAME
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -19817,43 +19608,43 @@ impl AstNode for CssUnicodeRangeInterval {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssUnicodeRangeInterval {
+impl std::fmt::Debug for TwFunctionalUtilityName {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssUnicodeRangeInterval")
-                .field("start", &support::DebugSyntaxResult(self.start()))
+            f.debug_struct("TwFunctionalUtilityName")
+                .field("identifier", &support::DebugSyntaxResult(self.identifier()))
                 .field(
                     "minus_token",
                     &support::DebugSyntaxResult(self.minus_token()),
                 )
-                .field("end", &support::DebugSyntaxResult(self.end()))
+                .field("star_token", &support::DebugSyntaxResult(self.star_token()))
                 .finish()
         } else {
-            f.debug_struct("CssUnicodeRangeInterval").finish()
+            f.debug_struct("TwFunctionalUtilityName").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssUnicodeRangeInterval> for SyntaxNode {
-    fn from(n: CssUnicodeRangeInterval) -> Self {
+impl From<TwFunctionalUtilityName> for SyntaxNode {
+    fn from(n: TwFunctionalUtilityName) -> Self {
         n.syntax
     }
 }
-impl From<CssUnicodeRangeInterval> for SyntaxElement {
-    fn from(n: CssUnicodeRangeInterval) -> Self {
+impl From<TwFunctionalUtilityName> for SyntaxElement {
+    fn from(n: TwFunctionalUtilityName) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssUnicodeRangeWildcard {
+impl AstNode for TwPluginAtRule {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_UNICODE_RANGE_WILDCARD as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(TW_PLUGIN_AT_RULE as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_UNICODE_RANGE_WILDCARD
+        kind == TW_PLUGIN_AT_RULE
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -19869,41 +19660,47 @@ impl AstNode for CssUnicodeRangeWildcard {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssUnicodeRangeWildcard {
+impl std::fmt::Debug for TwPluginAtRule {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssUnicodeRangeWildcard")
+            f.debug_struct("TwPluginAtRule")
                 .field(
-                    "value_token",
-                    &support::DebugSyntaxResult(self.value_token()),
+                    "plugin_token",
+                    &support::DebugSyntaxResult(self.plugin_token()),
+                )
+                .field("name", &support::DebugSyntaxResult(self.name()))
+                .field("block", &support::DebugOptionalElement(self.block()))
+                .field(
+                    "semicolon_token",
+                    &support::DebugOptionalElement(self.semicolon_token()),
                 )
                 .finish()
         } else {
-            f.debug_struct("CssUnicodeRangeWildcard").finish()
+            f.debug_struct("TwPluginAtRule").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssUnicodeRangeWildcard> for SyntaxNode {
-    fn from(n: CssUnicodeRangeWildcard) -> Self {
+impl From<TwPluginAtRule> for SyntaxNode {
+    fn from(n: TwPluginAtRule) -> Self {
         n.syntax
     }
 }
-impl From<CssUnicodeRangeWildcard> for SyntaxElement {
-    fn from(n: CssUnicodeRangeWildcard) -> Self {
+impl From<TwPluginAtRule> for SyntaxElement {
+    fn from(n: TwPluginAtRule) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssUniversalNamespacePrefix {
+impl AstNode for TwReferenceAtRule {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_UNIVERSAL_NAMESPACE_PREFIX as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(TW_REFERENCE_AT_RULE as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_UNIVERSAL_NAMESPACE_PREFIX
+        kind == TW_REFERENCE_AT_RULE
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -19919,38 +19716,46 @@ impl AstNode for CssUniversalNamespacePrefix {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssUniversalNamespacePrefix {
+impl std::fmt::Debug for TwReferenceAtRule {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssUniversalNamespacePrefix")
-                .field("star_token", &support::DebugSyntaxResult(self.star_token()))
+            f.debug_struct("TwReferenceAtRule")
+                .field(
+                    "reference_token",
+                    &support::DebugSyntaxResult(self.reference_token()),
+                )
+                .field("path", &support::DebugSyntaxResult(self.path()))
+                .field(
+                    "semicolon_token",
+                    &support::DebugSyntaxResult(self.semicolon_token()),
+                )
                 .finish()
         } else {
-            f.debug_struct("CssUniversalNamespacePrefix").finish()
+            f.debug_struct("TwReferenceAtRule").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssUniversalNamespacePrefix> for SyntaxNode {
-    fn from(n: CssUniversalNamespacePrefix) -> Self {
+impl From<TwReferenceAtRule> for SyntaxNode {
+    fn from(n: TwReferenceAtRule) -> Self {
         n.syntax
     }
 }
-impl From<CssUniversalNamespacePrefix> for SyntaxElement {
-    fn from(n: CssUniversalNamespacePrefix) -> Self {
+impl From<TwReferenceAtRule> for SyntaxElement {
+    fn from(n: TwReferenceAtRule) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssUniversalSelector {
+impl AstNode for TwSlotAtRule {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_UNIVERSAL_SELECTOR as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(TW_SLOT_AT_RULE as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_UNIVERSAL_SELECTOR
+        kind == TW_SLOT_AT_RULE
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -19966,42 +19771,42 @@ impl AstNode for CssUniversalSelector {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssUniversalSelector {
+impl std::fmt::Debug for TwSlotAtRule {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssUniversalSelector")
+            f.debug_struct("TwSlotAtRule")
+                .field("slot_token", &support::DebugSyntaxResult(self.slot_token()))
                 .field(
-                    "namespace",
-                    &support::DebugOptionalElement(self.namespace()),
+                    "semicolon_token",
+                    &support::DebugSyntaxResult(self.semicolon_token()),
                 )
-                .field("star_token", &support::DebugSyntaxResult(self.star_token()))
                 .finish()
         } else {
-            f.debug_struct("CssUniversalSelector").finish()
+            f.debug_struct("TwSlotAtRule").finish()
         };
         DEPTH.set(current_depth);
         result
     }
 }
-impl From<CssUniversalSelector> for SyntaxNode {
-    fn from(n: CssUniversalSelector) -> Self {
+impl From<TwSlotAtRule> for SyntaxNode {
+    fn from(n: TwSlotAtRule) -> Self {
         n.syntax
     }
 }
-impl From<CssUniversalSelector> for SyntaxElement {
-    fn from(n: CssUniversalSelector) -> Self {
+impl From<TwSlotAtRule> for SyntaxElement {
+    fn from(n: TwSlotAtRule) -> Self {
         n.syntax.into()
     }
 }
-impl AstNode for CssUnknownBlockAtRule {
+impl AstNode for TwSourceAtRule {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_UNKNOWN_BLOCK_AT_RULE as u16));
+        SyntaxKindSet::from_raw(RawSyntaxKind(TW_SOURCE_AT_RULE as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_UNKNOWN_BLOCK_AT_RULE
+        kind == TW_SOURCE_AT_RULE
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         if Self::can_cast(syntax.kind()) {
@@ -20017,2668 +19822,909 @@ impl AstNode for CssUnknownBlockAtRule {
         self.syntax
     }
 }
-impl std::fmt::Debug for CssUnknownBlockAtRule {
+impl std::fmt::Debug for TwSourceAtRule {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
         let current_depth = DEPTH.get();
         let result = if current_depth < 16 {
             DEPTH.set(current_depth + 1);
-            f.debug_struct("CssUnknownBlockAtRule")
-                .field("name", &support::DebugSyntaxResult(self.name()))
-                .field("components", &support::DebugSyntaxResult(self.components()))
-                .field("block", &support::DebugSyntaxResult(self.block()))
-                .finish()
-        } else {
-            f.debug_struct("CssUnknownBlockAtRule").finish()
-        };
-        DEPTH.set(current_depth);
-        result
-    }
-}
-impl From<CssUnknownBlockAtRule> for SyntaxNode {
-    fn from(n: CssUnknownBlockAtRule) -> Self {
-        n.syntax
-    }
-}
-impl From<CssUnknownBlockAtRule> for SyntaxElement {
-    fn from(n: CssUnknownBlockAtRule) -> Self {
-        n.syntax.into()
-    }
-}
-impl AstNode for CssUnknownDimension {
-    type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_UNKNOWN_DIMENSION as u16));
-    fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_UNKNOWN_DIMENSION
-    }
-    fn cast(syntax: SyntaxNode) -> Option<Self> {
-        if Self::can_cast(syntax.kind()) {
-            Some(Self { syntax })
-        } else {
-            None
-        }
-    }
-    fn syntax(&self) -> &SyntaxNode {
-        &self.syntax
-    }
-    fn into_syntax(self) -> SyntaxNode {
-        self.syntax
-    }
-}
-impl std::fmt::Debug for CssUnknownDimension {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
-        let current_depth = DEPTH.get();
-        let result = if current_depth < 16 {
-            DEPTH.set(current_depth + 1);
-            f.debug_struct("CssUnknownDimension")
-                .field(
-                    "value_token",
-                    &support::DebugSyntaxResult(self.value_token()),
-                )
-                .field("unit_token", &support::DebugSyntaxResult(self.unit_token()))
-                .finish()
-        } else {
-            f.debug_struct("CssUnknownDimension").finish()
-        };
-        DEPTH.set(current_depth);
-        result
-    }
-}
-impl From<CssUnknownDimension> for SyntaxNode {
-    fn from(n: CssUnknownDimension) -> Self {
-        n.syntax
-    }
-}
-impl From<CssUnknownDimension> for SyntaxElement {
-    fn from(n: CssUnknownDimension) -> Self {
-        n.syntax.into()
-    }
-}
-impl AstNode for CssUnknownValueAtRule {
-    type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_UNKNOWN_VALUE_AT_RULE as u16));
-    fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_UNKNOWN_VALUE_AT_RULE
-    }
-    fn cast(syntax: SyntaxNode) -> Option<Self> {
-        if Self::can_cast(syntax.kind()) {
-            Some(Self { syntax })
-        } else {
-            None
-        }
-    }
-    fn syntax(&self) -> &SyntaxNode {
-        &self.syntax
-    }
-    fn into_syntax(self) -> SyntaxNode {
-        self.syntax
-    }
-}
-impl std::fmt::Debug for CssUnknownValueAtRule {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
-        let current_depth = DEPTH.get();
-        let result = if current_depth < 16 {
-            DEPTH.set(current_depth + 1);
-            f.debug_struct("CssUnknownValueAtRule")
-                .field("name", &support::DebugSyntaxResult(self.name()))
-                .field("components", &support::DebugSyntaxResult(self.components()))
-                .field(
-                    "semicolon_token",
-                    &support::DebugSyntaxResult(self.semicolon_token()),
-                )
-                .finish()
-        } else {
-            f.debug_struct("CssUnknownValueAtRule").finish()
-        };
-        DEPTH.set(current_depth);
-        result
-    }
-}
-impl From<CssUnknownValueAtRule> for SyntaxNode {
-    fn from(n: CssUnknownValueAtRule) -> Self {
-        n.syntax
-    }
-}
-impl From<CssUnknownValueAtRule> for SyntaxElement {
-    fn from(n: CssUnknownValueAtRule) -> Self {
-        n.syntax.into()
-    }
-}
-impl AstNode for CssUrlFunction {
-    type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_URL_FUNCTION as u16));
-    fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_URL_FUNCTION
-    }
-    fn cast(syntax: SyntaxNode) -> Option<Self> {
-        if Self::can_cast(syntax.kind()) {
-            Some(Self { syntax })
-        } else {
-            None
-        }
-    }
-    fn syntax(&self) -> &SyntaxNode {
-        &self.syntax
-    }
-    fn into_syntax(self) -> SyntaxNode {
-        self.syntax
-    }
-}
-impl std::fmt::Debug for CssUrlFunction {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
-        let current_depth = DEPTH.get();
-        let result = if current_depth < 16 {
-            DEPTH.set(current_depth + 1);
-            f.debug_struct("CssUrlFunction")
-                .field("name", &support::DebugSyntaxResult(self.name()))
-                .field(
-                    "l_paren_token",
-                    &support::DebugSyntaxResult(self.l_paren_token()),
-                )
-                .field("value", &support::DebugOptionalElement(self.value()))
-                .field("modifiers", &self.modifiers())
-                .field(
-                    "r_paren_token",
-                    &support::DebugSyntaxResult(self.r_paren_token()),
-                )
-                .finish()
-        } else {
-            f.debug_struct("CssUrlFunction").finish()
-        };
-        DEPTH.set(current_depth);
-        result
-    }
-}
-impl From<CssUrlFunction> for SyntaxNode {
-    fn from(n: CssUrlFunction) -> Self {
-        n.syntax
-    }
-}
-impl From<CssUrlFunction> for SyntaxElement {
-    fn from(n: CssUrlFunction) -> Self {
-        n.syntax.into()
-    }
-}
-impl AstNode for CssUrlValueRaw {
-    type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_URL_VALUE_RAW as u16));
-    fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_URL_VALUE_RAW
-    }
-    fn cast(syntax: SyntaxNode) -> Option<Self> {
-        if Self::can_cast(syntax.kind()) {
-            Some(Self { syntax })
-        } else {
-            None
-        }
-    }
-    fn syntax(&self) -> &SyntaxNode {
-        &self.syntax
-    }
-    fn into_syntax(self) -> SyntaxNode {
-        self.syntax
-    }
-}
-impl std::fmt::Debug for CssUrlValueRaw {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
-        let current_depth = DEPTH.get();
-        let result = if current_depth < 16 {
-            DEPTH.set(current_depth + 1);
-            f.debug_struct("CssUrlValueRaw")
-                .field(
-                    "value_token",
-                    &support::DebugSyntaxResult(self.value_token()),
-                )
-                .finish()
-        } else {
-            f.debug_struct("CssUrlValueRaw").finish()
-        };
-        DEPTH.set(current_depth);
-        result
-    }
-}
-impl From<CssUrlValueRaw> for SyntaxNode {
-    fn from(n: CssUrlValueRaw) -> Self {
-        n.syntax
-    }
-}
-impl From<CssUrlValueRaw> for SyntaxElement {
-    fn from(n: CssUrlValueRaw) -> Self {
-        n.syntax.into()
-    }
-}
-impl AstNode for CssValueAtRule {
-    type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_VALUE_AT_RULE as u16));
-    fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_VALUE_AT_RULE
-    }
-    fn cast(syntax: SyntaxNode) -> Option<Self> {
-        if Self::can_cast(syntax.kind()) {
-            Some(Self { syntax })
-        } else {
-            None
-        }
-    }
-    fn syntax(&self) -> &SyntaxNode {
-        &self.syntax
-    }
-    fn into_syntax(self) -> SyntaxNode {
-        self.syntax
-    }
-}
-impl std::fmt::Debug for CssValueAtRule {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
-        let current_depth = DEPTH.get();
-        let result = if current_depth < 16 {
-            DEPTH.set(current_depth + 1);
-            f.debug_struct("CssValueAtRule")
+            f.debug_struct("TwSourceAtRule")
                 .field(
-                    "value_token",
-                    &support::DebugSyntaxResult(self.value_token()),
+                    "source_token",
+                    &support::DebugSyntaxResult(self.source_token()),
                 )
-                .field("clause", &support::DebugSyntaxResult(self.clause()))
                 .field(
-                    "semicolon_token",
-                    &support::DebugSyntaxResult(self.semicolon_token()),
-                )
-                .finish()
-        } else {
-            f.debug_struct("CssValueAtRule").finish()
-        };
-        DEPTH.set(current_depth);
-        result
-    }
-}
-impl From<CssValueAtRule> for SyntaxNode {
-    fn from(n: CssValueAtRule) -> Self {
-        n.syntax
-    }
-}
-impl From<CssValueAtRule> for SyntaxElement {
-    fn from(n: CssValueAtRule) -> Self {
-        n.syntax.into()
-    }
-}
-impl AstNode for CssValueAtRuleDeclarationClause {
-    type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_VALUE_AT_RULE_DECLARATION_CLAUSE as u16));
-    fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_VALUE_AT_RULE_DECLARATION_CLAUSE
-    }
-    fn cast(syntax: SyntaxNode) -> Option<Self> {
-        if Self::can_cast(syntax.kind()) {
-            Some(Self { syntax })
-        } else {
-            None
-        }
-    }
-    fn syntax(&self) -> &SyntaxNode {
-        &self.syntax
-    }
-    fn into_syntax(self) -> SyntaxNode {
-        self.syntax
-    }
-}
-impl std::fmt::Debug for CssValueAtRuleDeclarationClause {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
-        let current_depth = DEPTH.get();
-        let result = if current_depth < 16 {
-            DEPTH.set(current_depth + 1);
-            f.debug_struct("CssValueAtRuleDeclarationClause")
-                .field("properties", &self.properties())
-                .finish()
-        } else {
-            f.debug_struct("CssValueAtRuleDeclarationClause").finish()
-        };
-        DEPTH.set(current_depth);
-        result
-    }
-}
-impl From<CssValueAtRuleDeclarationClause> for SyntaxNode {
-    fn from(n: CssValueAtRuleDeclarationClause) -> Self {
-        n.syntax
-    }
-}
-impl From<CssValueAtRuleDeclarationClause> for SyntaxElement {
-    fn from(n: CssValueAtRuleDeclarationClause) -> Self {
-        n.syntax.into()
-    }
-}
-impl AstNode for CssValueAtRuleGenericProperty {
-    type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_VALUE_AT_RULE_GENERIC_PROPERTY as u16));
-    fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_VALUE_AT_RULE_GENERIC_PROPERTY
-    }
-    fn cast(syntax: SyntaxNode) -> Option<Self> {
-        if Self::can_cast(syntax.kind()) {
-            Some(Self { syntax })
-        } else {
-            None
-        }
-    }
-    fn syntax(&self) -> &SyntaxNode {
-        &self.syntax
-    }
-    fn into_syntax(self) -> SyntaxNode {
-        self.syntax
-    }
-}
-impl std::fmt::Debug for CssValueAtRuleGenericProperty {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
-        let current_depth = DEPTH.get();
-        let result = if current_depth < 16 {
-            DEPTH.set(current_depth + 1);
-            f.debug_struct("CssValueAtRuleGenericProperty")
-                .field("name", &support::DebugSyntaxResult(self.name()))
-                .field(
-                    "colon_token",
-                    &support::DebugSyntaxResult(self.colon_token()),
-                )
-                .field("value", &support::DebugSyntaxResult(self.value()))
-                .finish()
-        } else {
-            f.debug_struct("CssValueAtRuleGenericProperty").finish()
-        };
-        DEPTH.set(current_depth);
-        result
-    }
-}
-impl From<CssValueAtRuleGenericProperty> for SyntaxNode {
-    fn from(n: CssValueAtRuleGenericProperty) -> Self {
-        n.syntax
-    }
-}
-impl From<CssValueAtRuleGenericProperty> for SyntaxElement {
-    fn from(n: CssValueAtRuleGenericProperty) -> Self {
-        n.syntax.into()
-    }
-}
-impl AstNode for CssValueAtRuleImportClause {
-    type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_VALUE_AT_RULE_IMPORT_CLAUSE as u16));
-    fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_VALUE_AT_RULE_IMPORT_CLAUSE
-    }
-    fn cast(syntax: SyntaxNode) -> Option<Self> {
-        if Self::can_cast(syntax.kind()) {
-            Some(Self { syntax })
-        } else {
-            None
-        }
-    }
-    fn syntax(&self) -> &SyntaxNode {
-        &self.syntax
-    }
-    fn into_syntax(self) -> SyntaxNode {
-        self.syntax
-    }
-}
-impl std::fmt::Debug for CssValueAtRuleImportClause {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
-        let current_depth = DEPTH.get();
-        let result = if current_depth < 16 {
-            DEPTH.set(current_depth + 1);
-            f.debug_struct("CssValueAtRuleImportClause")
-                .field("specifiers", &self.specifiers())
-                .field("from_token", &support::DebugSyntaxResult(self.from_token()))
-                .field("source", &support::DebugSyntaxResult(self.source()))
-                .finish()
-        } else {
-            f.debug_struct("CssValueAtRuleImportClause").finish()
-        };
-        DEPTH.set(current_depth);
-        result
-    }
-}
-impl From<CssValueAtRuleImportClause> for SyntaxNode {
-    fn from(n: CssValueAtRuleImportClause) -> Self {
-        n.syntax
-    }
-}
-impl From<CssValueAtRuleImportClause> for SyntaxElement {
-    fn from(n: CssValueAtRuleImportClause) -> Self {
-        n.syntax.into()
-    }
-}
-impl AstNode for CssValueAtRuleImportSpecifier {
-    type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_VALUE_AT_RULE_IMPORT_SPECIFIER as u16));
-    fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_VALUE_AT_RULE_IMPORT_SPECIFIER
-    }
-    fn cast(syntax: SyntaxNode) -> Option<Self> {
-        if Self::can_cast(syntax.kind()) {
-            Some(Self { syntax })
-        } else {
-            None
-        }
-    }
-    fn syntax(&self) -> &SyntaxNode {
-        &self.syntax
-    }
-    fn into_syntax(self) -> SyntaxNode {
-        self.syntax
-    }
-}
-impl std::fmt::Debug for CssValueAtRuleImportSpecifier {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
-        let current_depth = DEPTH.get();
-        let result = if current_depth < 16 {
-            DEPTH.set(current_depth + 1);
-            f.debug_struct("CssValueAtRuleImportSpecifier")
-                .field("name", &support::DebugSyntaxResult(self.name()))
-                .finish()
-        } else {
-            f.debug_struct("CssValueAtRuleImportSpecifier").finish()
-        };
-        DEPTH.set(current_depth);
-        result
-    }
-}
-impl From<CssValueAtRuleImportSpecifier> for SyntaxNode {
-    fn from(n: CssValueAtRuleImportSpecifier) -> Self {
-        n.syntax
-    }
-}
-impl From<CssValueAtRuleImportSpecifier> for SyntaxElement {
-    fn from(n: CssValueAtRuleImportSpecifier) -> Self {
-        n.syntax.into()
-    }
-}
-impl AstNode for CssValueAtRuleNamedImportSpecifier {
-    type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> = SyntaxKindSet::from_raw(RawSyntaxKind(
-        CSS_VALUE_AT_RULE_NAMED_IMPORT_SPECIFIER as u16,
-    ));
-    fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_VALUE_AT_RULE_NAMED_IMPORT_SPECIFIER
-    }
-    fn cast(syntax: SyntaxNode) -> Option<Self> {
-        if Self::can_cast(syntax.kind()) {
-            Some(Self { syntax })
-        } else {
-            None
-        }
-    }
-    fn syntax(&self) -> &SyntaxNode {
-        &self.syntax
-    }
-    fn into_syntax(self) -> SyntaxNode {
-        self.syntax
-    }
-}
-impl std::fmt::Debug for CssValueAtRuleNamedImportSpecifier {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
-        let current_depth = DEPTH.get();
-        let result = if current_depth < 16 {
-            DEPTH.set(current_depth + 1);
-            f.debug_struct("CssValueAtRuleNamedImportSpecifier")
-                .field("name", &support::DebugSyntaxResult(self.name()))
-                .field("as_token", &support::DebugSyntaxResult(self.as_token()))
-                .field("local_name", &support::DebugSyntaxResult(self.local_name()))
-                .finish()
-        } else {
-            f.debug_struct("CssValueAtRuleNamedImportSpecifier")
-                .finish()
-        };
-        DEPTH.set(current_depth);
-        result
-    }
-}
-impl From<CssValueAtRuleNamedImportSpecifier> for SyntaxNode {
-    fn from(n: CssValueAtRuleNamedImportSpecifier) -> Self {
-        n.syntax
-    }
-}
-impl From<CssValueAtRuleNamedImportSpecifier> for SyntaxElement {
-    fn from(n: CssValueAtRuleNamedImportSpecifier) -> Self {
-        n.syntax.into()
-    }
-}
-impl AstNode for CssViewTransitionAtRule {
-    type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_VIEW_TRANSITION_AT_RULE as u16));
-    fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_VIEW_TRANSITION_AT_RULE
-    }
-    fn cast(syntax: SyntaxNode) -> Option<Self> {
-        if Self::can_cast(syntax.kind()) {
-            Some(Self { syntax })
-        } else {
-            None
-        }
-    }
-    fn syntax(&self) -> &SyntaxNode {
-        &self.syntax
-    }
-    fn into_syntax(self) -> SyntaxNode {
-        self.syntax
-    }
-}
-impl std::fmt::Debug for CssViewTransitionAtRule {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
-        let current_depth = DEPTH.get();
-        let result = if current_depth < 16 {
-            DEPTH.set(current_depth + 1);
-            f.debug_struct("CssViewTransitionAtRule")
-                .field("declarator", &support::DebugSyntaxResult(self.declarator()))
-                .field("block", &support::DebugSyntaxResult(self.block()))
-                .finish()
-        } else {
-            f.debug_struct("CssViewTransitionAtRule").finish()
-        };
-        DEPTH.set(current_depth);
-        result
-    }
-}
-impl From<CssViewTransitionAtRule> for SyntaxNode {
-    fn from(n: CssViewTransitionAtRule) -> Self {
-        n.syntax
-    }
-}
-impl From<CssViewTransitionAtRule> for SyntaxElement {
-    fn from(n: CssViewTransitionAtRule) -> Self {
-        n.syntax.into()
-    }
-}
-impl AstNode for CssViewTransitionAtRuleDeclarator {
-    type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_VIEW_TRANSITION_AT_RULE_DECLARATOR as u16));
-    fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_VIEW_TRANSITION_AT_RULE_DECLARATOR
-    }
-    fn cast(syntax: SyntaxNode) -> Option<Self> {
-        if Self::can_cast(syntax.kind()) {
-            Some(Self { syntax })
-        } else {
-            None
-        }
-    }
-    fn syntax(&self) -> &SyntaxNode {
-        &self.syntax
-    }
-    fn into_syntax(self) -> SyntaxNode {
-        self.syntax
-    }
-}
-impl std::fmt::Debug for CssViewTransitionAtRuleDeclarator {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
-        let current_depth = DEPTH.get();
-        let result = if current_depth < 16 {
-            DEPTH.set(current_depth + 1);
-            f.debug_struct("CssViewTransitionAtRuleDeclarator")
-                .field(
-                    "view_transition_token",
-                    &support::DebugSyntaxResult(self.view_transition_token()),
-                )
-                .finish()
-        } else {
-            f.debug_struct("CssViewTransitionAtRuleDeclarator").finish()
-        };
-        DEPTH.set(current_depth);
-        result
-    }
-}
-impl From<CssViewTransitionAtRuleDeclarator> for SyntaxNode {
-    fn from(n: CssViewTransitionAtRuleDeclarator) -> Self {
-        n.syntax
-    }
-}
-impl From<CssViewTransitionAtRuleDeclarator> for SyntaxElement {
-    fn from(n: CssViewTransitionAtRuleDeclarator) -> Self {
-        n.syntax.into()
-    }
-}
-impl AstNode for TwApplyAtRule {
-    type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(TW_APPLY_AT_RULE as u16));
-    fn can_cast(kind: SyntaxKind) -> bool {
-        kind == TW_APPLY_AT_RULE
-    }
-    fn cast(syntax: SyntaxNode) -> Option<Self> {
-        if Self::can_cast(syntax.kind()) {
-            Some(Self { syntax })
-        } else {
-            None
-        }
-    }
-    fn syntax(&self) -> &SyntaxNode {
-        &self.syntax
-    }
-    fn into_syntax(self) -> SyntaxNode {
-        self.syntax
-    }
-}
-impl std::fmt::Debug for TwApplyAtRule {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
-        let current_depth = DEPTH.get();
-        let result = if current_depth < 16 {
-            DEPTH.set(current_depth + 1);
-            f.debug_struct("TwApplyAtRule")
-                .field(
-                    "apply_token",
-                    &support::DebugSyntaxResult(self.apply_token()),
-                )
-                .field("classes", &self.classes())
-                .field(
-                    "semicolon_token",
-                    &support::DebugSyntaxResult(self.semicolon_token()),
-                )
-                .finish()
-        } else {
-            f.debug_struct("TwApplyAtRule").finish()
-        };
-        DEPTH.set(current_depth);
-        result
-    }
-}
-impl From<TwApplyAtRule> for SyntaxNode {
-    fn from(n: TwApplyAtRule) -> Self {
-        n.syntax
-    }
-}
-impl From<TwApplyAtRule> for SyntaxElement {
-    fn from(n: TwApplyAtRule) -> Self {
-        n.syntax.into()
-    }
-}
-impl AstNode for TwConfigAtRule {
-    type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(TW_CONFIG_AT_RULE as u16));
-    fn can_cast(kind: SyntaxKind) -> bool {
-        kind == TW_CONFIG_AT_RULE
-    }
-    fn cast(syntax: SyntaxNode) -> Option<Self> {
-        if Self::can_cast(syntax.kind()) {
-            Some(Self { syntax })
-        } else {
-            None
-        }
-    }
-    fn syntax(&self) -> &SyntaxNode {
-        &self.syntax
-    }
-    fn into_syntax(self) -> SyntaxNode {
-        self.syntax
-    }
-}
-impl std::fmt::Debug for TwConfigAtRule {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
-        let current_depth = DEPTH.get();
-        let result = if current_depth < 16 {
-            DEPTH.set(current_depth + 1);
-            f.debug_struct("TwConfigAtRule")
-                .field(
-                    "config_token",
-                    &support::DebugSyntaxResult(self.config_token()),
-                )
-                .field("path", &support::DebugSyntaxResult(self.path()))
-                .field(
-                    "semicolon_token",
-                    &support::DebugSyntaxResult(self.semicolon_token()),
-                )
-                .finish()
-        } else {
-            f.debug_struct("TwConfigAtRule").finish()
-        };
-        DEPTH.set(current_depth);
-        result
-    }
-}
-impl From<TwConfigAtRule> for SyntaxNode {
-    fn from(n: TwConfigAtRule) -> Self {
-        n.syntax
-    }
-}
-impl From<TwConfigAtRule> for SyntaxElement {
-    fn from(n: TwConfigAtRule) -> Self {
-        n.syntax.into()
-    }
-}
-impl AstNode for TwCustomVariantAtRule {
-    type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(TW_CUSTOM_VARIANT_AT_RULE as u16));
-    fn can_cast(kind: SyntaxKind) -> bool {
-        kind == TW_CUSTOM_VARIANT_AT_RULE
-    }
-    fn cast(syntax: SyntaxNode) -> Option<Self> {
-        if Self::can_cast(syntax.kind()) {
-            Some(Self { syntax })
-        } else {
-            None
-        }
-    }
-    fn syntax(&self) -> &SyntaxNode {
-        &self.syntax
-    }
-    fn into_syntax(self) -> SyntaxNode {
-        self.syntax
-    }
-}
-impl std::fmt::Debug for TwCustomVariantAtRule {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
-        let current_depth = DEPTH.get();
-        let result = if current_depth < 16 {
-            DEPTH.set(current_depth + 1);
-            f.debug_struct("TwCustomVariantAtRule")
-                .field(
-                    "custom_variant_token",
-                    &support::DebugSyntaxResult(self.custom_variant_token()),
-                )
-                .field("name", &support::DebugSyntaxResult(self.name()))
-                .field("selector", &support::DebugSyntaxResult(self.selector()))
-                .finish()
-        } else {
-            f.debug_struct("TwCustomVariantAtRule").finish()
-        };
-        DEPTH.set(current_depth);
-        result
-    }
-}
-impl From<TwCustomVariantAtRule> for SyntaxNode {
-    fn from(n: TwCustomVariantAtRule) -> Self {
-        n.syntax
-    }
-}
-impl From<TwCustomVariantAtRule> for SyntaxElement {
-    fn from(n: TwCustomVariantAtRule) -> Self {
-        n.syntax.into()
-    }
-}
-impl AstNode for TwCustomVariantShorthand {
-    type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(TW_CUSTOM_VARIANT_SHORTHAND as u16));
-    fn can_cast(kind: SyntaxKind) -> bool {
-        kind == TW_CUSTOM_VARIANT_SHORTHAND
-    }
-    fn cast(syntax: SyntaxNode) -> Option<Self> {
-        if Self::can_cast(syntax.kind()) {
-            Some(Self { syntax })
-        } else {
-            None
-        }
-    }
-    fn syntax(&self) -> &SyntaxNode {
-        &self.syntax
-    }
-    fn into_syntax(self) -> SyntaxNode {
-        self.syntax
-    }
-}
-impl std::fmt::Debug for TwCustomVariantShorthand {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
-        let current_depth = DEPTH.get();
-        let result = if current_depth < 16 {
-            DEPTH.set(current_depth + 1);
-            f.debug_struct("TwCustomVariantShorthand")
-                .field(
-                    "l_paren_token",
-                    &support::DebugSyntaxResult(self.l_paren_token()),
-                )
-                .field("selector", &support::DebugSyntaxResult(self.selector()))
-                .field(
-                    "r_paren_token",
-                    &support::DebugSyntaxResult(self.r_paren_token()),
-                )
-                .field(
-                    "semicolon_token",
-                    &support::DebugSyntaxResult(self.semicolon_token()),
-                )
-                .finish()
-        } else {
-            f.debug_struct("TwCustomVariantShorthand").finish()
-        };
-        DEPTH.set(current_depth);
-        result
-    }
-}
-impl From<TwCustomVariantShorthand> for SyntaxNode {
-    fn from(n: TwCustomVariantShorthand) -> Self {
-        n.syntax
-    }
-}
-impl From<TwCustomVariantShorthand> for SyntaxElement {
-    fn from(n: TwCustomVariantShorthand) -> Self {
-        n.syntax.into()
-    }
-}
-impl AstNode for TwFunctionalUtilityName {
-    type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(TW_FUNCTIONAL_UTILITY_NAME as u16));
-    fn can_cast(kind: SyntaxKind) -> bool {
-        kind == TW_FUNCTIONAL_UTILITY_NAME
-    }
-    fn cast(syntax: SyntaxNode) -> Option<Self> {
-        if Self::can_cast(syntax.kind()) {
-            Some(Self { syntax })
-        } else {
-            None
-        }
-    }
-    fn syntax(&self) -> &SyntaxNode {
-        &self.syntax
-    }
-    fn into_syntax(self) -> SyntaxNode {
-        self.syntax
-    }
-}
-impl std::fmt::Debug for TwFunctionalUtilityName {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
-        let current_depth = DEPTH.get();
-        let result = if current_depth < 16 {
-            DEPTH.set(current_depth + 1);
-            f.debug_struct("TwFunctionalUtilityName")
-                .field("identifier", &support::DebugSyntaxResult(self.identifier()))
-                .field(
-                    "minus_token",
-                    &support::DebugSyntaxResult(self.minus_token()),
-                )
-                .field("star_token", &support::DebugSyntaxResult(self.star_token()))
-                .finish()
-        } else {
-            f.debug_struct("TwFunctionalUtilityName").finish()
-        };
-        DEPTH.set(current_depth);
-        result
-    }
-}
-impl From<TwFunctionalUtilityName> for SyntaxNode {
-    fn from(n: TwFunctionalUtilityName) -> Self {
-        n.syntax
-    }
-}
-impl From<TwFunctionalUtilityName> for SyntaxElement {
-    fn from(n: TwFunctionalUtilityName) -> Self {
-        n.syntax.into()
-    }
-}
-impl AstNode for TwPluginAtRule {
-    type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(TW_PLUGIN_AT_RULE as u16));
-    fn can_cast(kind: SyntaxKind) -> bool {
-        kind == TW_PLUGIN_AT_RULE
-    }
-    fn cast(syntax: SyntaxNode) -> Option<Self> {
-        if Self::can_cast(syntax.kind()) {
-            Some(Self { syntax })
-        } else {
-            None
-        }
-    }
-    fn syntax(&self) -> &SyntaxNode {
-        &self.syntax
-    }
-    fn into_syntax(self) -> SyntaxNode {
-        self.syntax
-    }
-}
-impl std::fmt::Debug for TwPluginAtRule {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
-        let current_depth = DEPTH.get();
-        let result = if current_depth < 16 {
-            DEPTH.set(current_depth + 1);
-            f.debug_struct("TwPluginAtRule")
-                .field(
-                    "plugin_token",
-                    &support::DebugSyntaxResult(self.plugin_token()),
-                )
-                .field("name", &support::DebugSyntaxResult(self.name()))
-                .field("block", &support::DebugOptionalElement(self.block()))
-                .field(
-                    "semicolon_token",
-                    &support::DebugOptionalElement(self.semicolon_token()),
-                )
-                .finish()
-        } else {
-            f.debug_struct("TwPluginAtRule").finish()
-        };
-        DEPTH.set(current_depth);
-        result
-    }
-}
-impl From<TwPluginAtRule> for SyntaxNode {
-    fn from(n: TwPluginAtRule) -> Self {
-        n.syntax
-    }
-}
-impl From<TwPluginAtRule> for SyntaxElement {
-    fn from(n: TwPluginAtRule) -> Self {
-        n.syntax.into()
-    }
-}
-impl AstNode for TwReferenceAtRule {
-    type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(TW_REFERENCE_AT_RULE as u16));
-    fn can_cast(kind: SyntaxKind) -> bool {
-        kind == TW_REFERENCE_AT_RULE
-    }
-    fn cast(syntax: SyntaxNode) -> Option<Self> {
-        if Self::can_cast(syntax.kind()) {
-            Some(Self { syntax })
-        } else {
-            None
-        }
-    }
-    fn syntax(&self) -> &SyntaxNode {
-        &self.syntax
-    }
-    fn into_syntax(self) -> SyntaxNode {
-        self.syntax
-    }
-}
-impl std::fmt::Debug for TwReferenceAtRule {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
-        let current_depth = DEPTH.get();
-        let result = if current_depth < 16 {
-            DEPTH.set(current_depth + 1);
-            f.debug_struct("TwReferenceAtRule")
-                .field(
-                    "reference_token",
-                    &support::DebugSyntaxResult(self.reference_token()),
-                )
-                .field("path", &support::DebugSyntaxResult(self.path()))
-                .field(
-                    "semicolon_token",
-                    &support::DebugSyntaxResult(self.semicolon_token()),
-                )
-                .finish()
-        } else {
-            f.debug_struct("TwReferenceAtRule").finish()
-        };
-        DEPTH.set(current_depth);
-        result
-    }
-}
-impl From<TwReferenceAtRule> for SyntaxNode {
-    fn from(n: TwReferenceAtRule) -> Self {
-        n.syntax
-    }
-}
-impl From<TwReferenceAtRule> for SyntaxElement {
-    fn from(n: TwReferenceAtRule) -> Self {
-        n.syntax.into()
-    }
-}
-impl AstNode for TwSlotAtRule {
-    type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(TW_SLOT_AT_RULE as u16));
-    fn can_cast(kind: SyntaxKind) -> bool {
-        kind == TW_SLOT_AT_RULE
-    }
-    fn cast(syntax: SyntaxNode) -> Option<Self> {
-        if Self::can_cast(syntax.kind()) {
-            Some(Self { syntax })
-        } else {
-            None
-        }
-    }
-    fn syntax(&self) -> &SyntaxNode {
-        &self.syntax
-    }
-    fn into_syntax(self) -> SyntaxNode {
-        self.syntax
-    }
-}
-impl std::fmt::Debug for TwSlotAtRule {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
-        let current_depth = DEPTH.get();
-        let result = if current_depth < 16 {
-            DEPTH.set(current_depth + 1);
-            f.debug_struct("TwSlotAtRule")
-                .field("slot_token", &support::DebugSyntaxResult(self.slot_token()))
-                .field(
-                    "semicolon_token",
-                    &support::DebugSyntaxResult(self.semicolon_token()),
-                )
-                .finish()
-        } else {
-            f.debug_struct("TwSlotAtRule").finish()
-        };
-        DEPTH.set(current_depth);
-        result
-    }
-}
-impl From<TwSlotAtRule> for SyntaxNode {
-    fn from(n: TwSlotAtRule) -> Self {
-        n.syntax
-    }
-}
-impl From<TwSlotAtRule> for SyntaxElement {
-    fn from(n: TwSlotAtRule) -> Self {
-        n.syntax.into()
-    }
-}
-impl AstNode for TwSourceAtRule {
-    type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(TW_SOURCE_AT_RULE as u16));
-    fn can_cast(kind: SyntaxKind) -> bool {
-        kind == TW_SOURCE_AT_RULE
-    }
-    fn cast(syntax: SyntaxNode) -> Option<Self> {
-        if Self::can_cast(syntax.kind()) {
-            Some(Self { syntax })
-        } else {
-            None
-        }
-    }
-    fn syntax(&self) -> &SyntaxNode {
-        &self.syntax
-    }
-    fn into_syntax(self) -> SyntaxNode {
-        self.syntax
-    }
-}
-impl std::fmt::Debug for TwSourceAtRule {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
-        let current_depth = DEPTH.get();
-        let result = if current_depth < 16 {
-            DEPTH.set(current_depth + 1);
-            f.debug_struct("TwSourceAtRule")
-                .field(
-                    "source_token",
-                    &support::DebugSyntaxResult(self.source_token()),
-                )
-                .field(
-                    "not_token",
-                    &support::DebugOptionalElement(self.not_token()),
-                )
-                .field("source", &support::DebugSyntaxResult(self.source()))
-                .field(
-                    "semicolon_token",
-                    &support::DebugSyntaxResult(self.semicolon_token()),
-                )
-                .finish()
-        } else {
-            f.debug_struct("TwSourceAtRule").finish()
-        };
-        DEPTH.set(current_depth);
-        result
-    }
-}
-impl From<TwSourceAtRule> for SyntaxNode {
-    fn from(n: TwSourceAtRule) -> Self {
-        n.syntax
-    }
-}
-impl From<TwSourceAtRule> for SyntaxElement {
-    fn from(n: TwSourceAtRule) -> Self {
-        n.syntax.into()
-    }
-}
-impl AstNode for TwSourceInline {
-    type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(TW_SOURCE_INLINE as u16));
-    fn can_cast(kind: SyntaxKind) -> bool {
-        kind == TW_SOURCE_INLINE
-    }
-    fn cast(syntax: SyntaxNode) -> Option<Self> {
-        if Self::can_cast(syntax.kind()) {
-            Some(Self { syntax })
-        } else {
-            None
-        }
-    }
-    fn syntax(&self) -> &SyntaxNode {
-        &self.syntax
-    }
-    fn into_syntax(self) -> SyntaxNode {
-        self.syntax
-    }
-}
-impl std::fmt::Debug for TwSourceInline {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
-        let current_depth = DEPTH.get();
-        let result = if current_depth < 16 {
-            DEPTH.set(current_depth + 1);
-            f.debug_struct("TwSourceInline")
-                .field(
-                    "inline_token",
-                    &support::DebugSyntaxResult(self.inline_token()),
-                )
-                .field(
-                    "l_paren_token",
-                    &support::DebugSyntaxResult(self.l_paren_token()),
-                )
-                .field("content", &support::DebugSyntaxResult(self.content()))
-                .field(
-                    "r_paren_token",
-                    &support::DebugSyntaxResult(self.r_paren_token()),
-                )
-                .finish()
-        } else {
-            f.debug_struct("TwSourceInline").finish()
-        };
-        DEPTH.set(current_depth);
-        result
-    }
-}
-impl From<TwSourceInline> for SyntaxNode {
-    fn from(n: TwSourceInline) -> Self {
-        n.syntax
-    }
-}
-impl From<TwSourceInline> for SyntaxElement {
-    fn from(n: TwSourceInline) -> Self {
-        n.syntax.into()
-    }
-}
-impl AstNode for TwThemeAtRule {
-    type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(TW_THEME_AT_RULE as u16));
-    fn can_cast(kind: SyntaxKind) -> bool {
-        kind == TW_THEME_AT_RULE
-    }
-    fn cast(syntax: SyntaxNode) -> Option<Self> {
-        if Self::can_cast(syntax.kind()) {
-            Some(Self { syntax })
-        } else {
-            None
-        }
-    }
-    fn syntax(&self) -> &SyntaxNode {
-        &self.syntax
-    }
-    fn into_syntax(self) -> SyntaxNode {
-        self.syntax
-    }
-}
-impl std::fmt::Debug for TwThemeAtRule {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
-        let current_depth = DEPTH.get();
-        let result = if current_depth < 16 {
-            DEPTH.set(current_depth + 1);
-            f.debug_struct("TwThemeAtRule")
-                .field(
-                    "theme_token",
-                    &support::DebugSyntaxResult(self.theme_token()),
-                )
-                .field("name", &support::DebugOptionalElement(self.name()))
-                .field("block", &support::DebugSyntaxResult(self.block()))
-                .finish()
-        } else {
-            f.debug_struct("TwThemeAtRule").finish()
-        };
-        DEPTH.set(current_depth);
-        result
-    }
-}
-impl From<TwThemeAtRule> for SyntaxNode {
-    fn from(n: TwThemeAtRule) -> Self {
-        n.syntax
-    }
-}
-impl From<TwThemeAtRule> for SyntaxElement {
-    fn from(n: TwThemeAtRule) -> Self {
-        n.syntax.into()
-    }
-}
-impl AstNode for TwUtilityAtRule {
-    type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(TW_UTILITY_AT_RULE as u16));
-    fn can_cast(kind: SyntaxKind) -> bool {
-        kind == TW_UTILITY_AT_RULE
-    }
-    fn cast(syntax: SyntaxNode) -> Option<Self> {
-        if Self::can_cast(syntax.kind()) {
-            Some(Self { syntax })
-        } else {
-            None
-        }
-    }
-    fn syntax(&self) -> &SyntaxNode {
-        &self.syntax
-    }
-    fn into_syntax(self) -> SyntaxNode {
-        self.syntax
-    }
-}
-impl std::fmt::Debug for TwUtilityAtRule {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
-        let current_depth = DEPTH.get();
-        let result = if current_depth < 16 {
-            DEPTH.set(current_depth + 1);
-            f.debug_struct("TwUtilityAtRule")
-                .field(
-                    "utility_token",
-                    &support::DebugSyntaxResult(self.utility_token()),
-                )
-                .field("name", &support::DebugSyntaxResult(self.name()))
-                .field("block", &support::DebugSyntaxResult(self.block()))
-                .finish()
-        } else {
-            f.debug_struct("TwUtilityAtRule").finish()
-        };
-        DEPTH.set(current_depth);
-        result
-    }
-}
-impl From<TwUtilityAtRule> for SyntaxNode {
-    fn from(n: TwUtilityAtRule) -> Self {
-        n.syntax
-    }
-}
-impl From<TwUtilityAtRule> for SyntaxElement {
-    fn from(n: TwUtilityAtRule) -> Self {
-        n.syntax.into()
-    }
-}
-impl AstNode for TwValueThemeReference {
-    type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(TW_VALUE_THEME_REFERENCE as u16));
-    fn can_cast(kind: SyntaxKind) -> bool {
-        kind == TW_VALUE_THEME_REFERENCE
-    }
-    fn cast(syntax: SyntaxNode) -> Option<Self> {
-        if Self::can_cast(syntax.kind()) {
-            Some(Self { syntax })
-        } else {
-            None
-        }
-    }
-    fn syntax(&self) -> &SyntaxNode {
-        &self.syntax
-    }
-    fn into_syntax(self) -> SyntaxNode {
-        self.syntax
-    }
-}
-impl std::fmt::Debug for TwValueThemeReference {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
-        let current_depth = DEPTH.get();
-        let result = if current_depth < 16 {
-            DEPTH.set(current_depth + 1);
-            f.debug_struct("TwValueThemeReference")
-                .field("reference", &support::DebugSyntaxResult(self.reference()))
-                .field(
-                    "minus_token",
-                    &support::DebugOptionalElement(self.minus_token()),
-                )
-                .field("star_token", &support::DebugSyntaxResult(self.star_token()))
-                .finish()
-        } else {
-            f.debug_struct("TwValueThemeReference").finish()
-        };
-        DEPTH.set(current_depth);
-        result
-    }
-}
-impl From<TwValueThemeReference> for SyntaxNode {
-    fn from(n: TwValueThemeReference) -> Self {
-        n.syntax
-    }
-}
-impl From<TwValueThemeReference> for SyntaxElement {
-    fn from(n: TwValueThemeReference) -> Self {
-        n.syntax.into()
-    }
-}
-impl AstNode for TwVariantAtRule {
-    type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(TW_VARIANT_AT_RULE as u16));
-    fn can_cast(kind: SyntaxKind) -> bool {
-        kind == TW_VARIANT_AT_RULE
-    }
-    fn cast(syntax: SyntaxNode) -> Option<Self> {
-        if Self::can_cast(syntax.kind()) {
-            Some(Self { syntax })
-        } else {
-            None
-        }
-    }
-    fn syntax(&self) -> &SyntaxNode {
-        &self.syntax
-    }
-    fn into_syntax(self) -> SyntaxNode {
-        self.syntax
-    }
-}
-impl std::fmt::Debug for TwVariantAtRule {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
-        let current_depth = DEPTH.get();
-        let result = if current_depth < 16 {
-            DEPTH.set(current_depth + 1);
-            f.debug_struct("TwVariantAtRule")
-                .field(
-                    "variant_token",
-                    &support::DebugSyntaxResult(self.variant_token()),
-                )
-                .field("name", &support::DebugSyntaxResult(self.name()))
-                .field("block", &support::DebugSyntaxResult(self.block()))
-                .finish()
-        } else {
-            f.debug_struct("TwVariantAtRule").finish()
-        };
-        DEPTH.set(current_depth);
-        result
-    }
-}
-impl From<TwVariantAtRule> for SyntaxNode {
-    fn from(n: TwVariantAtRule) -> Self {
-        n.syntax
-    }
-}
-impl From<TwVariantAtRule> for SyntaxElement {
-    fn from(n: TwVariantAtRule) -> Self {
-        n.syntax.into()
-    }
-}
-impl From<CssBogusAtRule> for AnyCssAtRule {
-    fn from(node: CssBogusAtRule) -> Self {
-        Self::CssBogusAtRule(node)
-    }
-}
-impl From<CssCharsetAtRule> for AnyCssAtRule {
-    fn from(node: CssCharsetAtRule) -> Self {
-        Self::CssCharsetAtRule(node)
-    }
-}
-impl From<CssColorProfileAtRule> for AnyCssAtRule {
-    fn from(node: CssColorProfileAtRule) -> Self {
-        Self::CssColorProfileAtRule(node)
-    }
-}
-impl From<CssContainerAtRule> for AnyCssAtRule {
-    fn from(node: CssContainerAtRule) -> Self {
-        Self::CssContainerAtRule(node)
-    }
-}
-impl From<CssCounterStyleAtRule> for AnyCssAtRule {
-    fn from(node: CssCounterStyleAtRule) -> Self {
-        Self::CssCounterStyleAtRule(node)
-    }
-}
-impl From<CssDocumentAtRule> for AnyCssAtRule {
-    fn from(node: CssDocumentAtRule) -> Self {
-        Self::CssDocumentAtRule(node)
-    }
-}
-impl From<CssFontFaceAtRule> for AnyCssAtRule {
-    fn from(node: CssFontFaceAtRule) -> Self {
-        Self::CssFontFaceAtRule(node)
-    }
-}
-impl From<CssFontFeatureValuesAtRule> for AnyCssAtRule {
-    fn from(node: CssFontFeatureValuesAtRule) -> Self {
-        Self::CssFontFeatureValuesAtRule(node)
-    }
-}
-impl From<CssFontPaletteValuesAtRule> for AnyCssAtRule {
-    fn from(node: CssFontPaletteValuesAtRule) -> Self {
-        Self::CssFontPaletteValuesAtRule(node)
-    }
-}
-impl From<CssImportAtRule> for AnyCssAtRule {
-    fn from(node: CssImportAtRule) -> Self {
-        Self::CssImportAtRule(node)
-    }
-}
-impl From<CssKeyframesAtRule> for AnyCssAtRule {
-    fn from(node: CssKeyframesAtRule) -> Self {
-        Self::CssKeyframesAtRule(node)
-    }
-}
-impl From<CssLayerAtRule> for AnyCssAtRule {
-    fn from(node: CssLayerAtRule) -> Self {
-        Self::CssLayerAtRule(node)
-    }
-}
-impl From<CssMediaAtRule> for AnyCssAtRule {
-    fn from(node: CssMediaAtRule) -> Self {
-        Self::CssMediaAtRule(node)
-    }
-}
-impl From<CssNamespaceAtRule> for AnyCssAtRule {
-    fn from(node: CssNamespaceAtRule) -> Self {
-        Self::CssNamespaceAtRule(node)
-    }
-}
-impl From<CssPageAtRule> for AnyCssAtRule {
-    fn from(node: CssPageAtRule) -> Self {
-        Self::CssPageAtRule(node)
-    }
-}
-impl From<CssPositionTryAtRule> for AnyCssAtRule {
-    fn from(node: CssPositionTryAtRule) -> Self {
-        Self::CssPositionTryAtRule(node)
-    }
-}
-impl From<CssPropertyAtRule> for AnyCssAtRule {
-    fn from(node: CssPropertyAtRule) -> Self {
-        Self::CssPropertyAtRule(node)
-    }
-}
-impl From<CssScopeAtRule> for AnyCssAtRule {
-    fn from(node: CssScopeAtRule) -> Self {
-        Self::CssScopeAtRule(node)
-    }
-}
-impl From<CssStartingStyleAtRule> for AnyCssAtRule {
-    fn from(node: CssStartingStyleAtRule) -> Self {
-        Self::CssStartingStyleAtRule(node)
-    }
-}
-impl From<CssSupportsAtRule> for AnyCssAtRule {
-    fn from(node: CssSupportsAtRule) -> Self {
-        Self::CssSupportsAtRule(node)
-    }
-}
-impl From<CssUnknownBlockAtRule> for AnyCssAtRule {
-    fn from(node: CssUnknownBlockAtRule) -> Self {
-        Self::CssUnknownBlockAtRule(node)
-    }
-}
-impl From<CssUnknownValueAtRule> for AnyCssAtRule {
-    fn from(node: CssUnknownValueAtRule) -> Self {
-        Self::CssUnknownValueAtRule(node)
-    }
-}
-impl From<CssValueAtRule> for AnyCssAtRule {
-    fn from(node: CssValueAtRule) -> Self {
-        Self::CssValueAtRule(node)
-    }
-}
-impl From<CssViewTransitionAtRule> for AnyCssAtRule {
-    fn from(node: CssViewTransitionAtRule) -> Self {
-        Self::CssViewTransitionAtRule(node)
-    }
-}
-impl From<TwApplyAtRule> for AnyCssAtRule {
-    fn from(node: TwApplyAtRule) -> Self {
-        Self::TwApplyAtRule(node)
-    }
-}
-impl From<TwConfigAtRule> for AnyCssAtRule {
-    fn from(node: TwConfigAtRule) -> Self {
-        Self::TwConfigAtRule(node)
-    }
-}
-impl From<TwCustomVariantAtRule> for AnyCssAtRule {
-    fn from(node: TwCustomVariantAtRule) -> Self {
-        Self::TwCustomVariantAtRule(node)
-    }
-}
-impl From<TwPluginAtRule> for AnyCssAtRule {
-    fn from(node: TwPluginAtRule) -> Self {
-        Self::TwPluginAtRule(node)
-    }
-}
-impl From<TwReferenceAtRule> for AnyCssAtRule {
-    fn from(node: TwReferenceAtRule) -> Self {
-        Self::TwReferenceAtRule(node)
-    }
-}
-impl From<TwSlotAtRule> for AnyCssAtRule {
-    fn from(node: TwSlotAtRule) -> Self {
-        Self::TwSlotAtRule(node)
-    }
-}
-impl From<TwSourceAtRule> for AnyCssAtRule {
-    fn from(node: TwSourceAtRule) -> Self {
-        Self::TwSourceAtRule(node)
-    }
-}
-impl From<TwThemeAtRule> for AnyCssAtRule {
-    fn from(node: TwThemeAtRule) -> Self {
-        Self::TwThemeAtRule(node)
-    }
-}
-impl From<TwUtilityAtRule> for AnyCssAtRule {
-    fn from(node: TwUtilityAtRule) -> Self {
-        Self::TwUtilityAtRule(node)
-    }
-}
-impl From<TwVariantAtRule> for AnyCssAtRule {
-    fn from(node: TwVariantAtRule) -> Self {
-        Self::TwVariantAtRule(node)
-    }
-}
-impl AstNode for AnyCssAtRule {
-    type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> = CssBogusAtRule::KIND_SET
-        .union(CssCharsetAtRule::KIND_SET)
-        .union(CssColorProfileAtRule::KIND_SET)
-        .union(CssContainerAtRule::KIND_SET)
-        .union(CssCounterStyleAtRule::KIND_SET)
-        .union(CssDocumentAtRule::KIND_SET)
-        .union(CssFontFaceAtRule::KIND_SET)
-        .union(CssFontFeatureValuesAtRule::KIND_SET)
-        .union(CssFontPaletteValuesAtRule::KIND_SET)
-        .union(CssImportAtRule::KIND_SET)
-        .union(CssKeyframesAtRule::KIND_SET)
-        .union(CssLayerAtRule::KIND_SET)
-        .union(CssMediaAtRule::KIND_SET)
-        .union(CssNamespaceAtRule::KIND_SET)
-        .union(CssPageAtRule::KIND_SET)
-        .union(CssPositionTryAtRule::KIND_SET)
-        .union(CssPropertyAtRule::KIND_SET)
-        .union(CssScopeAtRule::KIND_SET)
-        .union(CssStartingStyleAtRule::KIND_SET)
-        .union(CssSupportsAtRule::KIND_SET)
-        .union(CssUnknownBlockAtRule::KIND_SET)
-        .union(CssUnknownValueAtRule::KIND_SET)
-        .union(CssValueAtRule::KIND_SET)
-        .union(CssViewTransitionAtRule::KIND_SET)
-        .union(TwApplyAtRule::KIND_SET)
-        .union(TwConfigAtRule::KIND_SET)
-        .union(TwCustomVariantAtRule::KIND_SET)
-        .union(TwPluginAtRule::KIND_SET)
-        .union(TwReferenceAtRule::KIND_SET)
-        .union(TwSlotAtRule::KIND_SET)
-        .union(TwSourceAtRule::KIND_SET)
-        .union(TwThemeAtRule::KIND_SET)
-        .union(TwUtilityAtRule::KIND_SET)
-        .union(TwVariantAtRule::KIND_SET);
-    fn can_cast(kind: SyntaxKind) -> bool {
-        matches!(
-            kind,
-            CSS_BOGUS_AT_RULE
-                | CSS_CHARSET_AT_RULE
-                | CSS_COLOR_PROFILE_AT_RULE
-                | CSS_CONTAINER_AT_RULE
-                | CSS_COUNTER_STYLE_AT_RULE
-                | CSS_DOCUMENT_AT_RULE
-                | CSS_FONT_FACE_AT_RULE
-                | CSS_FONT_FEATURE_VALUES_AT_RULE
-                | CSS_FONT_PALETTE_VALUES_AT_RULE
-                | CSS_IMPORT_AT_RULE
-                | CSS_KEYFRAMES_AT_RULE
-                | CSS_LAYER_AT_RULE
-                | CSS_MEDIA_AT_RULE
-                | CSS_NAMESPACE_AT_RULE
-                | CSS_PAGE_AT_RULE
-                | CSS_POSITION_TRY_AT_RULE
-                | CSS_PROPERTY_AT_RULE
-                | CSS_SCOPE_AT_RULE
-                | CSS_STARTING_STYLE_AT_RULE
-                | CSS_SUPPORTS_AT_RULE
-                | CSS_UNKNOWN_BLOCK_AT_RULE
-                | CSS_UNKNOWN_VALUE_AT_RULE
-                | CSS_VALUE_AT_RULE
-                | CSS_VIEW_TRANSITION_AT_RULE
-                | TW_APPLY_AT_RULE
-                | TW_CONFIG_AT_RULE
-                | TW_CUSTOM_VARIANT_AT_RULE
-                | TW_PLUGIN_AT_RULE
-                | TW_REFERENCE_AT_RULE
-                | TW_SLOT_AT_RULE
-                | TW_SOURCE_AT_RULE
-                | TW_THEME_AT_RULE
-                | TW_UTILITY_AT_RULE
-                | TW_VARIANT_AT_RULE
-        )
-    }
-    fn cast(syntax: SyntaxNode) -> Option<Self> {
-        let res = match syntax.kind() {
-            CSS_BOGUS_AT_RULE => Self::CssBogusAtRule(CssBogusAtRule { syntax }),
-            CSS_CHARSET_AT_RULE => Self::CssCharsetAtRule(CssCharsetAtRule { syntax }),
-            CSS_COLOR_PROFILE_AT_RULE => {
-                Self::CssColorProfileAtRule(CssColorProfileAtRule { syntax })
-            }
-            CSS_CONTAINER_AT_RULE => Self::CssContainerAtRule(CssContainerAtRule { syntax }),
-            CSS_COUNTER_STYLE_AT_RULE => {
-                Self::CssCounterStyleAtRule(CssCounterStyleAtRule { syntax })
-            }
-            CSS_DOCUMENT_AT_RULE => Self::CssDocumentAtRule(CssDocumentAtRule { syntax }),
-            CSS_FONT_FACE_AT_RULE => Self::CssFontFaceAtRule(CssFontFaceAtRule { syntax }),
-            CSS_FONT_FEATURE_VALUES_AT_RULE => {
-                Self::CssFontFeatureValuesAtRule(CssFontFeatureValuesAtRule { syntax })
-            }
-            CSS_FONT_PALETTE_VALUES_AT_RULE => {
-                Self::CssFontPaletteValuesAtRule(CssFontPaletteValuesAtRule { syntax })
-            }
-            CSS_IMPORT_AT_RULE => Self::CssImportAtRule(CssImportAtRule { syntax }),
-            CSS_KEYFRAMES_AT_RULE => Self::CssKeyframesAtRule(CssKeyframesAtRule { syntax }),
-            CSS_LAYER_AT_RULE => Self::CssLayerAtRule(CssLayerAtRule { syntax }),
-            CSS_MEDIA_AT_RULE => Self::CssMediaAtRule(CssMediaAtRule { syntax }),
-            CSS_NAMESPACE_AT_RULE => Self::CssNamespaceAtRule(CssNamespaceAtRule { syntax }),
-            CSS_PAGE_AT_RULE => Self::CssPageAtRule(CssPageAtRule { syntax }),
-            CSS_POSITION_TRY_AT_RULE => Self::CssPositionTryAtRule(CssPositionTryAtRule { syntax }),
-            CSS_PROPERTY_AT_RULE => Self::CssPropertyAtRule(CssPropertyAtRule { syntax }),
-            CSS_SCOPE_AT_RULE => Self::CssScopeAtRule(CssScopeAtRule { syntax }),
-            CSS_STARTING_STYLE_AT_RULE => {
-                Self::CssStartingStyleAtRule(CssStartingStyleAtRule { syntax })
-            }
-            CSS_SUPPORTS_AT_RULE => Self::CssSupportsAtRule(CssSupportsAtRule { syntax }),
-            CSS_UNKNOWN_BLOCK_AT_RULE => {
-                Self::CssUnknownBlockAtRule(CssUnknownBlockAtRule { syntax })
-            }
-            CSS_UNKNOWN_VALUE_AT_RULE => {
-                Self::CssUnknownValueAtRule(CssUnknownValueAtRule { syntax })
-            }
-            CSS_VALUE_AT_RULE => Self::CssValueAtRule(CssValueAtRule { syntax }),
-            CSS_VIEW_TRANSITION_AT_RULE => {
-                Self::CssViewTransitionAtRule(CssViewTransitionAtRule { syntax })
-            }
-            TW_APPLY_AT_RULE => Self::TwApplyAtRule(TwApplyAtRule { syntax }),
-            TW_CONFIG_AT_RULE => Self::TwConfigAtRule(TwConfigAtRule { syntax }),
-            TW_CUSTOM_VARIANT_AT_RULE => {
-                Self::TwCustomVariantAtRule(TwCustomVariantAtRule { syntax })
-            }
-            TW_PLUGIN_AT_RULE => Self::TwPluginAtRule(TwPluginAtRule { syntax }),
-            TW_REFERENCE_AT_RULE => Self::TwReferenceAtRule(TwReferenceAtRule { syntax }),
-            TW_SLOT_AT_RULE => Self::TwSlotAtRule(TwSlotAtRule { syntax }),
-            TW_SOURCE_AT_RULE => Self::TwSourceAtRule(TwSourceAtRule { syntax }),
-            TW_THEME_AT_RULE => Self::TwThemeAtRule(TwThemeAtRule { syntax }),
-            TW_UTILITY_AT_RULE => Self::TwUtilityAtRule(TwUtilityAtRule { syntax }),
-            TW_VARIANT_AT_RULE => Self::TwVariantAtRule(TwVariantAtRule { syntax }),
-            _ => return None,
-        };
-        Some(res)
-    }
-    fn syntax(&self) -> &SyntaxNode {
-        match self {
-            Self::CssBogusAtRule(it) => it.syntax(),
-            Self::CssCharsetAtRule(it) => it.syntax(),
-            Self::CssColorProfileAtRule(it) => it.syntax(),
-            Self::CssContainerAtRule(it) => it.syntax(),
-            Self::CssCounterStyleAtRule(it) => it.syntax(),
-            Self::CssDocumentAtRule(it) => it.syntax(),
-            Self::CssFontFaceAtRule(it) => it.syntax(),
-            Self::CssFontFeatureValuesAtRule(it) => it.syntax(),
-            Self::CssFontPaletteValuesAtRule(it) => it.syntax(),
-            Self::CssImportAtRule(it) => it.syntax(),
-            Self::CssKeyframesAtRule(it) => it.syntax(),
-            Self::CssLayerAtRule(it) => it.syntax(),
-            Self::CssMediaAtRule(it) => it.syntax(),
-            Self::CssNamespaceAtRule(it) => it.syntax(),
-            Self::CssPageAtRule(it) => it.syntax(),
-            Self::CssPositionTryAtRule(it) => it.syntax(),
-            Self::CssPropertyAtRule(it) => it.syntax(),
-            Self::CssScopeAtRule(it) => it.syntax(),
-            Self::CssStartingStyleAtRule(it) => it.syntax(),
-            Self::CssSupportsAtRule(it) => it.syntax(),
-            Self::CssUnknownBlockAtRule(it) => it.syntax(),
-            Self::CssUnknownValueAtRule(it) => it.syntax(),
-            Self::CssValueAtRule(it) => it.syntax(),
-            Self::CssViewTransitionAtRule(it) => it.syntax(),
-            Self::TwApplyAtRule(it) => it.syntax(),
-            Self::TwConfigAtRule(it) => it.syntax(),
-            Self::TwCustomVariantAtRule(it) => it.syntax(),
-            Self::TwPluginAtRule(it) => it.syntax(),
-            Self::TwReferenceAtRule(it) => it.syntax(),
-            Self::TwSlotAtRule(it) => it.syntax(),
-            Self::TwSourceAtRule(it) => it.syntax(),
-            Self::TwThemeAtRule(it) => it.syntax(),
-            Self::TwUtilityAtRule(it) => it.syntax(),
-            Self::TwVariantAtRule(it) => it.syntax(),
-        }
-    }
-    fn into_syntax(self) -> SyntaxNode {
-        match self {
-            Self::CssBogusAtRule(it) => it.into_syntax(),
-            Self::CssCharsetAtRule(it) => it.into_syntax(),
-            Self::CssColorProfileAtRule(it) => it.into_syntax(),
-            Self::CssContainerAtRule(it) => it.into_syntax(),
-            Self::CssCounterStyleAtRule(it) => it.into_syntax(),
-            Self::CssDocumentAtRule(it) => it.into_syntax(),
-            Self::CssFontFaceAtRule(it) => it.into_syntax(),
-            Self::CssFontFeatureValuesAtRule(it) => it.into_syntax(),
-            Self::CssFontPaletteValuesAtRule(it) => it.into_syntax(),
-            Self::CssImportAtRule(it) => it.into_syntax(),
-            Self::CssKeyframesAtRule(it) => it.into_syntax(),
-            Self::CssLayerAtRule(it) => it.into_syntax(),
-            Self::CssMediaAtRule(it) => it.into_syntax(),
-            Self::CssNamespaceAtRule(it) => it.into_syntax(),
-            Self::CssPageAtRule(it) => it.into_syntax(),
-            Self::CssPositionTryAtRule(it) => it.into_syntax(),
-            Self::CssPropertyAtRule(it) => it.into_syntax(),
-            Self::CssScopeAtRule(it) => it.into_syntax(),
-            Self::CssStartingStyleAtRule(it) => it.into_syntax(),
-            Self::CssSupportsAtRule(it) => it.into_syntax(),
-            Self::CssUnknownBlockAtRule(it) => it.into_syntax(),
-            Self::CssUnknownValueAtRule(it) => it.into_syntax(),
-            Self::CssValueAtRule(it) => it.into_syntax(),
-            Self::CssViewTransitionAtRule(it) => it.into_syntax(),
-            Self::TwApplyAtRule(it) => it.into_syntax(),
-            Self::TwConfigAtRule(it) => it.into_syntax(),
-            Self::TwCustomVariantAtRule(it) => it.into_syntax(),
-            Self::TwPluginAtRule(it) => it.into_syntax(),
-            Self::TwReferenceAtRule(it) => it.into_syntax(),
-            Self::TwSlotAtRule(it) => it.into_syntax(),
-            Self::TwSourceAtRule(it) => it.into_syntax(),
-            Self::TwThemeAtRule(it) => it.into_syntax(),
-            Self::TwUtilityAtRule(it) => it.into_syntax(),
-            Self::TwVariantAtRule(it) => it.into_syntax(),
-        }
-    }
-}
-impl std::fmt::Debug for AnyCssAtRule {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        match self {
-            Self::CssBogusAtRule(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssCharsetAtRule(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssColorProfileAtRule(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssContainerAtRule(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssCounterStyleAtRule(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssDocumentAtRule(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssFontFaceAtRule(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssFontFeatureValuesAtRule(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssFontPaletteValuesAtRule(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssImportAtRule(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssKeyframesAtRule(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssLayerAtRule(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssMediaAtRule(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssNamespaceAtRule(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssPageAtRule(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssPositionTryAtRule(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssPropertyAtRule(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssScopeAtRule(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssStartingStyleAtRule(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssSupportsAtRule(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssUnknownBlockAtRule(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssUnknownValueAtRule(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssValueAtRule(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssViewTransitionAtRule(it) => std::fmt::Debug::fmt(it, f),
-            Self::TwApplyAtRule(it) => std::fmt::Debug::fmt(it, f),
-            Self::TwConfigAtRule(it) => std::fmt::Debug::fmt(it, f),
-            Self::TwCustomVariantAtRule(it) => std::fmt::Debug::fmt(it, f),
-            Self::TwPluginAtRule(it) => std::fmt::Debug::fmt(it, f),
-            Self::TwReferenceAtRule(it) => std::fmt::Debug::fmt(it, f),
-            Self::TwSlotAtRule(it) => std::fmt::Debug::fmt(it, f),
-            Self::TwSourceAtRule(it) => std::fmt::Debug::fmt(it, f),
-            Self::TwThemeAtRule(it) => std::fmt::Debug::fmt(it, f),
-            Self::TwUtilityAtRule(it) => std::fmt::Debug::fmt(it, f),
-            Self::TwVariantAtRule(it) => std::fmt::Debug::fmt(it, f),
-        }
-    }
-}
-impl From<AnyCssAtRule> for SyntaxNode {
-    fn from(n: AnyCssAtRule) -> Self {
-        match n {
-            AnyCssAtRule::CssBogusAtRule(it) => it.into_syntax(),
-            AnyCssAtRule::CssCharsetAtRule(it) => it.into_syntax(),
-            AnyCssAtRule::CssColorProfileAtRule(it) => it.into_syntax(),
-            AnyCssAtRule::CssContainerAtRule(it) => it.into_syntax(),
-            AnyCssAtRule::CssCounterStyleAtRule(it) => it.into_syntax(),
-            AnyCssAtRule::CssDocumentAtRule(it) => it.into_syntax(),
-            AnyCssAtRule::CssFontFaceAtRule(it) => it.into_syntax(),
-            AnyCssAtRule::CssFontFeatureValuesAtRule(it) => it.into_syntax(),
-            AnyCssAtRule::CssFontPaletteValuesAtRule(it) => it.into_syntax(),
-            AnyCssAtRule::CssImportAtRule(it) => it.into_syntax(),
-            AnyCssAtRule::CssKeyframesAtRule(it) => it.into_syntax(),
-            AnyCssAtRule::CssLayerAtRule(it) => it.into_syntax(),
-            AnyCssAtRule::CssMediaAtRule(it) => it.into_syntax(),
-            AnyCssAtRule::CssNamespaceAtRule(it) => it.into_syntax(),
-            AnyCssAtRule::CssPageAtRule(it) => it.into_syntax(),
-            AnyCssAtRule::CssPositionTryAtRule(it) => it.into_syntax(),
-            AnyCssAtRule::CssPropertyAtRule(it) => it.into_syntax(),
-            AnyCssAtRule::CssScopeAtRule(it) => it.into_syntax(),
-            AnyCssAtRule::CssStartingStyleAtRule(it) => it.into_syntax(),
-            AnyCssAtRule::CssSupportsAtRule(it) => it.into_syntax(),
-            AnyCssAtRule::CssUnknownBlockAtRule(it) => it.into_syntax(),
-            AnyCssAtRule::CssUnknownValueAtRule(it) => it.into_syntax(),
-            AnyCssAtRule::CssValueAtRule(it) => it.into_syntax(),
-            AnyCssAtRule::CssViewTransitionAtRule(it) => it.into_syntax(),
-            AnyCssAtRule::TwApplyAtRule(it) => it.into_syntax(),
-            AnyCssAtRule::TwConfigAtRule(it) => it.into_syntax(),
-            AnyCssAtRule::TwCustomVariantAtRule(it) => it.into_syntax(),
-            AnyCssAtRule::TwPluginAtRule(it) => it.into_syntax(),
-            AnyCssAtRule::TwReferenceAtRule(it) => it.into_syntax(),
-            AnyCssAtRule::TwSlotAtRule(it) => it.into_syntax(),
-            AnyCssAtRule::TwSourceAtRule(it) => it.into_syntax(),
-            AnyCssAtRule::TwThemeAtRule(it) => it.into_syntax(),
-            AnyCssAtRule::TwUtilityAtRule(it) => it.into_syntax(),
-            AnyCssAtRule::TwVariantAtRule(it) => it.into_syntax(),
-        }
-    }
-}
-impl From<AnyCssAtRule> for SyntaxElement {
-    fn from(n: AnyCssAtRule) -> Self {
-        let node: SyntaxNode = n.into();
-        node.into()
-    }
-}
-impl From<CssColorProfileAtRuleDeclarator> for AnyCssAtRuleDeclarator {
-    fn from(node: CssColorProfileAtRuleDeclarator) -> Self {
-        Self::CssColorProfileAtRuleDeclarator(node)
-    }
-}
-impl From<CssContainerAtRuleDeclarator> for AnyCssAtRuleDeclarator {
-    fn from(node: CssContainerAtRuleDeclarator) -> Self {
-        Self::CssContainerAtRuleDeclarator(node)
-    }
-}
-impl From<CssCounterStyleAtRuleDeclarator> for AnyCssAtRuleDeclarator {
-    fn from(node: CssCounterStyleAtRuleDeclarator) -> Self {
-        Self::CssCounterStyleAtRuleDeclarator(node)
+                    "not_token",
+                    &support::DebugOptionalElement(self.not_token()),
+                )
+                .field("source", &support::DebugSyntaxResult(self.source()))
+                .field(
+                    "semicolon_token",
+                    &support::DebugSyntaxResult(self.semicolon_token()),
+                )
+                .finish()
+        } else {
+            f.debug_struct("TwSourceAtRule").finish()
+        };
+        DEPTH.set(current_depth);
+        result
     }
 }
-impl From<CssFontFaceAtRuleDeclarator> for AnyCssAtRuleDeclarator {
-    fn from(node: CssFontFaceAtRuleDeclarator) -> Self {
-        Self::CssFontFaceAtRuleDeclarator(node)
+impl From<TwSourceAtRule> for SyntaxNode {
+    fn from(n: TwSourceAtRule) -> Self {
+        n.syntax
     }
 }
-impl From<CssFontPaletteValuesAtRuleDeclarator> for AnyCssAtRuleDeclarator {
-    fn from(node: CssFontPaletteValuesAtRuleDeclarator) -> Self {
-        Self::CssFontPaletteValuesAtRuleDeclarator(node)
+impl From<TwSourceAtRule> for SyntaxElement {
+    fn from(n: TwSourceAtRule) -> Self {
+        n.syntax.into()
     }
 }
-impl From<CssMediaAtRuleDeclarator> for AnyCssAtRuleDeclarator {
-    fn from(node: CssMediaAtRuleDeclarator) -> Self {
-        Self::CssMediaAtRuleDeclarator(node)
+impl AstNode for TwSourceInline {
+    type Language = Language;
+    const KIND_SET: SyntaxKindSet<Language> =
+        SyntaxKindSet::from_raw(RawSyntaxKind(TW_SOURCE_INLINE as u16));
+    fn can_cast(kind: SyntaxKind) -> bool {
+        kind == TW_SOURCE_INLINE
     }
-}
-impl From<CssPositionTryAtRuleDeclarator> for AnyCssAtRuleDeclarator {
-    fn from(node: CssPositionTryAtRuleDeclarator) -> Self {
-        Self::CssPositionTryAtRuleDeclarator(node)
+    fn cast(syntax: SyntaxNode) -> Option<Self> {
+        if Self::can_cast(syntax.kind()) {
+            Some(Self { syntax })
+        } else {
+            None
+        }
     }
-}
-impl From<CssPropertyAtRuleDeclarator> for AnyCssAtRuleDeclarator {
-    fn from(node: CssPropertyAtRuleDeclarator) -> Self {
-        Self::CssPropertyAtRuleDeclarator(node)
+    fn syntax(&self) -> &SyntaxNode {
+        &self.syntax
     }
-}
-impl From<CssScopeAtRuleDeclarator> for AnyCssAtRuleDeclarator {
-    fn from(node: CssScopeAtRuleDeclarator) -> Self {
-        Self::CssScopeAtRuleDeclarator(node)
+    fn into_syntax(self) -> SyntaxNode {
+        self.syntax
     }
 }
-impl From<CssStartingStyleAtRuleDeclarator> for AnyCssAtRuleDeclarator {
-    fn from(node: CssStartingStyleAtRuleDeclarator) -> Self {
-        Self::CssStartingStyleAtRuleDeclarator(node)
+impl std::fmt::Debug for TwSourceInline {
+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+        thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
+        let current_depth = DEPTH.get();
+        let result = if current_depth < 16 {
+            DEPTH.set(current_depth + 1);
+            f.debug_struct("TwSourceInline")
+                .field(
+                    "inline_token",
+                    &support::DebugSyntaxResult(self.inline_token()),
+                )
+                .field(
+                    "l_paren_token",
+                    &support::DebugSyntaxResult(self.l_paren_token()),
+                )
+                .field("content", &support::DebugSyntaxResult(self.content()))
+                .field(
+                    "r_paren_token",
+                    &support::DebugSyntaxResult(self.r_paren_token()),
+                )
+                .finish()
+        } else {
+            f.debug_struct("TwSourceInline").finish()
+        };
+        DEPTH.set(current_depth);
+        result
     }
 }
-impl From<CssSupportsAtRuleDeclarator> for AnyCssAtRuleDeclarator {
-    fn from(node: CssSupportsAtRuleDeclarator) -> Self {
-        Self::CssSupportsAtRuleDeclarator(node)
+impl From<TwSourceInline> for SyntaxNode {
+    fn from(n: TwSourceInline) -> Self {
+        n.syntax
     }
 }
-impl From<CssViewTransitionAtRuleDeclarator> for AnyCssAtRuleDeclarator {
-    fn from(node: CssViewTransitionAtRuleDeclarator) -> Self {
-        Self::CssViewTransitionAtRuleDeclarator(node)
+impl From<TwSourceInline> for SyntaxElement {
+    fn from(n: TwSourceInline) -> Self {
+        n.syntax.into()
     }
 }
-impl AstNode for AnyCssAtRuleDeclarator {
+impl AstNode for TwThemeAtRule {
     type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> = CssColorProfileAtRuleDeclarator::KIND_SET
-        .union(CssContainerAtRuleDeclarator::KIND_SET)
-        .union(CssCounterStyleAtRuleDeclarator::KIND_SET)
-        .union(CssFontFaceAtRuleDeclarator::KIND_SET)
-        .union(CssFontPaletteValuesAtRuleDeclarator::KIND_SET)
-        .union(CssMediaAtRuleDeclarator::KIND_SET)
-        .union(CssPositionTryAtRuleDeclarator::KIND_SET)
-        .union(CssPropertyAtRuleDeclarator::KIND_SET)
-        .union(CssScopeAtRuleDeclarator::KIND_SET)
-        .union(CssStartingStyleAtRuleDeclarator::KIND_SET)
-        .union(CssSupportsAtRuleDeclarator::KIND_SET)
-        .union(CssViewTransitionAtRuleDeclarator::KIND_SET);
+    const KIND_SET: SyntaxKindSet<Language> =
+        SyntaxKindSet::from_raw(RawSyntaxKind(TW_THEME_AT_RULE as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        matches!(
-            kind,
-            CSS_COLOR_PROFILE_AT_RULE_DECLARATOR
-                | CSS_CONTAINER_AT_RULE_DECLARATOR
-                | CSS_COUNTER_STYLE_AT_RULE_DECLARATOR
-                | CSS_FONT_FACE_AT_RULE_DECLARATOR
-                | CSS_FONT_PALETTE_VALUES_AT_RULE_DECLARATOR
-                | CSS_MEDIA_AT_RULE_DECLARATOR
-                | CSS_POSITION_TRY_AT_RULE_DECLARATOR
-                | CSS_PROPERTY_AT_RULE_DECLARATOR
-                | CSS_SCOPE_AT_RULE_DECLARATOR
-                | CSS_STARTING_STYLE_AT_RULE_DECLARATOR
-                | CSS_SUPPORTS_AT_RULE_DECLARATOR
-                | CSS_VIEW_TRANSITION_AT_RULE_DECLARATOR
-        )
+        kind == TW_THEME_AT_RULE
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
-        let res = match syntax.kind() {
-            CSS_COLOR_PROFILE_AT_RULE_DECLARATOR => {
-                Self::CssColorProfileAtRuleDeclarator(CssColorProfileAtRuleDeclarator { syntax })
-            }
-            CSS_CONTAINER_AT_RULE_DECLARATOR => {
-                Self::CssContainerAtRuleDeclarator(CssContainerAtRuleDeclarator { syntax })
-            }
-            CSS_COUNTER_STYLE_AT_RULE_DECLARATOR => {
-                Self::CssCounterStyleAtRuleDeclarator(CssCounterStyleAtRuleDeclarator { syntax })
-            }
-            CSS_FONT_FACE_AT_RULE_DECLARATOR => {
-                Self::CssFontFaceAtRuleDeclarator(CssFontFaceAtRuleDeclarator { syntax })
-            }
-            CSS_FONT_PALETTE_VALUES_AT_RULE_DECLARATOR => {
-                Self::CssFontPaletteValuesAtRuleDeclarator(CssFontPaletteValuesAtRuleDeclarator {
-                    syntax,
-                })
-            }
-            CSS_MEDIA_AT_RULE_DECLARATOR => {
-                Self::CssMediaAtRuleDeclarator(CssMediaAtRuleDeclarator { syntax })
-            }
-            CSS_POSITION_TRY_AT_RULE_DECLARATOR => {
-                Self::CssPositionTryAtRuleDeclarator(CssPositionTryAtRuleDeclarator { syntax })
-            }
-            CSS_PROPERTY_AT_RULE_DECLARATOR => {
-                Self::CssPropertyAtRuleDeclarator(CssPropertyAtRuleDeclarator { syntax })
-            }
-            CSS_SCOPE_AT_RULE_DECLARATOR => {
-                Self::CssScopeAtRuleDeclarator(CssScopeAtRuleDeclarator { syntax })
-            }
-            CSS_STARTING_STYLE_AT_RULE_DECLARATOR => {
-                Self::CssStartingStyleAtRuleDeclarator(CssStartingStyleAtRuleDeclarator { syntax })
-            }
-            CSS_SUPPORTS_AT_RULE_DECLARATOR => {
-                Self::CssSupportsAtRuleDeclarator(CssSupportsAtRuleDeclarator { syntax })
-            }
-            CSS_VIEW_TRANSITION_AT_RULE_DECLARATOR => {
-                Self::CssViewTransitionAtRuleDeclarator(CssViewTransitionAtRuleDeclarator {
-                    syntax,
-                })
-            }
-            _ => return None,
-        };
-        Some(res)
+        if Self::can_cast(syntax.kind()) {
+            Some(Self { syntax })
+        } else {
+            None
+        }
     }
     fn syntax(&self) -> &SyntaxNode {
-        match self {
-            Self::CssColorProfileAtRuleDeclarator(it) => it.syntax(),
-            Self::CssContainerAtRuleDeclarator(it) => it.syntax(),
-            Self::CssCounterStyleAtRuleDeclarator(it) => it.syntax(),
-            Self::CssFontFaceAtRuleDeclarator(it) => it.syntax(),
-            Self::CssFontPaletteValuesAtRuleDeclarator(it) => it.syntax(),
-            Self::CssMediaAtRuleDeclarator(it) => it.syntax(),
-            Self::CssPositionTryAtRuleDeclarator(it) => it.syntax(),
-            Self::CssPropertyAtRuleDeclarator(it) => it.syntax(),
-            Self::CssScopeAtRuleDeclarator(it) => it.syntax(),
-            Self::CssStartingStyleAtRuleDeclarator(it) => it.syntax(),
-            Self::CssSupportsAtRuleDeclarator(it) => it.syntax(),
-            Self::CssViewTransitionAtRuleDeclarator(it) => it.syntax(),
-        }
+        &self.syntax
     }
     fn into_syntax(self) -> SyntaxNode {
-        match self {
-            Self::CssColorProfileAtRuleDeclarator(it) => it.into_syntax(),
-            Self::CssContainerAtRuleDeclarator(it) => it.into_syntax(),
-            Self::CssCounterStyleAtRuleDeclarator(it) => it.into_syntax(),
-            Self::CssFontFaceAtRuleDeclarator(it) => it.into_syntax(),
-            Self::CssFontPaletteValuesAtRuleDeclarator(it) => it.into_syntax(),
-            Self::CssMediaAtRuleDeclarator(it) => it.into_syntax(),
-            Self::CssPositionTryAtRuleDeclarator(it) => it.into_syntax(),
-            Self::CssPropertyAtRuleDeclarator(it) => it.into_syntax(),
-            Self::CssScopeAtRuleDeclarator(it) => it.into_syntax(),
-            Self::CssStartingStyleAtRuleDeclarator(it) => it.into_syntax(),
-            Self::CssSupportsAtRuleDeclarator(it) => it.into_syntax(),
-            Self::CssViewTransitionAtRuleDeclarator(it) => it.into_syntax(),
-        }
+        self.syntax
     }
 }
-impl std::fmt::Debug for AnyCssAtRuleDeclarator {
+impl std::fmt::Debug for TwThemeAtRule {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        match self {
-            Self::CssColorProfileAtRuleDeclarator(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssContainerAtRuleDeclarator(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssCounterStyleAtRuleDeclarator(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssFontFaceAtRuleDeclarator(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssFontPaletteValuesAtRuleDeclarator(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssMediaAtRuleDeclarator(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssPositionTryAtRuleDeclarator(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssPropertyAtRuleDeclarator(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssScopeAtRuleDeclarator(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssStartingStyleAtRuleDeclarator(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssSupportsAtRuleDeclarator(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssViewTransitionAtRuleDeclarator(it) => std::fmt::Debug::fmt(it, f),
-        }
-    }
-}
-impl From<AnyCssAtRuleDeclarator> for SyntaxNode {
-    fn from(n: AnyCssAtRuleDeclarator) -> Self {
-        match n {
-            AnyCssAtRuleDeclarator::CssColorProfileAtRuleDeclarator(it) => it.into_syntax(),
-            AnyCssAtRuleDeclarator::CssContainerAtRuleDeclarator(it) => it.into_syntax(),
-            AnyCssAtRuleDeclarator::CssCounterStyleAtRuleDeclarator(it) => it.into_syntax(),
-            AnyCssAtRuleDeclarator::CssFontFaceAtRuleDeclarator(it) => it.into_syntax(),
-            AnyCssAtRuleDeclarator::CssFontPaletteValuesAtRuleDeclarator(it) => it.into_syntax(),
-            AnyCssAtRuleDeclarator::CssMediaAtRuleDeclarator(it) => it.into_syntax(),
-            AnyCssAtRuleDeclarator::CssPositionTryAtRuleDeclarator(it) => it.into_syntax(),
-            AnyCssAtRuleDeclarator::CssPropertyAtRuleDeclarator(it) => it.into_syntax(),
-            AnyCssAtRuleDeclarator::CssScopeAtRuleDeclarator(it) => it.into_syntax(),
-            AnyCssAtRuleDeclarator::CssStartingStyleAtRuleDeclarator(it) => it.into_syntax(),
-            AnyCssAtRuleDeclarator::CssSupportsAtRuleDeclarator(it) => it.into_syntax(),
-            AnyCssAtRuleDeclarator::CssViewTransitionAtRuleDeclarator(it) => it.into_syntax(),
-        }
-    }
-}
-impl From<AnyCssAtRuleDeclarator> for SyntaxElement {
-    fn from(n: AnyCssAtRuleDeclarator) -> Self {
-        let node: SyntaxNode = n.into();
-        node.into()
+        thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
+        let current_depth = DEPTH.get();
+        let result = if current_depth < 16 {
+            DEPTH.set(current_depth + 1);
+            f.debug_struct("TwThemeAtRule")
+                .field(
+                    "theme_token",
+                    &support::DebugSyntaxResult(self.theme_token()),
+                )
+                .field("name", &support::DebugOptionalElement(self.name()))
+                .field("block", &support::DebugSyntaxResult(self.block()))
+                .finish()
+        } else {
+            f.debug_struct("TwThemeAtRule").finish()
+        };
+        DEPTH.set(current_depth);
+        result
     }
 }
-impl From<CssIdentifier> for AnyCssAttributeMatcherValue {
-    fn from(node: CssIdentifier) -> Self {
-        Self::CssIdentifier(node)
+impl From<TwThemeAtRule> for SyntaxNode {
+    fn from(n: TwThemeAtRule) -> Self {
+        n.syntax
     }
 }
-impl From<CssString> for AnyCssAttributeMatcherValue {
-    fn from(node: CssString) -> Self {
-        Self::CssString(node)
+impl From<TwThemeAtRule> for SyntaxElement {
+    fn from(n: TwThemeAtRule) -> Self {
+        n.syntax.into()
     }
 }
-impl AstNode for AnyCssAttributeMatcherValue {
+impl AstNode for TwUtilityAtRule {
     type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> = CssIdentifier::KIND_SET.union(CssString::KIND_SET);
+    const KIND_SET: SyntaxKindSet<Language> =
+        SyntaxKindSet::from_raw(RawSyntaxKind(TW_UTILITY_AT_RULE as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        matches!(kind, CSS_IDENTIFIER | CSS_STRING)
+        kind == TW_UTILITY_AT_RULE
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
-        let res = match syntax.kind() {
-            CSS_IDENTIFIER => Self::CssIdentifier(CssIdentifier { syntax }),
-            CSS_STRING => Self::CssString(CssString { syntax }),
-            _ => return None,
-        };
-        Some(res)
+        if Self::can_cast(syntax.kind()) {
+            Some(Self { syntax })
+        } else {
+            None
+        }
     }
     fn syntax(&self) -> &SyntaxNode {
-        match self {
-            Self::CssIdentifier(it) => it.syntax(),
-            Self::CssString(it) => it.syntax(),
-        }
+        &self.syntax
     }
     fn into_syntax(self) -> SyntaxNode {
-        match self {
-            Self::CssIdentifier(it) => it.into_syntax(),
-            Self::CssString(it) => it.into_syntax(),
-        }
+        self.syntax
     }
 }
-impl std::fmt::Debug for AnyCssAttributeMatcherValue {
+impl std::fmt::Debug for TwUtilityAtRule {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        match self {
-            Self::CssIdentifier(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssString(it) => std::fmt::Debug::fmt(it, f),
-        }
-    }
-}
-impl From<AnyCssAttributeMatcherValue> for SyntaxNode {
-    fn from(n: AnyCssAttributeMatcherValue) -> Self {
-        match n {
-            AnyCssAttributeMatcherValue::CssIdentifier(it) => it.into_syntax(),
-            AnyCssAttributeMatcherValue::CssString(it) => it.into_syntax(),
-        }
-    }
-}
-impl From<AnyCssAttributeMatcherValue> for SyntaxElement {
-    fn from(n: AnyCssAttributeMatcherValue) -> Self {
-        let node: SyntaxNode = n.into();
-        node.into()
+        thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
+        let current_depth = DEPTH.get();
+        let result = if current_depth < 16 {
+            DEPTH.set(current_depth + 1);
+            f.debug_struct("TwUtilityAtRule")
+                .field(
+                    "utility_token",
+                    &support::DebugSyntaxResult(self.utility_token()),
+                )
+                .field("name", &support::DebugSyntaxResult(self.name()))
+                .field("block", &support::DebugSyntaxResult(self.block()))
+                .finish()
+        } else {
+            f.debug_struct("TwUtilityAtRule").finish()
+        };
+        DEPTH.set(current_depth);
+        result
     }
 }
-impl From<CssIdentifier> for AnyCssComposesImportSource {
-    fn from(node: CssIdentifier) -> Self {
-        Self::CssIdentifier(node)
+impl From<TwUtilityAtRule> for SyntaxNode {
+    fn from(n: TwUtilityAtRule) -> Self {
+        n.syntax
     }
 }
-impl From<CssString> for AnyCssComposesImportSource {
-    fn from(node: CssString) -> Self {
-        Self::CssString(node)
+impl From<TwUtilityAtRule> for SyntaxElement {
+    fn from(n: TwUtilityAtRule) -> Self {
+        n.syntax.into()
     }
 }
-impl AstNode for AnyCssComposesImportSource {
+impl AstNode for TwValueThemeReference {
     type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> = CssIdentifier::KIND_SET.union(CssString::KIND_SET);
+    const KIND_SET: SyntaxKindSet<Language> =
+        SyntaxKindSet::from_raw(RawSyntaxKind(TW_VALUE_THEME_REFERENCE as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        matches!(kind, CSS_IDENTIFIER | CSS_STRING)
+        kind == TW_VALUE_THEME_REFERENCE
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
-        let res = match syntax.kind() {
-            CSS_IDENTIFIER => Self::CssIdentifier(CssIdentifier { syntax }),
-            CSS_STRING => Self::CssString(CssString { syntax }),
-            _ => return None,
-        };
-        Some(res)
+        if Self::can_cast(syntax.kind()) {
+            Some(Self { syntax })
+        } else {
+            None
+        }
     }
     fn syntax(&self) -> &SyntaxNode {
-        match self {
-            Self::CssIdentifier(it) => it.syntax(),
-            Self::CssString(it) => it.syntax(),
-        }
+        &self.syntax
     }
     fn into_syntax(self) -> SyntaxNode {
-        match self {
-            Self::CssIdentifier(it) => it.into_syntax(),
-            Self::CssString(it) => it.into_syntax(),
-        }
+        self.syntax
     }
 }
-impl std::fmt::Debug for AnyCssComposesImportSource {
+impl std::fmt::Debug for TwValueThemeReference {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        match self {
-            Self::CssIdentifier(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssString(it) => std::fmt::Debug::fmt(it, f),
-        }
-    }
-}
-impl From<AnyCssComposesImportSource> for SyntaxNode {
-    fn from(n: AnyCssComposesImportSource) -> Self {
-        match n {
-            AnyCssComposesImportSource::CssIdentifier(it) => it.into_syntax(),
-            AnyCssComposesImportSource::CssString(it) => it.into_syntax(),
-        }
-    }
-}
-impl From<AnyCssComposesImportSource> for SyntaxElement {
-    fn from(n: AnyCssComposesImportSource) -> Self {
-        let node: SyntaxNode = n.into();
-        node.into()
+        thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
+        let current_depth = DEPTH.get();
+        let result = if current_depth < 16 {
+            DEPTH.set(current_depth + 1);
+            f.debug_struct("TwValueThemeReference")
+                .field("reference", &support::DebugSyntaxResult(self.reference()))
+                .field(
+                    "minus_token",
+                    &support::DebugOptionalElement(self.minus_token()),
+                )
+                .field("star_token", &support::DebugSyntaxResult(self.star_token()))
+                .finish()
+        } else {
+            f.debug_struct("TwValueThemeReference").finish()
+        };
+        DEPTH.set(current_depth);
+        result
     }
 }
-impl From<CssBogusSelector> for AnyCssCompoundSelector {
-    fn from(node: CssBogusSelector) -> Self {
-        Self::CssBogusSelector(node)
+impl From<TwValueThemeReference> for SyntaxNode {
+    fn from(n: TwValueThemeReference) -> Self {
+        n.syntax
     }
 }
-impl From<CssCompoundSelector> for AnyCssCompoundSelector {
-    fn from(node: CssCompoundSelector) -> Self {
-        Self::CssCompoundSelector(node)
+impl From<TwValueThemeReference> for SyntaxElement {
+    fn from(n: TwValueThemeReference) -> Self {
+        n.syntax.into()
     }
 }
-impl AstNode for AnyCssCompoundSelector {
+impl AstNode for TwVariantAtRule {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        CssBogusSelector::KIND_SET.union(CssCompoundSelector::KIND_SET);
+        SyntaxKindSet::from_raw(RawSyntaxKind(TW_VARIANT_AT_RULE as u16));
     fn can_cast(kind: SyntaxKind) -> bool {
-        matches!(kind, CSS_BOGUS_SELECTOR | CSS_COMPOUND_SELECTOR)
+        kind == TW_VARIANT_AT_RULE
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
-        let res = match syntax.kind() {
-            CSS_BOGUS_SELECTOR => Self::CssBogusSelector(CssBogusSelector { syntax }),
-            CSS_COMPOUND_SELECTOR => Self::CssCompoundSelector(CssCompoundSelector { syntax }),
-            _ => return None,
-        };
-        Some(res)
+        if Self::can_cast(syntax.kind()) {
+            Some(Self { syntax })
+        } else {
+            None
+        }
     }
     fn syntax(&self) -> &SyntaxNode {
-        match self {
-            Self::CssBogusSelector(it) => it.syntax(),
-            Self::CssCompoundSelector(it) => it.syntax(),
-        }
+        &self.syntax
     }
     fn into_syntax(self) -> SyntaxNode {
-        match self {
-            Self::CssBogusSelector(it) => it.into_syntax(),
-            Self::CssCompoundSelector(it) => it.into_syntax(),
-        }
+        self.syntax
     }
 }
-impl std::fmt::Debug for AnyCssCompoundSelector {
+impl std::fmt::Debug for TwVariantAtRule {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        match self {
-            Self::CssBogusSelector(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssCompoundSelector(it) => std::fmt::Debug::fmt(it, f),
-        }
+        thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
+        let current_depth = DEPTH.get();
+        let result = if current_depth < 16 {
+            DEPTH.set(current_depth + 1);
+            f.debug_struct("TwVariantAtRule")
+                .field(
+                    "variant_token",
+                    &support::DebugSyntaxResult(self.variant_token()),
+                )
+                .field("name", &support::DebugSyntaxResult(self.name()))
+                .field("block", &support::DebugSyntaxResult(self.block()))
+                .finish()
+        } else {
+            f.debug_struct("TwVariantAtRule").finish()
+        };
+        DEPTH.set(current_depth);
+        result
     }
 }
-impl From<AnyCssCompoundSelector> for SyntaxNode {
-    fn from(n: AnyCssCompoundSelector) -> Self {
-        match n {
-            AnyCssCompoundSelector::CssBogusSelector(it) => it.into_syntax(),
-            AnyCssCompoundSelector::CssCompoundSelector(it) => it.into_syntax(),
-        }
+impl From<TwVariantAtRule> for SyntaxNode {
+    fn from(n: TwVariantAtRule) -> Self {
+        n.syntax
+    }
+}
+impl From<TwVariantAtRule> for SyntaxElement {
+    fn from(n: TwVariantAtRule) -> Self {
+        n.syntax.into()
+    }
+}
+impl From<CssBogusAtRule> for AnyCssAtRule {
+    fn from(node: CssBogusAtRule) -> Self {
+        Self::CssBogusAtRule(node)
+    }
+}
+impl From<CssCharsetAtRule> for AnyCssAtRule {
+    fn from(node: CssCharsetAtRule) -> Self {
+        Self::CssCharsetAtRule(node)
+    }
+}
+impl From<CssColorProfileAtRule> for AnyCssAtRule {
+    fn from(node: CssColorProfileAtRule) -> Self {
+        Self::CssColorProfileAtRule(node)
+    }
+}
+impl From<CssContainerAtRule> for AnyCssAtRule {
+    fn from(node: CssContainerAtRule) -> Self {
+        Self::CssContainerAtRule(node)
     }
 }
-impl From<AnyCssCompoundSelector> for SyntaxElement {
-    fn from(n: AnyCssCompoundSelector) -> Self {
-        let node: SyntaxNode = n.into();
-        node.into()
+impl From<CssCounterStyleAtRule> for AnyCssAtRule {
+    fn from(node: CssCounterStyleAtRule) -> Self {
+        Self::CssCounterStyleAtRule(node)
     }
 }
-impl From<CssBogusBlock> for AnyCssConditionalBlock {
-    fn from(node: CssBogusBlock) -> Self {
-        Self::CssBogusBlock(node)
+impl From<CssDocumentAtRule> for AnyCssAtRule {
+    fn from(node: CssDocumentAtRule) -> Self {
+        Self::CssDocumentAtRule(node)
     }
 }
-impl From<CssDeclarationOrRuleBlock> for AnyCssConditionalBlock {
-    fn from(node: CssDeclarationOrRuleBlock) -> Self {
-        Self::CssDeclarationOrRuleBlock(node)
+impl From<CssFontFaceAtRule> for AnyCssAtRule {
+    fn from(node: CssFontFaceAtRule) -> Self {
+        Self::CssFontFaceAtRule(node)
     }
 }
-impl From<CssRuleBlock> for AnyCssConditionalBlock {
-    fn from(node: CssRuleBlock) -> Self {
-        Self::CssRuleBlock(node)
+impl From<CssFontFeatureValuesAtRule> for AnyCssAtRule {
+    fn from(node: CssFontFeatureValuesAtRule) -> Self {
+        Self::CssFontFeatureValuesAtRule(node)
     }
 }
-impl AstNode for AnyCssConditionalBlock {
-    type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> = CssBogusBlock::KIND_SET
-        .union(CssDeclarationOrRuleBlock::KIND_SET)
-        .union(CssRuleBlock::KIND_SET);
-    fn can_cast(kind: SyntaxKind) -> bool {
-        matches!(
-            kind,
-            CSS_BOGUS_BLOCK | CSS_DECLARATION_OR_RULE_BLOCK | CSS_RULE_BLOCK
-        )
+impl From<CssFontPaletteValuesAtRule> for AnyCssAtRule {
+    fn from(node: CssFontPaletteValuesAtRule) -> Self {
+        Self::CssFontPaletteValuesAtRule(node)
     }
-    fn cast(syntax: SyntaxNode) -> Option<Self> {
-        let res = match syntax.kind() {
-            CSS_BOGUS_BLOCK => Self::CssBogusBlock(CssBogusBlock { syntax }),
-            CSS_DECLARATION_OR_RULE_BLOCK => {
-                Self::CssDeclarationOrRuleBlock(CssDeclarationOrRuleBlock { syntax })
-            }
-            CSS_RULE_BLOCK => Self::CssRuleBlock(CssRuleBlock { syntax }),
-            _ => return None,
-        };
-        Some(res)
+}
+impl From<CssImportAtRule> for AnyCssAtRule {
+    fn from(node: CssImportAtRule) -> Self {
+        Self::CssImportAtRule(node)
     }
-    fn syntax(&self) -> &SyntaxNode {
-        match self {
-            Self::CssBogusBlock(it) => it.syntax(),
-            Self::CssDeclarationOrRuleBlock(it) => it.syntax(),
-            Self::CssRuleBlock(it) => it.syntax(),
-        }
+}
+impl From<CssKeyframesAtRule> for AnyCssAtRule {
+    fn from(node: CssKeyframesAtRule) -> Self {
+        Self::CssKeyframesAtRule(node)
     }
-    fn into_syntax(self) -> SyntaxNode {
-        match self {
-            Self::CssBogusBlock(it) => it.into_syntax(),
-            Self::CssDeclarationOrRuleBlock(it) => it.into_syntax(),
-            Self::CssRuleBlock(it) => it.into_syntax(),
-        }
+}
+impl From<CssLayerAtRule> for AnyCssAtRule {
+    fn from(node: CssLayerAtRule) -> Self {
+        Self::CssLayerAtRule(node)
     }
 }
-impl std::fmt::Debug for AnyCssConditionalBlock {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        match self {
-            Self::CssBogusBlock(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssDeclarationOrRuleBlock(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssRuleBlock(it) => std::fmt::Debug::fmt(it, f),
-        }
+impl From<CssMediaAtRule> for AnyCssAtRule {
+    fn from(node: CssMediaAtRule) -> Self {
+        Self::CssMediaAtRule(node)
     }
 }
-impl From<AnyCssConditionalBlock> for SyntaxNode {
-    fn from(n: AnyCssConditionalBlock) -> Self {
-        match n {
-            AnyCssConditionalBlock::CssBogusBlock(it) => it.into_syntax(),
-            AnyCssConditionalBlock::CssDeclarationOrRuleBlock(it) => it.into_syntax(),
-            AnyCssConditionalBlock::CssRuleBlock(it) => it.into_syntax(),
-        }
+impl From<CssNamespaceAtRule> for AnyCssAtRule {
+    fn from(node: CssNamespaceAtRule) -> Self {
+        Self::CssNamespaceAtRule(node)
     }
 }
-impl From<AnyCssConditionalBlock> for SyntaxElement {
-    fn from(n: AnyCssConditionalBlock) -> Self {
-        let node: SyntaxNode = n.into();
-        node.into()
+impl From<CssPageAtRule> for AnyCssAtRule {
+    fn from(node: CssPageAtRule) -> Self {
+        Self::CssPageAtRule(node)
     }
 }
-impl From<CssContainerAndQuery> for AnyCssContainerAndCombinableQuery {
-    fn from(node: CssContainerAndQuery) -> Self {
-        Self::CssContainerAndQuery(node)
+impl From<CssPositionTryAtRule> for AnyCssAtRule {
+    fn from(node: CssPositionTryAtRule) -> Self {
+        Self::CssPositionTryAtRule(node)
     }
 }
-impl AstNode for AnyCssContainerAndCombinableQuery {
-    type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> =
-        AnyCssContainerQueryInParens::KIND_SET.union(CssContainerAndQuery::KIND_SET);
-    fn can_cast(kind: SyntaxKind) -> bool {
-        match kind {
-            CSS_CONTAINER_AND_QUERY => true,
-            k if AnyCssContainerQueryInParens::can_cast(k) => true,
-            _ => false,
-        }
+impl From<CssPropertyAtRule> for AnyCssAtRule {
+    fn from(node: CssPropertyAtRule) -> Self {
+        Self::CssPropertyAtRule(node)
     }
-    fn cast(syntax: SyntaxNode) -> Option<Self> {
-        let res = match syntax.kind() {
-            CSS_CONTAINER_AND_QUERY => Self::CssContainerAndQuery(CssContainerAndQuery { syntax }),
-            _ => {
-                if let Some(any_css_container_query_in_parens) =
-                    AnyCssContainerQueryInParens::cast(syntax)
-                {
-                    return Some(Self::AnyCssContainerQueryInParens(
-                        any_css_container_query_in_parens,
-                    ));
-                }
-                return None;
-            }
-        };
-        Some(res)
+}
+impl From<CssScopeAtRule> for AnyCssAtRule {
+    fn from(node: CssScopeAtRule) -> Self {
+        Self::CssScopeAtRule(node)
     }
-    fn syntax(&self) -> &SyntaxNode {
-        match self {
-            Self::CssContainerAndQuery(it) => it.syntax(),
-            Self::AnyCssContainerQueryInParens(it) => it.syntax(),
-        }
+}
+impl From<CssStartingStyleAtRule> for AnyCssAtRule {
+    fn from(node: CssStartingStyleAtRule) -> Self {
+        Self::CssStartingStyleAtRule(node)
     }
-    fn into_syntax(self) -> SyntaxNode {
-        match self {
-            Self::CssContainerAndQuery(it) => it.into_syntax(),
-            Self::AnyCssContainerQueryInParens(it) => it.into_syntax(),
-        }
+}
+impl From<CssSupportsAtRule> for AnyCssAtRule {
+    fn from(node: CssSupportsAtRule) -> Self {
+        Self::CssSupportsAtRule(node)
     }
 }
-impl std::fmt::Debug for AnyCssContainerAndCombinableQuery {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        match self {
-            Self::AnyCssContainerQueryInParens(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssContainerAndQuery(it) => std::fmt::Debug::fmt(it, f),
-        }
+impl From<CssUnknownBlockAtRule> for AnyCssAtRule {
+    fn from(node: CssUnknownBlockAtRule) -> Self {
+        Self::CssUnknownBlockAtRule(node)
     }
 }
-impl From<AnyCssContainerAndCombinableQuery> for SyntaxNode {
-    fn from(n: AnyCssContainerAndCombinableQuery) -> Self {
-        match n {
-            AnyCssContainerAndCombinableQuery::AnyCssContainerQueryInParens(it) => it.into_syntax(),
-            AnyCssContainerAndCombinableQuery::CssContainerAndQuery(it) => it.into_syntax(),
-        }
+impl From<CssUnknownValueAtRule> for AnyCssAtRule {
+    fn from(node: CssUnknownValueAtRule) -> Self {
+        Self::CssUnknownValueAtRule(node)
     }
 }
-impl From<AnyCssContainerAndCombinableQuery> for SyntaxElement {
-    fn from(n: AnyCssContainerAndCombinableQuery) -> Self {
-        let node: SyntaxNode = n.into();
-        node.into()
+impl From<CssValueAtRule> for AnyCssAtRule {
+    fn from(node: CssValueAtRule) -> Self {
+        Self::CssValueAtRule(node)
     }
 }
-impl From<CssContainerOrQuery> for AnyCssContainerOrCombinableQuery {
-    fn from(node: CssContainerOrQuery) -> Self {
-        Self::CssContainerOrQuery(node)
+impl From<CssViewTransitionAtRule> for AnyCssAtRule {
+    fn from(node: CssViewTransitionAtRule) -> Self {
+        Self::CssViewTransitionAtRule(node)
     }
 }
-impl AstNode for AnyCssContainerOrCombinableQuery {
-    type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> =
-        AnyCssContainerQueryInParens::KIND_SET.union(CssContainerOrQuery::KIND_SET);
-    fn can_cast(kind: SyntaxKind) -> bool {
-        match kind {
-            CSS_CONTAINER_OR_QUERY => true,
-            k if AnyCssContainerQueryInParens::can_cast(k) => true,
-            _ => false,
-        }
+impl From<TwApplyAtRule> for AnyCssAtRule {
+    fn from(node: TwApplyAtRule) -> Self {
+        Self::TwApplyAtRule(node)
     }
-    fn cast(syntax: SyntaxNode) -> Option<Self> {
-        let res = match syntax.kind() {
-            CSS_CONTAINER_OR_QUERY => Self::CssContainerOrQuery(CssContainerOrQuery { syntax }),
-            _ => {
-                if let Some(any_css_container_query_in_parens) =
-                    AnyCssContainerQueryInParens::cast(syntax)
-                {
-                    return Some(Self::AnyCssContainerQueryInParens(
-                        any_css_container_query_in_parens,
-                    ));
-                }
-                return None;
-            }
-        };
-        Some(res)
+}
+impl From<TwConfigAtRule> for AnyCssAtRule {
+    fn from(node: TwConfigAtRule) -> Self {
+        Self::TwConfigAtRule(node)
     }
-    fn syntax(&self) -> &SyntaxNode {
-        match self {
-            Self::CssContainerOrQuery(it) => it.syntax(),
-            Self::AnyCssContainerQueryInParens(it) => it.syntax(),
-        }
+}
+impl From<TwCustomVariantAtRule> for AnyCssAtRule {
+    fn from(node: TwCustomVariantAtRule) -> Self {
+        Self::TwCustomVariantAtRule(node)
     }
-    fn into_syntax(self) -> SyntaxNode {
-        match self {
-            Self::CssContainerOrQuery(it) => it.into_syntax(),
-            Self::AnyCssContainerQueryInParens(it) => it.into_syntax(),
-        }
+}
+impl From<TwPluginAtRule> for AnyCssAtRule {
+    fn from(node: TwPluginAtRule) -> Self {
+        Self::TwPluginAtRule(node)
     }
 }
-impl std::fmt::Debug for AnyCssContainerOrCombinableQuery {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        match self {
-            Self::AnyCssContainerQueryInParens(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssContainerOrQuery(it) => std::fmt::Debug::fmt(it, f),
-        }
+impl From<TwReferenceAtRule> for AnyCssAtRule {
+    fn from(node: TwReferenceAtRule) -> Self {
+        Self::TwReferenceAtRule(node)
     }
 }
-impl From<AnyCssContainerOrCombinableQuery> for SyntaxNode {
-    fn from(n: AnyCssContainerOrCombinableQuery) -> Self {
-        match n {
-            AnyCssContainerOrCombinableQuery::AnyCssContainerQueryInParens(it) => it.into_syntax(),
-            AnyCssContainerOrCombinableQuery::CssContainerOrQuery(it) => it.into_syntax(),
-        }
+impl From<TwSlotAtRule> for AnyCssAtRule {
+    fn from(node: TwSlotAtRule) -> Self {
+        Self::TwSlotAtRule(node)
     }
 }
-impl From<AnyCssContainerOrCombinableQuery> for SyntaxElement {
-    fn from(n: AnyCssContainerOrCombinableQuery) -> Self {
-        let node: SyntaxNode = n.into();
-        node.into()
+impl From<TwSourceAtRule> for AnyCssAtRule {
+    fn from(node: TwSourceAtRule) -> Self {
+        Self::TwSourceAtRule(node)
     }
 }
-impl From<CssContainerAndQuery> for AnyCssContainerQuery {
-    fn from(node: CssContainerAndQuery) -> Self {
-        Self::CssContainerAndQuery(node)
+impl From<TwThemeAtRule> for AnyCssAtRule {
+    fn from(node: TwThemeAtRule) -> Self {
+        Self::TwThemeAtRule(node)
     }
 }
-impl From<CssContainerNotQuery> for AnyCssContainerQuery {
-    fn from(node: CssContainerNotQuery) -> Self {
-        Self::CssContainerNotQuery(node)
+impl From<TwUtilityAtRule> for AnyCssAtRule {
+    fn from(node: TwUtilityAtRule) -> Self {
+        Self::TwUtilityAtRule(node)
     }
 }
-impl From<CssContainerOrQuery> for AnyCssContainerQuery {
-    fn from(node: CssContainerOrQuery) -> Self {
-        Self::CssContainerOrQuery(node)
+impl From<TwVariantAtRule> for AnyCssAtRule {
+    fn from(node: TwVariantAtRule) -> Self {
+        Self::TwVariantAtRule(node)
     }
 }
-impl AstNode for AnyCssContainerQuery {
+impl AstNode for AnyCssAtRule {
     type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> = AnyCssContainerQueryInParens::KIND_SET
-        .union(CssContainerAndQuery::KIND_SET)
-        .union(CssContainerNotQuery::KIND_SET)
-        .union(CssContainerOrQuery::KIND_SET);
+    const KIND_SET: SyntaxKindSet<Language> = CssBogusAtRule::KIND_SET
+        .union(CssCharsetAtRule::KIND_SET)
+        .union(CssColorProfileAtRule::KIND_SET)
+        .union(CssContainerAtRule::KIND_SET)
+        .union(CssCounterStyleAtRule::KIND_SET)
+        .union(CssDocumentAtRule::KIND_SET)
+        .union(CssFontFaceAtRule::KIND_SET)
+        .union(CssFontFeatureValuesAtRule::KIND_SET)
+        .union(CssFontPaletteValuesAtRule::KIND_SET)
+        .union(CssImportAtRule::KIND_SET)
+        .union(CssKeyframesAtRule::KIND_SET)
+        .union(CssLayerAtRule::KIND_SET)
+        .union(CssMediaAtRule::KIND_SET)
+        .union(CssNamespaceAtRule::KIND_SET)
+        .union(CssPageAtRule::KIND_SET)
+        .union(CssPositionTryAtRule::KIND_SET)
+        .union(CssPropertyAtRule::KIND_SET)
+        .union(CssScopeAtRule::KIND_SET)
+        .union(CssStartingStyleAtRule::KIND_SET)
+        .union(CssSupportsAtRule::KIND_SET)
+        .union(CssUnknownBlockAtRule::KIND_SET)
+        .union(CssUnknownValueAtRule::KIND_SET)
+        .union(CssValueAtRule::KIND_SET)
+        .union(CssViewTransitionAtRule::KIND_SET)
+        .union(TwApplyAtRule::KIND_SET)
+        .union(TwConfigAtRule::KIND_SET)
+        .union(TwCustomVariantAtRule::KIND_SET)
+        .union(TwPluginAtRule::KIND_SET)
+        .union(TwReferenceAtRule::KIND_SET)
+        .union(TwSlotAtRule::KIND_SET)
+        .union(TwSourceAtRule::KIND_SET)
+        .union(TwThemeAtRule::KIND_SET)
+        .union(TwUtilityAtRule::KIND_SET)
+        .union(TwVariantAtRule::KIND_SET);
     fn can_cast(kind: SyntaxKind) -> bool {
-        match kind {
-            CSS_CONTAINER_AND_QUERY | CSS_CONTAINER_NOT_QUERY | CSS_CONTAINER_OR_QUERY => true,
-            k if AnyCssContainerQueryInParens::can_cast(k) => true,
-            _ => false,
-        }
+        matches!(
+            kind,
+            CSS_BOGUS_AT_RULE
+                | CSS_CHARSET_AT_RULE
+                | CSS_COLOR_PROFILE_AT_RULE
+                | CSS_CONTAINER_AT_RULE
+                | CSS_COUNTER_STYLE_AT_RULE
+                | CSS_DOCUMENT_AT_RULE
+                | CSS_FONT_FACE_AT_RULE
+                | CSS_FONT_FEATURE_VALUES_AT_RULE
+                | CSS_FONT_PALETTE_VALUES_AT_RULE
+                | CSS_IMPORT_AT_RULE
+                | CSS_KEYFRAMES_AT_RULE
+                | CSS_LAYER_AT_RULE
+                | CSS_MEDIA_AT_RULE
+                | CSS_NAMESPACE_AT_RULE
+                | CSS_PAGE_AT_RULE
+                | CSS_POSITION_TRY_AT_RULE
+                | CSS_PROPERTY_AT_RULE
+                | CSS_SCOPE_AT_RULE
+                | CSS_STARTING_STYLE_AT_RULE
+                | CSS_SUPPORTS_AT_RULE
+                | CSS_UNKNOWN_BLOCK_AT_RULE
+                | CSS_UNKNOWN_VALUE_AT_RULE
+                | CSS_VALUE_AT_RULE
+                | CSS_VIEW_TRANSITION_AT_RULE
+                | TW_APPLY_AT_RULE
+                | TW_CONFIG_AT_RULE
+                | TW_CUSTOM_VARIANT_AT_RULE
+                | TW_PLUGIN_AT_RULE
+                | TW_REFERENCE_AT_RULE
+                | TW_SLOT_AT_RULE
+                | TW_SOURCE_AT_RULE
+                | TW_THEME_AT_RULE
+                | TW_UTILITY_AT_RULE
+                | TW_VARIANT_AT_RULE
+        )
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         let res = match syntax.kind() {
-            CSS_CONTAINER_AND_QUERY => Self::CssContainerAndQuery(CssContainerAndQuery { syntax }),
-            CSS_CONTAINER_NOT_QUERY => Self::CssContainerNotQuery(CssContainerNotQuery { syntax }),
-            CSS_CONTAINER_OR_QUERY => Self::CssContainerOrQuery(CssContainerOrQuery { syntax }),
-            _ => {
-                if let Some(any_css_container_query_in_parens) =
-                    AnyCssContainerQueryInParens::cast(syntax)
-                {
-                    return Some(Self::AnyCssContainerQueryInParens(
-                        any_css_container_query_in_parens,
-                    ));
-                }
-                return None;
+            CSS_BOGUS_AT_RULE => Self::CssBogusAtRule(CssBogusAtRule { syntax }),
+            CSS_CHARSET_AT_RULE => Self::CssCharsetAtRule(CssCharsetAtRule { syntax }),
+            CSS_COLOR_PROFILE_AT_RULE => {
+                Self::CssColorProfileAtRule(CssColorProfileAtRule { syntax })
+            }
+            CSS_CONTAINER_AT_RULE => Self::CssContainerAtRule(CssContainerAtRule { syntax }),
+            CSS_COUNTER_STYLE_AT_RULE => {
+                Self::CssCounterStyleAtRule(CssCounterStyleAtRule { syntax })
+            }
+            CSS_DOCUMENT_AT_RULE => Self::CssDocumentAtRule(CssDocumentAtRule { syntax }),
+            CSS_FONT_FACE_AT_RULE => Self::CssFontFaceAtRule(CssFontFaceAtRule { syntax }),
+            CSS_FONT_FEATURE_VALUES_AT_RULE => {
+                Self::CssFontFeatureValuesAtRule(CssFontFeatureValuesAtRule { syntax })
+            }
+            CSS_FONT_PALETTE_VALUES_AT_RULE => {
+                Self::CssFontPaletteValuesAtRule(CssFontPaletteValuesAtRule { syntax })
+            }
+            CSS_IMPORT_AT_RULE => Self::CssImportAtRule(CssImportAtRule { syntax }),
+            CSS_KEYFRAMES_AT_RULE => Self::CssKeyframesAtRule(CssKeyframesAtRule { syntax }),
+            CSS_LAYER_AT_RULE => Self::CssLayerAtRule(CssLayerAtRule { syntax }),
+            CSS_MEDIA_AT_RULE => Self::CssMediaAtRule(CssMediaAtRule { syntax }),
+            CSS_NAMESPACE_AT_RULE => Self::CssNamespaceAtRule(CssNamespaceAtRule { syntax }),
+            CSS_PAGE_AT_RULE => Self::CssPageAtRule(CssPageAtRule { syntax }),
+            CSS_POSITION_TRY_AT_RULE => Self::CssPositionTryAtRule(CssPositionTryAtRule { syntax }),
+            CSS_PROPERTY_AT_RULE => Self::CssPropertyAtRule(CssPropertyAtRule { syntax }),
+            CSS_SCOPE_AT_RULE => Self::CssScopeAtRule(CssScopeAtRule { syntax }),
+            CSS_STARTING_STYLE_AT_RULE => {
+                Self::CssStartingStyleAtRule(CssStartingStyleAtRule { syntax })
+            }
+            CSS_SUPPORTS_AT_RULE => Self::CssSupportsAtRule(CssSupportsAtRule { syntax }),
+            CSS_UNKNOWN_BLOCK_AT_RULE => {
+                Self::CssUnknownBlockAtRule(CssUnknownBlockAtRule { syntax })
+            }
+            CSS_UNKNOWN_VALUE_AT_RULE => {
+                Self::CssUnknownValueAtRule(CssUnknownValueAtRule { syntax })
+            }
+            CSS_VALUE_AT_RULE => Self::CssValueAtRule(CssValueAtRule { syntax }),
+            CSS_VIEW_TRANSITION_AT_RULE => {
+                Self::CssViewTransitionAtRule(CssViewTransitionAtRule { syntax })
             }
+            TW_APPLY_AT_RULE => Self::TwApplyAtRule(TwApplyAtRule { syntax }),
+            TW_CONFIG_AT_RULE => Self::TwConfigAtRule(TwConfigAtRule { syntax }),
+            TW_CUSTOM_VARIANT_AT_RULE => {
+                Self::TwCustomVariantAtRule(TwCustomVariantAtRule { syntax })
+            }
+            TW_PLUGIN_AT_RULE => Self::TwPluginAtRule(TwPluginAtRule { syntax }),
+            TW_REFERENCE_AT_RULE => Self::TwReferenceAtRule(TwReferenceAtRule { syntax }),
+            TW_SLOT_AT_RULE => Self::TwSlotAtRule(TwSlotAtRule { syntax }),
+            TW_SOURCE_AT_RULE => Self::TwSourceAtRule(TwSourceAtRule { syntax }),
+            TW_THEME_AT_RULE => Self::TwThemeAtRule(TwThemeAtRule { syntax }),
+            TW_UTILITY_AT_RULE => Self::TwUtilityAtRule(TwUtilityAtRule { syntax }),
+            TW_VARIANT_AT_RULE => Self::TwVariantAtRule(TwVariantAtRule { syntax }),
+            _ => return None,
         };
         Some(res)
     }
     fn syntax(&self) -> &SyntaxNode {
         match self {
-            Self::CssContainerAndQuery(it) => it.syntax(),
-            Self::CssContainerNotQuery(it) => it.syntax(),
-            Self::CssContainerOrQuery(it) => it.syntax(),
-            Self::AnyCssContainerQueryInParens(it) => it.syntax(),
+            Self::CssBogusAtRule(it) => it.syntax(),
+            Self::CssCharsetAtRule(it) => it.syntax(),
+            Self::CssColorProfileAtRule(it) => it.syntax(),
+            Self::CssContainerAtRule(it) => it.syntax(),
+            Self::CssCounterStyleAtRule(it) => it.syntax(),
+            Self::CssDocumentAtRule(it) => it.syntax(),
+            Self::CssFontFaceAtRule(it) => it.syntax(),
+            Self::CssFontFeatureValuesAtRule(it) => it.syntax(),
+            Self::CssFontPaletteValuesAtRule(it) => it.syntax(),
+            Self::CssImportAtRule(it) => it.syntax(),
+            Self::CssKeyframesAtRule(it) => it.syntax(),
+            Self::CssLayerAtRule(it) => it.syntax(),
+            Self::CssMediaAtRule(it) => it.syntax(),
+            Self::CssNamespaceAtRule(it) => it.syntax(),
+            Self::CssPageAtRule(it) => it.syntax(),
+            Self::CssPositionTryAtRule(it) => it.syntax(),
+            Self::CssPropertyAtRule(it) => it.syntax(),
+            Self::CssScopeAtRule(it) => it.syntax(),
+            Self::CssStartingStyleAtRule(it) => it.syntax(),
+            Self::CssSupportsAtRule(it) => it.syntax(),
+            Self::CssUnknownBlockAtRule(it) => it.syntax(),
+            Self::CssUnknownValueAtRule(it) => it.syntax(),
+            Self::CssValueAtRule(it) => it.syntax(),
+            Self::CssViewTransitionAtRule(it) => it.syntax(),
+            Self::TwApplyAtRule(it) => it.syntax(),
+            Self::TwConfigAtRule(it) => it.syntax(),
+            Self::TwCustomVariantAtRule(it) => it.syntax(),
+            Self::TwPluginAtRule(it) => it.syntax(),
+            Self::TwReferenceAtRule(it) => it.syntax(),
+            Self::TwSlotAtRule(it) => it.syntax(),
+            Self::TwSourceAtRule(it) => it.syntax(),
+            Self::TwThemeAtRule(it) => it.syntax(),
+            Self::TwUtilityAtRule(it) => it.syntax(),
+            Self::TwVariantAtRule(it) => it.syntax(),
         }
     }
     fn into_syntax(self) -> SyntaxNode {
         match self {
-            Self::CssContainerAndQuery(it) => it.into_syntax(),
-            Self::CssContainerNotQuery(it) => it.into_syntax(),
-            Self::CssContainerOrQuery(it) => it.into_syntax(),
-            Self::AnyCssContainerQueryInParens(it) => it.into_syntax(),
+            Self::CssBogusAtRule(it) => it.into_syntax(),
+            Self::CssCharsetAtRule(it) => it.into_syntax(),
+            Self::CssColorProfileAtRule(it) => it.into_syntax(),
+            Self::CssContainerAtRule(it) => it.into_syntax(),
+            Self::CssCounterStyleAtRule(it) => it.into_syntax(),
+            Self::CssDocumentAtRule(it) => it.into_syntax(),
+            Self::CssFontFaceAtRule(it) => it.into_syntax(),
+            Self::CssFontFeatureValuesAtRule(it) => it.into_syntax(),
+            Self::CssFontPaletteValuesAtRule(it) => it.into_syntax(),
+            Self::CssImportAtRule(it) => it.into_syntax(),
+            Self::CssKeyframesAtRule(it) => it.into_syntax(),
+            Self::CssLayerAtRule(it) => it.into_syntax(),
+            Self::CssMediaAtRule(it) => it.into_syntax(),
+            Self::CssNamespaceAtRule(it) => it.into_syntax(),
+            Self::CssPageAtRule(it) => it.into_syntax(),
+            Self::CssPositionTryAtRule(it) => it.into_syntax(),
+            Self::CssPropertyAtRule(it) => it.into_syntax(),
+            Self::CssScopeAtRule(it) => it.into_syntax(),
+            Self::CssStartingStyleAtRule(it) => it.into_syntax(),
+            Self::CssSupportsAtRule(it) => it.into_syntax(),
+            Self::CssUnknownBlockAtRule(it) => it.into_syntax(),
+            Self::CssUnknownValueAtRule(it) => it.into_syntax(),
+            Self::CssValueAtRule(it) => it.into_syntax(),
+            Self::CssViewTransitionAtRule(it) => it.into_syntax(),
+            Self::TwApplyAtRule(it) => it.into_syntax(),
+            Self::TwConfigAtRule(it) => it.into_syntax(),
+            Self::TwCustomVariantAtRule(it) => it.into_syntax(),
+            Self::TwPluginAtRule(it) => it.into_syntax(),
+            Self::TwReferenceAtRule(it) => it.into_syntax(),
+            Self::TwSlotAtRule(it) => it.into_syntax(),
+            Self::TwSourceAtRule(it) => it.into_syntax(),
+            Self::TwThemeAtRule(it) => it.into_syntax(),
+            Self::TwUtilityAtRule(it) => it.into_syntax(),
+            Self::TwVariantAtRule(it) => it.into_syntax(),
         }
     }
 }
-impl std::fmt::Debug for AnyCssContainerQuery {
+impl std::fmt::Debug for AnyCssAtRule {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        match self {
-            Self::AnyCssContainerQueryInParens(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssContainerAndQuery(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssContainerNotQuery(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssContainerOrQuery(it) => std::fmt::Debug::fmt(it, f),
+        match self {
+            Self::CssBogusAtRule(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssCharsetAtRule(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssColorProfileAtRule(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssContainerAtRule(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssCounterStyleAtRule(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssDocumentAtRule(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssFontFaceAtRule(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssFontFeatureValuesAtRule(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssFontPaletteValuesAtRule(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssImportAtRule(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssKeyframesAtRule(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssLayerAtRule(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssMediaAtRule(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssNamespaceAtRule(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssPageAtRule(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssPositionTryAtRule(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssPropertyAtRule(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssScopeAtRule(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssStartingStyleAtRule(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssSupportsAtRule(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssUnknownBlockAtRule(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssUnknownValueAtRule(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssValueAtRule(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssViewTransitionAtRule(it) => std::fmt::Debug::fmt(it, f),
+            Self::TwApplyAtRule(it) => std::fmt::Debug::fmt(it, f),
+            Self::TwConfigAtRule(it) => std::fmt::Debug::fmt(it, f),
+            Self::TwCustomVariantAtRule(it) => std::fmt::Debug::fmt(it, f),
+            Self::TwPluginAtRule(it) => std::fmt::Debug::fmt(it, f),
+            Self::TwReferenceAtRule(it) => std::fmt::Debug::fmt(it, f),
+            Self::TwSlotAtRule(it) => std::fmt::Debug::fmt(it, f),
+            Self::TwSourceAtRule(it) => std::fmt::Debug::fmt(it, f),
+            Self::TwThemeAtRule(it) => std::fmt::Debug::fmt(it, f),
+            Self::TwUtilityAtRule(it) => std::fmt::Debug::fmt(it, f),
+            Self::TwVariantAtRule(it) => std::fmt::Debug::fmt(it, f),
         }
     }
 }
-impl From<AnyCssContainerQuery> for SyntaxNode {
-    fn from(n: AnyCssContainerQuery) -> Self {
+impl From<AnyCssAtRule> for SyntaxNode {
+    fn from(n: AnyCssAtRule) -> Self {
         match n {
-            AnyCssContainerQuery::AnyCssContainerQueryInParens(it) => it.into_syntax(),
-            AnyCssContainerQuery::CssContainerAndQuery(it) => it.into_syntax(),
-            AnyCssContainerQuery::CssContainerNotQuery(it) => it.into_syntax(),
-            AnyCssContainerQuery::CssContainerOrQuery(it) => it.into_syntax(),
+            AnyCssAtRule::CssBogusAtRule(it) => it.into_syntax(),
+            AnyCssAtRule::CssCharsetAtRule(it) => it.into_syntax(),
+            AnyCssAtRule::CssColorProfileAtRule(it) => it.into_syntax(),
+            AnyCssAtRule::CssContainerAtRule(it) => it.into_syntax(),
+            AnyCssAtRule::CssCounterStyleAtRule(it) => it.into_syntax(),
+            AnyCssAtRule::CssDocumentAtRule(it) => it.into_syntax(),
+            AnyCssAtRule::CssFontFaceAtRule(it) => it.into_syntax(),
+            AnyCssAtRule::CssFontFeatureValuesAtRule(it) => it.into_syntax(),
+            AnyCssAtRule::CssFontPaletteValuesAtRule(it) => it.into_syntax(),
+            AnyCssAtRule::CssImportAtRule(it) => it.into_syntax(),
+            AnyCssAtRule::CssKeyframesAtRule(it) => it.into_syntax(),
+            AnyCssAtRule::CssLayerAtRule(it) => it.into_syntax(),
+            AnyCssAtRule::CssMediaAtRule(it) => it.into_syntax(),
+            AnyCssAtRule::CssNamespaceAtRule(it) => it.into_syntax(),
+            AnyCssAtRule::CssPageAtRule(it) => it.into_syntax(),
+            AnyCssAtRule::CssPositionTryAtRule(it) => it.into_syntax(),
+            AnyCssAtRule::CssPropertyAtRule(it) => it.into_syntax(),
+            AnyCssAtRule::CssScopeAtRule(it) => it.into_syntax(),
+            AnyCssAtRule::CssStartingStyleAtRule(it) => it.into_syntax(),
+            AnyCssAtRule::CssSupportsAtRule(it) => it.into_syntax(),
+            AnyCssAtRule::CssUnknownBlockAtRule(it) => it.into_syntax(),
+            AnyCssAtRule::CssUnknownValueAtRule(it) => it.into_syntax(),
+            AnyCssAtRule::CssValueAtRule(it) => it.into_syntax(),
+            AnyCssAtRule::CssViewTransitionAtRule(it) => it.into_syntax(),
+            AnyCssAtRule::TwApplyAtRule(it) => it.into_syntax(),
+            AnyCssAtRule::TwConfigAtRule(it) => it.into_syntax(),
+            AnyCssAtRule::TwCustomVariantAtRule(it) => it.into_syntax(),
+            AnyCssAtRule::TwPluginAtRule(it) => it.into_syntax(),
+            AnyCssAtRule::TwReferenceAtRule(it) => it.into_syntax(),
+            AnyCssAtRule::TwSlotAtRule(it) => it.into_syntax(),
+            AnyCssAtRule::TwSourceAtRule(it) => it.into_syntax(),
+            AnyCssAtRule::TwThemeAtRule(it) => it.into_syntax(),
+            AnyCssAtRule::TwUtilityAtRule(it) => it.into_syntax(),
+            AnyCssAtRule::TwVariantAtRule(it) => it.into_syntax(),
         }
     }
 }
-impl From<AnyCssContainerQuery> for SyntaxElement {
-    fn from(n: AnyCssContainerQuery) -> Self {
+impl From<AnyCssAtRule> for SyntaxElement {
+    fn from(n: AnyCssAtRule) -> Self {
         let node: SyntaxNode = n.into();
         node.into()
     }
 }
-impl From<CssContainerQueryInParens> for AnyCssContainerQueryInParens {
-    fn from(node: CssContainerQueryInParens) -> Self {
-        Self::CssContainerQueryInParens(node)
+impl From<CssColorProfileAtRuleDeclarator> for AnyCssAtRuleDeclarator {
+    fn from(node: CssColorProfileAtRuleDeclarator) -> Self {
+        Self::CssColorProfileAtRuleDeclarator(node)
     }
 }
-impl From<CssContainerSizeFeatureInParens> for AnyCssContainerQueryInParens {
-    fn from(node: CssContainerSizeFeatureInParens) -> Self {
-        Self::CssContainerSizeFeatureInParens(node)
+impl From<CssContainerAtRuleDeclarator> for AnyCssAtRuleDeclarator {
+    fn from(node: CssContainerAtRuleDeclarator) -> Self {
+        Self::CssContainerAtRuleDeclarator(node)
     }
 }
-impl From<CssContainerStyleQueryInParens> for AnyCssContainerQueryInParens {
-    fn from(node: CssContainerStyleQueryInParens) -> Self {
-        Self::CssContainerStyleQueryInParens(node)
+impl From<CssCounterStyleAtRuleDeclarator> for AnyCssAtRuleDeclarator {
+    fn from(node: CssCounterStyleAtRuleDeclarator) -> Self {
+        Self::CssCounterStyleAtRuleDeclarator(node)
     }
 }
-impl AstNode for AnyCssContainerQueryInParens {
-    type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> = CssContainerQueryInParens::KIND_SET
-        .union(CssContainerSizeFeatureInParens::KIND_SET)
-        .union(CssContainerStyleQueryInParens::KIND_SET);
-    fn can_cast(kind: SyntaxKind) -> bool {
-        matches!(
-            kind,
-            CSS_CONTAINER_QUERY_IN_PARENS
-                | CSS_CONTAINER_SIZE_FEATURE_IN_PARENS
-                | CSS_CONTAINER_STYLE_QUERY_IN_PARENS
-        )
+impl From<CssFontFaceAtRuleDeclarator> for AnyCssAtRuleDeclarator {
+    fn from(node: CssFontFaceAtRuleDeclarator) -> Self {
+        Self::CssFontFaceAtRuleDeclarator(node)
     }
-    fn cast(syntax: SyntaxNode) -> Option<Self> {
-        let res = match syntax.kind() {
-            CSS_CONTAINER_QUERY_IN_PARENS => {
-                Self::CssContainerQueryInParens(CssContainerQueryInParens { syntax })
-            }
-            CSS_CONTAINER_SIZE_FEATURE_IN_PARENS => {
-                Self::CssContainerSizeFeatureInParens(CssContainerSizeFeatureInParens { syntax })
-            }
-            CSS_CONTAINER_STYLE_QUERY_IN_PARENS => {
-                Self::CssContainerStyleQueryInParens(CssContainerStyleQueryInParens { syntax })
-            }
-            _ => return None,
-        };
-        Some(res)
+}
+impl From<CssFontPaletteValuesAtRuleDeclarator> for AnyCssAtRuleDeclarator {
+    fn from(node: CssFontPaletteValuesAtRuleDeclarator) -> Self {
+        Self::CssFontPaletteValuesAtRuleDeclarator(node)
     }
-    fn syntax(&self) -> &SyntaxNode {
-        match self {
-            Self::CssContainerQueryInParens(it) => it.syntax(),
-            Self::CssContainerSizeFeatureInParens(it) => it.syntax(),
-            Self::CssContainerStyleQueryInParens(it) => it.syntax(),
-        }
+}
+impl From<CssMediaAtRuleDeclarator> for AnyCssAtRuleDeclarator {
+    fn from(node: CssMediaAtRuleDeclarator) -> Self {
+        Self::CssMediaAtRuleDeclarator(node)
     }
-    fn into_syntax(self) -> SyntaxNode {
-        match self {
-            Self::CssContainerQueryInParens(it) => it.into_syntax(),
-            Self::CssContainerSizeFeatureInParens(it) => it.into_syntax(),
-            Self::CssContainerStyleQueryInParens(it) => it.into_syntax(),
-        }
+}
+impl From<CssPositionTryAtRuleDeclarator> for AnyCssAtRuleDeclarator {
+    fn from(node: CssPositionTryAtRuleDeclarator) -> Self {
+        Self::CssPositionTryAtRuleDeclarator(node)
     }
 }
-impl std::fmt::Debug for AnyCssContainerQueryInParens {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        match self {
-            Self::CssContainerQueryInParens(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssContainerSizeFeatureInParens(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssContainerStyleQueryInParens(it) => std::fmt::Debug::fmt(it, f),
-        }
+impl From<CssPropertyAtRuleDeclarator> for AnyCssAtRuleDeclarator {
+    fn from(node: CssPropertyAtRuleDeclarator) -> Self {
+        Self::CssPropertyAtRuleDeclarator(node)
     }
 }
-impl From<AnyCssContainerQueryInParens> for SyntaxNode {
-    fn from(n: AnyCssContainerQueryInParens) -> Self {
-        match n {
-            AnyCssContainerQueryInParens::CssContainerQueryInParens(it) => it.into_syntax(),
-            AnyCssContainerQueryInParens::CssContainerSizeFeatureInParens(it) => it.into_syntax(),
-            AnyCssContainerQueryInParens::CssContainerStyleQueryInParens(it) => it.into_syntax(),
-        }
+impl From<CssScopeAtRuleDeclarator> for AnyCssAtRuleDeclarator {
+    fn from(node: CssScopeAtRuleDeclarator) -> Self {
+        Self::CssScopeAtRuleDeclarator(node)
     }
 }
-impl From<AnyCssContainerQueryInParens> for SyntaxElement {
-    fn from(n: AnyCssContainerQueryInParens) -> Self {
-        let node: SyntaxNode = n.into();
-        node.into()
+impl From<CssStartingStyleAtRuleDeclarator> for AnyCssAtRuleDeclarator {
+    fn from(node: CssStartingStyleAtRuleDeclarator) -> Self {
+        Self::CssStartingStyleAtRuleDeclarator(node)
     }
 }
-impl From<CssContainerStyleAndQuery> for AnyCssContainerStyleAndCombinableQuery {
-    fn from(node: CssContainerStyleAndQuery) -> Self {
-        Self::CssContainerStyleAndQuery(node)
+impl From<CssSupportsAtRuleDeclarator> for AnyCssAtRuleDeclarator {
+    fn from(node: CssSupportsAtRuleDeclarator) -> Self {
+        Self::CssSupportsAtRuleDeclarator(node)
     }
 }
-impl From<CssContainerStyleInParens> for AnyCssContainerStyleAndCombinableQuery {
-    fn from(node: CssContainerStyleInParens) -> Self {
-        Self::CssContainerStyleInParens(node)
+impl From<CssViewTransitionAtRuleDeclarator> for AnyCssAtRuleDeclarator {
+    fn from(node: CssViewTransitionAtRuleDeclarator) -> Self {
+        Self::CssViewTransitionAtRuleDeclarator(node)
     }
 }
-impl AstNode for AnyCssContainerStyleAndCombinableQuery {
+impl AstNode for AnyCssAtRuleDeclarator {
     type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> =
-        CssContainerStyleAndQuery::KIND_SET.union(CssContainerStyleInParens::KIND_SET);
+    const KIND_SET: SyntaxKindSet<Language> = CssColorProfileAtRuleDeclarator::KIND_SET
+        .union(CssContainerAtRuleDeclarator::KIND_SET)
+        .union(CssCounterStyleAtRuleDeclarator::KIND_SET)
+        .union(CssFontFaceAtRuleDeclarator::KIND_SET)
+        .union(CssFontPaletteValuesAtRuleDeclarator::KIND_SET)
+        .union(CssMediaAtRuleDeclarator::KIND_SET)
+        .union(CssPositionTryAtRuleDeclarator::KIND_SET)
+        .union(CssPropertyAtRuleDeclarator::KIND_SET)
+        .union(CssScopeAtRuleDeclarator::KIND_SET)
+        .union(CssStartingStyleAtRuleDeclarator::KIND_SET)
+        .union(CssSupportsAtRuleDeclarator::KIND_SET)
+        .union(CssViewTransitionAtRuleDeclarator::KIND_SET);
     fn can_cast(kind: SyntaxKind) -> bool {
         matches!(
             kind,
-            CSS_CONTAINER_STYLE_AND_QUERY | CSS_CONTAINER_STYLE_IN_PARENS
+            CSS_COLOR_PROFILE_AT_RULE_DECLARATOR
+                | CSS_CONTAINER_AT_RULE_DECLARATOR
+                | CSS_COUNTER_STYLE_AT_RULE_DECLARATOR
+                | CSS_FONT_FACE_AT_RULE_DECLARATOR
+                | CSS_FONT_PALETTE_VALUES_AT_RULE_DECLARATOR
+                | CSS_MEDIA_AT_RULE_DECLARATOR
+                | CSS_POSITION_TRY_AT_RULE_DECLARATOR
+                | CSS_PROPERTY_AT_RULE_DECLARATOR
+                | CSS_SCOPE_AT_RULE_DECLARATOR
+                | CSS_STARTING_STYLE_AT_RULE_DECLARATOR
+                | CSS_SUPPORTS_AT_RULE_DECLARATOR
+                | CSS_VIEW_TRANSITION_AT_RULE_DECLARATOR
         )
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         let res = match syntax.kind() {
-            CSS_CONTAINER_STYLE_AND_QUERY => {
-                Self::CssContainerStyleAndQuery(CssContainerStyleAndQuery { syntax })
+            CSS_COLOR_PROFILE_AT_RULE_DECLARATOR => {
+                Self::CssColorProfileAtRuleDeclarator(CssColorProfileAtRuleDeclarator { syntax })
+            }
+            CSS_CONTAINER_AT_RULE_DECLARATOR => {
+                Self::CssContainerAtRuleDeclarator(CssContainerAtRuleDeclarator { syntax })
+            }
+            CSS_COUNTER_STYLE_AT_RULE_DECLARATOR => {
+                Self::CssCounterStyleAtRuleDeclarator(CssCounterStyleAtRuleDeclarator { syntax })
+            }
+            CSS_FONT_FACE_AT_RULE_DECLARATOR => {
+                Self::CssFontFaceAtRuleDeclarator(CssFontFaceAtRuleDeclarator { syntax })
+            }
+            CSS_FONT_PALETTE_VALUES_AT_RULE_DECLARATOR => {
+                Self::CssFontPaletteValuesAtRuleDeclarator(CssFontPaletteValuesAtRuleDeclarator {
+                    syntax,
+                })
+            }
+            CSS_MEDIA_AT_RULE_DECLARATOR => {
+                Self::CssMediaAtRuleDeclarator(CssMediaAtRuleDeclarator { syntax })
+            }
+            CSS_POSITION_TRY_AT_RULE_DECLARATOR => {
+                Self::CssPositionTryAtRuleDeclarator(CssPositionTryAtRuleDeclarator { syntax })
+            }
+            CSS_PROPERTY_AT_RULE_DECLARATOR => {
+                Self::CssPropertyAtRuleDeclarator(CssPropertyAtRuleDeclarator { syntax })
+            }
+            CSS_SCOPE_AT_RULE_DECLARATOR => {
+                Self::CssScopeAtRuleDeclarator(CssScopeAtRuleDeclarator { syntax })
+            }
+            CSS_STARTING_STYLE_AT_RULE_DECLARATOR => {
+                Self::CssStartingStyleAtRuleDeclarator(CssStartingStyleAtRuleDeclarator { syntax })
+            }
+            CSS_SUPPORTS_AT_RULE_DECLARATOR => {
+                Self::CssSupportsAtRuleDeclarator(CssSupportsAtRuleDeclarator { syntax })
             }
-            CSS_CONTAINER_STYLE_IN_PARENS => {
-                Self::CssContainerStyleInParens(CssContainerStyleInParens { syntax })
+            CSS_VIEW_TRANSITION_AT_RULE_DECLARATOR => {
+                Self::CssViewTransitionAtRuleDeclarator(CssViewTransitionAtRuleDeclarator {
+                    syntax,
+                })
             }
             _ => return None,
         };
@@ -22686,644 +20732,665 @@ impl AstNode for AnyCssContainerStyleAndCombinableQuery {
     }
     fn syntax(&self) -> &SyntaxNode {
         match self {
-            Self::CssContainerStyleAndQuery(it) => it.syntax(),
-            Self::CssContainerStyleInParens(it) => it.syntax(),
+            Self::CssColorProfileAtRuleDeclarator(it) => it.syntax(),
+            Self::CssContainerAtRuleDeclarator(it) => it.syntax(),
+            Self::CssCounterStyleAtRuleDeclarator(it) => it.syntax(),
+            Self::CssFontFaceAtRuleDeclarator(it) => it.syntax(),
+            Self::CssFontPaletteValuesAtRuleDeclarator(it) => it.syntax(),
+            Self::CssMediaAtRuleDeclarator(it) => it.syntax(),
+            Self::CssPositionTryAtRuleDeclarator(it) => it.syntax(),
+            Self::CssPropertyAtRuleDeclarator(it) => it.syntax(),
+            Self::CssScopeAtRuleDeclarator(it) => it.syntax(),
+            Self::CssStartingStyleAtRuleDeclarator(it) => it.syntax(),
+            Self::CssSupportsAtRuleDeclarator(it) => it.syntax(),
+            Self::CssViewTransitionAtRuleDeclarator(it) => it.syntax(),
         }
     }
     fn into_syntax(self) -> SyntaxNode {
         match self {
-            Self::CssContainerStyleAndQuery(it) => it.into_syntax(),
-            Self::CssContainerStyleInParens(it) => it.into_syntax(),
+            Self::CssColorProfileAtRuleDeclarator(it) => it.into_syntax(),
+            Self::CssContainerAtRuleDeclarator(it) => it.into_syntax(),
+            Self::CssCounterStyleAtRuleDeclarator(it) => it.into_syntax(),
+            Self::CssFontFaceAtRuleDeclarator(it) => it.into_syntax(),
+            Self::CssFontPaletteValuesAtRuleDeclarator(it) => it.into_syntax(),
+            Self::CssMediaAtRuleDeclarator(it) => it.into_syntax(),
+            Self::CssPositionTryAtRuleDeclarator(it) => it.into_syntax(),
+            Self::CssPropertyAtRuleDeclarator(it) => it.into_syntax(),
+            Self::CssScopeAtRuleDeclarator(it) => it.into_syntax(),
+            Self::CssStartingStyleAtRuleDeclarator(it) => it.into_syntax(),
+            Self::CssSupportsAtRuleDeclarator(it) => it.into_syntax(),
+            Self::CssViewTransitionAtRuleDeclarator(it) => it.into_syntax(),
         }
     }
 }
-impl std::fmt::Debug for AnyCssContainerStyleAndCombinableQuery {
+impl std::fmt::Debug for AnyCssAtRuleDeclarator {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         match self {
-            Self::CssContainerStyleAndQuery(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssContainerStyleInParens(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssColorProfileAtRuleDeclarator(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssContainerAtRuleDeclarator(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssCounterStyleAtRuleDeclarator(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssFontFaceAtRuleDeclarator(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssFontPaletteValuesAtRuleDeclarator(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssMediaAtRuleDeclarator(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssPositionTryAtRuleDeclarator(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssPropertyAtRuleDeclarator(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssScopeAtRuleDeclarator(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssStartingStyleAtRuleDeclarator(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssSupportsAtRuleDeclarator(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssViewTransitionAtRuleDeclarator(it) => std::fmt::Debug::fmt(it, f),
         }
     }
 }
-impl From<AnyCssContainerStyleAndCombinableQuery> for SyntaxNode {
-    fn from(n: AnyCssContainerStyleAndCombinableQuery) -> Self {
+impl From<AnyCssAtRuleDeclarator> for SyntaxNode {
+    fn from(n: AnyCssAtRuleDeclarator) -> Self {
         match n {
-            AnyCssContainerStyleAndCombinableQuery::CssContainerStyleAndQuery(it) => {
-                it.into_syntax()
-            }
-            AnyCssContainerStyleAndCombinableQuery::CssContainerStyleInParens(it) => {
-                it.into_syntax()
-            }
+            AnyCssAtRuleDeclarator::CssColorProfileAtRuleDeclarator(it) => it.into_syntax(),
+            AnyCssAtRuleDeclarator::CssContainerAtRuleDeclarator(it) => it.into_syntax(),
+            AnyCssAtRuleDeclarator::CssCounterStyleAtRuleDeclarator(it) => it.into_syntax(),
+            AnyCssAtRuleDeclarator::CssFontFaceAtRuleDeclarator(it) => it.into_syntax(),
+            AnyCssAtRuleDeclarator::CssFontPaletteValuesAtRuleDeclarator(it) => it.into_syntax(),
+            AnyCssAtRuleDeclarator::CssMediaAtRuleDeclarator(it) => it.into_syntax(),
+            AnyCssAtRuleDeclarator::CssPositionTryAtRuleDeclarator(it) => it.into_syntax(),
+            AnyCssAtRuleDeclarator::CssPropertyAtRuleDeclarator(it) => it.into_syntax(),
+            AnyCssAtRuleDeclarator::CssScopeAtRuleDeclarator(it) => it.into_syntax(),
+            AnyCssAtRuleDeclarator::CssStartingStyleAtRuleDeclarator(it) => it.into_syntax(),
+            AnyCssAtRuleDeclarator::CssSupportsAtRuleDeclarator(it) => it.into_syntax(),
+            AnyCssAtRuleDeclarator::CssViewTransitionAtRuleDeclarator(it) => it.into_syntax(),
         }
     }
 }
-impl From<AnyCssContainerStyleAndCombinableQuery> for SyntaxElement {
-    fn from(n: AnyCssContainerStyleAndCombinableQuery) -> Self {
+impl From<AnyCssAtRuleDeclarator> for SyntaxElement {
+    fn from(n: AnyCssAtRuleDeclarator) -> Self {
         let node: SyntaxNode = n.into();
         node.into()
     }
 }
-impl From<CssDeclaration> for AnyCssContainerStyleInParens {
-    fn from(node: CssDeclaration) -> Self {
-        Self::CssDeclaration(node)
+impl From<CssIdentifier> for AnyCssAttributeMatcherValue {
+    fn from(node: CssIdentifier) -> Self {
+        Self::CssIdentifier(node)
     }
 }
-impl AstNode for AnyCssContainerStyleInParens {
+impl From<CssString> for AnyCssAttributeMatcherValue {
+    fn from(node: CssString) -> Self {
+        Self::CssString(node)
+    }
+}
+impl AstNode for AnyCssAttributeMatcherValue {
     type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> =
-        AnyCssContainerStyleQuery::KIND_SET.union(CssDeclaration::KIND_SET);
+    const KIND_SET: SyntaxKindSet<Language> = CssIdentifier::KIND_SET.union(CssString::KIND_SET);
     fn can_cast(kind: SyntaxKind) -> bool {
-        match kind {
-            CSS_DECLARATION => true,
-            k if AnyCssContainerStyleQuery::can_cast(k) => true,
-            _ => false,
-        }
+        matches!(kind, CSS_IDENTIFIER | CSS_STRING)
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         let res = match syntax.kind() {
-            CSS_DECLARATION => Self::CssDeclaration(CssDeclaration { syntax }),
-            _ => {
-                if let Some(any_css_container_style_query) = AnyCssContainerStyleQuery::cast(syntax)
-                {
-                    return Some(Self::AnyCssContainerStyleQuery(
-                        any_css_container_style_query,
-                    ));
-                }
-                return None;
-            }
+            CSS_IDENTIFIER => Self::CssIdentifier(CssIdentifier { syntax }),
+            CSS_STRING => Self::CssString(CssString { syntax }),
+            _ => return None,
         };
         Some(res)
     }
     fn syntax(&self) -> &SyntaxNode {
         match self {
-            Self::CssDeclaration(it) => it.syntax(),
-            Self::AnyCssContainerStyleQuery(it) => it.syntax(),
+            Self::CssIdentifier(it) => it.syntax(),
+            Self::CssString(it) => it.syntax(),
         }
     }
     fn into_syntax(self) -> SyntaxNode {
         match self {
-            Self::CssDeclaration(it) => it.into_syntax(),
-            Self::AnyCssContainerStyleQuery(it) => it.into_syntax(),
+            Self::CssIdentifier(it) => it.into_syntax(),
+            Self::CssString(it) => it.into_syntax(),
         }
     }
 }
-impl std::fmt::Debug for AnyCssContainerStyleInParens {
+impl std::fmt::Debug for AnyCssAttributeMatcherValue {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         match self {
-            Self::AnyCssContainerStyleQuery(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssDeclaration(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssIdentifier(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssString(it) => std::fmt::Debug::fmt(it, f),
         }
     }
 }
-impl From<AnyCssContainerStyleInParens> for SyntaxNode {
-    fn from(n: AnyCssContainerStyleInParens) -> Self {
+impl From<AnyCssAttributeMatcherValue> for SyntaxNode {
+    fn from(n: AnyCssAttributeMatcherValue) -> Self {
         match n {
-            AnyCssContainerStyleInParens::AnyCssContainerStyleQuery(it) => it.into_syntax(),
-            AnyCssContainerStyleInParens::CssDeclaration(it) => it.into_syntax(),
+            AnyCssAttributeMatcherValue::CssIdentifier(it) => it.into_syntax(),
+            AnyCssAttributeMatcherValue::CssString(it) => it.into_syntax(),
         }
     }
 }
-impl From<AnyCssContainerStyleInParens> for SyntaxElement {
-    fn from(n: AnyCssContainerStyleInParens) -> Self {
+impl From<AnyCssAttributeMatcherValue> for SyntaxElement {
+    fn from(n: AnyCssAttributeMatcherValue) -> Self {
         let node: SyntaxNode = n.into();
         node.into()
     }
 }
-impl From<CssContainerStyleInParens> for AnyCssContainerStyleOrCombinableQuery {
-    fn from(node: CssContainerStyleInParens) -> Self {
-        Self::CssContainerStyleInParens(node)
+impl From<CssIdentifier> for AnyCssComposesImportSource {
+    fn from(node: CssIdentifier) -> Self {
+        Self::CssIdentifier(node)
     }
 }
-impl From<CssContainerStyleOrQuery> for AnyCssContainerStyleOrCombinableQuery {
-    fn from(node: CssContainerStyleOrQuery) -> Self {
-        Self::CssContainerStyleOrQuery(node)
+impl From<CssString> for AnyCssComposesImportSource {
+    fn from(node: CssString) -> Self {
+        Self::CssString(node)
     }
 }
-impl AstNode for AnyCssContainerStyleOrCombinableQuery {
+impl AstNode for AnyCssComposesImportSource {
     type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> =
-        CssContainerStyleInParens::KIND_SET.union(CssContainerStyleOrQuery::KIND_SET);
+    const KIND_SET: SyntaxKindSet<Language> = CssIdentifier::KIND_SET.union(CssString::KIND_SET);
     fn can_cast(kind: SyntaxKind) -> bool {
-        matches!(
-            kind,
-            CSS_CONTAINER_STYLE_IN_PARENS | CSS_CONTAINER_STYLE_OR_QUERY
-        )
+        matches!(kind, CSS_IDENTIFIER | CSS_STRING)
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         let res = match syntax.kind() {
-            CSS_CONTAINER_STYLE_IN_PARENS => {
-                Self::CssContainerStyleInParens(CssContainerStyleInParens { syntax })
-            }
-            CSS_CONTAINER_STYLE_OR_QUERY => {
-                Self::CssContainerStyleOrQuery(CssContainerStyleOrQuery { syntax })
-            }
+            CSS_IDENTIFIER => Self::CssIdentifier(CssIdentifier { syntax }),
+            CSS_STRING => Self::CssString(CssString { syntax }),
             _ => return None,
         };
         Some(res)
     }
     fn syntax(&self) -> &SyntaxNode {
         match self {
-            Self::CssContainerStyleInParens(it) => it.syntax(),
-            Self::CssContainerStyleOrQuery(it) => it.syntax(),
+            Self::CssIdentifier(it) => it.syntax(),
+            Self::CssString(it) => it.syntax(),
         }
     }
     fn into_syntax(self) -> SyntaxNode {
         match self {
-            Self::CssContainerStyleInParens(it) => it.into_syntax(),
-            Self::CssContainerStyleOrQuery(it) => it.into_syntax(),
+            Self::CssIdentifier(it) => it.into_syntax(),
+            Self::CssString(it) => it.into_syntax(),
         }
     }
 }
-impl std::fmt::Debug for AnyCssContainerStyleOrCombinableQuery {
+impl std::fmt::Debug for AnyCssComposesImportSource {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         match self {
-            Self::CssContainerStyleInParens(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssContainerStyleOrQuery(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssIdentifier(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssString(it) => std::fmt::Debug::fmt(it, f),
         }
     }
 }
-impl From<AnyCssContainerStyleOrCombinableQuery> for SyntaxNode {
-    fn from(n: AnyCssContainerStyleOrCombinableQuery) -> Self {
+impl From<AnyCssComposesImportSource> for SyntaxNode {
+    fn from(n: AnyCssComposesImportSource) -> Self {
         match n {
-            AnyCssContainerStyleOrCombinableQuery::CssContainerStyleInParens(it) => {
-                it.into_syntax()
-            }
-            AnyCssContainerStyleOrCombinableQuery::CssContainerStyleOrQuery(it) => it.into_syntax(),
+            AnyCssComposesImportSource::CssIdentifier(it) => it.into_syntax(),
+            AnyCssComposesImportSource::CssString(it) => it.into_syntax(),
         }
     }
 }
-impl From<AnyCssContainerStyleOrCombinableQuery> for SyntaxElement {
-    fn from(n: AnyCssContainerStyleOrCombinableQuery) -> Self {
+impl From<AnyCssComposesImportSource> for SyntaxElement {
+    fn from(n: AnyCssComposesImportSource) -> Self {
         let node: SyntaxNode = n.into();
         node.into()
     }
 }
-impl From<CssContainerStyleAndQuery> for AnyCssContainerStyleQuery {
-    fn from(node: CssContainerStyleAndQuery) -> Self {
-        Self::CssContainerStyleAndQuery(node)
-    }
-}
-impl From<CssContainerStyleInParens> for AnyCssContainerStyleQuery {
-    fn from(node: CssContainerStyleInParens) -> Self {
-        Self::CssContainerStyleInParens(node)
-    }
-}
-impl From<CssContainerStyleNotQuery> for AnyCssContainerStyleQuery {
-    fn from(node: CssContainerStyleNotQuery) -> Self {
-        Self::CssContainerStyleNotQuery(node)
-    }
-}
-impl From<CssContainerStyleOrQuery> for AnyCssContainerStyleQuery {
-    fn from(node: CssContainerStyleOrQuery) -> Self {
-        Self::CssContainerStyleOrQuery(node)
+impl From<CssBogusSelector> for AnyCssCompoundSelector {
+    fn from(node: CssBogusSelector) -> Self {
+        Self::CssBogusSelector(node)
     }
 }
-impl From<CssDeclaration> for AnyCssContainerStyleQuery {
-    fn from(node: CssDeclaration) -> Self {
-        Self::CssDeclaration(node)
+impl From<CssCompoundSelector> for AnyCssCompoundSelector {
+    fn from(node: CssCompoundSelector) -> Self {
+        Self::CssCompoundSelector(node)
     }
 }
-impl AstNode for AnyCssContainerStyleQuery {
+impl AstNode for AnyCssCompoundSelector {
     type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> = CssContainerStyleAndQuery::KIND_SET
-        .union(CssContainerStyleInParens::KIND_SET)
-        .union(CssContainerStyleNotQuery::KIND_SET)
-        .union(CssContainerStyleOrQuery::KIND_SET)
-        .union(CssDeclaration::KIND_SET);
-    fn can_cast(kind: SyntaxKind) -> bool {
-        matches!(
-            kind,
-            CSS_CONTAINER_STYLE_AND_QUERY
-                | CSS_CONTAINER_STYLE_IN_PARENS
-                | CSS_CONTAINER_STYLE_NOT_QUERY
-                | CSS_CONTAINER_STYLE_OR_QUERY
-                | CSS_DECLARATION
-        )
-    }
-    fn cast(syntax: SyntaxNode) -> Option<Self> {
-        let res = match syntax.kind() {
-            CSS_CONTAINER_STYLE_AND_QUERY => {
-                Self::CssContainerStyleAndQuery(CssContainerStyleAndQuery { syntax })
-            }
-            CSS_CONTAINER_STYLE_IN_PARENS => {
-                Self::CssContainerStyleInParens(CssContainerStyleInParens { syntax })
-            }
-            CSS_CONTAINER_STYLE_NOT_QUERY => {
-                Self::CssContainerStyleNotQuery(CssContainerStyleNotQuery { syntax })
-            }
-            CSS_CONTAINER_STYLE_OR_QUERY => {
-                Self::CssContainerStyleOrQuery(CssContainerStyleOrQuery { syntax })
-            }
-            CSS_DECLARATION => Self::CssDeclaration(CssDeclaration { syntax }),
+    const KIND_SET: SyntaxKindSet<Language> =
+        CssBogusSelector::KIND_SET.union(CssCompoundSelector::KIND_SET);
+    fn can_cast(kind: SyntaxKind) -> bool {
+        matches!(kind, CSS_BOGUS_SELECTOR | CSS_COMPOUND_SELECTOR)
+    }
+    fn cast(syntax: SyntaxNode) -> Option<Self> {
+        let res = match syntax.kind() {
+            CSS_BOGUS_SELECTOR => Self::CssBogusSelector(CssBogusSelector { syntax }),
+            CSS_COMPOUND_SELECTOR => Self::CssCompoundSelector(CssCompoundSelector { syntax }),
             _ => return None,
         };
         Some(res)
     }
     fn syntax(&self) -> &SyntaxNode {
         match self {
-            Self::CssContainerStyleAndQuery(it) => it.syntax(),
-            Self::CssContainerStyleInParens(it) => it.syntax(),
-            Self::CssContainerStyleNotQuery(it) => it.syntax(),
-            Self::CssContainerStyleOrQuery(it) => it.syntax(),
-            Self::CssDeclaration(it) => it.syntax(),
+            Self::CssBogusSelector(it) => it.syntax(),
+            Self::CssCompoundSelector(it) => it.syntax(),
         }
     }
     fn into_syntax(self) -> SyntaxNode {
         match self {
-            Self::CssContainerStyleAndQuery(it) => it.into_syntax(),
-            Self::CssContainerStyleInParens(it) => it.into_syntax(),
-            Self::CssContainerStyleNotQuery(it) => it.into_syntax(),
-            Self::CssContainerStyleOrQuery(it) => it.into_syntax(),
-            Self::CssDeclaration(it) => it.into_syntax(),
+            Self::CssBogusSelector(it) => it.into_syntax(),
+            Self::CssCompoundSelector(it) => it.into_syntax(),
         }
     }
 }
-impl std::fmt::Debug for AnyCssContainerStyleQuery {
+impl std::fmt::Debug for AnyCssCompoundSelector {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         match self {
-            Self::CssContainerStyleAndQuery(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssContainerStyleInParens(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssContainerStyleNotQuery(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssContainerStyleOrQuery(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssDeclaration(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssBogusSelector(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssCompoundSelector(it) => std::fmt::Debug::fmt(it, f),
         }
     }
 }
-impl From<AnyCssContainerStyleQuery> for SyntaxNode {
-    fn from(n: AnyCssContainerStyleQuery) -> Self {
+impl From<AnyCssCompoundSelector> for SyntaxNode {
+    fn from(n: AnyCssCompoundSelector) -> Self {
         match n {
-            AnyCssContainerStyleQuery::CssContainerStyleAndQuery(it) => it.into_syntax(),
-            AnyCssContainerStyleQuery::CssContainerStyleInParens(it) => it.into_syntax(),
-            AnyCssContainerStyleQuery::CssContainerStyleNotQuery(it) => it.into_syntax(),
-            AnyCssContainerStyleQuery::CssContainerStyleOrQuery(it) => it.into_syntax(),
-            AnyCssContainerStyleQuery::CssDeclaration(it) => it.into_syntax(),
+            AnyCssCompoundSelector::CssBogusSelector(it) => it.into_syntax(),
+            AnyCssCompoundSelector::CssCompoundSelector(it) => it.into_syntax(),
         }
     }
 }
-impl From<AnyCssContainerStyleQuery> for SyntaxElement {
-    fn from(n: AnyCssContainerStyleQuery) -> Self {
+impl From<AnyCssCompoundSelector> for SyntaxElement {
+    fn from(n: AnyCssCompoundSelector) -> Self {
         let node: SyntaxNode = n.into();
         node.into()
     }
 }
-impl From<CssBogusCustomIdentifier> for AnyCssCustomIdentifier {
-    fn from(node: CssBogusCustomIdentifier) -> Self {
-        Self::CssBogusCustomIdentifier(node)
+impl From<CssBogusBlock> for AnyCssConditionalBlock {
+    fn from(node: CssBogusBlock) -> Self {
+        Self::CssBogusBlock(node)
     }
 }
-impl From<CssCustomIdentifier> for AnyCssCustomIdentifier {
-    fn from(node: CssCustomIdentifier) -> Self {
-        Self::CssCustomIdentifier(node)
+impl From<CssDeclarationOrRuleBlock> for AnyCssConditionalBlock {
+    fn from(node: CssDeclarationOrRuleBlock) -> Self {
+        Self::CssDeclarationOrRuleBlock(node)
     }
 }
-impl AstNode for AnyCssCustomIdentifier {
+impl From<CssRuleBlock> for AnyCssConditionalBlock {
+    fn from(node: CssRuleBlock) -> Self {
+        Self::CssRuleBlock(node)
+    }
+}
+impl AstNode for AnyCssConditionalBlock {
     type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> =
-        CssBogusCustomIdentifier::KIND_SET.union(CssCustomIdentifier::KIND_SET);
+    const KIND_SET: SyntaxKindSet<Language> = CssBogusBlock::KIND_SET
+        .union(CssDeclarationOrRuleBlock::KIND_SET)
+        .union(CssRuleBlock::KIND_SET);
     fn can_cast(kind: SyntaxKind) -> bool {
-        matches!(kind, CSS_BOGUS_CUSTOM_IDENTIFIER | CSS_CUSTOM_IDENTIFIER)
+        matches!(
+            kind,
+            CSS_BOGUS_BLOCK | CSS_DECLARATION_OR_RULE_BLOCK | CSS_RULE_BLOCK
+        )
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         let res = match syntax.kind() {
-            CSS_BOGUS_CUSTOM_IDENTIFIER => {
-                Self::CssBogusCustomIdentifier(CssBogusCustomIdentifier { syntax })
+            CSS_BOGUS_BLOCK => Self::CssBogusBlock(CssBogusBlock { syntax }),
+            CSS_DECLARATION_OR_RULE_BLOCK => {
+                Self::CssDeclarationOrRuleBlock(CssDeclarationOrRuleBlock { syntax })
             }
-            CSS_CUSTOM_IDENTIFIER => Self::CssCustomIdentifier(CssCustomIdentifier { syntax }),
+            CSS_RULE_BLOCK => Self::CssRuleBlock(CssRuleBlock { syntax }),
             _ => return None,
         };
         Some(res)
     }
     fn syntax(&self) -> &SyntaxNode {
         match self {
-            Self::CssBogusCustomIdentifier(it) => it.syntax(),
-            Self::CssCustomIdentifier(it) => it.syntax(),
+            Self::CssBogusBlock(it) => it.syntax(),
+            Self::CssDeclarationOrRuleBlock(it) => it.syntax(),
+            Self::CssRuleBlock(it) => it.syntax(),
         }
     }
     fn into_syntax(self) -> SyntaxNode {
         match self {
-            Self::CssBogusCustomIdentifier(it) => it.into_syntax(),
-            Self::CssCustomIdentifier(it) => it.into_syntax(),
+            Self::CssBogusBlock(it) => it.into_syntax(),
+            Self::CssDeclarationOrRuleBlock(it) => it.into_syntax(),
+            Self::CssRuleBlock(it) => it.into_syntax(),
         }
     }
 }
-impl std::fmt::Debug for AnyCssCustomIdentifier {
+impl std::fmt::Debug for AnyCssConditionalBlock {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         match self {
-            Self::CssBogusCustomIdentifier(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssCustomIdentifier(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssBogusBlock(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssDeclarationOrRuleBlock(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssRuleBlock(it) => std::fmt::Debug::fmt(it, f),
         }
     }
 }
-impl From<AnyCssCustomIdentifier> for SyntaxNode {
-    fn from(n: AnyCssCustomIdentifier) -> Self {
+impl From<AnyCssConditionalBlock> for SyntaxNode {
+    fn from(n: AnyCssConditionalBlock) -> Self {
         match n {
-            AnyCssCustomIdentifier::CssBogusCustomIdentifier(it) => it.into_syntax(),
-            AnyCssCustomIdentifier::CssCustomIdentifier(it) => it.into_syntax(),
+            AnyCssConditionalBlock::CssBogusBlock(it) => it.into_syntax(),
+            AnyCssConditionalBlock::CssDeclarationOrRuleBlock(it) => it.into_syntax(),
+            AnyCssConditionalBlock::CssRuleBlock(it) => it.into_syntax(),
         }
     }
 }
-impl From<AnyCssCustomIdentifier> for SyntaxElement {
-    fn from(n: AnyCssCustomIdentifier) -> Self {
+impl From<AnyCssConditionalBlock> for SyntaxElement {
+    fn from(n: AnyCssConditionalBlock) -> Self {
         let node: SyntaxNode = n.into();
         node.into()
     }
 }
-impl From<CssDeclarationWithSemicolon> for AnyCssDeclaration {
-    fn from(node: CssDeclarationWithSemicolon) -> Self {
-        Self::CssDeclarationWithSemicolon(node)
-    }
-}
-impl From<CssEmptyDeclaration> for AnyCssDeclaration {
-    fn from(node: CssEmptyDeclaration) -> Self {
-        Self::CssEmptyDeclaration(node)
+impl From<CssContainerAndQuery> for AnyCssContainerAndCombinableQuery {
+    fn from(node: CssContainerAndQuery) -> Self {
+        Self::CssContainerAndQuery(node)
     }
 }
-impl AstNode for AnyCssDeclaration {
+impl AstNode for AnyCssContainerAndCombinableQuery {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        CssDeclarationWithSemicolon::KIND_SET.union(CssEmptyDeclaration::KIND_SET);
+        AnyCssContainerQueryInParens::KIND_SET.union(CssContainerAndQuery::KIND_SET);
     fn can_cast(kind: SyntaxKind) -> bool {
-        matches!(kind, CSS_DECLARATION_WITH_SEMICOLON | CSS_EMPTY_DECLARATION)
+        match kind {
+            CSS_CONTAINER_AND_QUERY => true,
+            k if AnyCssContainerQueryInParens::can_cast(k) => true,
+            _ => false,
+        }
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         let res = match syntax.kind() {
-            CSS_DECLARATION_WITH_SEMICOLON => {
-                Self::CssDeclarationWithSemicolon(CssDeclarationWithSemicolon { syntax })
+            CSS_CONTAINER_AND_QUERY => Self::CssContainerAndQuery(CssContainerAndQuery { syntax }),
+            _ => {
+                if let Some(any_css_container_query_in_parens) =
+                    AnyCssContainerQueryInParens::cast(syntax)
+                {
+                    return Some(Self::AnyCssContainerQueryInParens(
+                        any_css_container_query_in_parens,
+                    ));
+                }
+                return None;
             }
-            CSS_EMPTY_DECLARATION => Self::CssEmptyDeclaration(CssEmptyDeclaration { syntax }),
-            _ => return None,
         };
         Some(res)
     }
     fn syntax(&self) -> &SyntaxNode {
         match self {
-            Self::CssDeclarationWithSemicolon(it) => it.syntax(),
-            Self::CssEmptyDeclaration(it) => it.syntax(),
+            Self::CssContainerAndQuery(it) => it.syntax(),
+            Self::AnyCssContainerQueryInParens(it) => it.syntax(),
         }
     }
     fn into_syntax(self) -> SyntaxNode {
         match self {
-            Self::CssDeclarationWithSemicolon(it) => it.into_syntax(),
-            Self::CssEmptyDeclaration(it) => it.into_syntax(),
+            Self::CssContainerAndQuery(it) => it.into_syntax(),
+            Self::AnyCssContainerQueryInParens(it) => it.into_syntax(),
         }
     }
 }
-impl std::fmt::Debug for AnyCssDeclaration {
+impl std::fmt::Debug for AnyCssContainerAndCombinableQuery {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         match self {
-            Self::CssDeclarationWithSemicolon(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssEmptyDeclaration(it) => std::fmt::Debug::fmt(it, f),
+            Self::AnyCssContainerQueryInParens(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssContainerAndQuery(it) => std::fmt::Debug::fmt(it, f),
         }
     }
 }
-impl From<AnyCssDeclaration> for SyntaxNode {
-    fn from(n: AnyCssDeclaration) -> Self {
+impl From<AnyCssContainerAndCombinableQuery> for SyntaxNode {
+    fn from(n: AnyCssContainerAndCombinableQuery) -> Self {
         match n {
-            AnyCssDeclaration::CssDeclarationWithSemicolon(it) => it.into_syntax(),
-            AnyCssDeclaration::CssEmptyDeclaration(it) => it.into_syntax(),
+            AnyCssContainerAndCombinableQuery::AnyCssContainerQueryInParens(it) => it.into_syntax(),
+            AnyCssContainerAndCombinableQuery::CssContainerAndQuery(it) => it.into_syntax(),
         }
     }
 }
-impl From<AnyCssDeclaration> for SyntaxElement {
-    fn from(n: AnyCssDeclaration) -> Self {
+impl From<AnyCssContainerAndCombinableQuery> for SyntaxElement {
+    fn from(n: AnyCssContainerAndCombinableQuery) -> Self {
         let node: SyntaxNode = n.into();
         node.into()
     }
 }
-impl From<CssBogusBlock> for AnyCssDeclarationBlock {
-    fn from(node: CssBogusBlock) -> Self {
-        Self::CssBogusBlock(node)
-    }
-}
-impl From<CssDeclarationBlock> for AnyCssDeclarationBlock {
-    fn from(node: CssDeclarationBlock) -> Self {
-        Self::CssDeclarationBlock(node)
+impl From<CssContainerOrQuery> for AnyCssContainerOrCombinableQuery {
+    fn from(node: CssContainerOrQuery) -> Self {
+        Self::CssContainerOrQuery(node)
     }
 }
-impl AstNode for AnyCssDeclarationBlock {
+impl AstNode for AnyCssContainerOrCombinableQuery {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        CssBogusBlock::KIND_SET.union(CssDeclarationBlock::KIND_SET);
+        AnyCssContainerQueryInParens::KIND_SET.union(CssContainerOrQuery::KIND_SET);
     fn can_cast(kind: SyntaxKind) -> bool {
-        matches!(kind, CSS_BOGUS_BLOCK | CSS_DECLARATION_BLOCK)
+        match kind {
+            CSS_CONTAINER_OR_QUERY => true,
+            k if AnyCssContainerQueryInParens::can_cast(k) => true,
+            _ => false,
+        }
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         let res = match syntax.kind() {
-            CSS_BOGUS_BLOCK => Self::CssBogusBlock(CssBogusBlock { syntax }),
-            CSS_DECLARATION_BLOCK => Self::CssDeclarationBlock(CssDeclarationBlock { syntax }),
-            _ => return None,
+            CSS_CONTAINER_OR_QUERY => Self::CssContainerOrQuery(CssContainerOrQuery { syntax }),
+            _ => {
+                if let Some(any_css_container_query_in_parens) =
+                    AnyCssContainerQueryInParens::cast(syntax)
+                {
+                    return Some(Self::AnyCssContainerQueryInParens(
+                        any_css_container_query_in_parens,
+                    ));
+                }
+                return None;
+            }
         };
         Some(res)
     }
     fn syntax(&self) -> &SyntaxNode {
         match self {
-            Self::CssBogusBlock(it) => it.syntax(),
-            Self::CssDeclarationBlock(it) => it.syntax(),
+            Self::CssContainerOrQuery(it) => it.syntax(),
+            Self::AnyCssContainerQueryInParens(it) => it.syntax(),
         }
     }
     fn into_syntax(self) -> SyntaxNode {
         match self {
-            Self::CssBogusBlock(it) => it.into_syntax(),
-            Self::CssDeclarationBlock(it) => it.into_syntax(),
+            Self::CssContainerOrQuery(it) => it.into_syntax(),
+            Self::AnyCssContainerQueryInParens(it) => it.into_syntax(),
         }
     }
 }
-impl std::fmt::Debug for AnyCssDeclarationBlock {
+impl std::fmt::Debug for AnyCssContainerOrCombinableQuery {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         match self {
-            Self::CssBogusBlock(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssDeclarationBlock(it) => std::fmt::Debug::fmt(it, f),
+            Self::AnyCssContainerQueryInParens(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssContainerOrQuery(it) => std::fmt::Debug::fmt(it, f),
         }
     }
 }
-impl From<AnyCssDeclarationBlock> for SyntaxNode {
-    fn from(n: AnyCssDeclarationBlock) -> Self {
+impl From<AnyCssContainerOrCombinableQuery> for SyntaxNode {
+    fn from(n: AnyCssContainerOrCombinableQuery) -> Self {
         match n {
-            AnyCssDeclarationBlock::CssBogusBlock(it) => it.into_syntax(),
-            AnyCssDeclarationBlock::CssDeclarationBlock(it) => it.into_syntax(),
+            AnyCssContainerOrCombinableQuery::AnyCssContainerQueryInParens(it) => it.into_syntax(),
+            AnyCssContainerOrCombinableQuery::CssContainerOrQuery(it) => it.into_syntax(),
         }
     }
 }
-impl From<AnyCssDeclarationBlock> for SyntaxElement {
-    fn from(n: AnyCssDeclarationBlock) -> Self {
+impl From<AnyCssContainerOrCombinableQuery> for SyntaxElement {
+    fn from(n: AnyCssContainerOrCombinableQuery) -> Self {
         let node: SyntaxNode = n.into();
         node.into()
     }
 }
-impl From<CssDashedIdentifier> for AnyCssDeclarationName {
-    fn from(node: CssDashedIdentifier) -> Self {
-        Self::CssDashedIdentifier(node)
+impl From<CssContainerAndQuery> for AnyCssContainerQuery {
+    fn from(node: CssContainerAndQuery) -> Self {
+        Self::CssContainerAndQuery(node)
     }
 }
-impl From<CssIdentifier> for AnyCssDeclarationName {
-    fn from(node: CssIdentifier) -> Self {
-        Self::CssIdentifier(node)
+impl From<CssContainerNotQuery> for AnyCssContainerQuery {
+    fn from(node: CssContainerNotQuery) -> Self {
+        Self::CssContainerNotQuery(node)
     }
 }
-impl From<TwValueThemeReference> for AnyCssDeclarationName {
-    fn from(node: TwValueThemeReference) -> Self {
-        Self::TwValueThemeReference(node)
+impl From<CssContainerOrQuery> for AnyCssContainerQuery {
+    fn from(node: CssContainerOrQuery) -> Self {
+        Self::CssContainerOrQuery(node)
     }
 }
-impl AstNode for AnyCssDeclarationName {
-    type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> = CssDashedIdentifier::KIND_SET
-        .union(CssIdentifier::KIND_SET)
-        .union(TwValueThemeReference::KIND_SET);
+impl AstNode for AnyCssContainerQuery {
+    type Language = Language;
+    const KIND_SET: SyntaxKindSet<Language> = AnyCssContainerQueryInParens::KIND_SET
+        .union(CssContainerAndQuery::KIND_SET)
+        .union(CssContainerNotQuery::KIND_SET)
+        .union(CssContainerOrQuery::KIND_SET);
     fn can_cast(kind: SyntaxKind) -> bool {
-        matches!(
-            kind,
-            CSS_DASHED_IDENTIFIER | CSS_IDENTIFIER | TW_VALUE_THEME_REFERENCE
-        )
+        match kind {
+            CSS_CONTAINER_AND_QUERY | CSS_CONTAINER_NOT_QUERY | CSS_CONTAINER_OR_QUERY => true,
+            k if AnyCssContainerQueryInParens::can_cast(k) => true,
+            _ => false,
+        }
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         let res = match syntax.kind() {
-            CSS_DASHED_IDENTIFIER => Self::CssDashedIdentifier(CssDashedIdentifier { syntax }),
-            CSS_IDENTIFIER => Self::CssIdentifier(CssIdentifier { syntax }),
-            TW_VALUE_THEME_REFERENCE => {
-                Self::TwValueThemeReference(TwValueThemeReference { syntax })
+            CSS_CONTAINER_AND_QUERY => Self::CssContainerAndQuery(CssContainerAndQuery { syntax }),
+            CSS_CONTAINER_NOT_QUERY => Self::CssContainerNotQuery(CssContainerNotQuery { syntax }),
+            CSS_CONTAINER_OR_QUERY => Self::CssContainerOrQuery(CssContainerOrQuery { syntax }),
+            _ => {
+                if let Some(any_css_container_query_in_parens) =
+                    AnyCssContainerQueryInParens::cast(syntax)
+                {
+                    return Some(Self::AnyCssContainerQueryInParens(
+                        any_css_container_query_in_parens,
+                    ));
+                }
+                return None;
             }
-            _ => return None,
         };
         Some(res)
     }
     fn syntax(&self) -> &SyntaxNode {
         match self {
-            Self::CssDashedIdentifier(it) => it.syntax(),
-            Self::CssIdentifier(it) => it.syntax(),
-            Self::TwValueThemeReference(it) => it.syntax(),
+            Self::CssContainerAndQuery(it) => it.syntax(),
+            Self::CssContainerNotQuery(it) => it.syntax(),
+            Self::CssContainerOrQuery(it) => it.syntax(),
+            Self::AnyCssContainerQueryInParens(it) => it.syntax(),
         }
     }
     fn into_syntax(self) -> SyntaxNode {
         match self {
-            Self::CssDashedIdentifier(it) => it.into_syntax(),
-            Self::CssIdentifier(it) => it.into_syntax(),
-            Self::TwValueThemeReference(it) => it.into_syntax(),
+            Self::CssContainerAndQuery(it) => it.into_syntax(),
+            Self::CssContainerNotQuery(it) => it.into_syntax(),
+            Self::CssContainerOrQuery(it) => it.into_syntax(),
+            Self::AnyCssContainerQueryInParens(it) => it.into_syntax(),
         }
     }
 }
-impl std::fmt::Debug for AnyCssDeclarationName {
+impl std::fmt::Debug for AnyCssContainerQuery {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         match self {
-            Self::CssDashedIdentifier(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssIdentifier(it) => std::fmt::Debug::fmt(it, f),
-            Self::TwValueThemeReference(it) => std::fmt::Debug::fmt(it, f),
+            Self::AnyCssContainerQueryInParens(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssContainerAndQuery(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssContainerNotQuery(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssContainerOrQuery(it) => std::fmt::Debug::fmt(it, f),
         }
     }
 }
-impl From<AnyCssDeclarationName> for SyntaxNode {
-    fn from(n: AnyCssDeclarationName) -> Self {
+impl From<AnyCssContainerQuery> for SyntaxNode {
+    fn from(n: AnyCssContainerQuery) -> Self {
         match n {
-            AnyCssDeclarationName::CssDashedIdentifier(it) => it.into_syntax(),
-            AnyCssDeclarationName::CssIdentifier(it) => it.into_syntax(),
-            AnyCssDeclarationName::TwValueThemeReference(it) => it.into_syntax(),
+            AnyCssContainerQuery::AnyCssContainerQueryInParens(it) => it.into_syntax(),
+            AnyCssContainerQuery::CssContainerAndQuery(it) => it.into_syntax(),
+            AnyCssContainerQuery::CssContainerNotQuery(it) => it.into_syntax(),
+            AnyCssContainerQuery::CssContainerOrQuery(it) => it.into_syntax(),
         }
     }
 }
-impl From<AnyCssDeclarationName> for SyntaxElement {
-    fn from(n: AnyCssDeclarationName) -> Self {
+impl From<AnyCssContainerQuery> for SyntaxElement {
+    fn from(n: AnyCssContainerQuery) -> Self {
         let node: SyntaxNode = n.into();
         node.into()
     }
 }
-impl From<CssAtRule> for AnyCssDeclarationOrAtRule {
-    fn from(node: CssAtRule) -> Self {
-        Self::CssAtRule(node)
+impl From<CssContainerQueryInParens> for AnyCssContainerQueryInParens {
+    fn from(node: CssContainerQueryInParens) -> Self {
+        Self::CssContainerQueryInParens(node)
     }
 }
-impl From<CssDeclarationWithSemicolon> for AnyCssDeclarationOrAtRule {
-    fn from(node: CssDeclarationWithSemicolon) -> Self {
-        Self::CssDeclarationWithSemicolon(node)
+impl From<CssContainerSizeFeatureInParens> for AnyCssContainerQueryInParens {
+    fn from(node: CssContainerSizeFeatureInParens) -> Self {
+        Self::CssContainerSizeFeatureInParens(node)
     }
 }
-impl From<CssEmptyDeclaration> for AnyCssDeclarationOrAtRule {
-    fn from(node: CssEmptyDeclaration) -> Self {
-        Self::CssEmptyDeclaration(node)
+impl From<CssContainerStyleQueryInParens> for AnyCssContainerQueryInParens {
+    fn from(node: CssContainerStyleQueryInParens) -> Self {
+        Self::CssContainerStyleQueryInParens(node)
     }
 }
-impl AstNode for AnyCssDeclarationOrAtRule {
+impl AstNode for AnyCssContainerQueryInParens {
     type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> = CssAtRule::KIND_SET
-        .union(CssDeclarationWithSemicolon::KIND_SET)
-        .union(CssEmptyDeclaration::KIND_SET);
+    const KIND_SET: SyntaxKindSet<Language> = CssContainerQueryInParens::KIND_SET
+        .union(CssContainerSizeFeatureInParens::KIND_SET)
+        .union(CssContainerStyleQueryInParens::KIND_SET);
     fn can_cast(kind: SyntaxKind) -> bool {
         matches!(
             kind,
-            CSS_AT_RULE | CSS_DECLARATION_WITH_SEMICOLON | CSS_EMPTY_DECLARATION
+            CSS_CONTAINER_QUERY_IN_PARENS
+                | CSS_CONTAINER_SIZE_FEATURE_IN_PARENS
+                | CSS_CONTAINER_STYLE_QUERY_IN_PARENS
         )
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         let res = match syntax.kind() {
-            CSS_AT_RULE => Self::CssAtRule(CssAtRule { syntax }),
-            CSS_DECLARATION_WITH_SEMICOLON => {
-                Self::CssDeclarationWithSemicolon(CssDeclarationWithSemicolon { syntax })
+            CSS_CONTAINER_QUERY_IN_PARENS => {
+                Self::CssContainerQueryInParens(CssContainerQueryInParens { syntax })
+            }
+            CSS_CONTAINER_SIZE_FEATURE_IN_PARENS => {
+                Self::CssContainerSizeFeatureInParens(CssContainerSizeFeatureInParens { syntax })
+            }
+            CSS_CONTAINER_STYLE_QUERY_IN_PARENS => {
+                Self::CssContainerStyleQueryInParens(CssContainerStyleQueryInParens { syntax })
             }
-            CSS_EMPTY_DECLARATION => Self::CssEmptyDeclaration(CssEmptyDeclaration { syntax }),
             _ => return None,
         };
         Some(res)
     }
     fn syntax(&self) -> &SyntaxNode {
         match self {
-            Self::CssAtRule(it) => it.syntax(),
-            Self::CssDeclarationWithSemicolon(it) => it.syntax(),
-            Self::CssEmptyDeclaration(it) => it.syntax(),
+            Self::CssContainerQueryInParens(it) => it.syntax(),
+            Self::CssContainerSizeFeatureInParens(it) => it.syntax(),
+            Self::CssContainerStyleQueryInParens(it) => it.syntax(),
         }
     }
     fn into_syntax(self) -> SyntaxNode {
         match self {
-            Self::CssAtRule(it) => it.into_syntax(),
-            Self::CssDeclarationWithSemicolon(it) => it.into_syntax(),
-            Self::CssEmptyDeclaration(it) => it.into_syntax(),
+            Self::CssContainerQueryInParens(it) => it.into_syntax(),
+            Self::CssContainerSizeFeatureInParens(it) => it.into_syntax(),
+            Self::CssContainerStyleQueryInParens(it) => it.into_syntax(),
         }
     }
 }
-impl std::fmt::Debug for AnyCssDeclarationOrAtRule {
+impl std::fmt::Debug for AnyCssContainerQueryInParens {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         match self {
-            Self::CssAtRule(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssDeclarationWithSemicolon(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssEmptyDeclaration(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssContainerQueryInParens(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssContainerSizeFeatureInParens(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssContainerStyleQueryInParens(it) => std::fmt::Debug::fmt(it, f),
         }
     }
 }
-impl From<AnyCssDeclarationOrAtRule> for SyntaxNode {
-    fn from(n: AnyCssDeclarationOrAtRule) -> Self {
+impl From<AnyCssContainerQueryInParens> for SyntaxNode {
+    fn from(n: AnyCssContainerQueryInParens) -> Self {
         match n {
-            AnyCssDeclarationOrAtRule::CssAtRule(it) => it.into_syntax(),
-            AnyCssDeclarationOrAtRule::CssDeclarationWithSemicolon(it) => it.into_syntax(),
-            AnyCssDeclarationOrAtRule::CssEmptyDeclaration(it) => it.into_syntax(),
+            AnyCssContainerQueryInParens::CssContainerQueryInParens(it) => it.into_syntax(),
+            AnyCssContainerQueryInParens::CssContainerSizeFeatureInParens(it) => it.into_syntax(),
+            AnyCssContainerQueryInParens::CssContainerStyleQueryInParens(it) => it.into_syntax(),
         }
     }
 }
-impl From<AnyCssDeclarationOrAtRule> for SyntaxElement {
-    fn from(n: AnyCssDeclarationOrAtRule) -> Self {
+impl From<AnyCssContainerQueryInParens> for SyntaxElement {
+    fn from(n: AnyCssContainerQueryInParens) -> Self {
         let node: SyntaxNode = n.into();
         node.into()
     }
 }
-impl From<CssBogusBlock> for AnyCssDeclarationOrAtRuleBlock {
-    fn from(node: CssBogusBlock) -> Self {
-        Self::CssBogusBlock(node)
+impl From<CssContainerStyleAndQuery> for AnyCssContainerStyleAndCombinableQuery {
+    fn from(node: CssContainerStyleAndQuery) -> Self {
+        Self::CssContainerStyleAndQuery(node)
     }
 }
-impl From<CssDeclarationOrAtRuleBlock> for AnyCssDeclarationOrAtRuleBlock {
-    fn from(node: CssDeclarationOrAtRuleBlock) -> Self {
-        Self::CssDeclarationOrAtRuleBlock(node)
+impl From<CssContainerStyleInParens> for AnyCssContainerStyleAndCombinableQuery {
+    fn from(node: CssContainerStyleInParens) -> Self {
+        Self::CssContainerStyleInParens(node)
     }
 }
-impl AstNode for AnyCssDeclarationOrAtRuleBlock {
+impl AstNode for AnyCssContainerStyleAndCombinableQuery {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        CssBogusBlock::KIND_SET.union(CssDeclarationOrAtRuleBlock::KIND_SET);
+        CssContainerStyleAndQuery::KIND_SET.union(CssContainerStyleInParens::KIND_SET);
     fn can_cast(kind: SyntaxKind) -> bool {
-        matches!(kind, CSS_BOGUS_BLOCK | CSS_DECLARATION_OR_AT_RULE_BLOCK)
+        matches!(
+            kind,
+            CSS_CONTAINER_STYLE_AND_QUERY | CSS_CONTAINER_STYLE_IN_PARENS
+        )
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         let res = match syntax.kind() {
-            CSS_BOGUS_BLOCK => Self::CssBogusBlock(CssBogusBlock { syntax }),
-            CSS_DECLARATION_OR_AT_RULE_BLOCK => {
-                Self::CssDeclarationOrAtRuleBlock(CssDeclarationOrAtRuleBlock { syntax })
+            CSS_CONTAINER_STYLE_AND_QUERY => {
+                Self::CssContainerStyleAndQuery(CssContainerStyleAndQuery { syntax })
+            }
+            CSS_CONTAINER_STYLE_IN_PARENS => {
+                Self::CssContainerStyleInParens(CssContainerStyleInParens { syntax })
             }
             _ => return None,
         };
@@ -23331,87 +21398,68 @@ impl AstNode for AnyCssDeclarationOrAtRuleBlock {
     }
     fn syntax(&self) -> &SyntaxNode {
         match self {
-            Self::CssBogusBlock(it) => it.syntax(),
-            Self::CssDeclarationOrAtRuleBlock(it) => it.syntax(),
+            Self::CssContainerStyleAndQuery(it) => it.syntax(),
+            Self::CssContainerStyleInParens(it) => it.syntax(),
         }
     }
     fn into_syntax(self) -> SyntaxNode {
         match self {
-            Self::CssBogusBlock(it) => it.into_syntax(),
-            Self::CssDeclarationOrAtRuleBlock(it) => it.into_syntax(),
+            Self::CssContainerStyleAndQuery(it) => it.into_syntax(),
+            Self::CssContainerStyleInParens(it) => it.into_syntax(),
         }
     }
 }
-impl std::fmt::Debug for AnyCssDeclarationOrAtRuleBlock {
+impl std::fmt::Debug for AnyCssContainerStyleAndCombinableQuery {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         match self {
-            Self::CssBogusBlock(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssDeclarationOrAtRuleBlock(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssContainerStyleAndQuery(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssContainerStyleInParens(it) => std::fmt::Debug::fmt(it, f),
         }
     }
 }
-impl From<AnyCssDeclarationOrAtRuleBlock> for SyntaxNode {
-    fn from(n: AnyCssDeclarationOrAtRuleBlock) -> Self {
+impl From<AnyCssContainerStyleAndCombinableQuery> for SyntaxNode {
+    fn from(n: AnyCssContainerStyleAndCombinableQuery) -> Self {
         match n {
-            AnyCssDeclarationOrAtRuleBlock::CssBogusBlock(it) => it.into_syntax(),
-            AnyCssDeclarationOrAtRuleBlock::CssDeclarationOrAtRuleBlock(it) => it.into_syntax(),
+            AnyCssContainerStyleAndCombinableQuery::CssContainerStyleAndQuery(it) => {
+                it.into_syntax()
+            }
+            AnyCssContainerStyleAndCombinableQuery::CssContainerStyleInParens(it) => {
+                it.into_syntax()
+            }
         }
     }
 }
-impl From<AnyCssDeclarationOrAtRuleBlock> for SyntaxElement {
-    fn from(n: AnyCssDeclarationOrAtRuleBlock) -> Self {
+impl From<AnyCssContainerStyleAndCombinableQuery> for SyntaxElement {
+    fn from(n: AnyCssContainerStyleAndCombinableQuery) -> Self {
         let node: SyntaxNode = n.into();
         node.into()
     }
 }
-impl From<CssBogus> for AnyCssDeclarationOrRule {
-    fn from(node: CssBogus) -> Self {
-        Self::CssBogus(node)
-    }
-}
-impl From<CssDeclarationWithSemicolon> for AnyCssDeclarationOrRule {
-    fn from(node: CssDeclarationWithSemicolon) -> Self {
-        Self::CssDeclarationWithSemicolon(node)
-    }
-}
-impl From<CssEmptyDeclaration> for AnyCssDeclarationOrRule {
-    fn from(node: CssEmptyDeclaration) -> Self {
-        Self::CssEmptyDeclaration(node)
-    }
-}
-impl From<CssMetavariable> for AnyCssDeclarationOrRule {
-    fn from(node: CssMetavariable) -> Self {
-        Self::CssMetavariable(node)
+impl From<CssDeclaration> for AnyCssContainerStyleInParens {
+    fn from(node: CssDeclaration) -> Self {
+        Self::CssDeclaration(node)
     }
 }
-impl AstNode for AnyCssDeclarationOrRule {
+impl AstNode for AnyCssContainerStyleInParens {
     type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> = AnyCssRule::KIND_SET
-        .union(CssBogus::KIND_SET)
-        .union(CssDeclarationWithSemicolon::KIND_SET)
-        .union(CssEmptyDeclaration::KIND_SET)
-        .union(CssMetavariable::KIND_SET);
+    const KIND_SET: SyntaxKindSet<Language> =
+        AnyCssContainerStyleQuery::KIND_SET.union(CssDeclaration::KIND_SET);
     fn can_cast(kind: SyntaxKind) -> bool {
         match kind {
-            CSS_BOGUS
-            | CSS_DECLARATION_WITH_SEMICOLON
-            | CSS_EMPTY_DECLARATION
-            | CSS_METAVARIABLE => true,
-            k if AnyCssRule::can_cast(k) => true,
+            CSS_DECLARATION => true,
+            k if AnyCssContainerStyleQuery::can_cast(k) => true,
             _ => false,
         }
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         let res = match syntax.kind() {
-            CSS_BOGUS => Self::CssBogus(CssBogus { syntax }),
-            CSS_DECLARATION_WITH_SEMICOLON => {
-                Self::CssDeclarationWithSemicolon(CssDeclarationWithSemicolon { syntax })
-            }
-            CSS_EMPTY_DECLARATION => Self::CssEmptyDeclaration(CssEmptyDeclaration { syntax }),
-            CSS_METAVARIABLE => Self::CssMetavariable(CssMetavariable { syntax }),
+            CSS_DECLARATION => Self::CssDeclaration(CssDeclaration { syntax }),
             _ => {
-                if let Some(any_css_rule) = AnyCssRule::cast(syntax) {
-                    return Some(Self::AnyCssRule(any_css_rule));
+                if let Some(any_css_container_style_query) = AnyCssContainerStyleQuery::cast(syntax)
+                {
+                    return Some(Self::AnyCssContainerStyleQuery(
+                        any_css_container_style_query,
+                    ));
                 }
                 return None;
             }
@@ -23420,73 +21468,66 @@ impl AstNode for AnyCssDeclarationOrRule {
     }
     fn syntax(&self) -> &SyntaxNode {
         match self {
-            Self::CssBogus(it) => it.syntax(),
-            Self::CssDeclarationWithSemicolon(it) => it.syntax(),
-            Self::CssEmptyDeclaration(it) => it.syntax(),
-            Self::CssMetavariable(it) => it.syntax(),
-            Self::AnyCssRule(it) => it.syntax(),
+            Self::CssDeclaration(it) => it.syntax(),
+            Self::AnyCssContainerStyleQuery(it) => it.syntax(),
         }
     }
     fn into_syntax(self) -> SyntaxNode {
         match self {
-            Self::CssBogus(it) => it.into_syntax(),
-            Self::CssDeclarationWithSemicolon(it) => it.into_syntax(),
-            Self::CssEmptyDeclaration(it) => it.into_syntax(),
-            Self::CssMetavariable(it) => it.into_syntax(),
-            Self::AnyCssRule(it) => it.into_syntax(),
+            Self::CssDeclaration(it) => it.into_syntax(),
+            Self::AnyCssContainerStyleQuery(it) => it.into_syntax(),
         }
     }
 }
-impl std::fmt::Debug for AnyCssDeclarationOrRule {
+impl std::fmt::Debug for AnyCssContainerStyleInParens {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         match self {
-            Self::AnyCssRule(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssBogus(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssDeclarationWithSemicolon(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssEmptyDeclaration(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssMetavariable(it) => std::fmt::Debug::fmt(it, f),
+            Self::AnyCssContainerStyleQuery(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssDeclaration(it) => std::fmt::Debug::fmt(it, f),
         }
     }
 }
-impl From<AnyCssDeclarationOrRule> for SyntaxNode {
-    fn from(n: AnyCssDeclarationOrRule) -> Self {
+impl From<AnyCssContainerStyleInParens> for SyntaxNode {
+    fn from(n: AnyCssContainerStyleInParens) -> Self {
         match n {
-            AnyCssDeclarationOrRule::AnyCssRule(it) => it.into_syntax(),
-            AnyCssDeclarationOrRule::CssBogus(it) => it.into_syntax(),
-            AnyCssDeclarationOrRule::CssDeclarationWithSemicolon(it) => it.into_syntax(),
-            AnyCssDeclarationOrRule::CssEmptyDeclaration(it) => it.into_syntax(),
-            AnyCssDeclarationOrRule::CssMetavariable(it) => it.into_syntax(),
+            AnyCssContainerStyleInParens::AnyCssContainerStyleQuery(it) => it.into_syntax(),
+            AnyCssContainerStyleInParens::CssDeclaration(it) => it.into_syntax(),
         }
     }
 }
-impl From<AnyCssDeclarationOrRule> for SyntaxElement {
-    fn from(n: AnyCssDeclarationOrRule) -> Self {
+impl From<AnyCssContainerStyleInParens> for SyntaxElement {
+    fn from(n: AnyCssContainerStyleInParens) -> Self {
         let node: SyntaxNode = n.into();
         node.into()
     }
 }
-impl From<CssBogusBlock> for AnyCssDeclarationOrRuleBlock {
-    fn from(node: CssBogusBlock) -> Self {
-        Self::CssBogusBlock(node)
+impl From<CssContainerStyleInParens> for AnyCssContainerStyleOrCombinableQuery {
+    fn from(node: CssContainerStyleInParens) -> Self {
+        Self::CssContainerStyleInParens(node)
     }
 }
-impl From<CssDeclarationOrRuleBlock> for AnyCssDeclarationOrRuleBlock {
-    fn from(node: CssDeclarationOrRuleBlock) -> Self {
-        Self::CssDeclarationOrRuleBlock(node)
+impl From<CssContainerStyleOrQuery> for AnyCssContainerStyleOrCombinableQuery {
+    fn from(node: CssContainerStyleOrQuery) -> Self {
+        Self::CssContainerStyleOrQuery(node)
     }
 }
-impl AstNode for AnyCssDeclarationOrRuleBlock {
+impl AstNode for AnyCssContainerStyleOrCombinableQuery {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        CssBogusBlock::KIND_SET.union(CssDeclarationOrRuleBlock::KIND_SET);
+        CssContainerStyleInParens::KIND_SET.union(CssContainerStyleOrQuery::KIND_SET);
     fn can_cast(kind: SyntaxKind) -> bool {
-        matches!(kind, CSS_BOGUS_BLOCK | CSS_DECLARATION_OR_RULE_BLOCK)
+        matches!(
+            kind,
+            CSS_CONTAINER_STYLE_IN_PARENS | CSS_CONTAINER_STYLE_OR_QUERY
+        )
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         let res = match syntax.kind() {
-            CSS_BOGUS_BLOCK => Self::CssBogusBlock(CssBogusBlock { syntax }),
-            CSS_DECLARATION_OR_RULE_BLOCK => {
-                Self::CssDeclarationOrRuleBlock(CssDeclarationOrRuleBlock { syntax })
+            CSS_CONTAINER_STYLE_IN_PARENS => {
+                Self::CssContainerStyleInParens(CssContainerStyleInParens { syntax })
+            }
+            CSS_CONTAINER_STYLE_OR_QUERY => {
+                Self::CssContainerStyleOrQuery(CssContainerStyleOrQuery { syntax })
             }
             _ => return None,
         };
@@ -23494,371 +21535,365 @@ impl AstNode for AnyCssDeclarationOrRuleBlock {
     }
     fn syntax(&self) -> &SyntaxNode {
         match self {
-            Self::CssBogusBlock(it) => it.syntax(),
-            Self::CssDeclarationOrRuleBlock(it) => it.syntax(),
+            Self::CssContainerStyleInParens(it) => it.syntax(),
+            Self::CssContainerStyleOrQuery(it) => it.syntax(),
         }
     }
     fn into_syntax(self) -> SyntaxNode {
         match self {
-            Self::CssBogusBlock(it) => it.into_syntax(),
-            Self::CssDeclarationOrRuleBlock(it) => it.into_syntax(),
+            Self::CssContainerStyleInParens(it) => it.into_syntax(),
+            Self::CssContainerStyleOrQuery(it) => it.into_syntax(),
         }
     }
 }
-impl std::fmt::Debug for AnyCssDeclarationOrRuleBlock {
+impl std::fmt::Debug for AnyCssContainerStyleOrCombinableQuery {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         match self {
-            Self::CssBogusBlock(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssDeclarationOrRuleBlock(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssContainerStyleInParens(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssContainerStyleOrQuery(it) => std::fmt::Debug::fmt(it, f),
         }
     }
 }
-impl From<AnyCssDeclarationOrRuleBlock> for SyntaxNode {
-    fn from(n: AnyCssDeclarationOrRuleBlock) -> Self {
+impl From<AnyCssContainerStyleOrCombinableQuery> for SyntaxNode {
+    fn from(n: AnyCssContainerStyleOrCombinableQuery) -> Self {
         match n {
-            AnyCssDeclarationOrRuleBlock::CssBogusBlock(it) => it.into_syntax(),
-            AnyCssDeclarationOrRuleBlock::CssDeclarationOrRuleBlock(it) => it.into_syntax(),
+            AnyCssContainerStyleOrCombinableQuery::CssContainerStyleInParens(it) => {
+                it.into_syntax()
+            }
+            AnyCssContainerStyleOrCombinableQuery::CssContainerStyleOrQuery(it) => it.into_syntax(),
         }
     }
 }
-impl From<AnyCssDeclarationOrRuleBlock> for SyntaxElement {
-    fn from(n: AnyCssDeclarationOrRuleBlock) -> Self {
+impl From<AnyCssContainerStyleOrCombinableQuery> for SyntaxElement {
+    fn from(n: AnyCssContainerStyleOrCombinableQuery) -> Self {
         let node: SyntaxNode = n.into();
         node.into()
     }
 }
-impl From<CssPercentage> for AnyCssDimension {
-    fn from(node: CssPercentage) -> Self {
-        Self::CssPercentage(node)
+impl From<CssContainerStyleAndQuery> for AnyCssContainerStyleQuery {
+    fn from(node: CssContainerStyleAndQuery) -> Self {
+        Self::CssContainerStyleAndQuery(node)
     }
 }
-impl From<CssRegularDimension> for AnyCssDimension {
-    fn from(node: CssRegularDimension) -> Self {
-        Self::CssRegularDimension(node)
+impl From<CssContainerStyleInParens> for AnyCssContainerStyleQuery {
+    fn from(node: CssContainerStyleInParens) -> Self {
+        Self::CssContainerStyleInParens(node)
     }
 }
-impl From<CssUnknownDimension> for AnyCssDimension {
-    fn from(node: CssUnknownDimension) -> Self {
-        Self::CssUnknownDimension(node)
+impl From<CssContainerStyleNotQuery> for AnyCssContainerStyleQuery {
+    fn from(node: CssContainerStyleNotQuery) -> Self {
+        Self::CssContainerStyleNotQuery(node)
     }
 }
-impl AstNode for AnyCssDimension {
+impl From<CssContainerStyleOrQuery> for AnyCssContainerStyleQuery {
+    fn from(node: CssContainerStyleOrQuery) -> Self {
+        Self::CssContainerStyleOrQuery(node)
+    }
+}
+impl From<CssDeclaration> for AnyCssContainerStyleQuery {
+    fn from(node: CssDeclaration) -> Self {
+        Self::CssDeclaration(node)
+    }
+}
+impl AstNode for AnyCssContainerStyleQuery {
     type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> = CssPercentage::KIND_SET
-        .union(CssRegularDimension::KIND_SET)
-        .union(CssUnknownDimension::KIND_SET);
+    const KIND_SET: SyntaxKindSet<Language> = CssContainerStyleAndQuery::KIND_SET
+        .union(CssContainerStyleInParens::KIND_SET)
+        .union(CssContainerStyleNotQuery::KIND_SET)
+        .union(CssContainerStyleOrQuery::KIND_SET)
+        .union(CssDeclaration::KIND_SET);
     fn can_cast(kind: SyntaxKind) -> bool {
         matches!(
             kind,
-            CSS_PERCENTAGE | CSS_REGULAR_DIMENSION | CSS_UNKNOWN_DIMENSION
+            CSS_CONTAINER_STYLE_AND_QUERY
+                | CSS_CONTAINER_STYLE_IN_PARENS
+                | CSS_CONTAINER_STYLE_NOT_QUERY
+                | CSS_CONTAINER_STYLE_OR_QUERY
+                | CSS_DECLARATION
         )
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         let res = match syntax.kind() {
-            CSS_PERCENTAGE => Self::CssPercentage(CssPercentage { syntax }),
-            CSS_REGULAR_DIMENSION => Self::CssRegularDimension(CssRegularDimension { syntax }),
-            CSS_UNKNOWN_DIMENSION => Self::CssUnknownDimension(CssUnknownDimension { syntax }),
+            CSS_CONTAINER_STYLE_AND_QUERY => {
+                Self::CssContainerStyleAndQuery(CssContainerStyleAndQuery { syntax })
+            }
+            CSS_CONTAINER_STYLE_IN_PARENS => {
+                Self::CssContainerStyleInParens(CssContainerStyleInParens { syntax })
+            }
+            CSS_CONTAINER_STYLE_NOT_QUERY => {
+                Self::CssContainerStyleNotQuery(CssContainerStyleNotQuery { syntax })
+            }
+            CSS_CONTAINER_STYLE_OR_QUERY => {
+                Self::CssContainerStyleOrQuery(CssContainerStyleOrQuery { syntax })
+            }
+            CSS_DECLARATION => Self::CssDeclaration(CssDeclaration { syntax }),
             _ => return None,
         };
         Some(res)
     }
     fn syntax(&self) -> &SyntaxNode {
         match self {
-            Self::CssPercentage(it) => it.syntax(),
-            Self::CssRegularDimension(it) => it.syntax(),
-            Self::CssUnknownDimension(it) => it.syntax(),
+            Self::CssContainerStyleAndQuery(it) => it.syntax(),
+            Self::CssContainerStyleInParens(it) => it.syntax(),
+            Self::CssContainerStyleNotQuery(it) => it.syntax(),
+            Self::CssContainerStyleOrQuery(it) => it.syntax(),
+            Self::CssDeclaration(it) => it.syntax(),
         }
     }
     fn into_syntax(self) -> SyntaxNode {
         match self {
-            Self::CssPercentage(it) => it.into_syntax(),
-            Self::CssRegularDimension(it) => it.into_syntax(),
-            Self::CssUnknownDimension(it) => it.into_syntax(),
+            Self::CssContainerStyleAndQuery(it) => it.into_syntax(),
+            Self::CssContainerStyleInParens(it) => it.into_syntax(),
+            Self::CssContainerStyleNotQuery(it) => it.into_syntax(),
+            Self::CssContainerStyleOrQuery(it) => it.into_syntax(),
+            Self::CssDeclaration(it) => it.into_syntax(),
         }
     }
 }
-impl std::fmt::Debug for AnyCssDimension {
+impl std::fmt::Debug for AnyCssContainerStyleQuery {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         match self {
-            Self::CssPercentage(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssRegularDimension(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssUnknownDimension(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssContainerStyleAndQuery(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssContainerStyleInParens(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssContainerStyleNotQuery(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssContainerStyleOrQuery(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssDeclaration(it) => std::fmt::Debug::fmt(it, f),
         }
     }
 }
-impl From<AnyCssDimension> for SyntaxNode {
-    fn from(n: AnyCssDimension) -> Self {
+impl From<AnyCssContainerStyleQuery> for SyntaxNode {
+    fn from(n: AnyCssContainerStyleQuery) -> Self {
         match n {
-            AnyCssDimension::CssPercentage(it) => it.into_syntax(),
-            AnyCssDimension::CssRegularDimension(it) => it.into_syntax(),
-            AnyCssDimension::CssUnknownDimension(it) => it.into_syntax(),
+            AnyCssContainerStyleQuery::CssContainerStyleAndQuery(it) => it.into_syntax(),
+            AnyCssContainerStyleQuery::CssContainerStyleInParens(it) => it.into_syntax(),
+            AnyCssContainerStyleQuery::CssContainerStyleNotQuery(it) => it.into_syntax(),
+            AnyCssContainerStyleQuery::CssContainerStyleOrQuery(it) => it.into_syntax(),
+            AnyCssContainerStyleQuery::CssDeclaration(it) => it.into_syntax(),
         }
     }
 }
-impl From<AnyCssDimension> for SyntaxElement {
-    fn from(n: AnyCssDimension) -> Self {
+impl From<AnyCssContainerStyleQuery> for SyntaxElement {
+    fn from(n: AnyCssContainerStyleQuery) -> Self {
         let node: SyntaxNode = n.into();
         node.into()
     }
 }
-impl From<CssBogusDocumentMatcher> for AnyCssDocumentMatcher {
-    fn from(node: CssBogusDocumentMatcher) -> Self {
-        Self::CssBogusDocumentMatcher(node)
-    }
-}
-impl From<CssDocumentCustomMatcher> for AnyCssDocumentMatcher {
-    fn from(node: CssDocumentCustomMatcher) -> Self {
-        Self::CssDocumentCustomMatcher(node)
+impl From<CssBogusCustomIdentifier> for AnyCssCustomIdentifier {
+    fn from(node: CssBogusCustomIdentifier) -> Self {
+        Self::CssBogusCustomIdentifier(node)
     }
 }
-impl From<CssUrlFunction> for AnyCssDocumentMatcher {
-    fn from(node: CssUrlFunction) -> Self {
-        Self::CssUrlFunction(node)
+impl From<CssCustomIdentifier> for AnyCssCustomIdentifier {
+    fn from(node: CssCustomIdentifier) -> Self {
+        Self::CssCustomIdentifier(node)
     }
 }
-impl AstNode for AnyCssDocumentMatcher {
+impl AstNode for AnyCssCustomIdentifier {
     type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> = CssBogusDocumentMatcher::KIND_SET
-        .union(CssDocumentCustomMatcher::KIND_SET)
-        .union(CssUrlFunction::KIND_SET);
+    const KIND_SET: SyntaxKindSet<Language> =
+        CssBogusCustomIdentifier::KIND_SET.union(CssCustomIdentifier::KIND_SET);
     fn can_cast(kind: SyntaxKind) -> bool {
-        matches!(
-            kind,
-            CSS_BOGUS_DOCUMENT_MATCHER | CSS_DOCUMENT_CUSTOM_MATCHER | CSS_URL_FUNCTION
-        )
+        matches!(kind, CSS_BOGUS_CUSTOM_IDENTIFIER | CSS_CUSTOM_IDENTIFIER)
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         let res = match syntax.kind() {
-            CSS_BOGUS_DOCUMENT_MATCHER => {
-                Self::CssBogusDocumentMatcher(CssBogusDocumentMatcher { syntax })
-            }
-            CSS_DOCUMENT_CUSTOM_MATCHER => {
-                Self::CssDocumentCustomMatcher(CssDocumentCustomMatcher { syntax })
+            CSS_BOGUS_CUSTOM_IDENTIFIER => {
+                Self::CssBogusCustomIdentifier(CssBogusCustomIdentifier { syntax })
             }
-            CSS_URL_FUNCTION => Self::CssUrlFunction(CssUrlFunction { syntax }),
+            CSS_CUSTOM_IDENTIFIER => Self::CssCustomIdentifier(CssCustomIdentifier { syntax }),
             _ => return None,
         };
         Some(res)
     }
     fn syntax(&self) -> &SyntaxNode {
         match self {
-            Self::CssBogusDocumentMatcher(it) => it.syntax(),
-            Self::CssDocumentCustomMatcher(it) => it.syntax(),
-            Self::CssUrlFunction(it) => it.syntax(),
+            Self::CssBogusCustomIdentifier(it) => it.syntax(),
+            Self::CssCustomIdentifier(it) => it.syntax(),
         }
     }
     fn into_syntax(self) -> SyntaxNode {
         match self {
-            Self::CssBogusDocumentMatcher(it) => it.into_syntax(),
-            Self::CssDocumentCustomMatcher(it) => it.into_syntax(),
-            Self::CssUrlFunction(it) => it.into_syntax(),
+            Self::CssBogusCustomIdentifier(it) => it.into_syntax(),
+            Self::CssCustomIdentifier(it) => it.into_syntax(),
         }
     }
 }
-impl std::fmt::Debug for AnyCssDocumentMatcher {
+impl std::fmt::Debug for AnyCssCustomIdentifier {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         match self {
-            Self::CssBogusDocumentMatcher(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssDocumentCustomMatcher(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssUrlFunction(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssBogusCustomIdentifier(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssCustomIdentifier(it) => std::fmt::Debug::fmt(it, f),
         }
     }
 }
-impl From<AnyCssDocumentMatcher> for SyntaxNode {
-    fn from(n: AnyCssDocumentMatcher) -> Self {
+impl From<AnyCssCustomIdentifier> for SyntaxNode {
+    fn from(n: AnyCssCustomIdentifier) -> Self {
         match n {
-            AnyCssDocumentMatcher::CssBogusDocumentMatcher(it) => it.into_syntax(),
-            AnyCssDocumentMatcher::CssDocumentCustomMatcher(it) => it.into_syntax(),
-            AnyCssDocumentMatcher::CssUrlFunction(it) => it.into_syntax(),
+            AnyCssCustomIdentifier::CssBogusCustomIdentifier(it) => it.into_syntax(),
+            AnyCssCustomIdentifier::CssCustomIdentifier(it) => it.into_syntax(),
         }
     }
 }
-impl From<AnyCssDocumentMatcher> for SyntaxElement {
-    fn from(n: AnyCssDocumentMatcher) -> Self {
+impl From<AnyCssCustomIdentifier> for SyntaxElement {
+    fn from(n: AnyCssCustomIdentifier) -> Self {
         let node: SyntaxNode = n.into();
         node.into()
     }
 }
-impl From<CssBinaryExpression> for AnyCssExpression {
-    fn from(node: CssBinaryExpression) -> Self {
-        Self::CssBinaryExpression(node)
-    }
-}
-impl From<CssListOfComponentValuesExpression> for AnyCssExpression {
-    fn from(node: CssListOfComponentValuesExpression) -> Self {
-        Self::CssListOfComponentValuesExpression(node)
+impl From<CssDeclarationWithSemicolon> for AnyCssDeclaration {
+    fn from(node: CssDeclarationWithSemicolon) -> Self {
+        Self::CssDeclarationWithSemicolon(node)
     }
 }
-impl From<CssParenthesizedExpression> for AnyCssExpression {
-    fn from(node: CssParenthesizedExpression) -> Self {
-        Self::CssParenthesizedExpression(node)
+impl From<CssEmptyDeclaration> for AnyCssDeclaration {
+    fn from(node: CssEmptyDeclaration) -> Self {
+        Self::CssEmptyDeclaration(node)
     }
 }
-impl AstNode for AnyCssExpression {
+impl AstNode for AnyCssDeclaration {
     type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> = CssBinaryExpression::KIND_SET
-        .union(CssListOfComponentValuesExpression::KIND_SET)
-        .union(CssParenthesizedExpression::KIND_SET);
+    const KIND_SET: SyntaxKindSet<Language> =
+        CssDeclarationWithSemicolon::KIND_SET.union(CssEmptyDeclaration::KIND_SET);
     fn can_cast(kind: SyntaxKind) -> bool {
-        matches!(
-            kind,
-            CSS_BINARY_EXPRESSION
-                | CSS_LIST_OF_COMPONENT_VALUES_EXPRESSION
-                | CSS_PARENTHESIZED_EXPRESSION
-        )
+        matches!(kind, CSS_DECLARATION_WITH_SEMICOLON | CSS_EMPTY_DECLARATION)
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         let res = match syntax.kind() {
-            CSS_BINARY_EXPRESSION => Self::CssBinaryExpression(CssBinaryExpression { syntax }),
-            CSS_LIST_OF_COMPONENT_VALUES_EXPRESSION => {
-                Self::CssListOfComponentValuesExpression(CssListOfComponentValuesExpression {
-                    syntax,
-                })
-            }
-            CSS_PARENTHESIZED_EXPRESSION => {
-                Self::CssParenthesizedExpression(CssParenthesizedExpression { syntax })
+            CSS_DECLARATION_WITH_SEMICOLON => {
+                Self::CssDeclarationWithSemicolon(CssDeclarationWithSemicolon { syntax })
             }
+            CSS_EMPTY_DECLARATION => Self::CssEmptyDeclaration(CssEmptyDeclaration { syntax }),
             _ => return None,
         };
         Some(res)
     }
     fn syntax(&self) -> &SyntaxNode {
         match self {
-            Self::CssBinaryExpression(it) => it.syntax(),
-            Self::CssListOfComponentValuesExpression(it) => it.syntax(),
-            Self::CssParenthesizedExpression(it) => it.syntax(),
+            Self::CssDeclarationWithSemicolon(it) => it.syntax(),
+            Self::CssEmptyDeclaration(it) => it.syntax(),
         }
     }
     fn into_syntax(self) -> SyntaxNode {
         match self {
-            Self::CssBinaryExpression(it) => it.into_syntax(),
-            Self::CssListOfComponentValuesExpression(it) => it.into_syntax(),
-            Self::CssParenthesizedExpression(it) => it.into_syntax(),
+            Self::CssDeclarationWithSemicolon(it) => it.into_syntax(),
+            Self::CssEmptyDeclaration(it) => it.into_syntax(),
         }
     }
 }
-impl std::fmt::Debug for AnyCssExpression {
+impl std::fmt::Debug for AnyCssDeclaration {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         match self {
-            Self::CssBinaryExpression(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssListOfComponentValuesExpression(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssParenthesizedExpression(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssDeclarationWithSemicolon(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssEmptyDeclaration(it) => std::fmt::Debug::fmt(it, f),
         }
     }
 }
-impl From<AnyCssExpression> for SyntaxNode {
-    fn from(n: AnyCssExpression) -> Self {
+impl From<AnyCssDeclaration> for SyntaxNode {
+    fn from(n: AnyCssDeclaration) -> Self {
         match n {
-            AnyCssExpression::CssBinaryExpression(it) => it.into_syntax(),
-            AnyCssExpression::CssListOfComponentValuesExpression(it) => it.into_syntax(),
-            AnyCssExpression::CssParenthesizedExpression(it) => it.into_syntax(),
+            AnyCssDeclaration::CssDeclarationWithSemicolon(it) => it.into_syntax(),
+            AnyCssDeclaration::CssEmptyDeclaration(it) => it.into_syntax(),
         }
     }
 }
-impl From<AnyCssExpression> for SyntaxElement {
-    fn from(n: AnyCssExpression) -> Self {
+impl From<AnyCssDeclaration> for SyntaxElement {
+    fn from(n: AnyCssDeclaration) -> Self {
         let node: SyntaxNode = n.into();
         node.into()
     }
 }
-impl From<CssBogusFontFamilyName> for AnyCssFontFamilyName {
-    fn from(node: CssBogusFontFamilyName) -> Self {
-        Self::CssBogusFontFamilyName(node)
-    }
-}
-impl From<CssFontFamilyName> for AnyCssFontFamilyName {
-    fn from(node: CssFontFamilyName) -> Self {
-        Self::CssFontFamilyName(node)
+impl From<CssBogusBlock> for AnyCssDeclarationBlock {
+    fn from(node: CssBogusBlock) -> Self {
+        Self::CssBogusBlock(node)
     }
 }
-impl From<CssString> for AnyCssFontFamilyName {
-    fn from(node: CssString) -> Self {
-        Self::CssString(node)
+impl From<CssDeclarationBlock> for AnyCssDeclarationBlock {
+    fn from(node: CssDeclarationBlock) -> Self {
+        Self::CssDeclarationBlock(node)
     }
 }
-impl AstNode for AnyCssFontFamilyName {
+impl AstNode for AnyCssDeclarationBlock {
     type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> = CssBogusFontFamilyName::KIND_SET
-        .union(CssFontFamilyName::KIND_SET)
-        .union(CssString::KIND_SET);
+    const KIND_SET: SyntaxKindSet<Language> =
+        CssBogusBlock::KIND_SET.union(CssDeclarationBlock::KIND_SET);
     fn can_cast(kind: SyntaxKind) -> bool {
-        matches!(
-            kind,
-            CSS_BOGUS_FONT_FAMILY_NAME | CSS_FONT_FAMILY_NAME | CSS_STRING
-        )
+        matches!(kind, CSS_BOGUS_BLOCK | CSS_DECLARATION_BLOCK)
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         let res = match syntax.kind() {
-            CSS_BOGUS_FONT_FAMILY_NAME => {
-                Self::CssBogusFontFamilyName(CssBogusFontFamilyName { syntax })
-            }
-            CSS_FONT_FAMILY_NAME => Self::CssFontFamilyName(CssFontFamilyName { syntax }),
-            CSS_STRING => Self::CssString(CssString { syntax }),
+            CSS_BOGUS_BLOCK => Self::CssBogusBlock(CssBogusBlock { syntax }),
+            CSS_DECLARATION_BLOCK => Self::CssDeclarationBlock(CssDeclarationBlock { syntax }),
             _ => return None,
         };
         Some(res)
     }
     fn syntax(&self) -> &SyntaxNode {
         match self {
-            Self::CssBogusFontFamilyName(it) => it.syntax(),
-            Self::CssFontFamilyName(it) => it.syntax(),
-            Self::CssString(it) => it.syntax(),
+            Self::CssBogusBlock(it) => it.syntax(),
+            Self::CssDeclarationBlock(it) => it.syntax(),
         }
     }
     fn into_syntax(self) -> SyntaxNode {
         match self {
-            Self::CssBogusFontFamilyName(it) => it.into_syntax(),
-            Self::CssFontFamilyName(it) => it.into_syntax(),
-            Self::CssString(it) => it.into_syntax(),
+            Self::CssBogusBlock(it) => it.into_syntax(),
+            Self::CssDeclarationBlock(it) => it.into_syntax(),
         }
     }
 }
-impl std::fmt::Debug for AnyCssFontFamilyName {
+impl std::fmt::Debug for AnyCssDeclarationBlock {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         match self {
-            Self::CssBogusFontFamilyName(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssFontFamilyName(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssString(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssBogusBlock(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssDeclarationBlock(it) => std::fmt::Debug::fmt(it, f),
         }
     }
 }
-impl From<AnyCssFontFamilyName> for SyntaxNode {
-    fn from(n: AnyCssFontFamilyName) -> Self {
+impl From<AnyCssDeclarationBlock> for SyntaxNode {
+    fn from(n: AnyCssDeclarationBlock) -> Self {
         match n {
-            AnyCssFontFamilyName::CssBogusFontFamilyName(it) => it.into_syntax(),
-            AnyCssFontFamilyName::CssFontFamilyName(it) => it.into_syntax(),
-            AnyCssFontFamilyName::CssString(it) => it.into_syntax(),
+            AnyCssDeclarationBlock::CssBogusBlock(it) => it.into_syntax(),
+            AnyCssDeclarationBlock::CssDeclarationBlock(it) => it.into_syntax(),
         }
     }
 }
-impl From<AnyCssFontFamilyName> for SyntaxElement {
-    fn from(n: AnyCssFontFamilyName) -> Self {
+impl From<AnyCssDeclarationBlock> for SyntaxElement {
+    fn from(n: AnyCssDeclarationBlock) -> Self {
         let node: SyntaxNode = n.into();
         node.into()
     }
 }
-impl From<CssBogusBlock> for AnyCssFontFeatureValuesBlock {
-    fn from(node: CssBogusBlock) -> Self {
-        Self::CssBogusBlock(node)
+impl From<CssDashedIdentifier> for AnyCssDeclarationName {
+    fn from(node: CssDashedIdentifier) -> Self {
+        Self::CssDashedIdentifier(node)
     }
 }
-impl From<CssFontFeatureValuesBlock> for AnyCssFontFeatureValuesBlock {
-    fn from(node: CssFontFeatureValuesBlock) -> Self {
-        Self::CssFontFeatureValuesBlock(node)
+impl From<CssIdentifier> for AnyCssDeclarationName {
+    fn from(node: CssIdentifier) -> Self {
+        Self::CssIdentifier(node)
     }
 }
-impl AstNode for AnyCssFontFeatureValuesBlock {
+impl From<TwValueThemeReference> for AnyCssDeclarationName {
+    fn from(node: TwValueThemeReference) -> Self {
+        Self::TwValueThemeReference(node)
+    }
+}
+impl AstNode for AnyCssDeclarationName {
     type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> =
-        CssBogusBlock::KIND_SET.union(CssFontFeatureValuesBlock::KIND_SET);
+    const KIND_SET: SyntaxKindSet<Language> = CssDashedIdentifier::KIND_SET
+        .union(CssIdentifier::KIND_SET)
+        .union(TwValueThemeReference::KIND_SET);
     fn can_cast(kind: SyntaxKind) -> bool {
-        matches!(kind, CSS_BOGUS_BLOCK | CSS_FONT_FEATURE_VALUES_BLOCK)
+        matches!(
+            kind,
+            CSS_DASHED_IDENTIFIER | CSS_IDENTIFIER | TW_VALUE_THEME_REFERENCE
+        )
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         let res = match syntax.kind() {
-            CSS_BOGUS_BLOCK => Self::CssBogusBlock(CssBogusBlock { syntax }),
-            CSS_FONT_FEATURE_VALUES_BLOCK => {
-                Self::CssFontFeatureValuesBlock(CssFontFeatureValuesBlock { syntax })
+            CSS_DASHED_IDENTIFIER => Self::CssDashedIdentifier(CssDashedIdentifier { syntax }),
+            CSS_IDENTIFIER => Self::CssIdentifier(CssIdentifier { syntax }),
+            TW_VALUE_THEME_REFERENCE => {
+                Self::TwValueThemeReference(TwValueThemeReference { syntax })
             }
             _ => return None,
         };
@@ -23866,199 +21901,229 @@ impl AstNode for AnyCssFontFeatureValuesBlock {
     }
     fn syntax(&self) -> &SyntaxNode {
         match self {
-            Self::CssBogusBlock(it) => it.syntax(),
-            Self::CssFontFeatureValuesBlock(it) => it.syntax(),
+            Self::CssDashedIdentifier(it) => it.syntax(),
+            Self::CssIdentifier(it) => it.syntax(),
+            Self::TwValueThemeReference(it) => it.syntax(),
         }
     }
     fn into_syntax(self) -> SyntaxNode {
         match self {
-            Self::CssBogusBlock(it) => it.into_syntax(),
-            Self::CssFontFeatureValuesBlock(it) => it.into_syntax(),
+            Self::CssDashedIdentifier(it) => it.into_syntax(),
+            Self::CssIdentifier(it) => it.into_syntax(),
+            Self::TwValueThemeReference(it) => it.into_syntax(),
         }
     }
 }
-impl std::fmt::Debug for AnyCssFontFeatureValuesBlock {
+impl std::fmt::Debug for AnyCssDeclarationName {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         match self {
-            Self::CssBogusBlock(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssFontFeatureValuesBlock(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssDashedIdentifier(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssIdentifier(it) => std::fmt::Debug::fmt(it, f),
+            Self::TwValueThemeReference(it) => std::fmt::Debug::fmt(it, f),
         }
     }
 }
-impl From<AnyCssFontFeatureValuesBlock> for SyntaxNode {
-    fn from(n: AnyCssFontFeatureValuesBlock) -> Self {
+impl From<AnyCssDeclarationName> for SyntaxNode {
+    fn from(n: AnyCssDeclarationName) -> Self {
         match n {
-            AnyCssFontFeatureValuesBlock::CssBogusBlock(it) => it.into_syntax(),
-            AnyCssFontFeatureValuesBlock::CssFontFeatureValuesBlock(it) => it.into_syntax(),
+            AnyCssDeclarationName::CssDashedIdentifier(it) => it.into_syntax(),
+            AnyCssDeclarationName::CssIdentifier(it) => it.into_syntax(),
+            AnyCssDeclarationName::TwValueThemeReference(it) => it.into_syntax(),
         }
     }
 }
-impl From<AnyCssFontFeatureValuesBlock> for SyntaxElement {
-    fn from(n: AnyCssFontFeatureValuesBlock) -> Self {
+impl From<AnyCssDeclarationName> for SyntaxElement {
+    fn from(n: AnyCssDeclarationName) -> Self {
         let node: SyntaxNode = n.into();
         node.into()
     }
 }
-impl From<CssBogusFontFeatureValuesItem> for AnyCssFontFeatureValuesItem {
-    fn from(node: CssBogusFontFeatureValuesItem) -> Self {
-        Self::CssBogusFontFeatureValuesItem(node)
+impl From<CssAtRule> for AnyCssDeclarationOrAtRule {
+    fn from(node: CssAtRule) -> Self {
+        Self::CssAtRule(node)
     }
 }
-impl From<CssFontFeatureValuesItem> for AnyCssFontFeatureValuesItem {
-    fn from(node: CssFontFeatureValuesItem) -> Self {
-        Self::CssFontFeatureValuesItem(node)
+impl From<CssDeclarationWithSemicolon> for AnyCssDeclarationOrAtRule {
+    fn from(node: CssDeclarationWithSemicolon) -> Self {
+        Self::CssDeclarationWithSemicolon(node)
     }
 }
-impl AstNode for AnyCssFontFeatureValuesItem {
+impl From<CssEmptyDeclaration> for AnyCssDeclarationOrAtRule {
+    fn from(node: CssEmptyDeclaration) -> Self {
+        Self::CssEmptyDeclaration(node)
+    }
+}
+impl AstNode for AnyCssDeclarationOrAtRule {
     type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> =
-        CssBogusFontFeatureValuesItem::KIND_SET.union(CssFontFeatureValuesItem::KIND_SET);
+    const KIND_SET: SyntaxKindSet<Language> = CssAtRule::KIND_SET
+        .union(CssDeclarationWithSemicolon::KIND_SET)
+        .union(CssEmptyDeclaration::KIND_SET);
     fn can_cast(kind: SyntaxKind) -> bool {
         matches!(
             kind,
-            CSS_BOGUS_FONT_FEATURE_VALUES_ITEM | CSS_FONT_FEATURE_VALUES_ITEM
+            CSS_AT_RULE | CSS_DECLARATION_WITH_SEMICOLON | CSS_EMPTY_DECLARATION
         )
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         let res = match syntax.kind() {
-            CSS_BOGUS_FONT_FEATURE_VALUES_ITEM => {
-                Self::CssBogusFontFeatureValuesItem(CssBogusFontFeatureValuesItem { syntax })
-            }
-            CSS_FONT_FEATURE_VALUES_ITEM => {
-                Self::CssFontFeatureValuesItem(CssFontFeatureValuesItem { syntax })
+            CSS_AT_RULE => Self::CssAtRule(CssAtRule { syntax }),
+            CSS_DECLARATION_WITH_SEMICOLON => {
+                Self::CssDeclarationWithSemicolon(CssDeclarationWithSemicolon { syntax })
             }
+            CSS_EMPTY_DECLARATION => Self::CssEmptyDeclaration(CssEmptyDeclaration { syntax }),
             _ => return None,
         };
         Some(res)
     }
     fn syntax(&self) -> &SyntaxNode {
         match self {
-            Self::CssBogusFontFeatureValuesItem(it) => it.syntax(),
-            Self::CssFontFeatureValuesItem(it) => it.syntax(),
+            Self::CssAtRule(it) => it.syntax(),
+            Self::CssDeclarationWithSemicolon(it) => it.syntax(),
+            Self::CssEmptyDeclaration(it) => it.syntax(),
         }
     }
     fn into_syntax(self) -> SyntaxNode {
-        match self {
-            Self::CssBogusFontFeatureValuesItem(it) => it.into_syntax(),
-            Self::CssFontFeatureValuesItem(it) => it.into_syntax(),
+        match self {
+            Self::CssAtRule(it) => it.into_syntax(),
+            Self::CssDeclarationWithSemicolon(it) => it.into_syntax(),
+            Self::CssEmptyDeclaration(it) => it.into_syntax(),
         }
     }
 }
-impl std::fmt::Debug for AnyCssFontFeatureValuesItem {
+impl std::fmt::Debug for AnyCssDeclarationOrAtRule {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         match self {
-            Self::CssBogusFontFeatureValuesItem(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssFontFeatureValuesItem(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssAtRule(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssDeclarationWithSemicolon(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssEmptyDeclaration(it) => std::fmt::Debug::fmt(it, f),
         }
     }
 }
-impl From<AnyCssFontFeatureValuesItem> for SyntaxNode {
-    fn from(n: AnyCssFontFeatureValuesItem) -> Self {
+impl From<AnyCssDeclarationOrAtRule> for SyntaxNode {
+    fn from(n: AnyCssDeclarationOrAtRule) -> Self {
         match n {
-            AnyCssFontFeatureValuesItem::CssBogusFontFeatureValuesItem(it) => it.into_syntax(),
-            AnyCssFontFeatureValuesItem::CssFontFeatureValuesItem(it) => it.into_syntax(),
+            AnyCssDeclarationOrAtRule::CssAtRule(it) => it.into_syntax(),
+            AnyCssDeclarationOrAtRule::CssDeclarationWithSemicolon(it) => it.into_syntax(),
+            AnyCssDeclarationOrAtRule::CssEmptyDeclaration(it) => it.into_syntax(),
         }
     }
 }
-impl From<AnyCssFontFeatureValuesItem> for SyntaxElement {
-    fn from(n: AnyCssFontFeatureValuesItem) -> Self {
+impl From<AnyCssDeclarationOrAtRule> for SyntaxElement {
+    fn from(n: AnyCssDeclarationOrAtRule) -> Self {
         let node: SyntaxNode = n.into();
         node.into()
     }
 }
-impl From<CssFunction> for AnyCssFunction {
-    fn from(node: CssFunction) -> Self {
-        Self::CssFunction(node)
-    }
-}
-impl From<CssIfFunction> for AnyCssFunction {
-    fn from(node: CssIfFunction) -> Self {
-        Self::CssIfFunction(node)
+impl From<CssBogusBlock> for AnyCssDeclarationOrAtRuleBlock {
+    fn from(node: CssBogusBlock) -> Self {
+        Self::CssBogusBlock(node)
     }
 }
-impl From<CssUrlFunction> for AnyCssFunction {
-    fn from(node: CssUrlFunction) -> Self {
-        Self::CssUrlFunction(node)
+impl From<CssDeclarationOrAtRuleBlock> for AnyCssDeclarationOrAtRuleBlock {
+    fn from(node: CssDeclarationOrAtRuleBlock) -> Self {
+        Self::CssDeclarationOrAtRuleBlock(node)
     }
 }
-impl AstNode for AnyCssFunction {
+impl AstNode for AnyCssDeclarationOrAtRuleBlock {
     type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> = CssFunction::KIND_SET
-        .union(CssIfFunction::KIND_SET)
-        .union(CssUrlFunction::KIND_SET);
+    const KIND_SET: SyntaxKindSet<Language> =
+        CssBogusBlock::KIND_SET.union(CssDeclarationOrAtRuleBlock::KIND_SET);
     fn can_cast(kind: SyntaxKind) -> bool {
-        matches!(kind, CSS_FUNCTION | CSS_IF_FUNCTION | CSS_URL_FUNCTION)
+        matches!(kind, CSS_BOGUS_BLOCK | CSS_DECLARATION_OR_AT_RULE_BLOCK)
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         let res = match syntax.kind() {
-            CSS_FUNCTION => Self::CssFunction(CssFunction { syntax }),
-            CSS_IF_FUNCTION => Self::CssIfFunction(CssIfFunction { syntax }),
-            CSS_URL_FUNCTION => Self::CssUrlFunction(CssUrlFunction { syntax }),
+            CSS_BOGUS_BLOCK => Self::CssBogusBlock(CssBogusBlock { syntax }),
+            CSS_DECLARATION_OR_AT_RULE_BLOCK => {
+                Self::CssDeclarationOrAtRuleBlock(CssDeclarationOrAtRuleBlock { syntax })
+            }
             _ => return None,
         };
         Some(res)
     }
     fn syntax(&self) -> &SyntaxNode {
         match self {
-            Self::CssFunction(it) => it.syntax(),
-            Self::CssIfFunction(it) => it.syntax(),
-            Self::CssUrlFunction(it) => it.syntax(),
+            Self::CssBogusBlock(it) => it.syntax(),
+            Self::CssDeclarationOrAtRuleBlock(it) => it.syntax(),
         }
     }
     fn into_syntax(self) -> SyntaxNode {
         match self {
-            Self::CssFunction(it) => it.into_syntax(),
-            Self::CssIfFunction(it) => it.into_syntax(),
-            Self::CssUrlFunction(it) => it.into_syntax(),
+            Self::CssBogusBlock(it) => it.into_syntax(),
+            Self::CssDeclarationOrAtRuleBlock(it) => it.into_syntax(),
         }
     }
 }
-impl std::fmt::Debug for AnyCssFunction {
+impl std::fmt::Debug for AnyCssDeclarationOrAtRuleBlock {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         match self {
-            Self::CssFunction(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssIfFunction(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssUrlFunction(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssBogusBlock(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssDeclarationOrAtRuleBlock(it) => std::fmt::Debug::fmt(it, f),
         }
     }
 }
-impl From<AnyCssFunction> for SyntaxNode {
-    fn from(n: AnyCssFunction) -> Self {
+impl From<AnyCssDeclarationOrAtRuleBlock> for SyntaxNode {
+    fn from(n: AnyCssDeclarationOrAtRuleBlock) -> Self {
         match n {
-            AnyCssFunction::CssFunction(it) => it.into_syntax(),
-            AnyCssFunction::CssIfFunction(it) => it.into_syntax(),
-            AnyCssFunction::CssUrlFunction(it) => it.into_syntax(),
+            AnyCssDeclarationOrAtRuleBlock::CssBogusBlock(it) => it.into_syntax(),
+            AnyCssDeclarationOrAtRuleBlock::CssDeclarationOrAtRuleBlock(it) => it.into_syntax(),
         }
     }
 }
-impl From<AnyCssFunction> for SyntaxElement {
-    fn from(n: AnyCssFunction) -> Self {
+impl From<AnyCssDeclarationOrAtRuleBlock> for SyntaxElement {
+    fn from(n: AnyCssDeclarationOrAtRuleBlock) -> Self {
         let node: SyntaxNode = n.into();
         node.into()
     }
 }
-impl From<CssGenericDelimiter> for AnyCssGenericComponentValue {
-    fn from(node: CssGenericDelimiter) -> Self {
-        Self::CssGenericDelimiter(node)
+impl From<CssBogus> for AnyCssDeclarationOrRule {
+    fn from(node: CssBogus) -> Self {
+        Self::CssBogus(node)
     }
 }
-impl AstNode for AnyCssGenericComponentValue {
+impl From<CssDeclarationWithSemicolon> for AnyCssDeclarationOrRule {
+    fn from(node: CssDeclarationWithSemicolon) -> Self {
+        Self::CssDeclarationWithSemicolon(node)
+    }
+}
+impl From<CssEmptyDeclaration> for AnyCssDeclarationOrRule {
+    fn from(node: CssEmptyDeclaration) -> Self {
+        Self::CssEmptyDeclaration(node)
+    }
+}
+impl From<CssMetavariable> for AnyCssDeclarationOrRule {
+    fn from(node: CssMetavariable) -> Self {
+        Self::CssMetavariable(node)
+    }
+}
+impl AstNode for AnyCssDeclarationOrRule {
     type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> =
-        AnyCssValue::KIND_SET.union(CssGenericDelimiter::KIND_SET);
+    const KIND_SET: SyntaxKindSet<Language> = AnyCssRule::KIND_SET
+        .union(CssBogus::KIND_SET)
+        .union(CssDeclarationWithSemicolon::KIND_SET)
+        .union(CssEmptyDeclaration::KIND_SET)
+        .union(CssMetavariable::KIND_SET);
     fn can_cast(kind: SyntaxKind) -> bool {
         match kind {
-            CSS_GENERIC_DELIMITER => true,
-            k if AnyCssValue::can_cast(k) => true,
+            CSS_BOGUS
+            | CSS_DECLARATION_WITH_SEMICOLON
+            | CSS_EMPTY_DECLARATION
+            | CSS_METAVARIABLE => true,
+            k if AnyCssRule::can_cast(k) => true,
             _ => false,
         }
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         let res = match syntax.kind() {
-            CSS_GENERIC_DELIMITER => Self::CssGenericDelimiter(CssGenericDelimiter { syntax }),
+            CSS_BOGUS => Self::CssBogus(CssBogus { syntax }),
+            CSS_DECLARATION_WITH_SEMICOLON => {
+                Self::CssDeclarationWithSemicolon(CssDeclarationWithSemicolon { syntax })
+            }
+            CSS_EMPTY_DECLARATION => Self::CssEmptyDeclaration(CssEmptyDeclaration { syntax }),
+            CSS_METAVARIABLE => Self::CssMetavariable(CssMetavariable { syntax }),
             _ => {
-                if let Some(any_css_value) = AnyCssValue::cast(syntax) {
-                    return Some(Self::AnyCssValue(any_css_value));
+                if let Some(any_css_rule) = AnyCssRule::cast(syntax) {
+                    return Some(Self::AnyCssRule(any_css_rule));
                 }
                 return None;
             }
@@ -24067,621 +22132,633 @@ impl AstNode for AnyCssGenericComponentValue {
     }
     fn syntax(&self) -> &SyntaxNode {
         match self {
-            Self::CssGenericDelimiter(it) => it.syntax(),
-            Self::AnyCssValue(it) => it.syntax(),
+            Self::CssBogus(it) => it.syntax(),
+            Self::CssDeclarationWithSemicolon(it) => it.syntax(),
+            Self::CssEmptyDeclaration(it) => it.syntax(),
+            Self::CssMetavariable(it) => it.syntax(),
+            Self::AnyCssRule(it) => it.syntax(),
         }
     }
     fn into_syntax(self) -> SyntaxNode {
         match self {
-            Self::CssGenericDelimiter(it) => it.into_syntax(),
-            Self::AnyCssValue(it) => it.into_syntax(),
+            Self::CssBogus(it) => it.into_syntax(),
+            Self::CssDeclarationWithSemicolon(it) => it.into_syntax(),
+            Self::CssEmptyDeclaration(it) => it.into_syntax(),
+            Self::CssMetavariable(it) => it.into_syntax(),
+            Self::AnyCssRule(it) => it.into_syntax(),
         }
     }
 }
-impl std::fmt::Debug for AnyCssGenericComponentValue {
+impl std::fmt::Debug for AnyCssDeclarationOrRule {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         match self {
-            Self::AnyCssValue(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssGenericDelimiter(it) => std::fmt::Debug::fmt(it, f),
+            Self::AnyCssRule(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssBogus(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssDeclarationWithSemicolon(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssEmptyDeclaration(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssMetavariable(it) => std::fmt::Debug::fmt(it, f),
         }
     }
 }
-impl From<AnyCssGenericComponentValue> for SyntaxNode {
-    fn from(n: AnyCssGenericComponentValue) -> Self {
+impl From<AnyCssDeclarationOrRule> for SyntaxNode {
+    fn from(n: AnyCssDeclarationOrRule) -> Self {
         match n {
-            AnyCssGenericComponentValue::AnyCssValue(it) => it.into_syntax(),
-            AnyCssGenericComponentValue::CssGenericDelimiter(it) => it.into_syntax(),
+            AnyCssDeclarationOrRule::AnyCssRule(it) => it.into_syntax(),
+            AnyCssDeclarationOrRule::CssBogus(it) => it.into_syntax(),
+            AnyCssDeclarationOrRule::CssDeclarationWithSemicolon(it) => it.into_syntax(),
+            AnyCssDeclarationOrRule::CssEmptyDeclaration(it) => it.into_syntax(),
+            AnyCssDeclarationOrRule::CssMetavariable(it) => it.into_syntax(),
         }
     }
 }
-impl From<AnyCssGenericComponentValue> for SyntaxElement {
-    fn from(n: AnyCssGenericComponentValue) -> Self {
+impl From<AnyCssDeclarationOrRule> for SyntaxElement {
+    fn from(n: AnyCssDeclarationOrRule) -> Self {
         let node: SyntaxNode = n.into();
         node.into()
     }
 }
-impl From<CssBogusIfBranch> for AnyCssIfBranch {
-    fn from(node: CssBogusIfBranch) -> Self {
-        Self::CssBogusIfBranch(node)
+impl From<CssBogusBlock> for AnyCssDeclarationOrRuleBlock {
+    fn from(node: CssBogusBlock) -> Self {
+        Self::CssBogusBlock(node)
     }
 }
-impl From<CssIfBranch> for AnyCssIfBranch {
-    fn from(node: CssIfBranch) -> Self {
-        Self::CssIfBranch(node)
+impl From<CssDeclarationOrRuleBlock> for AnyCssDeclarationOrRuleBlock {
+    fn from(node: CssDeclarationOrRuleBlock) -> Self {
+        Self::CssDeclarationOrRuleBlock(node)
     }
 }
-impl AstNode for AnyCssIfBranch {
+impl AstNode for AnyCssDeclarationOrRuleBlock {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        CssBogusIfBranch::KIND_SET.union(CssIfBranch::KIND_SET);
+        CssBogusBlock::KIND_SET.union(CssDeclarationOrRuleBlock::KIND_SET);
     fn can_cast(kind: SyntaxKind) -> bool {
-        matches!(kind, CSS_BOGUS_IF_BRANCH | CSS_IF_BRANCH)
+        matches!(kind, CSS_BOGUS_BLOCK | CSS_DECLARATION_OR_RULE_BLOCK)
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         let res = match syntax.kind() {
-            CSS_BOGUS_IF_BRANCH => Self::CssBogusIfBranch(CssBogusIfBranch { syntax }),
-            CSS_IF_BRANCH => Self::CssIfBranch(CssIfBranch { syntax }),
+            CSS_BOGUS_BLOCK => Self::CssBogusBlock(CssBogusBlock { syntax }),
+            CSS_DECLARATION_OR_RULE_BLOCK => {
+                Self::CssDeclarationOrRuleBlock(CssDeclarationOrRuleBlock { syntax })
+            }
             _ => return None,
         };
         Some(res)
     }
     fn syntax(&self) -> &SyntaxNode {
         match self {
-            Self::CssBogusIfBranch(it) => it.syntax(),
-            Self::CssIfBranch(it) => it.syntax(),
+            Self::CssBogusBlock(it) => it.syntax(),
+            Self::CssDeclarationOrRuleBlock(it) => it.syntax(),
         }
     }
     fn into_syntax(self) -> SyntaxNode {
         match self {
-            Self::CssBogusIfBranch(it) => it.into_syntax(),
-            Self::CssIfBranch(it) => it.into_syntax(),
+            Self::CssBogusBlock(it) => it.into_syntax(),
+            Self::CssDeclarationOrRuleBlock(it) => it.into_syntax(),
         }
     }
 }
-impl std::fmt::Debug for AnyCssIfBranch {
+impl std::fmt::Debug for AnyCssDeclarationOrRuleBlock {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         match self {
-            Self::CssBogusIfBranch(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssIfBranch(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssBogusBlock(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssDeclarationOrRuleBlock(it) => std::fmt::Debug::fmt(it, f),
         }
     }
 }
-impl From<AnyCssIfBranch> for SyntaxNode {
-    fn from(n: AnyCssIfBranch) -> Self {
+impl From<AnyCssDeclarationOrRuleBlock> for SyntaxNode {
+    fn from(n: AnyCssDeclarationOrRuleBlock) -> Self {
         match n {
-            AnyCssIfBranch::CssBogusIfBranch(it) => it.into_syntax(),
-            AnyCssIfBranch::CssIfBranch(it) => it.into_syntax(),
+            AnyCssDeclarationOrRuleBlock::CssBogusBlock(it) => it.into_syntax(),
+            AnyCssDeclarationOrRuleBlock::CssDeclarationOrRuleBlock(it) => it.into_syntax(),
         }
     }
 }
-impl From<AnyCssIfBranch> for SyntaxElement {
-    fn from(n: AnyCssIfBranch) -> Self {
+impl From<AnyCssDeclarationOrRuleBlock> for SyntaxElement {
+    fn from(n: AnyCssDeclarationOrRuleBlock) -> Self {
         let node: SyntaxNode = n.into();
         node.into()
     }
 }
-impl From<CssElseKeyword> for AnyCssIfCondition {
-    fn from(node: CssElseKeyword) -> Self {
-        Self::CssElseKeyword(node)
+impl From<CssPercentage> for AnyCssDimension {
+    fn from(node: CssPercentage) -> Self {
+        Self::CssPercentage(node)
+    }
+}
+impl From<CssRegularDimension> for AnyCssDimension {
+    fn from(node: CssRegularDimension) -> Self {
+        Self::CssRegularDimension(node)
+    }
+}
+impl From<CssUnknownDimension> for AnyCssDimension {
+    fn from(node: CssUnknownDimension) -> Self {
+        Self::CssUnknownDimension(node)
     }
 }
-impl AstNode for AnyCssIfCondition {
+impl AstNode for AnyCssDimension {
     type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> =
-        AnyCssIfTestBooleanExpr::KIND_SET.union(CssElseKeyword::KIND_SET);
+    const KIND_SET: SyntaxKindSet<Language> = CssPercentage::KIND_SET
+        .union(CssRegularDimension::KIND_SET)
+        .union(CssUnknownDimension::KIND_SET);
     fn can_cast(kind: SyntaxKind) -> bool {
-        match kind {
-            CSS_ELSE_KEYWORD => true,
-            k if AnyCssIfTestBooleanExpr::can_cast(k) => true,
-            _ => false,
-        }
+        matches!(
+            kind,
+            CSS_PERCENTAGE | CSS_REGULAR_DIMENSION | CSS_UNKNOWN_DIMENSION
+        )
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         let res = match syntax.kind() {
-            CSS_ELSE_KEYWORD => Self::CssElseKeyword(CssElseKeyword { syntax }),
-            _ => {
-                if let Some(any_css_if_test_boolean_expr) = AnyCssIfTestBooleanExpr::cast(syntax) {
-                    return Some(Self::AnyCssIfTestBooleanExpr(any_css_if_test_boolean_expr));
-                }
-                return None;
-            }
+            CSS_PERCENTAGE => Self::CssPercentage(CssPercentage { syntax }),
+            CSS_REGULAR_DIMENSION => Self::CssRegularDimension(CssRegularDimension { syntax }),
+            CSS_UNKNOWN_DIMENSION => Self::CssUnknownDimension(CssUnknownDimension { syntax }),
+            _ => return None,
         };
         Some(res)
     }
     fn syntax(&self) -> &SyntaxNode {
         match self {
-            Self::CssElseKeyword(it) => it.syntax(),
-            Self::AnyCssIfTestBooleanExpr(it) => it.syntax(),
+            Self::CssPercentage(it) => it.syntax(),
+            Self::CssRegularDimension(it) => it.syntax(),
+            Self::CssUnknownDimension(it) => it.syntax(),
         }
     }
     fn into_syntax(self) -> SyntaxNode {
         match self {
-            Self::CssElseKeyword(it) => it.into_syntax(),
-            Self::AnyCssIfTestBooleanExpr(it) => it.into_syntax(),
+            Self::CssPercentage(it) => it.into_syntax(),
+            Self::CssRegularDimension(it) => it.into_syntax(),
+            Self::CssUnknownDimension(it) => it.into_syntax(),
         }
     }
 }
-impl std::fmt::Debug for AnyCssIfCondition {
+impl std::fmt::Debug for AnyCssDimension {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         match self {
-            Self::AnyCssIfTestBooleanExpr(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssElseKeyword(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssPercentage(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssRegularDimension(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssUnknownDimension(it) => std::fmt::Debug::fmt(it, f),
         }
     }
 }
-impl From<AnyCssIfCondition> for SyntaxNode {
-    fn from(n: AnyCssIfCondition) -> Self {
+impl From<AnyCssDimension> for SyntaxNode {
+    fn from(n: AnyCssDimension) -> Self {
         match n {
-            AnyCssIfCondition::AnyCssIfTestBooleanExpr(it) => it.into_syntax(),
-            AnyCssIfCondition::CssElseKeyword(it) => it.into_syntax(),
+            AnyCssDimension::CssPercentage(it) => it.into_syntax(),
+            AnyCssDimension::CssRegularDimension(it) => it.into_syntax(),
+            AnyCssDimension::CssUnknownDimension(it) => it.into_syntax(),
         }
     }
 }
-impl From<AnyCssIfCondition> for SyntaxElement {
-    fn from(n: AnyCssIfCondition) -> Self {
+impl From<AnyCssDimension> for SyntaxElement {
+    fn from(n: AnyCssDimension) -> Self {
         let node: SyntaxNode = n.into();
         node.into()
     }
 }
-impl AstNode for AnyCssIfMediaTestQuery {
+impl From<CssBogusDocumentMatcher> for AnyCssDocumentMatcher {
+    fn from(node: CssBogusDocumentMatcher) -> Self {
+        Self::CssBogusDocumentMatcher(node)
+    }
+}
+impl From<CssDocumentCustomMatcher> for AnyCssDocumentMatcher {
+    fn from(node: CssDocumentCustomMatcher) -> Self {
+        Self::CssDocumentCustomMatcher(node)
+    }
+}
+impl From<CssUrlFunction> for AnyCssDocumentMatcher {
+    fn from(node: CssUrlFunction) -> Self {
+        Self::CssUrlFunction(node)
+    }
+}
+impl AstNode for AnyCssDocumentMatcher {
     type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> =
-        AnyCssMediaCondition::KIND_SET.union(AnyCssQueryFeature::KIND_SET);
+    const KIND_SET: SyntaxKindSet<Language> = CssBogusDocumentMatcher::KIND_SET
+        .union(CssDocumentCustomMatcher::KIND_SET)
+        .union(CssUrlFunction::KIND_SET);
     fn can_cast(kind: SyntaxKind) -> bool {
-        match kind {
-            k if AnyCssMediaCondition::can_cast(k) => true,
-            k if AnyCssQueryFeature::can_cast(k) => true,
-            _ => false,
-        }
+        matches!(
+            kind,
+            CSS_BOGUS_DOCUMENT_MATCHER | CSS_DOCUMENT_CUSTOM_MATCHER | CSS_URL_FUNCTION
+        )
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
-        let syntax = match AnyCssMediaCondition::try_cast(syntax) {
-            Ok(any_css_media_condition) => {
-                return Some(Self::AnyCssMediaCondition(any_css_media_condition));
+        let res = match syntax.kind() {
+            CSS_BOGUS_DOCUMENT_MATCHER => {
+                Self::CssBogusDocumentMatcher(CssBogusDocumentMatcher { syntax })
             }
-            Err(syntax) => syntax,
+            CSS_DOCUMENT_CUSTOM_MATCHER => {
+                Self::CssDocumentCustomMatcher(CssDocumentCustomMatcher { syntax })
+            }
+            CSS_URL_FUNCTION => Self::CssUrlFunction(CssUrlFunction { syntax }),
+            _ => return None,
         };
-        if let Some(any_css_query_feature) = AnyCssQueryFeature::cast(syntax) {
-            return Some(Self::AnyCssQueryFeature(any_css_query_feature));
-        }
-        None
+        Some(res)
     }
     fn syntax(&self) -> &SyntaxNode {
         match self {
-            Self::AnyCssMediaCondition(it) => it.syntax(),
-            Self::AnyCssQueryFeature(it) => it.syntax(),
+            Self::CssBogusDocumentMatcher(it) => it.syntax(),
+            Self::CssDocumentCustomMatcher(it) => it.syntax(),
+            Self::CssUrlFunction(it) => it.syntax(),
         }
     }
     fn into_syntax(self) -> SyntaxNode {
         match self {
-            Self::AnyCssMediaCondition(it) => it.into_syntax(),
-            Self::AnyCssQueryFeature(it) => it.into_syntax(),
+            Self::CssBogusDocumentMatcher(it) => it.into_syntax(),
+            Self::CssDocumentCustomMatcher(it) => it.into_syntax(),
+            Self::CssUrlFunction(it) => it.into_syntax(),
         }
     }
 }
-impl std::fmt::Debug for AnyCssIfMediaTestQuery {
+impl std::fmt::Debug for AnyCssDocumentMatcher {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         match self {
-            Self::AnyCssMediaCondition(it) => std::fmt::Debug::fmt(it, f),
-            Self::AnyCssQueryFeature(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssBogusDocumentMatcher(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssDocumentCustomMatcher(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssUrlFunction(it) => std::fmt::Debug::fmt(it, f),
         }
     }
 }
-impl From<AnyCssIfMediaTestQuery> for SyntaxNode {
-    fn from(n: AnyCssIfMediaTestQuery) -> Self {
+impl From<AnyCssDocumentMatcher> for SyntaxNode {
+    fn from(n: AnyCssDocumentMatcher) -> Self {
         match n {
-            AnyCssIfMediaTestQuery::AnyCssMediaCondition(it) => it.into_syntax(),
-            AnyCssIfMediaTestQuery::AnyCssQueryFeature(it) => it.into_syntax(),
+            AnyCssDocumentMatcher::CssBogusDocumentMatcher(it) => it.into_syntax(),
+            AnyCssDocumentMatcher::CssDocumentCustomMatcher(it) => it.into_syntax(),
+            AnyCssDocumentMatcher::CssUrlFunction(it) => it.into_syntax(),
         }
     }
 }
-impl From<AnyCssIfMediaTestQuery> for SyntaxElement {
-    fn from(n: AnyCssIfMediaTestQuery) -> Self {
+impl From<AnyCssDocumentMatcher> for SyntaxElement {
+    fn from(n: AnyCssDocumentMatcher) -> Self {
         let node: SyntaxNode = n.into();
         node.into()
     }
 }
-impl From<CssIfSupportsIdentifierTest> for AnyCssIfSupportsTestCondition {
-    fn from(node: CssIfSupportsIdentifierTest) -> Self {
-        Self::CssIfSupportsIdentifierTest(node)
+impl From<CssBinaryExpression> for AnyCssExpression {
+    fn from(node: CssBinaryExpression) -> Self {
+        Self::CssBinaryExpression(node)
+    }
+}
+impl From<CssListOfComponentValuesExpression> for AnyCssExpression {
+    fn from(node: CssListOfComponentValuesExpression) -> Self {
+        Self::CssListOfComponentValuesExpression(node)
+    }
+}
+impl From<CssParenthesizedExpression> for AnyCssExpression {
+    fn from(node: CssParenthesizedExpression) -> Self {
+        Self::CssParenthesizedExpression(node)
     }
 }
-impl AstNode for AnyCssIfSupportsTestCondition {
+impl AstNode for AnyCssExpression {
     type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> =
-        AnyCssImportSupportsCondition::KIND_SET.union(CssIfSupportsIdentifierTest::KIND_SET);
+    const KIND_SET: SyntaxKindSet<Language> = CssBinaryExpression::KIND_SET
+        .union(CssListOfComponentValuesExpression::KIND_SET)
+        .union(CssParenthesizedExpression::KIND_SET);
     fn can_cast(kind: SyntaxKind) -> bool {
-        match kind {
-            CSS_IF_SUPPORTS_IDENTIFIER_TEST => true,
-            k if AnyCssImportSupportsCondition::can_cast(k) => true,
-            _ => false,
-        }
+        matches!(
+            kind,
+            CSS_BINARY_EXPRESSION
+                | CSS_LIST_OF_COMPONENT_VALUES_EXPRESSION
+                | CSS_PARENTHESIZED_EXPRESSION
+        )
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         let res = match syntax.kind() {
-            CSS_IF_SUPPORTS_IDENTIFIER_TEST => {
-                Self::CssIfSupportsIdentifierTest(CssIfSupportsIdentifierTest { syntax })
+            CSS_BINARY_EXPRESSION => Self::CssBinaryExpression(CssBinaryExpression { syntax }),
+            CSS_LIST_OF_COMPONENT_VALUES_EXPRESSION => {
+                Self::CssListOfComponentValuesExpression(CssListOfComponentValuesExpression {
+                    syntax,
+                })
             }
-            _ => {
-                if let Some(any_css_import_supports_condition) =
-                    AnyCssImportSupportsCondition::cast(syntax)
-                {
-                    return Some(Self::AnyCssImportSupportsCondition(
-                        any_css_import_supports_condition,
-                    ));
-                }
-                return None;
+            CSS_PARENTHESIZED_EXPRESSION => {
+                Self::CssParenthesizedExpression(CssParenthesizedExpression { syntax })
             }
+            _ => return None,
         };
         Some(res)
     }
     fn syntax(&self) -> &SyntaxNode {
         match self {
-            Self::CssIfSupportsIdentifierTest(it) => it.syntax(),
-            Self::AnyCssImportSupportsCondition(it) => it.syntax(),
+            Self::CssBinaryExpression(it) => it.syntax(),
+            Self::CssListOfComponentValuesExpression(it) => it.syntax(),
+            Self::CssParenthesizedExpression(it) => it.syntax(),
         }
     }
     fn into_syntax(self) -> SyntaxNode {
         match self {
-            Self::CssIfSupportsIdentifierTest(it) => it.into_syntax(),
-            Self::AnyCssImportSupportsCondition(it) => it.into_syntax(),
+            Self::CssBinaryExpression(it) => it.into_syntax(),
+            Self::CssListOfComponentValuesExpression(it) => it.into_syntax(),
+            Self::CssParenthesizedExpression(it) => it.into_syntax(),
         }
     }
 }
-impl std::fmt::Debug for AnyCssIfSupportsTestCondition {
+impl std::fmt::Debug for AnyCssExpression {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         match self {
-            Self::AnyCssImportSupportsCondition(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssIfSupportsIdentifierTest(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssBinaryExpression(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssListOfComponentValuesExpression(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssParenthesizedExpression(it) => std::fmt::Debug::fmt(it, f),
         }
     }
 }
-impl From<AnyCssIfSupportsTestCondition> for SyntaxNode {
-    fn from(n: AnyCssIfSupportsTestCondition) -> Self {
+impl From<AnyCssExpression> for SyntaxNode {
+    fn from(n: AnyCssExpression) -> Self {
         match n {
-            AnyCssIfSupportsTestCondition::AnyCssImportSupportsCondition(it) => it.into_syntax(),
-            AnyCssIfSupportsTestCondition::CssIfSupportsIdentifierTest(it) => it.into_syntax(),
+            AnyCssExpression::CssBinaryExpression(it) => it.into_syntax(),
+            AnyCssExpression::CssListOfComponentValuesExpression(it) => it.into_syntax(),
+            AnyCssExpression::CssParenthesizedExpression(it) => it.into_syntax(),
         }
     }
 }
-impl From<AnyCssIfSupportsTestCondition> for SyntaxElement {
-    fn from(n: AnyCssIfSupportsTestCondition) -> Self {
+impl From<AnyCssExpression> for SyntaxElement {
+    fn from(n: AnyCssExpression) -> Self {
         let node: SyntaxNode = n.into();
         node.into()
     }
 }
-impl From<CssBogusIfTest> for AnyCssIfTest {
-    fn from(node: CssBogusIfTest) -> Self {
-        Self::CssBogusIfTest(node)
-    }
-}
-impl From<CssIfMediaTest> for AnyCssIfTest {
-    fn from(node: CssIfMediaTest) -> Self {
-        Self::CssIfMediaTest(node)
+impl From<CssBogusFontFamilyName> for AnyCssFontFamilyName {
+    fn from(node: CssBogusFontFamilyName) -> Self {
+        Self::CssBogusFontFamilyName(node)
     }
 }
-impl From<CssIfStyleTest> for AnyCssIfTest {
-    fn from(node: CssIfStyleTest) -> Self {
-        Self::CssIfStyleTest(node)
+impl From<CssFontFamilyName> for AnyCssFontFamilyName {
+    fn from(node: CssFontFamilyName) -> Self {
+        Self::CssFontFamilyName(node)
     }
 }
-impl From<CssIfSupportsTest> for AnyCssIfTest {
-    fn from(node: CssIfSupportsTest) -> Self {
-        Self::CssIfSupportsTest(node)
+impl From<CssString> for AnyCssFontFamilyName {
+    fn from(node: CssString) -> Self {
+        Self::CssString(node)
     }
 }
-impl AstNode for AnyCssIfTest {
+impl AstNode for AnyCssFontFamilyName {
     type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> = CssBogusIfTest::KIND_SET
-        .union(CssIfMediaTest::KIND_SET)
-        .union(CssIfStyleTest::KIND_SET)
-        .union(CssIfSupportsTest::KIND_SET);
+    const KIND_SET: SyntaxKindSet<Language> = CssBogusFontFamilyName::KIND_SET
+        .union(CssFontFamilyName::KIND_SET)
+        .union(CssString::KIND_SET);
     fn can_cast(kind: SyntaxKind) -> bool {
         matches!(
             kind,
-            CSS_BOGUS_IF_TEST | CSS_IF_MEDIA_TEST | CSS_IF_STYLE_TEST | CSS_IF_SUPPORTS_TEST
+            CSS_BOGUS_FONT_FAMILY_NAME | CSS_FONT_FAMILY_NAME | CSS_STRING
         )
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         let res = match syntax.kind() {
-            CSS_BOGUS_IF_TEST => Self::CssBogusIfTest(CssBogusIfTest { syntax }),
-            CSS_IF_MEDIA_TEST => Self::CssIfMediaTest(CssIfMediaTest { syntax }),
-            CSS_IF_STYLE_TEST => Self::CssIfStyleTest(CssIfStyleTest { syntax }),
-            CSS_IF_SUPPORTS_TEST => Self::CssIfSupportsTest(CssIfSupportsTest { syntax }),
+            CSS_BOGUS_FONT_FAMILY_NAME => {
+                Self::CssBogusFontFamilyName(CssBogusFontFamilyName { syntax })
+            }
+            CSS_FONT_FAMILY_NAME => Self::CssFontFamilyName(CssFontFamilyName { syntax }),
+            CSS_STRING => Self::CssString(CssString { syntax }),
             _ => return None,
         };
         Some(res)
     }
     fn syntax(&self) -> &SyntaxNode {
         match self {
-            Self::CssBogusIfTest(it) => it.syntax(),
-            Self::CssIfMediaTest(it) => it.syntax(),
-            Self::CssIfStyleTest(it) => it.syntax(),
-            Self::CssIfSupportsTest(it) => it.syntax(),
+            Self::CssBogusFontFamilyName(it) => it.syntax(),
+            Self::CssFontFamilyName(it) => it.syntax(),
+            Self::CssString(it) => it.syntax(),
         }
     }
     fn into_syntax(self) -> SyntaxNode {
         match self {
-            Self::CssBogusIfTest(it) => it.into_syntax(),
-            Self::CssIfMediaTest(it) => it.into_syntax(),
-            Self::CssIfStyleTest(it) => it.into_syntax(),
-            Self::CssIfSupportsTest(it) => it.into_syntax(),
+            Self::CssBogusFontFamilyName(it) => it.into_syntax(),
+            Self::CssFontFamilyName(it) => it.into_syntax(),
+            Self::CssString(it) => it.into_syntax(),
         }
     }
 }
-impl std::fmt::Debug for AnyCssIfTest {
+impl std::fmt::Debug for AnyCssFontFamilyName {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         match self {
-            Self::CssBogusIfTest(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssIfMediaTest(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssIfStyleTest(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssIfSupportsTest(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssBogusFontFamilyName(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssFontFamilyName(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssString(it) => std::fmt::Debug::fmt(it, f),
         }
     }
 }
-impl From<AnyCssIfTest> for SyntaxNode {
-    fn from(n: AnyCssIfTest) -> Self {
+impl From<AnyCssFontFamilyName> for SyntaxNode {
+    fn from(n: AnyCssFontFamilyName) -> Self {
         match n {
-            AnyCssIfTest::CssBogusIfTest(it) => it.into_syntax(),
-            AnyCssIfTest::CssIfMediaTest(it) => it.into_syntax(),
-            AnyCssIfTest::CssIfStyleTest(it) => it.into_syntax(),
-            AnyCssIfTest::CssIfSupportsTest(it) => it.into_syntax(),
+            AnyCssFontFamilyName::CssBogusFontFamilyName(it) => it.into_syntax(),
+            AnyCssFontFamilyName::CssFontFamilyName(it) => it.into_syntax(),
+            AnyCssFontFamilyName::CssString(it) => it.into_syntax(),
         }
     }
 }
-impl From<AnyCssIfTest> for SyntaxElement {
-    fn from(n: AnyCssIfTest) -> Self {
+impl From<AnyCssFontFamilyName> for SyntaxElement {
+    fn from(n: AnyCssFontFamilyName) -> Self {
         let node: SyntaxNode = n.into();
         node.into()
     }
 }
-impl From<CssIfTestBooleanAndExpr> for AnyCssIfTestBooleanAndCombinableExpr {
-    fn from(node: CssIfTestBooleanAndExpr) -> Self {
-        Self::CssIfTestBooleanAndExpr(node)
+impl From<CssBogusBlock> for AnyCssFontFeatureValuesBlock {
+    fn from(node: CssBogusBlock) -> Self {
+        Self::CssBogusBlock(node)
+    }
+}
+impl From<CssFontFeatureValuesBlock> for AnyCssFontFeatureValuesBlock {
+    fn from(node: CssFontFeatureValuesBlock) -> Self {
+        Self::CssFontFeatureValuesBlock(node)
     }
 }
-impl AstNode for AnyCssIfTestBooleanAndCombinableExpr {
+impl AstNode for AnyCssFontFeatureValuesBlock {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        AnyCssIfTestBooleanExprGroup::KIND_SET.union(CssIfTestBooleanAndExpr::KIND_SET);
+        CssBogusBlock::KIND_SET.union(CssFontFeatureValuesBlock::KIND_SET);
     fn can_cast(kind: SyntaxKind) -> bool {
-        match kind {
-            CSS_IF_TEST_BOOLEAN_AND_EXPR => true,
-            k if AnyCssIfTestBooleanExprGroup::can_cast(k) => true,
-            _ => false,
-        }
+        matches!(kind, CSS_BOGUS_BLOCK | CSS_FONT_FEATURE_VALUES_BLOCK)
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         let res = match syntax.kind() {
-            CSS_IF_TEST_BOOLEAN_AND_EXPR => {
-                Self::CssIfTestBooleanAndExpr(CssIfTestBooleanAndExpr { syntax })
-            }
-            _ => {
-                if let Some(any_css_if_test_boolean_expr_group) =
-                    AnyCssIfTestBooleanExprGroup::cast(syntax)
-                {
-                    return Some(Self::AnyCssIfTestBooleanExprGroup(
-                        any_css_if_test_boolean_expr_group,
-                    ));
-                }
-                return None;
+            CSS_BOGUS_BLOCK => Self::CssBogusBlock(CssBogusBlock { syntax }),
+            CSS_FONT_FEATURE_VALUES_BLOCK => {
+                Self::CssFontFeatureValuesBlock(CssFontFeatureValuesBlock { syntax })
             }
+            _ => return None,
         };
         Some(res)
     }
     fn syntax(&self) -> &SyntaxNode {
         match self {
-            Self::CssIfTestBooleanAndExpr(it) => it.syntax(),
-            Self::AnyCssIfTestBooleanExprGroup(it) => it.syntax(),
+            Self::CssBogusBlock(it) => it.syntax(),
+            Self::CssFontFeatureValuesBlock(it) => it.syntax(),
         }
     }
     fn into_syntax(self) -> SyntaxNode {
         match self {
-            Self::CssIfTestBooleanAndExpr(it) => it.into_syntax(),
-            Self::AnyCssIfTestBooleanExprGroup(it) => it.into_syntax(),
+            Self::CssBogusBlock(it) => it.into_syntax(),
+            Self::CssFontFeatureValuesBlock(it) => it.into_syntax(),
         }
     }
 }
-impl std::fmt::Debug for AnyCssIfTestBooleanAndCombinableExpr {
+impl std::fmt::Debug for AnyCssFontFeatureValuesBlock {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         match self {
-            Self::AnyCssIfTestBooleanExprGroup(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssIfTestBooleanAndExpr(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssBogusBlock(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssFontFeatureValuesBlock(it) => std::fmt::Debug::fmt(it, f),
         }
     }
 }
-impl From<AnyCssIfTestBooleanAndCombinableExpr> for SyntaxNode {
-    fn from(n: AnyCssIfTestBooleanAndCombinableExpr) -> Self {
+impl From<AnyCssFontFeatureValuesBlock> for SyntaxNode {
+    fn from(n: AnyCssFontFeatureValuesBlock) -> Self {
         match n {
-            AnyCssIfTestBooleanAndCombinableExpr::AnyCssIfTestBooleanExprGroup(it) => {
-                it.into_syntax()
-            }
-            AnyCssIfTestBooleanAndCombinableExpr::CssIfTestBooleanAndExpr(it) => it.into_syntax(),
+            AnyCssFontFeatureValuesBlock::CssBogusBlock(it) => it.into_syntax(),
+            AnyCssFontFeatureValuesBlock::CssFontFeatureValuesBlock(it) => it.into_syntax(),
         }
     }
 }
-impl From<AnyCssIfTestBooleanAndCombinableExpr> for SyntaxElement {
-    fn from(n: AnyCssIfTestBooleanAndCombinableExpr) -> Self {
+impl From<AnyCssFontFeatureValuesBlock> for SyntaxElement {
+    fn from(n: AnyCssFontFeatureValuesBlock) -> Self {
         let node: SyntaxNode = n.into();
         node.into()
     }
 }
-impl From<CssIfTestBooleanNotExpr> for AnyCssIfTestBooleanExpr {
-    fn from(node: CssIfTestBooleanNotExpr) -> Self {
-        Self::CssIfTestBooleanNotExpr(node)
+impl From<CssBogusFontFeatureValuesItem> for AnyCssFontFeatureValuesItem {
+    fn from(node: CssBogusFontFeatureValuesItem) -> Self {
+        Self::CssBogusFontFeatureValuesItem(node)
+    }
+}
+impl From<CssFontFeatureValuesItem> for AnyCssFontFeatureValuesItem {
+    fn from(node: CssFontFeatureValuesItem) -> Self {
+        Self::CssFontFeatureValuesItem(node)
     }
 }
-impl AstNode for AnyCssIfTestBooleanExpr {
+impl AstNode for AnyCssFontFeatureValuesItem {
     type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> = AnyCssIfTestBooleanAndCombinableExpr::KIND_SET
-        .union(AnyCssIfTestBooleanOrCombinableExpr::KIND_SET)
-        .union(CssIfTestBooleanNotExpr::KIND_SET);
+    const KIND_SET: SyntaxKindSet<Language> =
+        CssBogusFontFeatureValuesItem::KIND_SET.union(CssFontFeatureValuesItem::KIND_SET);
     fn can_cast(kind: SyntaxKind) -> bool {
-        match kind {
-            CSS_IF_TEST_BOOLEAN_NOT_EXPR => true,
-            k if AnyCssIfTestBooleanAndCombinableExpr::can_cast(k) => true,
-            k if AnyCssIfTestBooleanOrCombinableExpr::can_cast(k) => true,
-            _ => false,
-        }
+        matches!(
+            kind,
+            CSS_BOGUS_FONT_FEATURE_VALUES_ITEM | CSS_FONT_FEATURE_VALUES_ITEM
+        )
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         let res = match syntax.kind() {
-            CSS_IF_TEST_BOOLEAN_NOT_EXPR => {
-                Self::CssIfTestBooleanNotExpr(CssIfTestBooleanNotExpr { syntax })
+            CSS_BOGUS_FONT_FEATURE_VALUES_ITEM => {
+                Self::CssBogusFontFeatureValuesItem(CssBogusFontFeatureValuesItem { syntax })
             }
-            _ => {
-                let syntax = match AnyCssIfTestBooleanAndCombinableExpr::try_cast(syntax) {
-                    Ok(any_css_if_test_boolean_and_combinable_expr) => {
-                        return Some(Self::AnyCssIfTestBooleanAndCombinableExpr(
-                            any_css_if_test_boolean_and_combinable_expr,
-                        ));
-                    }
-                    Err(syntax) => syntax,
-                };
-                if let Some(any_css_if_test_boolean_or_combinable_expr) =
-                    AnyCssIfTestBooleanOrCombinableExpr::cast(syntax)
-                {
-                    return Some(Self::AnyCssIfTestBooleanOrCombinableExpr(
-                        any_css_if_test_boolean_or_combinable_expr,
-                    ));
-                }
-                return None;
+            CSS_FONT_FEATURE_VALUES_ITEM => {
+                Self::CssFontFeatureValuesItem(CssFontFeatureValuesItem { syntax })
             }
+            _ => return None,
         };
         Some(res)
     }
     fn syntax(&self) -> &SyntaxNode {
         match self {
-            Self::CssIfTestBooleanNotExpr(it) => it.syntax(),
-            Self::AnyCssIfTestBooleanAndCombinableExpr(it) => it.syntax(),
-            Self::AnyCssIfTestBooleanOrCombinableExpr(it) => it.syntax(),
+            Self::CssBogusFontFeatureValuesItem(it) => it.syntax(),
+            Self::CssFontFeatureValuesItem(it) => it.syntax(),
         }
     }
     fn into_syntax(self) -> SyntaxNode {
         match self {
-            Self::CssIfTestBooleanNotExpr(it) => it.into_syntax(),
-            Self::AnyCssIfTestBooleanAndCombinableExpr(it) => it.into_syntax(),
-            Self::AnyCssIfTestBooleanOrCombinableExpr(it) => it.into_syntax(),
+            Self::CssBogusFontFeatureValuesItem(it) => it.into_syntax(),
+            Self::CssFontFeatureValuesItem(it) => it.into_syntax(),
         }
     }
 }
-impl std::fmt::Debug for AnyCssIfTestBooleanExpr {
+impl std::fmt::Debug for AnyCssFontFeatureValuesItem {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         match self {
-            Self::AnyCssIfTestBooleanAndCombinableExpr(it) => std::fmt::Debug::fmt(it, f),
-            Self::AnyCssIfTestBooleanOrCombinableExpr(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssIfTestBooleanNotExpr(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssBogusFontFeatureValuesItem(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssFontFeatureValuesItem(it) => std::fmt::Debug::fmt(it, f),
         }
     }
 }
-impl From<AnyCssIfTestBooleanExpr> for SyntaxNode {
-    fn from(n: AnyCssIfTestBooleanExpr) -> Self {
+impl From<AnyCssFontFeatureValuesItem> for SyntaxNode {
+    fn from(n: AnyCssFontFeatureValuesItem) -> Self {
         match n {
-            AnyCssIfTestBooleanExpr::AnyCssIfTestBooleanAndCombinableExpr(it) => it.into_syntax(),
-            AnyCssIfTestBooleanExpr::AnyCssIfTestBooleanOrCombinableExpr(it) => it.into_syntax(),
-            AnyCssIfTestBooleanExpr::CssIfTestBooleanNotExpr(it) => it.into_syntax(),
+            AnyCssFontFeatureValuesItem::CssBogusFontFeatureValuesItem(it) => it.into_syntax(),
+            AnyCssFontFeatureValuesItem::CssFontFeatureValuesItem(it) => it.into_syntax(),
         }
     }
 }
-impl From<AnyCssIfTestBooleanExpr> for SyntaxElement {
-    fn from(n: AnyCssIfTestBooleanExpr) -> Self {
+impl From<AnyCssFontFeatureValuesItem> for SyntaxElement {
+    fn from(n: AnyCssFontFeatureValuesItem) -> Self {
         let node: SyntaxNode = n.into();
         node.into()
     }
 }
-impl From<CssIfTestBooleanExprInParens> for AnyCssIfTestBooleanExprGroup {
-    fn from(node: CssIfTestBooleanExprInParens) -> Self {
-        Self::CssIfTestBooleanExprInParens(node)
+impl From<CssFunction> for AnyCssFunction {
+    fn from(node: CssFunction) -> Self {
+        Self::CssFunction(node)
+    }
+}
+impl From<CssUrlFunction> for AnyCssFunction {
+    fn from(node: CssUrlFunction) -> Self {
+        Self::CssUrlFunction(node)
     }
 }
-impl AstNode for AnyCssIfTestBooleanExprGroup {
+impl AstNode for AnyCssFunction {
     type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> =
-        AnyCssIfTest::KIND_SET.union(CssIfTestBooleanExprInParens::KIND_SET);
+    const KIND_SET: SyntaxKindSet<Language> = CssFunction::KIND_SET.union(CssUrlFunction::KIND_SET);
     fn can_cast(kind: SyntaxKind) -> bool {
-        match kind {
-            CSS_IF_TEST_BOOLEAN_EXPR_IN_PARENS => true,
-            k if AnyCssIfTest::can_cast(k) => true,
-            _ => false,
-        }
+        matches!(kind, CSS_FUNCTION | CSS_URL_FUNCTION)
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         let res = match syntax.kind() {
-            CSS_IF_TEST_BOOLEAN_EXPR_IN_PARENS => {
-                Self::CssIfTestBooleanExprInParens(CssIfTestBooleanExprInParens { syntax })
-            }
-            _ => {
-                if let Some(any_css_if_test) = AnyCssIfTest::cast(syntax) {
-                    return Some(Self::AnyCssIfTest(any_css_if_test));
-                }
-                return None;
-            }
+            CSS_FUNCTION => Self::CssFunction(CssFunction { syntax }),
+            CSS_URL_FUNCTION => Self::CssUrlFunction(CssUrlFunction { syntax }),
+            _ => return None,
         };
         Some(res)
     }
     fn syntax(&self) -> &SyntaxNode {
         match self {
-            Self::CssIfTestBooleanExprInParens(it) => it.syntax(),
-            Self::AnyCssIfTest(it) => it.syntax(),
+            Self::CssFunction(it) => it.syntax(),
+            Self::CssUrlFunction(it) => it.syntax(),
         }
     }
     fn into_syntax(self) -> SyntaxNode {
         match self {
-            Self::CssIfTestBooleanExprInParens(it) => it.into_syntax(),
-            Self::AnyCssIfTest(it) => it.into_syntax(),
+            Self::CssFunction(it) => it.into_syntax(),
+            Self::CssUrlFunction(it) => it.into_syntax(),
         }
     }
 }
-impl std::fmt::Debug for AnyCssIfTestBooleanExprGroup {
+impl std::fmt::Debug for AnyCssFunction {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         match self {
-            Self::AnyCssIfTest(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssIfTestBooleanExprInParens(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssFunction(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssUrlFunction(it) => std::fmt::Debug::fmt(it, f),
         }
     }
 }
-impl From<AnyCssIfTestBooleanExprGroup> for SyntaxNode {
-    fn from(n: AnyCssIfTestBooleanExprGroup) -> Self {
+impl From<AnyCssFunction> for SyntaxNode {
+    fn from(n: AnyCssFunction) -> Self {
         match n {
-            AnyCssIfTestBooleanExprGroup::AnyCssIfTest(it) => it.into_syntax(),
-            AnyCssIfTestBooleanExprGroup::CssIfTestBooleanExprInParens(it) => it.into_syntax(),
+            AnyCssFunction::CssFunction(it) => it.into_syntax(),
+            AnyCssFunction::CssUrlFunction(it) => it.into_syntax(),
         }
     }
 }
-impl From<AnyCssIfTestBooleanExprGroup> for SyntaxElement {
-    fn from(n: AnyCssIfTestBooleanExprGroup) -> Self {
+impl From<AnyCssFunction> for SyntaxElement {
+    fn from(n: AnyCssFunction) -> Self {
         let node: SyntaxNode = n.into();
         node.into()
     }
 }
-impl From<CssIfTestBooleanOrExpr> for AnyCssIfTestBooleanOrCombinableExpr {
-    fn from(node: CssIfTestBooleanOrExpr) -> Self {
-        Self::CssIfTestBooleanOrExpr(node)
+impl From<CssGenericDelimiter> for AnyCssGenericComponentValue {
+    fn from(node: CssGenericDelimiter) -> Self {
+        Self::CssGenericDelimiter(node)
     }
 }
-impl AstNode for AnyCssIfTestBooleanOrCombinableExpr {
+impl AstNode for AnyCssGenericComponentValue {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
-        AnyCssIfTestBooleanExprGroup::KIND_SET.union(CssIfTestBooleanOrExpr::KIND_SET);
+        AnyCssValue::KIND_SET.union(CssGenericDelimiter::KIND_SET);
     fn can_cast(kind: SyntaxKind) -> bool {
         match kind {
-            CSS_IF_TEST_BOOLEAN_OR_EXPR => true,
-            k if AnyCssIfTestBooleanExprGroup::can_cast(k) => true,
+            CSS_GENERIC_DELIMITER => true,
+            k if AnyCssValue::can_cast(k) => true,
             _ => false,
         }
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
         let res = match syntax.kind() {
-            CSS_IF_TEST_BOOLEAN_OR_EXPR => {
-                Self::CssIfTestBooleanOrExpr(CssIfTestBooleanOrExpr { syntax })
-            }
+            CSS_GENERIC_DELIMITER => Self::CssGenericDelimiter(CssGenericDelimiter { syntax }),
             _ => {
-                if let Some(any_css_if_test_boolean_expr_group) =
-                    AnyCssIfTestBooleanExprGroup::cast(syntax)
-                {
-                    return Some(Self::AnyCssIfTestBooleanExprGroup(
-                        any_css_if_test_boolean_expr_group,
-                    ));
+                if let Some(any_css_value) = AnyCssValue::cast(syntax) {
+                    return Some(Self::AnyCssValue(any_css_value));
                 }
                 return None;
             }
@@ -24690,37 +22767,35 @@ impl AstNode for AnyCssIfTestBooleanOrCombinableExpr {
     }
     fn syntax(&self) -> &SyntaxNode {
         match self {
-            Self::CssIfTestBooleanOrExpr(it) => it.syntax(),
-            Self::AnyCssIfTestBooleanExprGroup(it) => it.syntax(),
+            Self::CssGenericDelimiter(it) => it.syntax(),
+            Self::AnyCssValue(it) => it.syntax(),
         }
     }
     fn into_syntax(self) -> SyntaxNode {
         match self {
-            Self::CssIfTestBooleanOrExpr(it) => it.into_syntax(),
-            Self::AnyCssIfTestBooleanExprGroup(it) => it.into_syntax(),
+            Self::CssGenericDelimiter(it) => it.into_syntax(),
+            Self::AnyCssValue(it) => it.into_syntax(),
         }
     }
 }
-impl std::fmt::Debug for AnyCssIfTestBooleanOrCombinableExpr {
+impl std::fmt::Debug for AnyCssGenericComponentValue {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         match self {
-            Self::AnyCssIfTestBooleanExprGroup(it) => std::fmt::Debug::fmt(it, f),
-            Self::CssIfTestBooleanOrExpr(it) => std::fmt::Debug::fmt(it, f),
+            Self::AnyCssValue(it) => std::fmt::Debug::fmt(it, f),
+            Self::CssGenericDelimiter(it) => std::fmt::Debug::fmt(it, f),
         }
     }
 }
-impl From<AnyCssIfTestBooleanOrCombinableExpr> for SyntaxNode {
-    fn from(n: AnyCssIfTestBooleanOrCombinableExpr) -> Self {
+impl From<AnyCssGenericComponentValue> for SyntaxNode {
+    fn from(n: AnyCssGenericComponentValue) -> Self {
         match n {
-            AnyCssIfTestBooleanOrCombinableExpr::AnyCssIfTestBooleanExprGroup(it) => {
-                it.into_syntax()
-            }
-            AnyCssIfTestBooleanOrCombinableExpr::CssIfTestBooleanOrExpr(it) => it.into_syntax(),
+            AnyCssGenericComponentValue::AnyCssValue(it) => it.into_syntax(),
+            AnyCssGenericComponentValue::CssGenericDelimiter(it) => it.into_syntax(),
         }
     }
 }
-impl From<AnyCssIfTestBooleanOrCombinableExpr> for SyntaxElement {
-    fn from(n: AnyCssIfTestBooleanOrCombinableExpr) -> Self {
+impl From<AnyCssGenericComponentValue> for SyntaxElement {
+    fn from(n: AnyCssGenericComponentValue) -> Self {
         let node: SyntaxNode = n.into();
         node.into()
     }
@@ -29065,51 +27140,6 @@ impl std::fmt::Display for AnyCssGenericComponentValue {
         std::fmt::Display::fmt(self.syntax(), f)
     }
 }
-impl std::fmt::Display for AnyCssIfBranch {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        std::fmt::Display::fmt(self.syntax(), f)
-    }
-}
-impl std::fmt::Display for AnyCssIfCondition {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        std::fmt::Display::fmt(self.syntax(), f)
-    }
-}
-impl std::fmt::Display for AnyCssIfMediaTestQuery {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        std::fmt::Display::fmt(self.syntax(), f)
-    }
-}
-impl std::fmt::Display for AnyCssIfSupportsTestCondition {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        std::fmt::Display::fmt(self.syntax(), f)
-    }
-}
-impl std::fmt::Display for AnyCssIfTest {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        std::fmt::Display::fmt(self.syntax(), f)
-    }
-}
-impl std::fmt::Display for AnyCssIfTestBooleanAndCombinableExpr {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        std::fmt::Display::fmt(self.syntax(), f)
-    }
-}
-impl std::fmt::Display for AnyCssIfTestBooleanExpr {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        std::fmt::Display::fmt(self.syntax(), f)
-    }
-}
-impl std::fmt::Display for AnyCssIfTestBooleanExprGroup {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        std::fmt::Display::fmt(self.syntax(), f)
-    }
-}
-impl std::fmt::Display for AnyCssIfTestBooleanOrCombinableExpr {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        std::fmt::Display::fmt(self.syntax(), f)
-    }
-}
 impl std::fmt::Display for AnyCssImportLayer {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         std::fmt::Display::fmt(self.syntax(), f)
@@ -29590,11 +27620,6 @@ impl std::fmt::Display for CssDocumentCustomMatcher {
         std::fmt::Display::fmt(self.syntax(), f)
     }
 }
-impl std::fmt::Display for CssElseKeyword {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        std::fmt::Display::fmt(self.syntax(), f)
-    }
-}
 impl std::fmt::Display for CssEmptyDeclaration {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         std::fmt::Display::fmt(self.syntax(), f)
@@ -29665,56 +27690,6 @@ impl std::fmt::Display for CssIdentifier {
         std::fmt::Display::fmt(self.syntax(), f)
     }
 }
-impl std::fmt::Display for CssIfBranch {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        std::fmt::Display::fmt(self.syntax(), f)
-    }
-}
-impl std::fmt::Display for CssIfFunction {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        std::fmt::Display::fmt(self.syntax(), f)
-    }
-}
-impl std::fmt::Display for CssIfMediaTest {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        std::fmt::Display::fmt(self.syntax(), f)
-    }
-}
-impl std::fmt::Display for CssIfStyleTest {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        std::fmt::Display::fmt(self.syntax(), f)
-    }
-}
-impl std::fmt::Display for CssIfSupportsIdentifierTest {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        std::fmt::Display::fmt(self.syntax(), f)
-    }
-}
-impl std::fmt::Display for CssIfSupportsTest {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        std::fmt::Display::fmt(self.syntax(), f)
-    }
-}
-impl std::fmt::Display for CssIfTestBooleanAndExpr {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        std::fmt::Display::fmt(self.syntax(), f)
-    }
-}
-impl std::fmt::Display for CssIfTestBooleanExprInParens {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        std::fmt::Display::fmt(self.syntax(), f)
-    }
-}
-impl std::fmt::Display for CssIfTestBooleanNotExpr {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        std::fmt::Display::fmt(self.syntax(), f)
-    }
-}
-impl std::fmt::Display for CssIfTestBooleanOrExpr {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        std::fmt::Display::fmt(self.syntax(), f)
-    }
-}
 impl std::fmt::Display for CssImportAnonymousLayer {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         std::fmt::Display::fmt(self.syntax(), f)
@@ -30824,118 +28799,6 @@ impl From<CssBogusFontFeatureValuesItem> for SyntaxElement {
     }
 }
 #[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub struct CssBogusIfBranch {
-    syntax: SyntaxNode,
-}
-impl CssBogusIfBranch {
-    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
-    #[doc = r""]
-    #[doc = r" # Safety"]
-    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
-    #[doc = r" or a match on [SyntaxNode::kind]"]
-    #[inline]
-    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
-        Self { syntax }
-    }
-    pub fn items(&self) -> SyntaxElementChildren {
-        support::elements(&self.syntax)
-    }
-}
-impl AstNode for CssBogusIfBranch {
-    type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_BOGUS_IF_BRANCH as u16));
-    fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_BOGUS_IF_BRANCH
-    }
-    fn cast(syntax: SyntaxNode) -> Option<Self> {
-        if Self::can_cast(syntax.kind()) {
-            Some(Self { syntax })
-        } else {
-            None
-        }
-    }
-    fn syntax(&self) -> &SyntaxNode {
-        &self.syntax
-    }
-    fn into_syntax(self) -> SyntaxNode {
-        self.syntax
-    }
-}
-impl std::fmt::Debug for CssBogusIfBranch {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        f.debug_struct("CssBogusIfBranch")
-            .field("items", &DebugSyntaxElementChildren(self.items()))
-            .finish()
-    }
-}
-impl From<CssBogusIfBranch> for SyntaxNode {
-    fn from(n: CssBogusIfBranch) -> Self {
-        n.syntax
-    }
-}
-impl From<CssBogusIfBranch> for SyntaxElement {
-    fn from(n: CssBogusIfBranch) -> Self {
-        n.syntax.into()
-    }
-}
-#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
-pub struct CssBogusIfTest {
-    syntax: SyntaxNode,
-}
-impl CssBogusIfTest {
-    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
-    #[doc = r""]
-    #[doc = r" # Safety"]
-    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
-    #[doc = r" or a match on [SyntaxNode::kind]"]
-    #[inline]
-    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
-        Self { syntax }
-    }
-    pub fn items(&self) -> SyntaxElementChildren {
-        support::elements(&self.syntax)
-    }
-}
-impl AstNode for CssBogusIfTest {
-    type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_BOGUS_IF_TEST as u16));
-    fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_BOGUS_IF_TEST
-    }
-    fn cast(syntax: SyntaxNode) -> Option<Self> {
-        if Self::can_cast(syntax.kind()) {
-            Some(Self { syntax })
-        } else {
-            None
-        }
-    }
-    fn syntax(&self) -> &SyntaxNode {
-        &self.syntax
-    }
-    fn into_syntax(self) -> SyntaxNode {
-        self.syntax
-    }
-}
-impl std::fmt::Debug for CssBogusIfTest {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        f.debug_struct("CssBogusIfTest")
-            .field("items", &DebugSyntaxElementChildren(self.items()))
-            .finish()
-    }
-}
-impl From<CssBogusIfTest> for SyntaxNode {
-    fn from(n: CssBogusIfTest) -> Self {
-        n.syntax
-    }
-}
-impl From<CssBogusIfTest> for SyntaxElement {
-    fn from(n: CssBogusIfTest) -> Self {
-        n.syntax.into()
-    }
-}
-#[derive(Clone, PartialEq, Eq, Hash, Serialize)]
 pub struct CssBogusKeyframesItem {
     syntax: SyntaxNode,
 }
@@ -31999,7 +29862,7 @@ impl From<CssValueAtRuleGenericValue> for SyntaxElement {
         n.syntax.into()
     }
 }
-biome_rowan::declare_node_union! { pub AnyCssBogusNode = CssBogus | CssBogusAtRule | CssBogusBlock | CssBogusCustomIdentifier | CssBogusDeclarationItem | CssBogusDocumentMatcher | CssBogusFontFamilyName | CssBogusFontFeatureValuesItem | CssBogusIfBranch | CssBogusIfTest | CssBogusKeyframesItem | CssBogusKeyframesName | CssBogusLayer | CssBogusMediaQuery | CssBogusPageSelectorPseudo | CssBogusParameter | CssBogusProperty | CssBogusPropertyValue | CssBogusPseudoClass | CssBogusPseudoElement | CssBogusRule | CssBogusScopeRange | CssBogusSelector | CssBogusSubSelector | CssBogusSupportsCondition | CssBogusUnicodeRangeValue | CssBogusUrlModifier | CssUnknownAtRuleComponentList | CssValueAtRuleGenericValue }
+biome_rowan::declare_node_union! { pub AnyCssBogusNode = CssBogus | CssBogusAtRule | CssBogusBlock | CssBogusCustomIdentifier | CssBogusDeclarationItem | CssBogusDocumentMatcher | CssBogusFontFamilyName | CssBogusFontFeatureValuesItem | CssBogusKeyframesItem | CssBogusKeyframesName | CssBogusLayer | CssBogusMediaQuery | CssBogusPageSelectorPseudo | CssBogusParameter | CssBogusProperty | CssBogusPropertyValue | CssBogusPseudoClass | CssBogusPseudoElement | CssBogusRule | CssBogusScopeRange | CssBogusSelector | CssBogusSubSelector | CssBogusSupportsCondition | CssBogusUnicodeRangeValue | CssBogusUrlModifier | CssUnknownAtRuleComponentList | CssValueAtRuleGenericValue }
 #[derive(Clone, Eq, PartialEq, Hash)]
 pub struct CssBracketedValueList {
     syntax_list: SyntaxList,
@@ -32985,88 +30848,6 @@ impl IntoIterator for CssGenericComponentValueList {
     }
 }
 #[derive(Clone, Eq, PartialEq, Hash)]
-pub struct CssIfBranchList {
-    syntax_list: SyntaxList,
-}
-impl CssIfBranchList {
-    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
-    #[doc = r""]
-    #[doc = r" # Safety"]
-    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
-    #[doc = r" or a match on [SyntaxNode::kind]"]
-    #[inline]
-    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
-        Self {
-            syntax_list: syntax.into_list(),
-        }
-    }
-}
-impl AstNode for CssIfBranchList {
-    type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(CSS_IF_BRANCH_LIST as u16));
-    fn can_cast(kind: SyntaxKind) -> bool {
-        kind == CSS_IF_BRANCH_LIST
-    }
-    fn cast(syntax: SyntaxNode) -> Option<Self> {
-        if Self::can_cast(syntax.kind()) {
-            Some(Self {
-                syntax_list: syntax.into_list(),
-            })
-        } else {
-            None
-        }
-    }
-    fn syntax(&self) -> &SyntaxNode {
-        self.syntax_list.node()
-    }
-    fn into_syntax(self) -> SyntaxNode {
-        self.syntax_list.into_node()
-    }
-}
-impl Serialize for CssIfBranchList {
-    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
-    where
-        S: Serializer,
-    {
-        let mut seq = serializer.serialize_seq(Some(self.len()))?;
-        for e in self.iter() {
-            seq.serialize_element(&e)?;
-        }
-        seq.end()
-    }
-}
-impl AstSeparatedList for CssIfBranchList {
-    type Language = Language;
-    type Node = AnyCssIfBranch;
-    fn syntax_list(&self) -> &SyntaxList {
-        &self.syntax_list
-    }
-    fn into_syntax_list(self) -> SyntaxList {
-        self.syntax_list
-    }
-}
-impl Debug for CssIfBranchList {
-    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
-        f.write_str("CssIfBranchList ")?;
-        f.debug_list().entries(self.elements()).finish()
-    }
-}
-impl IntoIterator for CssIfBranchList {
-    type Item = SyntaxResult<AnyCssIfBranch>;
-    type IntoIter = AstSeparatedListNodesIterator<Language, AnyCssIfBranch>;
-    fn into_iter(self) -> Self::IntoIter {
-        self.iter()
-    }
-}
-impl IntoIterator for &CssIfBranchList {
-    type Item = SyntaxResult<AnyCssIfBranch>;
-    type IntoIter = AstSeparatedListNodesIterator<Language, AnyCssIfBranch>;
-    fn into_iter(self) -> Self::IntoIter {
-        self.iter()
-    }
-}
-#[derive(Clone, Eq, PartialEq, Hash)]
 pub struct CssKeyframesItemList {
     syntax_list: SyntaxList,
 }
diff --git a/crates/biome_css_syntax/src/generated/nodes_mut.rs b/crates/biome_css_syntax/src/generated/nodes_mut.rs
index 90da81b944..85eaa3f461 100644
--- a/crates/biome_css_syntax/src/generated/nodes_mut.rs
+++ b/crates/biome_css_syntax/src/generated/nodes_mut.rs
@@ -723,14 +723,6 @@ impl CssDocumentCustomMatcher {
         )
     }
 }
-impl CssElseKeyword {
-    pub fn with_else_token(self, element: SyntaxToken) -> Self {
-        Self::unwrap_cast(
-            self.syntax
-                .splice_slots(0usize..=0usize, once(Some(element.into()))),
-        )
-    }
-}
 impl CssEmptyDeclaration {
     pub fn with_semicolon_token(self, element: SyntaxToken) -> Self {
         Self::unwrap_cast(
@@ -933,224 +925,6 @@ impl CssIdentifier {
         )
     }
 }
-impl CssIfBranch {
-    pub fn with_condition(self, element: AnyCssIfCondition) -> Self {
-        Self::unwrap_cast(
-            self.syntax
-                .splice_slots(0usize..=0usize, once(Some(element.into_syntax().into()))),
-        )
-    }
-    pub fn with_colon_token(self, element: SyntaxToken) -> Self {
-        Self::unwrap_cast(
-            self.syntax
-                .splice_slots(1usize..=1usize, once(Some(element.into()))),
-        )
-    }
-    pub fn with_value(self, element: CssGenericComponentValueList) -> Self {
-        Self::unwrap_cast(
-            self.syntax
-                .splice_slots(2usize..=2usize, once(Some(element.into_syntax().into()))),
-        )
-    }
-}
-impl CssIfFunction {
-    pub fn with_if_token(self, element: SyntaxToken) -> Self {
-        Self::unwrap_cast(
-            self.syntax
-                .splice_slots(0usize..=0usize, once(Some(element.into()))),
-        )
-    }
-    pub fn with_l_paren_token(self, element: SyntaxToken) -> Self {
-        Self::unwrap_cast(
-            self.syntax
-                .splice_slots(1usize..=1usize, once(Some(element.into()))),
-        )
-    }
-    pub fn with_css_if_branch_list(self, element: CssIfBranchList) -> Self {
-        Self::unwrap_cast(
-            self.syntax
-                .splice_slots(2usize..=2usize, once(Some(element.into_syntax().into()))),
-        )
-    }
-    pub fn with_r_paren_token(self, element: SyntaxToken) -> Self {
-        Self::unwrap_cast(
-            self.syntax
-                .splice_slots(3usize..=3usize, once(Some(element.into()))),
-        )
-    }
-}
-impl CssIfMediaTest {
-    pub fn with_media_token(self, element: SyntaxToken) -> Self {
-        Self::unwrap_cast(
-            self.syntax
-                .splice_slots(0usize..=0usize, once(Some(element.into()))),
-        )
-    }
-    pub fn with_l_paren_token(self, element: SyntaxToken) -> Self {
-        Self::unwrap_cast(
-            self.syntax
-                .splice_slots(1usize..=1usize, once(Some(element.into()))),
-        )
-    }
-    pub fn with_test(self, element: AnyCssIfMediaTestQuery) -> Self {
-        Self::unwrap_cast(
-            self.syntax
-                .splice_slots(2usize..=2usize, once(Some(element.into_syntax().into()))),
-        )
-    }
-    pub fn with_r_paren_token(self, element: SyntaxToken) -> Self {
-        Self::unwrap_cast(
-            self.syntax
-                .splice_slots(3usize..=3usize, once(Some(element.into()))),
-        )
-    }
-}
-impl CssIfStyleTest {
-    pub fn with_style_token(self, element: SyntaxToken) -> Self {
-        Self::unwrap_cast(
-            self.syntax
-                .splice_slots(0usize..=0usize, once(Some(element.into()))),
-        )
-    }
-    pub fn with_l_paren_token(self, element: SyntaxToken) -> Self {
-        Self::unwrap_cast(
-            self.syntax
-                .splice_slots(1usize..=1usize, once(Some(element.into()))),
-        )
-    }
-    pub fn with_test(self, element: AnyCssContainerStyleQuery) -> Self {
-        Self::unwrap_cast(
-            self.syntax
-                .splice_slots(2usize..=2usize, once(Some(element.into_syntax().into()))),
-        )
-    }
-    pub fn with_r_paren_token(self, element: SyntaxToken) -> Self {
-        Self::unwrap_cast(
-            self.syntax
-                .splice_slots(3usize..=3usize, once(Some(element.into()))),
-        )
-    }
-}
-impl CssIfSupportsIdentifierTest {
-    pub fn with_ident(self, element: CssIdentifier) -> Self {
-        Self::unwrap_cast(
-            self.syntax
-                .splice_slots(0usize..=0usize, once(Some(element.into_syntax().into()))),
-        )
-    }
-    pub fn with_colon_token(self, element: SyntaxToken) -> Self {
-        Self::unwrap_cast(
-            self.syntax
-                .splice_slots(1usize..=1usize, once(Some(element.into()))),
-        )
-    }
-    pub fn with_value(self, element: AnyCssGenericComponentValue) -> Self {
-        Self::unwrap_cast(
-            self.syntax
-                .splice_slots(2usize..=2usize, once(Some(element.into_syntax().into()))),
-        )
-    }
-}
-impl CssIfSupportsTest {
-    pub fn with_supports_token(self, element: SyntaxToken) -> Self {
-        Self::unwrap_cast(
-            self.syntax
-                .splice_slots(0usize..=0usize, once(Some(element.into()))),
-        )
-    }
-    pub fn with_l_paren_token(self, element: SyntaxToken) -> Self {
-        Self::unwrap_cast(
-            self.syntax
-                .splice_slots(1usize..=1usize, once(Some(element.into()))),
-        )
-    }
-    pub fn with_test(self, element: AnyCssIfSupportsTestCondition) -> Self {
-        Self::unwrap_cast(
-            self.syntax
-                .splice_slots(2usize..=2usize, once(Some(element.into_syntax().into()))),
-        )
-    }
-    pub fn with_r_paren_token(self, element: SyntaxToken) -> Self {
-        Self::unwrap_cast(
-            self.syntax
-                .splice_slots(3usize..=3usize, once(Some(element.into()))),
-        )
-    }
-}
-impl CssIfTestBooleanAndExpr {
-    pub fn with_left(self, element: AnyCssIfTestBooleanExprGroup) -> Self {
-        Self::unwrap_cast(
-            self.syntax
-                .splice_slots(0usize..=0usize, once(Some(element.into_syntax().into()))),
-        )
-    }
-    pub fn with_and_token(self, element: SyntaxToken) -> Self {
-        Self::unwrap_cast(
-            self.syntax
-                .splice_slots(1usize..=1usize, once(Some(element.into()))),
-        )
-    }
-    pub fn with_right(self, element: AnyCssIfTestBooleanAndCombinableExpr) -> Self {
-        Self::unwrap_cast(
-            self.syntax
-                .splice_slots(2usize..=2usize, once(Some(element.into_syntax().into()))),
-        )
-    }
-}
-impl CssIfTestBooleanExprInParens {
-    pub fn with_l_paren_token(self, element: SyntaxToken) -> Self {
-        Self::unwrap_cast(
-            self.syntax
-                .splice_slots(0usize..=0usize, once(Some(element.into()))),
-        )
-    }
-    pub fn with_expression(self, element: AnyCssIfTestBooleanExpr) -> Self {
-        Self::unwrap_cast(
-            self.syntax
-                .splice_slots(1usize..=1usize, once(Some(element.into_syntax().into()))),
-        )
-    }
-    pub fn with_r_paren_token(self, element: SyntaxToken) -> Self {
-        Self::unwrap_cast(
-            self.syntax
-                .splice_slots(2usize..=2usize, once(Some(element.into()))),
-        )
-    }
-}
-impl CssIfTestBooleanNotExpr {
-    pub fn with_not_token(self, element: SyntaxToken) -> Self {
-        Self::unwrap_cast(
-            self.syntax
-                .splice_slots(0usize..=0usize, once(Some(element.into()))),
-        )
-    }
-    pub fn with_expression(self, element: AnyCssIfTestBooleanExprGroup) -> Self {
-        Self::unwrap_cast(
-            self.syntax
-                .splice_slots(1usize..=1usize, once(Some(element.into_syntax().into()))),
-        )
-    }
-}
-impl CssIfTestBooleanOrExpr {
-    pub fn with_left(self, element: AnyCssIfTestBooleanExprGroup) -> Self {
-        Self::unwrap_cast(
-            self.syntax
-                .splice_slots(0usize..=0usize, once(Some(element.into_syntax().into()))),
-        )
-    }
-    pub fn with_or_token(self, element: SyntaxToken) -> Self {
-        Self::unwrap_cast(
-            self.syntax
-                .splice_slots(1usize..=1usize, once(Some(element.into()))),
-        )
-    }
-    pub fn with_right(self, element: AnyCssIfTestBooleanOrCombinableExpr) -> Self {
-        Self::unwrap_cast(
-            self.syntax
-                .splice_slots(2usize..=2usize, once(Some(element.into_syntax().into()))),
-        )
-    }
-}
 impl CssImportAnonymousLayer {
     pub fn with_layer_token(self, element: SyntaxToken) -> Self {
         Self::unwrap_cast(
diff --git a/crates/biome_grit_patterns/src/grit_target_language/css_target_language/generated_mappings.rs b/crates/biome_grit_patterns/src/grit_target_language/css_target_language/generated_mappings.rs
index b65422d924..8ac94dc133 100644
--- a/crates/biome_grit_patterns/src/grit_target_language/css_target_language/generated_mappings.rs
+++ b/crates/biome_grit_patterns/src/grit_target_language/css_target_language/generated_mappings.rs
@@ -61,7 +61,6 @@ pub fn kind_by_name(node_name: &str) -> Option<CssSyntaxKind> {
         "CssDeclarationWithSemicolon" => lang::CssDeclarationWithSemicolon::KIND_SET.iter().next(),
         "CssDocumentAtRule" => lang::CssDocumentAtRule::KIND_SET.iter().next(),
         "CssDocumentCustomMatcher" => lang::CssDocumentCustomMatcher::KIND_SET.iter().next(),
-        "CssElseKeyword" => lang::CssElseKeyword::KIND_SET.iter().next(),
         "CssEmptyDeclaration" => lang::CssEmptyDeclaration::KIND_SET.iter().next(),
         "CssFontFaceAtRule" => lang::CssFontFaceAtRule::KIND_SET.iter().next(),
         "CssFontFaceAtRuleDeclarator" => lang::CssFontFaceAtRuleDeclarator::KIND_SET.iter().next(),
@@ -80,18 +79,6 @@ pub fn kind_by_name(node_name: &str) -> Option<CssSyntaxKind> {
         "CssGenericProperty" => lang::CssGenericProperty::KIND_SET.iter().next(),
         "CssIdSelector" => lang::CssIdSelector::KIND_SET.iter().next(),
         "CssIdentifier" => lang::CssIdentifier::KIND_SET.iter().next(),
-        "CssIfBranch" => lang::CssIfBranch::KIND_SET.iter().next(),
-        "CssIfFunction" => lang::CssIfFunction::KIND_SET.iter().next(),
-        "CssIfMediaTest" => lang::CssIfMediaTest::KIND_SET.iter().next(),
-        "CssIfStyleTest" => lang::CssIfStyleTest::KIND_SET.iter().next(),
-        "CssIfSupportsIdentifierTest" => lang::CssIfSupportsIdentifierTest::KIND_SET.iter().next(),
-        "CssIfSupportsTest" => lang::CssIfSupportsTest::KIND_SET.iter().next(),
-        "CssIfTestBooleanAndExpr" => lang::CssIfTestBooleanAndExpr::KIND_SET.iter().next(),
-        "CssIfTestBooleanExprInParens" => {
-            lang::CssIfTestBooleanExprInParens::KIND_SET.iter().next()
-        }
-        "CssIfTestBooleanNotExpr" => lang::CssIfTestBooleanNotExpr::KIND_SET.iter().next(),
-        "CssIfTestBooleanOrExpr" => lang::CssIfTestBooleanOrExpr::KIND_SET.iter().next(),
         "CssImportAnonymousLayer" => lang::CssImportAnonymousLayer::KIND_SET.iter().next(),
         "CssImportAtRule" => lang::CssImportAtRule::KIND_SET.iter().next(),
         "CssImportNamedLayer" => lang::CssImportNamedLayer::KIND_SET.iter().next(),
diff --git a/crates/biome_html_analyze/src/lint/nursery/no_sync_scripts.rs b/crates/biome_html_analyze/src/lint/nursery/no_sync_scripts.rs
index 14bb3a2b9b..6c3c6bd66c 100644
--- a/crates/biome_html_analyze/src/lint/nursery/no_sync_scripts.rs
+++ b/crates/biome_html_analyze/src/lint/nursery/no_sync_scripts.rs
@@ -24,7 +24,6 @@ declare_lint_rule! {
     /// ```html
     /// <script src="" async></script>
     /// <script src="" defer></script>
-    /// <script src="" type="module"></script>
     /// ```
     ///
     pub NoSyncScripts {
@@ -53,17 +52,6 @@ impl Rule for NoSyncScripts {
 
         let attributes = binding.attributes();
         if attributes.find_by_name("src").is_none()
-            || attributes.find_by_name("type").is_some_and(|attribute| {
-                attribute.initializer().is_some_and(|initializer| {
-                    initializer.value().ok().is_some_and(|value| {
-                        value.as_html_string().is_some_and(|html_string| {
-                            html_string
-                                .inner_string_text()
-                                .is_ok_and(|inner_string| inner_string.text() == "module")
-                        })
-                    })
-                })
-            })
             || attributes.find_by_name("async").is_some()
             || attributes.find_by_name("defer").is_some()
         {
diff --git a/crates/biome_html_factory/src/make.rs b/crates/biome_html_factory/src/make.rs
index ef5007be66..df4cffff53 100644
--- a/crates/biome_html_factory/src/make.rs
+++ b/crates/biome_html_factory/src/make.rs
@@ -5,13 +5,3 @@ pub use crate::generated::node_factory::*;
 pub fn ident(text: &str) -> HtmlSyntaxToken {
     HtmlSyntaxToken::new_detached(HtmlSyntaxKind::IDENT, text, [], [])
 }
-
-/// Create a new string literal token with no attached trivia
-pub fn html_string_literal(text: &str) -> HtmlSyntaxToken {
-    HtmlSyntaxToken::new_detached(
-        HtmlSyntaxKind::HTML_STRING_LITERAL,
-        &format!("\"{text}\""),
-        [],
-        [],
-    )
-}
diff --git a/crates/biome_html_syntax/src/lib.rs b/crates/biome_html_syntax/src/lib.rs
index 0a9717abb2..4dea369c58 100644
--- a/crates/biome_html_syntax/src/lib.rs
+++ b/crates/biome_html_syntax/src/lib.rs
@@ -6,7 +6,6 @@ pub mod element_ext;
 mod file_source;
 mod generated;
 mod script_type;
-mod string_ext;
 mod syntax_node;
 
 pub use biome_rowan::{TextLen, TextRange, TextSize, TokenAtOffset, TriviaPieceKind, WalkEvent};
diff --git a/crates/biome_html_syntax/src/string_ext.rs b/crates/biome_html_syntax/src/string_ext.rs
deleted file mode 100644
index c3a1c5227a..0000000000
--- a/crates/biome_html_syntax/src/string_ext.rs
+++ /dev/null
@@ -1,20 +0,0 @@
-use crate::{HtmlString, inner_string_text};
-use biome_rowan::{SyntaxResult, TokenText};
-
-impl HtmlString {
-    /// Returns the inner text of a string not including the quotes.
-    ///
-    /// ## Examples
-    ///
-    /// ```
-    /// use biome_html_factory::make;
-    /// use biome_rowan::TriviaPieceKind;
-    ///
-    ///let string = make::html_string(make::html_string_literal("button")
-    ///     .with_leading_trivia(vec![(TriviaPieceKind::Whitespace, " ")]));
-    /// assert_eq!(string.inner_string_text().unwrap().text(), "button");
-    /// ```
-    pub fn inner_string_text(&self) -> SyntaxResult<TokenText> {
-        Ok(inner_string_text(&self.value_token()?))
-    }
-}
diff --git a/crates/biome_js_analyze/src/lint/nursery/no_sync_scripts.rs b/crates/biome_js_analyze/src/lint/nursery/no_sync_scripts.rs
index 67fb95faa6..ed54c0d39d 100644
--- a/crates/biome_js_analyze/src/lint/nursery/no_sync_scripts.rs
+++ b/crates/biome_js_analyze/src/lint/nursery/no_sync_scripts.rs
@@ -29,7 +29,6 @@ declare_lint_rule! {
     ///     <>
     ///       <script src="https://third-party-script.js" async />
     ///       <script src="https://third-party-script.js" defer />
-    ///       <script src="https://third-party-script.js" type="module" />
     ///     </>
     ///   );
     /// }
@@ -72,17 +71,6 @@ fn validate_name(node: &AnyJsxElementName) -> Option<()> {
 
 fn validate_attributes(list: &JsxAttributeList) -> Option<()> {
     if list.find_by_name("src").is_none()
-        || list.find_by_name("type").is_some_and(|attribute| {
-            attribute.initializer().is_some_and(|initializer| {
-                initializer.value().ok().is_some_and(|value| {
-                    value.as_jsx_string().is_some_and(|jsx_string| {
-                        jsx_string
-                            .inner_string_text()
-                            .is_ok_and(|inner_string| inner_string.text() == "module")
-                    })
-                })
-            })
-        })
         || list.find_by_name("async").is_some()
         || list.find_by_name("defer").is_some()
     {
diff --git a/crates/biome_js_type_info/src/format_type_info.rs b/crates/biome_js_type_info/src/format_type_info.rs
index c2e8f7471c..88de813555 100644
--- a/crates/biome_js_type_info/src/format_type_info.rs
+++ b/crates/biome_js_type_info/src/format_type_info.rs
@@ -788,23 +788,50 @@ impl Format<FormatTypeContext> for Interface {
 
 impl Format<FormatTypeContext> for Literal {
     fn fmt(&self, f: &mut Formatter<FormatTypeContext>) -> FormatResult<()> {
-        write!(f, [&format_args![token("value:"), space()]])?;
         match self {
-            Self::BigInt(bigint_text) => write!(f, [text(bigint_text, TextSize::default())]),
+            Self::BigInt(bigint_text) => write!(
+                f,
+                [
+                    token("bigint:"),
+                    space(),
+                    text(bigint_text, TextSize::default())
+                ]
+            ),
             Self::Boolean(lit) => write!(
                 f,
-                [text(
-                    lit.as_bool().to_string().as_str(),
-                    TextSize::default()
-                )]
+                [
+                    token("bool:"),
+                    space(),
+                    text(lit.as_bool().to_string().as_str(), TextSize::default())
+                ]
             ),
             Self::Number(lit) => {
-                write!(f, [text(lit.as_str(), TextSize::default())])
+                write!(
+                    f,
+                    [
+                        token("number:"),
+                        space(),
+                        text(lit.as_str(), TextSize::default())
+                    ]
+                )
             }
             Self::Object(obj) => write!(f, [&obj]),
-            Self::RegExp(regexp_text) => write!(f, [text(regexp_text, TextSize::default())]),
-            Self::String(lit) => write!(f, [text(lit.as_str(), TextSize::default())]),
-            Self::Template(template_text) => write!(f, [text(template_text, TextSize::default())]),
+            Self::RegExp(regex) => write!(
+                f,
+                [token("regex:"), space(), text(regex, TextSize::default())]
+            ),
+            Self::String(lit) => write!(
+                f,
+                [
+                    token("string:"),
+                    space(),
+                    text(lit.as_str(), TextSize::default())
+                ]
+            ),
+            Self::Template(tmpl) => write!(
+                f,
+                [token("string:"), space(), text(tmpl, TextSize::default())]
+            ),
         }
     }
 }
diff --git a/crates/biome_js_type_info/src/globals.rs b/crates/biome_js_type_info/src/globals.rs
index d69bf821e0..29df93aa87 100644
--- a/crates/biome_js_type_info/src/globals.rs
+++ b/crates/biome_js_type_info/src/globals.rs
@@ -1,6 +1,6 @@
 //! Hardcoded global definitions.
 
-// FIXME: Implement inference from type definitions.
+// FIXME: Implement inference from type definitions: https://github.com/biomejs/biome/issues/5977
 
 use std::{
     borrow::Cow,
@@ -59,22 +59,25 @@ pub const PROMISE_RACE_ID: TypeId = TypeId::new(22);
 pub const PROMISE_REJECT_ID: TypeId = TypeId::new(23);
 pub const PROMISE_RESOLVE_ID: TypeId = TypeId::new(24);
 pub const PROMISE_TRY_ID: TypeId = TypeId::new(25);
-pub const BIGINT_STRING_LITERAL_ID: TypeId = TypeId::new(26);
-pub const BOOLEAN_STRING_LITERAL_ID: TypeId = TypeId::new(27);
-pub const FUNCTION_STRING_LITERAL_ID: TypeId = TypeId::new(28);
-pub const NUMBER_STRING_LITERAL_ID: TypeId = TypeId::new(29);
-pub const OBJECT_STRING_LITERAL_ID: TypeId = TypeId::new(30);
-pub const STRING_STRING_LITERAL_ID: TypeId = TypeId::new(31);
-pub const SYMBOL_STRING_LITERAL_ID: TypeId = TypeId::new(32);
-pub const UNDEFINED_STRING_LITERAL_ID: TypeId = TypeId::new(33);
-pub const TYPEOF_OPERATOR_RETURN_UNION_ID: TypeId = TypeId::new(34);
-pub const T_ID: TypeId = TypeId::new(35);
-pub const U_ID: TypeId = TypeId::new(36);
-pub const CONDITIONAL_CALLBACK_ID: TypeId = TypeId::new(37);
-pub const MAP_CALLBACK_ID: TypeId = TypeId::new(38);
-pub const VOID_CALLBACK_ID: TypeId = TypeId::new(39);
-pub const FETCH_ID: TypeId = TypeId::new(40);
-pub const NUM_PREDEFINED_TYPES: usize = 41; // Must be one more than the highest `TypeId` above.
+pub const INSTANCEOF_REGEXP_ID: TypeId = TypeId::new(26);
+pub const REGEXP_ID: TypeId = TypeId::new(27);
+pub const REGEXP_EXEC_ID: TypeId = TypeId::new(28);
+pub const BIGINT_STRING_LITERAL_ID: TypeId = TypeId::new(29);
+pub const BOOLEAN_STRING_LITERAL_ID: TypeId = TypeId::new(30);
+pub const FUNCTION_STRING_LITERAL_ID: TypeId = TypeId::new(31);
+pub const NUMBER_STRING_LITERAL_ID: TypeId = TypeId::new(32);
+pub const OBJECT_STRING_LITERAL_ID: TypeId = TypeId::new(33);
+pub const STRING_STRING_LITERAL_ID: TypeId = TypeId::new(34);
+pub const SYMBOL_STRING_LITERAL_ID: TypeId = TypeId::new(35);
+pub const UNDEFINED_STRING_LITERAL_ID: TypeId = TypeId::new(36);
+pub const TYPEOF_OPERATOR_RETURN_UNION_ID: TypeId = TypeId::new(37);
+pub const T_ID: TypeId = TypeId::new(38);
+pub const U_ID: TypeId = TypeId::new(39);
+pub const CONDITIONAL_CALLBACK_ID: TypeId = TypeId::new(40);
+pub const MAP_CALLBACK_ID: TypeId = TypeId::new(41);
+pub const VOID_CALLBACK_ID: TypeId = TypeId::new(42);
+pub const FETCH_ID: TypeId = TypeId::new(43);
+pub const NUM_PREDEFINED_TYPES: usize = 44; // Must be one more than the highest `TypeId` above.
 
 pub const GLOBAL_UNKNOWN_ID: ResolvedTypeId = ResolvedTypeId::new(GLOBAL_LEVEL, UNKNOWN_ID);
 pub const GLOBAL_UNDEFINED_ID: ResolvedTypeId = ResolvedTypeId::new(GLOBAL_LEVEL, UNDEFINED_ID);
@@ -83,6 +86,9 @@ pub const GLOBAL_CONDITIONAL_ID: ResolvedTypeId = ResolvedTypeId::new(GLOBAL_LEV
 pub const GLOBAL_NUMBER_ID: ResolvedTypeId = ResolvedTypeId::new(GLOBAL_LEVEL, NUMBER_ID);
 pub const GLOBAL_STRING_ID: ResolvedTypeId = ResolvedTypeId::new(GLOBAL_LEVEL, STRING_ID);
 pub const GLOBAL_ARRAY_ID: ResolvedTypeId = ResolvedTypeId::new(GLOBAL_LEVEL, ARRAY_ID);
+pub const GLOBAL_INSTANCEOF_REGEXP_ID: ResolvedTypeId =
+    ResolvedTypeId::new(GLOBAL_LEVEL, INSTANCEOF_REGEXP_ID);
+pub const GLOBAL_REGEXP_ID: ResolvedTypeId = ResolvedTypeId::new(GLOBAL_LEVEL, REGEXP_ID);
 pub const GLOBAL_GLOBAL_ID /* :smirk: */: ResolvedTypeId = ResolvedTypeId::new(GLOBAL_LEVEL, GLOBAL_ID);
 pub const GLOBAL_INSTANCEOF_PROMISE_ID: ResolvedTypeId =
     ResolvedTypeId::new(GLOBAL_LEVEL, INSTANCEOF_PROMISE_ID);
@@ -140,24 +146,27 @@ pub fn global_type_name(id: TypeId) -> &'static str {
         23 => "Promise.reject",
         24 => "Promise.resolve",
         25 => "Promise.try",
-        26 => "\"bigint\"",
-        27 => "\"boolean\"",
-        28 => "\"function\"",
-        29 => "\"number\"",
-        30 => "\"object\"",
-        31 => "\"string\"",
-        32 => "\"symbol\"",
-        33 => "\"undefined\"",
-        34 => {
+        26 => "instanceof RegExp",
+        27 => "RegExp",
+        28 => "RegExp.exec",
+        29 => "\"bigint\"",
+        30 => "\"boolean\"",
+        31 => "\"function\"",
+        32 => "\"number\"",
+        33 => "\"object\"",
+        34 => "\"string\"",
+        35 => "\"symbol\"",
+        36 => "\"undefined\"",
+        37 => {
             "\"bigint\" | \"boolean\" | \"function\" | \"number\" | \"object\" \
                 | \"string\" | \"symbol\" | \"undefined\""
         }
-        35 => "T",
-        36 => "U",
-        37 => "() => conditional",
-        38 => "<U>(item: T) => U",
-        39 => "() => void",
-        40 => "fetch",
+        38 => "T",
+        39 => "U",
+        40 => "() => conditional",
+        41 => "<U>(item: T) => U",
+        42 => "() => void",
+        43 => "fetch",
         _ => "inferred type",
     }
 }
@@ -215,6 +224,16 @@ impl Default for GlobalsResolver {
             })
         };
 
+        let regexp_method_definition = |id: TypeId| {
+            TypeData::from(Function {
+                is_async: false,
+                type_parameters: Default::default(),
+                name: Some(Text::new_static(global_type_name(id))),
+                parameters: Default::default(),
+                return_type: ReturnType::Type(GLOBAL_INSTANCEOF_REGEXP_ID.into()),
+            })
+        };
+
         let string_literal = |value: &'static str| -> TypeData {
             TypeData::from(Literal::String(Text::new_static(value).into()))
         };
@@ -311,6 +330,15 @@ impl Default for GlobalsResolver {
             promise_method_definition(PROMISE_REJECT_ID),
             promise_method_definition(PROMISE_RESOLVE_ID),
             promise_method_definition(PROMISE_TRY_ID),
+            TypeData::instance_of(TypeReference::from(GLOBAL_REGEXP_ID)),
+            TypeData::Class(Box::new(Class {
+                name: Some(Text::new_static("RegExp")),
+                type_parameters: Box::default(),
+                extends: None,
+                implements: [].into(),
+                members: Box::new([method("exec", REGEXP_EXEC_ID)]),
+            })),
+            regexp_method_definition(REGEXP_EXEC_ID),
             string_literal("bigint"),
             string_literal("boolean"),
             string_literal("function"),
@@ -454,6 +482,8 @@ impl TypeResolver for GlobalsResolver {
             Some(GLOBAL_ARRAY_ID)
         } else if qualifier.is_promise() && !qualifier.has_known_type_parameters() {
             Some(GLOBAL_PROMISE_ID)
+        } else if qualifier.is_regex() && !qualifier.has_known_type_parameters() {
+            Some(GLOBAL_REGEXP_ID)
         } else if !qualifier.type_only
             && let Some(ident) = qualifier.path.identifier()
         {
diff --git a/crates/biome_js_type_info/src/type_data.rs b/crates/biome_js_type_info/src/type_data.rs
index 321e2b253e..1ad0c83de1 100644
--- a/crates/biome_js_type_info/src/type_data.rs
+++ b/crates/biome_js_type_info/src/type_data.rs
@@ -1402,6 +1402,17 @@ impl TypeReferenceQualifier {
         self.path.is_identifier("Promise")
     }
 
+    /// Checks whether this type qualifier references the `RegExp` type.
+    ///
+    /// This method simply checks whether the reference is for a literal
+    /// `RegExp`, without considering whether another symbol named `RegExp` is
+    /// in scope. It can be used _after_ type resolution has failed to find a
+    /// `RegExp` symbol in scope, but should not be used _instead of_ such type
+    /// resolution.
+    pub fn is_regex(&self) -> bool {
+        self.path.is_identifier("RegExp")
+    }
+
     pub fn with_excluded_binding_id(mut self, binding_id: BindingId) -> Self {
         self.excluded_binding_id = Some(binding_id);
         self
diff --git a/xtask/codegen/css.ungram b/xtask/codegen/css.ungram
index 9180d8a9ad..f9b420577f 100644
--- a/xtask/codegen/css.ungram
+++ b/xtask/codegen/css.ungram
@@ -61,8 +61,6 @@ CssBogusCustomIdentifier = SyntaxElement*
 CssBogusKeyframesName = SyntaxElement*
 CssBogusUnicodeRangeValue = SyntaxElement*
 CssBogusSupportsCondition = SyntaxElement*
-CssBogusIfBranch = SyntaxElement*
-CssBogusIfTest = SyntaxElement*
 
 CssRoot =
 	bom: 'UNICODE_BOM'?
@@ -1801,7 +1799,6 @@ CssRatio =
 AnyCssFunction =
 	CssFunction
 	| CssUrlFunction
-	| CssIfFunction
 
 // content: counter(section);
 // 					^^^^^^^^^^^^^^^^
@@ -1847,117 +1844,6 @@ CssParameterList = CssParameter (',' CssParameter)* ','?
 //                                ^^^^^^^^^^
 CssParameter = AnyCssExpression
 
-// https://drafts.csswg.org/css-values-5/#if-notation
-// <if()> = if( [ <if-branch> ; ]* <if-branch> ;? )
-// <if-branch> = <if-condition> : <declaration-value>?
-// <if-condition> = <boolean-expr[ <if-test> ]> | else
-// <if-test> =
-//  supports( [ <ident> : <declaration-value> ] | <supports-condition> ) |
-//  media( <media-feature> | <media-condition> ) |
-//  style( <style-query> )
-CssIfFunction =
-	'if'
-	'('
-	CssIfBranchList
-	')'
-
-CssIfBranchList = AnyCssIfBranch (';' AnyCssIfBranch)* ';'?
-
-// https://drafts.csswg.org/css-values-5/#typedef-boolean-expr
-
-// <boolean-expr[ <if-test> ]> =
-//   not <boolean-expr-group>
-//   | <boolean-expr-group> [ [ and <boolean-expr-group> ]* | [ or <boolean-expr-group> ]* ]
-AnyCssIfTestBooleanExpr =
-	CssIfTestBooleanNotExpr
-	| AnyCssIfTestBooleanAndCombinableExpr
-	| AnyCssIfTestBooleanOrCombinableExpr
-
-// not <boolean-expr-group>
-CssIfTestBooleanNotExpr =
-	'not'
-	expression: AnyCssIfTestBooleanExprGroup
-
-AnyCssIfTestBooleanAndCombinableExpr =
-	AnyCssIfTestBooleanExprGroup
-	| CssIfTestBooleanAndExpr
-
-CssIfTestBooleanAndExpr =
-	left: AnyCssIfTestBooleanExprGroup
-	'and'
-	right: AnyCssIfTestBooleanAndCombinableExpr
-
-AnyCssIfTestBooleanOrCombinableExpr =
-	AnyCssIfTestBooleanExprGroup
-	| CssIfTestBooleanOrExpr
-
-CssIfTestBooleanOrExpr =
-	left: AnyCssIfTestBooleanExprGroup
-	'or'
-	right: AnyCssIfTestBooleanOrCombinableExpr
-
-// <boolean-expr-group> = <if-test> | ( <boolean-expr> )
-AnyCssIfTestBooleanExprGroup =
-	AnyCssIfTest
-	| CssIfTestBooleanExprInParens
-
-// ( <boolean-expr> )
-CssIfTestBooleanExprInParens =
-	'('
-	expression: AnyCssIfTestBooleanExpr
-	')'
-
-CssElseKeyword = 'else'
-
-AnyCssIfCondition = AnyCssIfTestBooleanExpr | CssElseKeyword
-
-CssIfBranch =
-	condition: AnyCssIfCondition
-	':'
-	value: CssGenericComponentValueList
-
-AnyCssIfBranch =
-	CssIfBranch
-	| CssBogusIfBranch
-
-CssIfSupportsIdentifierTest =
-	ident: CssIdentifier
-	':'
-	value: AnyCssGenericComponentValue
-
-AnyCssIfSupportsTestCondition =
-	CssIfSupportsIdentifierTest
-	| AnyCssImportSupportsCondition
-
-CssIfSupportsTest =
-	'supports'
-	'('
-	test: AnyCssIfSupportsTestCondition
-	')'
-
-AnyCssIfMediaTestQuery =
-	AnyCssMediaCondition
-	| AnyCssQueryFeature
-
-CssIfMediaTest =
-	'media'
-	'('
-	test: AnyCssIfMediaTestQuery
-	')'
-
-CssIfStyleTest =
-	'style'
-	'('
-	test: AnyCssContainerStyleQuery
-	')'
-
-AnyCssIfTest =
-	CssIfSupportsTest
-	| CssIfMediaTest
-	| CssIfStyleTest
-	| CssBogusIfTest
-
-
 AnyCssExpression =
 	CssBinaryExpression
 	| CssParenthesizedExpression
diff --git a/xtask/codegen/src/css_kinds_src.rs b/xtask/codegen/src/css_kinds_src.rs
index 0cbb9b2013..f309f100cc 100644
--- a/xtask/codegen/src/css_kinds_src.rs
+++ b/xtask/codegen/src/css_kinds_src.rs
@@ -93,8 +93,6 @@ pub const CSS_KINDS_SRC: KindsSrc = KindsSrc {
         "to",
         "var",
         "url",
-        "if",
-        "else",
         "src",
         "font-palette-values",
         "font-feature-values",
@@ -386,18 +384,6 @@ pub const CSS_KINDS_SRC: KindsSrc = KindsSrc {
         "CSS_BINARY_EXPRESSION",
         "CSS_URL_VALUE_RAW",
         "CSS_URL_FUNCTION",
-        "CSS_IF_FUNCTION",
-        "CSS_IF_BRANCH_LIST",
-        "CSS_IF_BRANCH",
-        "CSS_ELSE_KEYWORD",
-        "CSS_IF_SUPPORTS_TEST",
-        "CSS_IF_STYLE_TEST",
-        "CSS_IF_MEDIA_TEST",
-        "CSS_IF_SUPPORTS_IDENTIFIER_TEST",
-        "CSS_IF_TEST_BOOLEAN_NOT_EXPR",
-        "CSS_IF_TEST_BOOLEAN_AND_EXPR",
-        "CSS_IF_TEST_BOOLEAN_OR_EXPR",
-        "CSS_IF_TEST_BOOLEAN_EXPR_IN_PARENS",
         "CSS_URL_MODIFIER_LIST",
         "CSS_COLOR",
         "CSS_BORDER",
@@ -574,8 +560,6 @@ pub const CSS_KINDS_SRC: KindsSrc = KindsSrc {
         "CSS_BOGUS_KEYFRAMES_NAME",
         "CSS_BOGUS_UNICODE_RANGE_VALUE",
         "CSS_BOGUS_SUPPORTS_CONDITION",
-        "CSS_BOGUS_IF_BRANCH",
-        "CSS_BOGUS_IF_TEST",
         // Grit metavariable
         "CSS_METAVARIABLE",
     ],
