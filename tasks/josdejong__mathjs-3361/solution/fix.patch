diff --git a/src/expression/transform/index.transform.js b/src/expression/transform/index.transform.js
index 94b667296..40ffe3694 100644
--- a/src/expression/transform/index.transform.js
+++ b/src/expression/transform/index.transform.js
@@ -1,4 +1,6 @@
-import { isArray, isBigNumber, isMatrix, isNumber, isRange } from '../../utils/is.js'
+import {
+  isArray, isBigInt, isBigNumber, isMatrix, isNumber, isRange
+} from '../../utils/is.js'
 import { factory } from '../../utils/factory.js'
 
 const name = 'index'
@@ -26,14 +28,14 @@ export const createIndexTransform = /* #__PURE__ */ factory(name, dependencies,
         if (getMatrixDataType(arg) !== 'boolean') {
           arg = arg.map(function (v) { return v - 1 })
         }
-      } else if (isNumber(arg)) {
+      } else if (isNumber(arg) || isBigInt(arg)) {
         arg--
       } else if (isBigNumber(arg)) {
         arg = arg.toNumber() - 1
       } else if (typeof arg === 'string') {
       // leave as is
       } else {
-        throw new TypeError('Dimension must be an Array, Matrix, number, string, or Range')
+        throw new TypeError('Dimension must be an Array, Matrix, number, bigint, string, or Range')
       }
 
       args[i] = arg
diff --git a/src/function/matrix/range.js b/src/function/matrix/range.js
index 1c6abe64e..f96836bb9 100644
--- a/src/function/matrix/range.js
+++ b/src/function/matrix/range.js
@@ -25,37 +25,51 @@ export const createRange = /* #__PURE__ */ factory(name, dependencies, ({ typed,
    *
    * - `str: string`
    *   A string 'start:end' or 'start:step:end'
-   * - `start: {number | BigNumber | Unit}`
+   * - `start: {number | bigint | BigNumber | Fraction | Unit}`
    *   Start of the range
-   * - `end: number | BigNumber | Unit`
+   * - `end: number | bigint | BigNumber | Fraction | Unit`
    *   End of the range, excluded by default, included when parameter includeEnd=true
-   * - `step: number | BigNumber | Unit`
+   * - `step: number | bigint | BigNumber | Fraction | Unit`
    *   Step size. Default value is 1.
    * - `includeEnd: boolean`
    *   Option to specify whether to include the end or not. False by default.
    *
+   * Note that the return type of the range is taken from the type of
+   * the start/end. If only one these is a built-in `number` type, it will
+   * be promoted to the type of the other endpoint. However, in the case of
+   * Unit values, both endpoints must have compatible units, and the return
+   * value will have compatible units as well.
+   *
    * Examples:
    *
    *     math.range(2, 6)        // [2, 3, 4, 5]
    *     math.range(2, -3, -1)   // [2, 1, 0, -1, -2]
    *     math.range('2:1:6')     // [2, 3, 4, 5]
    *     math.range(2, 6, true)  // [2, 3, 4, 5, 6]
+   *     math.range(2, math.fraction(8,3), math.fraction(1,3)) // [fraction(2), fraction(7,3)]
    *     math.range(math.unit(2, 'm'), math.unit(-3, 'm'), math.unit(-1, 'm')) // [2 m, 1 m, 0 m , -1 m, -2 m]
    *
    * See also:
    *
    *     ones, zeros, size, subset
    *
-   * @param {*} args   Parameters describing the ranges `start`, `end`, and optional `step`.
+   * @param {*} args   Parameters describing the range's `start`, `end`, and optional `step`.
    * @return {Array | Matrix} range
    */
   return typed(name, {
     // TODO: simplify signatures when typed-function supports default values and optional arguments
 
-    // TODO: a number or boolean should not be converted to string here
     string: _strRange,
     'string, boolean': _strRange,
 
+    number: function (oops) {
+      throw new TypeError(`Too few arguments to function range(): ${oops}`)
+    },
+
+    boolean: function (oops) {
+      throw new TypeError(`Unexpected type of argument 1 to function range(): ${oops}, number|bigint|BigNumber|Fraction`)
+    },
+
     'number, number': function (start, end) {
       return _out(_range(start, end, 1, false))
     },
@@ -69,6 +83,32 @@ export const createRange = /* #__PURE__ */ factory(name, dependencies, ({ typed,
       return _out(_range(start, end, step, includeEnd))
     },
 
+    // Handle bigints; if either limit is bigint, range should be too
+    'bigint, bigint|number': function (start, end) {
+      return _out(_range(start, end, 1n, false))
+    },
+    'number, bigint': function (start, end) {
+      return _out(_range(BigInt(start), end, 1n, false))
+    },
+    'bigint, bigint|number, bigint|number': function (start, end, step) {
+      return _out(_range(start, end, BigInt(step), false))
+    },
+    'number, bigint, bigint|number': function (start, end, step) {
+      return _out(_range(BigInt(start), end, BigInt(step), false))
+    },
+    'bigint, bigint|number, boolean': function (start, end, includeEnd) {
+      return _out(_range(start, end, 1n, includeEnd))
+    },
+    'number, bigint, boolean': function (start, end, includeEnd) {
+      return _out(_range(BigInt(start), end, 1n, includeEnd))
+    },
+    'bigint, bigint|number, bigint|number, boolean': function (start, end, step, includeEnd) {
+      return _out(_range(start, end, BigInt(step), includeEnd))
+    },
+    'number, bigint, bigint|number, boolean': function (start, end, step, includeEnd) {
+      return _out(_range(BigInt(start), end, BigInt(step), includeEnd))
+    },
+
     'BigNumber, BigNumber': function (start, end) {
       const BigNumber = start.constructor
 
@@ -85,6 +125,20 @@ export const createRange = /* #__PURE__ */ factory(name, dependencies, ({ typed,
     'BigNumber, BigNumber, BigNumber, boolean': function (start, end, step, includeEnd) {
       return _out(_range(start, end, step, includeEnd))
     },
+
+    'Fraction, Fraction': function (start, end) {
+      return _out(_range(start, end, 1, false))
+    },
+    'Fraction, Fraction, Fraction': function (start, end, step) {
+      return _out(_range(start, end, step, false))
+    },
+    'Fraction, Fraction, boolean': function (start, end, includeEnd) {
+      return _out(_range(start, end, 1, includeEnd))
+    },
+    'Fraction, Fraction, Fraction, boolean': function (start, end, step, includeEnd) {
+      return _out(_range(start, end, step, includeEnd))
+    },
+
     'Unit, Unit, Unit': function (start, end, step) {
       return _out(_range(start, end, step, false))
     },
diff --git a/src/type/matrix/MatrixIndex.js b/src/type/matrix/MatrixIndex.js
index 3f88a0d7d..a76ab8526 100644
--- a/src/type/matrix/MatrixIndex.js
+++ b/src/type/matrix/MatrixIndex.js
@@ -42,6 +42,7 @@ export const createIndexClass = /* #__PURE__ */ factory(name, dependencies, ({ I
       const arg = arguments[i]
       const argIsArray = isArray(arg)
       const argIsMatrix = isMatrix(arg)
+      const argType = typeof arg
       let sourceSize = null
       if (isRange(arg)) {
         this._dimensions.push(arg)
@@ -65,13 +66,15 @@ export const createIndexClass = /* #__PURE__ */ factory(name, dependencies, ({ I
         if (size.length !== 1 || size[0] !== 1 || sourceSize !== null) {
           this._isScalar = false
         }
-      } else if (typeof arg === 'number') {
+      } else if (argType === 'number') {
         this._dimensions.push(_createImmutableMatrix([arg]))
-      } else if (typeof arg === 'string') {
+      } else if (argType === 'bigint') {
+        this._dimensions.push(_createImmutableMatrix([Number(arg)]))
+      } else if (argType === 'string') {
         // object property (arguments.count should be 1)
         this._dimensions.push(arg)
       } else {
-        throw new TypeError('Dimension must be an Array, Matrix, number, string, or Range')
+        throw new TypeError('Dimension must be an Array, Matrix, number, bigint, string, or Range')
       }
       this._sourceSize.push(sourceSize)
       // TODO: implement support for wildcard '*'
diff --git a/src/type/matrix/Range.js b/src/type/matrix/Range.js
index 3f7d914a4..b6a386458 100644
--- a/src/type/matrix/Range.js
+++ b/src/type/matrix/Range.js
@@ -1,4 +1,4 @@
-import { isBigNumber } from '../../utils/is.js'
+import { isBigInt, isBigNumber } from '../../utils/is.js'
 import { format, sign } from '../../utils/number.js'
 import { factory } from '../../utils/factory.js'
 
@@ -7,14 +7,21 @@ const dependencies = []
 
 export const createRangeClass = /* #__PURE__ */ factory(name, dependencies, () => {
   /**
-   * Create a range. A range has a start, step, and end, and contains functions
-   * to iterate over the range.
+   * Create a range of numbers. A range has a start, step, and end,
+   * and contains functions to iterate over the range.
    *
    * A range can be constructed as:
    *
    *     const range = new Range(start, end)
    *     const range = new Range(start, end, step)
    *
+   * Note that the endpoints and step may be specified with other numeric
+   * types such as bigint or BigNumber, but they will be demoted to the
+   * built-in `number` type and the Range will only contain numbers. The
+   * rationale for this demotion is that Range objects are primarily used
+   * for indexing Matrix objects, and Matrix objects may only be indexed
+   * with `number`s.
+   *
    * To get the result of the range:
    *     range.forEach(function (x) {
    *         console.log(x)
@@ -49,22 +56,22 @@ export const createRangeClass = /* #__PURE__ */ factory(name, dependencies, () =
     if (hasStart) {
       if (isBigNumber(start)) {
         start = start.toNumber()
-      } else if (typeof start !== 'number') {
-        throw new TypeError('Parameter start must be a number')
+      } else if (typeof start !== 'number' && !isBigInt(start)) {
+        throw new TypeError('Parameter start must be a number or bigint')
       }
     }
     if (hasEnd) {
       if (isBigNumber(end)) {
         end = end.toNumber()
-      } else if (typeof end !== 'number') {
-        throw new TypeError('Parameter end must be a number')
+      } else if (typeof end !== 'number' && !isBigInt(end)) {
+        throw new TypeError('Parameter end must be a number or bigint')
       }
     }
     if (hasStep) {
       if (isBigNumber(step)) {
         step = step.toNumber()
-      } else if (typeof step !== 'number') {
-        throw new TypeError('Parameter step must be a number')
+      } else if (typeof step !== 'number' && !isBigInt(step)) {
+        throw new TypeError('Parameter step must be a number or bigint')
       }
     }
 
