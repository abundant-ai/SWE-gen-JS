diff --git a/AUTHORS b/AUTHORS
index 778df79bc..d7d7d99d8 100644
--- a/AUTHORS
+++ b/AUTHORS
@@ -230,6 +230,7 @@ Michael Greminger <michael.greminger@gmail.com>
 Kiku <kiku-cn@foxmail.com>
 MaybePixem <47889538+MaybePixem@users.noreply.github.com>
 Aly Khaled <alykhaled2001@live.com>
+Praise Nnamonu <praise.nnamonu@kibo.school>
 BuildTools <anikpatel1322@gmail.com>
 Anik Patel <74193405+Bobingstern@users.noreply.github.com>
 Vrushaket Chaudhari <82214275+vrushaket@users.noreply.github.com>
diff --git a/src/function/arithmetic/gcd.js b/src/function/arithmetic/gcd.js
index 46a32b3e8..d370c498d 100644
--- a/src/function/arithmetic/gcd.js
+++ b/src/function/arithmetic/gcd.js
@@ -1,16 +1,20 @@
+import { isInteger } from '../../utils/number.js'
 import { factory } from '../../utils/factory.js'
+import { createMod } from './mod.js'
 import { createMatAlgo01xDSid } from '../../type/matrix/utils/matAlgo01xDSid.js'
 import { createMatAlgo04xSidSid } from '../../type/matrix/utils/matAlgo04xSidSid.js'
 import { createMatAlgo10xSids } from '../../type/matrix/utils/matAlgo10xSids.js'
 import { createMatrixAlgorithmSuite } from '../../type/matrix/utils/matrixAlgorithmSuite.js'
-import { gcdNumber } from '../../plain/number/index.js'
 import { ArgumentsError } from '../../error/ArgumentsError.js'
 
 const name = 'gcd'
 const dependencies = [
   'typed',
+  'config',
+  'round',
   'matrix',
   'equalScalar',
+  'zeros',
   'BigNumber',
   'DenseMatrix',
   'concat'
@@ -23,7 +27,8 @@ function is1d (array) {
   return !array.some(element => Array.isArray(element))
 }
 
-export const createGcd = /* #__PURE__ */ factory(name, dependencies, ({ typed, matrix, equalScalar, BigNumber, DenseMatrix, concat }) => {
+export const createGcd = /* #__PURE__ */ factory(name, dependencies, ({ typed, matrix, config, round, equalScalar, zeros, BigNumber, DenseMatrix, concat }) => {
+  const mod = createMod({ typed, config, round, matrix, equalScalar, zeros, DenseMatrix, concat })
   const matAlgo01xDSid = createMatAlgo01xDSid({ typed })
   const matAlgo04xSidSid = createMatAlgo04xSidSid({ typed, equalScalar })
   const matAlgo10xSids = createMatAlgo10xSids({ typed, DenseMatrix })
@@ -57,7 +62,7 @@ export const createGcd = /* #__PURE__ */ factory(name, dependencies, ({ typed, m
   return typed(
     name,
     {
-      'number, number': gcdNumber,
+      'number, number': _gcdNumber,
       'BigNumber, BigNumber': _gcdBigNumber,
       'Fraction, Fraction': (x, y) => x.gcd(y)
     },
@@ -89,6 +94,28 @@ export const createGcd = /* #__PURE__ */ factory(name, dependencies, ({ typed, m
     }
   )
 
+  /**
+ * Calculate gcd for numbers
+ * @param {number} a
+ * @param {number} b
+ * @returns {number} Returns the greatest common denominator of a and b
+ * @private
+ */
+  function _gcdNumber (a, b) {
+    if (!isInteger(a) || !isInteger(b)) {
+      throw new Error('Parameters in function gcd must be integer numbers')
+    }
+
+    // https://en.wikipedia.org/wiki/Euclidean_algorithm
+    let r
+    while (b !== 0) {
+      r = mod(a, b)
+      a = b
+      b = r
+    }
+    return (a < 0) ? -a : a
+  }
+
   /**
    * Calculate gcd for BigNumbers
    * @param {BigNumber} a
@@ -104,7 +131,7 @@ export const createGcd = /* #__PURE__ */ factory(name, dependencies, ({ typed, m
     // https://en.wikipedia.org/wiki/Euclidean_algorithm
     const zero = new BigNumber(0)
     while (!b.isZero()) {
-      const r = a.mod(b)
+      const r = mod(a, b)
       a = b
       b = r
     }
diff --git a/src/function/arithmetic/mod.js b/src/function/arithmetic/mod.js
index f22492fb8..322813712 100644
--- a/src/function/arithmetic/mod.js
+++ b/src/function/arithmetic/mod.js
@@ -1,22 +1,26 @@
 import { factory } from '../../utils/factory.js'
+import { createFloor } from './floor.js'
 import { createMatAlgo02xDS0 } from '../../type/matrix/utils/matAlgo02xDS0.js'
 import { createMatAlgo03xDSf } from '../../type/matrix/utils/matAlgo03xDSf.js'
 import { createMatAlgo05xSfSf } from '../../type/matrix/utils/matAlgo05xSfSf.js'
 import { createMatAlgo11xS0s } from '../../type/matrix/utils/matAlgo11xS0s.js'
 import { createMatAlgo12xSfs } from '../../type/matrix/utils/matAlgo12xSfs.js'
-import { modNumber } from '../../plain/number/index.js'
 import { createMatrixAlgorithmSuite } from '../../type/matrix/utils/matrixAlgorithmSuite.js'
 
 const name = 'mod'
 const dependencies = [
   'typed',
+  'config',
+  'round',
   'matrix',
   'equalScalar',
+  'zeros',
   'DenseMatrix',
   'concat'
 ]
 
-export const createMod = /* #__PURE__ */ factory(name, dependencies, ({ typed, matrix, equalScalar, DenseMatrix, concat }) => {
+export const createMod = /* #__PURE__ */ factory(name, dependencies, ({ typed, config, round, matrix, equalScalar, zeros, DenseMatrix, concat }) => {
+  const floor = createFloor({ typed, config, round, matrix, equalScalar, zeros, DenseMatrix })
   const matAlgo02xDS0 = createMatAlgo02xDS0({ typed, equalScalar })
   const matAlgo03xDSf = createMatAlgo03xDSf({ typed })
   const matAlgo05xSfSf = createMatAlgo05xSfSf({ typed, equalScalar })
@@ -62,13 +66,12 @@ export const createMod = /* #__PURE__ */ factory(name, dependencies, ({ typed, m
   return typed(
     name,
     {
-      'number, number': modNumber,
+      'number, number': _modNumber,
 
       'BigNumber, BigNumber': function (x, y) {
         if (y.isNeg()) {
           throw new Error('Cannot calculate mod for a negative divisor')
-        }
-        return y.isZero() ? x : x.mod(y)
+        } return y.isZero() ? x : x.mod(y)
       },
 
       'Fraction, Fraction': function (x, y) {
@@ -87,4 +90,21 @@ export const createMod = /* #__PURE__ */ factory(name, dependencies, ({ typed, m
       sS: matAlgo12xSfs
     })
   )
+
+  /**
+ * Calculate the modulus of two numbers
+ * @param {number} x
+ * @param {number} y
+ * @returns {number} res
+ * @private
+ */
+  function _modNumber (x, y) {
+    // We don't use JavaScript's % operator here as this doesn't work
+    // correctly for x < 0 and x === 0
+    // see https://en.wikipedia.org/wiki/Modulo_operation
+
+    // We use mathjs floor to handle errors associated with
+    // precision float approximation
+    return (y === 0) ? x : x - y * floor(x / y)
+  }
 })
diff --git a/src/plain/number/arithmetic.js b/src/plain/number/arithmetic.js
index 51b12bdcf..bb006d4f9 100644
--- a/src/plain/number/arithmetic.js
+++ b/src/plain/number/arithmetic.js
@@ -157,17 +157,10 @@ log1pNumber.signature = n1
  * @private
  */
 export function modNumber (x, y) {
-  if (y > 0) {
-    // We don't use JavaScript's % operator here as this doesn't work
-    // correctly for x < 0 and x === 0
-    // see https://en.wikipedia.org/wiki/Modulo_operation
-    return x - y * Math.floor(x / y)
-  } else if (y === 0) {
-    return x
-  } else { // y < 0
-    // TODO: implement mod for a negative divisor
-    throw new Error('Cannot calculate mod for a negative divisor')
-  }
+  // We don't use JavaScript's % operator here as this doesn't work
+  // correctly for x < 0 and x === 0
+  // see https://en.wikipedia.org/wiki/Modulo_operation
+  return (y === 0) ? x : x - y * Math.floor(x / y)
 }
 modNumber.signature = n2
 
