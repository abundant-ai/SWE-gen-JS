diff --git a/.changeset/warm-tips-cut.md b/.changeset/warm-tips-cut.md
new file mode 100644
index 0000000000..12e21250c6
--- /dev/null
+++ b/.changeset/warm-tips-cut.md
@@ -0,0 +1,39 @@
+---
+'@xstate/store': minor
+---
+
+Added undo/redo functionality to XState Store via the `undoRedo` higher-order store logic:
+
+- Adds `undo` and `redo` events to stores
+- Supports grouping related events into transactions using `transactionId`
+- Maintains event history for precise state reconstruction
+
+- Automatically clears redo stack when new events occur
+
+```ts
+import { createStore } from '@xstate/store';
+import { undoRedo } from '@xstate/store/undo';
+
+const store = createStore(
+  undoRedo({
+    context: { count: 0 },
+    on: {
+      inc: (ctx) => ({ count: ctx.count + 1 }),
+      dec: (ctx) => ({ count: ctx.count - 1 })
+    }
+  })
+);
+
+store.trigger.inc();
+// count: 1
+store.trigger.inc();
+// count: 2
+store.trigger.undo();
+// count: 1
+store.trigger.undo();
+// count: 0
+store.trigger.redo();
+// count: 1
+store.trigger.redo();
+// count: 2
+```
diff --git a/packages/xstate-store/src/store.ts b/packages/xstate-store/src/store.ts
index 2fda9b080a..c47a02d527 100644
--- a/packages/xstate-store/src/store.ts
+++ b/packages/xstate-store/src/store.ts
@@ -18,7 +18,10 @@ import {
   StoreSnapshot,
   Selector,
   Selection,
-  InternalBaseAtom
+  InternalBaseAtom,
+  StoreLogic,
+  StoreTransition,
+  AnyStoreLogic
 } from './types';
 
 const symbolObservable: typeof Symbol.observable = (() =>
@@ -46,32 +49,17 @@ const inspectionObservers = new WeakMap<
 
 function createStoreCore<
   TContext extends StoreContext,
+  TSnapshot extends StoreSnapshot<any>,
   TEventPayloadMap extends EventPayloadMap,
   TEmitted extends EventObject
 >(
-  initialContext: TContext,
-  transitions: {
-    [K in keyof TEventPayloadMap & string]: StoreAssigner<
-      NoInfer<TContext>,
-      { type: K } & TEventPayloadMap[K],
-      TEmitted
-    >;
-  },
-  emits?: Record<string, (payload: any) => void>, // TODO: improve this type
-  producer?: (
-    context: NoInfer<TContext>,
-    recipe: (context: NoInfer<TContext>) => void
-  ) => NoInfer<TContext>
+  logic: StoreLogic<TSnapshot, ExtractEvents<TEventPayloadMap>, TEmitted>,
+  emits?: Record<string, (payload: any) => void> // TODO: improve this type
 ): Store<TContext, ExtractEvents<TEventPayloadMap>, TEmitted> {
   type StoreEvent = ExtractEvents<TEventPayloadMap>;
   let listeners: Map<TEmitted['type'], Set<any>> | undefined;
-  const initialSnapshot: StoreSnapshot<TContext> = {
-    context: initialContext,
-    status: 'active',
-    output: undefined,
-    error: undefined
-  };
-  let currentSnapshot: StoreSnapshot<TContext> = initialSnapshot;
+  const initialSnapshot = logic.getInitialSnapshot();
+  let currentSnapshot: TSnapshot = initialSnapshot;
   const atom = createAtom<StoreSnapshot<TContext>>(currentSnapshot);
 
   const emit = (ev: TEmitted) => {
@@ -85,7 +73,7 @@ function createStoreCore<
     }
   };
 
-  const transition = createStoreTransition(transitions, producer);
+  const transition = logic.transition;
 
   function receive(event: StoreEvent) {
     let effects: StoreEffect<TEmitted>[];
@@ -137,7 +125,7 @@ function createStoreCore<
         }
       };
     },
-    transition,
+    transition: logic.transition as any, // TODO: fix this
     sessionId: uniqueId(),
     send(event) {
       inspectionObservers.get(store)?.forEach((observer) => {
@@ -229,18 +217,6 @@ export type TransitionsFromEventPayloadMap<
   >;
 };
 
-type CreateStoreParameterTypes<
-  TContext extends StoreContext,
-  TEventPayloadMap extends EventPayloadMap,
-  TEmitted extends EventPayloadMap
-> = [definition: StoreConfig<TContext, TEventPayloadMap, TEmitted>];
-
-type CreateStoreReturnType<
-  TContext extends StoreContext,
-  TEventPayloadMap extends EventPayloadMap,
-  TEmitted extends EventPayloadMap
-> = Store<TContext, ExtractEvents<TEventPayloadMap>, ExtractEvents<TEmitted>>;
-
 /**
  * Creates a **store** that has its own internal state and can be sent events
  * that update its internal state based on transitions.
@@ -249,9 +225,10 @@ type CreateStoreReturnType<
  *
  * ```ts
  * const store = createStore({
- *   context: { count: 0 },
+ *   context: { count: 0, name: 'Ada' },
  *   on: {
  *     inc: (context, event: { by: number }) => ({
+ *       ...context,
  *       count: context.count + event.by
  *     })
  *   }
@@ -262,7 +239,7 @@ type CreateStoreReturnType<
  * });
  *
  * store.send({ type: 'inc', by: 5 });
- * // Logs { context: { count: 5 }, status: 'active', ... }
+ * // Logs { context: { count: 5, name: 'Ada' }, status: 'active', ... }
  * ```
  *
  * @param config - The store configuration object
@@ -272,72 +249,47 @@ type CreateStoreReturnType<
  * @returns A store instance with methods to send events and subscribe to state
  *   changes
  */
-function _createStore<
+export function createStore<
   TContext extends StoreContext,
   TEventPayloadMap extends EventPayloadMap,
-  TEmitted extends EventPayloadMap
+  TEmittedPayloadMap extends EventPayloadMap
 >(
-  ...[{ context, on, emits }]: CreateStoreParameterTypes<
-    TContext,
-    TEventPayloadMap,
-    TEmitted
+  definition: StoreConfig<TContext, TEventPayloadMap, TEmittedPayloadMap>
+): Store<
+  TContext,
+  ExtractEvents<TEventPayloadMap>,
+  ExtractEvents<TEmittedPayloadMap>
+>;
+export function createStore<
+  TContext extends StoreContext,
+  TEvent extends EventObject,
+  TEmittedPayloadMap extends EventPayloadMap
+>(
+  logic: StoreLogic<
+    StoreSnapshot<TContext>,
+    TEvent,
+    ExtractEvents<TEmittedPayloadMap>
   >
-): CreateStoreReturnType<TContext, TEventPayloadMap, TEmitted> {
-  return createStoreCore(context, on, emits);
+): Store<TContext, TEvent, ExtractEvents<TEmittedPayloadMap>>;
+export function createStore(
+  definitionOrLogic: StoreConfig<any, any, any> | AnyStoreLogic
+) {
+  if ('transition' in definitionOrLogic) {
+    return createStoreCore(definitionOrLogic);
+  }
+  const transition = createStoreTransition(definitionOrLogic.on);
+  const logic: AnyStoreLogic = {
+    getInitialSnapshot: () => ({
+      status: 'active' as const,
+      context: definitionOrLogic.context,
+      output: undefined,
+      error: undefined
+    }),
+    transition
+  } satisfies AnyStoreLogic;
+  return createStoreCore(logic, definitionOrLogic.emits);
 }
 
-// those overloads are exactly the same, we only duplicate them so TypeScript can:
-// 1. assign contextual parameter types during inference attempt for the first overload when the source object is still context-sensitive and often non-inferable
-// 2. infer correctly during inference attempt for the second overload when the parameter types are already "known"
-export const createStore: {
-  /**
-   * Creates a **store** that has its own internal state and can be sent events
-   * that update its internal state based on transitions.
-   *
-   * @example
-   *
-   * ```ts
-   * const store = createStore({
-   *   context: { count: 0, name: 'Ada' },
-   *   on: {
-   *     inc: (context, event: { by: number }) => ({
-   *       ...context,
-   *       count: context.count + event.by
-   *     })
-   *   }
-   * });
-   *
-   * store.subscribe((snapshot) => {
-   *   console.log(snapshot);
-   * });
-   *
-   * store.send({ type: 'inc', by: 5 });
-   * // Logs { context: { count: 5, name: 'Ada' }, status: 'active', ... }
-   * ```
-   *
-   * @param config - The store configuration object
-   * @param config.context - The initial state of the store
-   * @param config.on - An object mapping event types to transition functions
-   * @param config.emits - An object mapping emitted event types to handlers
-   * @returns A store instance with methods to send events and subscribe to
-   *   state changes
-   */
-  <
-    TContext extends StoreContext,
-    TEventPayloadMap extends EventPayloadMap,
-    TEmitted extends EventPayloadMap
-  >(
-    ...args: CreateStoreParameterTypes<TContext, TEventPayloadMap, TEmitted>
-  ): CreateStoreReturnType<TContext, TEventPayloadMap, TEmitted>;
-  <
-    TContext extends StoreContext,
-    TEventPayloadMap extends EventPayloadMap,
-    TEmitted extends EventPayloadMap
-  >(
-    ...args: CreateStoreParameterTypes<TContext, TEventPayloadMap, TEmitted>
-  ): CreateStoreReturnType<TContext, TEventPayloadMap, TEmitted>;
-} = _createStore;
-
 function _createStoreConfig<
   TContext extends StoreContext,
   TEventPayloadMap extends EventPayloadMap,
@@ -419,7 +371,18 @@ export function createStoreWithProducer<
   ExtractEvents<TEventPayloadMap>,
   ExtractEvents<TEmittedPayloadMap>
 > {
-  return createStoreCore(config.context, config.on, config.emits, producer);
+  const transition = createStoreTransition(config.on, producer);
+  const logic = {
+    getInitialSnapshot: () => ({
+      status: 'active' as const,
+      context: config.context,
+      output: undefined,
+      error: undefined
+    }),
+    transition
+  } satisfies AnyStoreLogic;
+
+  return createStoreCore(logic, config.emits);
 }
 
 declare global {
@@ -454,7 +417,7 @@ export function createStoreTransition<
     context: TContext,
     recipe: (context: TContext) => void
   ) => TContext
-) {
+): StoreTransition<TContext, ExtractEvents<TEventPayloadMap>, TEmitted> {
   return (
     snapshot: StoreSnapshot<TContext>,
     event: ExtractEvents<TEventPayloadMap>
diff --git a/packages/xstate-store/src/types.ts b/packages/xstate-store/src/types.ts
index a02cec60a6..ee16929c94 100644
--- a/packages/xstate-store/src/types.ts
+++ b/packages/xstate-store/src/types.ts
@@ -77,7 +77,7 @@ export type StoreSnapshot<TContext> = Snapshot<undefined> & {
  * - Is observable
  */
 export interface Store<
-  TContext,
+  TContext extends StoreContext,
   TEvent extends EventObject,
   TEmitted extends EventObject
 > extends Subscribable<StoreSnapshot<TContext>>,
@@ -143,12 +143,18 @@ export interface Store<
    * });
    * ```
    */
-  transition: (
-    state: StoreSnapshot<TContext>,
-    event: TEvent
-  ) => [StoreSnapshot<TContext>, StoreEffect<TEmitted>[]];
+  transition: StoreTransition<TContext, TEvent, TEmitted>;
 }
 
+export type StoreTransition<
+  TContext extends StoreContext,
+  TEvent extends EventObject,
+  TEmitted extends EventObject
+> = (
+  state: StoreSnapshot<TContext>,
+  event: TEvent
+) => [StoreSnapshot<TContext>, StoreEffect<TEmitted>[]];
+
 export type StoreConfig<
   TContext extends StoreContext,
   TEventPayloadMap extends EventPayloadMap,
@@ -407,3 +413,30 @@ export interface ReadonlyAtom<T> extends BaseAtom<T> {}
 type DistributiveOmit<T, K extends PropertyKey> = T extends any
   ? Omit<T, K>
   : never;
+
+export type StoreLogic<
+  TSnapshot extends StoreSnapshot<any>,
+  TEvent extends EventObject,
+  TEmitted extends EventObject
+> = {
+  getInitialSnapshot: () => TSnapshot;
+  transition: (
+    snapshot: TSnapshot,
+    event: TEvent
+  ) => [TSnapshot, StoreEffect<TEmitted>[]];
+};
+export type AnyStoreLogic = StoreLogic<any, any, any>;
+
+export type AnyStoreConfig = StoreConfig<any, any, any>;
+export type EventFromStoreConfig<TStore extends AnyStoreConfig> =
+  TStore extends StoreConfig<any, infer TEventPayloadMap, any>
+    ? ExtractEvents<TEventPayloadMap>
+    : never;
+
+export type EmitsFromStoreConfig<TStore extends AnyStoreConfig> =
+  TStore extends StoreConfig<any, any, infer TEmitted>
+    ? ExtractEvents<TEmitted>
+    : never;
+
+export type ContextFromStoreConfig<TStore extends AnyStoreConfig> =
+  TStore extends StoreConfig<infer TContext, any, any> ? TContext : never;
diff --git a/packages/xstate-store/src/undo.ts b/packages/xstate-store/src/undo.ts
new file mode 100644
index 0000000000..a6441a84ea
--- /dev/null
+++ b/packages/xstate-store/src/undo.ts
@@ -0,0 +1,228 @@
+import {
+  AnyStoreLogic,
+  EmitsFromStoreConfig,
+  EventObject,
+  EventPayloadMap,
+  ExtractEvents,
+  StoreConfig,
+  StoreContext,
+  StoreLogic,
+  StoreSnapshot
+} from './types';
+import { createStoreTransition } from './store';
+
+type UndoEvent<TEvent extends EventObject> = {
+  event: TEvent;
+  transactionId?: string;
+};
+
+/**
+ * Creates store logic with undo/redo functionality.
+ *
+ * It maintains an event history and allows reverting to previous states by
+ * replaying events from the beginning up to a certain point.
+ *
+ * @example
+ *
+ * ```ts
+ * // Basic usage - each event is its own transaction
+ * const store = createStore(
+ *   undoRedo({
+ *     context: { count: 0 },
+ *     on: {
+ *       inc: (ctx) => ({ count: ctx.count + 1 }),
+ *       dec: (ctx) => ({ count: ctx.count - 1 })
+ *     }
+ *   })
+ * );
+ *
+ * store.trigger.inc(); // count = 1
+ * store.trigger.inc(); // count = 2
+ * store.trigger.undo(); // count = 1 (undoes last inc)
+ * store.trigger.redo(); // count = 2 (redoes the inc)
+ * ```
+ *
+ * @example
+ *
+ * ```ts
+ * // Grouped events by transaction ID
+ * const store = createStore(
+ *   undoRedo(
+ *     {
+ *       context: { count: 0 },
+ *       on: {
+ *         inc: (ctx) => ({ count: ctx.count + 1 }),
+ *         dec: (ctx) => ({ count: ctx.count - 1 })
+ *       }
+ *     },
+ *     {
+ *       getTransactionId: (event) => event.type
+ *     }
+ *   )
+ * );
+ *
+ * store.send({ type: 'inc' }); // count = 1 (1st transaction)
+ * store.send({ type: 'inc' }); // count = 2 (1st transaction)
+ * store.send({ type: 'dec' }); // count = 1 (2nd transaction)
+ * store.send({ type: 'dec' }); // count = 0 (2nd transaction)
+ *
+ * store.trigger.undo(); // count = 1 (undoes both dec events)
+ * store.trigger.undo(); // count = 0 (undoes both inc events)
+ * ```
+ *
+ * @returns Store logic with additional `undo` and `redo` event handlers
+ */
+export function undoRedo<
+  TContext extends StoreContext,
+  TEventPayloadMap extends EventPayloadMap,
+  TEmittedPayloadMap extends EventPayloadMap
+>(
+  storeConfig: StoreConfig<TContext, TEventPayloadMap, TEmittedPayloadMap>,
+  options?: {
+    getTransactionId?: (event: ExtractEvents<TEventPayloadMap>) => string;
+  }
+): StoreLogic<
+  StoreSnapshot<TContext>,
+  ExtractEvents<TEventPayloadMap> | { type: 'undo' } | { type: 'redo' },
+  EmitsFromStoreConfig<any>
+> {
+  type TEvent = ExtractEvents<TEventPayloadMap>;
+  const logic: AnyStoreLogic = {
+    getInitialSnapshot: () => ({
+      status: 'active',
+      context: storeConfig.context,
+      output: undefined,
+      error: undefined
+    }),
+    transition: createStoreTransition(storeConfig.on)
+  };
+
+  const enhancedLogic: AnyStoreLogic = {
+    getInitialSnapshot: () => ({
+      status: 'active',
+      context: storeConfig.context,
+      output: undefined,
+      error: undefined,
+      events: [],
+      undoStack: []
+    }),
+    transition: (snapshot, event) => {
+      if (event.type === 'undo') {
+        const events = snapshot.events.slice();
+        const undoStack = snapshot.undoStack.slice();
+        if (!events.length) {
+          return [
+            {
+              ...snapshot,
+              events,
+              undoStack
+            },
+            []
+          ];
+        }
+
+        // Get the transaction ID of the last event
+        const lastTransactionId = events[events.length - 1].transactionId;
+
+        // Remove all events with the same transaction ID
+        // If transactionId is undefined, only remove the last event
+        const eventsToUndo: UndoEvent<TEvent>[] = [];
+        if (lastTransactionId === undefined) {
+          // When no transaction ID is provided, each event is its own transaction
+          const event = events.pop()!;
+          eventsToUndo.unshift(event);
+          undoStack.push(event);
+        } else {
+          // Remove all events with the same transaction ID
+          while (true) {
+            const event = events.pop()!;
+            eventsToUndo.unshift(event);
+            undoStack.push(event);
+            if (
+              lastTransactionId === undefined ||
+              !events.length ||
+              events[events.length - 1].transactionId !== lastTransactionId
+            ) {
+              break;
+            }
+          }
+        }
+
+        // Replay remaining events to get to the new state
+        let state = {
+          ...logic.getInitialSnapshot(),
+          events,
+          undoStack
+        };
+
+        for (const { event } of events) {
+          const [newState, _effects] = logic.transition(state, event);
+          state = {
+            ...newState,
+            events,
+            undoStack
+          };
+        }
+
+        return [state, []];
+      }
+
+      if (event.type === 'redo') {
+        const events = snapshot.events.slice();
+        const undoStack = snapshot.undoStack.slice();
+        if (!undoStack.length) {
+          return [
+            {
+              ...snapshot,
+              events,
+              undoStack
+            },
+            []
+          ];
+        }
+
+        const lastTransactionId = undoStack[undoStack.length - 1].transactionId;
+        let state = {
+          ...snapshot,
+          events,
+          undoStack
+        };
+        const allEffects: any[] = [];
+
+        while (
+          undoStack.length > 0 &&
+          undoStack[undoStack.length - 1].transactionId === lastTransactionId
+        ) {
+          const undoEvent = undoStack.pop()!;
+          events.push(undoEvent);
+          const [newState, effects] = logic.transition(state, undoEvent.event);
+          state = {
+            ...newState,
+            events,
+            undoStack
+          };
+          allEffects.push(...effects);
+        }
+
+        return [state, allEffects];
+      }
+
+      const events = snapshot.events.slice();
+      const [state, effects] = logic.transition(snapshot, event);
+      return [
+        {
+          ...state,
+          events: events.concat({
+            event,
+            transactionId: options?.getTransactionId?.(event)
+          }),
+          // Clear the undo stack when new events occur
+          undoStack: []
+        },
+        effects
+      ];
+    }
+  };
+
+  return enhancedLogic;
+}
