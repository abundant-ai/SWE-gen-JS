diff --git a/.vscode/settings.json b/.vscode/settings.json
index 6f4faab..002e270 100644
--- a/.vscode/settings.json
+++ b/.vscode/settings.json
@@ -1,5 +1,4 @@
 {
   "javascript.validate.enable": false,
-  "typescript.tsdk": "node_modules/typescript/lib",
-  "jest.enableInlineErrorMessages": true
+  "typescript.tsdk": "node_modules/typescript/lib"
 }
diff --git a/__tests__/frozen.js b/__tests__/frozen.js
index 34d0c3b..7d4d3e3 100644
--- a/__tests__/frozen.js
+++ b/__tests__/frozen.js
@@ -23,6 +23,7 @@ function runTests(name, useProxies) {
 			const base = {arr: [1], obj: {a: 1}}
 			const next = produce(base, draft => {
 				draft.arr.push(1)
+				debugger
 			})
 			expect(isFrozen(base)).toBeFalsy()
 			expect(isFrozen(base.arr)).toBeFalsy()
@@ -190,6 +191,7 @@ function runTests(name, useProxies) {
 
 			// https://github.com/immerjs/immer/issues/472
 			produce(frozen, draft => {
+				// if (useProxies) debugger
 				;["b", "c"].forEach(other => {
 					const m = draft.map.get(other)
 
@@ -197,28 +199,5 @@ function runTests(name, useProxies) {
 				})
 			})
 		})
-
-		it("never freezes non-enumerable fields #590", () => {
-			const component = {}
-			Object.defineProperty(component, "state", {
-				value: {x: 1},
-				enumerable: false,
-				writable: true,
-				configurable: true
-			})
-
-			const state = {
-				x: 1
-			}
-
-			const state2 = produce(state, draft => {
-				draft.ref = component
-			})
-
-			expect(() => {
-				state2.ref.state.x++
-			}).not.toThrow()
-			expect(state2.ref.state.x).toBe(2)
-		})
 	})
 }
diff --git a/src/core/finalize.ts b/src/core/finalize.ts
index f4ee8b7..093752b 100644
--- a/src/core/finalize.ts
+++ b/src/core/finalize.ts
@@ -64,11 +64,8 @@ function finalize(rootScope: ImmerScope, value: any, path?: PatchPath) {
 	const state: ImmerState = value[DRAFT_STATE]
 	// A plain object, might need freezing, might contain drafts
 	if (!state) {
-		each(
-			value,
-			(key, childValue) =>
-				finalizeProperty(rootScope, state, value, key, childValue, path),
-			true // See #590, don't recurse into non-enumarable of non drafted objects
+		each(value, (key, childValue) =>
+			finalizeProperty(rootScope, state, value, key, childValue, path)
 		)
 		return value
 	}
diff --git a/src/utils/common.ts b/src/utils/common.ts
index 53a9fe7..c0954ff 100644
--- a/src/utils/common.ts
+++ b/src/utils/common.ts
@@ -67,14 +67,11 @@ export const ownKeys: (target: AnyObject) => PropertyKey[] =
 
 export function each<T extends Objectish>(
 	obj: T,
-	iter: (key: string | number, value: any, source: T) => void,
-	enumerableOnly?: boolean
+	iter: (key: string | number, value: any, source: T) => void
 ): void
-export function each(obj: any, iter: any, enumerableOnly = false) {
+export function each(obj: any, iter: any) {
 	if (getArchtype(obj) === ArchtypeObject) {
-		;(enumerableOnly ? Object.keys : ownKeys)(obj).forEach(key =>
-			iter(key, obj[key], obj)
-		)
+		ownKeys(obj).forEach(key => iter(key, obj[key], obj))
 	} else {
 		obj.forEach((entry: any, index: any) => iter(index, entry, obj))
 	}
@@ -181,7 +178,7 @@ export function freeze(obj: any, deep: boolean): void {
 		obj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections as any
 	}
 	Object.freeze(obj)
-	if (deep) each(obj, (key, value) => freeze(value, true), true)
+	if (deep) each(obj, (_, value) => freeze(value, true))
 }
 
 function dontMutateFrozenCollections() {
