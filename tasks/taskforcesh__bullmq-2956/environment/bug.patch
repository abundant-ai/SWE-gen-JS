diff --git a/src/classes/job-scheduler.ts b/src/classes/job-scheduler.ts
index bd47466ce5..1f3493c6e6 100644
--- a/src/classes/job-scheduler.ts
+++ b/src/classes/job-scheduler.ts
@@ -11,7 +11,7 @@ import { Job } from './job';
 import { QueueBase } from './queue-base';
 import { RedisConnection } from './redis-connection';
 import { SpanKind, TelemetryAttributes } from '../enums';
-import { array2obj, optsAsJSON, optsFromJSON } from '../utils';
+import { optsAsJSON, optsFromJSON } from '../utils';
 
 export class JobScheduler extends QueueBase {
   private repeatStrategy: RepeatStrategy;
@@ -202,21 +202,13 @@ export class JobScheduler extends QueueBase {
     return this.scripts.removeJobScheduler(jobSchedulerId);
   }
 
-  private async getSchedulerData<D>(
+  private async getSchedulerData(
     client: RedisClient,
     key: string,
     next?: number,
-  ): Promise<JobSchedulerJson<D>> {
+  ): Promise<JobSchedulerJson> {
     const jobData = await client.hgetall(this.toKey('repeat:' + key));
 
-    return this.transformSchedulerData<D>(key, jobData, next);
-  }
-
-  private async transformSchedulerData<D>(
-    key: string,
-    jobData: any,
-    next?: number,
-  ): Promise<JobSchedulerJson<D>> {
     if (jobData) {
       return {
         key,
@@ -225,11 +217,6 @@ export class JobScheduler extends QueueBase {
         tz: jobData.tz || null,
         pattern: jobData.pattern || null,
         every: jobData.every || null,
-        ...(jobData.data || jobData.opts
-          ? {
-              template: this.getTemplateFromJSON<D>(jobData.data, jobData.opts),
-            }
-          : {}),
         next,
       };
     }
@@ -252,14 +239,30 @@ export class JobScheduler extends QueueBase {
     };
   }
 
-  async getScheduler<D = any>(id: string): Promise<JobSchedulerJson<D>> {
-    const [rawJobData, next] = await this.scripts.getJobScheduler(id);
-
-    return this.transformSchedulerData<D>(
-      id,
-      rawJobData ? array2obj(rawJobData) : null,
-      next ? parseInt(next) : null,
+  async getJobScheduler<D = any>(id: string): Promise<JobSchedulerJson<D>> {
+    const client = await this.client;
+    const schedulerAttributes = await client.hgetall(
+      this.toKey('repeat:' + id),
     );
+
+    if (schedulerAttributes) {
+      return {
+        key: id,
+        name: schedulerAttributes.name,
+        endDate: parseInt(schedulerAttributes.endDate) || null,
+        tz: schedulerAttributes.tz || null,
+        pattern: schedulerAttributes.pattern || null,
+        every: schedulerAttributes.every || null,
+        ...(schedulerAttributes.data || schedulerAttributes.opts
+          ? {
+              template: this.getTemplateFromJSON<D>(
+                schedulerAttributes.data,
+                schedulerAttributes.opts,
+              ),
+            }
+          : {}),
+      };
+    }
   }
 
   private getTemplateFromJSON<D = any>(
@@ -276,11 +279,11 @@ export class JobScheduler extends QueueBase {
     return template;
   }
 
-  async getJobSchedulers<D = any>(
+  async getJobSchedulers(
     start = 0,
     end = -1,
     asc = false,
-  ): Promise<JobSchedulerJson<D>[]> {
+  ): Promise<JobSchedulerJson[]> {
     const client = await this.client;
     const jobSchedulersKey = this.keys.repeat;
 
@@ -291,7 +294,7 @@ export class JobScheduler extends QueueBase {
     const jobs = [];
     for (let i = 0; i < result.length; i += 2) {
       jobs.push(
-        this.getSchedulerData<D>(client, result[i], parseInt(result[i + 1])),
+        this.getSchedulerData(client, result[i], parseInt(result[i + 1])),
       );
     }
     return Promise.all(jobs);
diff --git a/src/classes/queue.ts b/src/classes/queue.ts
index 1525d13254..3afa5691c0 100644
--- a/src/classes/queue.ts
+++ b/src/classes/queue.ts
@@ -573,7 +573,7 @@ export class Queue<
    * @param id - identifier of scheduler.
    */
   async getJobScheduler(id: string): Promise<JobSchedulerJson<DataType>> {
-    return (await this.jobScheduler).getScheduler<DataType>(id);
+    return (await this.jobScheduler).getJobScheduler(id);
   }
 
   /**
@@ -588,12 +588,8 @@ export class Queue<
     start?: number,
     end?: number,
     asc?: boolean,
-  ): Promise<JobSchedulerJson<DataType>[]> {
-    return (await this.jobScheduler).getJobSchedulers<DataType>(
-      start,
-      end,
-      asc,
-    );
+  ): Promise<RepeatableJob[]> {
+    return (await this.jobScheduler).getJobSchedulers(start, end, asc);
   }
 
   /**
diff --git a/src/classes/scripts.ts b/src/classes/scripts.ts
index dc487b42d1..0897d905a9 100644
--- a/src/classes/scripts.ts
+++ b/src/classes/scripts.ts
@@ -1088,20 +1088,6 @@ export class Scripts {
     ]);
   }
 
-  getJobSchedulerArgs(id: string): string[] {
-    const keys: string[] = [this.queue.keys.repeat];
-
-    return keys.concat([id]);
-  }
-
-  async getJobScheduler(id: string): Promise<[any, string | null]> {
-    const client = await this.queue.client;
-
-    const args = this.getJobSchedulerArgs(id);
-
-    return this.execCommand(client, 'getJobScheduler', args);
-  }
-
   retryJobArgs(
     jobId: string,
     lifo: boolean,
diff --git a/src/commands/getJobScheduler-1.lua b/src/commands/getJobScheduler-1.lua
deleted file mode 100644
index 324bdb58eb..0000000000
--- a/src/commands/getJobScheduler-1.lua
+++ /dev/null
@@ -1,19 +0,0 @@
---[[
-  Get job scheduler record.
-
-  Input:
-    KEYS[1] 'repeat' key
-
-    ARGV[1] id
-]]
-
-local rcall = redis.call
-local jobSchedulerKey = KEYS[1] .. ":" .. ARGV[1]
-
-local score = rcall("ZSCORE", KEYS[1], ARGV[1])
-
-if score then
-  return {rcall("HGETALL", jobSchedulerKey), score} -- get job data
-end
-
-return {nil, nil}
diff --git a/src/commands/updateJobOption-1.lua b/src/commands/updateJobOption-1.lua
new file mode 100644
index 0000000000..03949faf29
--- /dev/null
+++ b/src/commands/updateJobOption-1.lua
@@ -0,0 +1,26 @@
+--[[
+  Update a job option
+
+  Input:
+    KEYS[1] Job id key
+
+    ARGV[1] field
+    ARGV[2] value
+
+  Output:
+    0 - OK
+   -1 - Missing job.
+]]
+local rcall = redis.call
+
+if rcall("EXISTS", KEYS[1]) == 1 then -- // Make sure job exists
+
+    local opts = rcall("HGET", KEYS[1], "opts")
+    local jsonOpts = cjson.decode(opts)
+    jsonOpts[ARGV[1]] = ARGV[2]
+
+    rcall("HSET", KEYS[1], "opts", cjson.encode(jsonOpts))
+    return 0
+else
+    return -1
+end
diff --git a/src/interfaces/telemetry.ts b/src/interfaces/telemetry.ts
index d39794d34a..e55c0990dc 100644
--- a/src/interfaces/telemetry.ts
+++ b/src/interfaces/telemetry.ts
@@ -36,8 +36,8 @@ export interface ContextManager<Context = any> {
   /**
    * Creates a new context and sets it as active for the fn passed as last argument
    *
-   * @param context -
-   * @param fn -
+   * @param context
+   * @param fn
    */
   with<A extends (...args: any[]) => any>(
     context: Context,
@@ -54,7 +54,7 @@ export interface ContextManager<Context = any> {
    * is the mechanism used to propagate the context across a distributed
    * application.
    *
-   * @param context -
+   * @param context
    */
   getMetadata(context: Context): string;
 
@@ -62,8 +62,8 @@ export interface ContextManager<Context = any> {
    * Creates a new context from a serialized version effectively
    * linking the new context to the parent context.
    *
-   * @param activeContext -
-   * @param metadata -
+   * @param activeContext
+   * @param metadata
    */
   fromMetadata(activeContext: Context, metadata: string): Context;
 }
@@ -78,9 +78,9 @@ export interface Tracer<Context = any> {
    * context. If the context is not provided, the current active context should be
    * used.
    *
-   * @param name -
-   * @param options -
-   * @param context -
+   * @param name
+   * @param options
+   * @param context
    */
   startSpan(name: string, options?: SpanOptions, context?: Context): Span;
 }
diff --git a/tests/test_job_scheduler.ts b/tests/test_job_scheduler.ts
index 427cb99cee..ee329207aa 100644
--- a/tests/test_job_scheduler.ts
+++ b/tests/test_job_scheduler.ts
@@ -342,7 +342,7 @@ describe('Job Scheduler', function () {
     );
     const delayStub = sinon.stub(worker, 'delay').callsFake(async () => {});
 
-    const date = new Date('2017-02-07T15:24:00.000Z');
+    const date = new Date('2017-02-07 9:24:00');
     this.clock.setSystemTime(date);
 
     await queue.upsertJobScheduler(
@@ -360,7 +360,6 @@ describe('Job Scheduler', function () {
       tz: null,
       pattern: '*/2 * * * * *',
       every: null,
-      next: 1486481042000,
       template: {
         data: {
           foo: 'bar',
@@ -683,7 +682,7 @@ describe('Job Scheduler', function () {
         );
         const delayStub = sinon.stub(worker, 'delay').callsFake(async () => {});
 
-        const date = new Date('2017-02-07T15:24:00.000Z');
+        const date = new Date('2017-02-07 9:24:00');
         this.clock.setSystemTime(date);
 
         const repeat = {
@@ -699,7 +698,6 @@ describe('Job Scheduler', function () {
           key: 'rrule',
           name: 'rrule',
           endDate: null,
-          next: 1486481042000,
           tz: null,
           pattern: 'RRULE:FREQ=SECONDLY;INTERVAL=2;WKST=MO',
           every: null,
@@ -1426,11 +1424,8 @@ describe('Job Scheduler', function () {
 
   describe('when repeatable job fails', function () {
     it('should continue repeating', async function () {
-      const date = new Date('2017-02-07T15:24:00.000Z');
-      this.clock.setSystemTime(date);
       const repeatOpts = {
         pattern: '0 * 1 * *',
-        tz: 'Asia/Calcutta',
       };
 
       const worker = new Worker(
@@ -1450,11 +1445,7 @@ describe('Job Scheduler', function () {
         });
       });
 
-      const repeatableJob = await queue.upsertJobScheduler('test', repeatOpts, {
-        name: 'a',
-        data: { foo: 'bar' },
-        opts: { priority: 1 },
-      });
+      const repeatableJob = await queue.upsertJobScheduler('test', repeatOpts);
       const delayedCount = await queue.getDelayedCount();
       expect(delayedCount).to.be.equal(1);
 
@@ -1472,25 +1463,6 @@ describe('Job Scheduler', function () {
       const count = await queue.count();
       expect(count).to.be.equal(1);
       expect(jobSchedulers).to.have.length(1);
-
-      expect(jobSchedulers[0]).to.deep.equal({
-        key: 'test',
-        name: 'a',
-        endDate: null,
-        tz: 'Asia/Calcutta',
-        pattern: '0 * 1 * *',
-        every: null,
-        next: 1488310200000,
-        template: {
-          data: {
-            foo: 'bar',
-          },
-          opts: {
-            priority: 1,
-          },
-        },
-      });
-
       await worker.close();
     });
 
diff --git a/tests/test_metrics.ts b/tests/test_metrics.ts
index f59d4e44d7..6433afc8b2 100644
--- a/tests/test_metrics.ts
+++ b/tests/test_metrics.ts
@@ -28,7 +28,7 @@ describe('metrics', function () {
   });
 
   beforeEach(function () {
-    this.clock = sinon.useFakeTimers({ shouldClearNativeTimers: true });
+    this.clock = sinon.useFakeTimers();
   });
 
   beforeEach(async function () {
