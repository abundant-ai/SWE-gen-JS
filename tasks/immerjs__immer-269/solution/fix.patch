diff --git a/.vscode/settings.json b/.vscode/settings.json
new file mode 100644
index 0000000..f9a4c68
--- /dev/null
+++ b/.vscode/settings.json
@@ -0,0 +1,3 @@
+{
+  "javascript.validate.enable": false
+}
diff --git a/package.json b/package.json
index c3ff623..9e7b1e2 100644
--- a/package.json
+++ b/package.json
@@ -12,10 +12,10 @@
     "watch": "jest --watch",
     "test": "jest",
     "test:perf": "NODE_ENV=production yarn-or-npm build && cd __performance_tests__ && babel-node add-data.js && babel-node todo.js && babel-node incremental.js",
-    "test:flow": "yarn-or-npm flow check",
-    "test:dts": "tsc -p __tests__/test.tsconfig.json --noEmit",
-    "coveralls": "jest --coverage && cat ./coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js && rm -rf ./coverage",
-    "build": "rimraf dist/ && cross-env NODE_ENV=production rollup -c && cpx \"src/immer.{d.ts,js.flow}\" dist"
+    "test:flow": "yarn-or-npm flow check __tests__/flow",
+    "test:dts": "tsc -p __tests__/tsconfig.json --noEmit",
+    "coveralls": "jest --coverage && cat ./coverage/lcov.info | ./node_modules/.bin/coveralls && rm -rf ./coverage",
+    "build": "rimraf dist/ && cross-env NODE_ENV=production rollup -c && cpx 'src/immer.{d.ts,js.flow}' dist -v"
   },
   "husky": {
     "hooks": {
diff --git a/src/immer.d.ts b/src/immer.d.ts
new file mode 100644
index 0000000..e2ab2da
--- /dev/null
+++ b/src/immer.d.ts
@@ -0,0 +1,188 @@
+/** Object types that should never be mapped */
+type AtomicObject =
+    | Function
+    | Map<any, any>
+    | WeakMap<any, any>
+    | Set<any>
+    | WeakSet<any>
+    | Promise<any>
+    | Date
+    | RegExp
+    | Boolean
+    | Number
+    | String
+
+/** Use type inference to know when an array is finite */
+type IsFinite<T extends any[]> = T extends never[]
+    ? true
+    : T extends ReadonlyArray<infer U>
+    ? (U[] extends T ? false : true)
+    : true
+
+export type DraftObject<T> = T extends object
+    ? T extends AtomicObject
+        ? T
+        : {-readonly [P in keyof T]: Draft<T[P]>}
+    : T
+
+export type DraftArray<T> = Array<
+    T extends ReadonlyArray<any>
+        ? {[P in keyof T]: Draft<T>}[keyof T]
+        : DraftObject<T>
+>
+
+export type DraftTuple<T extends any[]> = {
+    [P in keyof T]: T[P] extends T[number] ? Draft<T[P]> : never
+}
+
+export type Draft<T> = T extends any[]
+    ? IsFinite<T> extends true
+        ? DraftTuple<T>
+        : DraftArray<T[number]>
+    : T extends ReadonlyArray<any>
+    ? DraftArray<T[number]>
+    : T extends object
+    ? DraftObject<T>
+    : T
+
+export interface Patch {
+    op: "replace" | "remove" | "add"
+    path: (string | number)[]
+    value?: any
+}
+
+export type PatchListener = (patches: Patch[], inversePatches: Patch[]) => void
+
+export interface IProduce {
+    /**
+     * The `produce` function takes a value and a "recipe function" (whose
+     * return value often depends on the base state). The recipe function is
+     * free to mutate its first argument however it wants. All mutations are
+     * only ever applied to a __copy__ of the base state.
+     *
+     * Pass only a function to create a "curried producer" which relieves you
+     * from passing the recipe function every time.
+     *
+     * Only plain objects and arrays are made mutable. All other objects are
+     * considered uncopyable.
+     *
+     * Note: This function is __bound__ to its `Immer` instance.
+     *
+     * @param {any} base - the initial state
+     * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified
+     * @param {Function} patchListener - optional function that will be called with all the patches produced here
+     * @returns {any} a new state, or the initial state if nothing was modified
+     */
+    <S = any, R = never>(
+        currentState: S,
+        recipe: (this: Draft<S>, draft: Draft<S>) => void | R,
+        listener?: PatchListener
+    ): R
+
+    /** Curried producer with an initial state */
+    <S = any, R = never>(
+        recipe: (this: Draft<S>, draft: Draft<S>) => void | R,
+        defaultBase: S
+    ): (base: S | undefined) => R
+
+    /** Curried producer with no initial state */
+    <S = any, R = never, Args extends any[] = any[]>(
+        recipe: (
+            this: Draft<S>,
+            draft: Draft<S>,
+            ...extraArgs: Args
+        ) => void | R
+    ): (base: S, ...extraArgs: Args) => R
+}
+
+export const produce: IProduce
+export default produce
+
+/**
+ * The sentinel value returned by producers to replace the draft with undefined.
+ */
+export const nothing: undefined
+
+/**
+ * Pass true to automatically freeze all copies created by Immer.
+ *
+ * By default, auto-freezing is disabled in production.
+ */
+export function setAutoFreeze(autoFreeze: boolean): void
+
+/**
+ * Pass true to use the ES2015 `Proxy` class when creating drafts, which is
+ * always faster than using ES5 proxies.
+ *
+ * By default, feature detection is used, so calling this is rarely necessary.
+ */
+export function setUseProxies(useProxies: boolean): void
+
+/**
+ * Apply an array of Immer patches to the first argument.
+ *
+ * This function is a producer, which means copy-on-write is in effect.
+ */
+export function applyPatches<S>(base: S, patches: Patch[]): S
+
+export function original<T>(value: T): T | void
+
+export function isDraft(value: any): boolean
+
+export class Immer {
+    constructor(config: {
+        useProxies?: boolean
+        autoFreeze?: boolean
+        onAssign?: (state: ImmerState, prop: keyof any, value: any) => void
+        onDelete?: (state: ImmerState, prop: keyof any) => void
+        onCopy?: (state: ImmerState) => void
+    })
+    /**
+     * The `produce` function takes a value and a "recipe function" (whose
+     * return value often depends on the base state). The recipe function is
+     * free to mutate its first argument however it wants. All mutations are
+     * only ever applied to a __copy__ of the base state.
+     *
+     * Pass only a function to create a "curried producer" which relieves you
+     * from passing the recipe function every time.
+     *
+     * Only plain objects and arrays are made mutable. All other objects are
+     * considered uncopyable.
+     *
+     * Note: This function is __bound__ to its `Immer` instance.
+     *
+     * @param {any} base - the initial state
+     * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified
+     * @param {Function} patchListener - optional function that will be called with all the patches produced here
+     * @returns {any} a new state, or the initial state if nothing was modified
+     */
+    produce: IProduce
+    /**
+     * When true, `produce` will freeze the copies it creates.
+     */
+    readonly autoFreeze: boolean
+    /**
+     * When true, drafts are ES2015 proxies.
+     */
+    readonly useProxies: boolean
+    /**
+     * Pass true to automatically freeze all copies created by Immer.
+     *
+     * By default, auto-freezing is disabled in production.
+     */
+    setAutoFreeze(autoFreeze: boolean): void
+    /**
+     * Pass true to use the ES2015 `Proxy` class when creating drafts, which is
+     * always faster than using ES5 proxies.
+     *
+     * By default, feature detection is used, so calling this is rarely necessary.
+     */
+    setUseProxies(useProxies: boolean): void
+}
+
+export interface ImmerState<T = any> {
+    parent?: ImmerState
+    base: T
+    copy: T
+    assigned: {[prop: string]: boolean}
+}
diff --git a/src/immer.js.flow b/src/immer.js.flow
new file mode 100644
index 0000000..7301843
--- /dev/null
+++ b/src/immer.js.flow
@@ -0,0 +1,92 @@
+// @flow
+
+export interface Patch {
+    op: "replace" | "remove" | "add",
+    path: (string|number)[],
+    value?: any
+}
+
+export type PatchListener = (patches: Patch[], inversePatches: Patch[]) => void
+
+interface IProduce {
+    /**
+     * Immer takes a state, and runs a function against it.
+     * That function can freely mutate the state, as it will create copies-on-write.
+     * This means that the original state will stay unchanged, and once the function finishes, the modified state is returned.
+     *
+     * If the first argument is a function, this is interpreted as the recipe, and will create a curried function that will execute the recipe
+     * any time it is called with the current state.
+     *
+     * @param currentState - the state to start with
+     * @param recipe - function that receives a proxy of the current state as first argument and which can be freely modified
+     * @param initialState - if a curried function is created and this argument was given, it will be used as fallback if the curried function is called with a state of undefined
+     * @returns The next state: a new state, or the current state if nothing was modified
+     */
+    <S>(
+        currentState: S,
+        recipe: (draftState: S) => S | void,
+        patchListener?: PatchListener
+    ): S;
+    // curried invocations with inital state
+    <S, A, B, C>(
+        recipe: (draftState: S, a: A, b: B, c: C) => S | void,
+        initialState: S
+    ): (currentState: S | void, a: A, b: B, c: C) => S;
+    <S, A, B>(
+        recipe: (draftState: S, a: A, b: B) => S | void,
+        initialState: S
+    ): (currentState: S | void, a: A, b: B) => S;
+    <S, A>(
+        recipe: (draftState: S, a: A) => S | void,
+        initialState: S
+    ): (currentState: S | void, a: A) => S;
+    <S>(
+        recipe: (draftState: S) => S | void,
+        initialState: S
+    ): (currentState: S | void) => S;
+    <S>(
+        recipe: (draftState: S, ...extraArgs: any[]) => S | void,
+        initialState: S
+    ): (currentState: S | void, ...extraArgs: any[]) => S;
+    // curried invocations without inital state
+    <S, A, B, C>(
+        recipe: (draftState: S, a: A, b: B, c: C) => S | void
+    ): (currentState: S, a: A, b: B, c: C) => S;
+    <S, A, B>(
+        recipe: (draftState: S, a: A, b: B) => S | void
+    ): (currentState: S, a: A, b: B) => S;
+    <S, A>(
+        recipe: (draftState: S, a: A) => S | void
+    ): (currentState: S, a: A) => S;
+    <S>(
+        recipe: (draftState: S) => S | void
+    ): (currentState: S) => S;
+    <S>(
+        recipe: (draftState: S, ...extraArgs: any[]) => S | void
+    ): (currentState: S, ...extraArgs: any[]) => S;
+}
+
+declare export var produce: IProduce
+declare export default IProduce
+
+declare export var nothing: typeof undefined
+
+/**
+ * Automatically freezes any state trees generated by immer.
+ * This protects against accidental modifications of the state tree outside of an immer function.
+ * This comes with a performance impact, so it is recommended to disable this option in production.
+ * By default it is turned on during local development, and turned off in production.
+ */
+declare export function setAutoFreeze(autoFreeze: boolean): void
+
+/**
+ * Manually override whether proxies should be used.
+ * By default done by using feature detection
+ */
+declare export function setUseProxies(useProxies: boolean): void
+
+declare export function applyPatches<S>(state: S, patches: Patch[]): S
+
+declare export function original<S>(value: S): ?S
+
+declare export function isDraft(value: any): boolean
