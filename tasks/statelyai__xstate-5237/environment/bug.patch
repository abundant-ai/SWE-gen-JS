diff --git a/.changeset/grumpy-countries-serve.md b/.changeset/grumpy-countries-serve.md
deleted file mode 100644
index 481ee37f36..0000000000
--- a/.changeset/grumpy-countries-serve.md
+++ /dev/null
@@ -1,5 +0,0 @@
----
-'@xstate/store': patch
----
-
-Fixed a bug where conditional atoms were not properly unsubscribed when no longer needed.
diff --git a/packages/xstate-store/src/atom.ts b/packages/xstate-store/src/atom.ts
index ce9892c96e..2b108a9fb4 100644
--- a/packages/xstate-store/src/atom.ts
+++ b/packages/xstate-store/src/atom.ts
@@ -1,12 +1,5 @@
 import { toObserver } from './toObserver';
-import {
-  AnyAtom,
-  Atom,
-  Observer,
-  Readable,
-  ReadonlyAtom,
-  Subscription
-} from './types';
+import { Atom, Observer, Readable, ReadonlyAtom, Subscription } from './types';
 
 export function createAtom<T>(
   getValue: (read: <U>(atom: Readable<U>) => U) => T
@@ -17,17 +10,14 @@ export function createAtom<T>(
 ): Atom<T> | ReadonlyAtom<T> {
   const current = { value: undefined as T };
   let observers: Set<Observer<T>> | undefined;
+  const subs = new Map<Atom<any>, Subscription>();
 
   // Handle computed case
   if (typeof valueOrFn === 'function') {
-    const subs = new Map<AnyAtom, Subscription>();
-    let observedAtoms = new Set<AnyAtom>();
-
     const getValue = valueOrFn as (read: <U>(atom: Atom<U>) => U) => T;
-    const read = (atom: AnyAtom) => {
-      observedAtoms.add(atom);
+    const read = (atom: Atom<any>) => {
       const val = atom.get();
-      if (subs.has(atom)) {
+      if (subs.get(atom)) {
         return val;
       }
       const sub = atom.subscribe(recompute);
@@ -36,17 +26,7 @@ export function createAtom<T>(
     };
 
     function recompute() {
-      observedAtoms = new Set();
       const newValue = getValue(read);
-
-      // Cleanup any atoms that are no longer observed
-      for (const [atom, sub] of subs) {
-        if (!observedAtoms.has(atom)) {
-          sub.unsubscribe();
-          subs.delete(atom);
-        }
-      }
-
       current.value = newValue;
       observers?.forEach((o) => o.next?.(newValue));
     }
diff --git a/packages/xstate-store/src/types.ts b/packages/xstate-store/src/types.ts
index 948bcd96d8..93732b1a2f 100644
--- a/packages/xstate-store/src/types.ts
+++ b/packages/xstate-store/src/types.ts
@@ -370,8 +370,6 @@ export interface Atom<T> extends Subscribable<T>, Readable<T> {
   set(value: T): void;
 }
 
-export type AnyAtom = Atom<any>;
-
 /**
  * An atom that is read-only and cannot be set.
  *
diff --git a/packages/xstate-store/test/atom.test.ts b/packages/xstate-store/test/atom.test.ts
index 54f730e22a..e4589909d9 100644
--- a/packages/xstate-store/test/atom.test.ts
+++ b/packages/xstate-store/test/atom.test.ts
@@ -139,67 +139,3 @@ it('combined atoms should be read-only', () => {
 
   expect(combinedAtom.get()).toBe(1);
 });
-
-it('conditionally read atoms are properly read in combined atoms', () => {
-  const atom1 = createAtom(true);
-  const atom2 = createAtom(false);
-  const activatorAtom = createAtom<'inactive' | 'active'>('inactive');
-  const combinedAtom = createAtom((read) =>
-    read(activatorAtom) === 'active' ? read(atom1) : read(atom2)
-  );
-
-  expect(combinedAtom.get()).toBe(false);
-
-  activatorAtom.set('active');
-
-  expect(combinedAtom.get()).toBe(true);
-
-  activatorAtom.set('inactive');
-
-  expect(combinedAtom.get()).toBe(false);
-});
-
-it('conditionally read atoms are properly unsubscribed when no longer needed', () => {
-  const atom1 = createAtom(true);
-  const activatorAtom = createAtom<'inactive' | 'active'>('active');
-  const combinedAtom = createAtom((read) =>
-    read(activatorAtom) === 'active' ? read(atom1) : {}
-  );
-
-  const vals: any[] = [];
-
-  combinedAtom.subscribe((val) => vals.push(val));
-
-  atom1.set(false);
-
-  expect(vals).toEqual([false]);
-
-  atom1.set(true);
-
-  expect(vals).toEqual([false, true]);
-
-  activatorAtom.set('inactive');
-
-  // From here, atom1 should no longer be subscribed to
-  // Without the unsubscribe logic, this would be [false, true, {}, {}, ...]
-
-  expect(vals).toEqual([false, true, {}]);
-
-  atom1.set(false);
-
-  expect(vals).toEqual([false, true, {}]);
-
-  atom1.set(true);
-
-  expect(vals).toEqual([false, true, {}]);
-
-  // Subscribing again should cause atom1 to be subscribed again
-
-  activatorAtom.set('active');
-
-  expect(vals).toEqual([false, true, {}, true]);
-
-  atom1.set(false);
-
-  expect(vals).toEqual([false, true, {}, true, false]);
-});
