diff --git a/.gitignore b/.gitignore
index 148181e07..075a4d740 100644
--- a/.gitignore
+++ b/.gitignore
@@ -3,8 +3,6 @@
 test.js
 coverage/
 build/
-logs
-wdio-logs
 npm-debug.log
 yarn-error.log
 .pnpm-debug.log
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 7e541a3d3..dbbab930b 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,20 +1,3 @@
-v8.49.0 - September 8, 2023
-
-* [`b7621c3`](https://github.com/eslint/eslint/commit/b7621c3b16cf7d5539f05336a827e1b32d95e6ac) chore: remove browser test from `npm test` (#17550) (Milos Djermanovic)
-* [`cac45d0`](https://github.com/eslint/eslint/commit/cac45d04b890b0700dd8908927300608adad05fe) chore: upgrade @eslint/js@8.49.0 (#17549) (Milos Djermanovic)
-* [`cd39508`](https://github.com/eslint/eslint/commit/cd395082bffcb4b68efa09226d7c682cef56179e) chore: package.json update for @eslint/js release (ESLint Jenkins)
-* [`ecfb54f`](https://github.com/eslint/eslint/commit/ecfb54ff4cdd18f28b4f9b78f0a78fb4cf80f1b8) docs: Update README (GitHub Actions Bot)
-* [`da09f4e`](https://github.com/eslint/eslint/commit/da09f4e641141f585ef611c6e9d63d4331054706) feat: Implement onUnreachableCodePathStart/End (#17511) (Nicholas C. Zakas)
-* [`de86b3b`](https://github.com/eslint/eslint/commit/de86b3b2e58edd5826200c23255d8325abe375e1) docs: update `no-promise-executor-return` examples (#17529) (Nitin Kumar)
-* [`203a971`](https://github.com/eslint/eslint/commit/203a971c0abc3a95ae02ff74104a01e569707060) ci: bump actions/checkout from 3 to 4 (#17530) (dependabot[bot])
-* [`32b2327`](https://github.com/eslint/eslint/commit/32b2327aafdd3b911fabab69ed75c9ff97658c60) feat: Emit deprecation warnings in RuleTester (#17527) (Nicholas C. Zakas)
-* [`acb7df3`](https://github.com/eslint/eslint/commit/acb7df35b9a7485f26bc6b3e1f9083d1c585dce9) feat: add new `enforce` option to `lines-between-class-members` (#17462) (Nitin Kumar)
-* [`032c4b1`](https://github.com/eslint/eslint/commit/032c4b1476a7b8cfd917a66772d2221950ea87eb) docs: add typescript template (#17500) (James)
-* [`cd7da5c`](https://github.com/eslint/eslint/commit/cd7da5cc3154f86f7ca45fb58929d27a7af359ed) docs: Update README (GitHub Actions Bot)
-* [`a40fa50`](https://github.com/eslint/eslint/commit/a40fa509922b36bb986eb1be9394591f84f62d9e) chore: use eslint-plugin-jsdoc's flat config (#17516) (Milos Djermanovic)
-* [`926a286`](https://github.com/eslint/eslint/commit/926a28684282aeec37680bbc52a66973b8055f54) test: replace Karma with Webdriver.IO (#17126) (Christian Bromann)
-* [`f591d2c`](https://github.com/eslint/eslint/commit/f591d2c88bf15af72e3a207b34fa872b4b90464b) chore: Upgrade config-array (#17512) (Nicholas C. Zakas)
-
 v8.48.0 - August 25, 2023
 
 * [`8dd3cec`](https://github.com/eslint/eslint/commit/8dd3cec90c97ed97d243a83b87ad4ea9e6b4781a) chore: upgrade @eslint/js@8.48.0 (#17501) (Milos Djermanovic)
diff --git a/Makefile.js b/Makefile.js
index 7978369c0..717cc7859 100644
--- a/Makefile.js
+++ b/Makefile.js
@@ -628,10 +628,12 @@ target.mocha = () => {
     }
 };
 
-target.wdio = () => {
+target.karma = () => {
     echo("Running unit tests on browsers");
+
     target.webpack("production");
-    const lastReturn = exec(`${getBinFile("wdio")} run wdio.conf.js`);
+
+    const lastReturn = exec(`${getBinFile("karma")} start karma.conf.js`);
 
     if (lastReturn.code !== 0) {
         exit(1);
@@ -641,9 +643,7 @@ target.wdio = () => {
 target.test = function() {
     target.checkRuleFiles();
     target.mocha();
-
-    // target.wdio(); // Temporarily disabled due to problems on Jenkins
-
+    target.karma();
     target.fuzz({ amount: 150, fuzzBrokenAutofixes: false });
     target.checkLicenses();
 };
diff --git a/README.md b/README.md
index 01d50a0c9..0ce3a4a5a 100644
--- a/README.md
+++ b/README.md
@@ -288,8 +288,8 @@ The following companies, organizations, and individuals support ESLint's ongoing
 <h3>Platinum Sponsors</h3>
 <p><a href="#"><img src="https://images.opencollective.com/2021-frameworks-fund/logo.png" alt="Chrome Frameworks Fund" height="undefined"></a> <a href="https://automattic.com"><img src="https://images.opencollective.com/automattic/d0ef3e1/logo.png" alt="Automattic" height="undefined"></a></p><h3>Gold Sponsors</h3>
 <p><a href="https://engineering.salesforce.com"><img src="https://images.opencollective.com/salesforce/ca8f997/logo.png" alt="Salesforce" height="96"></a> <a href="https://www.airbnb.com/"><img src="https://images.opencollective.com/airbnb/d327d66/logo.png" alt="Airbnb" height="96"></a></p><h3>Silver Sponsors</h3>
-<p><a href="https://sentry.io"><img src="https://avatars.githubusercontent.com/u/1396951?v=4" alt="Sentry" height="64"></a> <a href="https://liftoff.io/"><img src="https://images.opencollective.com/liftoff/5c4fa84/logo.png" alt="Liftoff" height="64"></a> <a href="https://opensource.siemens.com"><img src="https://avatars.githubusercontent.com/u/624020?v=4" alt="Siemens" height="64"></a> <a href="https://americanexpress.io"><img src="https://avatars.githubusercontent.com/u/3853301?v=4" alt="American Express" height="64"></a></p><h3>Bronze Sponsors</h3>
-<p><a href="https://themeisle.com"><img src="https://images.opencollective.com/themeisle/d5592fe/logo.png" alt="ThemeIsle" height="32"></a> <a href="https://nx.dev"><img src="https://images.opencollective.com/nx/0efbe42/logo.png" alt="Nx (by Nrwl)" height="32"></a> <a href="https://www.crosswordsolver.org/anagram-solver/"><img src="https://images.opencollective.com/anagram-solver/2666271/logo.png" alt="Anagram Solver" height="32"></a> <a href="https://icons8.com/"><img src="https://images.opencollective.com/icons8/7fa1641/logo.png" alt="Icons8" height="32"></a> <a href="https://discord.com"><img src="https://images.opencollective.com/discordapp/f9645d9/logo.png" alt="Discord" height="32"></a> <a href="https://github.com/about"><img src="https://avatars.githubusercontent.com/u/9919?v=4" alt="GitHub" height="32"></a> <a href="https://transloadit.com/"><img src="https://avatars.githubusercontent.com/u/125754?v=4" alt="Transloadit" height="32"></a> <a href="https://www.ignitionapp.com"><img src="https://avatars.githubusercontent.com/u/5753491?v=4" alt="Ignition" height="32"></a> <a href="https://herocoders.com"><img src="https://avatars.githubusercontent.com/u/37549774?v=4" alt="HeroCoders" height="32"></a> <a href="https://quickbookstoolhub.com"><img src="https://avatars.githubusercontent.com/u/95090305?u=e5bc398ef775c9ed19f955c675cdc1fb6abf01df&v=4" alt="QuickBooks Tool hub" height="32"></a></p>
+<p><a href="https://sentry.io"><img src="https://avatars.githubusercontent.com/u/1396951?v=4" alt="Sentry" height="64"></a> <a href="https://liftoff.io/"><img src="https://images.opencollective.com/liftoff/5c4fa84/logo.png" alt="Liftoff" height="64"></a> <a href="https://americanexpress.io"><img src="https://avatars.githubusercontent.com/u/3853301?v=4" alt="American Express" height="64"></a></p><h3>Bronze Sponsors</h3>
+<p><a href="https://themeisle.com"><img src="https://images.opencollective.com/themeisle/d5592fe/logo.png" alt="ThemeIsle" height="32"></a> <a href="https://nx.dev"><img src="https://images.opencollective.com/nx/0efbe42/logo.png" alt="Nx (by Nrwl)" height="32"></a> <a href="https://www.crosswordsolver.org/anagram-solver/"><img src="https://images.opencollective.com/anagram-solver/2666271/logo.png" alt="Anagram Solver" height="32"></a> <a href="https://icons8.com"><img src="https://images.opencollective.com/icons8/7fa1641/logo.png" alt="Icons8: free icons, photos, illustrations, and music" height="32"></a> <a href="https://discord.com"><img src="https://images.opencollective.com/discordapp/f9645d9/logo.png" alt="Discord" height="32"></a> <a href="https://github.com/about"><img src="https://avatars.githubusercontent.com/u/9919?v=4" alt="GitHub" height="32"></a> <a href="https://transloadit.com/"><img src="https://avatars.githubusercontent.com/u/125754?v=4" alt="Transloadit" height="32"></a> <a href="https://www.ignitionapp.com"><img src="https://avatars.githubusercontent.com/u/5753491?v=4" alt="Ignition" height="32"></a> <a href="https://herocoders.com"><img src="https://avatars.githubusercontent.com/u/37549774?v=4" alt="HeroCoders" height="32"></a> <a href="https://quickbookstoolhub.com"><img src="https://avatars.githubusercontent.com/u/95090305?u=e5bc398ef775c9ed19f955c675cdc1fb6abf01df&v=4" alt="QuickBooks Tool hub" height="32"></a></p>
 <!--sponsorsend-->
 
 ## Technology Sponsors
diff --git a/docs/package.json b/docs/package.json
index e04a56f13..15cab3134 100644
--- a/docs/package.json
+++ b/docs/package.json
@@ -1,7 +1,7 @@
 {
     "name": "docs-eslint",
     "private": true,
-    "version": "8.49.0",
+    "version": "8.48.0",
     "description": "",
     "main": "index.js",
     "keywords": [],
diff --git a/docs/src/_includes/layouts/doc.html b/docs/src/_includes/layouts/doc.html
index 58d8986a5..4050a9010 100644
--- a/docs/src/_includes/layouts/doc.html
+++ b/docs/src/_includes/layouts/doc.html
@@ -19,22 +19,6 @@ layout: base.html
     {% set added_version = rule_versions.added[title] %}
     {% set removed_version = rule_versions.removed[title] %}
 
-    {% if handled_by_typescript %}
-        {% set handled_by_typescript_content %}
-            <h2 id="handled_by_typescript">Handled by TypeScript</h2>
-            <p>
-                It is safe to disable this rule when using TypeScript because TypeScript's compiler enforces this check.
-            </p>
-            {% if extra_typescript_info %}
-                <p>
-                    {{ extra_typescript_info | markdown | safe }}
-                </p>
-            {% endif %}
-        {% endset %}
-
-        {% set all_content = [all_content, handled_by_typescript_content] | join %}
-    {% endif %}
-
     {% if related_rules %}
         {% set related_rules_content %}
             <h2 id="related-rules">Related Rules</h2>
@@ -64,7 +48,7 @@ layout: base.html
 
         {% set all_content = [all_content, further_reading_content] | join %}
     {% endif %}
-
+        
     {% if rule_meta %}
         {% set resources_content %}
             <h2 id="resources">Resources</h2>
@@ -92,7 +76,7 @@ layout: base.html
                 {% endif %}
 
                 {% include 'components/docs-toc.html' %}
-
+                
                 {{ all_content | safe }}
             </div>
 
@@ -118,7 +102,6 @@ layout: base.html
             {% include "partials/docs-footer.html" %}
         </div>
     </div>
-
     <a id="scroll-up-btn" href="#site_top">
         <svg fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 24 24" width="24"><line x1="12" x2="12" y1="19" y2="5"/><polyline points="5 12 12 5 19 12"/></svg>
     </a>
diff --git a/docs/src/extend/code-path-analysis.md b/docs/src/extend/code-path-analysis.md
index 879119574..7344f8647 100644
--- a/docs/src/extend/code-path-analysis.md
+++ b/docs/src/extend/code-path-analysis.md
@@ -37,7 +37,7 @@ This has references of both the initial segment and the final segments of a code
 * `finalSegments` (`CodePathSegment[]`) - The final segments which includes both returned and thrown.
 * `returnedSegments` (`CodePathSegment[]`) - The final segments which includes only returned.
 * `thrownSegments` (`CodePathSegment[]`) - The final segments which includes only thrown.
-* `currentSegments` (`CodePathSegment[]`) - **Deprecated.** Segments of the current traversal position.
+* `currentSegments` (`CodePathSegment[]`) - Segments of the current position.
 * `upper` (`CodePath|null`) - The code path of the upper function/global scope.
 * `childCodePaths` (`CodePath[]`) - Code paths of functions this code path contains.
 
@@ -56,110 +56,77 @@ Difference from doubly linked list is what there are forking and merging (the ne
 
 ## Events
 
-There are seven events related to code paths, and you can define event handlers by adding them alongside node visitors in the object exported from the `create()` method of your rule.
+There are five events related to code paths, and you can define event handlers in rules.
 
 ```js
-module.exports = {
-    meta: {
-        // ...
-    },
-    create(context) {
-
-        return {
-            /**
-             * This is called at the start of analyzing a code path.
-             * In this time, the code path object has only the initial segment.
-             *
-             * @param {CodePath} codePath - The new code path.
-             * @param {ASTNode} node - The current node.
-             * @returns {void}
-             */
-            onCodePathStart(codePath, node) {
-                // do something with codePath
-            },
-
-            /**
-             * This is called at the end of analyzing a code path.
-             * In this time, the code path object is complete.
-             *
-             * @param {CodePath} codePath - The completed code path.
-             * @param {ASTNode} node - The current node.
-             * @returns {void}
-             */
-            onCodePathEnd(codePath, node) {
-                // do something with codePath
-            },
-
-            /**
-             * This is called when a reachable code path segment was created.
-             * It meant the code path is forked or merged.
-             * In this time, the segment has the previous segments and has been
-             * judged reachable or not.
-             *
-             * @param {CodePathSegment} segment - The new code path segment.
-             * @param {ASTNode} node - The current node.
-             * @returns {void}
-             */
-            onCodePathSegmentStart(segment, node) {
-                // do something with segment
-            },
-
-            /**
-             * This is called when a reachable code path segment was left.
-             * In this time, the segment does not have the next segments yet.
-             *
-             * @param {CodePathSegment} segment - The left code path segment.
-             * @param {ASTNode} node - The current node.
-             * @returns {void}
-             */
-            onCodePathSegmentEnd(segment, node) {
-                // do something with segment
-            },
-
-            /**
-             * This is called when an unreachable code path segment was created.
-             * It meant the code path is forked or merged.
-             * In this time, the segment has the previous segments and has been
-             * judged reachable or not.
-             *
-             * @param {CodePathSegment} segment - The new code path segment.
-             * @param {ASTNode} node - The current node.
-             * @returns {void}
-             */
-            onUnreachableCodePathSegmentStart(segment, node) {
-                // do something with segment
-            },
-
-            /**
-             * This is called when an unreachable code path segment was left.
-             * In this time, the segment does not have the next segments yet.
-             *
-             * @param {CodePathSegment} segment - The left code path segment.
-             * @param {ASTNode} node - The current node.
-             * @returns {void}
-             */
-            onUnreachableCodePathSegmentEnd(segment, node) {
-                // do something with segment
-            },
-
-            /**
-             * This is called when a code path segment was looped.
-             * Usually segments have each previous segments when created,
-             * but when looped, a segment is added as a new previous segment into a
-             * existing segment.
-             *
-             * @param {CodePathSegment} fromSegment - A code path segment of source.
-             * @param {CodePathSegment} toSegment - A code path segment of destination.
-             * @param {ASTNode} node - The current node.
-             * @returns {void}
-             */
-            onCodePathSegmentLoop(fromSegment, toSegment, node) {
-                // do something with segment
-            }
-        };
-
-    }
-}
+module.exports = function(context) {
+    return {
+        /**
+         * This is called at the start of analyzing a code path.
+         * In this time, the code path object has only the initial segment.
+         *
+         * @param {CodePath} codePath - The new code path.
+         * @param {ASTNode} node - The current node.
+         * @returns {void}
+         */
+        "onCodePathStart": function(codePath, node) {
+            // do something with codePath
+        },
+
+        /**
+         * This is called at the end of analyzing a code path.
+         * In this time, the code path object is complete.
+         *
+         * @param {CodePath} codePath - The completed code path.
+         * @param {ASTNode} node - The current node.
+         * @returns {void}
+         */
+        "onCodePathEnd": function(codePath, node) {
+            // do something with codePath
+        },
+
+        /**
+         * This is called when a code path segment was created.
+         * It meant the code path is forked or merged.
+         * In this time, the segment has the previous segments and has been
+         * judged reachable or not.
+         *
+         * @param {CodePathSegment} segment - The new code path segment.
+         * @param {ASTNode} node - The current node.
+         * @returns {void}
+         */
+        "onCodePathSegmentStart": function(segment, node) {
+            // do something with segment
+        },
+
+        /**
+         * This is called when a code path segment was left.
+         * In this time, the segment does not have the next segments yet.
+         *
+         * @param {CodePathSegment} segment - The left code path segment.
+         * @param {ASTNode} node - The current node.
+         * @returns {void}
+         */
+        "onCodePathSegmentEnd": function(segment, node) {
+            // do something with segment
+        },
+
+        /**
+         * This is called when a code path segment was looped.
+         * Usually segments have each previous segments when created,
+         * but when looped, a segment is added as a new previous segment into a
+         * existing segment.
+         *
+         * @param {CodePathSegment} fromSegment - A code path segment of source.
+         * @param {CodePathSegment} toSegment - A code path segment of destination.
+         * @param {ASTNode} node - The current node.
+         * @returns {void}
+         */
+        "onCodePathSegmentLoop": function(fromSegment, toSegment, node) {
+            // do something with segment
+        }
+    };
+};
 ```
 
 ### About `onCodePathSegmentLoop`
@@ -245,134 +212,35 @@ bar();
 
 ## Usage Examples
 
-### Track current segment position
-
-To track the current code path segment position, you can define a rule like this:
+### To check whether or not this is reachable
 
 ```js
-module.exports = {
-    meta: {
-        // ...
-    },
-    create(context) {
-
-        // tracks the code path we are currently in
-        let currentCodePath;
-
-        // tracks the segments we've traversed in the current code path
-        let currentSegments;
-
-        // tracks all current segments for all open paths
-        const allCurrentSegments = [];
-
-        return {
-
-            onCodePathStart(codePath) {
-                currentCodePath = codePath;
-                allCurrentSegments.push(currentSegments);
-                currentSegments = new Set();
-            },
-
-            onCodePathEnd(codePath) {
-                currentCodePath = codePath.upper;
-                currentSegments = allCurrentSegments.pop();
-            },
-
-            onCodePathSegmentStart(segment) {
-                currentSegments.add(segment);
-            },
-
-            onCodePathSegmentEnd(segment) {
-                currentSegments.delete(segment);
-            },
-
-            onUnreachableCodePathSegmentStart(segment) {
-                currentSegments.add(segment);
-            },
-
-            onUnreachableCodePathSegmentEnd(segment) {
-                currentSegments.delete(segment);
-            }
-        };
-
-    }
-};
-```
-
-In this example, the `currentCodePath` variable is used to access the code path that is currently being traversed and the `currentSegments` variable tracks the segments in that code path that have been traversed to that point. Note that `currentSegments` both starts and ends as an empty set, constantly being updated as the traversal progresses.
-
-Tracking the current segment position is helpful for analyzing the code path that led to a particular node, as in the next example.
-
-### Find an unreachable node
-
-To find an unreachable node, track the current segment position and then use a node visitor to check if any of the segments are reachable. For example, the following looks for any `ExpressionStatement` that is unreachable.
-
-```js
-function areAnySegmentsReachable(segments) {
-    for (const segment of segments) {
-        if (segment.reachable) {
-            return true;
-        }
-    }
-
-    return false;
+function isReachable(segment) {
+    return segment.reachable;
 }
 
-module.exports = {
-    meta: {
-        // ...
-    },
-    create(context) {
-
-        // tracks the code path we are currently in
-        let currentCodePath;
-
-        // tracks the segments we've traversed in the current code path
-        let currentSegments;
-
-        // tracks all current segments for all open paths
-        const allCurrentSegments = [];
-
-        return {
-
-            onCodePathStart(codePath) {
-                currentCodePath = codePath;
-                allCurrentSegments.push(currentSegments);
-                currentSegments = new Set();
-            },
-
-            onCodePathEnd(codePath) {
-                currentCodePath = codePath.upper;
-                currentSegments = allCurrentSegments.pop();
-            },
-
-            onCodePathSegmentStart(segment) {
-                currentSegments.add(segment);
-            },
-
-            onCodePathSegmentEnd(segment) {
-                currentSegments.delete(segment);
-            },
-
-            onUnreachableCodePathSegmentStart(segment) {
-                currentSegments.add(segment);
-            },
-
-            onUnreachableCodePathSegmentEnd(segment) {
-                currentSegments.delete(segment);
-            },
-
-            ExpressionStatement(node) {
-
-                // check all the code path segments that led to this node
-                if (!areAnySegmentsReachable(currentSegments)) {
-                    context.report({ message: "Unreachable!", node });
-                }
+module.exports = function(context) {
+    var codePathStack = [];
+
+    return {
+        // Stores CodePath objects.
+        "onCodePathStart": function(codePath) {
+            codePathStack.push(codePath);
+        },
+        "onCodePathEnd": function(codePath) {
+            codePathStack.pop();
+        },
+
+        // Checks reachable or not.
+        "ExpressionStatement": function(node) {
+            var codePath = codePathStack[codePathStack.length - 1];
+
+            // Checks the current code path segments.
+            if (!codePath.currentSegments.some(isReachable)) {
+                context.report({message: "Unreachable!", node: node});
             }
-
-        };
-
-    }
+        }
+    };
 };
 ```
 
@@ -381,9 +249,9 @@ See Also:
 [no-fallthrough](https://github.com/eslint/eslint/blob/HEAD/lib/rules/no-fallthrough.js),
 [consistent-return](https://github.com/eslint/eslint/blob/HEAD/lib/rules/consistent-return.js)
 
-### Check if a function is called in every path
+### To check state of a code path
 
-This example checks whether or not the parameter `cb` is called in every path.
+This example is checking whether or not the parameter `cb` is called in every path.
 Instances of `CodePath` and `CodePathSegment` are shared to every rule.
 So a rule must not modify those instances.
 Please use a map of information instead.
@@ -403,101 +271,75 @@ function isCbCalled(info) {
     return info.cbCalled;
 }
 
-module.exports = {
-    meta: {
-        // ...
-    },
-    create(context) {
-
-        let funcInfo;
-        const funcInfoStack = [];
-        const segmentInfoMap = Object.create(null);
-
-        return {
-            // Checks `cb`.
-            onCodePathStart(codePath, node) {
-                funcInfoStack.push(funcInfo);
-
-                funcInfo = {
-                    codePath: codePath,
-                    hasCb: hasCb(node, context),
-                    currentSegments: new Set()
-                };
-            },
-
-            onCodePathEnd(codePath, node) {
-                funcInfo = funcInfoStack.pop();
-
-                // Checks `cb` was called in every paths.
-                const cbCalled = codePath.finalSegments.every(function(segment) {
-                    const info = segmentInfoMap[segment.id];
-                    return info.cbCalled;
+module.exports = function(context) {
+    var funcInfoStack = [];
+    var segmentInfoMap = Object.create(null);
+
+    return {
+        // Checks `cb`.
+        "onCodePathStart": function(codePath, node) {
+            funcInfoStack.push({
+                codePath: codePath,
+                hasCb: hasCb(node, context)
+            });
+        },
+        "onCodePathEnd": function(codePath, node) {
+            funcInfoStack.pop();
+
+            // Checks `cb` was called in every paths.
+            var cbCalled = codePath.finalSegments.every(function(segment) {
+                var info = segmentInfoMap[segment.id];
+                return info.cbCalled;
+            });
+
+            if (!cbCalled) {
+                context.report({
+                    message: "`cb` should be called in every path.",
+                    node: node
                 });
+            }
+        },
+
+        // Manages state of code paths.
+        "onCodePathSegmentStart": function(segment) {
+            var funcInfo = funcInfoStack[funcInfoStack.length - 1];
 
-                if (!cbCalled) {
-                    context.report({
-                        message: "`cb` should be called in every path.",
-                        node: node
-                    });
-                }
-            },
-
-            // Manages state of code paths and tracks traversed segments
-            onCodePathSegmentStart(segment) {
-
-                funcInfo.currentSegments.add(segment);
-
-                // Ignores if `cb` doesn't exist.
-                if (!funcInfo.hasCb) {
-                    return;
-                }
-
-                // Initialize state of this path.
-                const info = segmentInfoMap[segment.id] = {
-                    cbCalled: false
-                };
-
-                // If there are the previous paths, merges state.
-                // Checks `cb` was called in every previous path.
-                if (segment.prevSegments.length > 0) {
-                    info.cbCalled = segment.prevSegments.every(isCbCalled);
-                }
-            },
-
-            // Tracks unreachable segment traversal
-            onUnreachableCodePathSegmentStart(segment) {
-                funcInfo.currentSegments.add(segment);
-            },
-
-            // Tracks reachable segment traversal
-            onCodePathSegmentEnd(segment) {
-                funcInfo.currentSegments.delete(segment);
-            },
-
-            // Tracks unreachable segment traversal
-            onUnreachableCodePathSegmentEnd(segment) {
-                funcInfo.currentSegments.delete(segment);
-            },
-
-            // Checks reachable or not.
-            CallExpression(node) {
-
-                // Ignores if `cb` doesn't exist.
-                if (!funcInfo.hasCb) {
-                    return;
-                }
-
-                // Sets marks that `cb` was called.
-                const callee = node.callee;
-                if (callee.type === "Identifier" && callee.name === "cb") {
-                    funcInfo.currentSegments.forEach(segment => {
-                        const info = segmentInfoMap[segment.id];
-                        info.cbCalled = true;
-                    });
-                }
+            // Ignores if `cb` doesn't exist.
+            if (!funcInfo.hasCb) {
+                return;
             }
-        };
-    }
+
+            // Initialize state of this path.
+            var info = segmentInfoMap[segment.id] = {
+                cbCalled: false
+            };
+
+            // If there are the previous paths, merges state.
+            // Checks `cb` was called in every previous path.
+            if (segment.prevSegments.length > 0) {
+                info.cbCalled = segment.prevSegments.every(isCbCalled);
+            }
+        },
+
+        // Checks reachable or not.
+        "CallExpression": function(node) {
+            var funcInfo = funcInfoStack[funcInfoStack.length - 1];
+
+            // Ignores if `cb` doesn't exist.
+            if (!funcInfo.hasCb) {
+                return;
+            }
+
+            // Sets marks that `cb` was called.
+            var callee = node.callee;
+            if (callee.type === "Identifier" && callee.name === "cb") {
+                funcInfo.codePath.currentSegments.forEach(function(segment) {
+                    var info = segmentInfoMap[segment.id];
+                    info.cbCalled = true;
+                });
+            }
+        }
+    };
 };
 ```
 
diff --git a/docs/src/rules/constructor-super.md b/docs/src/rules/constructor-super.md
index 7c19df77d..c172b0a7c 100644
--- a/docs/src/rules/constructor-super.md
+++ b/docs/src/rules/constructor-super.md
@@ -1,7 +1,6 @@
 ---
 title: constructor-super
 rule_type: problem
-handled_by_typescript: true
 ---
 
 Constructors of derived classes must call `super()`.
@@ -70,3 +69,5 @@ class A extends B {
 ## When Not To Use It
 
 If you don't want to be notified about invalid/missing `super()` callings in constructors, you can safely disable this rule.
+
+It is safe to disable this rule when using TypeScript because TypeScript's compiler enforces this check (`ts(2335) & ts(2377)`).
diff --git a/docs/src/rules/getter-return.md b/docs/src/rules/getter-return.md
index 9d316303d..0c8937d14 100644
--- a/docs/src/rules/getter-return.md
+++ b/docs/src/rules/getter-return.md
@@ -1,7 +1,6 @@
 ---
 title: getter-return
 rule_type: problem
-handled_by_typescript: true
 further_reading:
 - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get
 - https://leanpub.com/understandinges6/read/#leanpub-auto-accessor-properties
diff --git a/docs/src/rules/lines-between-class-members.md b/docs/src/rules/lines-between-class-members.md
index 556275010..8daf2a2f7 100644
--- a/docs/src/rules/lines-between-class-members.md
+++ b/docs/src/rules/lines-between-class-members.md
@@ -69,19 +69,14 @@ class MyClass {
 
 ### Options
 
-This rule has two options, first option can be string or object, second option is object.
+This rule has a string option and an object option.
 
-First option can be string `"always"` or `"never"` or an object with a property named `enforce`:
+String option:
 
 * `"always"`(default) require an empty line after class members
 * `"never"` disallows an empty line after class members
-* `Object`: An object with a property named `enforce`. The enforce property should be an array of objects, each specifying the configuration for enforcing empty lines between specific pairs of class members.
-    * **enforce**: You can supply any number of configurations. If a member pair matches multiple configurations, the last matched configuration will be used. If a member pair does not match any configurations, it will be ignored. Each object should have the following properties:
-        * **blankLine**: Can be set to either `"always"` or `"never"`, indicating whether a blank line should be required or disallowed between the specified members.
-        * **prev**: Specifies the type of the preceding class member. It can be `"method"` for class methods, `"field"` for class fields, or `"*"` for any class member.
-        * **next**: Specifies the type of the following class member. It follows the same options as `prev`.
 
-Second option is an object with a property named `exceptAfterSingleLine`:
+Object option:
 
 * `"exceptAfterSingleLine": false`(default) **do not** skip checking empty lines after single-line class members
 * `"exceptAfterSingleLine": true` skip checking empty lines after single-line class members
@@ -134,146 +129,6 @@ class Foo{
 
 :::
 
-Examples of **incorrect** code for this rule with the array of configurations option:
-
-::: incorrect
-
-```js
-// disallows blank lines between methods
-/*eslint lines-between-class-members: [
-    "error",
-    {
-      enforce: [
-        { blankLine: "never", prev: "method", next: "method" }
-      ]
-    },
-]*/
-
-class MyClass {
-  constructor(height, width) {
-      this.height = height;
-      this.width = width;
-  }
-
-  fieldA = 'Field A';
-  #fieldB = 'Field B';
-
-  method1() {}
-
-  get area() {
-    return this.method1();
-  }
-
-  method2() {}
-}
-```
-
-:::
-
-::: incorrect
-
-```js
-// requires blank lines around fields, disallows blank lines between methods
-/*eslint lines-between-class-members: [
-    "error",
-    {
-      enforce: [
-        { blankLine: "always", prev: "*", next: "field" },
-        { blankLine: "always", prev: "field", next: "*" },
-        { blankLine: "never", prev: "method", next: "method" }
-      ]
-    },
-]*/
-
-class MyClass {
-  constructor(height, width) {
-      this.height = height;
-      this.width = width;
-  }
-  fieldA = 'Field A';
-  #fieldB = 'Field B';
-  method1() {}
-
-  get area() {
-    return this.method1();
-  }
-
-  method2() {}
-}
-```
-
-:::
-
-Examples of **correct** code for this rule with the array of configurations option:
-
-::: correct
-
-```js
-// disallows blank lines between methods
-/*eslint lines-between-class-members: [
-    "error",
-    {
-      enforce: [
-        { blankLine: "never", prev: "method", next: "method" }
-      ]
-    },
-]*/
-
-class MyClass {
-  constructor(height, width) {
-      this.height = height;
-      this.width = width;
-  }
-
-  fieldA = 'Field A';
-
-  #fieldB = 'Field B';
-
-  method1() {}
-  get area() {
-    return this.method1();
-  }
-  method2() {}
-}
-```
-
-:::
-
-::: correct
-
-```js
-// requires blank lines around fields, disallows blank lines between methods
-/*eslint lines-between-class-members: [
-    "error",
-    {
-      enforce: [
-        { blankLine: "always", prev: "*", next: "field" },
-        { blankLine: "always", prev: "field", next: "*" },
-        { blankLine: "never", prev: "method", next: "method" }
-      ]
-    },
-]*/
-
-class MyClass {
-  constructor(height, width) {
-      this.height = height;
-      this.width = width;
-  }
-
-  fieldA = 'Field A';
-
-  #fieldB = 'Field B';
-
-  method1() {}
-  get area() {
-    return this.method1();
-  }
-  method2() {}
-}
-```
-
-:::
-
 Examples of **correct** code for this rule with the object option:
 
 ::: correct
@@ -293,40 +148,6 @@ class Foo{
 
 :::
 
-::: correct
-
-```js
-/*eslint lines-between-class-members: [
-    "error",
-    {
-      enforce: [
-        { blankLine: "always", prev: "*", next: "method" },
-        { blankLine: "always", prev: "method", next: "*" },
-        { blankLine: "always", prev: "field", next: "field" }
-      ]
-    },
-    { exceptAfterSingleLine: true }
-]*/
-
-class MyClass {
-  constructor(height, width) {
-      this.height = height;
-      this.width = width;
-  }
-
-  fieldA = 'Field A';
-  #fieldB = 'Field B';
-  method1() {}
-  get area() {
-    return this.method1();
-  }
-
-  method2() {}
-}
-```
-
-:::
-
 ## When Not To Use It
 
 If you don't want to enforce empty lines between class members, you can disable this rule.
diff --git a/docs/src/rules/no-const-assign.md b/docs/src/rules/no-const-assign.md
index ca62132a7..f9f0ed172 100644
--- a/docs/src/rules/no-const-assign.md
+++ b/docs/src/rules/no-const-assign.md
@@ -1,7 +1,6 @@
 ---
 title: no-const-assign
 rule_type: problem
-handled_by_typescript: true
 ---
 
 
diff --git a/docs/src/rules/no-dupe-args.md b/docs/src/rules/no-dupe-args.md
index 3cb9133c8..79f791c46 100644
--- a/docs/src/rules/no-dupe-args.md
+++ b/docs/src/rules/no-dupe-args.md
@@ -1,7 +1,6 @@
 ---
 title: no-dupe-args
 rule_type: problem
-handled_by_typescript: true
 ---
 
 
diff --git a/docs/src/rules/no-dupe-class-members.md b/docs/src/rules/no-dupe-class-members.md
index 216f3c9fe..d50a7fe74 100644
--- a/docs/src/rules/no-dupe-class-members.md
+++ b/docs/src/rules/no-dupe-class-members.md
@@ -1,7 +1,6 @@
 ---
 title: no-dupe-class-members
 rule_type: problem
-handled_by_typescript: true
 ---
 
 
@@ -102,3 +101,5 @@ class Foo {
 This rule should not be used in ES3/5 environments.
 
 In ES2015 (ES6) or later, if you don't want to be notified about duplicate names in class members, you can safely disable this rule.
+
+It is safe to disable this rule when using TypeScript because TypeScript's compiler enforces this check (`ts(2300) & ts(2393)`).
diff --git a/docs/src/rules/no-dupe-keys.md b/docs/src/rules/no-dupe-keys.md
index 1527bf8f1..75fc9491f 100644
--- a/docs/src/rules/no-dupe-keys.md
+++ b/docs/src/rules/no-dupe-keys.md
@@ -1,7 +1,6 @@
 ---
 title: no-dupe-keys
 rule_type: problem
-handled_by_typescript: true
 ---
 
 
diff --git a/docs/src/rules/no-func-assign.md b/docs/src/rules/no-func-assign.md
index a0f146203..ffbcb46c6 100644
--- a/docs/src/rules/no-func-assign.md
+++ b/docs/src/rules/no-func-assign.md
@@ -1,7 +1,6 @@
 ---
 title: no-func-assign
 rule_type: problem
-handled_by_typescript: true
 ---
 
 
diff --git a/docs/src/rules/no-import-assign.md b/docs/src/rules/no-import-assign.md
index b0a7432bb..ca4b912de 100644
--- a/docs/src/rules/no-import-assign.md
+++ b/docs/src/rules/no-import-assign.md
@@ -1,8 +1,6 @@
 ---
 title: no-import-assign
 rule_type: problem
-handled_by_typescript: true
-extra_typescript_info: Note that the compiler will not catch the `Object.assign()` case. Thus, if you use `Object.assign()` in your codebase, this rule will still provide some value.
 ---
 
 
diff --git a/docs/src/rules/no-invalid-this.md b/docs/src/rules/no-invalid-this.md
index 9e4a2aedf..f3aa6ed76 100644
--- a/docs/src/rules/no-invalid-this.md
+++ b/docs/src/rules/no-invalid-this.md
@@ -1,8 +1,6 @@
 ---
 title: no-invalid-this
 rule_type: suggestion
-handled_by_typescript: true
-extra_typescript_info: Note that, technically, TypeScript will only catch this if you have the `strict` or `noImplicitThis` flags enabled. These are enabled in most TypeScript projects, since they are considered to be best practice.
 ---
 
 
diff --git a/docs/src/rules/no-new-symbol.md b/docs/src/rules/no-new-symbol.md
index d557811f3..44c34a4ee 100644
--- a/docs/src/rules/no-new-symbol.md
+++ b/docs/src/rules/no-new-symbol.md
@@ -1,7 +1,6 @@
 ---
 title: no-new-symbol
 rule_type: problem
-handled_by_typescript: true
 further_reading:
 - https://www.ecma-international.org/ecma-262/6.0/#sec-symbol-objects
 ---
diff --git a/docs/src/rules/no-obj-calls.md b/docs/src/rules/no-obj-calls.md
index 2fde92e5c..8d72e4ce2 100644
--- a/docs/src/rules/no-obj-calls.md
+++ b/docs/src/rules/no-obj-calls.md
@@ -1,7 +1,6 @@
 ---
 title: no-obj-calls
 rule_type: problem
-handled_by_typescript: true
 further_reading:
 - https://es5.github.io/#x15.8
 ---
diff --git a/docs/src/rules/no-promise-executor-return.md b/docs/src/rules/no-promise-executor-return.md
index f163d9ebf..d82e44734 100644
--- a/docs/src/rules/no-promise-executor-return.md
+++ b/docs/src/rules/no-promise-executor-return.md
@@ -38,7 +38,6 @@ Examples of **incorrect** code for this rule:
 
 ```js
 /*eslint no-promise-executor-return: "error"*/
-/*eslint-env es6*/
 
 new Promise((resolve, reject) => {
     if (someCondition) {
@@ -76,7 +75,6 @@ Examples of **correct** code for this rule:
 
 ```js
 /*eslint no-promise-executor-return: "error"*/
-/*eslint-env es6*/
 
 // Turn return inline into two lines
 new Promise((resolve, reject) => {
@@ -125,7 +123,6 @@ Examples of **correct** code for this rule with the `{ "allowVoid": true }` opti
 
 ```js
 /*eslint no-promise-executor-return: ["error", { allowVoid: true }]*/
-/*eslint-env es6*/
 
 new Promise((resolve, reject) => {
     if (someCondition) {
diff --git a/docs/src/rules/no-redeclare.md b/docs/src/rules/no-redeclare.md
index 009ba889f..e66f0570f 100644
--- a/docs/src/rules/no-redeclare.md
+++ b/docs/src/rules/no-redeclare.md
@@ -1,8 +1,6 @@
 ---
 title: no-redeclare
 rule_type: suggestion
-handled_by_typescript: true
-extra_typescript_info: Note that while TypeScript will catch `let` redeclares and `const` redeclares, it will not catch `var` redeclares. Thus, if you use the legacy `var` keyword in your TypeScript codebase, this rule will still provide some value.
 related_rules:
 - no-shadow
 ---
diff --git a/docs/src/rules/no-setter-return.md b/docs/src/rules/no-setter-return.md
index 50353c754..ceb4558c1 100644
--- a/docs/src/rules/no-setter-return.md
+++ b/docs/src/rules/no-setter-return.md
@@ -1,7 +1,6 @@
 ---
 title: no-setter-return
 rule_type: problem
-handled_by_typescript: true
 related_rules:
 - getter-return
 further_reading:
diff --git a/docs/src/rules/no-this-before-super.md b/docs/src/rules/no-this-before-super.md
index c1a654796..f1425b5ed 100644
--- a/docs/src/rules/no-this-before-super.md
+++ b/docs/src/rules/no-this-before-super.md
@@ -1,7 +1,6 @@
 ---
 title: no-this-before-super
 rule_type: problem
-handled_by_typescript: true
 ---
 
 
diff --git a/docs/src/rules/no-undef.md b/docs/src/rules/no-undef.md
index 72ea516f9..0bc7a2827 100644
--- a/docs/src/rules/no-undef.md
+++ b/docs/src/rules/no-undef.md
@@ -1,7 +1,6 @@
 ---
 title: no-undef
 rule_type: problem
-handled_by_typescript: true
 related_rules:
 - no-global-assign
 - no-redeclare
diff --git a/docs/src/rules/no-unreachable.md b/docs/src/rules/no-unreachable.md
index 15f77f817..4f762084b 100644
--- a/docs/src/rules/no-unreachable.md
+++ b/docs/src/rules/no-unreachable.md
@@ -1,7 +1,6 @@
 ---
 title: no-unreachable
 rule_type: problem
-handled_by_typescript: true
 ---
 
 
diff --git a/docs/src/rules/no-unsafe-negation.md b/docs/src/rules/no-unsafe-negation.md
index f3b495223..522e4ab4d 100644
--- a/docs/src/rules/no-unsafe-negation.md
+++ b/docs/src/rules/no-unsafe-negation.md
@@ -1,7 +1,6 @@
 ---
 title: no-unsafe-negation
 rule_type: problem
-handled_by_typescript: true
 ---
 
 
diff --git a/docs/src/use/command-line-interface.md b/docs/src/use/command-line-interface.md
index d88e35cfa..da4faf70e 100644
--- a/docs/src/use/command-line-interface.md
+++ b/docs/src/use/command-line-interface.md
@@ -110,6 +110,7 @@ Miscellaneous:
   --env-info                      Output execution environment information - default: false
   --no-error-on-unmatched-pattern  Prevent errors when pattern is unmatched
   --exit-on-fatal-error           Exit with exit code 2 in case of fatal error - default: false
+  --no-warn-ignored               Suppress warnings when the file list includes ignored files. *Flat Config Mode Only*
   --debug                         Output debugging information
   -h, --help                      Show help
   -v, --version                   Output the version number
@@ -703,6 +704,18 @@ This option causes ESLint to exit with exit code 2 if one or more fatal parsing
 npx eslint --exit-on-fatal-error file.js
 ```
 
+#### `--no-warn-ignored`
+
+**Flat Config Mode Only.** This option suppresses both `File ignored by default` and `File ignored because of a matching ignore pattern` warnings when an ignored filename is passed explicitly. It is useful when paired with `--max-warnings 0` as it will prevent exit code 1 due to the aforementioned warning.
+
+* **Argument Type**: No argument.
+
+##### `--no-warn-ignored` example
+
+```shell
+npx eslint --no-warn-ignored --max-warnings 0 ignored-file.js
+```
+
 #### `--debug`
 
 This option outputs debugging information to the console. Add this flag to an ESLint command line invocation in order to get extra debugging information while the command runs.
diff --git a/docs/src/use/configure/ignore.md b/docs/src/use/configure/ignore.md
index ffc23428e..16f1bfbcd 100644
--- a/docs/src/use/configure/ignore.md
+++ b/docs/src/use/configure/ignore.md
@@ -149,7 +149,7 @@ You'll see this warning:
 
 ```text
 foo.js
-  0:0  warning  File ignored because of a matching ignore pattern. Use "--no-ignore" to override.
+  0:0  warning  File ignored because of a matching ignore pattern. Use "--no-ignore" to disable file ignore settings or use "--no-warn-ignored" to suppress this warning.
 
 âœ– 1 problem (0 errors, 1 warning)
 ```
diff --git a/docs/src/use/formatters/html-formatter-example.html b/docs/src/use/formatters/html-formatter-example.html
index f1b577386..16db7f6d6 100644
--- a/docs/src/use/formatters/html-formatter-example.html
+++ b/docs/src/use/formatters/html-formatter-example.html
@@ -118,7 +118,7 @@
         <div id="overview" class="bg-2">
             <h1>ESLint Report</h1>
             <div>
-                <span>9 problems (5 errors, 4 warnings)</span> - Generated on Fri Sep 08 2023 16:22:14 GMT-0400 (Eastern Daylight Time)
+                <span>9 problems (5 errors, 4 warnings)</span> - Generated on Fri Aug 25 2023 16:01:24 GMT-0400 (Eastern Daylight Time)
             </div>
         </div>
         <table>
diff --git a/eslint.config.js b/eslint.config.js
index 40ebe8c08..214be713d 100644
--- a/eslint.config.js
+++ b/eslint.config.js
@@ -226,6 +226,7 @@ module.exports = [
         files: [INTERNAL_FILES.RULE_TESTER_PATTERN],
         rules: {
             "n/no-restricted-require": ["error", [
+                ...createInternalFilesPatterns(INTERNAL_FILES.RULE_TESTER_PATTERN),
                 resolveAbsolutePath("lib/cli-engine/index.js")
             ]]
         }
diff --git a/karma.conf.js b/karma.conf.js
new file mode 100644
index 000000000..606d13f88
--- /dev/null
+++ b/karma.conf.js
@@ -0,0 +1,125 @@
+"use strict";
+const os = require("os");
+const NodePolyfillPlugin = require("node-polyfill-webpack-plugin");
+
+if (os.platform === "linux" && os.arch() === "arm64") {
+
+    // For arm64 architecture, install chromium-browser using "apt-get install chromium-browser"
+    process.env.CHROME_BIN = "/usr/bin/chromium-browser";
+} else {
+    process.env.CHROME_BIN = require("puppeteer").executablePath();
+}
+
+module.exports = function(config) {
+    config.set({
+
+        // base path that will be used to resolve all patterns (eg. files, exclude)
+        basePath: "",
+
+        // next three sections allow console.log to work
+        client: {
+            captureConsole: true
+        },
+
+        browserConsoleLogOptions: {
+            terminal: true,
+            level: "log"
+        },
+
+        /*
+         * frameworks to use
+         * available frameworks: https://npmjs.org/browse/keyword/karma-adapter
+         */
+        frameworks: ["mocha", "webpack"],
+
+
+        // list of files / patterns to load in the browser
+        files: [
+            "tests/lib/linter/linter.js"
+        ],
+
+
+        // list of files to exclude
+        exclude: [
+        ],
+
+
+        /*
+         * preprocess matching files before serving them to the browser
+         * available preprocessors: https://npmjs.org/browse/keyword/karma-preprocessor
+         */
+        preprocessors: {
+            "tests/lib/linter/linter.js": ["webpack"]
+        },
+        webpack: {
+            mode: "none",
+            plugins: [
+                new NodePolyfillPlugin()
+            ],
+            resolve: {
+                alias: {
+                    "../../../lib/linter$": "../../../build/eslint.js"
+                }
+            },
+            stats: "errors-only"
+        },
+        webpackMiddleware: {
+            logLevel: "error"
+        },
+
+
+        /*
+         * test results reporter to use
+         * possible values: "dots", "progress"
+         * available reporters: https://npmjs.org/browse/keyword/karma-reporter
+         */
+        reporters: ["mocha"],
+
+        mochaReporter: {
+            output: "minimal"
+        },
+
+        // web server port
+        port: 9876,
+
+
+        // enable / disable colors in the output (reporters and logs)
+        colors: true,
+
+
+        /*
+         * level of logging
+         * possible values: config.LOG_DISABLE || config.LOG_ERROR || config.LOG_WARN || config.LOG_INFO || config.LOG_DEBUG
+         */
+        logLevel: config.LOG_INFO,
+
+
+        // enable / disable watching file and executing tests whenever any file changes
+        autoWatch: false,
+
+
+        /*
+         * start these browsers
+         * available browser launchers: https://npmjs.org/browse/keyword/karma-launcher
+         */
+        browsers: ["HeadlessChrome"],
+        customLaunchers: {
+            HeadlessChrome: {
+                base: "ChromeHeadless",
+                flags: ["--no-sandbox"]
+            }
+        },
+
+        /*
+         * Continuous Integration mode
+         * if true, Karma captures browsers, runs the tests and exits
+         */
+        singleRun: true,
+
+        /*
+         * Concurrency level
+         * how many browser should be started simultaneous
+         */
+        concurrency: Infinity
+    });
+};
diff --git a/lib/cli.js b/lib/cli.js
index a14930e9b..807d28a0d 100644
--- a/lib/cli.js
+++ b/lib/cli.js
@@ -91,7 +91,8 @@ async function translateOptions({
     reportUnusedDisableDirectives,
     resolvePluginsRelativeTo,
     rule,
-    rulesdir
+    rulesdir,
+    warnIgnored
 }, configType) {
 
     let overrideConfig, overrideConfigFile;
@@ -182,6 +183,7 @@ async function translateOptions({
 
     if (configType === "flat") {
         options.ignorePatterns = ignorePattern;
+        options.warnIgnored = warnIgnored;
     } else {
         options.resolvePluginsRelativeTo = resolvePluginsRelativeTo;
         options.rulePaths = rulesdir;
@@ -385,7 +387,9 @@ const cli = {
         if (useStdin) {
             results = await engine.lintText(text, {
                 filePath: options.stdinFilename,
-                warnIgnored: true
+
+                // flatConfig respects CLI flag and constructor warnIgnored, eslintrc forces true for backwards compatibility
+                warnIgnored: usingFlatConfig ? void 0 : true
             });
         } else {
             results = await engine.lintFiles(files);
diff --git a/lib/config/rule-validator.js b/lib/config/rule-validator.js
index eee5b40bd..0b5858fb3 100644
--- a/lib/config/rule-validator.js
+++ b/lib/config/rule-validator.js
@@ -9,8 +9,7 @@
 // Requirements
 //-----------------------------------------------------------------------------
 
-const ajvImport = require("../shared/ajv");
-const ajv = ajvImport();
+const ajv = require("../shared/ajv")();
 const {
     parseRuleId,
     getRuleFromConfig,
diff --git a/lib/eslint/eslint-helpers.js b/lib/eslint/eslint-helpers.js
index e25b10e8b..72828363c 100644
--- a/lib/eslint/eslint-helpers.js
+++ b/lib/eslint/eslint-helpers.js
@@ -594,9 +594,9 @@ function createIgnoreResult(filePath, baseDir) {
     const isInNodeModules = baseDir && path.dirname(path.relative(baseDir, filePath)).split(path.sep).includes("node_modules");
 
     if (isInNodeModules) {
-        message = "File ignored by default because it is located under the node_modules directory. Use ignore pattern \"!**/node_modules/\" to override.";
+        message = "File ignored by default because it is located under the node_modules directory. Use ignore pattern \"!**/node_modules/\" to disable file ignore settings or use \"--no-warn-ignored\" to suppress this warning.";
     } else {
-        message = "File ignored because of a matching ignore pattern. Use \"--no-ignore\" to override.";
+        message = "File ignored because of a matching ignore pattern. Use \"--no-ignore\" to disable file ignore settings or use \"--no-warn-ignored\" to suppress this warning.";
     }
 
     return {
@@ -676,6 +676,7 @@ function processOptions({
     overrideConfigFile = null,
     plugins = {},
     reportUnusedDisableDirectives = null, // â† should be null by default because if it's a string then it overrides the 'reportUnusedDisableDirectives' setting in config files. And we cannot use `overrideConfig.reportUnusedDisableDirectives` instead because we cannot configure the `error` severity with that.
+    warnIgnored = true,
     ...unknownOptions
 }) {
     const errors = [];
@@ -781,6 +782,9 @@ function processOptions({
     ) {
         errors.push("'reportUnusedDisableDirectives' must be any of \"error\", \"warn\", \"off\", and null.");
     }
+    if (typeof warnIgnored !== "boolean") {
+        errors.push("'warnIgnored' must be a boolean.");
+    }
     if (errors.length > 0) {
         throw new ESLintInvalidOptionsError(errors);
     }
@@ -802,7 +806,8 @@ function processOptions({
         globInputPaths,
         ignore,
         ignorePatterns,
-        reportUnusedDisableDirectives
+        reportUnusedDisableDirectives,
+        warnIgnored
     };
 }
 
diff --git a/lib/eslint/flat-eslint.js b/lib/eslint/flat-eslint.js
index 4ef386113..306c80de1 100644
--- a/lib/eslint/flat-eslint.js
+++ b/lib/eslint/flat-eslint.js
@@ -84,6 +84,7 @@ const LintResultCache = require("../cli-engine/lint-result-cache");
  *      when a string.
  * @property {Record<string,Plugin>} [plugins] An array of plugin implementations.
  * @property {"error" | "warn" | "off"} [reportUnusedDisableDirectives] the severity to report unused eslint-disable directives.
+ * @property {boolean} warnIgnored Show warnings when the file list includes ignored files
  */
 
 //------------------------------------------------------------------------------
@@ -749,7 +750,8 @@ class FlatESLint {
             fixTypes,
             reportUnusedDisableDirectives,
             globInputPaths,
-            errorOnUnmatchedPattern
+            errorOnUnmatchedPattern,
+            warnIgnored
         } = eslintOptions;
         const startTime = Date.now();
         const fixTypesSet = fixTypes ? new Set(fixTypes) : null;
@@ -795,7 +797,11 @@ class FlatESLint {
                  * pattern, then notify the user.
                  */
                 if (ignored) {
-                    return createIgnoreResult(filePath, cwd);
+                    if (warnIgnored) {
+                        return createIgnoreResult(filePath, cwd);
+                    }
+
+                    return void 0;
                 }
 
                 const config = configs.getConfig(filePath);
@@ -908,7 +914,7 @@ class FlatESLint {
 
         const {
             filePath,
-            warnIgnored = false,
+            warnIgnored,
             ...unknownOptions
         } = options || {};
 
@@ -922,7 +928,7 @@ class FlatESLint {
             throw new Error("'options.filePath' must be a non-empty string or undefined");
         }
 
-        if (typeof warnIgnored !== "boolean") {
+        if (typeof warnIgnored !== "boolean" && typeof warnIgnored !== "undefined") {
             throw new Error("'options.warnIgnored' must be a boolean or undefined");
         }
 
@@ -937,7 +943,8 @@ class FlatESLint {
             allowInlineConfig,
             cwd,
             fix,
-            reportUnusedDisableDirectives
+            reportUnusedDisableDirectives,
+            warnIgnored: constructorWarnIgnored
         } = eslintOptions;
         const results = [];
         const startTime = Date.now();
@@ -945,7 +952,9 @@ class FlatESLint {
 
         // Clear the last used config arrays.
         if (resolvedFilename && await this.isPathIgnored(resolvedFilename)) {
-            if (warnIgnored) {
+            const shouldWarnIgnored = typeof warnIgnored === "boolean" ? warnIgnored : constructorWarnIgnored;
+
+            if (shouldWarnIgnored) {
                 results.push(createIgnoreResult(resolvedFilename, cwd));
             }
         } else {
diff --git a/lib/linter/code-path-analysis/code-path-analyzer.js b/lib/linter/code-path-analysis/code-path-analyzer.js
index b60e55c16..2dcc27348 100644
--- a/lib/linter/code-path-analysis/code-path-analyzer.js
+++ b/lib/linter/code-path-analysis/code-path-analyzer.js
@@ -192,18 +192,15 @@ function forwardCurrentToHead(analyzer, node) {
         headSegment = headSegments[i];
 
         if (currentSegment !== headSegment && currentSegment) {
+            debug.dump(`onCodePathSegmentEnd ${currentSegment.id}`);
 
-            const eventName = currentSegment.reachable
-                ? "onCodePathSegmentEnd"
-                : "onUnreachableCodePathSegmentEnd";
-
-            debug.dump(`${eventName} ${currentSegment.id}`);
-
-            analyzer.emitter.emit(
-                eventName,
-                currentSegment,
-                node
-            );
+            if (currentSegment.reachable) {
+                analyzer.emitter.emit(
+                    "onCodePathSegmentEnd",
+                    currentSegment,
+                    node
+                );
+            }
         }
     }
 
@@ -216,19 +213,16 @@ function forwardCurrentToHead(analyzer, node) {
         headSegment = headSegments[i];
 
         if (currentSegment !== headSegment && headSegment) {
-
-            const eventName = headSegment.reachable
-                ? "onCodePathSegmentStart"
-                : "onUnreachableCodePathSegmentStart";
-
-            debug.dump(`${eventName} ${headSegment.id}`);
+            debug.dump(`onCodePathSegmentStart ${headSegment.id}`);
 
             CodePathSegment.markUsed(headSegment);
-            analyzer.emitter.emit(
-                eventName,
-                headSegment,
-                node
-            );
+            if (headSegment.reachable) {
+                analyzer.emitter.emit(
+                    "onCodePathSegmentStart",
+                    headSegment,
+                    node
+                );
+            }
         }
     }
 
@@ -247,17 +241,15 @@ function leaveFromCurrentSegment(analyzer, node) {
 
     for (let i = 0; i < currentSegments.length; ++i) {
         const currentSegment = currentSegments[i];
-        const eventName = currentSegment.reachable
-            ? "onCodePathSegmentEnd"
-            : "onUnreachableCodePathSegmentEnd";
-
-        debug.dump(`${eventName} ${currentSegment.id}`);
 
-        analyzer.emitter.emit(
-            eventName,
-            currentSegment,
-            node
-        );
+        debug.dump(`onCodePathSegmentEnd ${currentSegment.id}`);
+        if (currentSegment.reachable) {
+            analyzer.emitter.emit(
+                "onCodePathSegmentEnd",
+                currentSegment,
+                node
+            );
+        }
     }
 
     state.currentSegments = [];
diff --git a/lib/linter/code-path-analysis/code-path.js b/lib/linter/code-path-analysis/code-path.js
index f6a88a00a..a028ca694 100644
--- a/lib/linter/code-path-analysis/code-path.js
+++ b/lib/linter/code-path-analysis/code-path.js
@@ -117,7 +117,6 @@ class CodePath {
     /**
      * Current code path segments.
      * @type {CodePathSegment[]}
-     * @deprecated
      */
     get currentSegments() {
         return this.internal.currentSegments;
diff --git a/lib/linter/linter.js b/lib/linter/linter.js
index 48b2bdbe5..233cbed5b 100644
--- a/lib/linter/linter.js
+++ b/lib/linter/linter.js
@@ -898,7 +898,6 @@ const DEPRECATED_SOURCECODE_PASSTHROUGHS = {
     getTokensBetween: "getTokensBetween"
 };
 
-
 const BASE_TRAVERSAL_CONTEXT = Object.freeze(
     Object.keys(DEPRECATED_SOURCECODE_PASSTHROUGHS).reduce(
         (contextInfo, methodName) =>
diff --git a/lib/options.js b/lib/options.js
index 2bc4018af..ae9a5d555 100644
--- a/lib/options.js
+++ b/lib/options.js
@@ -55,6 +55,7 @@ const optionator = require("optionator");
  * @property {string} [stdinFilename] Specify filename to process STDIN as
  * @property {boolean} quiet Report errors only
  * @property {boolean} [version] Output the version number
+ * @property {boolean} warnIgnored Show warnings when the file list includes ignored files
  * @property {string[]} _ Positional filenames or patterns
  */
 
@@ -139,6 +140,17 @@ module.exports = function(usingFlatConfig) {
         };
     }
 
+    let warnIgnoredFlag;
+
+    if (usingFlatConfig) {
+        warnIgnoredFlag = {
+            option: "warn-ignored",
+            type: "Boolean",
+            default: "true",
+            description: "Suppress warnings when the file list includes ignored files"
+        };
+    }
+
     return optionator({
         prepend: "eslint [options] file.js [file.js] [dir]",
         defaults: {
@@ -349,6 +361,7 @@ module.exports = function(usingFlatConfig) {
                 default: "false",
                 description: "Exit with exit code 2 in case of fatal error"
             },
+            warnIgnoredFlag,
             {
                 option: "debug",
                 type: "Boolean",
diff --git a/lib/rule-tester/flat-rule-tester.js b/lib/rule-tester/flat-rule-tester.js
index d5f5981e6..5a93be1cc 100644
--- a/lib/rule-tester/flat-rule-tester.js
+++ b/lib/rule-tester/flat-rule-tester.js
@@ -16,9 +16,7 @@ const
     equal = require("fast-deep-equal"),
     Traverser = require("../shared/traverser"),
     { getRuleOptionsSchema } = require("../config/flat-config-helpers"),
-    { Linter, SourceCodeFixer, interpolate } = require("../linter"),
-    CodePath = require("../linter/code-path-analysis/code-path");
-
+    { Linter, SourceCodeFixer, interpolate } = require("../linter");
 const { FlatConfigArray } = require("../config/flat-config-array");
 const { defaultConfig } = require("../config/default-config");
 
@@ -276,21 +274,6 @@ function getCommentsDeprecation() {
     );
 }
 
-/**
- * Emit a deprecation warning if rule uses CodePath#currentSegments.
- * @param {string} ruleName Name of the rule.
- * @returns {void}
- */
-function emitCodePathCurrentSegmentsWarning(ruleName) {
-    if (!emitCodePathCurrentSegmentsWarning[`warned-${ruleName}`]) {
-        emitCodePathCurrentSegmentsWarning[`warned-${ruleName}`] = true;
-        process.emitWarning(
-            `"${ruleName}" rule uses CodePath#currentSegments and will stop working in ESLint v9. Please read the documentation for how to update your code: https://eslint.org/docs/latest/extend/code-path-analysis#usage-examples`,
-            "DeprecationWarning"
-        );
-    }
-}
-
 //------------------------------------------------------------------------------
 // Public Interface
 //------------------------------------------------------------------------------
@@ -681,7 +664,6 @@ class FlatRuleTester {
 
             // Verify the code.
             const { getComments } = SourceCode.prototype;
-            const originalCurrentSegments = Object.getOwnPropertyDescriptor(CodePath.prototype, "currentSegments");
             let messages;
 
             // check for validation errors
@@ -695,20 +677,11 @@ class FlatRuleTester {
 
             try {
                 SourceCode.prototype.getComments = getCommentsDeprecation;
-                Object.defineProperty(CodePath.prototype, "currentSegments", {
-                    get() {
-                        emitCodePathCurrentSegmentsWarning(ruleName);
-                        return originalCurrentSegments.get.call(this);
-                    }
-                });
-
                 messages = linter.verify(code, configs, filename);
             } finally {
                 SourceCode.prototype.getComments = getComments;
-                Object.defineProperty(CodePath.prototype, "currentSegments", originalCurrentSegments);
             }
 
-
             const fatalErrorMessage = messages.find(m => m.fatal);
 
             assert(!fatalErrorMessage, `A fatal parsing error occurred: ${fatalErrorMessage && fatalErrorMessage.message}`);
diff --git a/lib/rule-tester/rule-tester.js b/lib/rule-tester/rule-tester.js
index 82d79790a..030a98686 100644
--- a/lib/rule-tester/rule-tester.js
+++ b/lib/rule-tester/rule-tester.js
@@ -48,8 +48,7 @@ const
     equal = require("fast-deep-equal"),
     Traverser = require("../../lib/shared/traverser"),
     { getRuleOptionsSchema, validate } = require("../shared/config-validator"),
-    { Linter, SourceCodeFixer, interpolate } = require("../linter"),
-    CodePath = require("../linter/code-path-analysis/code-path");
+    { Linter, SourceCodeFixer, interpolate } = require("../linter");
 
 const ajv = require("../shared/ajv")({ strictDefaults: true });
 
@@ -165,30 +164,6 @@ const friendlySuggestionObjectParameterList = `[${[...suggestionObjectParameters
 
 const hasOwnProperty = Function.call.bind(Object.hasOwnProperty);
 
-const DEPRECATED_SOURCECODE_PASSTHROUGHS = {
-    getSource: "getText",
-    getSourceLines: "getLines",
-    getAllComments: "getAllComments",
-    getNodeByRangeIndex: "getNodeByRangeIndex",
-
-    // getComments: "getComments", -- already handled by a separate error
-    getCommentsBefore: "getCommentsBefore",
-    getCommentsAfter: "getCommentsAfter",
-    getCommentsInside: "getCommentsInside",
-    getJSDocComment: "getJSDocComment",
-    getFirstToken: "getFirstToken",
-    getFirstTokens: "getFirstTokens",
-    getLastToken: "getLastToken",
-    getLastTokens: "getLastTokens",
-    getTokenAfter: "getTokenAfter",
-    getTokenBefore: "getTokenBefore",
-    getTokenByRangeStart: "getTokenByRangeStart",
-    getTokens: "getTokens",
-    getTokensAfter: "getTokensAfter",
-    getTokensBefore: "getTokensBefore",
-    getTokensBetween: "getTokensBetween"
-};
-
 /**
  * Clones a given value deeply.
  * Note: This ignores `parent` property.
@@ -360,37 +335,6 @@ function emitMissingSchemaWarning(ruleName) {
     }
 }
 
-/**
- * Emit a deprecation warning if a rule uses a deprecated `context` method.
- * @param {string} ruleName Name of the rule.
- * @param {string} methodName The name of the method on `context` that was used.
- * @returns {void}
- */
-function emitDeprecatedContextMethodWarning(ruleName, methodName) {
-    if (!emitDeprecatedContextMethodWarning[`warned-${ruleName}-${methodName}`]) {
-        emitDeprecatedContextMethodWarning[`warned-${ruleName}-${methodName}`] = true;
-        process.emitWarning(
-            `"${ruleName}" rule is using \`context.${methodName}()\`, which is deprecated and will be removed in ESLint v9. Please use \`sourceCode.${DEPRECATED_SOURCECODE_PASSTHROUGHS[methodName]}()\` instead.`,
-            "DeprecationWarning"
-        );
-    }
-}
-
-/**
- * Emit a deprecation warning if rule uses CodePath#currentSegments.
- * @param {string} ruleName Name of the rule.
- * @returns {void}
- */
-function emitCodePathCurrentSegmentsWarning(ruleName) {
-    if (!emitCodePathCurrentSegmentsWarning[`warned-${ruleName}`]) {
-        emitCodePathCurrentSegmentsWarning[`warned-${ruleName}`] = true;
-        process.emitWarning(
-            `"${ruleName}" rule uses CodePath#currentSegments and will stop working in ESLint v9. Please read the documentation for how to update your code: https://eslint.org/docs/latest/extend/code-path-analysis#usage-examples`,
-            "DeprecationWarning"
-        );
-    }
-}
-
 //------------------------------------------------------------------------------
 // Public Interface
 //------------------------------------------------------------------------------
@@ -622,27 +566,7 @@ class RuleTester {
                 freezeDeeply(context.settings);
                 freezeDeeply(context.parserOptions);
 
-                const newContext = Object.freeze(
-                    Object.create(
-                        context,
-                        Object.fromEntries(Object.keys(DEPRECATED_SOURCECODE_PASSTHROUGHS).map(methodName => [
-                            methodName,
-                            {
-                                value(...args) {
-
-                                    // emit deprecation warning
-                                    emitDeprecatedContextMethodWarning(ruleName, methodName);
-
-                                    // call the original method
-                                    return context[methodName].call(this, ...args);
-                                },
-                                enumerable: true
-                            }
-                        ]))
-                    )
-                );
-
-                return (typeof rule === "function" ? rule : rule.create)(newContext);
+                return (typeof rule === "function" ? rule : rule.create)(context);
             }
         }));
 
@@ -762,22 +686,13 @@ class RuleTester {
 
             // Verify the code.
             const { getComments } = SourceCode.prototype;
-            const originalCurrentSegments = Object.getOwnPropertyDescriptor(CodePath.prototype, "currentSegments");
             let messages;
 
             try {
                 SourceCode.prototype.getComments = getCommentsDeprecation;
-                Object.defineProperty(CodePath.prototype, "currentSegments", {
-                    get() {
-                        emitCodePathCurrentSegmentsWarning(ruleName);
-                        return originalCurrentSegments.get.call(this);
-                    }
-                });
-
                 messages = linter.verify(code, config, filename);
             } finally {
                 SourceCode.prototype.getComments = getComments;
-                Object.defineProperty(CodePath.prototype, "currentSegments", originalCurrentSegments);
             }
 
             const fatalErrorMessage = messages.find(m => m.fatal);
diff --git a/lib/rules/array-callback-return.js b/lib/rules/array-callback-return.js
index 24a33d16c..05cd4ede9 100644
--- a/lib/rules/array-callback-return.js
+++ b/lib/rules/array-callback-return.js
@@ -18,6 +18,15 @@ const astUtils = require("./utils/ast-utils");
 const TARGET_NODE_TYPE = /^(?:Arrow)?FunctionExpression$/u;
 const TARGET_METHODS = /^(?:every|filter|find(?:Last)?(?:Index)?|flatMap|forEach|map|reduce(?:Right)?|some|sort|toSorted)$/u;
 
+/**
+ * Checks a given code path segment is reachable.
+ * @param {CodePathSegment} segment A segment to check.
+ * @returns {boolean} `true` if the segment is reachable.
+ */
+function isReachable(segment) {
+    return segment.reachable;
+}
+
 /**
  * Checks a given node is a member access which has the specified name's
  * property.
@@ -29,22 +38,6 @@ function isTargetMethod(node) {
     return astUtils.isSpecificMemberAccess(node, null, TARGET_METHODS);
 }
 
-/**
- * Checks all segments in a set and returns true if any are reachable.
- * @param {Set<CodePathSegment>} segments The segments to check.
- * @returns {boolean} True if any segment is reachable; false otherwise.
- */
-function isAnySegmentReachable(segments) {
-
-    for (const segment of segments) {
-        if (segment.reachable) {
-            return true;
-        }
-    }
-
-    return false;
-}
-
 /**
  * Returns a human-legible description of an array method
  * @param {string} arrayMethodName A method name to fully qualify
@@ -212,7 +205,7 @@ module.exports = {
                     messageId = "expectedNoReturnValue";
                 }
             } else {
-                if (node.body.type === "BlockStatement" && isAnySegmentReachable(funcInfo.currentSegments)) {
+                if (node.body.type === "BlockStatement" && funcInfo.codePath.currentSegments.some(isReachable)) {
                     messageId = funcInfo.hasReturn ? "expectedAtEnd" : "expectedInside";
                 }
             }
@@ -249,8 +242,7 @@ module.exports = {
                         methodName &&
                         !node.async &&
                         !node.generator,
-                    node,
-                    currentSegments: new Set()
+                    node
                 };
             },
 
@@ -259,23 +251,6 @@ module.exports = {
                 funcInfo = funcInfo.upper;
             },
 
-            onUnreachableCodePathSegmentStart(segment) {
-                funcInfo.currentSegments.add(segment);
-            },
-
-            onUnreachableCodePathSegmentEnd(segment) {
-                funcInfo.currentSegments.delete(segment);
-            },
-
-            onCodePathSegmentStart(segment) {
-                funcInfo.currentSegments.add(segment);
-            },
-
-            onCodePathSegmentEnd(segment) {
-                funcInfo.currentSegments.delete(segment);
-            },
-
-
             // Checks the return statement is valid.
             ReturnStatement(node) {
 
diff --git a/lib/rules/consistent-return.js b/lib/rules/consistent-return.js
index 304e924b1..e2d3f0782 100644
--- a/lib/rules/consistent-return.js
+++ b/lib/rules/consistent-return.js
@@ -16,19 +16,12 @@ const { upperCaseFirst } = require("../shared/string-utils");
 //------------------------------------------------------------------------------
 
 /**
- * Checks all segments in a set and returns true if all are unreachable.
- * @param {Set<CodePathSegment>} segments The segments to check.
- * @returns {boolean} True if all segments are unreachable; false otherwise.
+ * Checks whether or not a given code path segment is unreachable.
+ * @param {CodePathSegment} segment A CodePathSegment to check.
+ * @returns {boolean} `true` if the segment is unreachable.
  */
-function areAllSegmentsUnreachable(segments) {
-
-    for (const segment of segments) {
-        if (segment.reachable) {
-            return false;
-        }
-    }
-
-    return true;
+function isUnreachable(segment) {
+    return !segment.reachable;
 }
 
 /**
@@ -95,7 +88,7 @@ module.exports = {
              * When unreachable, all paths are returned or thrown.
              */
             if (!funcInfo.hasReturnValue ||
-                areAllSegmentsUnreachable(funcInfo.currentSegments) ||
+                funcInfo.codePath.currentSegments.every(isUnreachable) ||
                 astUtils.isES5Constructor(node) ||
                 isClassConstructor(node)
             ) {
@@ -148,31 +141,13 @@ module.exports = {
                     hasReturn: false,
                     hasReturnValue: false,
                     messageId: "",
-                    node,
-                    currentSegments: new Set()
+                    node
                 };
             },
             onCodePathEnd() {
                 funcInfo = funcInfo.upper;
             },
 
-            onUnreachableCodePathSegmentStart(segment) {
-                funcInfo.currentSegments.add(segment);
-            },
-
-            onUnreachableCodePathSegmentEnd(segment) {
-                funcInfo.currentSegments.delete(segment);
-            },
-
-            onCodePathSegmentStart(segment) {
-                funcInfo.currentSegments.add(segment);
-            },
-
-            onCodePathSegmentEnd(segment) {
-                funcInfo.currentSegments.delete(segment);
-            },
-
-
             // Reports a given return statement if it's inconsistent.
             ReturnStatement(node) {
                 const argument = node.argument;
diff --git a/lib/rules/constructor-super.js b/lib/rules/constructor-super.js
index 330be80f3..5f4058812 100644
--- a/lib/rules/constructor-super.js
+++ b/lib/rules/constructor-super.js
@@ -10,19 +10,12 @@
 //------------------------------------------------------------------------------
 
 /**
- * Checks all segments in a set and returns true if any are reachable.
- * @param {Set<CodePathSegment>} segments The segments to check.
- * @returns {boolean} True if any segment is reachable; false otherwise.
+ * Checks whether a given code path segment is reachable or not.
+ * @param {CodePathSegment} segment A code path segment to check.
+ * @returns {boolean} `true` if the segment is reachable.
  */
-function isAnySegmentReachable(segments) {
-
-    for (const segment of segments) {
-        if (segment.reachable) {
-            return true;
-        }
-    }
-
-    return false;
+function isReachable(segment) {
+    return segment.reachable;
 }
 
 /**
@@ -217,8 +210,7 @@ module.exports = {
                         isConstructor: true,
                         hasExtends: Boolean(superClass),
                         superIsConstructor: isPossibleConstructor(superClass),
-                        codePath,
-                        currentSegments: new Set()
+                        codePath
                     };
                 } else {
                     funcInfo = {
@@ -226,8 +218,7 @@ module.exports = {
                         isConstructor: false,
                         hasExtends: false,
                         superIsConstructor: false,
-                        codePath,
-                        currentSegments: new Set()
+                        codePath
                     };
                 }
             },
@@ -270,9 +261,6 @@ module.exports = {
              * @returns {void}
              */
             onCodePathSegmentStart(segment) {
-
-                funcInfo.currentSegments.add(segment);
-
                 if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) {
                     return;
                 }
@@ -293,19 +281,6 @@ module.exports = {
                 }
             },
 
-            onUnreachableCodePathSegmentStart(segment) {
-                funcInfo.currentSegments.add(segment);
-            },
-
-            onUnreachableCodePathSegmentEnd(segment) {
-                funcInfo.currentSegments.delete(segment);
-            },
-
-            onCodePathSegmentEnd(segment) {
-                funcInfo.currentSegments.delete(segment);
-            },
-
-
             /**
              * Update information of the code path segment when a code path was
              * looped.
@@ -369,11 +344,12 @@ module.exports = {
 
                 // Reports if needed.
                 if (funcInfo.hasExtends) {
-                    const segments = funcInfo.currentSegments;
+                    const segments = funcInfo.codePath.currentSegments;
                     let duplicate = false;
                     let info = null;
 
-                    for (const segment of segments) {
+                    for (let i = 0; i < segments.length; ++i) {
+                        const segment = segments[i];
 
                         if (segment.reachable) {
                             info = segInfoMap[segment.id];
@@ -398,7 +374,7 @@ module.exports = {
                             info.validNodes.push(node);
                         }
                     }
-                } else if (isAnySegmentReachable(funcInfo.currentSegments)) {
+                } else if (funcInfo.codePath.currentSegments.some(isReachable)) {
                     context.report({
                         messageId: "unexpected",
                         node
@@ -422,9 +398,10 @@ module.exports = {
                 }
 
                 // Returning argument is a substitute of 'super()'.
-                const segments = funcInfo.currentSegments;
+                const segments = funcInfo.codePath.currentSegments;
 
-                for (const segment of segments) {
+                for (let i = 0; i < segments.length; ++i) {
+                    const segment = segments[i];
 
                     if (segment.reachable) {
                         const info = segInfoMap[segment.id];
diff --git a/lib/rules/getter-return.js b/lib/rules/getter-return.js
index 79ebf3e09..622b6a754 100644
--- a/lib/rules/getter-return.js
+++ b/lib/rules/getter-return.js
@@ -14,23 +14,15 @@ const astUtils = require("./utils/ast-utils");
 //------------------------------------------------------------------------------
 // Helpers
 //------------------------------------------------------------------------------
-
 const TARGET_NODE_TYPE = /^(?:Arrow)?FunctionExpression$/u;
 
 /**
- * Checks all segments in a set and returns true if any are reachable.
- * @param {Set<CodePathSegment>} segments The segments to check.
- * @returns {boolean} True if any segment is reachable; false otherwise.
+ * Checks a given code path segment is reachable.
+ * @param {CodePathSegment} segment A segment to check.
+ * @returns {boolean} `true` if the segment is reachable.
  */
-function isAnySegmentReachable(segments) {
-
-    for (const segment of segments) {
-        if (segment.reachable) {
-            return true;
-        }
-    }
-
-    return false;
+function isReachable(segment) {
+    return segment.reachable;
 }
 
 //------------------------------------------------------------------------------
@@ -79,8 +71,7 @@ module.exports = {
             codePath: null,
             hasReturn: false,
             shouldCheck: false,
-            node: null,
-            currentSegments: []
+            node: null
         };
 
         /**
@@ -94,7 +85,7 @@ module.exports = {
          */
         function checkLastSegment(node) {
             if (funcInfo.shouldCheck &&
-                isAnySegmentReachable(funcInfo.currentSegments)
+                funcInfo.codePath.currentSegments.some(isReachable)
             ) {
                 context.report({
                     node,
@@ -153,8 +144,7 @@ module.exports = {
                     codePath,
                     hasReturn: false,
                     shouldCheck: isGetter(node),
-                    node,
-                    currentSegments: new Set()
+                    node
                 };
             },
 
@@ -162,21 +152,6 @@ module.exports = {
             onCodePathEnd() {
                 funcInfo = funcInfo.upper;
             },
-            onUnreachableCodePathSegmentStart(segment) {
-                funcInfo.currentSegments.add(segment);
-            },
-
-            onUnreachableCodePathSegmentEnd(segment) {
-                funcInfo.currentSegments.delete(segment);
-            },
-
-            onCodePathSegmentStart(segment) {
-                funcInfo.currentSegments.add(segment);
-            },
-
-            onCodePathSegmentEnd(segment) {
-                funcInfo.currentSegments.delete(segment);
-            },
 
             // Checks the return statement is valid.
             ReturnStatement(node) {
diff --git a/lib/rules/lines-between-class-members.js b/lib/rules/lines-between-class-members.js
index 3d0a5e673..dee4bab5f 100644
--- a/lib/rules/lines-between-class-members.js
+++ b/lib/rules/lines-between-class-members.js
@@ -10,21 +10,6 @@
 
 const astUtils = require("./utils/ast-utils");
 
-//------------------------------------------------------------------------------
-// Helpers
-//------------------------------------------------------------------------------
-
-/**
- * Types of class members.
- * Those have `test` method to check it matches to the given class member.
- * @private
- */
-const ClassMemberTypes = {
-    "*": { test: () => true },
-    field: { test: node => node.type === "PropertyDefinition" },
-    method: { test: node => node.type === "MethodDefinition" }
-};
-
 //------------------------------------------------------------------------------
 // Rule Definition
 //------------------------------------------------------------------------------
@@ -44,32 +29,7 @@ module.exports = {
 
         schema: [
             {
-                anyOf: [
-                    {
-                        type: "object",
-                        properties: {
-                            enforce: {
-                                type: "array",
-                                items: {
-                                    type: "object",
-                                    properties: {
-                                        blankLine: { enum: ["always", "never"] },
-                                        prev: { enum: ["method", "field", "*"] },
-                                        next: { enum: ["method", "field", "*"] }
-                                    },
-                                    additionalProperties: false,
-                                    required: ["blankLine", "prev", "next"]
-                                },
-                                minItems: 1
-                            }
-                        },
-                        additionalProperties: false,
-                        required: ["enforce"]
-                    },
-                    {
-                        enum: ["always", "never"]
-                    }
-                ]
+                enum: ["always", "never"]
             },
             {
                 type: "object",
@@ -95,7 +55,6 @@ module.exports = {
         options[0] = context.options[0] || "always";
         options[1] = context.options[1] || { exceptAfterSingleLine: false };
 
-        const configureList = typeof options[0] === "object" ? options[0].enforce : [{ blankLine: options[0], prev: "*", next: "*" }];
         const sourceCode = context.sourceCode;
 
         /**
@@ -185,38 +144,6 @@ module.exports = {
             return sourceCode.getTokensBetween(before, after, { includeComments: true }).length !== 0;
         }
 
-        /**
-         * Checks whether the given node matches the given type.
-         * @param {ASTNode} node The class member node to check.
-         * @param {string} type The class member type to check.
-         * @returns {boolean} `true` if the class member node matched the type.
-         * @private
-         */
-        function match(node, type) {
-            return ClassMemberTypes[type].test(node);
-        }
-
-        /**
-         * Finds the last matched configuration from the configureList.
-         * @param {ASTNode} prevNode The previous node to match.
-         * @param {ASTNode} nextNode The current node to match.
-         * @returns {string|null} Padding type or `null` if no matches were found.
-         * @private
-         */
-        function getPaddingType(prevNode, nextNode) {
-            for (let i = configureList.length - 1; i >= 0; --i) {
-                const configure = configureList[i];
-                const matched =
-                    match(prevNode, configure.prev) &&
-                    match(nextNode, configure.next);
-
-                if (matched) {
-                    return configure.blankLine;
-                }
-            }
-            return null;
-        }
-
         return {
             ClassBody(node) {
                 const body = node.body;
@@ -231,34 +158,22 @@ module.exports = {
                     const isPadded = afterPadding.loc.start.line - beforePadding.loc.end.line > 1;
                     const hasTokenInPadding = hasTokenOrCommentBetween(beforePadding, afterPadding);
                     const curLineLastToken = findLastConsecutiveTokenAfter(curLast, nextFirst, 0);
-                    const paddingType = getPaddingType(body[i], body[i + 1]);
-
-                    if (paddingType === "never" && isPadded) {
-                        context.report({
-                            node: body[i + 1],
-                            messageId: "never",
 
-                            fix(fixer) {
-                                if (hasTokenInPadding) {
-                                    return null;
-                                }
-                                return fixer.replaceTextRange([beforePadding.range[1], afterPadding.range[0]], "\n");
-                            }
-                        });
-                    } else if (paddingType === "always" && !skip && !isPadded) {
+                    if ((options[0] === "always" && !skip && !isPadded) ||
+                        (options[0] === "never" && isPadded)) {
                         context.report({
                             node: body[i + 1],
-                            messageId: "always",
-
+                            messageId: isPadded ? "never" : "always",
                             fix(fixer) {
                                 if (hasTokenInPadding) {
                                     return null;
                                 }
-                                return fixer.insertTextAfter(curLineLastToken, "\n");
+                                return isPadded
+                                    ? fixer.replaceTextRange([beforePadding.range[1], afterPadding.range[0]], "\n")
+                                    : fixer.insertTextAfter(curLineLastToken, "\n");
                             }
                         });
                     }
-
                 }
             }
         };
diff --git a/lib/rules/no-fallthrough.js b/lib/rules/no-fallthrough.js
index 91da12120..bd2ee9bbe 100644
--- a/lib/rules/no-fallthrough.js
+++ b/lib/rules/no-fallthrough.js
@@ -16,22 +16,6 @@ const { directivesPattern } = require("../shared/directives");
 
 const DEFAULT_FALLTHROUGH_COMMENT = /falls?\s?through/iu;
 
-/**
- * Checks all segments in a set and returns true if any are reachable.
- * @param {Set<CodePathSegment>} segments The segments to check.
- * @returns {boolean} True if any segment is reachable; false otherwise.
- */
-function isAnySegmentReachable(segments) {
-
-    for (const segment of segments) {
-        if (segment.reachable) {
-            return true;
-        }
-    }
-
-    return false;
-}
-
 /**
  * Checks whether or not a given comment string is really a fallthrough comment and not an ESLint directive.
  * @param {string} comment The comment string to check.
@@ -67,6 +51,15 @@ function hasFallthroughComment(caseWhichFallsThrough, subsequentCase, context, f
     return Boolean(comment && isFallThroughComment(comment.value, fallthroughCommentPattern));
 }
 
+/**
+ * Checks whether or not a given code path segment is reachable.
+ * @param {CodePathSegment} segment A CodePathSegment to check.
+ * @returns {boolean} `true` if the segment is reachable.
+ */
+function isReachable(segment) {
+    return segment.reachable;
+}
+
 /**
  * Checks whether a node and a token are separated by blank lines
  * @param {ASTNode} node The node to check
@@ -116,8 +109,7 @@ module.exports = {
 
     create(context) {
         const options = context.options[0] || {};
-        const codePathSegments = [];
-        let currentCodePathSegments = new Set();
+        let currentCodePath = null;
         const sourceCode = context.sourceCode;
         const allowEmptyCase = options.allowEmptyCase || false;
 
@@ -134,33 +126,13 @@ module.exports = {
             fallthroughCommentPattern = DEFAULT_FALLTHROUGH_COMMENT;
         }
         return {
-
-            onCodePathStart() {
-                codePathSegments.push(currentCodePathSegments);
-                currentCodePathSegments = new Set();
+            onCodePathStart(codePath) {
+                currentCodePath = codePath;
             },
-
             onCodePathEnd() {
-                currentCodePathSegments = codePathSegments.pop();
-            },
-
-            onUnreachableCodePathSegmentStart(segment) {
-                currentCodePathSegments.add(segment);
-            },
-
-            onUnreachableCodePathSegmentEnd(segment) {
-                currentCodePathSegments.delete(segment);
-            },
-
-            onCodePathSegmentStart(segment) {
-                currentCodePathSegments.add(segment);
+                currentCodePath = currentCodePath.upper;
             },
 
-            onCodePathSegmentEnd(segment) {
-                currentCodePathSegments.delete(segment);
-            },
-
-
             SwitchCase(node) {
 
                 /*
@@ -185,7 +157,7 @@ module.exports = {
                  * `break`, `return`, or `throw` are unreachable.
                  * And allows empty cases and the last case.
                  */
-                if (isAnySegmentReachable(currentCodePathSegments) &&
+                if (currentCodePath.currentSegments.some(isReachable) &&
                     (node.consequent.length > 0 || (!allowEmptyCase && hasBlankLinesBetween(node, nextToken))) &&
                     node.parent.cases[node.parent.cases.length - 1] !== node) {
                     fallthroughCase = node;
diff --git a/lib/rules/no-this-before-super.js b/lib/rules/no-this-before-super.js
index f96d8ace8..139bb6649 100644
--- a/lib/rules/no-this-before-super.js
+++ b/lib/rules/no-this-before-super.js
@@ -90,21 +90,6 @@ module.exports = {
             return Boolean(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends);
         }
 
-        /**
-         * Determines if every segment in a set has been called.
-         * @param {Set<CodePathSegment>} segments The segments to search.
-         * @returns {boolean} True if every segment has been called; false otherwise.
-         */
-        function isEverySegmentCalled(segments) {
-            for (const segment of segments) {
-                if (!isCalled(segment)) {
-                    return false;
-                }
-            }
-
-            return true;
-        }
-
         /**
          * Checks whether or not this is before `super()` is called.
          * @returns {boolean} `true` if this is before `super()` is called.
@@ -112,7 +97,7 @@ module.exports = {
         function isBeforeCallOfSuper() {
             return (
                 isInConstructorOfDerivedClass() &&
-                !isEverySegmentCalled(funcInfo.currentSegments)
+                !funcInfo.codePath.currentSegments.every(isCalled)
             );
         }
 
@@ -123,9 +108,11 @@ module.exports = {
          * @returns {void}
          */
         function setInvalid(node) {
-            const segments = funcInfo.currentSegments;
+            const segments = funcInfo.codePath.currentSegments;
+
+            for (let i = 0; i < segments.length; ++i) {
+                const segment = segments[i];
 
-            for (const segment of segments) {
                 if (segment.reachable) {
                     segInfoMap[segment.id].invalidNodes.push(node);
                 }
@@ -137,9 +124,11 @@ module.exports = {
          * @returns {void}
          */
         function setSuperCalled() {
-            const segments = funcInfo.currentSegments;
+            const segments = funcInfo.codePath.currentSegments;
+
+            for (let i = 0; i < segments.length; ++i) {
+                const segment = segments[i];
 
-            for (const segment of segments) {
                 if (segment.reachable) {
                     segInfoMap[segment.id].superCalled = true;
                 }
@@ -167,16 +156,14 @@ module.exports = {
                             classNode.superClass &&
                             !astUtils.isNullOrUndefined(classNode.superClass)
                         ),
-                        codePath,
-                        currentSegments: new Set()
+                        codePath
                     };
                 } else {
                     funcInfo = {
                         upper: funcInfo,
                         isConstructor: false,
                         hasExtends: false,
-                        codePath,
-                        currentSegments: new Set()
+                        codePath
                     };
                 }
             },
@@ -224,8 +211,6 @@ module.exports = {
              * @returns {void}
              */
             onCodePathSegmentStart(segment) {
-                funcInfo.currentSegments.add(segment);
-
                 if (!isInConstructorOfDerivedClass()) {
                     return;
                 }
@@ -240,18 +225,6 @@ module.exports = {
                 };
             },
 
-            onUnreachableCodePathSegmentStart(segment) {
-                funcInfo.currentSegments.add(segment);
-            },
-
-            onUnreachableCodePathSegmentEnd(segment) {
-                funcInfo.currentSegments.delete(segment);
-            },
-
-            onCodePathSegmentEnd(segment) {
-                funcInfo.currentSegments.delete(segment);
-            },
-
             /**
              * Update information of the code path segment when a code path was
              * looped.
diff --git a/lib/rules/no-unreachable-loop.js b/lib/rules/no-unreachable-loop.js
index 577d39ac7..1df764e17 100644
--- a/lib/rules/no-unreachable-loop.js
+++ b/lib/rules/no-unreachable-loop.js
@@ -11,22 +11,6 @@
 
 const allLoopTypes = ["WhileStatement", "DoWhileStatement", "ForStatement", "ForInStatement", "ForOfStatement"];
 
-/**
- * Checks all segments in a set and returns true if any are reachable.
- * @param {Set<CodePathSegment>} segments The segments to check.
- * @returns {boolean} True if any segment is reachable; false otherwise.
- */
-function isAnySegmentReachable(segments) {
-
-    for (const segment of segments) {
-        if (segment.reachable) {
-            return true;
-        }
-    }
-
-    return false;
-}
-
 /**
  * Determines whether the given node is the first node in the code path to which a loop statement
  * 'loops' for the next iteration.
@@ -106,36 +90,29 @@ module.exports = {
             loopsByTargetSegments = new Map(),
             loopsToReport = new Set();
 
-        const codePathSegments = [];
-        let currentCodePathSegments = new Set();
+        let currentCodePath = null;
 
         return {
-
-            onCodePathStart() {
-                codePathSegments.push(currentCodePathSegments);
-                currentCodePathSegments = new Set();
+            onCodePathStart(codePath) {
+                currentCodePath = codePath;
             },
 
             onCodePathEnd() {
-                currentCodePathSegments = codePathSegments.pop();
-            },
-
-            onUnreachableCodePathSegmentStart(segment) {
-                currentCodePathSegments.add(segment);
+                currentCodePath = currentCodePath.upper;
             },
 
-            onUnreachableCodePathSegmentEnd(segment) {
-                currentCodePathSegments.delete(segment);
-            },
+            [loopSelector](node) {
 
-            onCodePathSegmentEnd(segment) {
-                currentCodePathSegments.delete(segment);
+                /**
+                 * Ignore unreachable loop statements to avoid unnecessary complexity in the implementation, or false positives otherwise.
+                 * For unreachable segments, the code path analysis does not raise events required for this implementation.
+                 */
+                if (currentCodePath.currentSegments.some(segment => segment.reachable)) {
+                    loopsToReport.add(node);
+                }
             },
 
             onCodePathSegmentStart(segment, node) {
-
-                currentCodePathSegments.add(segment);
-
                 if (isLoopingTarget(node)) {
                     const loop = node.parent;
 
@@ -163,18 +140,6 @@ module.exports = {
                 }
             },
 
-            [loopSelector](node) {
-
-                /**
-                 * Ignore unreachable loop statements to avoid unnecessary complexity in the implementation, or false positives otherwise.
-                 * For unreachable segments, the code path analysis does not raise events required for this implementation.
-                 */
-                if (isAnySegmentReachable(currentCodePathSegments)) {
-                    loopsToReport.add(node);
-                }
-            },
-
-
             "Program:exit"() {
                 loopsToReport.forEach(
                     node => context.report({ node, messageId: "invalid" })
diff --git a/lib/rules/no-unreachable.js b/lib/rules/no-unreachable.js
index 0cf750e42..6216a73a2 100644
--- a/lib/rules/no-unreachable.js
+++ b/lib/rules/no-unreachable.js
@@ -24,19 +24,12 @@ function isInitialized(node) {
 }
 
 /**
- * Checks all segments in a set and returns true if all are unreachable.
- * @param {Set<CodePathSegment>} segments The segments to check.
- * @returns {boolean} True if all segments are unreachable; false otherwise.
+ * Checks whether or not a given code path segment is unreachable.
+ * @param {CodePathSegment} segment A CodePathSegment to check.
+ * @returns {boolean} `true` if the segment is unreachable.
  */
-function areAllSegmentsUnreachable(segments) {
-
-    for (const segment of segments) {
-        if (segment.reachable) {
-            return false;
-        }
-    }
-
-    return true;
+function isUnreachable(segment) {
+    return !segment.reachable;
 }
 
 /**
@@ -131,6 +124,7 @@ module.exports = {
     },
 
     create(context) {
+        let currentCodePath = null;
 
         /** @type {ConstructorInfo | null} */
         let constructorInfo = null;
@@ -138,12 +132,6 @@ module.exports = {
         /** @type {ConsecutiveRange} */
         const range = new ConsecutiveRange(context.sourceCode);
 
-        /** @type {Array<Set<CodePathSegment>>} */
-        const codePathSegments = [];
-
-        /** @type {Set<CodePathSegment>} */
-        let currentCodePathSegments = new Set();
-
         /**
          * Reports a given node if it's unreachable.
          * @param {ASTNode} node A statement node to report.
@@ -152,7 +140,7 @@ module.exports = {
         function reportIfUnreachable(node) {
             let nextNode = null;
 
-            if (node && (node.type === "PropertyDefinition" || areAllSegmentsUnreachable(currentCodePathSegments))) {
+            if (node && (node.type === "PropertyDefinition" || currentCodePath.currentSegments.every(isUnreachable))) {
 
                 // Store this statement to distinguish consecutive statements.
                 if (range.isEmpty) {
@@ -193,29 +181,12 @@ module.exports = {
         return {
 
             // Manages the current code path.
-            onCodePathStart() {
-                codePathSegments.push(currentCodePathSegments);
-                currentCodePathSegments = new Set();
+            onCodePathStart(codePath) {
+                currentCodePath = codePath;
             },
 
             onCodePathEnd() {
-                currentCodePathSegments = codePathSegments.pop();
-            },
-
-            onUnreachableCodePathSegmentStart(segment) {
-                currentCodePathSegments.add(segment);
-            },
-
-            onUnreachableCodePathSegmentEnd(segment) {
-                currentCodePathSegments.delete(segment);
-            },
-
-            onCodePathSegmentEnd(segment) {
-                currentCodePathSegments.delete(segment);
-            },
-
-            onCodePathSegmentStart(segment) {
-                currentCodePathSegments.add(segment);
+                currentCodePath = currentCodePath.upper;
             },
 
             // Registers for all statement nodes (excludes FunctionDeclaration).
diff --git a/lib/rules/no-useless-return.js b/lib/rules/no-useless-return.js
index 81d610510..f89523153 100644
--- a/lib/rules/no-useless-return.js
+++ b/lib/rules/no-useless-return.js
@@ -57,22 +57,6 @@ function isInFinally(node) {
     return false;
 }
 
-/**
- * Checks all segments in a set and returns true if any are reachable.
- * @param {Set<CodePathSegment>} segments The segments to check.
- * @returns {boolean} True if any segment is reachable; false otherwise.
- */
-function isAnySegmentReachable(segments) {
-
-    for (const segment of segments) {
-        if (segment.reachable) {
-            return true;
-        }
-    }
-
-    return false;
-}
-
 //------------------------------------------------------------------------------
 // Rule Definition
 //------------------------------------------------------------------------------
@@ -221,6 +205,7 @@ module.exports = {
          */
         function markReturnStatementsOnCurrentSegmentsAsUsed() {
             scopeInfo
+                .codePath
                 .currentSegments
                 .forEach(segment => markReturnStatementsOnSegmentAsUsed(segment, new Set()));
         }
@@ -237,8 +222,7 @@ module.exports = {
                     upper: scopeInfo,
                     uselessReturns: [],
                     traversedTryBlockStatements: [],
-                    codePath,
-                    currentSegments: new Set()
+                    codePath
                 };
             },
 
@@ -275,9 +259,6 @@ module.exports = {
              * NOTE: This event is notified for only reachable segments.
              */
             onCodePathSegmentStart(segment) {
-
-                scopeInfo.currentSegments.add(segment);
-
                 const info = {
                     uselessReturns: getUselessReturns([], segment.allPrevSegments),
                     returned: false
@@ -287,18 +268,6 @@ module.exports = {
                 segmentInfoMap.set(segment, info);
             },
 
-            onUnreachableCodePathSegmentStart(segment) {
-                scopeInfo.currentSegments.add(segment);
-            },
-
-            onUnreachableCodePathSegmentEnd(segment) {
-                scopeInfo.currentSegments.delete(segment);
-            },
-
-            onCodePathSegmentEnd(segment) {
-                scopeInfo.currentSegments.delete(segment);
-            },
-
             // Adds ReturnStatement node to check whether it's useless or not.
             ReturnStatement(node) {
                 if (node.argument) {
@@ -310,12 +279,12 @@ module.exports = {
                     isInFinally(node) ||
 
                     // Ignore `return` statements in unreachable places (https://github.com/eslint/eslint/issues/11647).
-                    !isAnySegmentReachable(scopeInfo.currentSegments)
+                    !scopeInfo.codePath.currentSegments.some(s => s.reachable)
                 ) {
                     return;
                 }
 
-                for (const segment of scopeInfo.currentSegments) {
+                for (const segment of scopeInfo.codePath.currentSegments) {
                     const info = segmentInfoMap.get(segment);
 
                     if (info) {
diff --git a/lib/rules/require-atomic-updates.js b/lib/rules/require-atomic-updates.js
index 7e397ceb1..ba369a203 100644
--- a/lib/rules/require-atomic-updates.js
+++ b/lib/rules/require-atomic-updates.js
@@ -213,8 +213,7 @@ module.exports = {
                 stack = {
                     upper: stack,
                     codePath,
-                    referenceMap: shouldVerify ? createReferenceMap(scope) : null,
-                    currentSegments: new Set()
+                    referenceMap: shouldVerify ? createReferenceMap(scope) : null
                 };
             },
             onCodePathEnd() {
@@ -224,25 +223,11 @@ module.exports = {
             // Initialize the segment information.
             onCodePathSegmentStart(segment) {
                 segmentInfo.initialize(segment);
-                stack.currentSegments.add(segment);
             },
 
-            onUnreachableCodePathSegmentStart(segment) {
-                stack.currentSegments.add(segment);
-            },
-
-            onUnreachableCodePathSegmentEnd(segment) {
-                stack.currentSegments.delete(segment);
-            },
-
-            onCodePathSegmentEnd(segment) {
-                stack.currentSegments.delete(segment);
-            },
-
-
             // Handle references to prepare verification.
             Identifier(node) {
-                const { referenceMap } = stack;
+                const { codePath, referenceMap } = stack;
                 const reference = referenceMap && referenceMap.get(node);
 
                 // Ignore if this is not a valid variable reference.
@@ -255,7 +240,7 @@ module.exports = {
 
                 // Add a fresh read variable.
                 if (reference.isRead() && !(writeExpr && writeExpr.parent.operator === "=")) {
-                    segmentInfo.markAsRead(stack.currentSegments, variable);
+                    segmentInfo.markAsRead(codePath.currentSegments, variable);
                 }
 
                 /*
@@ -282,15 +267,16 @@ module.exports = {
              * If the reference exists in `outdatedReadVariables` list, report it.
              */
             ":expression:exit"(node) {
+                const { codePath, referenceMap } = stack;
 
                 // referenceMap exists if this is in a resumable function scope.
-                if (!stack.referenceMap) {
+                if (!referenceMap) {
                     return;
                 }
 
                 // Mark the read variables on this code path as outdated.
                 if (node.type === "AwaitExpression" || node.type === "YieldExpression") {
-                    segmentInfo.makeOutdated(stack.currentSegments);
+                    segmentInfo.makeOutdated(codePath.currentSegments);
                 }
 
                 // Verify.
@@ -302,7 +288,7 @@ module.exports = {
                     for (const reference of references) {
                         const variable = reference.resolved;
 
-                        if (segmentInfo.isOutdated(stack.currentSegments, variable)) {
+                        if (segmentInfo.isOutdated(codePath.currentSegments, variable)) {
                             if (node.parent.left === reference.identifier) {
                                 context.report({
                                     node: node.parent,
diff --git a/package.json b/package.json
index 9fe892ea5..d52a2aef6 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
   "name": "eslint",
-  "version": "8.49.0",
+  "version": "8.48.0",
   "author": "Nicholas C. Zakas <nicholas+npm@nczconsulting.com>",
   "description": "An AST-based pattern checker for JavaScript.",
   "bin": {
@@ -63,7 +63,7 @@
     "@eslint-community/eslint-utils": "^4.2.0",
     "@eslint-community/regexpp": "^4.6.1",
     "@eslint/eslintrc": "^2.1.2",
-    "@eslint/js": "8.49.0",
+    "@eslint/js": "8.48.0",
     "@humanwhocodes/config-array": "^0.11.11",
     "@humanwhocodes/module-importer": "^1.0.1",
     "@nodelib/fs.walk": "^1.2.8",
@@ -101,11 +101,6 @@
   "devDependencies": {
     "@babel/core": "^7.4.3",
     "@babel/preset-env": "^7.4.3",
-    "@wdio/browser-runner": "^8.14.6",
-    "@wdio/cli": "^8.14.6",
-    "@wdio/concise-reporter": "^8.14.0",
-    "@wdio/globals": "^8.14.6",
-    "@wdio/mocha-framework": "^8.14.0",
     "babel-loader": "^8.0.5",
     "c8": "^7.12.0",
     "chai": "^4.0.1",
@@ -129,6 +124,11 @@
     "glob": "^7.1.6",
     "got": "^11.8.3",
     "gray-matter": "^4.0.3",
+    "karma": "^6.1.1",
+    "karma-chrome-launcher": "^3.1.0",
+    "karma-mocha": "^2.0.1",
+    "karma-mocha-reporter": "^2.2.5",
+    "karma-webpack": "^5.0.0",
     "lint-staged": "^11.0.0",
     "load-perf": "^0.2.0",
     "markdownlint": "^0.25.1",
@@ -148,14 +148,12 @@
     "pirates": "^4.0.5",
     "progress": "^2.0.3",
     "proxyquire": "^2.0.1",
+    "puppeteer": "^13.7.0",
     "recast": "^0.20.4",
     "regenerator-runtime": "^0.13.2",
-    "rollup-plugin-node-polyfills": "^0.2.1",
     "semver": "^7.5.3",
     "shelljs": "^0.8.2",
     "sinon": "^11.0.0",
-    "vite-plugin-commonjs": "^0.8.2",
-    "webdriverio": "^8.14.6",
     "webpack": "^5.23.0",
     "webpack-cli": "^4.5.0",
     "yorkie": "^2.0.0"
diff --git a/packages/eslint-config-eslint/base.js b/packages/eslint-config-eslint/base.js
index 083336919..136510839 100644
--- a/packages/eslint-config-eslint/base.js
+++ b/packages/eslint-config-eslint/base.js
@@ -9,6 +9,7 @@ const unicorn = require("eslint-plugin-unicorn");
  * the plugins' configs are not updated to support the flat config,
  * need to manually update the `plugins` property
  */
+jsdoc.configs.recommended.plugins = { jsdoc };
 eslintComments.configs.recommended.plugins = { "eslint-comments": eslintComments };
 
 // extends eslint recommended config
@@ -261,7 +262,7 @@ const jsConfigs = [js.configs.recommended, {
 }];
 
 // extends eslint-plugin-jsdoc's recommended config
-const jsdocConfigs = [jsdoc.configs["flat/recommended"], {
+const jsdocConfigs = [jsdoc.configs.recommended, {
     settings: {
         jsdoc: {
             mode: "typescript",
diff --git a/packages/eslint-config-eslint/package.json b/packages/eslint-config-eslint/package.json
index f8c7fab87..7d8a74753 100644
--- a/packages/eslint-config-eslint/package.json
+++ b/packages/eslint-config-eslint/package.json
@@ -30,7 +30,7 @@
   "dependencies": {
     "@eslint/js": "^8.42.0",
     "eslint-plugin-eslint-comments": "^3.2.0",
-    "eslint-plugin-jsdoc": "^46.5.1",
+    "eslint-plugin-jsdoc": "^46.2.5",
     "eslint-plugin-n": "^16.0.0",
     "eslint-plugin-unicorn": "^42.0.0"
   },
diff --git a/packages/js/package.json b/packages/js/package.json
index 7bfcf6e6b..965acdba0 100644
--- a/packages/js/package.json
+++ b/packages/js/package.json
@@ -1,6 +1,6 @@
 {
   "name": "@eslint/js",
-  "version": "8.49.0",
+  "version": "8.48.0",
   "description": "ESLint JavaScript language implementation",
   "main": "./src/index.js",
   "scripts": {},
diff --git a/wdio.conf.js b/wdio.conf.js
deleted file mode 100644
index f32d75713..000000000
--- a/wdio.conf.js
+++ /dev/null
@@ -1,387 +0,0 @@
-"use strict";
-
-const path = require("path");
-const commonjs = require("vite-plugin-commonjs").default;
-
-exports.config = {
-
-    /*
-     *
-     * ====================
-     * Runner Configuration
-     * ====================
-     * WebdriverIO supports running e2e tests as well as unit and component tests.
-     */
-    runner: ["browser", {
-        viteConfig: {
-            resolve: {
-                alias: {
-                    util: "rollup-plugin-node-polyfills/polyfills/util",
-                    path: "rollup-plugin-node-polyfills/polyfills/path",
-                    assert: "rollup-plugin-node-polyfills/polyfills/assert"
-                }
-            },
-            plugins: [
-                commonjs(),
-                {
-                    name: "wdio:import-fix",
-                    enforce: "pre",
-                    transform(source, id) {
-                        if (!id.endsWith("/tests/lib/linter/linter.js")) {
-                            return source;
-                        }
-
-                        return source.replace(
-                            'const { Linter } = require("../../../lib/linter");',
-                            'const { Linter } = require("../../../build/eslint");\n' +
-                            'process.cwd = () => "/";'
-                        );
-                    }
-                }
-            ]
-        }
-    }],
-
-    /*
-     *
-     * ==================
-     * Specify Test Files
-     * ==================
-     * Define which test specs should run. The pattern is relative to the directory
-     * of the configuration file being run.
-     *
-     * The specs are defined as an array of spec files (optionally using wildcards
-     * that will be expanded). The test for each spec file will be run in a separate
-     * worker process. In order to have a group of spec files run in the same worker
-     * process simply enclose them in an array within the specs array.
-     *
-     * If you are calling `wdio` from an NPM script (see https://docs.npmjs.com/cli/run-script),
-     * then the current working directory is where your `package.json` resides, so `wdio`
-     * will be called from there.
-     *
-     */
-    specs: [
-        path.join(__dirname, "tests", "lib", "linter", "linter.js")
-    ],
-
-    // Patterns to exclude.
-    exclude: [],
-
-    /*
-     *
-     * ============
-     * Capabilities
-     * ============
-     * Define your capabilities here. WebdriverIO can run multiple capabilities at the same
-     * time. Depending on the number of capabilities, WebdriverIO launches several test
-     * sessions. Within your capabilities you can overwrite the spec and exclude options in
-     * order to group specific specs to a specific capability.
-     *
-     * First, you can define how many instances should be started at the same time. Let"s
-     * say you have 3 different capabilities (Chrome, Firefox, and Safari) and you have
-     * set maxInstances to 1; wdio will spawn 3 processes. Therefore, if you have 10 spec
-     * files and you set maxInstances to 10, all spec files will get tested at the same time
-     * and 30 processes will get spawned. The property handles how many capabilities
-     * from the same test should run tests.
-     *
-     */
-    maxInstances: 10,
-
-    /*
-     *
-     * If you have trouble getting all important capabilities together, check out the
-     * Sauce Labs platform configurator - a great tool to configure your capabilities:
-     * https://saucelabs.com/platform/platform-configurator
-     *
-     */
-    capabilities: [{
-        browserName: "chrome",
-        "goog:chromeOptions": {
-            args: process.env.CI ? ["headless", "disable-gpu"] : []
-        }
-    }],
-
-    /*
-     *
-     * ===================
-     * Test Configurations
-     * ===================
-     * Define all options that are relevant for the WebdriverIO instance here
-     *
-     * Level of logging verbosity: trace | debug | info | warn | error | silent
-     */
-    logLevel: "trace",
-    outputDir: "./wdio-logs",
-
-    /*
-     *
-     * Set specific log levels per logger
-     * loggers:
-     * - webdriver, webdriverio
-     * - @wdio/browserstack-service, @wdio/devtools-service, @wdio/sauce-service
-     * - @wdio/mocha-framework, @wdio/jasmine-framework
-     * - @wdio/local-runner
-     * - @wdio/sumologic-reporter
-     * - @wdio/cli, @wdio/config, @wdio/utils
-     * Level of logging verbosity: trace | debug | info | warn | error | silent
-     * logLevels: {
-     *     webdriver: 'info',
-     *     '@wdio/appium-service': 'info'
-     * },
-     *
-     * If you only want to run your tests until a specific amount of tests have failed use
-     * bail (default is 0 - don't bail, run all tests).
-     */
-    bail: 0,
-
-    /*
-     *
-     * Set a base URL in order to shorten url command calls. If your `url` parameter starts
-     * with `/`, the base url gets prepended, not including the path portion of your baseUrl.
-     * If your `url` parameter starts without a scheme or `/` (like `some/path`), the base url
-     * gets prepended directly.
-     */
-    baseUrl: "",
-
-    /*
-     *
-     * Default timeout for all waitFor* commands.
-     */
-    waitforTimeout: 10000,
-
-    /*
-     *
-     * Default timeout in milliseconds for request
-     * if browser driver or grid doesn't send response
-     */
-    connectionRetryTimeout: 120000,
-
-    /*
-     *
-     * Default request retries count
-     */
-    connectionRetryCount: 3,
-
-    /*
-     * Framework you want to run your specs with.
-     * The following are supported: Mocha, Jasmine, and Cucumber
-     * see also: https://webdriver.io/docs/frameworks
-     *
-     * Make sure you have the wdio adapter package for the specific framework installed
-     * before running any tests.
-     */
-    framework: "mocha",
-
-    /*
-     *
-     * The number of times to retry the entire specfile when it fails as a whole
-     * specFileRetries: 1,
-     *
-     * Delay in seconds between the spec file retry attempts
-     * specFileRetriesDelay: 0,
-     *
-     * Whether or not retried specfiles should be retried immediately or deferred to the end of the queue
-     * specFileRetriesDeferred: false,
-     *
-     * Test reporter for stdout.
-     * The only one supported by default is 'dot'
-     * see also: https://webdriver.io/docs/dot-reporter
-     */
-    reporters: ["concise"],
-
-    /*
-     *
-     * Options to be passed to Mocha.
-     * See the full list at http://mochajs.org/
-     */
-    mochaOpts: {
-        ui: "bdd",
-        timeout: 5 * 60 * 1000, // 5min
-        grep: "@skipWeb",
-        invert: true
-    }
-
-    /*
-     *
-     * =====
-     * Hooks
-     * =====
-     * WebdriverIO provides several hooks you can use to interfere with the test process in order to enhance
-     * it and to build services around it. You can either apply a single function or an array of
-     * methods to it. If one of them returns with a promise, WebdriverIO will wait until that promise got
-     * resolved to continue.
-     */
-    /**
-     * Gets executed once before all workers get launched.
-     * @param {Object} config wdio configuration object
-     * @param {Array<Object>} capabilities list of capabilities details
-     */
-    /*
-     * onPrepare: function (config, capabilities) {
-     * },
-     */
-    /**
-     * Gets executed before a worker process is spawned and can be used to initialise specific service
-     * for that worker as well as modify runtime environments in an async fashion.
-     * @param {string} cid capability id (e.g 0-0)
-     * @param {Object} caps object containing capabilities for session that will be spawn in the worker
-     * @param {Object} specs specs to be run in the worker process
-     * @param {Object} args object that will be merged with the main configuration once worker is initialized
-     * @param {Object} execArgv list of string arguments passed to the worker process
-     */
-    /*
-     * onWorkerStart: function (cid, caps, specs, args, execArgv) {
-     * },
-     */
-    /**
-     * Gets executed just after a worker process has exited.
-     * @param {string} cid capability id (e.g 0-0)
-     * @param {number} exitCode 0 - success, 1 - fail
-     * @param {Object} specs specs to be run in the worker process
-     * @param {number} retries number of retries used
-     */
-    /*
-     * onWorkerEnd: function (cid, exitCode, specs, retries) {
-     * },
-     */
-    /**
-     * Gets executed just before initialising the webdriver session and test framework. It allows you
-     * to manipulate configurations depending on the capability or spec.
-     * @param {Object} config wdio configuration object
-     * @param {Array<Object>} capabilities list of capabilities details
-     * @param {Array<string>} specs List of spec file paths that are to be run
-     * @param {string} cid worker id (e.g. 0-0)
-     */
-    /*
-     * beforeSession: function (config, capabilities, specs, cid) {
-     * },
-     */
-    /**
-     * Gets executed before test execution begins. At this point you can access to all global
-     * variables like `browser`. It is the perfect place to define custom commands.
-     * @param {Array<Object>} capabilities list of capabilities details
-     * @param {Array<string>} specs List of spec file paths that are to be run
-     * @param {Object} browser instance of created browser/device session
-     */
-    /*
-     * before: function (capabilities, specs) {
-     * },
-     */
-    /**
-     * Runs before a WebdriverIO command gets executed.
-     * @param {string} commandName hook command name
-     * @param {Array} args arguments that command would receive
-     */
-    /*
-     * beforeCommand: function (commandName, args) {
-     * },
-     */
-    /**
-     * Hook that gets executed before the suite starts
-     * @param {Object} suite suite details
-     */
-    /*
-     * beforeSuite: function (suite) {
-     * },
-     */
-    /**
-     * Function to be executed before a test (in Mocha/Jasmine) starts.
-     */
-    /*
-     * beforeTest: function (test, context) {
-     * },
-     */
-    /**
-     * Hook that gets executed _before_ a hook within the suite starts (e.g. runs before calling
-     * beforeEach in Mocha)
-     */
-    /*
-     * beforeHook: function (test, context) {
-     * },
-     */
-    /**
-     * Hook that gets executed _after_ a hook within the suite starts (e.g. runs after calling
-     * afterEach in Mocha)
-     */
-    /*
-     * afterHook: function (test, context, { error, result, duration, passed, retries }) {
-     * },
-     */
-    /**
-     * Function to be executed after a test (in Mocha/Jasmine only)
-     * @param {Object} test test object
-     * @param {Object} context scope object the test was executed with
-     * @param {Error} result.error error object in case the test fails, otherwise `undefined`
-     * @param {any} result.result return object of test function
-     * @param {number} result.duration duration of test
-     * @param {boolean} result.passed true if test has passed, otherwise false
-     * @param {Object} result.retries informations to spec related retries, e.g. `{ attempts: 0, limit: 0 }`
-     */
-    /*
-     * afterTest: function(test, context, { error, result, duration, passed, retries }) {
-     * },
-     */
-
-
-    /**
-     * Hook that gets executed after the suite has ended
-     * @param {Object} suite suite details
-     */
-    /*
-     * afterSuite: function (suite) {
-     * },
-     */
-    /**
-     * Runs after a WebdriverIO command gets executed
-     * @param {string} commandName hook command name
-     * @param {Array} args arguments that command would receive
-     * @param {number} result 0 - command success, 1 - command error
-     * @param {Object} error error object if any
-     */
-    /*
-     * afterCommand: function (commandName, args, result, error) {
-     * },
-     */
-    /**
-     * Gets executed after all tests are done. You still have access to all global variables from
-     * the test.
-     * @param {number} result 0 - test pass, 1 - test fail
-     * @param {Array<Object>} capabilities list of capabilities details
-     * @param {Array<string>} specs List of spec file paths that ran
-     */
-    /*
-     * after: function (result, capabilities, specs) {
-     * },
-     */
-    /**
-     * Gets executed right after terminating the webdriver session.
-     * @param {Object} config wdio configuration object
-     * @param {Array<Object>} capabilities list of capabilities details
-     * @param {Array<string>} specs List of spec file paths that ran
-     */
-    /*
-     * afterSession: function (config, capabilities, specs) {
-     * },
-     */
-    /**
-     * Gets executed after all workers got shut down and the process is about to exit. An error
-     * thrown in the onComplete hook will result in the test run failing.
-     * @param {Object} exitCode 0 - success, 1 - fail
-     * @param {Object} config wdio configuration object
-     * @param {Array<Object>} capabilities list of capabilities details
-     * @param {Object} results object containing test results
-     */
-    /*
-     * onComplete: function(exitCode, config, capabilities, results) {
-     * },
-     */
-    /**
-     * Gets executed when a refresh happens.
-     * @param {string} oldSessionId session ID of the old session
-     * @param {string} newSessionId session ID of the new session
-     */
-    /*
-     * onReload: function(oldSessionId, newSessionId) {
-     * }
-     */
-};
