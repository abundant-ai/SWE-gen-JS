diff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml
index 27dae4c12..7602b8380 100644
--- a/.github/workflows/ci.yml
+++ b/.github/workflows/ci.yml
@@ -13,7 +13,7 @@ jobs:
     name: Verify Files
     runs-on: ubuntu-latest
     steps:
-    - uses: actions/checkout@v3
+    - uses: actions/checkout@v4
     - uses: actions/setup-node@v3
       with:
         node-version: 'lts/*'
@@ -53,7 +53,7 @@ jobs:
           node: "lts/*"
     runs-on: ${{ matrix.os }}
     steps:
-    - uses: actions/checkout@v3
+    - uses: actions/checkout@v4
     - uses: actions/setup-node@v3
       with:
         node-version: ${{ matrix.node }}
@@ -68,13 +68,19 @@ jobs:
     name: Browser Test
     runs-on: ubuntu-latest
     steps:
-    - uses: actions/checkout@v3
+    - uses: actions/checkout@v4
     - uses: actions/setup-node@v3
       with:
         node-version: '16'
     - name: Install Packages
       run: npm install
     - name: Test
-      run: node Makefile karma
+      run: node Makefile wdio
     - name: Fuzz Test
       run: node Makefile fuzz
+    - uses: actions/upload-artifact@v3
+      if: failure()
+      with:
+        name: logs
+        path: |
+          wdio-logs/*.log
diff --git a/.github/workflows/codeql-analysis.yml b/.github/workflows/codeql-analysis.yml
index e2995e66d..637f06e2e 100644
--- a/.github/workflows/codeql-analysis.yml
+++ b/.github/workflows/codeql-analysis.yml
@@ -39,7 +39,7 @@ jobs:
 
     steps:
     - name: Checkout repository
-      uses: actions/checkout@v3
+      uses: actions/checkout@v4
 
     # Initializes the CodeQL tools for scanning.
     - name: Initialize CodeQL
diff --git a/.github/workflows/update-readme.yml b/.github/workflows/update-readme.yml
index e6399920b..43b783d3f 100644
--- a/.github/workflows/update-readme.yml
+++ b/.github/workflows/update-readme.yml
@@ -9,7 +9,7 @@ jobs:
     runs-on: ubuntu-latest
     steps:
     - name: Check out repo
-      uses: actions/checkout@v3
+      uses: actions/checkout@v4
       with:
         token: ${{ secrets.WORKFLOW_PUSH_BOT_TOKEN }}
 
diff --git a/.gitignore b/.gitignore
index 075a4d740..148181e07 100644
--- a/.gitignore
+++ b/.gitignore
@@ -3,6 +3,8 @@
 test.js
 coverage/
 build/
+logs
+wdio-logs
 npm-debug.log
 yarn-error.log
 .pnpm-debug.log
diff --git a/CHANGELOG.md b/CHANGELOG.md
index dbbab930b..7e541a3d3 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,3 +1,20 @@
+v8.49.0 - September 8, 2023
+
+* [`b7621c3`](https://github.com/eslint/eslint/commit/b7621c3b16cf7d5539f05336a827e1b32d95e6ac) chore: remove browser test from `npm test` (#17550) (Milos Djermanovic)
+* [`cac45d0`](https://github.com/eslint/eslint/commit/cac45d04b890b0700dd8908927300608adad05fe) chore: upgrade @eslint/js@8.49.0 (#17549) (Milos Djermanovic)
+* [`cd39508`](https://github.com/eslint/eslint/commit/cd395082bffcb4b68efa09226d7c682cef56179e) chore: package.json update for @eslint/js release (ESLint Jenkins)
+* [`ecfb54f`](https://github.com/eslint/eslint/commit/ecfb54ff4cdd18f28b4f9b78f0a78fb4cf80f1b8) docs: Update README (GitHub Actions Bot)
+* [`da09f4e`](https://github.com/eslint/eslint/commit/da09f4e641141f585ef611c6e9d63d4331054706) feat: Implement onUnreachableCodePathStart/End (#17511) (Nicholas C. Zakas)
+* [`de86b3b`](https://github.com/eslint/eslint/commit/de86b3b2e58edd5826200c23255d8325abe375e1) docs: update `no-promise-executor-return` examples (#17529) (Nitin Kumar)
+* [`203a971`](https://github.com/eslint/eslint/commit/203a971c0abc3a95ae02ff74104a01e569707060) ci: bump actions/checkout from 3 to 4 (#17530) (dependabot[bot])
+* [`32b2327`](https://github.com/eslint/eslint/commit/32b2327aafdd3b911fabab69ed75c9ff97658c60) feat: Emit deprecation warnings in RuleTester (#17527) (Nicholas C. Zakas)
+* [`acb7df3`](https://github.com/eslint/eslint/commit/acb7df35b9a7485f26bc6b3e1f9083d1c585dce9) feat: add new `enforce` option to `lines-between-class-members` (#17462) (Nitin Kumar)
+* [`032c4b1`](https://github.com/eslint/eslint/commit/032c4b1476a7b8cfd917a66772d2221950ea87eb) docs: add typescript template (#17500) (James)
+* [`cd7da5c`](https://github.com/eslint/eslint/commit/cd7da5cc3154f86f7ca45fb58929d27a7af359ed) docs: Update README (GitHub Actions Bot)
+* [`a40fa50`](https://github.com/eslint/eslint/commit/a40fa509922b36bb986eb1be9394591f84f62d9e) chore: use eslint-plugin-jsdoc's flat config (#17516) (Milos Djermanovic)
+* [`926a286`](https://github.com/eslint/eslint/commit/926a28684282aeec37680bbc52a66973b8055f54) test: replace Karma with Webdriver.IO (#17126) (Christian Bromann)
+* [`f591d2c`](https://github.com/eslint/eslint/commit/f591d2c88bf15af72e3a207b34fa872b4b90464b) chore: Upgrade config-array (#17512) (Nicholas C. Zakas)
+
 v8.48.0 - August 25, 2023
 
 * [`8dd3cec`](https://github.com/eslint/eslint/commit/8dd3cec90c97ed97d243a83b87ad4ea9e6b4781a) chore: upgrade @eslint/js@8.48.0 (#17501) (Milos Djermanovic)
diff --git a/Makefile.js b/Makefile.js
index 717cc7859..7978369c0 100644
--- a/Makefile.js
+++ b/Makefile.js
@@ -628,12 +628,10 @@ target.mocha = () => {
     }
 };
 
-target.karma = () => {
+target.wdio = () => {
     echo("Running unit tests on browsers");
-
     target.webpack("production");
-
-    const lastReturn = exec(`${getBinFile("karma")} start karma.conf.js`);
+    const lastReturn = exec(`${getBinFile("wdio")} run wdio.conf.js`);
 
     if (lastReturn.code !== 0) {
         exit(1);
@@ -643,7 +641,9 @@ target.karma = () => {
 target.test = function() {
     target.checkRuleFiles();
     target.mocha();
-    target.karma();
+
+    // target.wdio(); // Temporarily disabled due to problems on Jenkins
+
     target.fuzz({ amount: 150, fuzzBrokenAutofixes: false });
     target.checkLicenses();
 };
diff --git a/README.md b/README.md
index 0ce3a4a5a..01d50a0c9 100644
--- a/README.md
+++ b/README.md
@@ -288,8 +288,8 @@ The following companies, organizations, and individuals support ESLint's ongoing
 <h3>Platinum Sponsors</h3>
 <p><a href="#"><img src="https://images.opencollective.com/2021-frameworks-fund/logo.png" alt="Chrome Frameworks Fund" height="undefined"></a> <a href="https://automattic.com"><img src="https://images.opencollective.com/automattic/d0ef3e1/logo.png" alt="Automattic" height="undefined"></a></p><h3>Gold Sponsors</h3>
 <p><a href="https://engineering.salesforce.com"><img src="https://images.opencollective.com/salesforce/ca8f997/logo.png" alt="Salesforce" height="96"></a> <a href="https://www.airbnb.com/"><img src="https://images.opencollective.com/airbnb/d327d66/logo.png" alt="Airbnb" height="96"></a></p><h3>Silver Sponsors</h3>
-<p><a href="https://sentry.io"><img src="https://avatars.githubusercontent.com/u/1396951?v=4" alt="Sentry" height="64"></a> <a href="https://liftoff.io/"><img src="https://images.opencollective.com/liftoff/5c4fa84/logo.png" alt="Liftoff" height="64"></a> <a href="https://americanexpress.io"><img src="https://avatars.githubusercontent.com/u/3853301?v=4" alt="American Express" height="64"></a></p><h3>Bronze Sponsors</h3>
-<p><a href="https://themeisle.com"><img src="https://images.opencollective.com/themeisle/d5592fe/logo.png" alt="ThemeIsle" height="32"></a> <a href="https://nx.dev"><img src="https://images.opencollective.com/nx/0efbe42/logo.png" alt="Nx (by Nrwl)" height="32"></a> <a href="https://www.crosswordsolver.org/anagram-solver/"><img src="https://images.opencollective.com/anagram-solver/2666271/logo.png" alt="Anagram Solver" height="32"></a> <a href="https://icons8.com"><img src="https://images.opencollective.com/icons8/7fa1641/logo.png" alt="Icons8: free icons, photos, illustrations, and music" height="32"></a> <a href="https://discord.com"><img src="https://images.opencollective.com/discordapp/f9645d9/logo.png" alt="Discord" height="32"></a> <a href="https://github.com/about"><img src="https://avatars.githubusercontent.com/u/9919?v=4" alt="GitHub" height="32"></a> <a href="https://transloadit.com/"><img src="https://avatars.githubusercontent.com/u/125754?v=4" alt="Transloadit" height="32"></a> <a href="https://www.ignitionapp.com"><img src="https://avatars.githubusercontent.com/u/5753491?v=4" alt="Ignition" height="32"></a> <a href="https://herocoders.com"><img src="https://avatars.githubusercontent.com/u/37549774?v=4" alt="HeroCoders" height="32"></a> <a href="https://quickbookstoolhub.com"><img src="https://avatars.githubusercontent.com/u/95090305?u=e5bc398ef775c9ed19f955c675cdc1fb6abf01df&v=4" alt="QuickBooks Tool hub" height="32"></a></p>
+<p><a href="https://sentry.io"><img src="https://avatars.githubusercontent.com/u/1396951?v=4" alt="Sentry" height="64"></a> <a href="https://liftoff.io/"><img src="https://images.opencollective.com/liftoff/5c4fa84/logo.png" alt="Liftoff" height="64"></a> <a href="https://opensource.siemens.com"><img src="https://avatars.githubusercontent.com/u/624020?v=4" alt="Siemens" height="64"></a> <a href="https://americanexpress.io"><img src="https://avatars.githubusercontent.com/u/3853301?v=4" alt="American Express" height="64"></a></p><h3>Bronze Sponsors</h3>
+<p><a href="https://themeisle.com"><img src="https://images.opencollective.com/themeisle/d5592fe/logo.png" alt="ThemeIsle" height="32"></a> <a href="https://nx.dev"><img src="https://images.opencollective.com/nx/0efbe42/logo.png" alt="Nx (by Nrwl)" height="32"></a> <a href="https://www.crosswordsolver.org/anagram-solver/"><img src="https://images.opencollective.com/anagram-solver/2666271/logo.png" alt="Anagram Solver" height="32"></a> <a href="https://icons8.com/"><img src="https://images.opencollective.com/icons8/7fa1641/logo.png" alt="Icons8" height="32"></a> <a href="https://discord.com"><img src="https://images.opencollective.com/discordapp/f9645d9/logo.png" alt="Discord" height="32"></a> <a href="https://github.com/about"><img src="https://avatars.githubusercontent.com/u/9919?v=4" alt="GitHub" height="32"></a> <a href="https://transloadit.com/"><img src="https://avatars.githubusercontent.com/u/125754?v=4" alt="Transloadit" height="32"></a> <a href="https://www.ignitionapp.com"><img src="https://avatars.githubusercontent.com/u/5753491?v=4" alt="Ignition" height="32"></a> <a href="https://herocoders.com"><img src="https://avatars.githubusercontent.com/u/37549774?v=4" alt="HeroCoders" height="32"></a> <a href="https://quickbookstoolhub.com"><img src="https://avatars.githubusercontent.com/u/95090305?u=e5bc398ef775c9ed19f955c675cdc1fb6abf01df&v=4" alt="QuickBooks Tool hub" height="32"></a></p>
 <!--sponsorsend-->
 
 ## Technology Sponsors
diff --git a/docs/package.json b/docs/package.json
index 15cab3134..e04a56f13 100644
--- a/docs/package.json
+++ b/docs/package.json
@@ -1,7 +1,7 @@
 {
     "name": "docs-eslint",
     "private": true,
-    "version": "8.48.0",
+    "version": "8.49.0",
     "description": "",
     "main": "index.js",
     "keywords": [],
diff --git a/docs/src/_includes/layouts/doc.html b/docs/src/_includes/layouts/doc.html
index 4050a9010..58d8986a5 100644
--- a/docs/src/_includes/layouts/doc.html
+++ b/docs/src/_includes/layouts/doc.html
@@ -19,6 +19,22 @@ layout: base.html
     {% set added_version = rule_versions.added[title] %}
     {% set removed_version = rule_versions.removed[title] %}
 
+    {% if handled_by_typescript %}
+        {% set handled_by_typescript_content %}
+            <h2 id="handled_by_typescript">Handled by TypeScript</h2>
+            <p>
+                It is safe to disable this rule when using TypeScript because TypeScript's compiler enforces this check.
+            </p>
+            {% if extra_typescript_info %}
+                <p>
+                    {{ extra_typescript_info | markdown | safe }}
+                </p>
+            {% endif %}
+        {% endset %}
+
+        {% set all_content = [all_content, handled_by_typescript_content] | join %}
+    {% endif %}
+
     {% if related_rules %}
         {% set related_rules_content %}
             <h2 id="related-rules">Related Rules</h2>
@@ -48,7 +64,7 @@ layout: base.html
 
         {% set all_content = [all_content, further_reading_content] | join %}
     {% endif %}
-        
+
     {% if rule_meta %}
         {% set resources_content %}
             <h2 id="resources">Resources</h2>
@@ -76,7 +92,7 @@ layout: base.html
                 {% endif %}
 
                 {% include 'components/docs-toc.html' %}
-                
+
                 {{ all_content | safe }}
             </div>
 
@@ -102,6 +118,7 @@ layout: base.html
             {% include "partials/docs-footer.html" %}
         </div>
     </div>
+
     <a id="scroll-up-btn" href="#site_top">
         <svg fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 24 24" width="24"><line x1="12" x2="12" y1="19" y2="5"/><polyline points="5 12 12 5 19 12"/></svg>
     </a>
diff --git a/docs/src/extend/code-path-analysis.md b/docs/src/extend/code-path-analysis.md
index 7344f8647..879119574 100644
--- a/docs/src/extend/code-path-analysis.md
+++ b/docs/src/extend/code-path-analysis.md
@@ -37,7 +37,7 @@ This has references of both the initial segment and the final segments of a code
 * `finalSegments` (`CodePathSegment[]`) - The final segments which includes both returned and thrown.
 * `returnedSegments` (`CodePathSegment[]`) - The final segments which includes only returned.
 * `thrownSegments` (`CodePathSegment[]`) - The final segments which includes only thrown.
-* `currentSegments` (`CodePathSegment[]`) - Segments of the current position.
+* `currentSegments` (`CodePathSegment[]`) - **Deprecated.** Segments of the current traversal position.
 * `upper` (`CodePath|null`) - The code path of the upper function/global scope.
 * `childCodePaths` (`CodePath[]`) - Code paths of functions this code path contains.
 
@@ -56,77 +56,110 @@ Difference from doubly linked list is what there are forking and merging (the ne
 
 ## Events
 
-There are five events related to code paths, and you can define event handlers in rules.
+There are seven events related to code paths, and you can define event handlers by adding them alongside node visitors in the object exported from the `create()` method of your rule.
 
 ```js
-module.exports = function(context) {
-    return {
-        /**
-         * This is called at the start of analyzing a code path.
-         * In this time, the code path object has only the initial segment.
-         *
-         * @param {CodePath} codePath - The new code path.
-         * @param {ASTNode} node - The current node.
-         * @returns {void}
-         */
-        "onCodePathStart": function(codePath, node) {
-            // do something with codePath
-        },
-
-        /**
-         * This is called at the end of analyzing a code path.
-         * In this time, the code path object is complete.
-         *
-         * @param {CodePath} codePath - The completed code path.
-         * @param {ASTNode} node - The current node.
-         * @returns {void}
-         */
-        "onCodePathEnd": function(codePath, node) {
-            // do something with codePath
-        },
-
-        /**
-         * This is called when a code path segment was created.
-         * It meant the code path is forked or merged.
-         * In this time, the segment has the previous segments and has been
-         * judged reachable or not.
-         *
-         * @param {CodePathSegment} segment - The new code path segment.
-         * @param {ASTNode} node - The current node.
-         * @returns {void}
-         */
-        "onCodePathSegmentStart": function(segment, node) {
-            // do something with segment
-        },
-
-        /**
-         * This is called when a code path segment was left.
-         * In this time, the segment does not have the next segments yet.
-         *
-         * @param {CodePathSegment} segment - The left code path segment.
-         * @param {ASTNode} node - The current node.
-         * @returns {void}
-         */
-        "onCodePathSegmentEnd": function(segment, node) {
-            // do something with segment
-        },
-
-        /**
-         * This is called when a code path segment was looped.
-         * Usually segments have each previous segments when created,
-         * but when looped, a segment is added as a new previous segment into a
-         * existing segment.
-         *
-         * @param {CodePathSegment} fromSegment - A code path segment of source.
-         * @param {CodePathSegment} toSegment - A code path segment of destination.
-         * @param {ASTNode} node - The current node.
-         * @returns {void}
-         */
-        "onCodePathSegmentLoop": function(fromSegment, toSegment, node) {
-            // do something with segment
-        }
-    };
-};
+module.exports = {
+    meta: {
+        // ...
+    },
+    create(context) {
+
+        return {
+            /**
+             * This is called at the start of analyzing a code path.
+             * In this time, the code path object has only the initial segment.
+             *
+             * @param {CodePath} codePath - The new code path.
+             * @param {ASTNode} node - The current node.
+             * @returns {void}
+             */
+            onCodePathStart(codePath, node) {
+                // do something with codePath
+            },
+
+            /**
+             * This is called at the end of analyzing a code path.
+             * In this time, the code path object is complete.
+             *
+             * @param {CodePath} codePath - The completed code path.
+             * @param {ASTNode} node - The current node.
+             * @returns {void}
+             */
+            onCodePathEnd(codePath, node) {
+                // do something with codePath
+            },
+
+            /**
+             * This is called when a reachable code path segment was created.
+             * It meant the code path is forked or merged.
+             * In this time, the segment has the previous segments and has been
+             * judged reachable or not.
+             *
+             * @param {CodePathSegment} segment - The new code path segment.
+             * @param {ASTNode} node - The current node.
+             * @returns {void}
+             */
+            onCodePathSegmentStart(segment, node) {
+                // do something with segment
+            },
+
+            /**
+             * This is called when a reachable code path segment was left.
+             * In this time, the segment does not have the next segments yet.
+             *
+             * @param {CodePathSegment} segment - The left code path segment.
+             * @param {ASTNode} node - The current node.
+             * @returns {void}
+             */
+            onCodePathSegmentEnd(segment, node) {
+                // do something with segment
+            },
+
+            /**
+             * This is called when an unreachable code path segment was created.
+             * It meant the code path is forked or merged.
+             * In this time, the segment has the previous segments and has been
+             * judged reachable or not.
+             *
+             * @param {CodePathSegment} segment - The new code path segment.
+             * @param {ASTNode} node - The current node.
+             * @returns {void}
+             */
+            onUnreachableCodePathSegmentStart(segment, node) {
+                // do something with segment
+            },
+
+            /**
+             * This is called when an unreachable code path segment was left.
+             * In this time, the segment does not have the next segments yet.
+             *
+             * @param {CodePathSegment} segment - The left code path segment.
+             * @param {ASTNode} node - The current node.
+             * @returns {void}
+             */
+            onUnreachableCodePathSegmentEnd(segment, node) {
+                // do something with segment
+            },
+
+            /**
+             * This is called when a code path segment was looped.
+             * Usually segments have each previous segments when created,
+             * but when looped, a segment is added as a new previous segment into a
+             * existing segment.
+             *
+             * @param {CodePathSegment} fromSegment - A code path segment of source.
+             * @param {CodePathSegment} toSegment - A code path segment of destination.
+             * @param {ASTNode} node - The current node.
+             * @returns {void}
+             */
+            onCodePathSegmentLoop(fromSegment, toSegment, node) {
+                // do something with segment
+            }
+        };
+
+    }
+}
 ```
 
 ### About `onCodePathSegmentLoop`
@@ -212,35 +245,134 @@ bar();
 
 ## Usage Examples
 
-### To check whether or not this is reachable
+### Track current segment position
+
+To track the current code path segment position, you can define a rule like this:
 
 ```js
-function isReachable(segment) {
-    return segment.reachable;
-}
+module.exports = {
+    meta: {
+        // ...
+    },
+    create(context) {
+
+        // tracks the code path we are currently in
+        let currentCodePath;
+
+        // tracks the segments we've traversed in the current code path
+        let currentSegments;
+
+        // tracks all current segments for all open paths
+        const allCurrentSegments = [];
+
+        return {
+
+            onCodePathStart(codePath) {
+                currentCodePath = codePath;
+                allCurrentSegments.push(currentSegments);
+                currentSegments = new Set();
+            },
+
+            onCodePathEnd(codePath) {
+                currentCodePath = codePath.upper;
+                currentSegments = allCurrentSegments.pop();
+            },
+
+            onCodePathSegmentStart(segment) {
+                currentSegments.add(segment);
+            },
+
+            onCodePathSegmentEnd(segment) {
+                currentSegments.delete(segment);
+            },
 
-module.exports = function(context) {
-    var codePathStack = [];
-
-    return {
-        // Stores CodePath objects.
-        "onCodePathStart": function(codePath) {
-            codePathStack.push(codePath);
-        },
-        "onCodePathEnd": function(codePath) {
-            codePathStack.pop();
-        },
-
-        // Checks reachable or not.
-        "ExpressionStatement": function(node) {
-            var codePath = codePathStack[codePathStack.length - 1];
-
-            // Checks the current code path segments.
-            if (!codePath.currentSegments.some(isReachable)) {
-                context.report({message: "Unreachable!", node: node});
+            onUnreachableCodePathSegmentStart(segment) {
+                currentSegments.add(segment);
+            },
+
+            onUnreachableCodePathSegmentEnd(segment) {
+                currentSegments.delete(segment);
             }
+        };
+
+    }
+};
+```
+
+In this example, the `currentCodePath` variable is used to access the code path that is currently being traversed and the `currentSegments` variable tracks the segments in that code path that have been traversed to that point. Note that `currentSegments` both starts and ends as an empty set, constantly being updated as the traversal progresses.
+
+Tracking the current segment position is helpful for analyzing the code path that led to a particular node, as in the next example.
+
+### Find an unreachable node
+
+To find an unreachable node, track the current segment position and then use a node visitor to check if any of the segments are reachable. For example, the following looks for any `ExpressionStatement` that is unreachable.
+
+```js
+function areAnySegmentsReachable(segments) {
+    for (const segment of segments) {
+        if (segment.reachable) {
+            return true;
         }
-    };
+    }
+
+    return false;
+}
+
+module.exports = {
+    meta: {
+        // ...
+    },
+    create(context) {
+
+        // tracks the code path we are currently in
+        let currentCodePath;
+
+        // tracks the segments we've traversed in the current code path
+        let currentSegments;
+
+        // tracks all current segments for all open paths
+        const allCurrentSegments = [];
+
+        return {
+
+            onCodePathStart(codePath) {
+                currentCodePath = codePath;
+                allCurrentSegments.push(currentSegments);
+                currentSegments = new Set();
+            },
+
+            onCodePathEnd(codePath) {
+                currentCodePath = codePath.upper;
+                currentSegments = allCurrentSegments.pop();
+            },
+
+            onCodePathSegmentStart(segment) {
+                currentSegments.add(segment);
+            },
+
+            onCodePathSegmentEnd(segment) {
+                currentSegments.delete(segment);
+            },
+
+            onUnreachableCodePathSegmentStart(segment) {
+                currentSegments.add(segment);
+            },
+
+            onUnreachableCodePathSegmentEnd(segment) {
+                currentSegments.delete(segment);
+            },
+
+            ExpressionStatement(node) {
+
+                // check all the code path segments that led to this node
+                if (!areAnySegmentsReachable(currentSegments)) {
+                    context.report({ message: "Unreachable!", node });
+                }
+            }
+
+        };
+
+    }
 };
 ```
 
@@ -249,9 +381,9 @@ See Also:
 [no-fallthrough](https://github.com/eslint/eslint/blob/HEAD/lib/rules/no-fallthrough.js),
 [consistent-return](https://github.com/eslint/eslint/blob/HEAD/lib/rules/consistent-return.js)
 
-### To check state of a code path
+### Check if a function is called in every path
 
-This example is checking whether or not the parameter `cb` is called in every path.
+This example checks whether or not the parameter `cb` is called in every path.
 Instances of `CodePath` and `CodePathSegment` are shared to every rule.
 So a rule must not modify those instances.
 Please use a map of information instead.
@@ -271,75 +403,101 @@ function isCbCalled(info) {
     return info.cbCalled;
 }
 
-module.exports = function(context) {
-    var funcInfoStack = [];
-    var segmentInfoMap = Object.create(null);
-
-    return {
-        // Checks `cb`.
-        "onCodePathStart": function(codePath, node) {
-            funcInfoStack.push({
-                codePath: codePath,
-                hasCb: hasCb(node, context)
-            });
-        },
-        "onCodePathEnd": function(codePath, node) {
-            funcInfoStack.pop();
-
-            // Checks `cb` was called in every paths.
-            var cbCalled = codePath.finalSegments.every(function(segment) {
-                var info = segmentInfoMap[segment.id];
-                return info.cbCalled;
-            });
-
-            if (!cbCalled) {
-                context.report({
-                    message: "`cb` should be called in every path.",
-                    node: node
+module.exports = {
+    meta: {
+        // ...
+    },
+    create(context) {
+
+        let funcInfo;
+        const funcInfoStack = [];
+        const segmentInfoMap = Object.create(null);
+
+        return {
+            // Checks `cb`.
+            onCodePathStart(codePath, node) {
+                funcInfoStack.push(funcInfo);
+
+                funcInfo = {
+                    codePath: codePath,
+                    hasCb: hasCb(node, context),
+                    currentSegments: new Set()
+                };
+            },
+
+            onCodePathEnd(codePath, node) {
+                funcInfo = funcInfoStack.pop();
+
+                // Checks `cb` was called in every paths.
+                const cbCalled = codePath.finalSegments.every(function(segment) {
+                    const info = segmentInfoMap[segment.id];
+                    return info.cbCalled;
                 });
-            }
-        },
-
-        // Manages state of code paths.
-        "onCodePathSegmentStart": function(segment) {
-            var funcInfo = funcInfoStack[funcInfoStack.length - 1];
 
-            // Ignores if `cb` doesn't exist.
-            if (!funcInfo.hasCb) {
-                return;
+                if (!cbCalled) {
+                    context.report({
+                        message: "`cb` should be called in every path.",
+                        node: node
+                    });
+                }
+            },
+
+            // Manages state of code paths and tracks traversed segments
+            onCodePathSegmentStart(segment) {
+
+                funcInfo.currentSegments.add(segment);
+
+                // Ignores if `cb` doesn't exist.
+                if (!funcInfo.hasCb) {
+                    return;
+                }
+
+                // Initialize state of this path.
+                const info = segmentInfoMap[segment.id] = {
+                    cbCalled: false
+                };
+
+                // If there are the previous paths, merges state.
+                // Checks `cb` was called in every previous path.
+                if (segment.prevSegments.length > 0) {
+                    info.cbCalled = segment.prevSegments.every(isCbCalled);
+                }
+            },
+
+            // Tracks unreachable segment traversal
+            onUnreachableCodePathSegmentStart(segment) {
+                funcInfo.currentSegments.add(segment);
+            },
+
+            // Tracks reachable segment traversal
+            onCodePathSegmentEnd(segment) {
+                funcInfo.currentSegments.delete(segment);
+            },
+
+            // Tracks unreachable segment traversal
+            onUnreachableCodePathSegmentEnd(segment) {
+                funcInfo.currentSegments.delete(segment);
+            },
+
+            // Checks reachable or not.
+            CallExpression(node) {
+
+                // Ignores if `cb` doesn't exist.
+                if (!funcInfo.hasCb) {
+                    return;
+                }
+
+                // Sets marks that `cb` was called.
+                const callee = node.callee;
+                if (callee.type === "Identifier" && callee.name === "cb") {
+                    funcInfo.currentSegments.forEach(segment => {
+                        const info = segmentInfoMap[segment.id];
+                        info.cbCalled = true;
+                    });
+                }
             }
-
-            // Initialize state of this path.
-            var info = segmentInfoMap[segment.id] = {
-                cbCalled: false
-            };
-
-            // If there are the previous paths, merges state.
-            // Checks `cb` was called in every previous path.
-            if (segment.prevSegments.length > 0) {
-                info.cbCalled = segment.prevSegments.every(isCbCalled);
-            }
-        },
-
-        // Checks reachable or not.
-        "CallExpression": function(node) {
-            var funcInfo = funcInfoStack[funcInfoStack.length - 1];
-
-            // Ignores if `cb` doesn't exist.
-            if (!funcInfo.hasCb) {
-                return;
-            }
-
-            // Sets marks that `cb` was called.
-            var callee = node.callee;
-            if (callee.type === "Identifier" && callee.name === "cb") {
-                funcInfo.codePath.currentSegments.forEach(function(segment) {
-                    var info = segmentInfoMap[segment.id];
-                    info.cbCalled = true;
-                });
-            }
-        }
-    };
+        };
+    }
 };
 ```
 
diff --git a/docs/src/rules/constructor-super.md b/docs/src/rules/constructor-super.md
index c172b0a7c..7c19df77d 100644
--- a/docs/src/rules/constructor-super.md
+++ b/docs/src/rules/constructor-super.md
@@ -1,6 +1,7 @@
 ---
 title: constructor-super
 rule_type: problem
+handled_by_typescript: true
 ---
 
 Constructors of derived classes must call `super()`.
@@ -69,5 +70,3 @@ class A extends B {
 ## When Not To Use It
 
 If you don't want to be notified about invalid/missing `super()` callings in constructors, you can safely disable this rule.
-
-It is safe to disable this rule when using TypeScript because TypeScript's compiler enforces this check (`ts(2335) & ts(2377)`).
diff --git a/docs/src/rules/getter-return.md b/docs/src/rules/getter-return.md
index 0c8937d14..9d316303d 100644
--- a/docs/src/rules/getter-return.md
+++ b/docs/src/rules/getter-return.md
@@ -1,6 +1,7 @@
 ---
 title: getter-return
 rule_type: problem
+handled_by_typescript: true
 further_reading:
 - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get
 - https://leanpub.com/understandinges6/read/#leanpub-auto-accessor-properties
diff --git a/docs/src/rules/lines-between-class-members.md b/docs/src/rules/lines-between-class-members.md
index 8daf2a2f7..556275010 100644
--- a/docs/src/rules/lines-between-class-members.md
+++ b/docs/src/rules/lines-between-class-members.md
@@ -69,14 +69,19 @@ class MyClass {
 
 ### Options
 
-This rule has a string option and an object option.
+This rule has two options, first option can be string or object, second option is object.
 
-String option:
+First option can be string `"always"` or `"never"` or an object with a property named `enforce`:
 
 * `"always"`(default) require an empty line after class members
 * `"never"` disallows an empty line after class members
+* `Object`: An object with a property named `enforce`. The enforce property should be an array of objects, each specifying the configuration for enforcing empty lines between specific pairs of class members.
+    * **enforce**: You can supply any number of configurations. If a member pair matches multiple configurations, the last matched configuration will be used. If a member pair does not match any configurations, it will be ignored. Each object should have the following properties:
+        * **blankLine**: Can be set to either `"always"` or `"never"`, indicating whether a blank line should be required or disallowed between the specified members.
+        * **prev**: Specifies the type of the preceding class member. It can be `"method"` for class methods, `"field"` for class fields, or `"*"` for any class member.
+        * **next**: Specifies the type of the following class member. It follows the same options as `prev`.
 
-Object option:
+Second option is an object with a property named `exceptAfterSingleLine`:
 
 * `"exceptAfterSingleLine": false`(default) **do not** skip checking empty lines after single-line class members
 * `"exceptAfterSingleLine": true` skip checking empty lines after single-line class members
@@ -129,6 +134,146 @@ class Foo{
 
 :::
 
+Examples of **incorrect** code for this rule with the array of configurations option:
+
+::: incorrect
+
+```js
+// disallows blank lines between methods
+/*eslint lines-between-class-members: [
+    "error",
+    {
+      enforce: [
+        { blankLine: "never", prev: "method", next: "method" }
+      ]
+    },
+]*/
+
+class MyClass {
+  constructor(height, width) {
+      this.height = height;
+      this.width = width;
+  }
+
+  fieldA = 'Field A';
+  #fieldB = 'Field B';
+
+  method1() {}
+
+  get area() {
+    return this.method1();
+  }
+
+  method2() {}
+}
+```
+
+:::
+
+::: incorrect
+
+```js
+// requires blank lines around fields, disallows blank lines between methods
+/*eslint lines-between-class-members: [
+    "error",
+    {
+      enforce: [
+        { blankLine: "always", prev: "*", next: "field" },
+        { blankLine: "always", prev: "field", next: "*" },
+        { blankLine: "never", prev: "method", next: "method" }
+      ]
+    },
+]*/
+
+class MyClass {
+  constructor(height, width) {
+      this.height = height;
+      this.width = width;
+  }
+  fieldA = 'Field A';
+  #fieldB = 'Field B';
+  method1() {}
+
+  get area() {
+    return this.method1();
+  }
+
+  method2() {}
+}
+```
+
+:::
+
+Examples of **correct** code for this rule with the array of configurations option:
+
+::: correct
+
+```js
+// disallows blank lines between methods
+/*eslint lines-between-class-members: [
+    "error",
+    {
+      enforce: [
+        { blankLine: "never", prev: "method", next: "method" }
+      ]
+    },
+]*/
+
+class MyClass {
+  constructor(height, width) {
+      this.height = height;
+      this.width = width;
+  }
+
+  fieldA = 'Field A';
+
+  #fieldB = 'Field B';
+
+  method1() {}
+  get area() {
+    return this.method1();
+  }
+  method2() {}
+}
+```
+
+:::
+
+::: correct
+
+```js
+// requires blank lines around fields, disallows blank lines between methods
+/*eslint lines-between-class-members: [
+    "error",
+    {
+      enforce: [
+        { blankLine: "always", prev: "*", next: "field" },
+        { blankLine: "always", prev: "field", next: "*" },
+        { blankLine: "never", prev: "method", next: "method" }
+      ]
+    },
+]*/
+
+class MyClass {
+  constructor(height, width) {
+      this.height = height;
+      this.width = width;
+  }
+
+  fieldA = 'Field A';
+
+  #fieldB = 'Field B';
+
+  method1() {}
+  get area() {
+    return this.method1();
+  }
+  method2() {}
+}
+```
+
+:::
+
 Examples of **correct** code for this rule with the object option:
 
 ::: correct
@@ -148,6 +293,40 @@ class Foo{
 
 :::
 
+::: correct
+
+```js
+/*eslint lines-between-class-members: [
+    "error",
+    {
+      enforce: [
+        { blankLine: "always", prev: "*", next: "method" },
+        { blankLine: "always", prev: "method", next: "*" },
+        { blankLine: "always", prev: "field", next: "field" }
+      ]
+    },
+    { exceptAfterSingleLine: true }
+]*/
+
+class MyClass {
+  constructor(height, width) {
+      this.height = height;
+      this.width = width;
+  }
+
+  fieldA = 'Field A';
+  #fieldB = 'Field B';
+  method1() {}
+  get area() {
+    return this.method1();
+  }
+
+  method2() {}
+}
+```
+
+:::
+
 ## When Not To Use It
 
 If you don't want to enforce empty lines between class members, you can disable this rule.
diff --git a/docs/src/rules/no-const-assign.md b/docs/src/rules/no-const-assign.md
index f9f0ed172..ca62132a7 100644
--- a/docs/src/rules/no-const-assign.md
+++ b/docs/src/rules/no-const-assign.md
@@ -1,6 +1,7 @@
 ---
 title: no-const-assign
 rule_type: problem
+handled_by_typescript: true
 ---
 
 
diff --git a/docs/src/rules/no-dupe-args.md b/docs/src/rules/no-dupe-args.md
index 79f791c46..3cb9133c8 100644
--- a/docs/src/rules/no-dupe-args.md
+++ b/docs/src/rules/no-dupe-args.md
@@ -1,6 +1,7 @@
 ---
 title: no-dupe-args
 rule_type: problem
+handled_by_typescript: true
 ---
 
 
diff --git a/docs/src/rules/no-dupe-class-members.md b/docs/src/rules/no-dupe-class-members.md
index d50a7fe74..216f3c9fe 100644
--- a/docs/src/rules/no-dupe-class-members.md
+++ b/docs/src/rules/no-dupe-class-members.md
@@ -1,6 +1,7 @@
 ---
 title: no-dupe-class-members
 rule_type: problem
+handled_by_typescript: true
 ---
 
 
@@ -101,5 +102,3 @@ class Foo {
 This rule should not be used in ES3/5 environments.
 
 In ES2015 (ES6) or later, if you don't want to be notified about duplicate names in class members, you can safely disable this rule.
-
-It is safe to disable this rule when using TypeScript because TypeScript's compiler enforces this check (`ts(2300) & ts(2393)`).
diff --git a/docs/src/rules/no-dupe-keys.md b/docs/src/rules/no-dupe-keys.md
index 75fc9491f..1527bf8f1 100644
--- a/docs/src/rules/no-dupe-keys.md
+++ b/docs/src/rules/no-dupe-keys.md
@@ -1,6 +1,7 @@
 ---
 title: no-dupe-keys
 rule_type: problem
+handled_by_typescript: true
 ---
 
 
diff --git a/docs/src/rules/no-func-assign.md b/docs/src/rules/no-func-assign.md
index ffbcb46c6..a0f146203 100644
--- a/docs/src/rules/no-func-assign.md
+++ b/docs/src/rules/no-func-assign.md
@@ -1,6 +1,7 @@
 ---
 title: no-func-assign
 rule_type: problem
+handled_by_typescript: true
 ---
 
 
diff --git a/docs/src/rules/no-import-assign.md b/docs/src/rules/no-import-assign.md
index ca4b912de..b0a7432bb 100644
--- a/docs/src/rules/no-import-assign.md
+++ b/docs/src/rules/no-import-assign.md
@@ -1,6 +1,8 @@
 ---
 title: no-import-assign
 rule_type: problem
+handled_by_typescript: true
+extra_typescript_info: Note that the compiler will not catch the `Object.assign()` case. Thus, if you use `Object.assign()` in your codebase, this rule will still provide some value.
 ---
 
 
diff --git a/docs/src/rules/no-invalid-this.md b/docs/src/rules/no-invalid-this.md
index f3aa6ed76..9e4a2aedf 100644
--- a/docs/src/rules/no-invalid-this.md
+++ b/docs/src/rules/no-invalid-this.md
@@ -1,6 +1,8 @@
 ---
 title: no-invalid-this
 rule_type: suggestion
+handled_by_typescript: true
+extra_typescript_info: Note that, technically, TypeScript will only catch this if you have the `strict` or `noImplicitThis` flags enabled. These are enabled in most TypeScript projects, since they are considered to be best practice.
 ---
 
 
diff --git a/docs/src/rules/no-new-symbol.md b/docs/src/rules/no-new-symbol.md
index 44c34a4ee..d557811f3 100644
--- a/docs/src/rules/no-new-symbol.md
+++ b/docs/src/rules/no-new-symbol.md
@@ -1,6 +1,7 @@
 ---
 title: no-new-symbol
 rule_type: problem
+handled_by_typescript: true
 further_reading:
 - https://www.ecma-international.org/ecma-262/6.0/#sec-symbol-objects
 ---
diff --git a/docs/src/rules/no-obj-calls.md b/docs/src/rules/no-obj-calls.md
index 8d72e4ce2..2fde92e5c 100644
--- a/docs/src/rules/no-obj-calls.md
+++ b/docs/src/rules/no-obj-calls.md
@@ -1,6 +1,7 @@
 ---
 title: no-obj-calls
 rule_type: problem
+handled_by_typescript: true
 further_reading:
 - https://es5.github.io/#x15.8
 ---
diff --git a/docs/src/rules/no-promise-executor-return.md b/docs/src/rules/no-promise-executor-return.md
index d82e44734..f163d9ebf 100644
--- a/docs/src/rules/no-promise-executor-return.md
+++ b/docs/src/rules/no-promise-executor-return.md
@@ -38,6 +38,7 @@ Examples of **incorrect** code for this rule:
 
 ```js
 /*eslint no-promise-executor-return: "error"*/
+/*eslint-env es6*/
 
 new Promise((resolve, reject) => {
     if (someCondition) {
@@ -75,6 +76,7 @@ Examples of **correct** code for this rule:
 
 ```js
 /*eslint no-promise-executor-return: "error"*/
+/*eslint-env es6*/
 
 // Turn return inline into two lines
 new Promise((resolve, reject) => {
@@ -123,6 +125,7 @@ Examples of **correct** code for this rule with the `{ "allowVoid": true }` opti
 
 ```js
 /*eslint no-promise-executor-return: ["error", { allowVoid: true }]*/
+/*eslint-env es6*/
 
 new Promise((resolve, reject) => {
     if (someCondition) {
diff --git a/docs/src/rules/no-redeclare.md b/docs/src/rules/no-redeclare.md
index e66f0570f..009ba889f 100644
--- a/docs/src/rules/no-redeclare.md
+++ b/docs/src/rules/no-redeclare.md
@@ -1,6 +1,8 @@
 ---
 title: no-redeclare
 rule_type: suggestion
+handled_by_typescript: true
+extra_typescript_info: Note that while TypeScript will catch `let` redeclares and `const` redeclares, it will not catch `var` redeclares. Thus, if you use the legacy `var` keyword in your TypeScript codebase, this rule will still provide some value.
 related_rules:
 - no-shadow
 ---
diff --git a/docs/src/rules/no-setter-return.md b/docs/src/rules/no-setter-return.md
index ceb4558c1..50353c754 100644
--- a/docs/src/rules/no-setter-return.md
+++ b/docs/src/rules/no-setter-return.md
@@ -1,6 +1,7 @@
 ---
 title: no-setter-return
 rule_type: problem
+handled_by_typescript: true
 related_rules:
 - getter-return
 further_reading:
diff --git a/docs/src/rules/no-this-before-super.md b/docs/src/rules/no-this-before-super.md
index f1425b5ed..c1a654796 100644
--- a/docs/src/rules/no-this-before-super.md
+++ b/docs/src/rules/no-this-before-super.md
@@ -1,6 +1,7 @@
 ---
 title: no-this-before-super
 rule_type: problem
+handled_by_typescript: true
 ---
 
 
diff --git a/docs/src/rules/no-undef.md b/docs/src/rules/no-undef.md
index 0bc7a2827..72ea516f9 100644
--- a/docs/src/rules/no-undef.md
+++ b/docs/src/rules/no-undef.md
@@ -1,6 +1,7 @@
 ---
 title: no-undef
 rule_type: problem
+handled_by_typescript: true
 related_rules:
 - no-global-assign
 - no-redeclare
diff --git a/docs/src/rules/no-unreachable.md b/docs/src/rules/no-unreachable.md
index 4f762084b..15f77f817 100644
--- a/docs/src/rules/no-unreachable.md
+++ b/docs/src/rules/no-unreachable.md
@@ -1,6 +1,7 @@
 ---
 title: no-unreachable
 rule_type: problem
+handled_by_typescript: true
 ---
 
 
diff --git a/docs/src/rules/no-unsafe-negation.md b/docs/src/rules/no-unsafe-negation.md
index 522e4ab4d..f3b495223 100644
--- a/docs/src/rules/no-unsafe-negation.md
+++ b/docs/src/rules/no-unsafe-negation.md
@@ -1,6 +1,7 @@
 ---
 title: no-unsafe-negation
 rule_type: problem
+handled_by_typescript: true
 ---
 
 
diff --git a/docs/src/use/command-line-interface.md b/docs/src/use/command-line-interface.md
index da4faf70e..d88e35cfa 100644
--- a/docs/src/use/command-line-interface.md
+++ b/docs/src/use/command-line-interface.md
@@ -110,7 +110,6 @@ Miscellaneous:
   --env-info                      Output execution environment information - default: false
   --no-error-on-unmatched-pattern  Prevent errors when pattern is unmatched
   --exit-on-fatal-error           Exit with exit code 2 in case of fatal error - default: false
-  --no-warn-ignored               Suppress warnings when the file list includes ignored files. *Flat Config Mode Only*
   --debug                         Output debugging information
   -h, --help                      Show help
   -v, --version                   Output the version number
@@ -704,18 +703,6 @@ This option causes ESLint to exit with exit code 2 if one or more fatal parsing
 npx eslint --exit-on-fatal-error file.js
 ```
 
-#### `--no-warn-ignored`
-
-**Flat Config Mode Only.** This option suppresses both `File ignored by default` and `File ignored because of a matching ignore pattern` warnings when an ignored filename is passed explicitly. It is useful when paired with `--max-warnings 0` as it will prevent exit code 1 due to the aforementioned warning.
-
-* **Argument Type**: No argument.
-
-##### `--no-warn-ignored` example
-
-```shell
-npx eslint --no-warn-ignored --max-warnings 0 ignored-file.js
-```
-
 #### `--debug`
 
 This option outputs debugging information to the console. Add this flag to an ESLint command line invocation in order to get extra debugging information while the command runs.
diff --git a/docs/src/use/configure/ignore.md b/docs/src/use/configure/ignore.md
index 16f1bfbcd..ffc23428e 100644
--- a/docs/src/use/configure/ignore.md
+++ b/docs/src/use/configure/ignore.md
@@ -149,7 +149,7 @@ You'll see this warning:
 
 ```text
 foo.js
-  0:0  warning  File ignored because of a matching ignore pattern. Use "--no-ignore" to disable file ignore settings or use "--no-warn-ignored" to suppress this warning.
+  0:0  warning  File ignored because of a matching ignore pattern. Use "--no-ignore" to override.
 
 âœ– 1 problem (0 errors, 1 warning)
 ```
diff --git a/docs/src/use/formatters/html-formatter-example.html b/docs/src/use/formatters/html-formatter-example.html
index 16db7f6d6..f1b577386 100644
--- a/docs/src/use/formatters/html-formatter-example.html
+++ b/docs/src/use/formatters/html-formatter-example.html
@@ -118,7 +118,7 @@
         <div id="overview" class="bg-2">
             <h1>ESLint Report</h1>
             <div>
-                <span>9 problems (5 errors, 4 warnings)</span> - Generated on Fri Aug 25 2023 16:01:24 GMT-0400 (Eastern Daylight Time)
+                <span>9 problems (5 errors, 4 warnings)</span> - Generated on Fri Sep 08 2023 16:22:14 GMT-0400 (Eastern Daylight Time)
             </div>
         </div>
         <table>
diff --git a/eslint.config.js b/eslint.config.js
index 214be713d..40ebe8c08 100644
--- a/eslint.config.js
+++ b/eslint.config.js
@@ -226,7 +226,6 @@ module.exports = [
         files: [INTERNAL_FILES.RULE_TESTER_PATTERN],
         rules: {
             "n/no-restricted-require": ["error", [
-                ...createInternalFilesPatterns(INTERNAL_FILES.RULE_TESTER_PATTERN),
                 resolveAbsolutePath("lib/cli-engine/index.js")
             ]]
         }
diff --git a/karma.conf.js b/karma.conf.js
deleted file mode 100644
index 606d13f88..000000000
--- a/karma.conf.js
+++ /dev/null
@@ -1,125 +0,0 @@
-"use strict";
-const os = require("os");
-const NodePolyfillPlugin = require("node-polyfill-webpack-plugin");
-
-if (os.platform === "linux" && os.arch() === "arm64") {
-
-    // For arm64 architecture, install chromium-browser using "apt-get install chromium-browser"
-    process.env.CHROME_BIN = "/usr/bin/chromium-browser";
-} else {
-    process.env.CHROME_BIN = require("puppeteer").executablePath();
-}
-
-module.exports = function(config) {
-    config.set({
-
-        // base path that will be used to resolve all patterns (eg. files, exclude)
-        basePath: "",
-
-        // next three sections allow console.log to work
-        client: {
-            captureConsole: true
-        },
-
-        browserConsoleLogOptions: {
-            terminal: true,
-            level: "log"
-        },
-
-        /*
-         * frameworks to use
-         * available frameworks: https://npmjs.org/browse/keyword/karma-adapter
-         */
-        frameworks: ["mocha", "webpack"],
-
-
-        // list of files / patterns to load in the browser
-        files: [
-            "tests/lib/linter/linter.js"
-        ],
-
-
-        // list of files to exclude
-        exclude: [
-        ],
-
-
-        /*
-         * preprocess matching files before serving them to the browser
-         * available preprocessors: https://npmjs.org/browse/keyword/karma-preprocessor
-         */
-        preprocessors: {
-            "tests/lib/linter/linter.js": ["webpack"]
-        },
-        webpack: {
-            mode: "none",
-            plugins: [
-                new NodePolyfillPlugin()
-            ],
-            resolve: {
-                alias: {
-                    "../../../lib/linter$": "../../../build/eslint.js"
-                }
-            },
-            stats: "errors-only"
-        },
-        webpackMiddleware: {
-            logLevel: "error"
-        },
-
-
-        /*
-         * test results reporter to use
-         * possible values: "dots", "progress"
-         * available reporters: https://npmjs.org/browse/keyword/karma-reporter
-         */
-        reporters: ["mocha"],
-
-        mochaReporter: {
-            output: "minimal"
-        },
-
-        // web server port
-        port: 9876,
-
-
-        // enable / disable colors in the output (reporters and logs)
-        colors: true,
-
-
-        /*
-         * level of logging
-         * possible values: config.LOG_DISABLE || config.LOG_ERROR || config.LOG_WARN || config.LOG_INFO || config.LOG_DEBUG
-         */
-        logLevel: config.LOG_INFO,
-
-
-        // enable / disable watching file and executing tests whenever any file changes
-        autoWatch: false,
-
-
-        /*
-         * start these browsers
-         * available browser launchers: https://npmjs.org/browse/keyword/karma-launcher
-         */
-        browsers: ["HeadlessChrome"],
-        customLaunchers: {
-            HeadlessChrome: {
-                base: "ChromeHeadless",
-                flags: ["--no-sandbox"]
-            }
-        },
-
-        /*
-         * Continuous Integration mode
-         * if true, Karma captures browsers, runs the tests and exits
-         */
-        singleRun: true,
-
-        /*
-         * Concurrency level
-         * how many browser should be started simultaneous
-         */
-        concurrency: Infinity
-    });
-};
diff --git a/lib/cli.js b/lib/cli.js
index 807d28a0d..a14930e9b 100644
--- a/lib/cli.js
+++ b/lib/cli.js
@@ -91,8 +91,7 @@ async function translateOptions({
     reportUnusedDisableDirectives,
     resolvePluginsRelativeTo,
     rule,
-    rulesdir,
-    warnIgnored
+    rulesdir
 }, configType) {
 
     let overrideConfig, overrideConfigFile;
@@ -183,7 +182,6 @@ async function translateOptions({
 
     if (configType === "flat") {
         options.ignorePatterns = ignorePattern;
-        options.warnIgnored = warnIgnored;
     } else {
         options.resolvePluginsRelativeTo = resolvePluginsRelativeTo;
         options.rulePaths = rulesdir;
@@ -387,9 +385,7 @@ const cli = {
         if (useStdin) {
             results = await engine.lintText(text, {
                 filePath: options.stdinFilename,
-
-                // flatConfig respects CLI flag and constructor warnIgnored, eslintrc forces true for backwards compatibility
-                warnIgnored: usingFlatConfig ? void 0 : true
+                warnIgnored: true
             });
         } else {
             results = await engine.lintFiles(files);
diff --git a/lib/config/rule-validator.js b/lib/config/rule-validator.js
index 0b5858fb3..eee5b40bd 100644
--- a/lib/config/rule-validator.js
+++ b/lib/config/rule-validator.js
@@ -9,7 +9,8 @@
 // Requirements
 //-----------------------------------------------------------------------------
 
-const ajv = require("../shared/ajv")();
+const ajvImport = require("../shared/ajv");
+const ajv = ajvImport();
 const {
     parseRuleId,
     getRuleFromConfig,
diff --git a/lib/eslint/eslint-helpers.js b/lib/eslint/eslint-helpers.js
index 72828363c..e25b10e8b 100644
--- a/lib/eslint/eslint-helpers.js
+++ b/lib/eslint/eslint-helpers.js
@@ -594,9 +594,9 @@ function createIgnoreResult(filePath, baseDir) {
     const isInNodeModules = baseDir && path.dirname(path.relative(baseDir, filePath)).split(path.sep).includes("node_modules");
 
     if (isInNodeModules) {
-        message = "File ignored by default because it is located under the node_modules directory. Use ignore pattern \"!**/node_modules/\" to disable file ignore settings or use \"--no-warn-ignored\" to suppress this warning.";
+        message = "File ignored by default because it is located under the node_modules directory. Use ignore pattern \"!**/node_modules/\" to override.";
     } else {
-        message = "File ignored because of a matching ignore pattern. Use \"--no-ignore\" to disable file ignore settings or use \"--no-warn-ignored\" to suppress this warning.";
+        message = "File ignored because of a matching ignore pattern. Use \"--no-ignore\" to override.";
     }
 
     return {
@@ -676,7 +676,6 @@ function processOptions({
     overrideConfigFile = null,
     plugins = {},
     reportUnusedDisableDirectives = null, // â† should be null by default because if it's a string then it overrides the 'reportUnusedDisableDirectives' setting in config files. And we cannot use `overrideConfig.reportUnusedDisableDirectives` instead because we cannot configure the `error` severity with that.
-    warnIgnored = true,
     ...unknownOptions
 }) {
     const errors = [];
@@ -782,9 +781,6 @@ function processOptions({
     ) {
         errors.push("'reportUnusedDisableDirectives' must be any of \"error\", \"warn\", \"off\", and null.");
     }
-    if (typeof warnIgnored !== "boolean") {
-        errors.push("'warnIgnored' must be a boolean.");
-    }
     if (errors.length > 0) {
         throw new ESLintInvalidOptionsError(errors);
     }
@@ -806,8 +802,7 @@ function processOptions({
         globInputPaths,
         ignore,
         ignorePatterns,
-        reportUnusedDisableDirectives,
-        warnIgnored
+        reportUnusedDisableDirectives
     };
 }
 
diff --git a/lib/eslint/flat-eslint.js b/lib/eslint/flat-eslint.js
index 306c80de1..4ef386113 100644
--- a/lib/eslint/flat-eslint.js
+++ b/lib/eslint/flat-eslint.js
@@ -84,7 +84,6 @@ const LintResultCache = require("../cli-engine/lint-result-cache");
  *      when a string.
  * @property {Record<string,Plugin>} [plugins] An array of plugin implementations.
  * @property {"error" | "warn" | "off"} [reportUnusedDisableDirectives] the severity to report unused eslint-disable directives.
- * @property {boolean} warnIgnored Show warnings when the file list includes ignored files
  */
 
 //------------------------------------------------------------------------------
@@ -750,8 +749,7 @@ class FlatESLint {
             fixTypes,
             reportUnusedDisableDirectives,
             globInputPaths,
-            errorOnUnmatchedPattern,
-            warnIgnored
+            errorOnUnmatchedPattern
         } = eslintOptions;
         const startTime = Date.now();
         const fixTypesSet = fixTypes ? new Set(fixTypes) : null;
@@ -797,11 +795,7 @@ class FlatESLint {
                  * pattern, then notify the user.
                  */
                 if (ignored) {
-                    if (warnIgnored) {
-                        return createIgnoreResult(filePath, cwd);
-                    }
-
-                    return void 0;
+                    return createIgnoreResult(filePath, cwd);
                 }
 
                 const config = configs.getConfig(filePath);
@@ -914,7 +908,7 @@ class FlatESLint {
 
         const {
             filePath,
-            warnIgnored,
+            warnIgnored = false,
             ...unknownOptions
         } = options || {};
 
@@ -928,7 +922,7 @@ class FlatESLint {
             throw new Error("'options.filePath' must be a non-empty string or undefined");
         }
 
-        if (typeof warnIgnored !== "boolean" && typeof warnIgnored !== "undefined") {
+        if (typeof warnIgnored !== "boolean") {
             throw new Error("'options.warnIgnored' must be a boolean or undefined");
         }
 
@@ -943,8 +937,7 @@ class FlatESLint {
             allowInlineConfig,
             cwd,
             fix,
-            reportUnusedDisableDirectives,
-            warnIgnored: constructorWarnIgnored
+            reportUnusedDisableDirectives
         } = eslintOptions;
         const results = [];
         const startTime = Date.now();
@@ -952,9 +945,7 @@ class FlatESLint {
 
         // Clear the last used config arrays.
         if (resolvedFilename && await this.isPathIgnored(resolvedFilename)) {
-            const shouldWarnIgnored = typeof warnIgnored === "boolean" ? warnIgnored : constructorWarnIgnored;
-
-            if (shouldWarnIgnored) {
+            if (warnIgnored) {
                 results.push(createIgnoreResult(resolvedFilename, cwd));
             }
         } else {
diff --git a/lib/linter/code-path-analysis/code-path-analyzer.js b/lib/linter/code-path-analysis/code-path-analyzer.js
index 2dcc27348..b60e55c16 100644
--- a/lib/linter/code-path-analysis/code-path-analyzer.js
+++ b/lib/linter/code-path-analysis/code-path-analyzer.js
@@ -192,15 +192,18 @@ function forwardCurrentToHead(analyzer, node) {
         headSegment = headSegments[i];
 
         if (currentSegment !== headSegment && currentSegment) {
-            debug.dump(`onCodePathSegmentEnd ${currentSegment.id}`);
 
-            if (currentSegment.reachable) {
-                analyzer.emitter.emit(
-                    "onCodePathSegmentEnd",
-                    currentSegment,
-                    node
-                );
-            }
+            const eventName = currentSegment.reachable
+                ? "onCodePathSegmentEnd"
+                : "onUnreachableCodePathSegmentEnd";
+
+            debug.dump(`${eventName} ${currentSegment.id}`);
+
+            analyzer.emitter.emit(
+                eventName,
+                currentSegment,
+                node
+            );
         }
     }
 
@@ -213,16 +216,19 @@ function forwardCurrentToHead(analyzer, node) {
         headSegment = headSegments[i];
 
         if (currentSegment !== headSegment && headSegment) {
-            debug.dump(`onCodePathSegmentStart ${headSegment.id}`);
+
+            const eventName = headSegment.reachable
+                ? "onCodePathSegmentStart"
+                : "onUnreachableCodePathSegmentStart";
+
+            debug.dump(`${eventName} ${headSegment.id}`);
 
             CodePathSegment.markUsed(headSegment);
-            if (headSegment.reachable) {
-                analyzer.emitter.emit(
-                    "onCodePathSegmentStart",
-                    headSegment,
-                    node
-                );
-            }
+            analyzer.emitter.emit(
+                eventName,
+                headSegment,
+                node
+            );
         }
     }
 
@@ -241,15 +247,17 @@ function leaveFromCurrentSegment(analyzer, node) {
 
     for (let i = 0; i < currentSegments.length; ++i) {
         const currentSegment = currentSegments[i];
+        const eventName = currentSegment.reachable
+            ? "onCodePathSegmentEnd"
+            : "onUnreachableCodePathSegmentEnd";
 
-        debug.dump(`onCodePathSegmentEnd ${currentSegment.id}`);
-        if (currentSegment.reachable) {
-            analyzer.emitter.emit(
-                "onCodePathSegmentEnd",
-                currentSegment,
-                node
-            );
-        }
+        debug.dump(`${eventName} ${currentSegment.id}`);
+
+        analyzer.emitter.emit(
+            eventName,
+            currentSegment,
+            node
+        );
     }
 
     state.currentSegments = [];
diff --git a/lib/linter/code-path-analysis/code-path.js b/lib/linter/code-path-analysis/code-path.js
index a028ca694..f6a88a00a 100644
--- a/lib/linter/code-path-analysis/code-path.js
+++ b/lib/linter/code-path-analysis/code-path.js
@@ -117,6 +117,7 @@ class CodePath {
     /**
      * Current code path segments.
      * @type {CodePathSegment[]}
+     * @deprecated
      */
     get currentSegments() {
         return this.internal.currentSegments;
diff --git a/lib/linter/linter.js b/lib/linter/linter.js
index 233cbed5b..48b2bdbe5 100644
--- a/lib/linter/linter.js
+++ b/lib/linter/linter.js
@@ -898,6 +898,7 @@ const DEPRECATED_SOURCECODE_PASSTHROUGHS = {
     getTokensBetween: "getTokensBetween"
 };
 
+
 const BASE_TRAVERSAL_CONTEXT = Object.freeze(
     Object.keys(DEPRECATED_SOURCECODE_PASSTHROUGHS).reduce(
         (contextInfo, methodName) =>
diff --git a/lib/options.js b/lib/options.js
index ae9a5d555..2bc4018af 100644
--- a/lib/options.js
+++ b/lib/options.js
@@ -55,7 +55,6 @@ const optionator = require("optionator");
  * @property {string} [stdinFilename] Specify filename to process STDIN as
  * @property {boolean} quiet Report errors only
  * @property {boolean} [version] Output the version number
- * @property {boolean} warnIgnored Show warnings when the file list includes ignored files
  * @property {string[]} _ Positional filenames or patterns
  */
 
@@ -140,17 +139,6 @@ module.exports = function(usingFlatConfig) {
         };
     }
 
-    let warnIgnoredFlag;
-
-    if (usingFlatConfig) {
-        warnIgnoredFlag = {
-            option: "warn-ignored",
-            type: "Boolean",
-            default: "true",
-            description: "Suppress warnings when the file list includes ignored files"
-        };
-    }
-
     return optionator({
         prepend: "eslint [options] file.js [file.js] [dir]",
         defaults: {
@@ -361,7 +349,6 @@ module.exports = function(usingFlatConfig) {
                 default: "false",
                 description: "Exit with exit code 2 in case of fatal error"
             },
-            warnIgnoredFlag,
             {
                 option: "debug",
                 type: "Boolean",
diff --git a/lib/rule-tester/flat-rule-tester.js b/lib/rule-tester/flat-rule-tester.js
index 5a93be1cc..d5f5981e6 100644
--- a/lib/rule-tester/flat-rule-tester.js
+++ b/lib/rule-tester/flat-rule-tester.js
@@ -16,7 +16,9 @@ const
     equal = require("fast-deep-equal"),
     Traverser = require("../shared/traverser"),
     { getRuleOptionsSchema } = require("../config/flat-config-helpers"),
-    { Linter, SourceCodeFixer, interpolate } = require("../linter");
+    { Linter, SourceCodeFixer, interpolate } = require("../linter"),
+    CodePath = require("../linter/code-path-analysis/code-path");
+
 const { FlatConfigArray } = require("../config/flat-config-array");
 const { defaultConfig } = require("../config/default-config");
 
@@ -274,6 +276,21 @@ function getCommentsDeprecation() {
     );
 }
 
+/**
+ * Emit a deprecation warning if rule uses CodePath#currentSegments.
+ * @param {string} ruleName Name of the rule.
+ * @returns {void}
+ */
+function emitCodePathCurrentSegmentsWarning(ruleName) {
+    if (!emitCodePathCurrentSegmentsWarning[`warned-${ruleName}`]) {
+        emitCodePathCurrentSegmentsWarning[`warned-${ruleName}`] = true;
+        process.emitWarning(
+            `"${ruleName}" rule uses CodePath#currentSegments and will stop working in ESLint v9. Please read the documentation for how to update your code: https://eslint.org/docs/latest/extend/code-path-analysis#usage-examples`,
+            "DeprecationWarning"
+        );
+    }
+}
+
 //------------------------------------------------------------------------------
 // Public Interface
 //------------------------------------------------------------------------------
@@ -664,6 +681,7 @@ class FlatRuleTester {
 
             // Verify the code.
             const { getComments } = SourceCode.prototype;
+            const originalCurrentSegments = Object.getOwnPropertyDescriptor(CodePath.prototype, "currentSegments");
             let messages;
 
             // check for validation errors
@@ -677,11 +695,20 @@ class FlatRuleTester {
 
             try {
                 SourceCode.prototype.getComments = getCommentsDeprecation;
+                Object.defineProperty(CodePath.prototype, "currentSegments", {
+                    get() {
+                        emitCodePathCurrentSegmentsWarning(ruleName);
+                        return originalCurrentSegments.get.call(this);
+                    }
+                });
+
                 messages = linter.verify(code, configs, filename);
             } finally {
                 SourceCode.prototype.getComments = getComments;
+                Object.defineProperty(CodePath.prototype, "currentSegments", originalCurrentSegments);
             }
 
+
             const fatalErrorMessage = messages.find(m => m.fatal);
 
             assert(!fatalErrorMessage, `A fatal parsing error occurred: ${fatalErrorMessage && fatalErrorMessage.message}`);
diff --git a/lib/rule-tester/rule-tester.js b/lib/rule-tester/rule-tester.js
index 030a98686..82d79790a 100644
--- a/lib/rule-tester/rule-tester.js
+++ b/lib/rule-tester/rule-tester.js
@@ -48,7 +48,8 @@ const
     equal = require("fast-deep-equal"),
     Traverser = require("../../lib/shared/traverser"),
     { getRuleOptionsSchema, validate } = require("../shared/config-validator"),
-    { Linter, SourceCodeFixer, interpolate } = require("../linter");
+    { Linter, SourceCodeFixer, interpolate } = require("../linter"),
+    CodePath = require("../linter/code-path-analysis/code-path");
 
 const ajv = require("../shared/ajv")({ strictDefaults: true });
 
@@ -164,6 +165,30 @@ const friendlySuggestionObjectParameterList = `[${[...suggestionObjectParameters
 
 const hasOwnProperty = Function.call.bind(Object.hasOwnProperty);
 
+const DEPRECATED_SOURCECODE_PASSTHROUGHS = {
+    getSource: "getText",
+    getSourceLines: "getLines",
+    getAllComments: "getAllComments",
+    getNodeByRangeIndex: "getNodeByRangeIndex",
+
+    // getComments: "getComments", -- already handled by a separate error
+    getCommentsBefore: "getCommentsBefore",
+    getCommentsAfter: "getCommentsAfter",
+    getCommentsInside: "getCommentsInside",
+    getJSDocComment: "getJSDocComment",
+    getFirstToken: "getFirstToken",
+    getFirstTokens: "getFirstTokens",
+    getLastToken: "getLastToken",
+    getLastTokens: "getLastTokens",
+    getTokenAfter: "getTokenAfter",
+    getTokenBefore: "getTokenBefore",
+    getTokenByRangeStart: "getTokenByRangeStart",
+    getTokens: "getTokens",
+    getTokensAfter: "getTokensAfter",
+    getTokensBefore: "getTokensBefore",
+    getTokensBetween: "getTokensBetween"
+};
+
 /**
  * Clones a given value deeply.
  * Note: This ignores `parent` property.
@@ -335,6 +360,37 @@ function emitMissingSchemaWarning(ruleName) {
     }
 }
 
+/**
+ * Emit a deprecation warning if a rule uses a deprecated `context` method.
+ * @param {string} ruleName Name of the rule.
+ * @param {string} methodName The name of the method on `context` that was used.
+ * @returns {void}
+ */
+function emitDeprecatedContextMethodWarning(ruleName, methodName) {
+    if (!emitDeprecatedContextMethodWarning[`warned-${ruleName}-${methodName}`]) {
+        emitDeprecatedContextMethodWarning[`warned-${ruleName}-${methodName}`] = true;
+        process.emitWarning(
+            `"${ruleName}" rule is using \`context.${methodName}()\`, which is deprecated and will be removed in ESLint v9. Please use \`sourceCode.${DEPRECATED_SOURCECODE_PASSTHROUGHS[methodName]}()\` instead.`,
+            "DeprecationWarning"
+        );
+    }
+}
+
+/**
+ * Emit a deprecation warning if rule uses CodePath#currentSegments.
+ * @param {string} ruleName Name of the rule.
+ * @returns {void}
+ */
+function emitCodePathCurrentSegmentsWarning(ruleName) {
+    if (!emitCodePathCurrentSegmentsWarning[`warned-${ruleName}`]) {
+        emitCodePathCurrentSegmentsWarning[`warned-${ruleName}`] = true;
+        process.emitWarning(
+            `"${ruleName}" rule uses CodePath#currentSegments and will stop working in ESLint v9. Please read the documentation for how to update your code: https://eslint.org/docs/latest/extend/code-path-analysis#usage-examples`,
+            "DeprecationWarning"
+        );
+    }
+}
+
 //------------------------------------------------------------------------------
 // Public Interface
 //------------------------------------------------------------------------------
@@ -566,7 +622,27 @@ class RuleTester {
                 freezeDeeply(context.settings);
                 freezeDeeply(context.parserOptions);
 
-                return (typeof rule === "function" ? rule : rule.create)(context);
+                const newContext = Object.freeze(
+                    Object.create(
+                        context,
+                        Object.fromEntries(Object.keys(DEPRECATED_SOURCECODE_PASSTHROUGHS).map(methodName => [
+                            methodName,
+                            {
+                                value(...args) {
+
+                                    // emit deprecation warning
+                                    emitDeprecatedContextMethodWarning(ruleName, methodName);
+
+                                    // call the original method
+                                    return context[methodName].call(this, ...args);
+                                },
+                                enumerable: true
+                            }
+                        ]))
+                    )
+                );
+
+                return (typeof rule === "function" ? rule : rule.create)(newContext);
             }
         }));
 
@@ -686,13 +762,22 @@ class RuleTester {
 
             // Verify the code.
             const { getComments } = SourceCode.prototype;
+            const originalCurrentSegments = Object.getOwnPropertyDescriptor(CodePath.prototype, "currentSegments");
             let messages;
 
             try {
                 SourceCode.prototype.getComments = getCommentsDeprecation;
+                Object.defineProperty(CodePath.prototype, "currentSegments", {
+                    get() {
+                        emitCodePathCurrentSegmentsWarning(ruleName);
+                        return originalCurrentSegments.get.call(this);
+                    }
+                });
+
                 messages = linter.verify(code, config, filename);
             } finally {
                 SourceCode.prototype.getComments = getComments;
+                Object.defineProperty(CodePath.prototype, "currentSegments", originalCurrentSegments);
             }
 
             const fatalErrorMessage = messages.find(m => m.fatal);
diff --git a/lib/rules/array-callback-return.js b/lib/rules/array-callback-return.js
index 05cd4ede9..24a33d16c 100644
--- a/lib/rules/array-callback-return.js
+++ b/lib/rules/array-callback-return.js
@@ -18,15 +18,6 @@ const astUtils = require("./utils/ast-utils");
 const TARGET_NODE_TYPE = /^(?:Arrow)?FunctionExpression$/u;
 const TARGET_METHODS = /^(?:every|filter|find(?:Last)?(?:Index)?|flatMap|forEach|map|reduce(?:Right)?|some|sort|toSorted)$/u;
 
-/**
- * Checks a given code path segment is reachable.
- * @param {CodePathSegment} segment A segment to check.
- * @returns {boolean} `true` if the segment is reachable.
- */
-function isReachable(segment) {
-    return segment.reachable;
-}
-
 /**
  * Checks a given node is a member access which has the specified name's
  * property.
@@ -38,6 +29,22 @@ function isTargetMethod(node) {
     return astUtils.isSpecificMemberAccess(node, null, TARGET_METHODS);
 }
 
+/**
+ * Checks all segments in a set and returns true if any are reachable.
+ * @param {Set<CodePathSegment>} segments The segments to check.
+ * @returns {boolean} True if any segment is reachable; false otherwise.
+ */
+function isAnySegmentReachable(segments) {
+
+    for (const segment of segments) {
+        if (segment.reachable) {
+            return true;
+        }
+    }
+
+    return false;
+}
+
 /**
  * Returns a human-legible description of an array method
  * @param {string} arrayMethodName A method name to fully qualify
@@ -205,7 +212,7 @@ module.exports = {
                     messageId = "expectedNoReturnValue";
                 }
             } else {
-                if (node.body.type === "BlockStatement" && funcInfo.codePath.currentSegments.some(isReachable)) {
+                if (node.body.type === "BlockStatement" && isAnySegmentReachable(funcInfo.currentSegments)) {
                     messageId = funcInfo.hasReturn ? "expectedAtEnd" : "expectedInside";
                 }
             }
@@ -242,7 +249,8 @@ module.exports = {
                         methodName &&
                         !node.async &&
                         !node.generator,
-                    node
+                    node,
+                    currentSegments: new Set()
                 };
             },
 
@@ -251,6 +259,23 @@ module.exports = {
                 funcInfo = funcInfo.upper;
             },
 
+            onUnreachableCodePathSegmentStart(segment) {
+                funcInfo.currentSegments.add(segment);
+            },
+
+            onUnreachableCodePathSegmentEnd(segment) {
+                funcInfo.currentSegments.delete(segment);
+            },
+
+            onCodePathSegmentStart(segment) {
+                funcInfo.currentSegments.add(segment);
+            },
+
+            onCodePathSegmentEnd(segment) {
+                funcInfo.currentSegments.delete(segment);
+            },
+
+
             // Checks the return statement is valid.
             ReturnStatement(node) {
 
diff --git a/lib/rules/consistent-return.js b/lib/rules/consistent-return.js
index e2d3f0782..304e924b1 100644
--- a/lib/rules/consistent-return.js
+++ b/lib/rules/consistent-return.js
@@ -16,12 +16,19 @@ const { upperCaseFirst } = require("../shared/string-utils");
 //------------------------------------------------------------------------------
 
 /**
- * Checks whether or not a given code path segment is unreachable.
- * @param {CodePathSegment} segment A CodePathSegment to check.
- * @returns {boolean} `true` if the segment is unreachable.
+ * Checks all segments in a set and returns true if all are unreachable.
+ * @param {Set<CodePathSegment>} segments The segments to check.
+ * @returns {boolean} True if all segments are unreachable; false otherwise.
  */
-function isUnreachable(segment) {
-    return !segment.reachable;
+function areAllSegmentsUnreachable(segments) {
+
+    for (const segment of segments) {
+        if (segment.reachable) {
+            return false;
+        }
+    }
+
+    return true;
 }
 
 /**
@@ -88,7 +95,7 @@ module.exports = {
              * When unreachable, all paths are returned or thrown.
              */
             if (!funcInfo.hasReturnValue ||
-                funcInfo.codePath.currentSegments.every(isUnreachable) ||
+                areAllSegmentsUnreachable(funcInfo.currentSegments) ||
                 astUtils.isES5Constructor(node) ||
                 isClassConstructor(node)
             ) {
@@ -141,13 +148,31 @@ module.exports = {
                     hasReturn: false,
                     hasReturnValue: false,
                     messageId: "",
-                    node
+                    node,
+                    currentSegments: new Set()
                 };
             },
             onCodePathEnd() {
                 funcInfo = funcInfo.upper;
             },
 
+            onUnreachableCodePathSegmentStart(segment) {
+                funcInfo.currentSegments.add(segment);
+            },
+
+            onUnreachableCodePathSegmentEnd(segment) {
+                funcInfo.currentSegments.delete(segment);
+            },
+
+            onCodePathSegmentStart(segment) {
+                funcInfo.currentSegments.add(segment);
+            },
+
+            onCodePathSegmentEnd(segment) {
+                funcInfo.currentSegments.delete(segment);
+            },
+
+
             // Reports a given return statement if it's inconsistent.
             ReturnStatement(node) {
                 const argument = node.argument;
diff --git a/lib/rules/constructor-super.js b/lib/rules/constructor-super.js
index 5f4058812..330be80f3 100644
--- a/lib/rules/constructor-super.js
+++ b/lib/rules/constructor-super.js
@@ -10,12 +10,19 @@
 //------------------------------------------------------------------------------
 
 /**
- * Checks whether a given code path segment is reachable or not.
- * @param {CodePathSegment} segment A code path segment to check.
- * @returns {boolean} `true` if the segment is reachable.
+ * Checks all segments in a set and returns true if any are reachable.
+ * @param {Set<CodePathSegment>} segments The segments to check.
+ * @returns {boolean} True if any segment is reachable; false otherwise.
  */
-function isReachable(segment) {
-    return segment.reachable;
+function isAnySegmentReachable(segments) {
+
+    for (const segment of segments) {
+        if (segment.reachable) {
+            return true;
+        }
+    }
+
+    return false;
 }
 
 /**
@@ -210,7 +217,8 @@ module.exports = {
                         isConstructor: true,
                         hasExtends: Boolean(superClass),
                         superIsConstructor: isPossibleConstructor(superClass),
-                        codePath
+                        codePath,
+                        currentSegments: new Set()
                     };
                 } else {
                     funcInfo = {
@@ -218,7 +226,8 @@ module.exports = {
                         isConstructor: false,
                         hasExtends: false,
                         superIsConstructor: false,
-                        codePath
+                        codePath,
+                        currentSegments: new Set()
                     };
                 }
             },
@@ -261,6 +270,9 @@ module.exports = {
              * @returns {void}
              */
             onCodePathSegmentStart(segment) {
+
+                funcInfo.currentSegments.add(segment);
+
                 if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) {
                     return;
                 }
@@ -281,6 +293,19 @@ module.exports = {
                 }
             },
 
+            onUnreachableCodePathSegmentStart(segment) {
+                funcInfo.currentSegments.add(segment);
+            },
+
+            onUnreachableCodePathSegmentEnd(segment) {
+                funcInfo.currentSegments.delete(segment);
+            },
+
+            onCodePathSegmentEnd(segment) {
+                funcInfo.currentSegments.delete(segment);
+            },
+
+
             /**
              * Update information of the code path segment when a code path was
              * looped.
@@ -344,12 +369,11 @@ module.exports = {
 
                 // Reports if needed.
                 if (funcInfo.hasExtends) {
-                    const segments = funcInfo.codePath.currentSegments;
+                    const segments = funcInfo.currentSegments;
                     let duplicate = false;
                     let info = null;
 
-                    for (let i = 0; i < segments.length; ++i) {
-                        const segment = segments[i];
+                    for (const segment of segments) {
 
                         if (segment.reachable) {
                             info = segInfoMap[segment.id];
@@ -374,7 +398,7 @@ module.exports = {
                             info.validNodes.push(node);
                         }
                     }
-                } else if (funcInfo.codePath.currentSegments.some(isReachable)) {
+                } else if (isAnySegmentReachable(funcInfo.currentSegments)) {
                     context.report({
                         messageId: "unexpected",
                         node
@@ -398,10 +422,9 @@ module.exports = {
                 }
 
                 // Returning argument is a substitute of 'super()'.
-                const segments = funcInfo.codePath.currentSegments;
+                const segments = funcInfo.currentSegments;
 
-                for (let i = 0; i < segments.length; ++i) {
-                    const segment = segments[i];
+                for (const segment of segments) {
 
                     if (segment.reachable) {
                         const info = segInfoMap[segment.id];
diff --git a/lib/rules/getter-return.js b/lib/rules/getter-return.js
index 622b6a754..79ebf3e09 100644
--- a/lib/rules/getter-return.js
+++ b/lib/rules/getter-return.js
@@ -14,15 +14,23 @@ const astUtils = require("./utils/ast-utils");
 //------------------------------------------------------------------------------
 // Helpers
 //------------------------------------------------------------------------------
+
 const TARGET_NODE_TYPE = /^(?:Arrow)?FunctionExpression$/u;
 
 /**
- * Checks a given code path segment is reachable.
- * @param {CodePathSegment} segment A segment to check.
- * @returns {boolean} `true` if the segment is reachable.
+ * Checks all segments in a set and returns true if any are reachable.
+ * @param {Set<CodePathSegment>} segments The segments to check.
+ * @returns {boolean} True if any segment is reachable; false otherwise.
  */
-function isReachable(segment) {
-    return segment.reachable;
+function isAnySegmentReachable(segments) {
+
+    for (const segment of segments) {
+        if (segment.reachable) {
+            return true;
+        }
+    }
+
+    return false;
 }
 
 //------------------------------------------------------------------------------
@@ -71,7 +79,8 @@ module.exports = {
             codePath: null,
             hasReturn: false,
             shouldCheck: false,
-            node: null
+            node: null,
+            currentSegments: []
         };
 
         /**
@@ -85,7 +94,7 @@ module.exports = {
          */
         function checkLastSegment(node) {
             if (funcInfo.shouldCheck &&
-                funcInfo.codePath.currentSegments.some(isReachable)
+                isAnySegmentReachable(funcInfo.currentSegments)
             ) {
                 context.report({
                     node,
@@ -144,7 +153,8 @@ module.exports = {
                     codePath,
                     hasReturn: false,
                     shouldCheck: isGetter(node),
-                    node
+                    node,
+                    currentSegments: new Set()
                 };
             },
 
@@ -152,6 +162,21 @@ module.exports = {
             onCodePathEnd() {
                 funcInfo = funcInfo.upper;
             },
+            onUnreachableCodePathSegmentStart(segment) {
+                funcInfo.currentSegments.add(segment);
+            },
+
+            onUnreachableCodePathSegmentEnd(segment) {
+                funcInfo.currentSegments.delete(segment);
+            },
+
+            onCodePathSegmentStart(segment) {
+                funcInfo.currentSegments.add(segment);
+            },
+
+            onCodePathSegmentEnd(segment) {
+                funcInfo.currentSegments.delete(segment);
+            },
 
             // Checks the return statement is valid.
             ReturnStatement(node) {
diff --git a/lib/rules/lines-between-class-members.js b/lib/rules/lines-between-class-members.js
index dee4bab5f..3d0a5e673 100644
--- a/lib/rules/lines-between-class-members.js
+++ b/lib/rules/lines-between-class-members.js
@@ -10,6 +10,21 @@
 
 const astUtils = require("./utils/ast-utils");
 
+//------------------------------------------------------------------------------
+// Helpers
+//------------------------------------------------------------------------------
+
+/**
+ * Types of class members.
+ * Those have `test` method to check it matches to the given class member.
+ * @private
+ */
+const ClassMemberTypes = {
+    "*": { test: () => true },
+    field: { test: node => node.type === "PropertyDefinition" },
+    method: { test: node => node.type === "MethodDefinition" }
+};
+
 //------------------------------------------------------------------------------
 // Rule Definition
 //------------------------------------------------------------------------------
@@ -29,7 +44,32 @@ module.exports = {
 
         schema: [
             {
-                enum: ["always", "never"]
+                anyOf: [
+                    {
+                        type: "object",
+                        properties: {
+                            enforce: {
+                                type: "array",
+                                items: {
+                                    type: "object",
+                                    properties: {
+                                        blankLine: { enum: ["always", "never"] },
+                                        prev: { enum: ["method", "field", "*"] },
+                                        next: { enum: ["method", "field", "*"] }
+                                    },
+                                    additionalProperties: false,
+                                    required: ["blankLine", "prev", "next"]
+                                },
+                                minItems: 1
+                            }
+                        },
+                        additionalProperties: false,
+                        required: ["enforce"]
+                    },
+                    {
+                        enum: ["always", "never"]
+                    }
+                ]
             },
             {
                 type: "object",
@@ -55,6 +95,7 @@ module.exports = {
         options[0] = context.options[0] || "always";
         options[1] = context.options[1] || { exceptAfterSingleLine: false };
 
+        const configureList = typeof options[0] === "object" ? options[0].enforce : [{ blankLine: options[0], prev: "*", next: "*" }];
         const sourceCode = context.sourceCode;
 
         /**
@@ -144,6 +185,38 @@ module.exports = {
             return sourceCode.getTokensBetween(before, after, { includeComments: true }).length !== 0;
         }
 
+        /**
+         * Checks whether the given node matches the given type.
+         * @param {ASTNode} node The class member node to check.
+         * @param {string} type The class member type to check.
+         * @returns {boolean} `true` if the class member node matched the type.
+         * @private
+         */
+        function match(node, type) {
+            return ClassMemberTypes[type].test(node);
+        }
+
+        /**
+         * Finds the last matched configuration from the configureList.
+         * @param {ASTNode} prevNode The previous node to match.
+         * @param {ASTNode} nextNode The current node to match.
+         * @returns {string|null} Padding type or `null` if no matches were found.
+         * @private
+         */
+        function getPaddingType(prevNode, nextNode) {
+            for (let i = configureList.length - 1; i >= 0; --i) {
+                const configure = configureList[i];
+                const matched =
+                    match(prevNode, configure.prev) &&
+                    match(nextNode, configure.next);
+
+                if (matched) {
+                    return configure.blankLine;
+                }
+            }
+            return null;
+        }
+
         return {
             ClassBody(node) {
                 const body = node.body;
@@ -158,22 +231,34 @@ module.exports = {
                     const isPadded = afterPadding.loc.start.line - beforePadding.loc.end.line > 1;
                     const hasTokenInPadding = hasTokenOrCommentBetween(beforePadding, afterPadding);
                     const curLineLastToken = findLastConsecutiveTokenAfter(curLast, nextFirst, 0);
+                    const paddingType = getPaddingType(body[i], body[i + 1]);
+
+                    if (paddingType === "never" && isPadded) {
+                        context.report({
+                            node: body[i + 1],
+                            messageId: "never",
 
-                    if ((options[0] === "always" && !skip && !isPadded) ||
-                        (options[0] === "never" && isPadded)) {
+                            fix(fixer) {
+                                if (hasTokenInPadding) {
+                                    return null;
+                                }
+                                return fixer.replaceTextRange([beforePadding.range[1], afterPadding.range[0]], "\n");
+                            }
+                        });
+                    } else if (paddingType === "always" && !skip && !isPadded) {
                         context.report({
                             node: body[i + 1],
-                            messageId: isPadded ? "never" : "always",
+                            messageId: "always",
+
                             fix(fixer) {
                                 if (hasTokenInPadding) {
                                     return null;
                                 }
-                                return isPadded
-                                    ? fixer.replaceTextRange([beforePadding.range[1], afterPadding.range[0]], "\n")
-                                    : fixer.insertTextAfter(curLineLastToken, "\n");
+                                return fixer.insertTextAfter(curLineLastToken, "\n");
                             }
                         });
                     }
+
                 }
             }
         };
diff --git a/lib/rules/no-fallthrough.js b/lib/rules/no-fallthrough.js
index bd2ee9bbe..91da12120 100644
--- a/lib/rules/no-fallthrough.js
+++ b/lib/rules/no-fallthrough.js
@@ -16,6 +16,22 @@ const { directivesPattern } = require("../shared/directives");
 
 const DEFAULT_FALLTHROUGH_COMMENT = /falls?\s?through/iu;
 
+/**
+ * Checks all segments in a set and returns true if any are reachable.
+ * @param {Set<CodePathSegment>} segments The segments to check.
+ * @returns {boolean} True if any segment is reachable; false otherwise.
+ */
+function isAnySegmentReachable(segments) {
+
+    for (const segment of segments) {
+        if (segment.reachable) {
+            return true;
+        }
+    }
+
+    return false;
+}
+
 /**
  * Checks whether or not a given comment string is really a fallthrough comment and not an ESLint directive.
  * @param {string} comment The comment string to check.
@@ -51,15 +67,6 @@ function hasFallthroughComment(caseWhichFallsThrough, subsequentCase, context, f
     return Boolean(comment && isFallThroughComment(comment.value, fallthroughCommentPattern));
 }
 
-/**
- * Checks whether or not a given code path segment is reachable.
- * @param {CodePathSegment} segment A CodePathSegment to check.
- * @returns {boolean} `true` if the segment is reachable.
- */
-function isReachable(segment) {
-    return segment.reachable;
-}
-
 /**
  * Checks whether a node and a token are separated by blank lines
  * @param {ASTNode} node The node to check
@@ -109,7 +116,8 @@ module.exports = {
 
     create(context) {
         const options = context.options[0] || {};
-        let currentCodePath = null;
+        const codePathSegments = [];
+        let currentCodePathSegments = new Set();
         const sourceCode = context.sourceCode;
         const allowEmptyCase = options.allowEmptyCase || false;
 
@@ -126,13 +134,33 @@ module.exports = {
             fallthroughCommentPattern = DEFAULT_FALLTHROUGH_COMMENT;
         }
         return {
-            onCodePathStart(codePath) {
-                currentCodePath = codePath;
+
+            onCodePathStart() {
+                codePathSegments.push(currentCodePathSegments);
+                currentCodePathSegments = new Set();
             },
+
             onCodePathEnd() {
-                currentCodePath = currentCodePath.upper;
+                currentCodePathSegments = codePathSegments.pop();
+            },
+
+            onUnreachableCodePathSegmentStart(segment) {
+                currentCodePathSegments.add(segment);
+            },
+
+            onUnreachableCodePathSegmentEnd(segment) {
+                currentCodePathSegments.delete(segment);
+            },
+
+            onCodePathSegmentStart(segment) {
+                currentCodePathSegments.add(segment);
             },
 
+            onCodePathSegmentEnd(segment) {
+                currentCodePathSegments.delete(segment);
+            },
+
+
             SwitchCase(node) {
 
                 /*
@@ -157,7 +185,7 @@ module.exports = {
                  * `break`, `return`, or `throw` are unreachable.
                  * And allows empty cases and the last case.
                  */
-                if (currentCodePath.currentSegments.some(isReachable) &&
+                if (isAnySegmentReachable(currentCodePathSegments) &&
                     (node.consequent.length > 0 || (!allowEmptyCase && hasBlankLinesBetween(node, nextToken))) &&
                     node.parent.cases[node.parent.cases.length - 1] !== node) {
                     fallthroughCase = node;
diff --git a/lib/rules/no-this-before-super.js b/lib/rules/no-this-before-super.js
index 139bb6649..f96d8ace8 100644
--- a/lib/rules/no-this-before-super.js
+++ b/lib/rules/no-this-before-super.js
@@ -90,6 +90,21 @@ module.exports = {
             return Boolean(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends);
         }
 
+        /**
+         * Determines if every segment in a set has been called.
+         * @param {Set<CodePathSegment>} segments The segments to search.
+         * @returns {boolean} True if every segment has been called; false otherwise.
+         */
+        function isEverySegmentCalled(segments) {
+            for (const segment of segments) {
+                if (!isCalled(segment)) {
+                    return false;
+                }
+            }
+
+            return true;
+        }
+
         /**
          * Checks whether or not this is before `super()` is called.
          * @returns {boolean} `true` if this is before `super()` is called.
@@ -97,7 +112,7 @@ module.exports = {
         function isBeforeCallOfSuper() {
             return (
                 isInConstructorOfDerivedClass() &&
-                !funcInfo.codePath.currentSegments.every(isCalled)
+                !isEverySegmentCalled(funcInfo.currentSegments)
             );
         }
 
@@ -108,11 +123,9 @@ module.exports = {
          * @returns {void}
          */
         function setInvalid(node) {
-            const segments = funcInfo.codePath.currentSegments;
-
-            for (let i = 0; i < segments.length; ++i) {
-                const segment = segments[i];
+            const segments = funcInfo.currentSegments;
 
+            for (const segment of segments) {
                 if (segment.reachable) {
                     segInfoMap[segment.id].invalidNodes.push(node);
                 }
@@ -124,11 +137,9 @@ module.exports = {
          * @returns {void}
          */
         function setSuperCalled() {
-            const segments = funcInfo.codePath.currentSegments;
-
-            for (let i = 0; i < segments.length; ++i) {
-                const segment = segments[i];
+            const segments = funcInfo.currentSegments;
 
+            for (const segment of segments) {
                 if (segment.reachable) {
                     segInfoMap[segment.id].superCalled = true;
                 }
@@ -156,14 +167,16 @@ module.exports = {
                             classNode.superClass &&
                             !astUtils.isNullOrUndefined(classNode.superClass)
                         ),
-                        codePath
+                        codePath,
+                        currentSegments: new Set()
                     };
                 } else {
                     funcInfo = {
                         upper: funcInfo,
                         isConstructor: false,
                         hasExtends: false,
-                        codePath
+                        codePath,
+                        currentSegments: new Set()
                     };
                 }
             },
@@ -211,6 +224,8 @@ module.exports = {
              * @returns {void}
              */
             onCodePathSegmentStart(segment) {
+                funcInfo.currentSegments.add(segment);
+
                 if (!isInConstructorOfDerivedClass()) {
                     return;
                 }
@@ -225,6 +240,18 @@ module.exports = {
                 };
             },
 
+            onUnreachableCodePathSegmentStart(segment) {
+                funcInfo.currentSegments.add(segment);
+            },
+
+            onUnreachableCodePathSegmentEnd(segment) {
+                funcInfo.currentSegments.delete(segment);
+            },
+
+            onCodePathSegmentEnd(segment) {
+                funcInfo.currentSegments.delete(segment);
+            },
+
             /**
              * Update information of the code path segment when a code path was
              * looped.
diff --git a/lib/rules/no-unreachable-loop.js b/lib/rules/no-unreachable-loop.js
index 1df764e17..577d39ac7 100644
--- a/lib/rules/no-unreachable-loop.js
+++ b/lib/rules/no-unreachable-loop.js
@@ -11,6 +11,22 @@
 
 const allLoopTypes = ["WhileStatement", "DoWhileStatement", "ForStatement", "ForInStatement", "ForOfStatement"];
 
+/**
+ * Checks all segments in a set and returns true if any are reachable.
+ * @param {Set<CodePathSegment>} segments The segments to check.
+ * @returns {boolean} True if any segment is reachable; false otherwise.
+ */
+function isAnySegmentReachable(segments) {
+
+    for (const segment of segments) {
+        if (segment.reachable) {
+            return true;
+        }
+    }
+
+    return false;
+}
+
 /**
  * Determines whether the given node is the first node in the code path to which a loop statement
  * 'loops' for the next iteration.
@@ -90,29 +106,36 @@ module.exports = {
             loopsByTargetSegments = new Map(),
             loopsToReport = new Set();
 
-        let currentCodePath = null;
+        const codePathSegments = [];
+        let currentCodePathSegments = new Set();
 
         return {
-            onCodePathStart(codePath) {
-                currentCodePath = codePath;
+
+            onCodePathStart() {
+                codePathSegments.push(currentCodePathSegments);
+                currentCodePathSegments = new Set();
             },
 
             onCodePathEnd() {
-                currentCodePath = currentCodePath.upper;
+                currentCodePathSegments = codePathSegments.pop();
             },
 
-            [loopSelector](node) {
+            onUnreachableCodePathSegmentStart(segment) {
+                currentCodePathSegments.add(segment);
+            },
 
-                /**
-                 * Ignore unreachable loop statements to avoid unnecessary complexity in the implementation, or false positives otherwise.
-                 * For unreachable segments, the code path analysis does not raise events required for this implementation.
-                 */
-                if (currentCodePath.currentSegments.some(segment => segment.reachable)) {
-                    loopsToReport.add(node);
-                }
+            onUnreachableCodePathSegmentEnd(segment) {
+                currentCodePathSegments.delete(segment);
+            },
+
+            onCodePathSegmentEnd(segment) {
+                currentCodePathSegments.delete(segment);
             },
 
             onCodePathSegmentStart(segment, node) {
+
+                currentCodePathSegments.add(segment);
+
                 if (isLoopingTarget(node)) {
                     const loop = node.parent;
 
@@ -140,6 +163,18 @@ module.exports = {
                 }
             },
 
+            [loopSelector](node) {
+
+                /**
+                 * Ignore unreachable loop statements to avoid unnecessary complexity in the implementation, or false positives otherwise.
+                 * For unreachable segments, the code path analysis does not raise events required for this implementation.
+                 */
+                if (isAnySegmentReachable(currentCodePathSegments)) {
+                    loopsToReport.add(node);
+                }
+            },
+
+
             "Program:exit"() {
                 loopsToReport.forEach(
                     node => context.report({ node, messageId: "invalid" })
diff --git a/lib/rules/no-unreachable.js b/lib/rules/no-unreachable.js
index 6216a73a2..0cf750e42 100644
--- a/lib/rules/no-unreachable.js
+++ b/lib/rules/no-unreachable.js
@@ -24,12 +24,19 @@ function isInitialized(node) {
 }
 
 /**
- * Checks whether or not a given code path segment is unreachable.
- * @param {CodePathSegment} segment A CodePathSegment to check.
- * @returns {boolean} `true` if the segment is unreachable.
+ * Checks all segments in a set and returns true if all are unreachable.
+ * @param {Set<CodePathSegment>} segments The segments to check.
+ * @returns {boolean} True if all segments are unreachable; false otherwise.
  */
-function isUnreachable(segment) {
-    return !segment.reachable;
+function areAllSegmentsUnreachable(segments) {
+
+    for (const segment of segments) {
+        if (segment.reachable) {
+            return false;
+        }
+    }
+
+    return true;
 }
 
 /**
@@ -124,7 +131,6 @@ module.exports = {
     },
 
     create(context) {
-        let currentCodePath = null;
 
         /** @type {ConstructorInfo | null} */
         let constructorInfo = null;
@@ -132,6 +138,12 @@ module.exports = {
         /** @type {ConsecutiveRange} */
         const range = new ConsecutiveRange(context.sourceCode);
 
+        /** @type {Array<Set<CodePathSegment>>} */
+        const codePathSegments = [];
+
+        /** @type {Set<CodePathSegment>} */
+        let currentCodePathSegments = new Set();
+
         /**
          * Reports a given node if it's unreachable.
          * @param {ASTNode} node A statement node to report.
@@ -140,7 +152,7 @@ module.exports = {
         function reportIfUnreachable(node) {
             let nextNode = null;
 
-            if (node && (node.type === "PropertyDefinition" || currentCodePath.currentSegments.every(isUnreachable))) {
+            if (node && (node.type === "PropertyDefinition" || areAllSegmentsUnreachable(currentCodePathSegments))) {
 
                 // Store this statement to distinguish consecutive statements.
                 if (range.isEmpty) {
@@ -181,12 +193,29 @@ module.exports = {
         return {
 
             // Manages the current code path.
-            onCodePathStart(codePath) {
-                currentCodePath = codePath;
+            onCodePathStart() {
+                codePathSegments.push(currentCodePathSegments);
+                currentCodePathSegments = new Set();
             },
 
             onCodePathEnd() {
-                currentCodePath = currentCodePath.upper;
+                currentCodePathSegments = codePathSegments.pop();
+            },
+
+            onUnreachableCodePathSegmentStart(segment) {
+                currentCodePathSegments.add(segment);
+            },
+
+            onUnreachableCodePathSegmentEnd(segment) {
+                currentCodePathSegments.delete(segment);
+            },
+
+            onCodePathSegmentEnd(segment) {
+                currentCodePathSegments.delete(segment);
+            },
+
+            onCodePathSegmentStart(segment) {
+                currentCodePathSegments.add(segment);
             },
 
             // Registers for all statement nodes (excludes FunctionDeclaration).
diff --git a/lib/rules/no-useless-return.js b/lib/rules/no-useless-return.js
index f89523153..81d610510 100644
--- a/lib/rules/no-useless-return.js
+++ b/lib/rules/no-useless-return.js
@@ -57,6 +57,22 @@ function isInFinally(node) {
     return false;
 }
 
+/**
+ * Checks all segments in a set and returns true if any are reachable.
+ * @param {Set<CodePathSegment>} segments The segments to check.
+ * @returns {boolean} True if any segment is reachable; false otherwise.
+ */
+function isAnySegmentReachable(segments) {
+
+    for (const segment of segments) {
+        if (segment.reachable) {
+            return true;
+        }
+    }
+
+    return false;
+}
+
 //------------------------------------------------------------------------------
 // Rule Definition
 //------------------------------------------------------------------------------
@@ -205,7 +221,6 @@ module.exports = {
          */
         function markReturnStatementsOnCurrentSegmentsAsUsed() {
             scopeInfo
-                .codePath
                 .currentSegments
                 .forEach(segment => markReturnStatementsOnSegmentAsUsed(segment, new Set()));
         }
@@ -222,7 +237,8 @@ module.exports = {
                     upper: scopeInfo,
                     uselessReturns: [],
                     traversedTryBlockStatements: [],
-                    codePath
+                    codePath,
+                    currentSegments: new Set()
                 };
             },
 
@@ -259,6 +275,9 @@ module.exports = {
              * NOTE: This event is notified for only reachable segments.
              */
             onCodePathSegmentStart(segment) {
+
+                scopeInfo.currentSegments.add(segment);
+
                 const info = {
                     uselessReturns: getUselessReturns([], segment.allPrevSegments),
                     returned: false
@@ -268,6 +287,18 @@ module.exports = {
                 segmentInfoMap.set(segment, info);
             },
 
+            onUnreachableCodePathSegmentStart(segment) {
+                scopeInfo.currentSegments.add(segment);
+            },
+
+            onUnreachableCodePathSegmentEnd(segment) {
+                scopeInfo.currentSegments.delete(segment);
+            },
+
+            onCodePathSegmentEnd(segment) {
+                scopeInfo.currentSegments.delete(segment);
+            },
+
             // Adds ReturnStatement node to check whether it's useless or not.
             ReturnStatement(node) {
                 if (node.argument) {
@@ -279,12 +310,12 @@ module.exports = {
                     isInFinally(node) ||
 
                     // Ignore `return` statements in unreachable places (https://github.com/eslint/eslint/issues/11647).
-                    !scopeInfo.codePath.currentSegments.some(s => s.reachable)
+                    !isAnySegmentReachable(scopeInfo.currentSegments)
                 ) {
                     return;
                 }
 
-                for (const segment of scopeInfo.codePath.currentSegments) {
+                for (const segment of scopeInfo.currentSegments) {
                     const info = segmentInfoMap.get(segment);
 
                     if (info) {
diff --git a/lib/rules/require-atomic-updates.js b/lib/rules/require-atomic-updates.js
index ba369a203..7e397ceb1 100644
--- a/lib/rules/require-atomic-updates.js
+++ b/lib/rules/require-atomic-updates.js
@@ -213,7 +213,8 @@ module.exports = {
                 stack = {
                     upper: stack,
                     codePath,
-                    referenceMap: shouldVerify ? createReferenceMap(scope) : null
+                    referenceMap: shouldVerify ? createReferenceMap(scope) : null,
+                    currentSegments: new Set()
                 };
             },
             onCodePathEnd() {
@@ -223,11 +224,25 @@ module.exports = {
             // Initialize the segment information.
             onCodePathSegmentStart(segment) {
                 segmentInfo.initialize(segment);
+                stack.currentSegments.add(segment);
             },
 
+            onUnreachableCodePathSegmentStart(segment) {
+                stack.currentSegments.add(segment);
+            },
+
+            onUnreachableCodePathSegmentEnd(segment) {
+                stack.currentSegments.delete(segment);
+            },
+
+            onCodePathSegmentEnd(segment) {
+                stack.currentSegments.delete(segment);
+            },
+
+
             // Handle references to prepare verification.
             Identifier(node) {
-                const { codePath, referenceMap } = stack;
+                const { referenceMap } = stack;
                 const reference = referenceMap && referenceMap.get(node);
 
                 // Ignore if this is not a valid variable reference.
@@ -240,7 +255,7 @@ module.exports = {
 
                 // Add a fresh read variable.
                 if (reference.isRead() && !(writeExpr && writeExpr.parent.operator === "=")) {
-                    segmentInfo.markAsRead(codePath.currentSegments, variable);
+                    segmentInfo.markAsRead(stack.currentSegments, variable);
                 }
 
                 /*
@@ -267,16 +282,15 @@ module.exports = {
              * If the reference exists in `outdatedReadVariables` list, report it.
              */
             ":expression:exit"(node) {
-                const { codePath, referenceMap } = stack;
 
                 // referenceMap exists if this is in a resumable function scope.
-                if (!referenceMap) {
+                if (!stack.referenceMap) {
                     return;
                 }
 
                 // Mark the read variables on this code path as outdated.
                 if (node.type === "AwaitExpression" || node.type === "YieldExpression") {
-                    segmentInfo.makeOutdated(codePath.currentSegments);
+                    segmentInfo.makeOutdated(stack.currentSegments);
                 }
 
                 // Verify.
@@ -288,7 +302,7 @@ module.exports = {
                     for (const reference of references) {
                         const variable = reference.resolved;
 
-                        if (segmentInfo.isOutdated(codePath.currentSegments, variable)) {
+                        if (segmentInfo.isOutdated(stack.currentSegments, variable)) {
                             if (node.parent.left === reference.identifier) {
                                 context.report({
                                     node: node.parent,
diff --git a/package.json b/package.json
index d52a2aef6..9fe892ea5 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
   "name": "eslint",
-  "version": "8.48.0",
+  "version": "8.49.0",
   "author": "Nicholas C. Zakas <nicholas+npm@nczconsulting.com>",
   "description": "An AST-based pattern checker for JavaScript.",
   "bin": {
@@ -63,7 +63,7 @@
     "@eslint-community/eslint-utils": "^4.2.0",
     "@eslint-community/regexpp": "^4.6.1",
     "@eslint/eslintrc": "^2.1.2",
-    "@eslint/js": "8.48.0",
+    "@eslint/js": "8.49.0",
     "@humanwhocodes/config-array": "^0.11.11",
     "@humanwhocodes/module-importer": "^1.0.1",
     "@nodelib/fs.walk": "^1.2.8",
@@ -101,6 +101,11 @@
   "devDependencies": {
     "@babel/core": "^7.4.3",
     "@babel/preset-env": "^7.4.3",
+    "@wdio/browser-runner": "^8.14.6",
+    "@wdio/cli": "^8.14.6",
+    "@wdio/concise-reporter": "^8.14.0",
+    "@wdio/globals": "^8.14.6",
+    "@wdio/mocha-framework": "^8.14.0",
     "babel-loader": "^8.0.5",
     "c8": "^7.12.0",
     "chai": "^4.0.1",
@@ -124,11 +129,6 @@
     "glob": "^7.1.6",
     "got": "^11.8.3",
     "gray-matter": "^4.0.3",
-    "karma": "^6.1.1",
-    "karma-chrome-launcher": "^3.1.0",
-    "karma-mocha": "^2.0.1",
-    "karma-mocha-reporter": "^2.2.5",
-    "karma-webpack": "^5.0.0",
     "lint-staged": "^11.0.0",
     "load-perf": "^0.2.0",
     "markdownlint": "^0.25.1",
@@ -148,12 +148,14 @@
     "pirates": "^4.0.5",
     "progress": "^2.0.3",
     "proxyquire": "^2.0.1",
-    "puppeteer": "^13.7.0",
     "recast": "^0.20.4",
     "regenerator-runtime": "^0.13.2",
+    "rollup-plugin-node-polyfills": "^0.2.1",
     "semver": "^7.5.3",
     "shelljs": "^0.8.2",
     "sinon": "^11.0.0",
+    "vite-plugin-commonjs": "^0.8.2",
+    "webdriverio": "^8.14.6",
     "webpack": "^5.23.0",
     "webpack-cli": "^4.5.0",
     "yorkie": "^2.0.0"
diff --git a/packages/eslint-config-eslint/base.js b/packages/eslint-config-eslint/base.js
index 136510839..083336919 100644
--- a/packages/eslint-config-eslint/base.js
+++ b/packages/eslint-config-eslint/base.js
@@ -9,7 +9,6 @@ const unicorn = require("eslint-plugin-unicorn");
  * the plugins' configs are not updated to support the flat config,
  * need to manually update the `plugins` property
  */
-jsdoc.configs.recommended.plugins = { jsdoc };
 eslintComments.configs.recommended.plugins = { "eslint-comments": eslintComments };
 
 // extends eslint recommended config
@@ -262,7 +261,7 @@ const jsConfigs = [js.configs.recommended, {
 }];
 
 // extends eslint-plugin-jsdoc's recommended config
-const jsdocConfigs = [jsdoc.configs.recommended, {
+const jsdocConfigs = [jsdoc.configs["flat/recommended"], {
     settings: {
         jsdoc: {
             mode: "typescript",
diff --git a/packages/eslint-config-eslint/package.json b/packages/eslint-config-eslint/package.json
index 7d8a74753..f8c7fab87 100644
--- a/packages/eslint-config-eslint/package.json
+++ b/packages/eslint-config-eslint/package.json
@@ -30,7 +30,7 @@
   "dependencies": {
     "@eslint/js": "^8.42.0",
     "eslint-plugin-eslint-comments": "^3.2.0",
-    "eslint-plugin-jsdoc": "^46.2.5",
+    "eslint-plugin-jsdoc": "^46.5.1",
     "eslint-plugin-n": "^16.0.0",
     "eslint-plugin-unicorn": "^42.0.0"
   },
diff --git a/packages/js/package.json b/packages/js/package.json
index 965acdba0..7bfcf6e6b 100644
--- a/packages/js/package.json
+++ b/packages/js/package.json
@@ -1,6 +1,6 @@
 {
   "name": "@eslint/js",
-  "version": "8.48.0",
+  "version": "8.49.0",
   "description": "ESLint JavaScript language implementation",
   "main": "./src/index.js",
   "scripts": {},
diff --git a/tests/lib/cli.js b/tests/lib/cli.js
index ad0b8ad23..15556e5cf 100644
--- a/tests/lib/cli.js
+++ b/tests/lib/cli.js
@@ -801,32 +801,6 @@ describe("cli", () => {
                         assert.isFalse(log.info.called);
                         assert.strictEqual(exit, 0);
                     });
-
-                    it(`should suppress the warning if --no-warn-ignored is passed with configType:${configType}`, async () => {
-                        const options = useFlatConfig
-                            ? `--config ${getFixturePath("eslint.config_with_ignores.js")}`
-                            : `--ignore-path ${getFixturePath(".eslintignore")}`;
-                        const filePath = getFixturePath("passing.js");
-                        const exit = await cli.execute(`${options} --no-warn-ignored ${filePath}`, null, useFlatConfig);
-
-                        assert.isFalse(log.info.called);
-
-                        // When eslintrc is used, we get an exit code of 2 because the --no-warn-ignored option is unrecognized.
-                        assert.strictEqual(exit, useFlatConfig ? 0 : 2);
-                    });
-
-                    it(`should suppress the warning if --no-warn-ignored is passed and an ignored file is passed via stdin with configType:${configType}`, async () => {
-                        const options = useFlatConfig
-                            ? `--config ${getFixturePath("eslint.config_with_ignores.js")}`
-                            : `--ignore-path ${getFixturePath(".eslintignore")}`;
-                        const filePath = getFixturePath("passing.js");
-                        const exit = await cli.execute(`${options} --no-warn-ignored --stdin --stdin-filename ${filePath}`, "foo", useFlatConfig);
-
-                        assert.isFalse(log.info.called);
-
-                        // When eslintrc is used, we get an exit code of 2 because the --no-warn-ignored option is unrecognized.
-                        assert.strictEqual(exit, useFlatConfig ? 0 : 2);
-                    });
                 });
 
                 describe("when given a pattern to ignore", () => {
diff --git a/tests/lib/eslint/flat-eslint.js b/tests/lib/eslint/flat-eslint.js
index 31af43c5a..9e0ca1245 100644
--- a/tests/lib/eslint/flat-eslint.js
+++ b/tests/lib/eslint/flat-eslint.js
@@ -211,8 +211,7 @@ describe("FlatESLint", () => {
                     overrideConfig: "",
                     overrideConfigFile: "",
                     plugins: "",
-                    reportUnusedDisableDirectives: "",
-                    warnIgnored: ""
+                    reportUnusedDisableDirectives: ""
                 }),
                 new RegExp(escapeStringRegExp([
                     "Invalid Options:",
@@ -230,8 +229,7 @@ describe("FlatESLint", () => {
                     "- 'overrideConfig' must be an object or null.",
                     "- 'overrideConfigFile' must be a non-empty string, null, or true.",
                     "- 'plugins' must be an object or null.",
-                    "- 'reportUnusedDisableDirectives' must be any of \"error\", \"warn\", \"off\", and null.",
-                    "- 'warnIgnored' must be a boolean."
+                    "- 'reportUnusedDisableDirectives' must be any of \"error\", \"warn\", \"off\", and null."
                 ].join("\n")), "u")
             );
         });
@@ -371,31 +369,7 @@ describe("FlatESLint", () => {
             assert.strictEqual(results.length, 1);
             assert.strictEqual(results[0].filePath, getFixturePath("passing.js"));
             assert.strictEqual(results[0].messages[0].severity, 1);
-            assert.strictEqual(results[0].messages[0].message, "File ignored because of a matching ignore pattern. Use \"--no-ignore\" to disable file ignore settings or use \"--no-warn-ignored\" to suppress this warning.");
-            assert.strictEqual(results[0].messages[0].output, void 0);
-            assert.strictEqual(results[0].errorCount, 0);
-            assert.strictEqual(results[0].warningCount, 1);
-            assert.strictEqual(results[0].fatalErrorCount, 0);
-            assert.strictEqual(results[0].fixableErrorCount, 0);
-            assert.strictEqual(results[0].fixableWarningCount, 0);
-            assert.strictEqual(results[0].usedDeprecatedRules.length, 0);
-            assert.strictEqual(results[0].suppressedMessages.length, 0);
-        });
-
-        it("should return a warning when given a filename by --stdin-filename in excluded files list if constructor warnIgnored is false, but lintText warnIgnored is true", async () => {
-            eslint = new FlatESLint({
-                cwd: getFixturePath(".."),
-                overrideConfigFile: "fixtures/eslint.config_with_ignores.js",
-                warnIgnored: false
-            });
-
-            const options = { filePath: "fixtures/passing.js", warnIgnored: true };
-            const results = await eslint.lintText("var bar = foo;", options);
-
-            assert.strictEqual(results.length, 1);
-            assert.strictEqual(results[0].filePath, getFixturePath("passing.js"));
-            assert.strictEqual(results[0].messages[0].severity, 1);
-            assert.strictEqual(results[0].messages[0].message, "File ignored because of a matching ignore pattern. Use \"--no-ignore\" to disable file ignore settings or use \"--no-warn-ignored\" to suppress this warning.");
+            assert.strictEqual(results[0].messages[0].message, "File ignored because of a matching ignore pattern. Use \"--no-ignore\" to override.");
             assert.strictEqual(results[0].messages[0].output, void 0);
             assert.strictEqual(results[0].errorCount, 0);
             assert.strictEqual(results[0].warningCount, 1);
@@ -423,20 +397,7 @@ describe("FlatESLint", () => {
             assert.strictEqual(results.length, 0);
         });
 
-        it("should not return a warning when given a filename by --stdin-filename in excluded files list if constructor warnIgnored is false", async () => {
-            eslint = new FlatESLint({
-                cwd: getFixturePath(".."),
-                overrideConfigFile: "fixtures/eslint.config_with_ignores.js",
-                warnIgnored: false
-            });
-            const options = { filePath: "fixtures/passing.js" };
-            const results = await eslint.lintText("var bar = foo;", options);
-
-            // should not report anything because the warning is suppressed
-            assert.strictEqual(results.length, 0);
-        });
-
-        it("should show excluded file warnings by default", async () => {
+        it("should suppress excluded file warnings by default", async () => {
             eslint = new FlatESLint({
                 cwd: getFixturePath(".."),
                 overrideConfigFile: "fixtures/eslint.config_with_ignores.js"
@@ -444,8 +405,8 @@ describe("FlatESLint", () => {
             const options = { filePath: "fixtures/passing.js" };
             const results = await eslint.lintText("var bar = foo;", options);
 
-            assert.strictEqual(results.length, 1);
-            assert.strictEqual(results[0].messages[0].message, "File ignored because of a matching ignore pattern. Use \"--no-ignore\" to disable file ignore settings or use \"--no-warn-ignored\" to suppress this warning.");
+            // should not report anything because there are no errors
+            assert.strictEqual(results.length, 0);
         });
 
         it("should return a message when given a filename by --stdin-filename in excluded files list and ignore is off", async () => {
@@ -724,7 +685,7 @@ describe("FlatESLint", () => {
                 ignore: false
             });
             const results = await eslint.lintText("var bar = foo;", { filePath: "node_modules/passing.js", warnIgnored: true });
-            const expectedMsg = "File ignored by default because it is located under the node_modules directory. Use ignore pattern \"!**/node_modules/\" to disable file ignore settings or use \"--no-warn-ignored\" to suppress this warning.";
+            const expectedMsg = "File ignored by default because it is located under the node_modules directory. Use ignore pattern \"!**/node_modules/\" to override.";
 
             assert.strictEqual(results.length, 1);
             assert.strictEqual(results[0].filePath, getFixturePath("node_modules/passing.js"));
@@ -1350,7 +1311,7 @@ describe("FlatESLint", () => {
                     cwd: getFixturePath("cli-engine")
                 });
                 const results = await eslint.lintFiles(["node_modules/foo.js"]);
-                const expectedMsg = "File ignored by default because it is located under the node_modules directory. Use ignore pattern \"!**/node_modules/\" to disable file ignore settings or use \"--no-warn-ignored\" to suppress this warning.";
+                const expectedMsg = "File ignored by default because it is located under the node_modules directory. Use ignore pattern \"!**/node_modules/\" to override.";
 
                 assert.strictEqual(results.length, 1);
                 assert.strictEqual(results[0].errorCount, 0);
@@ -1368,7 +1329,7 @@ describe("FlatESLint", () => {
                     cwd: getFixturePath("cli-engine")
                 });
                 const results = await eslint.lintFiles(["nested_node_modules/subdir/node_modules/text.js"]);
-                const expectedMsg = "File ignored by default because it is located under the node_modules directory. Use ignore pattern \"!**/node_modules/\" to disable file ignore settings or use \"--no-warn-ignored\" to suppress this warning.";
+                const expectedMsg = "File ignored by default because it is located under the node_modules directory. Use ignore pattern \"!**/node_modules/\" to override.";
 
                 assert.strictEqual(results.length, 1);
                 assert.strictEqual(results[0].errorCount, 0);
@@ -1387,7 +1348,7 @@ describe("FlatESLint", () => {
                     ignorePatterns: ["*.js"]
                 });
                 const results = await eslint.lintFiles(["node_modules_cleaner.js"]);
-                const expectedMsg = "File ignored because of a matching ignore pattern. Use \"--no-ignore\" to disable file ignore settings or use \"--no-warn-ignored\" to suppress this warning.";
+                const expectedMsg = "File ignored because of a matching ignore pattern. Use \"--no-ignore\" to override.";
 
                 assert.strictEqual(results.length, 1);
                 assert.strictEqual(results[0].errorCount, 0);
@@ -1400,16 +1361,6 @@ describe("FlatESLint", () => {
                 assert.strictEqual(results[0].suppressedMessages.length, 0);
             });
 
-            it("should suppress the warning when a file in the node_modules folder passed explicitly and warnIgnored is false", async () => {
-                eslint = new FlatESLint({
-                    cwd: getFixturePath("cli-engine"),
-                    warnIgnored: false
-                });
-                const results = await eslint.lintFiles(["node_modules/foo.js"]);
-
-                assert.strictEqual(results.length, 0);
-            });
-
             it("should report on globs with explicit inclusion of dotfiles", async () => {
                 eslint = new FlatESLint({
                     cwd: getFixturePath("cli-engine"),
@@ -1532,7 +1483,7 @@ describe("FlatESLint", () => {
                 assert.strictEqual(results.length, 1);
                 assert.strictEqual(results[0].filePath, filePath);
                 assert.strictEqual(results[0].messages[0].severity, 1);
-                assert.strictEqual(results[0].messages[0].message, "File ignored because of a matching ignore pattern. Use \"--no-ignore\" to disable file ignore settings or use \"--no-warn-ignored\" to suppress this warning.");
+                assert.strictEqual(results[0].messages[0].message, "File ignored because of a matching ignore pattern. Use \"--no-ignore\" to override.");
                 assert.strictEqual(results[0].errorCount, 0);
                 assert.strictEqual(results[0].warningCount, 1);
                 assert.strictEqual(results[0].fatalErrorCount, 0);
@@ -1541,18 +1492,6 @@ describe("FlatESLint", () => {
                 assert.strictEqual(results[0].suppressedMessages.length, 0);
             });
 
-            it("should suppress the warning when an explicitly given file is ignored and warnIgnored is false", async () => {
-                eslint = new FlatESLint({
-                    overrideConfigFile: "eslint.config_with_ignores.js",
-                    cwd: getFixturePath(),
-                    warnIgnored: false
-                });
-                const filePath = getFixturePath("passing.js");
-                const results = await eslint.lintFiles([filePath]);
-
-                assert.strictEqual(results.length, 0);
-            });
-
             it("should return a warning about matching ignore patterns when an explicitly given dotfile is ignored", async () => {
                 eslint = new FlatESLint({
                     overrideConfigFile: "eslint.config_with_ignores.js",
@@ -1564,7 +1503,7 @@ describe("FlatESLint", () => {
                 assert.strictEqual(results.length, 1);
                 assert.strictEqual(results[0].filePath, filePath);
                 assert.strictEqual(results[0].messages[0].severity, 1);
-                assert.strictEqual(results[0].messages[0].message, "File ignored because of a matching ignore pattern. Use \"--no-ignore\" to disable file ignore settings or use \"--no-warn-ignored\" to suppress this warning.");
+                assert.strictEqual(results[0].messages[0].message, "File ignored because of a matching ignore pattern. Use \"--no-ignore\" to override.");
                 assert.strictEqual(results[0].errorCount, 0);
                 assert.strictEqual(results[0].warningCount, 1);
                 assert.strictEqual(results[0].fatalErrorCount, 0);
@@ -5461,7 +5400,7 @@ describe("FlatESLint", () => {
                             {
                                 ruleId: null,
                                 fatal: false,
-                                message: "File ignored by default because it is located under the node_modules directory. Use ignore pattern \"!**/node_modules/\" to disable file ignore settings or use \"--no-warn-ignored\" to suppress this warning.",
+                                message: "File ignored by default because it is located under the node_modules directory. Use ignore pattern \"!**/node_modules/\" to override.",
                                 severity: 1,
                                 nodeType: null
                             }
diff --git a/tests/lib/linter/code-path-analysis/code-path-analyzer.js b/tests/lib/linter/code-path-analysis/code-path-analyzer.js
index cc2717a7f..dbed9b461 100644
--- a/tests/lib/linter/code-path-analysis/code-path-analyzer.js
+++ b/tests/lib/linter/code-path-analysis/code-path-analyzer.js
@@ -439,6 +439,164 @@ describe("CodePathAnalyzer", () => {
         });
     });
 
+    describe("onUnreachableCodePathSegmentStart", () => {
+        it("should be fired after a throw", () => {
+            let lastCodePathNodeType = null;
+
+            linter.defineRule("test", {
+                create: () => ({
+                    onUnreachableCodePathSegmentStart(segment, node) {
+                        lastCodePathNodeType = node.type;
+
+                        assert(segment instanceof CodePathSegment);
+                        assert.strictEqual(node.type, "ExpressionStatement");
+                    },
+                    ExpressionStatement() {
+                        assert.strictEqual(lastCodePathNodeType, "ExpressionStatement");
+                    }
+                })
+            });
+            linter.verify(
+                "throw 'boom'; foo();",
+                { rules: { test: 2 } }
+            );
+
+        });
+
+        it("should be fired after a return", () => {
+            let lastCodePathNodeType = null;
+
+            linter.defineRule("test", {
+                create: () => ({
+                    onUnreachableCodePathSegmentStart(segment, node) {
+                        lastCodePathNodeType = node.type;
+
+                        assert(segment instanceof CodePathSegment);
+                        assert.strictEqual(node.type, "ExpressionStatement");
+                    },
+                    ExpressionStatement() {
+                        assert.strictEqual(lastCodePathNodeType, "ExpressionStatement");
+                    }
+                })
+            });
+            linter.verify(
+                "function foo() { return; foo(); }",
+                { rules: { test: 2 } }
+            );
+
+        });
+    });
+
+    describe("onUnreachableCodePathSegmentEnd", () => {
+        it("should be fired after a throw", () => {
+            let lastCodePathNodeType = null;
+
+            linter.defineRule("test", {
+                create: () => ({
+                    onUnreachableCodePathSegmentEnd(segment, node) {
+                        lastCodePathNodeType = node.type;
+
+                        assert(segment instanceof CodePathSegment);
+                        assert.strictEqual(node.type, "Program");
+                    }
+                })
+            });
+            linter.verify(
+                "throw 'boom'; foo();",
+                { rules: { test: 2 } }
+            );
+
+            assert.strictEqual(lastCodePathNodeType, "Program");
+        });
+
+        it("should be fired after a return", () => {
+            let lastCodePathNodeType = null;
+
+            linter.defineRule("test", {
+                create: () => ({
+                    onUnreachableCodePathSegmentEnd(segment, node) {
+                        lastCodePathNodeType = node.type;
+                        assert(segment instanceof CodePathSegment);
+                        assert.strictEqual(node.type, "FunctionDeclaration");
+                    },
+                    "Program:exit"() {
+                        assert.strictEqual(lastCodePathNodeType, "FunctionDeclaration");
+                    }
+                })
+            });
+            linter.verify(
+                "function foo() { return; foo(); }",
+                { rules: { test: 2 } }
+            );
+
+        });
+
+        it("should be fired after a return inside of function and if statement", () => {
+            let lastCodePathNodeType = null;
+
+            linter.defineRule("test", {
+                create: () => ({
+                    onUnreachableCodePathSegmentEnd(segment, node) {
+                        lastCodePathNodeType = node.type;
+                        assert(segment instanceof CodePathSegment);
+                        assert.strictEqual(node.type, "BlockStatement");
+                    },
+                    "Program:exit"() {
+                        assert.strictEqual(lastCodePathNodeType, "BlockStatement");
+                    }
+                })
+            });
+            linter.verify(
+                "function foo() { if (bar) { return; foo(); } else {} }",
+                { rules: { test: 2 } }
+            );
+
+        });
+
+        it("should be fired at the end of programs/functions for the final segment", () => {
+            let count = 0;
+            let lastNodeType = null;
+
+            linter.defineRule("test", {
+                create: () => ({
+                    onUnreachableCodePathSegmentEnd(cp, node) {
+                        count += 1;
+
+                        assert(cp instanceof CodePathSegment);
+                        if (count === 4) {
+                            assert(node.type === "Program");
+                        } else if (count === 1) {
+                            assert(node.type === "FunctionDeclaration");
+                        } else if (count === 2) {
+                            assert(node.type === "FunctionExpression");
+                        } else if (count === 3) {
+                            assert(node.type === "ArrowFunctionExpression");
+                        }
+                        assert(node.type === lastNodeType);
+                    },
+                    "Program:exit"() {
+                        lastNodeType = "Program";
+                    },
+                    "FunctionDeclaration:exit"() {
+                        lastNodeType = "FunctionDeclaration";
+                    },
+                    "FunctionExpression:exit"() {
+                        lastNodeType = "FunctionExpression";
+                    },
+                    "ArrowFunctionExpression:exit"() {
+                        lastNodeType = "ArrowFunctionExpression";
+                    }
+                })
+            });
+            linter.verify(
+                "foo(); function foo() { return; } var foo = function() { return; }; var foo = () => { return; }; throw 'boom';",
+                { rules: { test: 2 }, env: { es6: true } }
+            );
+
+            assert(count === 4);
+        });
+    });
+
     describe("onCodePathSegmentLoop", () => {
         it("should be fired in `while` loops", () => {
             let count = 0;
diff --git a/tests/lib/linter/linter.js b/tests/lib/linter/linter.js
index f86e98ba8..65957f82a 100644
--- a/tests/lib/linter/linter.js
+++ b/tests/lib/linter/linter.js
@@ -9,7 +9,7 @@
 // Requirements
 //------------------------------------------------------------------------------
 
-const assert = require("chai").assert,
+const { assert } = require("chai"),
     sinon = require("sinon"),
     espree = require("espree"),
     esprima = require("esprima"),
@@ -7263,12 +7263,12 @@ var a = "test2";
 
         it("should have file path passed to it", () => {
             const code = "/* this is code */";
-            const parseSpy = sinon.spy(testParsers.stubParser, "parse");
+            const parseSpy = { parse: sinon.spy() };
 
-            linter.defineParser("stub-parser", testParsers.stubParser);
+            linter.defineParser("stub-parser", parseSpy);
             linter.verify(code, { parser: "stub-parser" }, filename, true);
 
-            sinon.assert.calledWithMatch(parseSpy, "", { filePath: filename });
+            sinon.assert.calledWithMatch(parseSpy.parse, "", { filePath: filename });
         });
 
         it("should not report an error when JSX code contains a spread operator and JSX is enabled", () => {
@@ -8068,16 +8068,16 @@ describe("Linter with FlatConfigArray", () => {
 
                     it("should have file path passed to it", () => {
                         const code = "/* this is code */";
-                        const parseSpy = sinon.spy(testParsers.stubParser, "parse");
+                        const parseSpy = { parse: sinon.spy() };
                         const config = {
                             languageOptions: {
-                                parser: testParsers.stubParser
+                                parser: parseSpy
                             }
                         };
 
                         linter.verify(code, config, filename, true);
 
-                        sinon.assert.calledWithMatch(parseSpy, "", { filePath: filename });
+                        sinon.assert.calledWithMatch(parseSpy.parse, "", { filePath: filename });
                     });
 
                     it("should not report an error when JSX code contains a spread operator and JSX is enabled", () => {
diff --git a/tests/lib/options.js b/tests/lib/options.js
index b663e8623..d8f795b78 100644
--- a/tests/lib/options.js
+++ b/tests/lib/options.js
@@ -415,18 +415,4 @@ describe("options", () => {
         });
     });
 
-    describe("--no-warn-ignored", () => {
-        it("should return false when --no-warn-ignored is passed", () => {
-            const currentOptions = flatOptions.parse("--no-warn-ignored");
-
-            assert.isFalse(currentOptions.warnIgnored);
-        });
-
-        it("should return true when --warn-ignored is passed", () => {
-            const currentOptions = flatOptions.parse("--warn-ignored");
-
-            assert.isTrue(currentOptions.warnIgnored);
-        });
-    });
-
 });
diff --git a/tests/lib/rule-tester/flat-rule-tester.js b/tests/lib/rule-tester/flat-rule-tester.js
index 8e1f83af6..3e34c4c34 100644
--- a/tests/lib/rule-tester/flat-rule-tester.js
+++ b/tests/lib/rule-tester/flat-rule-tester.js
@@ -2248,6 +2248,45 @@ describe("FlatRuleTester", () => {
         });
     });
 
+    describe("deprecations", () => {
+        let processStub;
+
+        beforeEach(() => {
+            processStub = sinon.stub(process, "emitWarning");
+        });
+
+        afterEach(() => {
+            processStub.restore();
+        });
+
+        it("should emit a deprecation warning when CodePath#currentSegments is accessed", () => {
+
+            const useCurrentSegmentsRule = {
+                create: () => ({
+                    onCodePathStart(codePath) {
+                        codePath.currentSegments.forEach(() => { });
+                    }
+                })
+            };
+
+            ruleTester.run("use-current-segments", useCurrentSegmentsRule, {
+                valid: ["foo"],
+                invalid: []
+            });
+
+            assert.strictEqual(processStub.callCount, 1, "calls `process.emitWarning()` once");
+            assert.deepStrictEqual(
+                processStub.getCall(0).args,
+                [
+                    "\"use-current-segments\" rule uses CodePath#currentSegments and will stop working in ESLint v9. Please read the documentation for how to update your code: https://eslint.org/docs/latest/extend/code-path-analysis#usage-examples",
+                    "DeprecationWarning"
+                ]
+            );
+
+        });
+
+    });
+
     /**
      * Asserts that a particular value will be emitted from an EventEmitter.
      * @param {EventEmitter} emitter The emitter that should emit a value
diff --git a/tests/lib/rule-tester/rule-tester.js b/tests/lib/rule-tester/rule-tester.js
index c607e4476..68cf887ad 100644
--- a/tests/lib/rule-tester/rule-tester.js
+++ b/tests/lib/rule-tester/rule-tester.js
@@ -2489,6 +2489,97 @@ describe("RuleTester", () => {
 
             assert.strictEqual(processStub.callCount, 0, "never calls `process.emitWarning()`");
         });
+
+        it("should emit a deprecation warning when CodePath#currentSegments is accessed", () => {
+
+            const useCurrentSegmentsRule = {
+                create: () => ({
+                    onCodePathStart(codePath) {
+                        codePath.currentSegments.forEach(() => {});
+                    }
+                })
+            };
+
+            ruleTester.run("use-current-segments", useCurrentSegmentsRule, {
+                valid: ["foo"],
+                invalid: []
+            });
+
+            assert.strictEqual(processStub.callCount, 1, "calls `process.emitWarning()` once");
+            assert.deepStrictEqual(
+                processStub.getCall(0).args,
+                [
+                    "\"use-current-segments\" rule uses CodePath#currentSegments and will stop working in ESLint v9. Please read the documentation for how to update your code: https://eslint.org/docs/latest/extend/code-path-analysis#usage-examples",
+                    "DeprecationWarning"
+                ]
+            );
+        });
+
+        Object.entries({
+            getSource: "getText",
+            getSourceLines: "getLines",
+            getAllComments: "getAllComments",
+            getNodeByRangeIndex: "getNodeByRangeIndex",
+            getCommentsBefore: "getCommentsBefore",
+            getCommentsAfter: "getCommentsAfter",
+            getCommentsInside: "getCommentsInside",
+            getJSDocComment: "getJSDocComment",
+            getFirstToken: "getFirstToken",
+            getFirstTokens: "getFirstTokens",
+            getLastToken: "getLastToken",
+            getLastTokens: "getLastTokens",
+            getTokenAfter: "getTokenAfter",
+            getTokenBefore: "getTokenBefore",
+            getTokenByRangeStart: "getTokenByRangeStart",
+            getTokens: "getTokens",
+            getTokensAfter: "getTokensAfter",
+            getTokensBefore: "getTokensBefore",
+            getTokensBetween: "getTokensBetween"
+        }).forEach(([methodName, replacementName]) => {
+
+
+            it(`should log a deprecation warning when calling \`context.${methodName}\``, () => {
+                const ruleToCheckDeprecation = {
+                    meta: {
+                        type: "problem",
+                        schema: []
+                    },
+                    create(context) {
+                        return {
+                            Program(node) {
+
+                                // special case
+                                if (methodName === "getTokensBetween") {
+                                    context[methodName](node, node);
+                                } else {
+                                    context[methodName](node);
+                                }
+
+                                context.report({ node, message: "bad" });
+                            }
+                        };
+                    }
+                };
+
+                ruleTester.run("deprecated-method", ruleToCheckDeprecation, {
+                    valid: [],
+                    invalid: [
+                        { code: "var foo = bar;", options: [], errors: 1 }
+                    ]
+                });
+
+                assert.strictEqual(processStub.callCount, 1, "calls `process.emitWarning()` once");
+                assert.deepStrictEqual(
+                    processStub.getCall(0).args,
+                    [
+                        `"deprecated-method" rule is using \`context.${methodName}()\`, which is deprecated and will be removed in ESLint v9. Please use \`sourceCode.${replacementName}()\` instead.`,
+                        "DeprecationWarning"
+                    ]
+                );
+            });
+
+        });
+
     });
 
     /**
diff --git a/tests/lib/rules/lines-between-class-members.js b/tests/lib/rules/lines-between-class-members.js
index feb9c085e..2ee17f713 100644
--- a/tests/lib/rules/lines-between-class-members.js
+++ b/tests/lib/rules/lines-between-class-members.js
@@ -50,24 +50,810 @@ ruleTester.run("lines-between-class-members", rule, {
         "class C {\naaa;\n\n#bbb;\n\nccc(){}\n\n#ddd(){}\n}",
 
         { code: "class foo{ bar(){}\nbaz(){}}", options: ["never"] },
-        { code: "class foo{ bar(){}\n/*comments*/baz(){}}", options: ["never"] },
-        { code: "class foo{ bar(){}\n//comments\nbaz(){}}", options: ["never"] },
-        { code: "class foo{ bar(){}/* comments\n\n*/baz(){}}", options: ["never"] },
-        { code: "class foo{ bar(){}/* \ncomments\n*/baz(){}}", options: ["never"] },
-        { code: "class foo{ bar(){}\n/* \ncomments\n*/\nbaz(){}}", options: ["never"] },
+        {
+            code: "class foo{ bar(){}\n/*comments*/baz(){}}",
+            options: ["never"]
+        },
+        {
+            code: "class foo{ bar(){}\n//comments\nbaz(){}}",
+            options: ["never"]
+        },
+        {
+            code: "class foo{ bar(){}/* comments\n\n*/baz(){}}",
+            options: ["never"]
+        },
+        {
+            code: "class foo{ bar(){}/* \ncomments\n*/baz(){}}",
+            options: ["never"]
+        },
+        {
+            code: "class foo{ bar(){}\n/* \ncomments\n*/\nbaz(){}}",
+            options: ["never"]
+        },
 
         { code: "class foo{ bar(){}\n\nbaz(){}}", options: ["always"] },
-        { code: "class foo{ bar(){}\n\n/*comments*/baz(){}}", options: ["always"] },
-        { code: "class foo{ bar(){}\n\n//comments\nbaz(){}}", options: ["always"] },
+        {
+            code: "class foo{ bar(){}\n\n/*comments*/baz(){}}",
+            options: ["always"]
+        },
+        {
+            code: "class foo{ bar(){}\n\n//comments\nbaz(){}}",
+            options: ["always"]
+        },
 
-        { code: "class foo{ bar(){}\nbaz(){}}", options: ["always", { exceptAfterSingleLine: true }] },
-        { code: "class foo{ bar(){\n}\n\nbaz(){}}", options: ["always", { exceptAfterSingleLine: true }] },
-        { code: "class foo{\naaa;\n#bbb;\nccc(){\n}\n\n#ddd(){\n}\n}", options: ["always", { exceptAfterSingleLine: true }] },
+        {
+            code: "class foo{ bar(){}\nbaz(){}}",
+            options: ["always", { exceptAfterSingleLine: true }]
+        },
+        {
+            code: "class foo{ bar(){\n}\n\nbaz(){}}",
+            options: ["always", { exceptAfterSingleLine: true }]
+        },
+        {
+            code: "class foo{\naaa;\n#bbb;\nccc(){\n}\n\n#ddd(){\n}\n}",
+            options: ["always", { exceptAfterSingleLine: true }]
+        },
 
         // semicolon-less style (semicolons are at the beginning of lines)
         { code: "class C { foo\n\n;bar }", options: ["always"] },
-        { code: "class C { foo\n;bar }", options: ["always", { exceptAfterSingleLine: true }] },
-        { code: "class C { foo\n;bar }", options: ["never"] }
+        {
+            code: "class C { foo\n;bar }",
+            options: ["always", { exceptAfterSingleLine: true }]
+        },
+        { code: "class C { foo\n;bar }", options: ["never"] },
+
+        // enforce option with blankLine: "always"
+        {
+            code: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+                fieldA = 'Field A';
+                #fieldB = 'Field B';
+
+                method1() {}
+
+                get area() {
+                    return this.method1();
+                }
+
+                method2() {}
+              }
+            `,
+            options: [
+                {
+                    enforce: [
+                        { blankLine: "always", prev: "method", next: "method" }
+                    ]
+                }
+            ]
+        },
+        {
+            code: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+
+                fieldA = 'Field A';
+
+                #fieldB = 'Field B';
+
+                method1() {}
+
+                get area() {
+                    return this.method1();
+                }
+
+                method2() {}
+              }
+            `,
+            options: [
+                {
+                    enforce: [
+                        { blankLine: "always", prev: "method", next: "method" }
+                    ]
+                }
+            ]
+        },
+        {
+            code: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+
+                fieldA = 'Field A';
+                #fieldB = 'Field B';
+
+                method1() {}
+                get area() {
+                    return this.method1();
+                }
+                method2() {}
+              }
+            `,
+            options: [
+                {
+                    enforce: [
+                        { blankLine: "always", prev: "method", next: "field" }
+                    ]
+                }
+            ]
+        },
+        {
+            code: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+
+                fieldA = 'Field A';
+
+                #fieldB = 'Field B';
+
+                method1() {}
+
+                get area() {
+                    return this.method1();
+                }
+
+                method2() {}
+              }
+            `,
+            options: [
+                {
+                    enforce: [
+                        { blankLine: "always", prev: "method", next: "field" }
+                    ]
+                }
+            ]
+        },
+        {
+            code: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+
+                fieldA = 'Field A';
+                #fieldB = 'Field B';
+
+                method1() {}
+
+                get area() {
+                    return this.method1();
+                }
+
+                method2() {}
+              }
+            `,
+            options: [
+                {
+                    enforce: [
+                        { blankLine: "always", prev: "method", next: "*" }
+                    ]
+                }
+            ]
+        },
+        {
+            code: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+
+                fieldA = 'Field A';
+                #fieldB = 'Field B';
+
+                method1() {}
+                get area() {
+                    return this.method1();
+                }
+                method2() {}
+              }
+            `,
+            options: [
+                {
+                    enforce: [
+                        { blankLine: "always", prev: "field", next: "method" }
+                    ]
+                }
+            ]
+        },
+
+        {
+            code: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+                fieldA = 'Field A';
+
+                #fieldB = 'Field B';
+                method1() {}
+                get area() {
+                    return this.method1();
+                }
+                method2() {}
+              }
+            `,
+            options: [
+                {
+                    enforce: [
+                        { blankLine: "always", prev: "field", next: "field" }
+                    ]
+                }
+            ]
+        },
+        {
+            code: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+                fieldA = 'Field A';
+
+                #fieldB = 'Field B';
+
+                method1() {}
+                get area() {
+                    return this.method1();
+                }
+                method2() {}
+              }
+            `,
+            options: [
+                {
+                    enforce: [
+                        { blankLine: "always", prev: "field", next: "*" }
+                    ]
+                }
+            ]
+        },
+        {
+            code: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+
+                fieldA = 'Field A';
+                #fieldB = 'Field B';
+
+                method1() {}
+
+                get area() {
+                    return this.method1();
+                }
+
+                method2() {}
+              }
+            `,
+            options: [
+                {
+                    enforce: [
+                        { blankLine: "always", prev: "*", next: "method" }
+                    ]
+                }
+            ]
+        },
+        {
+            code: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+
+                fieldA = 'Field A';
+
+                #fieldB = 'Field B';
+                method1() {}
+                get area() {
+                    return this.method1();
+                }
+                method2() {}
+              }
+            `,
+            options: [
+                {
+                    enforce: [
+                        { blankLine: "always", prev: "*", next: "field" }
+                    ]
+                }
+            ]
+        },
+        {
+            code: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+
+                fieldA = 'Field A';
+
+                #fieldB = 'Field B';
+
+                method1() {}
+
+                get area() {
+                    return this.method1();
+                }
+
+                method2() {}
+              }
+            `,
+            options: [
+                { enforce: [{ blankLine: "always", prev: "*", next: "*" }] }
+            ]
+        },
+
+        // enforce option - blankLine: "never"
+        {
+            code: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+                fieldA = 'Field A';
+                #fieldB = 'Field B';
+                method1() {}
+                get area() {
+                    return this.method1();
+                }
+                method2() {}
+              }
+            `,
+            options: [
+                {
+                    enforce: [
+                        { blankLine: "never", prev: "method", next: "method" }
+                    ]
+                }
+            ]
+        },
+        {
+            code: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+
+                fieldA = 'Field A';
+
+                #fieldB = 'Field B';
+
+                method1() {}
+                get area() {
+                    return this.method1();
+                }
+                method2() {}
+              }
+            `,
+            options: [
+                {
+                    enforce: [
+                        { blankLine: "never", prev: "method", next: "method" }
+                    ]
+                }
+            ]
+        },
+        {
+            code: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+                fieldA = 'Field A';
+                #fieldB = 'Field B';
+
+                method1() {}
+                get area() {
+                    return this.method1();
+                }
+                method2() {}
+              }
+            `,
+            options: [
+                {
+                    enforce: [
+                        { blankLine: "never", prev: "method", next: "field" }
+                    ]
+                }
+            ]
+        },
+        {
+            code: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+                fieldA = 'Field A';
+
+                #fieldB = 'Field B';
+
+                method1() {}
+
+                get area() {
+                    return this.method1();
+                }
+
+                method2() {}
+              }
+            `,
+            options: [
+                {
+                    enforce: [
+                        { blankLine: "never", prev: "method", next: "field" }
+                    ]
+                }
+            ]
+        },
+        {
+            code: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+                fieldA = 'Field A';
+
+                #fieldB = 'Field B';
+
+                method1() {}
+                get area() {
+                    return this.method1();
+                }
+                method2() {}
+              }
+            `,
+            options: [
+                {
+                    enforce: [
+                        { blankLine: "never", prev: "method", next: "*" }
+                    ]
+                }
+            ]
+        },
+        {
+            code: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+
+                fieldA = 'Field A';
+
+                #fieldB = 'Field B';
+                method1() {}
+
+                get area() {
+                    return this.method1();
+                }
+
+                method2() {}
+              }
+            `,
+            options: [
+                {
+                    enforce: [
+                        { blankLine: "never", prev: "field", next: "method" }
+                    ]
+                }
+            ]
+        },
+
+        {
+            code: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+
+                fieldA = 'Field A';
+                #fieldB = 'Field B';
+
+                method1() {}
+
+                get area() {
+                    return this.method1();
+                }
+
+                method2() {}
+              }
+            `,
+            options: [
+                {
+                    enforce: [
+                        { blankLine: "never", prev: "field", next: "field" }
+                    ]
+                }
+            ]
+        },
+        {
+            code: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+
+                fieldA = 'Field A';
+                #fieldB = 'Field B';
+                method1() {}
+
+                get area() {
+                    return this.method1();
+                }
+
+                method2() {}
+              }
+            `,
+            options: [
+                {
+                    enforce: [{ blankLine: "never", prev: "field", next: "*" }]
+                }
+            ]
+        },
+        {
+            code: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+
+                fieldA = 'Field A';
+
+                #fieldB = 'Field B';
+                method1() {}
+                get area() {
+                    return this.method1();
+                }
+                method2() {}
+              }
+            `,
+            options: [
+                {
+                    enforce: [
+                        { blankLine: "never", prev: "*", next: "method" }
+                    ]
+                }
+            ]
+        },
+        {
+            code: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+                fieldA = 'Field A';
+                #fieldB = 'Field B';
+
+                method1() {}
+
+                get area() {
+                    return this.method1();
+                }
+                method2() {}
+              }
+            `,
+            options: [
+                {
+                    enforce: [{ blankLine: "never", prev: "*", next: "field" }]
+                }
+            ]
+        },
+        {
+            code: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+                fieldA = 'Field A';
+                #fieldB = 'Field B';
+                method1() {}
+                get area() {
+                    return this.method1();
+                }
+                method2() {}
+              }
+            `,
+            options: [
+                { enforce: [{ blankLine: "never", prev: "*", next: "*" }] }
+            ]
+        },
+
+        // enforce option - multiple configurations
+        {
+            code: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+
+                fieldA = 'Field A';
+                #fieldB = 'Field B';
+
+                method1() {}
+
+                get area() {
+                    return this.method1();
+                }
+
+                method2() {}
+              }
+            `,
+            options: [
+                {
+
+                    // requires blank lines around methods, disallows blank lines between fields
+                    enforce: [
+                        { blankLine: "always", prev: "*", next: "method" },
+                        { blankLine: "always", prev: "method", next: "*" },
+                        { blankLine: "never", prev: "field", next: "field" }
+                    ]
+                }
+            ]
+        },
+        {
+            code: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+
+                fieldA = 'Field A';
+
+                #fieldB = 'Field B';
+
+                method1() {}
+                get area() {
+                    return this.method1();
+                }
+                method2() {}
+              }
+            `,
+            options: [
+                {
+
+                    // requires blank lines around fields, disallows blank lines between methods
+                    enforce: [
+                        { blankLine: "always", prev: "*", next: "field" },
+                        { blankLine: "always", prev: "field", next: "*" },
+                        { blankLine: "never", prev: "method", next: "method" }
+                    ]
+                }
+            ]
+        },
+        {
+            code: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+
+                fieldA = 'Field A';
+
+                #fieldB = 'Field B';
+
+                method1() {}
+
+                get area() {
+                    return this.method1();
+                }
+                
+                method2() {}
+              }
+            `,
+            options: [
+                {
+
+                    // requires blank lines around methods and fields
+                    enforce: [
+                        { blankLine: "always", prev: "*", next: "method" },
+                        { blankLine: "always", prev: "method", next: "*" },
+                        { blankLine: "always", prev: "field", next: "field" }
+                    ]
+                }
+            ]
+        },
+        {
+            code: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+
+                fieldA = 'Field A';
+
+                #fieldB = 'Field B';
+
+                method1() {}
+
+                get area() {
+                    return this.method1();
+                }
+                
+                method2() {}
+              }
+            `,
+            options: [
+                {
+
+                    // requires blank lines around methods and fields
+                    enforce: [
+                        { blankLine: "never", prev: "*", next: "method" },
+                        { blankLine: "never", prev: "method", next: "*" },
+                        { blankLine: "never", prev: "field", next: "field" },
+
+                        // This should take precedence over the above
+                        { blankLine: "always", prev: "*", next: "method" },
+                        { blankLine: "always", prev: "method", next: "*" },
+                        { blankLine: "always", prev: "field", next: "field" }
+                    ]
+                }
+            ]
+        },
+
+        // enforce with exceptAfterSingleLine option
+        {
+            code: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+
+                fieldA = 'Field A';
+                #fieldB = 'Field B';
+                method1() {}
+                get area() {
+                    return this.method1();
+                }
+
+                method2() {}
+              }
+            `,
+            options: [
+                {
+
+                    // requires blank lines around methods and fields
+                    enforce: [
+                        { blankLine: "always", prev: "*", next: "method" },
+                        { blankLine: "always", prev: "method", next: "*" },
+                        { blankLine: "always", prev: "field", next: "field" }
+                    ]
+                },
+                {
+                    exceptAfterSingleLine: true
+                }
+            ]
+        }
     ],
     invalid: [
         {
@@ -75,97 +861,116 @@ ruleTester.run("lines-between-class-members", rule, {
             output: "class foo{ bar(){}\n\nbaz(){}}",
             options: ["always"],
             errors: [alwaysError]
-        }, {
+        },
+        {
             code: "class foo{ bar(){}\n\nbaz(){}}",
             output: "class foo{ bar(){}\nbaz(){}}",
             options: ["never"],
             errors: [neverError]
-        }, {
+        },
+        {
             code: "class foo{ bar(){\n}\nbaz(){}}",
             output: "class foo{ bar(){\n}\n\nbaz(){}}",
             options: ["always", { exceptAfterSingleLine: true }],
             errors: [alwaysError]
-        }, {
+        },
+        {
             code: "class foo{ bar(){\n}\n/* comment */\nbaz(){}}",
             output: "class foo{ bar(){\n}\n\n/* comment */\nbaz(){}}",
             options: ["always", { exceptAfterSingleLine: true }],
             errors: [alwaysError]
-        }, {
+        },
+        {
             code: "class foo{ bar(){}\n\n// comment\nbaz(){}}",
             output: "class foo{ bar(){}\n// comment\nbaz(){}}",
             options: ["never"],
             errors: [neverError]
-        }, {
+        },
+        {
             code: "class foo{ bar(){}\n\n/* comment */\nbaz(){}}",
             output: "class foo{ bar(){}\n/* comment */\nbaz(){}}",
             options: ["never"],
             errors: [neverError]
-        }, {
+        },
+        {
             code: "class foo{ bar(){}\n/* comment-1 */\n\n/* comment-2 */\nbaz(){}}",
             output: "class foo{ bar(){}\n/* comment-1 */\n/* comment-2 */\nbaz(){}}",
             options: ["never"],
             errors: [neverError]
-        }, {
+        },
+        {
             code: "class foo{ bar(){}\n\n/* comment */\n\nbaz(){}}",
             output: null,
             options: ["never"],
             errors: [neverError]
-        }, {
+        },
+        {
             code: "class foo{ bar(){}\n\n// comment\n\nbaz(){}}",
             output: null,
             options: ["never"],
             errors: [neverError]
-        }, {
+        },
+        {
             code: "class foo{ bar(){}\n/* comment-1 */\n\n/* comment-2 */\n\n/* comment-3 */\nbaz(){}}",
             output: null,
             options: ["never"],
             errors: [neverError]
-        }, {
+        },
+        {
             code: "class foo{ bar(){}\n/* comment-1 */\n\n;\n\n/* comment-3 */\nbaz(){}}",
             output: null,
             options: ["never"],
             errors: [neverError]
-        }, {
+        },
+        {
             code: "class A {\nfoo() {}// comment\n;\n/* comment */\nbar() {}\n}",
             output: "class A {\nfoo() {}// comment\n\n;\n/* comment */\nbar() {}\n}",
             options: ["always"],
             errors: [alwaysError]
-        }, {
+        },
+        {
             code: "class A {\nfoo() {}\n/* comment */;\n;\n/* comment */\nbar() {}\n}",
             output: "class A {\nfoo() {}\n\n/* comment */;\n;\n/* comment */\nbar() {}\n}",
             options: ["always"],
             errors: [alwaysError]
-        }, {
+        },
+        {
             code: "class foo{ bar(){};\nbaz(){}}",
             output: "class foo{ bar(){};\n\nbaz(){}}",
             options: ["always"],
             errors: [alwaysError]
-        }, {
+        },
+        {
             code: "class foo{ bar(){} // comment \nbaz(){}}",
             output: "class foo{ bar(){} // comment \n\nbaz(){}}",
             options: ["always"],
             errors: [alwaysError]
-        }, {
+        },
+        {
             code: "class A {\nfoo() {}\n/* comment */;\n;\nbar() {}\n}",
             output: "class A {\nfoo() {}\n\n/* comment */;\n;\nbar() {}\n}",
             options: ["always"],
             errors: [alwaysError]
-        }, {
+        },
+        {
             code: "class C {\nfield1\nfield2\n}",
             output: "class C {\nfield1\n\nfield2\n}",
             options: ["always"],
             errors: [alwaysError]
-        }, {
+        },
+        {
             code: "class C {\n#field1\n#field2\n}",
             output: "class C {\n#field1\n\n#field2\n}",
             options: ["always"],
             errors: [alwaysError]
-        }, {
+        },
+        {
             code: "class C {\nfield1\n\nfield2\n}",
             output: "class C {\nfield1\nfield2\n}",
             options: ["never"],
             errors: [neverError]
-        }, {
+        },
+        {
             code: "class C {\nfield1 = () => {\n}\nfield2\nfield3\n}",
             output: "class C {\nfield1 = () => {\n}\n\nfield2\nfield3\n}",
             options: ["always", { exceptAfterSingleLine: true }],
@@ -208,6 +1013,1610 @@ ruleTester.run("lines-between-class-members", rule, {
             output: "class C { foo\n\n;;bar }",
             options: ["always"],
             errors: [alwaysError]
+        },
+
+        // enforce option with blankLine: "always"
+        {
+            code: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+                fieldA = 'Field A';
+                #fieldB = 'Field B';
+
+                method1() {}
+                get area() {
+                    return this.method1();
+                }
+                method2() {}
+              }
+            `,
+            output: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+                fieldA = 'Field A';
+                #fieldB = 'Field B';
+
+                method1() {}
+
+                get area() {
+                    return this.method1();
+                }
+
+                method2() {}
+              }
+            `,
+            options: [
+                {
+                    enforce: [
+                        { blankLine: "always", prev: "method", next: "method" }
+                    ]
+                }
+            ],
+            errors: [
+                {
+                    messageId: "always",
+                    line: 11,
+                    column: 17
+                },
+                {
+                    messageId: "always",
+                    line: 14,
+                    column: 17
+                }
+            ]
+        },
+        {
+            code: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+
+                fieldA = 'Field A';
+
+                #fieldB = 'Field B';
+
+                method1() {}
+                get area() {
+                    return this.method1();
+                }
+                method2() {}
+              }
+            `,
+            output: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+
+                fieldA = 'Field A';
+
+                #fieldB = 'Field B';
+
+                method1() {}
+
+                get area() {
+                    return this.method1();
+                }
+
+                method2() {}
+              }
+            `,
+            options: [
+                {
+                    enforce: [
+                        { blankLine: "always", prev: "method", next: "method" }
+                    ]
+                }
+            ],
+            errors: [
+                {
+                    messageId: "always",
+                    line: 13,
+                    column: 17
+                },
+                {
+                    messageId: "always",
+                    line: 16,
+                    column: 17
+                }
+            ]
+        },
+        {
+            code: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+                fieldA = 'Field A';
+                #fieldB = 'Field B';
+
+                method1() {}
+                get area() {
+                    return this.method1();
+                }
+                method2() {}
+              }
+            `,
+            output: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+
+                fieldA = 'Field A';
+                #fieldB = 'Field B';
+
+                method1() {}
+                get area() {
+                    return this.method1();
+                }
+                method2() {}
+              }
+            `,
+            options: [
+                {
+                    enforce: [
+                        { blankLine: "always", prev: "method", next: "field" }
+                    ]
+                }
+            ],
+            errors: [
+                {
+                    messageId: "always",
+                    line: 7,
+                    column: 17
+                }
+            ]
+        },
+        {
+            code: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+                fieldA = 'Field A';
+                #fieldB = 'Field B';
+                method1() {}
+                get area() {
+                    return this.method1();
+                }
+                method2() {}
+              }
+            `,
+            output: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+
+                fieldA = 'Field A';
+                #fieldB = 'Field B';
+                method1() {}
+                get area() {
+                    return this.method1();
+                }
+                method2() {}
+              }
+            `,
+            options: [
+                {
+                    enforce: [
+                        { blankLine: "always", prev: "method", next: "field" }
+                    ]
+                }
+            ],
+            errors: [
+                {
+                    messageId: "always",
+                    line: 7,
+                    column: 17
+                }
+            ]
+        },
+        {
+            code: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+                fieldA = 'Field A';
+                #fieldB = 'Field B';
+
+                method1() {}
+                get area() {
+                    return this.method1();
+                }
+                method2() {}
+              }
+            `,
+            output: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+
+                fieldA = 'Field A';
+                #fieldB = 'Field B';
+
+                method1() {}
+
+                get area() {
+                    return this.method1();
+                }
+
+                method2() {}
+              }
+            `,
+            options: [
+                {
+                    enforce: [
+                        { blankLine: "always", prev: "method", next: "*" }
+                    ]
+                }
+            ],
+            errors: [
+                {
+                    messageId: "always",
+                    line: 7,
+                    column: 17
+                },
+                {
+                    messageId: "always",
+                    line: 11,
+                    column: 17
+                },
+                {
+                    messageId: "always",
+                    line: 14,
+                    column: 17
+                }
+            ]
+        },
+        {
+            code: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+                fieldA = 'Field A';
+                #fieldB = 'Field B';
+                method1() {}
+                get area() {
+                    return this.method1();
+                }
+                method2() {}
+              }
+            `,
+            output: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+                fieldA = 'Field A';
+                #fieldB = 'Field B';
+
+                method1() {}
+                get area() {
+                    return this.method1();
+                }
+                method2() {}
+              }
+            `,
+            options: [
+                {
+                    enforce: [
+                        { blankLine: "always", prev: "field", next: "method" }
+                    ]
+                }
+            ],
+            errors: [
+                {
+                    messageId: "always",
+                    line: 9,
+                    column: 17
+                }
+            ]
+        },
+        {
+            code: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+                fieldA = 'Field A';
+                #fieldB = 'Field B';
+                method1() {}
+                get area() {
+                    return this.method1();
+                }
+                method2() {}
+              }
+            `,
+            output: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+                fieldA = 'Field A';
+
+                #fieldB = 'Field B';
+                method1() {}
+                get area() {
+                    return this.method1();
+                }
+                method2() {}
+              }
+            `,
+            options: [
+                {
+                    enforce: [
+                        { blankLine: "always", prev: "field", next: "field" }
+                    ]
+                }
+            ],
+            errors: [
+                {
+                    messageId: "always",
+                    line: 8,
+                    column: 17
+                }
+            ]
+        },
+        {
+            code: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+                fieldA = 'Field A';
+                #fieldB = 'Field B';
+                method1() {}
+                get area() {
+                    return this.method1();
+                }
+                method2() {}
+              }
+            `,
+            output: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+                fieldA = 'Field A';
+
+                #fieldB = 'Field B';
+
+                method1() {}
+                get area() {
+                    return this.method1();
+                }
+                method2() {}
+              }
+            `,
+            options: [
+                {
+                    enforce: [
+                        { blankLine: "always", prev: "field", next: "*" }
+                    ]
+                }
+            ],
+            errors: [
+                {
+                    messageId: "always",
+                    line: 8,
+                    column: 17
+                },
+                {
+                    messageId: "always",
+                    line: 9,
+                    column: 17
+                }
+            ]
+        },
+        {
+            code: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+                fieldA = 'Field A';
+                #fieldB = 'Field B';
+                method1() {}
+                get area() {
+                    return this.method1();
+                }
+                method2() {}
+              }
+            `,
+            output: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+                fieldA = 'Field A';
+                #fieldB = 'Field B';
+
+                method1() {}
+
+                get area() {
+                    return this.method1();
+                }
+
+                method2() {}
+              }
+            `,
+            options: [
+                {
+                    enforce: [
+                        { blankLine: "always", prev: "*", next: "method" }
+                    ]
+                }
+            ],
+            errors: [
+                {
+                    messageId: "always",
+                    line: 9,
+                    column: 17
+                },
+                {
+                    messageId: "always",
+                    line: 10,
+                    column: 17
+                },
+                {
+                    messageId: "always",
+                    line: 13,
+                    column: 17
+                }
+            ]
+        },
+        {
+            code: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+                fieldA = 'Field A';
+                #fieldB = 'Field B';
+                method1() {}
+                get area() {
+                    return this.method1();
+                }
+                method2() {}
+              }
+            `,
+            output: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+
+                fieldA = 'Field A';
+
+                #fieldB = 'Field B';
+                method1() {}
+                get area() {
+                    return this.method1();
+                }
+                method2() {}
+              }
+            `,
+            options: [
+                {
+                    enforce: [
+                        { blankLine: "always", prev: "*", next: "field" }
+                    ]
+                }
+            ],
+            errors: [
+                {
+                    messageId: "always",
+                    line: 7,
+                    column: 17
+                },
+                {
+                    messageId: "always",
+                    line: 8,
+                    column: 17
+                }
+            ]
+        },
+        {
+            code: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+                fieldA = 'Field A';
+                #fieldB = 'Field B';
+                method1() {}
+                get area() {
+                    return this.method1();
+                }
+                method2() {}
+              }
+            `,
+            output: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+
+                fieldA = 'Field A';
+
+                #fieldB = 'Field B';
+
+                method1() {}
+
+                get area() {
+                    return this.method1();
+                }
+
+                method2() {}
+              }
+            `,
+            options: [
+                { enforce: [{ blankLine: "always", prev: "*", next: "*" }] }
+            ],
+            errors: [
+                {
+                    messageId: "always",
+                    line: 7,
+                    column: 17
+                },
+                {
+                    messageId: "always",
+                    line: 8,
+                    column: 17
+                },
+                {
+                    messageId: "always",
+                    line: 9,
+                    column: 17
+                },
+                {
+                    messageId: "always",
+                    line: 10,
+                    column: 17
+                },
+                {
+                    messageId: "always",
+                    line: 13,
+                    column: 17
+                }
+            ]
+        },
+
+        // enforce option - blankLine: "never"
+        {
+            code: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+                fieldA = 'Field A';
+                #fieldB = 'Field B';
+                method1() {}
+                
+                get area() {
+                    return this.method1();
+                }
+
+                method2() {}
+              }
+            `,
+            output: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+                fieldA = 'Field A';
+                #fieldB = 'Field B';
+                method1() {}
+get area() {
+                    return this.method1();
+                }
+method2() {}
+              }
+            `,
+            options: [
+                {
+                    enforce: [
+                        { blankLine: "never", prev: "method", next: "method" }
+                    ]
+                }
+            ],
+            errors: [
+                {
+                    messageId: "never",
+                    line: 11,
+                    column: 17
+                },
+                {
+                    messageId: "never",
+                    line: 15,
+                    column: 17
+                }
+            ]
+        },
+        {
+            code: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+
+                fieldA = 'Field A';
+
+                #fieldB = 'Field B';
+
+                method1() {}
+
+                get area() {
+                    return this.method1();
+                }
+
+                method2() {}
+              }
+            `,
+            output: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+
+                fieldA = 'Field A';
+
+                #fieldB = 'Field B';
+
+                method1() {}
+get area() {
+                    return this.method1();
+                }
+method2() {}
+              }
+            `,
+            options: [
+                {
+                    enforce: [
+                        { blankLine: "never", prev: "method", next: "method" }
+                    ]
+                }
+            ],
+            errors: [
+                {
+                    messageId: "never",
+                    line: 14,
+                    column: 17
+                },
+                {
+                    messageId: "never",
+                    line: 18,
+                    column: 17
+                }
+            ]
+        },
+        {
+            code: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+
+                fieldA = 'Field A';
+                #fieldB = 'Field B';
+
+                method1() {}
+
+                get area() {
+                    return this.method1();
+                }
+
+                method2() {}
+              }
+            `,
+            output: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+fieldA = 'Field A';
+                #fieldB = 'Field B';
+
+                method1() {}
+
+                get area() {
+                    return this.method1();
+                }
+
+                method2() {}
+              }
+            `,
+            options: [
+                {
+                    enforce: [
+                        { blankLine: "never", prev: "method", next: "field" }
+                    ]
+                }
+            ],
+            errors: [
+                {
+                    messageId: "never",
+                    line: 8,
+                    column: 17
+                }
+            ]
+        },
+        {
+            code: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+                
+                fieldA = 'Field A';
+
+                #fieldB = 'Field B';
+
+                method1() {}
+
+                get area() {
+                    return this.method1();
+                }
+
+                method2() {}
+              }
+            `,
+            output: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+fieldA = 'Field A';
+
+                #fieldB = 'Field B';
+
+                method1() {}
+
+                get area() {
+                    return this.method1();
+                }
+
+                method2() {}
+              }
+            `,
+            options: [
+                {
+                    enforce: [
+                        { blankLine: "never", prev: "method", next: "field" }
+                    ]
+                }
+            ],
+            errors: [
+                {
+                    messageId: "never",
+                    line: 8,
+                    column: 17
+                }
+            ]
+        },
+        {
+            code: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+
+                fieldA = 'Field A';
+
+                #fieldB = 'Field B';
+
+                method1() {}
+
+                get area() {
+                    return this.method1();
+                }
+
+                method2() {}
+              }
+            `,
+            output: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+fieldA = 'Field A';
+
+                #fieldB = 'Field B';
+
+                method1() {}
+get area() {
+                    return this.method1();
+                }
+method2() {}
+              }
+            `,
+            options: [
+                {
+                    enforce: [
+                        { blankLine: "never", prev: "method", next: "*" }
+                    ]
+                }
+            ],
+            errors: [
+                {
+                    messageId: "never",
+                    line: 8,
+                    column: 17
+                },
+                {
+                    messageId: "never",
+                    line: 14,
+                    column: 17
+                },
+                {
+                    messageId: "never",
+                    line: 18,
+                    column: 17
+                }
+            ]
+        },
+        {
+            code: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+
+                fieldA = 'Field A';
+
+                #fieldB = 'Field B';
+
+                method1() {}
+
+                get area() {
+                    return this.method1();
+                }
+
+                method2() {}
+              }
+            `,
+            output: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+
+                fieldA = 'Field A';
+
+                #fieldB = 'Field B';
+method1() {}
+
+                get area() {
+                    return this.method1();
+                }
+
+                method2() {}
+              }
+            `,
+            options: [
+                {
+                    enforce: [
+                        { blankLine: "never", prev: "field", next: "method" }
+                    ]
+                }
+            ],
+            errors: [
+                {
+                    messageId: "never",
+                    line: 12,
+                    column: 17
+                }
+            ]
+        },
+        {
+            code: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+
+                fieldA = 'Field A';
+
+                #fieldB = 'Field B';
+
+                method1() {}
+
+                get area() {
+                    return this.method1();
+                }
+
+                method2() {}
+              }
+            `,
+            output: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+
+                fieldA = 'Field A';
+#fieldB = 'Field B';
+
+                method1() {}
+
+                get area() {
+                    return this.method1();
+                }
+
+                method2() {}
+              }
+            `,
+            options: [
+                {
+                    enforce: [
+                        { blankLine: "never", prev: "field", next: "field" }
+                    ]
+                }
+            ],
+            errors: [
+                {
+                    messageId: "never",
+                    line: 10,
+                    column: 17
+                }
+            ]
+        },
+        {
+            code: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+
+                fieldA = 'Field A';
+
+                #fieldB = 'Field B';
+
+                method1() {}
+
+                get area() {
+                    return this.method1();
+                }
+
+                method2() {}
+              }
+            `,
+            output: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+
+                fieldA = 'Field A';
+#fieldB = 'Field B';
+method1() {}
+
+                get area() {
+                    return this.method1();
+                }
+
+                method2() {}
+              }
+            `,
+            options: [
+                {
+                    enforce: [
+                        { blankLine: "never", prev: "field", next: "*" }
+                    ]
+                }
+            ],
+            errors: [
+                {
+                    messageId: "never",
+                    line: 10,
+                    column: 17
+                },
+                {
+                    messageId: "never",
+                    line: 12,
+                    column: 17
+                }
+            ]
+        },
+        {
+            code: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+
+                fieldA = 'Field A';
+
+                #fieldB = 'Field B';
+
+                method1() {}
+
+                get area() {
+                    return this.method1();
+                }
+
+                method2() {}
+              }
+            `,
+            output: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+
+                fieldA = 'Field A';
+
+                #fieldB = 'Field B';
+method1() {}
+get area() {
+                    return this.method1();
+                }
+method2() {}
+              }
+            `,
+            options: [
+                {
+                    enforce: [
+                        { blankLine: "never", prev: "*", next: "method" }
+                    ]
+                }
+            ],
+            errors: [
+                {
+                    messageId: "never",
+                    line: 12,
+                    column: 17
+                },
+                {
+                    messageId: "never",
+                    line: 14,
+                    column: 17
+                },
+                {
+                    messageId: "never",
+                    line: 18,
+                    column: 17
+                }
+            ]
+        },
+        {
+            code: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+
+                fieldA = 'Field A';
+
+                #fieldB = 'Field B';
+
+                method1() {}
+
+                get area() {
+                    return this.method1();
+                }
+                method2() {}
+              }
+            `,
+            output: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+fieldA = 'Field A';
+#fieldB = 'Field B';
+
+                method1() {}
+
+                get area() {
+                    return this.method1();
+                }
+                method2() {}
+              }
+            `,
+            options: [
+                {
+                    enforce: [
+                        { blankLine: "never", prev: "*", next: "field" }
+                    ]
+                }
+            ],
+            errors: [
+                {
+                    messageId: "never",
+                    line: 8,
+                    column: 17
+                },
+                {
+                    messageId: "never",
+                    line: 10,
+                    column: 17
+                }
+            ]
+        },
+        {
+            code: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+
+                fieldA = 'Field A';
+
+                #fieldB = 'Field B';
+
+                method1() {}
+
+                get area() {
+                    return this.method1();
+                }
+
+                method2() {}
+              }
+            `,
+            output: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+fieldA = 'Field A';
+#fieldB = 'Field B';
+method1() {}
+get area() {
+                    return this.method1();
+                }
+method2() {}
+              }
+            `,
+            options: [
+                { enforce: [{ blankLine: "never", prev: "*", next: "*" }] }
+            ],
+            errors: [
+                {
+                    messageId: "never",
+                    line: 8,
+                    column: 17
+                },
+                {
+                    messageId: "never",
+                    line: 10,
+                    column: 17
+                },
+                {
+                    messageId: "never",
+                    line: 12,
+                    column: 17
+                },
+                {
+                    messageId: "never",
+                    line: 14,
+                    column: 17
+                }, {
+                    messageId: "never",
+                    line: 18,
+                    column: 17
+                }
+            ]
+        },
+
+        // enforce option - multiple configurations
+        {
+            code: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+                fieldA = 'Field A';
+
+                #fieldB = 'Field B';
+                method1() {}
+                get area() {
+                    return this.method1();
+                }
+                method2() {}
+              }
+            `,
+            output: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+
+                fieldA = 'Field A';
+#fieldB = 'Field B';
+
+                method1() {}
+
+                get area() {
+                    return this.method1();
+                }
+
+                method2() {}
+              }
+            `,
+            options: [
+                {
+
+                    // requires blank lines around methods, disallows blank lines between fields
+                    enforce: [
+                        { blankLine: "always", prev: "*", next: "method" },
+                        { blankLine: "always", prev: "method", next: "*" },
+                        { blankLine: "never", prev: "field", next: "field" }
+                    ]
+                }
+            ],
+            errors: [
+                {
+                    messageId: "always",
+                    line: 7,
+                    column: 17
+                },
+                {
+                    messageId: "never",
+                    line: 9,
+                    column: 17
+                },
+                {
+                    messageId: "always",
+                    line: 10,
+                    column: 17
+                },
+                {
+                    messageId: "always",
+                    line: 11,
+                    column: 17
+                }, {
+                    messageId: "always",
+                    line: 14,
+                    column: 17
+                }
+            ]
+        },
+        {
+            code: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+                fieldA = 'Field A';
+                #fieldB = 'Field B';
+                method1() {}
+
+                get area() {
+                    return this.method1();
+                }
+
+                method2() {}
+              }
+            `,
+            output: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+
+                fieldA = 'Field A';
+
+                #fieldB = 'Field B';
+
+                method1() {}
+get area() {
+                    return this.method1();
+                }
+method2() {}
+              }
+            `,
+            options: [
+                {
+
+                    // requires blank lines around fields, disallows blank lines between methods
+                    enforce: [
+                        { blankLine: "always", prev: "*", next: "field" },
+                        { blankLine: "always", prev: "field", next: "*" },
+                        { blankLine: "never", prev: "method", next: "method" }
+                    ]
+                }
+            ],
+            errors: [
+                {
+                    messageId: "always",
+                    line: 7,
+                    column: 17
+                },
+                {
+                    messageId: "always",
+                    line: 8,
+                    column: 17
+                },
+                {
+                    messageId: "always",
+                    line: 9,
+                    column: 17
+                },
+                {
+                    messageId: "never",
+                    line: 11,
+                    column: 17
+                }, {
+                    messageId: "never",
+                    line: 15,
+                    column: 17
+                }
+            ]
+        },
+        {
+            code: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+                fieldA = 'Field A';
+                #fieldB = 'Field B';
+                method1() {}
+                get area() {
+                    return this.method1();
+                }
+                method2() {}
+              }
+            `,
+            output: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+
+                fieldA = 'Field A';
+
+                #fieldB = 'Field B';
+
+                method1() {}
+
+                get area() {
+                    return this.method1();
+                }
+
+                method2() {}
+              }
+            `,
+            options: [
+                {
+
+                    // requires blank lines around methods and fields
+                    enforce: [
+                        { blankLine: "always", prev: "*", next: "method" },
+                        { blankLine: "always", prev: "method", next: "*" },
+                        { blankLine: "always", prev: "field", next: "field" }
+                    ]
+                }
+            ],
+            errors: [
+                {
+                    messageId: "always",
+                    line: 7,
+                    column: 17
+                },
+                {
+                    messageId: "always",
+                    line: 8,
+                    column: 17
+                },
+                {
+                    messageId: "always",
+                    line: 9,
+                    column: 17
+                },
+                {
+                    messageId: "always",
+                    line: 10,
+                    column: 17
+                }, {
+                    messageId: "always",
+                    line: 13,
+                    column: 17
+                }
+            ]
+        },
+        {
+            code: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+                fieldA = 'Field A';
+                #fieldB = 'Field B';
+                method1() {}
+                get area() {
+                    return this.method1();
+                }
+                method2() {}
+              }
+            `,
+            output: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+
+                fieldA = 'Field A';
+
+                #fieldB = 'Field B';
+
+                method1() {}
+
+                get area() {
+                    return this.method1();
+                }
+
+                method2() {}
+              }
+            `,
+            options: [
+                {
+
+                    // requires blank lines around methods and fields
+                    enforce: [
+                        { blankLine: "never", prev: "*", next: "method" },
+                        { blankLine: "never", prev: "method", next: "*" },
+                        { blankLine: "never", prev: "field", next: "field" },
+
+                        // This should take precedence over the above
+                        { blankLine: "always", prev: "*", next: "method" },
+                        { blankLine: "always", prev: "method", next: "*" },
+                        { blankLine: "always", prev: "field", next: "field" }
+                    ]
+                }
+            ],
+            errors: [
+                {
+                    messageId: "always",
+                    line: 7,
+                    column: 17
+                },
+                {
+                    messageId: "always",
+                    line: 8,
+                    column: 17
+                },
+                {
+                    messageId: "always",
+                    line: 9,
+                    column: 17
+                },
+                {
+                    messageId: "always",
+                    line: 10,
+                    column: 17
+                }, {
+                    messageId: "always",
+                    line: 13,
+                    column: 17
+                }
+            ]
+        },
+
+        // enforce with exceptAfterSingleLine option
+        {
+            code: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+                fieldA = 'Field A';
+                #fieldB = 'Field B';
+                method1() {}
+                get area() {
+                    return this.method1();
+                }
+                method2() {}
+              }
+            `,
+            output: `
+              class MyClass {
+                constructor(height, width) {
+                    this.height = height;
+                    this.width = width;
+                }
+
+                fieldA = 'Field A';
+                #fieldB = 'Field B';
+                method1() {}
+                get area() {
+                    return this.method1();
+                }
+
+                method2() {}
+              }
+            `,
+            options: [
+                {
+
+                    // requires blank lines around methods and fields
+                    enforce: [
+                        { blankLine: "always", prev: "*", next: "method" },
+                        { blankLine: "always", prev: "method", next: "*" },
+                        { blankLine: "always", prev: "field", next: "field" }
+                    ]
+                },
+                {
+                    exceptAfterSingleLine: true
+                }
+            ],
+            errors: [
+                {
+                    messageId: "always",
+                    line: 7,
+                    column: 17
+                },
+                {
+                    messageId: "always",
+                    line: 13,
+                    column: 17
+                }
+            ]
         }
     ]
 });
diff --git a/wdio.conf.js b/wdio.conf.js
new file mode 100644
index 000000000..f32d75713
--- /dev/null
+++ b/wdio.conf.js
@@ -0,0 +1,387 @@
+"use strict";
+
+const path = require("path");
+const commonjs = require("vite-plugin-commonjs").default;
+
+exports.config = {
+
+    /*
+     *
+     * ====================
+     * Runner Configuration
+     * ====================
+     * WebdriverIO supports running e2e tests as well as unit and component tests.
+     */
+    runner: ["browser", {
+        viteConfig: {
+            resolve: {
+                alias: {
+                    util: "rollup-plugin-node-polyfills/polyfills/util",
+                    path: "rollup-plugin-node-polyfills/polyfills/path",
+                    assert: "rollup-plugin-node-polyfills/polyfills/assert"
+                }
+            },
+            plugins: [
+                commonjs(),
+                {
+                    name: "wdio:import-fix",
+                    enforce: "pre",
+                    transform(source, id) {
+                        if (!id.endsWith("/tests/lib/linter/linter.js")) {
+                            return source;
+                        }
+
+                        return source.replace(
+                            'const { Linter } = require("../../../lib/linter");',
+                            'const { Linter } = require("../../../build/eslint");\n' +
+                            'process.cwd = () => "/";'
+                        );
+                    }
+                }
+            ]
+        }
+    }],
+
+    /*
+     *
+     * ==================
+     * Specify Test Files
+     * ==================
+     * Define which test specs should run. The pattern is relative to the directory
+     * of the configuration file being run.
+     *
+     * The specs are defined as an array of spec files (optionally using wildcards
+     * that will be expanded). The test for each spec file will be run in a separate
+     * worker process. In order to have a group of spec files run in the same worker
+     * process simply enclose them in an array within the specs array.
+     *
+     * If you are calling `wdio` from an NPM script (see https://docs.npmjs.com/cli/run-script),
+     * then the current working directory is where your `package.json` resides, so `wdio`
+     * will be called from there.
+     *
+     */
+    specs: [
+        path.join(__dirname, "tests", "lib", "linter", "linter.js")
+    ],
+
+    // Patterns to exclude.
+    exclude: [],
+
+    /*
+     *
+     * ============
+     * Capabilities
+     * ============
+     * Define your capabilities here. WebdriverIO can run multiple capabilities at the same
+     * time. Depending on the number of capabilities, WebdriverIO launches several test
+     * sessions. Within your capabilities you can overwrite the spec and exclude options in
+     * order to group specific specs to a specific capability.
+     *
+     * First, you can define how many instances should be started at the same time. Let"s
+     * say you have 3 different capabilities (Chrome, Firefox, and Safari) and you have
+     * set maxInstances to 1; wdio will spawn 3 processes. Therefore, if you have 10 spec
+     * files and you set maxInstances to 10, all spec files will get tested at the same time
+     * and 30 processes will get spawned. The property handles how many capabilities
+     * from the same test should run tests.
+     *
+     */
+    maxInstances: 10,
+
+    /*
+     *
+     * If you have trouble getting all important capabilities together, check out the
+     * Sauce Labs platform configurator - a great tool to configure your capabilities:
+     * https://saucelabs.com/platform/platform-configurator
+     *
+     */
+    capabilities: [{
+        browserName: "chrome",
+        "goog:chromeOptions": {
+            args: process.env.CI ? ["headless", "disable-gpu"] : []
+        }
+    }],
+
+    /*
+     *
+     * ===================
+     * Test Configurations
+     * ===================
+     * Define all options that are relevant for the WebdriverIO instance here
+     *
+     * Level of logging verbosity: trace | debug | info | warn | error | silent
+     */
+    logLevel: "trace",
+    outputDir: "./wdio-logs",
+
+    /*
+     *
+     * Set specific log levels per logger
+     * loggers:
+     * - webdriver, webdriverio
+     * - @wdio/browserstack-service, @wdio/devtools-service, @wdio/sauce-service
+     * - @wdio/mocha-framework, @wdio/jasmine-framework
+     * - @wdio/local-runner
+     * - @wdio/sumologic-reporter
+     * - @wdio/cli, @wdio/config, @wdio/utils
+     * Level of logging verbosity: trace | debug | info | warn | error | silent
+     * logLevels: {
+     *     webdriver: 'info',
+     *     '@wdio/appium-service': 'info'
+     * },
+     *
+     * If you only want to run your tests until a specific amount of tests have failed use
+     * bail (default is 0 - don't bail, run all tests).
+     */
+    bail: 0,
+
+    /*
+     *
+     * Set a base URL in order to shorten url command calls. If your `url` parameter starts
+     * with `/`, the base url gets prepended, not including the path portion of your baseUrl.
+     * If your `url` parameter starts without a scheme or `/` (like `some/path`), the base url
+     * gets prepended directly.
+     */
+    baseUrl: "",
+
+    /*
+     *
+     * Default timeout for all waitFor* commands.
+     */
+    waitforTimeout: 10000,
+
+    /*
+     *
+     * Default timeout in milliseconds for request
+     * if browser driver or grid doesn't send response
+     */
+    connectionRetryTimeout: 120000,
+
+    /*
+     *
+     * Default request retries count
+     */
+    connectionRetryCount: 3,
+
+    /*
+     * Framework you want to run your specs with.
+     * The following are supported: Mocha, Jasmine, and Cucumber
+     * see also: https://webdriver.io/docs/frameworks
+     *
+     * Make sure you have the wdio adapter package for the specific framework installed
+     * before running any tests.
+     */
+    framework: "mocha",
+
+    /*
+     *
+     * The number of times to retry the entire specfile when it fails as a whole
+     * specFileRetries: 1,
+     *
+     * Delay in seconds between the spec file retry attempts
+     * specFileRetriesDelay: 0,
+     *
+     * Whether or not retried specfiles should be retried immediately or deferred to the end of the queue
+     * specFileRetriesDeferred: false,
+     *
+     * Test reporter for stdout.
+     * The only one supported by default is 'dot'
+     * see also: https://webdriver.io/docs/dot-reporter
+     */
+    reporters: ["concise"],
+
+    /*
+     *
+     * Options to be passed to Mocha.
+     * See the full list at http://mochajs.org/
+     */
+    mochaOpts: {
+        ui: "bdd",
+        timeout: 5 * 60 * 1000, // 5min
+        grep: "@skipWeb",
+        invert: true
+    }
+
+    /*
+     *
+     * =====
+     * Hooks
+     * =====
+     * WebdriverIO provides several hooks you can use to interfere with the test process in order to enhance
+     * it and to build services around it. You can either apply a single function or an array of
+     * methods to it. If one of them returns with a promise, WebdriverIO will wait until that promise got
+     * resolved to continue.
+     */
+    /**
+     * Gets executed once before all workers get launched.
+     * @param {Object} config wdio configuration object
+     * @param {Array<Object>} capabilities list of capabilities details
+     */
+    /*
+     * onPrepare: function (config, capabilities) {
+     * },
+     */
+    /**
+     * Gets executed before a worker process is spawned and can be used to initialise specific service
+     * for that worker as well as modify runtime environments in an async fashion.
+     * @param {string} cid capability id (e.g 0-0)
+     * @param {Object} caps object containing capabilities for session that will be spawn in the worker
+     * @param {Object} specs specs to be run in the worker process
+     * @param {Object} args object that will be merged with the main configuration once worker is initialized
+     * @param {Object} execArgv list of string arguments passed to the worker process
+     */
+    /*
+     * onWorkerStart: function (cid, caps, specs, args, execArgv) {
+     * },
+     */
+    /**
+     * Gets executed just after a worker process has exited.
+     * @param {string} cid capability id (e.g 0-0)
+     * @param {number} exitCode 0 - success, 1 - fail
+     * @param {Object} specs specs to be run in the worker process
+     * @param {number} retries number of retries used
+     */
+    /*
+     * onWorkerEnd: function (cid, exitCode, specs, retries) {
+     * },
+     */
+    /**
+     * Gets executed just before initialising the webdriver session and test framework. It allows you
+     * to manipulate configurations depending on the capability or spec.
+     * @param {Object} config wdio configuration object
+     * @param {Array<Object>} capabilities list of capabilities details
+     * @param {Array<string>} specs List of spec file paths that are to be run
+     * @param {string} cid worker id (e.g. 0-0)
+     */
+    /*
+     * beforeSession: function (config, capabilities, specs, cid) {
+     * },
+     */
+    /**
+     * Gets executed before test execution begins. At this point you can access to all global
+     * variables like `browser`. It is the perfect place to define custom commands.
+     * @param {Array<Object>} capabilities list of capabilities details
+     * @param {Array<string>} specs List of spec file paths that are to be run
+     * @param {Object} browser instance of created browser/device session
+     */
+    /*
+     * before: function (capabilities, specs) {
+     * },
+     */
+    /**
+     * Runs before a WebdriverIO command gets executed.
+     * @param {string} commandName hook command name
+     * @param {Array} args arguments that command would receive
+     */
+    /*
+     * beforeCommand: function (commandName, args) {
+     * },
+     */
+    /**
+     * Hook that gets executed before the suite starts
+     * @param {Object} suite suite details
+     */
+    /*
+     * beforeSuite: function (suite) {
+     * },
+     */
+    /**
+     * Function to be executed before a test (in Mocha/Jasmine) starts.
+     */
+    /*
+     * beforeTest: function (test, context) {
+     * },
+     */
+    /**
+     * Hook that gets executed _before_ a hook within the suite starts (e.g. runs before calling
+     * beforeEach in Mocha)
+     */
+    /*
+     * beforeHook: function (test, context) {
+     * },
+     */
+    /**
+     * Hook that gets executed _after_ a hook within the suite starts (e.g. runs after calling
+     * afterEach in Mocha)
+     */
+    /*
+     * afterHook: function (test, context, { error, result, duration, passed, retries }) {
+     * },
+     */
+    /**
+     * Function to be executed after a test (in Mocha/Jasmine only)
+     * @param {Object} test test object
+     * @param {Object} context scope object the test was executed with
+     * @param {Error} result.error error object in case the test fails, otherwise `undefined`
+     * @param {any} result.result return object of test function
+     * @param {number} result.duration duration of test
+     * @param {boolean} result.passed true if test has passed, otherwise false
+     * @param {Object} result.retries informations to spec related retries, e.g. `{ attempts: 0, limit: 0 }`
+     */
+    /*
+     * afterTest: function(test, context, { error, result, duration, passed, retries }) {
+     * },
+     */
+
+
+    /**
+     * Hook that gets executed after the suite has ended
+     * @param {Object} suite suite details
+     */
+    /*
+     * afterSuite: function (suite) {
+     * },
+     */
+    /**
+     * Runs after a WebdriverIO command gets executed
+     * @param {string} commandName hook command name
+     * @param {Array} args arguments that command would receive
+     * @param {number} result 0 - command success, 1 - command error
+     * @param {Object} error error object if any
+     */
+    /*
+     * afterCommand: function (commandName, args, result, error) {
+     * },
+     */
+    /**
+     * Gets executed after all tests are done. You still have access to all global variables from
+     * the test.
+     * @param {number} result 0 - test pass, 1 - test fail
+     * @param {Array<Object>} capabilities list of capabilities details
+     * @param {Array<string>} specs List of spec file paths that ran
+     */
+    /*
+     * after: function (result, capabilities, specs) {
+     * },
+     */
+    /**
+     * Gets executed right after terminating the webdriver session.
+     * @param {Object} config wdio configuration object
+     * @param {Array<Object>} capabilities list of capabilities details
+     * @param {Array<string>} specs List of spec file paths that ran
+     */
+    /*
+     * afterSession: function (config, capabilities, specs) {
+     * },
+     */
+    /**
+     * Gets executed after all workers got shut down and the process is about to exit. An error
+     * thrown in the onComplete hook will result in the test run failing.
+     * @param {Object} exitCode 0 - success, 1 - fail
+     * @param {Object} config wdio configuration object
+     * @param {Array<Object>} capabilities list of capabilities details
+     * @param {Object} results object containing test results
+     */
+    /*
+     * onComplete: function(exitCode, config, capabilities, results) {
+     * },
+     */
+    /**
+     * Gets executed when a refresh happens.
+     * @param {string} oldSessionId session ID of the old session
+     * @param {string} newSessionId session ID of the new session
+     */
+    /*
+     * onReload: function(oldSessionId, newSessionId) {
+     * }
+     */
+};
