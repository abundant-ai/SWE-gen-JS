diff --git a/.changeset/chilly-timers-kiss.md b/.changeset/chilly-timers-kiss.md
new file mode 100644
index 0000000000..d7b78e7e21
--- /dev/null
+++ b/.changeset/chilly-timers-kiss.md
@@ -0,0 +1,29 @@
+---
+'xstate': minor
+---
+
+You can now `spawn(...)` actors directly outside of `assign(...)` action creators:
+
+```ts
+import { createMachine, spawn } from 'xstate';
+
+const listenerMachine = createMachine({
+  // ...
+});
+
+const parentMachine = createMachine({
+  // ...
+  on: {
+    'listener.create': {
+      entry: spawn(listenerMachine, { id: 'listener' })
+    }
+  }
+  // ...
+});
+
+const actor = createActor(parentMachine).start();
+
+actor.send({ type: 'listener.create' });
+
+actor.getSnapshot().children.listener; // ActorRefFrom<typeof listenerMachine>
+```
diff --git a/packages/core/src/actions.ts b/packages/core/src/actions.ts
index 69dd1e3eb7..21af6111b2 100644
--- a/packages/core/src/actions.ts
+++ b/packages/core/src/actions.ts
@@ -16,3 +16,4 @@ export {
   type SendToAction
 } from './actions/send.ts';
 export { stop, type StopAction } from './actions/stop.ts';
+export { spawn, type SpawnAction } from './actions/spawn.ts';
diff --git a/packages/core/src/actions/spawn.ts b/packages/core/src/actions/spawn.ts
new file mode 100644
index 0000000000..d06ca291b4
--- /dev/null
+++ b/packages/core/src/actions/spawn.ts
@@ -0,0 +1,220 @@
+import isDevelopment from '#is-development';
+import { cloneState } from '../State.ts';
+import { createErrorActorEvent } from '../eventUtils.ts';
+import { ActorStatus, createActor } from '../interpreter.ts';
+import {
+  ActionArgs,
+  AnyActorContext,
+  AnyActorRef,
+  AnyActor,
+  AnyState,
+  EventObject,
+  MachineContext,
+  ParameterizedObject,
+  AnyActorLogic,
+  Snapshot,
+  ProvidedActor,
+  IsLiteralString,
+  InputFrom,
+  UnifiedArg
+} from '../types.ts';
+import { resolveReferencedActor } from '../utils.ts';
+
+type ResolvableActorId<
+  TContext extends MachineContext,
+  TExpressionEvent extends EventObject,
+  TEvent extends EventObject,
+  TId extends string | undefined
+> = TId | ((args: UnifiedArg<TContext, TExpressionEvent, TEvent>) => TId);
+
+function resolveSpawn(
+  actorContext: AnyActorContext,
+  state: AnyState,
+  actionArgs: ActionArgs<any, any, any, any>,
+  {
+    id,
+    systemId,
+    src,
+    input,
+    syncSnapshot
+  }: {
+    id: ResolvableActorId<MachineContext, EventObject, EventObject, string>;
+    systemId: string | undefined;
+    src: AnyActorLogic | string;
+    input?: unknown;
+    syncSnapshot: boolean;
+  }
+) {
+  const referenced =
+    typeof src === 'string'
+      ? resolveReferencedActor(state.machine, src)
+      : { src, input: undefined };
+  const resolvedId = typeof id === 'function' ? id(actionArgs) : id;
+
+  let actorRef: AnyActorRef | undefined;
+
+  if (referenced) {
+    // TODO: inline `input: undefined` should win over the referenced one
+    const configuredInput = input || referenced.input;
+    actorRef = createActor(referenced.src, {
+      id: resolvedId,
+      src: typeof src === 'string' ? src : undefined,
+      parent: actorContext?.self,
+      systemId,
+      input:
+        typeof configuredInput === 'function'
+          ? configuredInput({
+              context: state.context,
+              event: actionArgs.event,
+              self: actorContext?.self
+            })
+          : configuredInput
+    });
+
+    if (syncSnapshot) {
+      actorRef.subscribe({
+        next: (snapshot: Snapshot<unknown>) => {
+          if (snapshot.status === 'active') {
+            actorContext.self.send({
+              type: `xstate.snapshot.${id}`,
+              snapshot
+            });
+          }
+        },
+        error: () => {}
+      });
+    }
+  }
+
+  if (isDevelopment && !actorRef) {
+    console.warn(
+      `Actor type '${src}' not found in machine '${actorContext.id}'.`
+    );
+  }
+  return [
+    cloneState(state, {
+      children: {
+        ...state.children,
+        [resolvedId]: actorRef!
+      }
+    }),
+    {
+      id,
+      actorRef
+    }
+  ];
+}
+
+function executeSpawn(
+  actorContext: AnyActorContext,
+  { id, actorRef }: { id: string; actorRef: AnyActorRef }
+) {
+  if (!actorRef) {
+    return;
+  }
+
+  actorContext.defer(() => {
+    if (actorRef.status === ActorStatus.Stopped) {
+      return;
+    }
+    try {
+      actorRef.start?.();
+    } catch (err) {
+      (actorContext.self as AnyActor).send(createErrorActorEvent(id, err));
+      return;
+    }
+  });
+}
+
+export interface SpawnAction<
+  TContext extends MachineContext,
+  TExpressionEvent extends EventObject,
+  TExpressionAction extends ParameterizedObject | undefined,
+  TEvent extends EventObject,
+  TActor extends ProvidedActor
+> {
+  (_: ActionArgs<TContext, TExpressionEvent, TExpressionAction, TEvent>): void;
+  _out_TActor?: TActor;
+}
+
+type DistributeActors<
+  TContext extends MachineContext,
+  TExpressionEvent extends EventObject,
+  TEvent extends EventObject,
+  TActor extends ProvidedActor
+> = TActor extends any
+  ? 'id' extends keyof TActor
+    ? [
+        src: TActor['src'],
+        options: {
+          id: ResolvableActorId<
+            TContext,
+            TExpressionEvent,
+            TEvent,
+            TActor['id']
+          >;
+          systemId?: string;
+          input?: InputFrom<TActor['logic']>;
+          syncSnapshot?: boolean;
+        }
+      ]
+    : [
+        src: TActor['src'],
+        options?: {
+          id?: ResolvableActorId<TContext, TExpressionEvent, TEvent, string>;
+          systemId?: string;
+          input?: InputFrom<TActor['logic']>;
+          syncSnapshot?: boolean;
+        }
+      ]
+  : never;
+
+type SpawnArguments<
+  TContext extends MachineContext,
+  TExpressionEvent extends EventObject,
+  TEvent extends EventObject,
+  TActor extends ProvidedActor
+> = IsLiteralString<TActor['src']> extends true
+  ? DistributeActors<TContext, TExpressionEvent, TEvent, TActor>
+  : [
+      src: string | AnyActorLogic,
+      options?: {
+        id?: ResolvableActorId<TContext, TExpressionEvent, TEvent, string>;
+        systemId?: string;
+        input?: unknown;
+        syncSnapshot?: boolean;
+      }
+    ];
+
+export function spawn<
+  TContext extends MachineContext,
+  TExpressionEvent extends EventObject,
+  TExpressionAction extends ParameterizedObject | undefined,
+  TEvent extends EventObject,
+  TActor extends ProvidedActor
+>(
+  ...[
+    src,
+    { id, systemId, input, syncSnapshot = false } = {} as any
+  ]: SpawnArguments<TContext, TExpressionEvent, TEvent, TActor>
+): SpawnAction<TContext, TExpressionEvent, TExpressionAction, TEvent, TActor> {
+  function spawn(
+    _: ActionArgs<TContext, TExpressionEvent, TExpressionAction, TEvent>
+  ) {
+    if (isDevelopment) {
+      throw new Error(`This isn't supposed to be called`);
+    }
+  }
+
+  spawn.type = 'xstate.spawn';
+  spawn.id = id;
+  spawn.systemId = systemId;
+  spawn.src = src;
+  spawn.input = input;
+  spawn.syncSnapshot = syncSnapshot;
+
+  spawn.resolve = resolveSpawn;
+  spawn.execute = executeSpawn;
+
+  return spawn;
+}
diff --git a/packages/core/src/spawn.ts b/packages/core/src/spawn.ts
index 5bb50d4f8f..3dc913f7ce 100644
--- a/packages/core/src/spawn.ts
+++ b/packages/core/src/spawn.ts
@@ -15,7 +15,7 @@ import {
 } from './types.ts';
 import { resolveReferencedActor } from './utils.ts';
 
-type SpawnOptions<
+export type SpawnOptions<
   TActor extends ProvidedActor,
   TSrc extends TActor['src']
 > = TActor extends {
@@ -104,9 +104,7 @@ export function createSpawner(
               });
             }
           },
-          error: () => {
-            /* TODO */
-          }
+          error: () => {}
         });
       }
       return actorRef;
@@ -131,9 +129,7 @@ export function createSpawner(
               });
             }
           },
-          error: () => {
-            /* TODO */
-          }
+          error: () => {}
         });
       }
 
diff --git a/packages/core/src/stateUtils.ts b/packages/core/src/stateUtils.ts
index 65473e8f4c..4e85c8c7b6 100644
--- a/packages/core/src/stateUtils.ts
+++ b/packages/core/src/stateUtils.ts
@@ -4,7 +4,7 @@ import type { StateNode } from './StateNode.ts';
 import { raise } from './actions.ts';
 import { createAfterEvent, createDoneStateEvent } from './eventUtils.ts';
 import { cancel } from './actions/cancel.ts';
-import { invoke } from './actions/invoke.ts';
+import { spawn } from './actions/spawn.ts';
 import { stop } from './actions/stop.ts';
 import {
   XSTATE_INIT,
@@ -1148,7 +1148,12 @@ function enterStates(
     actions.push(...stateNodeToEnter.entry);
 
     for (const invokeDef of stateNodeToEnter.invoke) {
-      actions.push(invoke(invokeDef));
+      actions.push(
+        spawn(invokeDef.src, {
+          ...invokeDef,
+          syncSnapshot: !!invokeDef.onSnapshot
+        })
+      );
     }
 
     if (statesForDefaultEntry.has(stateNodeToEnter)) {
