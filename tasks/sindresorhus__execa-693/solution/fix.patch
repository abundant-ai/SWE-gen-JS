diff --git a/docs/transform.md b/docs/transform.md
new file mode 100644
index 0000000..885031e
--- /dev/null
+++ b/docs/transform.md
@@ -0,0 +1,57 @@
+# Transforms
+
+## Summary
+
+Transforms map or filter the input or output of a child process. They are defined by passing an [async generator function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function*) to the [`stdin`](../readme.md#stdin), [`stdout`](../readme.md#stdout-1), [`stderr`](../readme.md#stderr-1) or [`stdio`](../readme.md#stdio-1) option.
+
+```js
+import {execa} from 'execa';
+
+const transform = async function * (chunks) {
+	for await (const chunk of chunks) {
+		yield chunk.toUpperCase();
+	}
+};
+
+const {stdout} = await execa('echo', ['hello'], {stdout: transform});
+console.log(stdout); // HELLO
+```
+
+## Encoding
+
+The `chunks` argument passed to the transform is an [`AsyncIterable<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#the_async_iterator_and_async_iterable_protocols). If the [`encoding`](../readme.md#encoding) option is `buffer`, it is an `AsyncIterable<Uint8Array>` instead.
+
+The transform can `yield` either a `string` or an `Uint8Array`, regardless of the `chunks` argument's type.
+
+## Filtering
+
+`yield` can be called 0, 1 or multiple times. Not calling `yield` enables filtering a specific chunk.
+
+```js
+import {execa} from 'execa';
+
+const transform = async function * (chunks) {
+	for await (const chunk of chunks) {
+		if (!chunk.includes('secret')) {
+			yield chunk;
+		}
+	}
+};
+
+const {stdout} = await execa('echo', ['This is a secret.'], {stdout: transform});
+console.log(stdout); // ''
+```
+
+## Combining
+
+The [`stdin`](../readme.md#stdin), [`stdout`](../readme.md#stdout-1), [`stderr`](../readme.md#stderr-1) and [`stdio`](../readme.md#stdio-1) options can accept an array of values. While this is not specific to transforms, this can be useful with them too. For example, the following transform impacts the value printed by `inherit`.
+
+```js
+await execa('echo', ['hello'], {stdout: [transform, 'inherit']});
+```
+
+This also allows using multiple transforms.
+
+```js
+await execa('echo', ['hello'], {stdout: [transform, otherTransform]});
+```
diff --git a/index.d.ts b/index.d.ts
index a781165..b535073 100644
--- a/index.d.ts
+++ b/index.d.ts
@@ -18,13 +18,16 @@ type BaseStdioOption =
 	| 'ignore'
 	| 'inherit';
 
-type CommonStdioOption =
+type CommonStdioOption<IsSync extends boolean = boolean> =
 	| BaseStdioOption
 	| 'ipc'
 	| number
 	| undefined
 	| URL
-	| {file: string};
+	| {file: string}
+	// TODO: Use either `Iterable<string>` or `Iterable<Uint8Array>` based on whether `encoding: 'buffer'` is used.
+	// See https://github.com/sindresorhus/execa/issues/694
+	| IfAsync<IsSync, ((chunks: Iterable<string | Uint8Array>) => AsyncGenerator<string | Uint8Array, void, void>)>;
 
 type InputStdioOption<IsSync extends boolean = boolean> =
 	| Uint8Array
@@ -39,14 +42,14 @@ type OutputStdioOption<IsSync extends boolean = boolean> = IfAsync<IsSync,
 | WritableStream>;
 
 export type StdinOption<IsSync extends boolean = boolean> =
-	CommonStdioOption | InputStdioOption<IsSync>
-	| Array<CommonStdioOption | InputStdioOption<IsSync>>;
+	CommonStdioOption<IsSync> | InputStdioOption<IsSync>
+	| Array<CommonStdioOption<IsSync> | InputStdioOption<IsSync>>;
 export type StdoutStderrOption<IsSync extends boolean = boolean> =
-	CommonStdioOption | OutputStdioOption<IsSync>
-	| Array<CommonStdioOption | OutputStdioOption<IsSync>>;
+	CommonStdioOption<IsSync> | OutputStdioOption<IsSync>
+	| Array<CommonStdioOption<IsSync> | OutputStdioOption<IsSync>>;
 export type StdioOption<IsSync extends boolean = boolean> =
-	CommonStdioOption | InputStdioOption | OutputStdioOption<IsSync>
-	| Array<CommonStdioOption | InputStdioOption | OutputStdioOption<IsSync>>;
+	CommonStdioOption<IsSync> | InputStdioOption | OutputStdioOption<IsSync>
+	| Array<CommonStdioOption<IsSync> | InputStdioOption | OutputStdioOption<IsSync>>;
 
 type StdioOptionsArray<IsSync extends boolean = boolean> = readonly [
 	StdinOption<IsSync>,
@@ -241,6 +244,8 @@ type CommonOptions<IsSync extends boolean = boolean> = {
 
 	This can be an [array of values](https://github.com/sindresorhus/execa#redirect-stdinstdoutstderr-to-multiple-destinations) such as `['inherit', 'pipe']` or `[filePath, 'pipe']`.
 
+	This can also be an async generator function to transform the input. [Learn more.](https://github.com/sindresorhus/execa/tree/main/docs/transform.md)
+
 	@default `inherit` with `$`, `pipe` otherwise
 	*/
 	readonly stdin?: StdinOption<IsSync>;
@@ -260,6 +265,8 @@ type CommonOptions<IsSync extends boolean = boolean> = {
 
 	This can be an [array of values](https://github.com/sindresorhus/execa#redirect-stdinstdoutstderr-to-multiple-destinations) such as `['inherit', 'pipe']` or `[filePath, 'pipe']`.
 
+	This can also be an async generator function to transform the output. [Learn more.](https://github.com/sindresorhus/execa/tree/main/docs/transform.md)
+
 	@default 'pipe'
 	*/
 	readonly stdout?: StdoutStderrOption<IsSync>;
@@ -279,6 +286,8 @@ type CommonOptions<IsSync extends boolean = boolean> = {
 
 	This can be an [array of values](https://github.com/sindresorhus/execa#redirect-stdinstdoutstderr-to-multiple-destinations) such as `['inherit', 'pipe']` or `[filePath, 'pipe']`.
 
+	This can also be an async generator function to transform the output. [Learn more.](https://github.com/sindresorhus/execa/tree/main/docs/transform.md)
+
 	@default 'pipe'
 	*/
 	readonly stderr?: StdoutStderrOption<IsSync>;
diff --git a/index.test-d.ts b/index.test-d.ts
index e1795f8..5f6c04c 100644
--- a/index.test-d.ts
+++ b/index.test-d.ts
@@ -551,7 +551,7 @@ expectType<string | undefined>(noRejectsSyncResult.message);
 expectType<string | undefined>(noRejectsSyncResult.shortMessage);
 expectType<string | undefined>(noRejectsSyncResult.originalMessage);
 
-const stringGenerator = function * () {
+const emptyStringGenerator = function * () {
 	yield '';
 };
 
@@ -569,6 +569,40 @@ const asyncStringGenerator = async function * () {
 
 const fileUrl = new URL('file:///test');
 
+const stringOrUint8ArrayGenerator = async function * (chunks: Iterable<string | Uint8Array>) {
+	for await (const chunk of chunks) {
+		yield chunk;
+	}
+};
+
+const booleanGenerator = async function * (chunks: Iterable<boolean>) {
+	for await (const chunk of chunks) {
+		yield chunk;
+	}
+};
+
+const arrayGenerator = async function * (chunks: string[]) {
+	for await (const chunk of chunks) {
+		yield chunk;
+	}
+};
+
+const invalidReturnGenerator = async function * (chunks: Iterable<string>) {
+	for await (const chunk of chunks) {
+		yield chunk;
+	}
+
+	return false;
+};
+
+const syncGenerator = function * (chunks: Iterable<string>) {
+	for (const chunk of chunks) {
+		yield chunk;
+	}
+
+	return false;
+};
+
 expectAssignable<Options>({cleanup: false});
 expectNotAssignable<SyncOptions>({cleanup: false});
 expectAssignable<SyncOptions>({preferLocal: false});
@@ -642,10 +676,10 @@ expectError(execa('unicorns', {stdin: [new WritableStream()]}));
 expectError(execaSync('unicorns', {stdin: [new WritableStream()]}));
 execa('unicorns', {stdin: new Uint8Array()});
 execaSync('unicorns', {stdin: new Uint8Array()});
-execa('unicorns', {stdin: stringGenerator()});
-expectError(execaSync('unicorns', {stdin: stringGenerator()}));
-execa('unicorns', {stdin: [stringGenerator()]});
-expectError(execaSync('unicorns', {stdin: [stringGenerator()]}));
+execa('unicorns', {stdin: emptyStringGenerator()});
+expectError(execaSync('unicorns', {stdin: emptyStringGenerator()}));
+execa('unicorns', {stdin: [emptyStringGenerator()]});
+expectError(execaSync('unicorns', {stdin: [emptyStringGenerator()]}));
 execa('unicorns', {stdin: binaryGenerator()});
 expectError(execaSync('unicorns', {stdin: binaryGenerator()}));
 execa('unicorns', {stdin: [binaryGenerator()]});
@@ -670,6 +704,14 @@ execa('unicorns', {stdin: 1});
 execaSync('unicorns', {stdin: 1});
 execa('unicorns', {stdin: [1]});
 execaSync('unicorns', {stdin: [1]});
+execa('unicorns', {stdin: stringOrUint8ArrayGenerator});
+expectError(execaSync('unicorns', {stdin: stringOrUint8ArrayGenerator}));
+execa('unicorns', {stdin: [stringOrUint8ArrayGenerator]});
+expectError(execaSync('unicorns', {stdin: [stringOrUint8ArrayGenerator]}));
+expectError(execa('unicorns', {stdin: booleanGenerator}));
+expectError(execa('unicorns', {stdin: arrayGenerator}));
+expectError(execa('unicorns', {stdin: invalidReturnGenerator}));
+expectError(execa('unicorns', {stdin: syncGenerator}));
 execa('unicorns', {stdin: undefined});
 execaSync('unicorns', {stdin: undefined});
 execa('unicorns', {stdin: [undefined]});
@@ -728,6 +770,14 @@ execa('unicorns', {stdout: 1});
 execaSync('unicorns', {stdout: 1});
 execa('unicorns', {stdout: [1]});
 execaSync('unicorns', {stdout: [1]});
+execa('unicorns', {stdout: stringOrUint8ArrayGenerator});
+expectError(execaSync('unicorns', {stdout: stringOrUint8ArrayGenerator}));
+execa('unicorns', {stdout: [stringOrUint8ArrayGenerator]});
+expectError(execaSync('unicorns', {stdout: [stringOrUint8ArrayGenerator]}));
+expectError(execa('unicorns', {stdout: booleanGenerator}));
+expectError(execa('unicorns', {stdout: arrayGenerator}));
+expectError(execa('unicorns', {stdout: invalidReturnGenerator}));
+expectError(execa('unicorns', {stdout: syncGenerator}));
 execa('unicorns', {stdout: undefined});
 execaSync('unicorns', {stdout: undefined});
 execa('unicorns', {stdout: [undefined]});
@@ -786,6 +836,14 @@ execa('unicorns', {stderr: 1});
 execaSync('unicorns', {stderr: 1});
 execa('unicorns', {stderr: [1]});
 execaSync('unicorns', {stderr: [1]});
+execa('unicorns', {stderr: stringOrUint8ArrayGenerator});
+expectError(execaSync('unicorns', {stderr: stringOrUint8ArrayGenerator}));
+execa('unicorns', {stderr: [stringOrUint8ArrayGenerator]});
+expectError(execaSync('unicorns', {stderr: [stringOrUint8ArrayGenerator]}));
+expectError(execa('unicorns', {stderr: booleanGenerator}));
+expectError(execa('unicorns', {stderr: arrayGenerator}));
+expectError(execa('unicorns', {stderr: invalidReturnGenerator}));
+expectError(execa('unicorns', {stderr: syncGenerator}));
 execa('unicorns', {stderr: undefined});
 execaSync('unicorns', {stderr: undefined});
 execa('unicorns', {stderr: [undefined]});
@@ -822,6 +880,8 @@ expectError(execa('unicorns', {stdio: 'ipc'}));
 expectError(execaSync('unicorns', {stdio: 'ipc'}));
 expectError(execa('unicorns', {stdio: 1}));
 expectError(execaSync('unicorns', {stdio: 1}));
+expectError(execa('unicorns', {stdio: stringOrUint8ArrayGenerator}));
+expectError(execaSync('unicorns', {stdio: stringOrUint8ArrayGenerator}));
 expectError(execa('unicorns', {stdio: fileUrl}));
 expectError(execaSync('unicorns', {stdio: fileUrl}));
 expectError(execa('unicorns', {stdio: {file: './test'}}));
@@ -834,8 +894,8 @@ expectError(execa('unicorns', {stdio: new WritableStream()}));
 expectError(execaSync('unicorns', {stdio: new WritableStream()}));
 expectError(execa('unicorns', {stdio: new ReadableStream()}));
 expectError(execaSync('unicorns', {stdio: new ReadableStream()}));
-expectError(execa('unicorns', {stdio: stringGenerator()}));
-expectError(execaSync('unicorns', {stdio: stringGenerator()}));
+expectError(execa('unicorns', {stdio: emptyStringGenerator()}));
+expectError(execaSync('unicorns', {stdio: emptyStringGenerator()}));
 expectError(execa('unicorns', {stdio: asyncStringGenerator()}));
 expectError(execaSync('unicorns', {stdio: asyncStringGenerator()}));
 expectError(execa('unicorns', {stdio: ['pipe', 'pipe']}));
@@ -873,6 +933,7 @@ execa('unicorns', {
 		'inherit',
 		process.stdin,
 		1,
+		stringOrUint8ArrayGenerator,
 		undefined,
 		fileUrl,
 		{file: './test'},
@@ -881,7 +942,7 @@ execa('unicorns', {
 		new WritableStream(),
 		new ReadableStream(),
 		new Uint8Array(),
-		stringGenerator(),
+		emptyStringGenerator(),
 		asyncStringGenerator(),
 	],
 });
@@ -900,11 +961,12 @@ execaSync('unicorns', {
 		new Uint8Array(),
 	],
 });
+expectError(execaSync('unicorns', {stdio: [stringOrUint8ArrayGenerator]}));
 expectError(execaSync('unicorns', {stdio: [new Writable()]}));
 expectError(execaSync('unicorns', {stdio: [new Readable()]}));
 expectError(execaSync('unicorns', {stdio: [new WritableStream()]}));
 expectError(execaSync('unicorns', {stdio: [new ReadableStream()]}));
-expectError(execaSync('unicorns', {stdio: [stringGenerator()]}));
+expectError(execaSync('unicorns', {stdio: [emptyStringGenerator()]}));
 expectError(execaSync('unicorns', {stdio: [asyncStringGenerator()]}));
 execa('unicorns', {
 	stdio: [
@@ -916,6 +978,7 @@ execa('unicorns', {
 		['inherit'],
 		[process.stdin],
 		[1],
+		[stringOrUint8ArrayGenerator],
 		[undefined],
 		[fileUrl],
 		[{file: './test'}],
@@ -924,7 +987,7 @@ execa('unicorns', {
 		[new WritableStream()],
 		[new ReadableStream()],
 		[new Uint8Array()],
-		[stringGenerator()],
+		[emptyStringGenerator()],
 		[asyncStringGenerator()],
 	],
 });
@@ -944,11 +1007,12 @@ execaSync('unicorns', {
 		[new Uint8Array()],
 	],
 });
+expectError(execaSync('unicorns', {stdio: [[stringOrUint8ArrayGenerator]]}));
 expectError(execaSync('unicorns', {stdio: [[new Writable()]]}));
 expectError(execaSync('unicorns', {stdio: [[new Readable()]]}));
 expectError(execaSync('unicorns', {stdio: [[new WritableStream()]]}));
 expectError(execaSync('unicorns', {stdio: [[new ReadableStream()]]}));
-expectError(execaSync('unicorns', {stdio: [[stringGenerator()]]}));
+expectError(execaSync('unicorns', {stdio: [[emptyStringGenerator()]]}));
 expectError(execaSync('unicorns', {stdio: [[asyncStringGenerator()]]}));
 execa('unicorns', {serialization: 'advanced'});
 expectError(execaSync('unicorns', {serialization: 'advanced'}));
diff --git a/lib/stdio/async.js b/lib/stdio/async.js
index 6a0b7e9..a34be8e 100644
--- a/lib/stdio/async.js
+++ b/lib/stdio/async.js
@@ -4,6 +4,7 @@ import {Readable, Writable} from 'node:stream';
 import mergeStreams from '@sindresorhus/merge-streams';
 import {handleInput} from './handle.js';
 import {TYPE_TO_MESSAGE} from './type.js';
+import {generatorToTransformStream, pipeGenerator} from './generator.js';
 
 // Handle `input`, `inputFile`, `stdin`, `stdout` and `stderr` options, before spawning, in async mode
 export const handleInputAsync = options => handleInput(addPropertiesAsync, options);
@@ -14,6 +15,7 @@ const forbiddenIfAsync = ({type, optionName}) => {
 
 const addPropertiesAsync = {
 	input: {
+		generator: generatorToTransformStream,
 		fileUrl: ({value}) => ({value: createReadStream(value)}),
 		filePath: ({value}) => ({value: createReadStream(value.file)}),
 		webStream: ({value}) => ({value: Readable.fromWeb(value)}),
@@ -22,6 +24,7 @@ const addPropertiesAsync = {
 		uint8Array: ({value}) => ({value: Readable.from(Buffer.from(value))}),
 	},
 	output: {
+		generator: generatorToTransformStream,
 		fileUrl: ({value}) => ({value: createWriteStream(value)}),
 		filePath: ({value}) => ({value: createWriteStream(value.file)}),
 		webStream: ({value}) => ({value: Writable.fromWeb(value)}),
@@ -36,8 +39,15 @@ export const pipeOutputAsync = (spawned, stdioStreamsGroups) => {
 	const inputStreamsGroups = {};
 
 	for (const stdioStreams of stdioStreamsGroups) {
-		for (const stdioStream of stdioStreams) {
-			pipeStdioOption(spawned, stdioStream, inputStreamsGroups);
+		const generatorStreams = sortGeneratorStreams(stdioStreams.filter(({type}) => type === 'generator'));
+		const nonGeneratorStreams = stdioStreams.filter(({type}) => type !== 'generator');
+
+		for (const generatorStream of generatorStreams) {
+			pipeGenerator(spawned, generatorStream);
+		}
+
+		for (const nonGeneratorStream of nonGeneratorStreams) {
+			pipeStdioOption(spawned, nonGeneratorStream, inputStreamsGroups);
 		}
 	}
 
@@ -47,6 +57,8 @@ export const pipeOutputAsync = (spawned, stdioStreamsGroups) => {
 	}
 };
 
+const sortGeneratorStreams = generatorStreams => generatorStreams[0]?.direction === 'input' ? generatorStreams.reverse() : generatorStreams;
+
 const pipeStdioOption = (spawned, {type, value, direction, index}, inputStreamsGroups) => {
 	if (type === 'native') {
 		return;
diff --git a/lib/stdio/direction.js b/lib/stdio/direction.js
index e26f5ff..f15921f 100644
--- a/lib/stdio/direction.js
+++ b/lib/stdio/direction.js
@@ -31,6 +31,7 @@ const alwaysInput = () => 'input';
 
 // `string` can only be added through the `input` option, i.e. does not need to be handled here
 const guessStreamDirection = {
+	generator: anyDirection,
 	fileUrl: anyDirection,
 	filePath: anyDirection,
 	iterable: alwaysInput,
diff --git a/lib/stdio/generator.js b/lib/stdio/generator.js
new file mode 100644
index 0000000..ceda9d5
--- /dev/null
+++ b/lib/stdio/generator.js
@@ -0,0 +1,109 @@
+import {Duplex, Readable, PassThrough, getDefaultHighWaterMark} from 'node:stream';
+
+/*
+Generators can be used to transform/filter standard streams.
+
+Generators have a simple syntax, yet allows all of the following:
+- Sharing state between chunks, by using logic before the `for` loop
+- Flushing logic, by using logic after the `for` loop
+- Asynchronous logic
+- Emitting multiple chunks from a single source chunk, even if spaced in time, by using multiple `yield`
+- Filtering, by using no `yield`
+
+Therefore, there is no need to allow Node.js or web transform streams.
+
+The `highWaterMark` is kept as the default value, since this is what `childProcess.std*` uses.
+
+We ensure `objectMode` is `false` for better buffering.
+
+Chunks are currently processed serially. We could add a `concurrency` option to parallelize in the future.
+
+We return a `Duplex`, created by `Duplex.from()` made of a writable stream and a readable stream, piped to each other.
+- The writable stream is a simple `PassThrough`, so it only forwards data to the readable part.
+- The `PassThrough` is read as an iterable using `passThrough.iterator()`.
+- This iterable is transformed to another iterable, by applying the encoding generators.
+	Those convert the chunk type from `Buffer` to `string | Uint8Array` depending on the encoding option.
+- This new iterable is transformed again to another one, this time by applying the user-supplied generator.
+- Finally, `Readable.from()` is used to convert this final iterable to a `Readable` stream.
+*/
+export const generatorToTransformStream = ({value}, {encoding}) => {
+	const objectMode = false;
+	const highWaterMark = getDefaultHighWaterMark(objectMode);
+	const passThrough = new PassThrough({objectMode, highWaterMark, destroy: destroyPassThrough});
+	const iterable = passThrough.iterator();
+	const encodedIterable = applyEncoding(iterable, encoding);
+	const mappedIterable = value(encodedIterable);
+	const readableStream = Readable.from(mappedIterable, {objectMode, highWaterMark});
+	const duplexStream = Duplex.from({writable: passThrough, readable: readableStream});
+	return {value: duplexStream};
+};
+
+/*
+When an error is thrown in a generator, the PassThrough is aborted.
+
+This creates a race condition for which error is propagated, due to the Duplex throwing twice:
+- The writable side is aborted (PassThrough)
+- The readable side propagate the generator's error
+
+In order for the later to win that race, we need to wait one microtask.
+- However we wait one macrotask instead to be on the safe side
+- See https://github.com/sindresorhus/execa/pull/693#discussion_r1453809450
+*/
+const destroyPassThrough = (error, done) => {
+	setTimeout(() => {
+		done(error);
+	}, 0);
+};
+
+// When using generators, add an internal generator that converts chunks from `Buffer` to `string` or `Uint8Array`.
+// This allows generator functions to operate with those types instead.
+const applyEncoding = (iterable, encoding) => encoding === 'buffer'
+	? encodingStartBufferGenerator(iterable)
+	: encodingStartStringGenerator(iterable);
+
+/*
+Chunks might be Buffer, Uint8Array or strings since:
+- `childProcess.stdout|stderr` emits Buffers
+- `childProcess.stdin.write()` accepts Buffer, Uint8Array or string
+- Previous generators might return Uint8Array or string
+
+However, those are converted to Buffer:
+- on writes: `Duplex.writable` `decodeStrings: true` default option
+- on reads: `Duplex.readable` `readableEncoding: null` default option
+*/
+const encodingStartStringGenerator = async function * (chunks) {
+	const textDecoder = new TextDecoder();
+
+	for await (const chunk of chunks) {
+		yield textDecoder.decode(chunk, {stream: true});
+	}
+
+	const lastChunk = textDecoder.decode();
+	if (lastChunk !== '') {
+		yield lastChunk;
+	}
+};
+
+const encodingStartBufferGenerator = async function * (chunks) {
+	for await (const chunk of chunks) {
+		yield new Uint8Array(chunk);
+	}
+};
+
+// `childProcess.stdin|stdout|stderr|stdio` is directly mutated.
+export const pipeGenerator = (spawned, {value, direction, index}) => {
+	if (direction === 'output') {
+		spawned.stdio[index].pipe(value);
+	}	else {
+		value.pipe(spawned.stdio[index]);
+	}
+
+	const streamProperty = PROCESS_STREAM_PROPERTIES[index];
+	if (streamProperty !== undefined) {
+		spawned[streamProperty] = value;
+	}
+
+	spawned.stdio[index] = value;
+};
+
+const PROCESS_STREAM_PROPERTIES = ['stdin', 'stdout', 'stderr'];
diff --git a/lib/stdio/handle.js b/lib/stdio/handle.js
index bb96085..7a2fd12 100644
--- a/lib/stdio/handle.js
+++ b/lib/stdio/handle.js
@@ -11,7 +11,7 @@ export const handleInput = (addProperties, options) => {
 	const stdioStreamsGroups = [[...stdinStreams, ...handleInputOptions(options)], ...otherStreamsGroups]
 		.map(stdioStreams => validateStreams(stdioStreams))
 		.map(stdioStreams => addStreamDirection(stdioStreams))
-		.map(stdioStreams => addStreamsProperties(stdioStreams, addProperties));
+		.map(stdioStreams => addStreamsProperties(stdioStreams, addProperties, options));
 	options.stdio = transformStdio(stdioStreamsGroups);
 	return stdioStreamsGroups;
 };
@@ -51,7 +51,7 @@ const validateStdioArray = (stdioOptions, isStdioArray, optionName) => {
 const INVALID_STDIO_ARRAY_OPTIONS = ['ignore', 'ipc'];
 
 const getStdioStream = ({stdioOption, optionName, index, isStdioArray}) => {
-	const type = getStdioOptionType(stdioOption);
+	const type = getStdioOptionType(stdioOption, optionName);
 	const stdioStream = {type, value: stdioOption, optionName, index};
 	return handleNativeStream(stdioStream, isStdioArray);
 };
@@ -78,9 +78,9 @@ For example, you can use the \`pathToFileURL()\` method of the \`url\` core modu
 // Some `stdio` values require Execa to create streams.
 // For example, file paths create file read/write streams.
 // Those transformations are specified in `addProperties`, which is both direction-specific and type-specific.
-const addStreamsProperties = (stdioStreams, addProperties) => stdioStreams.map(stdioStream => ({
+const addStreamsProperties = (stdioStreams, addProperties, options) => stdioStreams.map(stdioStream => ({
 	...stdioStream,
-	...addProperties[stdioStream.direction][stdioStream.type]?.(stdioStream),
+	...addProperties[stdioStream.direction][stdioStream.type]?.(stdioStream, options),
 }));
 
 // When the `std*: Iterable | WebStream | URL | filePath`, `input` or `inputFile` option is used, we pipe to `spawned.std*`.
diff --git a/lib/stdio/sync.js b/lib/stdio/sync.js
index d797021..bb66b1f 100644
--- a/lib/stdio/sync.js
+++ b/lib/stdio/sync.js
@@ -25,6 +25,7 @@ const forbiddenIfSync = ({type, optionName}) => {
 
 const addPropertiesSync = {
 	input: {
+		generator: forbiddenIfSync,
 		fileUrl: ({value}) => ({value: bufferToUint8Array(readFileSync(value)), type: 'uint8Array'}),
 		filePath: ({value}) => ({value: bufferToUint8Array(readFileSync(value.file)), type: 'uint8Array'}),
 		webStream: forbiddenIfSync,
@@ -33,6 +34,7 @@ const addPropertiesSync = {
 		native: forbiddenIfStreamSync,
 	},
 	output: {
+		generator: forbiddenIfSync,
 		filePath: ({value}) => ({value: value.file}),
 		webStream: forbiddenIfSync,
 		nodeStream: forbiddenIfSync,
diff --git a/lib/stdio/type.js b/lib/stdio/type.js
index e829858..53c87ad 100644
--- a/lib/stdio/type.js
+++ b/lib/stdio/type.js
@@ -2,7 +2,15 @@ import {isStream as isNodeStream} from 'is-stream';
 import {isUint8Array} from './utils.js';
 
 // The `stdin`/`stdout`/`stderr` option can be of many types. This detects it.
-export const getStdioOptionType = stdioOption => {
+export const getStdioOptionType = (stdioOption, optionName) => {
+	if (isAsyncGenerator(stdioOption)) {
+		return 'generator';
+	}
+
+	if (isSyncGenerator(stdioOption)) {
+		throw new TypeError(`The \`${optionName}\` option must use an asynchronous generator, not a synchronous one.`);
+	}
+
 	if (isUrl(stdioOption)) {
 		return 'fileUrl';
 	}
@@ -30,6 +38,9 @@ export const getStdioOptionType = stdioOption => {
 	return 'native';
 };
 
+const isAsyncGenerator = stdioOption => Object.prototype.toString.call(stdioOption) === '[object AsyncGeneratorFunction]';
+const isSyncGenerator = stdioOption => Object.prototype.toString.call(stdioOption) === '[object GeneratorFunction]';
+
 export const isUrl = stdioOption => Object.prototype.toString.call(stdioOption) === '[object URL]';
 export const isRegularUrl = stdioOption => isUrl(stdioOption) && stdioOption.protocol !== 'file:';
 
@@ -53,6 +64,7 @@ const isIterableObject = stdioOption => typeof stdioOption === 'object'
 
 // Convert types to human-friendly strings for error messages
 export const TYPE_TO_MESSAGE = {
+	generator: 'a generator',
 	fileUrl: 'a file URL',
 	filePath: 'a file path string',
 	webStream: 'a web stream',
diff --git a/readme.md b/readme.md
index 2398507..5d0ba78 100644
--- a/readme.md
+++ b/readme.md
@@ -582,7 +582,7 @@ See also the [`input`](#input) and [`stdin`](#stdin) options.
 
 #### stdin
 
-Type: `string | number | stream.Readable | ReadableStream | URL | Uint8Array | Iterable<string | Uint8Array> | AsyncIterable<string | Uint8Array>` (or a tuple of those types)\
+Type: `string | number | stream.Readable | ReadableStream | URL | Uint8Array | Iterable<string | Uint8Array> | AsyncIterable<string | Uint8Array> | AsyncGeneratorFunction<string | Uint8Array>` (or a tuple of those types)\
 Default: `inherit` with [`$`](#command), `pipe` otherwise
 
 [How to setup](https://nodejs.org/api/child_process.html#child_process_options_stdio) the child process' standard input. This can be:
@@ -601,9 +601,11 @@ Default: `inherit` with [`$`](#command), `pipe` otherwise
 
 This can be an [array of values](#redirect-stdinstdoutstderr-to-multiple-destinations) such as `['inherit', 'pipe']` or `[filePath, 'pipe']`.
 
+This can also be an async generator function to transform the input. [Learn more.](docs/transform.md)
+
 #### stdout
 
-Type: `string | number | stream.Writable | WritableStream | URL` (or a tuple of those types)\
+Type: `string | number | stream.Writable | WritableStream | URL | AsyncGeneratorFunction<string | Uint8Array>` (or a tuple of those types)\
 Default: `pipe`
 
 [How to setup](https://nodejs.org/api/child_process.html#child_process_options_stdio) the child process' standard output. This can be:
@@ -620,9 +622,11 @@ Default: `pipe`
 
 This can be an [array of values](#redirect-stdinstdoutstderr-to-multiple-destinations) such as `['inherit', 'pipe']` or `[filePath, 'pipe']`.
 
+This can also be an async generator function to transform the output. [Learn more.](docs/transform.md)
+
 #### stderr
 
-Type: `string | number | stream.Writable | WritableStream | URL` (or a tuple of those types)`\
+Type: `string | number | stream.Writable | WritableStream | URL | AsyncGeneratorFunction<string | Uint8Array>` (or a tuple of those types)`\
 Default: `pipe`
 
 [How to setup](https://nodejs.org/api/child_process.html#child_process_options_stdio) the child process' standard error. This can be:
@@ -639,9 +643,11 @@ Default: `pipe`
 
 This can be an [array of values](#redirect-stdinstdoutstderr-to-multiple-destinations) such as `['inherit', 'pipe']` or `[filePath, 'pipe']`.
 
+This can also be an async generator function to transform the output. [Learn more.](docs/transform.md)
+
 #### stdio
 
-Type: `string | Array<string | number | stream.Readable | stream.Writable | ReadableStream | WritableStream | URL | Uint8Array | Iterable<string | Uint8Array> | AsyncIterable<string | Uint8Array>>` (or a tuple of those types)\
+Type: `string | Array<string | number | stream.Readable | stream.Writable | ReadableStream | WritableStream | URL | Uint8Array | Iterable<string | Uint8Array> | AsyncIterable<string | Uint8Array> | AsyncGeneratorFunction<string | Uint8Array>>` (or a tuple of those types)\
 Default: `pipe`
 
 Like the [`stdin`](#stdin), [`stdout`](#stdout-1) and [`stderr`](#stderr-1) options but for all file descriptors at once. For example, `{stdio: ['ignore', 'pipe', 'pipe']}` is the same as `{stdin: 'ignore', stdout: 'pipe', stderr: 'pipe'}`.
