diff --git a/.changeset/brown-women-jump.md b/.changeset/brown-women-jump.md
deleted file mode 100644
index 62b9418ec4..0000000000
--- a/.changeset/brown-women-jump.md
+++ /dev/null
@@ -1,5 +0,0 @@
----
-"@biomejs/biome": minor
----
-
-Add a new reporter `--reporter=sarif`, that emits diagnostics using the [SARIF](https://sarifweb.azurewebsites.net/) format.
diff --git a/.changeset/chubby-buttons-lie.md b/.changeset/chubby-buttons-lie.md
deleted file mode 100644
index 2e35902a2b..0000000000
--- a/.changeset/chubby-buttons-lie.md
+++ /dev/null
@@ -1,9 +0,0 @@
----
-"@biomejs/biome": minor
----
-
-It's now possible to provide the stacktrace for a fatal error. The stacktrace is only available when the environment variable `RUST_BACKTRACE=1` is set, either via the CLI or exported `$PATH`. This is useful when providing detailed information for debugging purposes:
-
-```shell
-RUST_BACKTRACE=1 biome lint
-```
diff --git a/.changeset/dirty-beans-flash.md b/.changeset/dirty-beans-flash.md
new file mode 100644
index 0000000000..64b632b1a9
--- /dev/null
+++ b/.changeset/dirty-beans-flash.md
@@ -0,0 +1,5 @@
+---
+"@biomejs/biome": minor
+---
+
+Fixed [#8024](https://github.com/biomejs/biome/issues/8024). The rule [`useIterableCallbackReturn`](https://biomejs.dev/linter/rules/use-iterable-callback-return/) now supports a `checkForEach` option. When set to `false`, the rule will skip checking for `forEach()` callbacks for returning values.
diff --git a/.changeset/html-no-autofocus.md b/.changeset/html-no-autofocus.md
deleted file mode 100644
index e2bacce5a6..0000000000
--- a/.changeset/html-no-autofocus.md
+++ /dev/null
@@ -1,5 +0,0 @@
----
-"@biomejs/biome": minor
----
-
-Added the [`noAutofocus`](https://biomejs.dev/linter/rules/no-autofocus/) lint rule for HTML. This rule enforces that the `autofocus` attribute is not used on elements, as it can cause usability issues for sighted and non-sighted users. The rule allows `autofocus` inside `dialog` elements or elements with the `popover` attribute, as these are modal contexts where autofocus is expected.
diff --git a/Cargo.lock b/Cargo.lock
index d99c99455c..36266f1844 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -189,7 +189,6 @@ dependencies = [
  "biome_grit_patterns",
  "biome_html_analyze",
  "biome_html_formatter",
- "biome_html_syntax",
  "biome_js_analyze",
  "biome_js_formatter",
  "biome_js_syntax",
diff --git a/crates/biome_cli/Cargo.toml b/crates/biome_cli/Cargo.toml
index cee93a460e..ebf2a2c6e6 100644
--- a/crates/biome_cli/Cargo.toml
+++ b/crates/biome_cli/Cargo.toml
@@ -36,7 +36,6 @@ biome_graphql_syntax     = { workspace = true }
 biome_grit_patterns      = { workspace = true }
 biome_html_analyze       = { workspace = true }
 biome_html_formatter     = { workspace = true }
-biome_html_syntax        = { workspace = true }
 biome_js_analyze         = { workspace = true }
 biome_js_formatter       = { workspace = true }
 biome_js_syntax          = { workspace = true }
diff --git a/crates/biome_cli/src/cli_options.rs b/crates/biome_cli/src/cli_options.rs
index 7dac898b5c..fe012c4f41 100644
--- a/crates/biome_cli/src/cli_options.rs
+++ b/crates/biome_cli/src/cli_options.rs
@@ -54,7 +54,7 @@ pub struct CliOptions {
     /// Allows to change how diagnostics and summary are reported.
     #[bpaf(
         long("reporter"),
-        argument("json|json-pretty|github|junit|summary|gitlab|checkstyle|rdjson|sarif"),
+        argument("json|json-pretty|github|junit|summary|gitlab|checkstyle|rdjson"),
         fallback(CliReporter::default())
     )]
     pub reporter: CliReporter,
@@ -140,8 +140,6 @@ pub enum CliReporter {
     Checkstyle,
     /// Reports diagnostics using the [Reviewdog JSON format](https://deepwiki.com/reviewdog/reviewdog/3.2-reviewdog-diagnostic-format)
     RdJson,
-    /// Reports diagnostics using the SARIF format
-    Sarif,
 }
 
 impl CliReporter {
@@ -163,7 +161,6 @@ impl FromStr for CliReporter {
             "gitlab" => Ok(Self::GitLab),
             "checkstyle" => Ok(Self::Checkstyle),
             "rdjson" => Ok(Self::RdJson),
-            "sarif" => Ok(Self::Sarif),
             _ => Err(format!(
                 "value {s:?} is not valid for the --reporter argument"
             )),
@@ -183,7 +180,6 @@ impl Display for CliReporter {
             Self::GitLab => f.write_str("gitlab"),
             Self::Checkstyle => f.write_str("checkstyle"),
             Self::RdJson => f.write_str("rdjson"),
-            Self::Sarif => f.write_str("sarif"),
         }
     }
 }
diff --git a/crates/biome_cli/src/panic.rs b/crates/biome_cli/src/panic.rs
index 1e72cda86f..1e1f5976e1 100644
--- a/crates/biome_cli/src/panic.rs
+++ b/crates/biome_cli/src/panic.rs
@@ -1,5 +1,4 @@
 use std::{
-    backtrace::{Backtrace, BacktraceStatus},
     fmt::Write,
     panic::{PanicHookInfo, set_hook},
     thread,
@@ -12,68 +11,39 @@ pub fn setup_panic_handler() {
 }
 
 fn panic_handler(info: &PanicHookInfo) {
-    let error = write_error(info).expect("To write into buffer");
-
-    // Write the panic to stderr
-    eprintln!("{error}");
-
-    // Write the panic to the log file, this is done last since the `tracing`
-    // infrastructure could panic a second time and abort the process, so we
-    // want to ensure the error has at least been logged to stderr beforehand
-    tracing::error!("{error}");
-}
-
-fn write_error(info: &PanicHookInfo) -> Result<String, std::fmt::Error> {
     // Buffer the error message to a string before printing it at once
     // to prevent it from getting mixed with other errors if multiple threads
     // panic at the same time
     let mut error = String::new();
 
-    writeln!(error, "Biome encountered an unexpected error")?;
-    writeln!(error)?;
+    writeln!(error, "Biome encountered an unexpected error").unwrap();
+    writeln!(error).unwrap();
 
-    writeln!(
-        error,
-        "This is a bug in Biome, not an error in your code, and we would appreciate it if you could report it to https://github.com/biomejs/biome/issues/ along with the following information to help us fixing the issue."
-    )?;
-    writeln!(error)?;
-    writeln!(
-        error,
-        "When opening the issue, please provide a minimal reproduction, or identify and share the file/code that triggers it. Without a way to reproduce the error, the error can't be fixed:"
-    )?;
-    writeln!(error)?;
+    writeln!(error, "This is a bug in Biome, not an error in your code, and we would appreciate it if you could report it to https://github.com/biomejs/biome/issues/ along with the following information to help us fixing the issue.").unwrap();
+    writeln!(error).unwrap();
+    writeln!(error, "When opening the issue, please provide a minimal reproduction, or identify and share the file/code that triggers it. Without a way to reproduce the error, the error can't be fixed:").unwrap();
+    writeln!(error).unwrap();
 
     if let Some(location) = info.location() {
-        writeln!(error, "Source Location: {location}")?;
+        writeln!(error, "Source Location: {location}").unwrap();
     }
 
     if let Some(thread) = thread::current().name() {
-        writeln!(error, "Thread Name: {thread}")?;
+        writeln!(error, "Thread Name: {thread}").unwrap();
     }
 
     let payload = info.payload();
     if let Some(msg) = payload.downcast_ref::<&'static str>() {
-        writeln!(error, "Message: {msg}")?;
+        writeln!(error, "Message: {msg}").unwrap();
     } else if let Some(msg) = payload.downcast_ref::<String>() {
-        writeln!(error, "Message: {msg}")?;
+        writeln!(error, "Message: {msg}").unwrap();
     }
 
-    let backtrace = Backtrace::capture();
-    match backtrace.status() {
-        BacktraceStatus::Captured => {
-            writeln!(error, "Stack Trace:")?;
-            writeln!(error, "{}", backtrace)?;
-        }
-        BacktraceStatus::Disabled => {
-            writeln!(
-                error,
-                "Stack Trace: Re-run with `RUST_BACKTRACE=1` to capture the stack trace"
-            )?;
-        }
-        _ => {
-            writeln!(error, "Stack Trace: Not Supported")?;
-        }
-    }
+    // Write the panic to stderr
+    eprintln!("{error}");
 
-    Ok(error)
+    // Write the panic to the log file, this is done last since the `tracing`
+    // infrastructure could panic a second time and abort the process, so we
+    // want to ensure the error has at least been logged to stderr beforehand
+    tracing::error!("{error}");
 }
diff --git a/crates/biome_cli/src/reporter/mod.rs b/crates/biome_cli/src/reporter/mod.rs
index 2d6c04cf72..7d0e63a9b0 100644
--- a/crates/biome_cli/src/reporter/mod.rs
+++ b/crates/biome_cli/src/reporter/mod.rs
@@ -4,7 +4,6 @@ pub(crate) mod gitlab;
 pub(crate) mod json;
 pub(crate) mod junit;
 pub(crate) mod rdjson;
-pub(crate) mod sarif;
 pub(crate) mod summary;
 pub(crate) mod terminal;
 
diff --git a/crates/biome_cli/src/reporter/sarif.rs b/crates/biome_cli/src/reporter/sarif.rs
deleted file mode 100644
index f2837048d7..0000000000
--- a/crates/biome_cli/src/reporter/sarif.rs
+++ /dev/null
@@ -1,391 +0,0 @@
-use std::collections::{BTreeMap, HashSet};
-
-use crate::reporter::{Reporter, ReporterVisitor};
-use crate::runner::execution::Execution;
-use crate::{DiagnosticsPayload, TraversalSummary};
-use biome_analyze::{GroupCategory, Queryable, RegistryVisitor, Rule, RuleCategory, RuleGroup};
-use biome_console::{Console, ConsoleExt, markup};
-use biome_css_syntax::CssLanguage;
-use biome_diagnostics::{Error, Location, PrintDescription, Severity, display::SourceFile};
-use biome_graphql_syntax::GraphqlLanguage;
-use biome_html_syntax::HtmlLanguage;
-use biome_js_syntax::JsLanguage;
-use biome_json_syntax::JsonLanguage;
-use biome_rowan::Language;
-use camino::{Utf8Path, Utf8PathBuf};
-use serde::Serialize;
-
-pub(crate) struct SarifReporter<'a> {
-    pub(crate) diagnostics_payload: DiagnosticsPayload,
-    pub(crate) execution: &'a dyn Execution,
-    pub(crate) verbose: bool,
-    pub(crate) working_directory: Option<Utf8PathBuf>,
-}
-
-impl Reporter for SarifReporter<'_> {
-    fn write(self, visitor: &mut dyn ReporterVisitor) -> std::io::Result<()> {
-        visitor.report_diagnostics(
-            self.execution,
-            self.diagnostics_payload,
-            self.verbose,
-            self.working_directory.as_deref(),
-        )?;
-        Ok(())
-    }
-}
-
-pub(crate) struct SarifReporterVisitor<'a> {
-    console: &'a mut dyn Console,
-    rule_descriptions: BTreeMap<&'static str, &'a str>,
-}
-
-impl<'a> SarifReporterVisitor<'a> {
-    pub fn new(console: &'a mut dyn Console) -> Self {
-        let mut visitor = Self {
-            console,
-            rule_descriptions: BTreeMap::new(),
-        };
-
-        biome_graphql_analyze::visit_registry(&mut visitor);
-        biome_html_analyze::visit_registry(&mut visitor);
-        biome_css_analyze::visit_registry(&mut visitor);
-        biome_json_analyze::visit_registry(&mut visitor);
-        biome_js_analyze::visit_registry(&mut visitor);
-
-        visitor
-    }
-
-    fn store_rule<R, L>(&mut self)
-    where
-        L: Language,
-        R: Rule<Options: Default, Query: Queryable<Language = L, Output: Clone>> + 'static,
-    {
-        let category = <R::Group as RuleGroup>::Category::CATEGORY;
-        if matches!(
-            category,
-            RuleCategory::Syntax | RuleCategory::Lint | RuleCategory::Action
-        ) {
-            let first_line: &'static str =
-                R::METADATA.docs.lines().next().unwrap_or_default().trim();
-            self.rule_descriptions.insert(R::METADATA.name, first_line);
-        }
-    }
-}
-
-impl RegistryVisitor<JsLanguage> for SarifReporterVisitor<'_> {
-    fn record_rule<R>(&mut self)
-    where
-        R: Rule<Options: Default, Query: Queryable<Language = JsLanguage, Output: Clone>> + 'static,
-    {
-        self.store_rule::<R, JsLanguage>();
-    }
-}
-
-impl RegistryVisitor<JsonLanguage> for SarifReporterVisitor<'_> {
-    fn record_rule<R>(&mut self)
-    where
-        R: Rule<Options: Default, Query: Queryable<Language = JsonLanguage, Output: Clone>>
-            + 'static,
-    {
-        self.store_rule::<R, JsonLanguage>();
-    }
-}
-
-impl RegistryVisitor<CssLanguage> for SarifReporterVisitor<'_> {
-    fn record_rule<R>(&mut self)
-    where
-        R: Rule<Options: Default, Query: Queryable<Language = CssLanguage, Output: Clone>>
-            + 'static,
-    {
-        self.store_rule::<R, CssLanguage>();
-    }
-}
-
-impl RegistryVisitor<GraphqlLanguage> for SarifReporterVisitor<'_> {
-    fn record_rule<R>(&mut self)
-    where
-        R: Rule<Options: Default, Query: Queryable<Language = GraphqlLanguage, Output: Clone>>
-            + 'static,
-    {
-        self.store_rule::<R, GraphqlLanguage>();
-    }
-}
-
-impl RegistryVisitor<HtmlLanguage> for SarifReporterVisitor<'_> {
-    fn record_rule<R>(&mut self)
-    where
-        R: Rule<Options: Default, Query: Queryable<Language = HtmlLanguage, Output: Clone>>
-            + 'static,
-    {
-        self.store_rule::<R, HtmlLanguage>();
-    }
-}
-
-impl ReporterVisitor for SarifReporterVisitor<'_> {
-    fn report_summary(
-        &mut self,
-        _execution: &dyn Execution,
-        _summary: TraversalSummary,
-        _verbose: bool,
-    ) -> std::io::Result<()> {
-        Ok(())
-    }
-
-    fn report_diagnostics(
-        &mut self,
-        _execution: &dyn Execution,
-        payload: DiagnosticsPayload,
-        verbose: bool,
-        working_directory: Option<&Utf8Path>,
-    ) -> std::io::Result<()> {
-        let mut sarif_rules: HashSet<_> = HashSet::new();
-
-        let sarif_results: Vec<_> = payload
-            .diagnostics
-            .iter()
-            .filter_map(|diagnostic| {
-                if diagnostic.severity() >= payload.diagnostic_level {
-                    if diagnostic.tags().is_verbose() {
-                        if verbose {
-                            if let Some(driver_rule) =
-                                to_sarif_driver_rule(diagnostic, &self.rule_descriptions)
-                            {
-                                sarif_rules.insert(driver_rule);
-                            }
-                            to_sarif_result(diagnostic, working_directory)
-                        } else {
-                            None
-                        }
-                    } else {
-                        if let Some(driver_rule) =
-                            to_sarif_driver_rule(diagnostic, &self.rule_descriptions)
-                        {
-                            sarif_rules.insert(driver_rule);
-                        }
-                        to_sarif_result(diagnostic, working_directory)
-                    }
-                } else {
-                    None
-                }
-            })
-            .collect();
-
-        let report = SarifReport {
-            schema: "https://json.schemastore.org/sarif-2.1.0.json",
-            version: "2.1.0",
-            runs: Vec::from([SarifRun {
-                tool: SarifTool {
-                    driver: SarifDriver {
-                        name: "Biome",
-                        information_uri: "https://biomejs.dev",
-                        rules: {
-                            // Make sure to maintain same order every run
-                            let mut sarif_rules_vec = sarif_rules.into_iter().collect::<Vec<_>>();
-                            sarif_rules_vec.sort_by(|a, b| a.id.cmp(b.id));
-                            sarif_rules_vec
-                        },
-                    },
-                },
-                results: sarif_results,
-            }]),
-        };
-
-        let result = serde_json::to_string_pretty(&report)?;
-
-        self.console.log(markup! {
-            {result}
-        });
-
-        Ok(())
-    }
-}
-
-fn to_sarif_result<'a>(
-    diagnostic: &'a Error,
-    working_directory: Option<&Utf8Path>,
-) -> Option<SarifResult<'a>> {
-    let category = diagnostic.category()?;
-
-    let message = SarifResultMessage {
-        text: PrintDescription(diagnostic).to_string(),
-    };
-
-    let location = diagnostic.location();
-    let location = to_sarif_result_location(location, working_directory)?;
-
-    Some(SarifResult {
-        rule_id: category.name(),
-        level: match diagnostic.severity() {
-            Severity::Hint => "note",
-            Severity::Information => "note",
-            Severity::Warning => "warning",
-            Severity::Error => "error",
-            Severity::Fatal => "error",
-        },
-        message,
-        locations: Vec::from([location]),
-    })
-}
-
-fn to_sarif_driver_rule<'a>(
-    diagnostic: &'a Error,
-    rule_descriptions: &BTreeMap<&'static str, &'a str>,
-) -> Option<SarifDriverRule<'a>> {
-    let category = diagnostic.category()?;
-
-    let name = category.name();
-    let link = if name == "format" {
-        "https://biomejs.dev/formatter/"
-    } else {
-        category.link().unwrap_or_default()
-    };
-
-    let description: &'a str = if name == "format" {
-        "Follow a consistent styleâ€”handling things like spacing, indentation, line breaks, and punctuation to make code easier to read and maintain."
-    } else if let Some(description) =
-        rule_descriptions.get(name.split('/').next_back().unwrap_or_default())
-    {
-        description
-    } else {
-        ""
-    };
-
-    Some(SarifDriverRule {
-        id: name,
-        short_description: SarifDriverRuleDescription { text: description },
-        help_uri: link,
-    })
-}
-
-fn to_sarif_result_location(
-    location: Location,
-    working_directory: Option<&Utf8Path>,
-) -> Option<SarifResultLocation> {
-    let artifact_location =
-        to_sarif_result_location_artifact_location(location, working_directory)?;
-    let region = to_sarif_result_location_region(location);
-
-    Some(SarifResultLocation {
-        physical_location: SarifResultLocationPhysicalLocation {
-            artifact_location,
-            region,
-        },
-    })
-}
-
-fn to_sarif_result_location_artifact_location(
-    location: Location,
-    working_directory: Option<&Utf8Path>,
-) -> Option<SarifResultLocationPhysicalLocationArtifactLocation> {
-    let resource = location.resource?;
-    let file = resource.as_file()?;
-    let absolute_path = working_directory
-        .as_ref()
-        .map(|wd| wd.join(file))
-        .unwrap_or(file.into());
-
-    Some(SarifResultLocationPhysicalLocationArtifactLocation {
-        // Transform Windows' backslash paths to UNIX's forward slash (SARIF spec follows RFC 3986 for consistency)
-        uri: absolute_path.as_str().replace('\\', "/"),
-    })
-}
-
-fn to_sarif_result_location_region(
-    location: Location,
-) -> Option<SarifResultLocationPhysicalLocationRegion> {
-    let source_code = location.source_code?;
-    let span = location.span?;
-
-    let source = SourceFile::new(source_code);
-    let start = source.location(span.start()).ok()?;
-    let end = source.location(span.end()).ok()?;
-
-    Some(SarifResultLocationPhysicalLocationRegion {
-        start_line: start.line_number.get(),
-        start_column: start.column_number.get(),
-        end_line: end.line_number.get(),
-        end_column: end.column_number.get(),
-    })
-}
-
-#[derive(Serialize)]
-pub struct SarifReport<'a> {
-    #[serde(rename = "$schema")]
-    schema: &'static str,
-    version: &'static str,
-    runs: Vec<SarifRun<'a>>,
-}
-
-#[derive(Serialize)]
-struct SarifRun<'a> {
-    tool: SarifTool<'a>,
-    results: Vec<SarifResult<'a>>,
-}
-
-#[derive(Serialize)]
-struct SarifTool<'a> {
-    driver: SarifDriver<'a>,
-}
-
-#[derive(Serialize)]
-#[serde(rename_all = "camelCase")]
-struct SarifDriver<'a> {
-    name: &'static str,
-    information_uri: &'static str,
-    rules: Vec<SarifDriverRule<'a>>,
-}
-
-#[derive(Serialize, Eq, PartialEq, Hash)]
-#[serde(rename_all = "camelCase")]
-struct SarifDriverRule<'a> {
-    id: &'static str,
-    short_description: SarifDriverRuleDescription<'a>,
-    help_uri: &'a str,
-}
-
-#[derive(Serialize, Eq, PartialEq, Hash)]
-struct SarifDriverRuleDescription<'a> {
-    text: &'a str,
-}
-
-#[derive(Serialize)]
-#[serde(rename_all = "camelCase")]
-struct SarifResult<'a> {
-    rule_id: &'a str,
-    level: &'a str,
-    message: SarifResultMessage,
-    locations: Vec<SarifResultLocation>,
-}
-
-#[derive(Serialize)]
-struct SarifResultMessage {
-    text: String,
-}
-
-#[derive(Serialize)]
-#[serde(rename_all = "camelCase")]
-struct SarifResultLocation {
-    physical_location: SarifResultLocationPhysicalLocation,
-}
-
-#[derive(Serialize)]
-#[serde(rename_all = "camelCase")]
-struct SarifResultLocationPhysicalLocation {
-    artifact_location: SarifResultLocationPhysicalLocationArtifactLocation,
-    #[serde(skip_serializing_if = "Option::is_none")]
-    region: Option<SarifResultLocationPhysicalLocationRegion>,
-}
-
-#[derive(Serialize)]
-struct SarifResultLocationPhysicalLocationArtifactLocation {
-    uri: String,
-}
-
-#[derive(Serialize)]
-#[serde(rename_all = "camelCase")]
-struct SarifResultLocationPhysicalLocationRegion {
-    start_line: usize,
-    start_column: usize,
-    end_line: usize,
-    end_column: usize,
-}
diff --git a/crates/biome_cli/src/runner/impls/finalizers/default.rs b/crates/biome_cli/src/runner/impls/finalizers/default.rs
index ef540aa4ae..6bb50cfe68 100644
--- a/crates/biome_cli/src/runner/impls/finalizers/default.rs
+++ b/crates/biome_cli/src/runner/impls/finalizers/default.rs
@@ -7,7 +7,6 @@ use crate::reporter::gitlab::{GitLabReporter, GitLabReporterVisitor};
 use crate::reporter::json::{JsonReporter, JsonReporterVisitor};
 use crate::reporter::junit::{JunitReporter, JunitReporterVisitor};
 use crate::reporter::rdjson::{RdJsonReporter, RdJsonReporterVisitor};
-use crate::reporter::sarif::{SarifReporter, SarifReporterVisitor};
 use crate::reporter::summary::{SummaryReporter, SummaryReporterVisitor};
 use crate::reporter::terminal::{ConsoleReporter, ConsoleReporterVisitor};
 use crate::runner::finalizer::{FinalizePayload, Finalizer};
@@ -193,15 +192,6 @@ impl Finalizer for DefaultFinalizer {
                 };
                 reporter.write(&mut RdJsonReporterVisitor(console))?;
             }
-            ReportMode::Sarif => {
-                let reporter = SarifReporter {
-                    diagnostics_payload,
-                    execution,
-                    verbose: cli_options.verbose,
-                    working_directory: fs.working_directory().clone(),
-                };
-                reporter.write(&mut SarifReporterVisitor::new(console))?;
-            }
         }
 
         // Processing emitted error diagnostics, exit with a non-zero code
@@ -255,8 +245,6 @@ pub enum ReportMode {
     Checkstyle,
     /// Reports information in [reviewdog JSON format](https://deepwiki.com/reviewdog/reviewdog/3.2-reviewdog-diagnostic-format)
     RdJson,
-    /// Reports diagnostics using the SARIF format
-    Sarif,
 }
 
 impl Default for ReportMode {
@@ -281,7 +269,6 @@ impl From<&CliReporter> for ReportMode {
             CliReporter::GitLab => Self::GitLab {},
             CliReporter::Checkstyle => Self::Checkstyle,
             CliReporter::RdJson => Self::RdJson,
-            CliReporter::Sarif => Self::Sarif,
         }
     }
 }
diff --git a/crates/biome_configuration/src/analyzer/linter/rules.rs b/crates/biome_configuration/src/analyzer/linter/rules.rs
index 083a833f8f..45e4084245 100644
--- a/crates/biome_configuration/src/analyzer/linter/rules.rs
+++ b/crates/biome_configuration/src/analyzer/linter/rules.rs
@@ -2072,7 +2072,7 @@ impl Rules {
 #[cfg_attr(feature = "schema", derive(JsonSchema))]
 #[serde(rename_all = "camelCase", default, deny_unknown_fields)]
 #[doc = r" A list of rules that belong to this group"]
-pub struct A11y { # [doc = r" Enables the recommended rules for this group"] # [serde (skip_serializing_if = "Option::is_none")] pub recommended : Option < bool > , # [doc = "Enforce that the accesskey attribute is not used on any HTML element.\nSee <https://biomejs.dev/linter/rules/no-access-key>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_access_key : Option < RuleFixConfiguration < biome_rule_options :: no_access_key :: NoAccessKeyOptions >> , # [doc = "Enforce that aria-hidden=\"true\" is not set on focusable elements.\nSee <https://biomejs.dev/linter/rules/no-aria-hidden-on-focusable>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_aria_hidden_on_focusable : Option < RuleFixConfiguration < biome_rule_options :: no_aria_hidden_on_focusable :: NoAriaHiddenOnFocusableOptions >> , # [doc = "Enforce that elements that do not support ARIA roles, states, and properties do not have those attributes.\nSee <https://biomejs.dev/linter/rules/no-aria-unsupported-elements>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_aria_unsupported_elements : Option < RuleFixConfiguration < biome_rule_options :: no_aria_unsupported_elements :: NoAriaUnsupportedElementsOptions >> , # [doc = "Enforce that the autofocus attribute is not used on elements.\nSee <https://biomejs.dev/linter/rules/no-autofocus>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_autofocus : Option < RuleFixConfiguration < biome_rule_options :: no_autofocus :: NoAutofocusOptions >> , # [doc = "Enforces that no distracting elements are used.\nSee <https://biomejs.dev/linter/rules/no-distracting-elements>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_distracting_elements : Option < RuleFixConfiguration < biome_rule_options :: no_distracting_elements :: NoDistractingElementsOptions >> , # [doc = "The scope prop should be used only on \\<th> elements.\nSee <https://biomejs.dev/linter/rules/no-header-scope>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_header_scope : Option < RuleFixConfiguration < biome_rule_options :: no_header_scope :: NoHeaderScopeOptions >> , # [doc = "Enforce that non-interactive ARIA roles are not assigned to interactive HTML elements.\nSee <https://biomejs.dev/linter/rules/no-interactive-element-to-noninteractive-role>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_interactive_element_to_noninteractive_role : Option < RuleFixConfiguration < biome_rule_options :: no_interactive_element_to_noninteractive_role :: NoInteractiveElementToNoninteractiveRoleOptions >> , # [doc = "Enforce that a label element or component has a text label and an associated input.\nSee <https://biomejs.dev/linter/rules/no-label-without-control>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_label_without_control : Option < RuleConfiguration < biome_rule_options :: no_label_without_control :: NoLabelWithoutControlOptions >> , # [doc = "Disallow use event handlers on non-interactive elements.\nSee <https://biomejs.dev/linter/rules/no-noninteractive-element-interactions>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_noninteractive_element_interactions : Option < RuleConfiguration < biome_rule_options :: no_noninteractive_element_interactions :: NoNoninteractiveElementInteractionsOptions >> , # [doc = "Enforce that interactive ARIA roles are not assigned to non-interactive HTML elements.\nSee <https://biomejs.dev/linter/rules/no-noninteractive-element-to-interactive-role>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_noninteractive_element_to_interactive_role : Option < RuleFixConfiguration < biome_rule_options :: no_noninteractive_element_to_interactive_role :: NoNoninteractiveElementToInteractiveRoleOptions >> , # [doc = "Enforce that tabIndex is not assigned to non-interactive HTML elements.\nSee <https://biomejs.dev/linter/rules/no-noninteractive-tabindex>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_noninteractive_tabindex : Option < RuleFixConfiguration < biome_rule_options :: no_noninteractive_tabindex :: NoNoninteractiveTabindexOptions >> , # [doc = "Prevent the usage of positive integers on tabindex attribute.\nSee <https://biomejs.dev/linter/rules/no-positive-tabindex>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_positive_tabindex : Option < RuleFixConfiguration < biome_rule_options :: no_positive_tabindex :: NoPositiveTabindexOptions >> , # [doc = "Enforce img alt prop does not contain the word \"image\", \"picture\", or \"photo\".\nSee <https://biomejs.dev/linter/rules/no-redundant-alt>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_redundant_alt : Option < RuleConfiguration < biome_rule_options :: no_redundant_alt :: NoRedundantAltOptions >> , # [doc = "Enforce explicit role property is not the same as implicit/default role property on an element.\nSee <https://biomejs.dev/linter/rules/no-redundant-roles>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_redundant_roles : Option < RuleFixConfiguration < biome_rule_options :: no_redundant_roles :: NoRedundantRolesOptions >> , # [doc = "Enforce that static, visible elements (such as \\<div>) that have click handlers use the valid role attribute.\nSee <https://biomejs.dev/linter/rules/no-static-element-interactions>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_static_element_interactions : Option < RuleConfiguration < biome_rule_options :: no_static_element_interactions :: NoStaticElementInteractionsOptions >> , # [doc = "Enforces the usage of the title element for the svg element.\nSee <https://biomejs.dev/linter/rules/no-svg-without-title>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_svg_without_title : Option < RuleConfiguration < biome_rule_options :: no_svg_without_title :: NoSvgWithoutTitleOptions >> , # [doc = "Enforce that all elements that require alternative text have meaningful information to relay back to the end user.\nSee <https://biomejs.dev/linter/rules/use-alt-text>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_alt_text : Option < RuleConfiguration < biome_rule_options :: use_alt_text :: UseAltTextOptions >> , # [doc = "Enforce that anchors have content and that the content is accessible to screen readers.\nSee <https://biomejs.dev/linter/rules/use-anchor-content>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_anchor_content : Option < RuleFixConfiguration < biome_rule_options :: use_anchor_content :: UseAnchorContentOptions >> , # [doc = "Enforce that tabIndex is assigned to non-interactive HTML elements with aria-activedescendant.\nSee <https://biomejs.dev/linter/rules/use-aria-activedescendant-with-tabindex>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_aria_activedescendant_with_tabindex : Option < RuleFixConfiguration < biome_rule_options :: use_aria_activedescendant_with_tabindex :: UseAriaActivedescendantWithTabindexOptions >> , # [doc = "Enforce that elements with ARIA roles must have all required ARIA attributes for that role.\nSee <https://biomejs.dev/linter/rules/use-aria-props-for-role>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_aria_props_for_role : Option < RuleConfiguration < biome_rule_options :: use_aria_props_for_role :: UseAriaPropsForRoleOptions >> , # [doc = "Enforce that ARIA properties are valid for the roles that are supported by the element.\nSee <https://biomejs.dev/linter/rules/use-aria-props-supported-by-role>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_aria_props_supported_by_role : Option < RuleConfiguration < biome_rule_options :: use_aria_props_supported_by_role :: UseAriaPropsSupportedByRoleOptions >> , # [doc = "Enforces the usage and validity of the attribute type for the element button.\nSee <https://biomejs.dev/linter/rules/use-button-type>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_button_type : Option < RuleConfiguration < biome_rule_options :: use_button_type :: UseButtonTypeOptions >> , # [doc = "Elements with an interactive role and interaction handlers must be focusable.\nSee <https://biomejs.dev/linter/rules/use-focusable-interactive>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_focusable_interactive : Option < RuleConfiguration < biome_rule_options :: use_focusable_interactive :: UseFocusableInteractiveOptions >> , # [doc = "Disallow a missing generic family keyword within font families.\nSee <https://biomejs.dev/linter/rules/use-generic-font-names>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_generic_font_names : Option < RuleConfiguration < biome_rule_options :: use_generic_font_names :: UseGenericFontNamesOptions >> , # [doc = "Enforce that heading elements (h1, h2, etc.) have content and that the content is accessible to screen readers. Accessible means that it is not hidden using the aria-hidden prop.\nSee <https://biomejs.dev/linter/rules/use-heading-content>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_heading_content : Option < RuleConfiguration < biome_rule_options :: use_heading_content :: UseHeadingContentOptions >> , # [doc = "Enforce that html element has lang attribute.\nSee <https://biomejs.dev/linter/rules/use-html-lang>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_html_lang : Option < RuleConfiguration < biome_rule_options :: use_html_lang :: UseHtmlLangOptions >> , # [doc = "Enforces the usage of the attribute title for the element iframe.\nSee <https://biomejs.dev/linter/rules/use-iframe-title>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_iframe_title : Option < RuleConfiguration < biome_rule_options :: use_iframe_title :: UseIframeTitleOptions >> , # [doc = "Enforce onClick is accompanied by at least one of the following: onKeyUp, onKeyDown, onKeyPress.\nSee <https://biomejs.dev/linter/rules/use-key-with-click-events>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_key_with_click_events : Option < RuleConfiguration < biome_rule_options :: use_key_with_click_events :: UseKeyWithClickEventsOptions >> , # [doc = "Enforce onMouseOver / onMouseOut are accompanied by onFocus / onBlur.\nSee <https://biomejs.dev/linter/rules/use-key-with-mouse-events>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_key_with_mouse_events : Option < RuleConfiguration < biome_rule_options :: use_key_with_mouse_events :: UseKeyWithMouseEventsOptions >> , # [doc = "Enforces that audio and video elements must have a track for captions.\nSee <https://biomejs.dev/linter/rules/use-media-caption>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_media_caption : Option < RuleConfiguration < biome_rule_options :: use_media_caption :: UseMediaCaptionOptions >> , # [doc = "It detects the use of role attributes in JSX elements and suggests using semantic elements instead.\nSee <https://biomejs.dev/linter/rules/use-semantic-elements>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_semantic_elements : Option < RuleConfiguration < biome_rule_options :: use_semantic_elements :: UseSemanticElementsOptions >> , # [doc = "Enforce that all anchors are valid, and they are navigable elements.\nSee <https://biomejs.dev/linter/rules/use-valid-anchor>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_valid_anchor : Option < RuleConfiguration < biome_rule_options :: use_valid_anchor :: UseValidAnchorOptions >> , # [doc = "Ensures that ARIA properties aria-* are all valid.\nSee <https://biomejs.dev/linter/rules/use-valid-aria-props>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_valid_aria_props : Option < RuleFixConfiguration < biome_rule_options :: use_valid_aria_props :: UseValidAriaPropsOptions >> , # [doc = "Elements with ARIA roles must use a valid, non-abstract ARIA role.\nSee <https://biomejs.dev/linter/rules/use-valid-aria-role>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_valid_aria_role : Option < RuleFixConfiguration < biome_rule_options :: use_valid_aria_role :: UseValidAriaRoleOptions >> , # [doc = "Enforce that ARIA state and property values are valid.\nSee <https://biomejs.dev/linter/rules/use-valid-aria-values>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_valid_aria_values : Option < RuleConfiguration < biome_rule_options :: use_valid_aria_values :: UseValidAriaValuesOptions >> , # [doc = "Use valid values for the autocomplete attribute on input elements.\nSee <https://biomejs.dev/linter/rules/use-valid-autocomplete>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_valid_autocomplete : Option < RuleConfiguration < biome_rule_options :: use_valid_autocomplete :: UseValidAutocompleteOptions >> , # [doc = "Ensure that the attribute passed to the lang attribute is a correct ISO language and/or country.\nSee <https://biomejs.dev/linter/rules/use-valid-lang>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_valid_lang : Option < RuleConfiguration < biome_rule_options :: use_valid_lang :: UseValidLangOptions >> }
+pub struct A11y { # [doc = r" Enables the recommended rules for this group"] # [serde (skip_serializing_if = "Option::is_none")] pub recommended : Option < bool > , # [doc = "Enforce that the accesskey attribute is not used on any HTML element.\nSee <https://biomejs.dev/linter/rules/no-access-key>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_access_key : Option < RuleFixConfiguration < biome_rule_options :: no_access_key :: NoAccessKeyOptions >> , # [doc = "Enforce that aria-hidden=\"true\" is not set on focusable elements.\nSee <https://biomejs.dev/linter/rules/no-aria-hidden-on-focusable>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_aria_hidden_on_focusable : Option < RuleFixConfiguration < biome_rule_options :: no_aria_hidden_on_focusable :: NoAriaHiddenOnFocusableOptions >> , # [doc = "Enforce that elements that do not support ARIA roles, states, and properties do not have those attributes.\nSee <https://biomejs.dev/linter/rules/no-aria-unsupported-elements>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_aria_unsupported_elements : Option < RuleFixConfiguration < biome_rule_options :: no_aria_unsupported_elements :: NoAriaUnsupportedElementsOptions >> , # [doc = "Enforce that autoFocus prop is not used on elements.\nSee <https://biomejs.dev/linter/rules/no-autofocus>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_autofocus : Option < RuleFixConfiguration < biome_rule_options :: no_autofocus :: NoAutofocusOptions >> , # [doc = "Enforces that no distracting elements are used.\nSee <https://biomejs.dev/linter/rules/no-distracting-elements>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_distracting_elements : Option < RuleFixConfiguration < biome_rule_options :: no_distracting_elements :: NoDistractingElementsOptions >> , # [doc = "The scope prop should be used only on \\<th> elements.\nSee <https://biomejs.dev/linter/rules/no-header-scope>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_header_scope : Option < RuleFixConfiguration < biome_rule_options :: no_header_scope :: NoHeaderScopeOptions >> , # [doc = "Enforce that non-interactive ARIA roles are not assigned to interactive HTML elements.\nSee <https://biomejs.dev/linter/rules/no-interactive-element-to-noninteractive-role>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_interactive_element_to_noninteractive_role : Option < RuleFixConfiguration < biome_rule_options :: no_interactive_element_to_noninteractive_role :: NoInteractiveElementToNoninteractiveRoleOptions >> , # [doc = "Enforce that a label element or component has a text label and an associated input.\nSee <https://biomejs.dev/linter/rules/no-label-without-control>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_label_without_control : Option < RuleConfiguration < biome_rule_options :: no_label_without_control :: NoLabelWithoutControlOptions >> , # [doc = "Disallow use event handlers on non-interactive elements.\nSee <https://biomejs.dev/linter/rules/no-noninteractive-element-interactions>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_noninteractive_element_interactions : Option < RuleConfiguration < biome_rule_options :: no_noninteractive_element_interactions :: NoNoninteractiveElementInteractionsOptions >> , # [doc = "Enforce that interactive ARIA roles are not assigned to non-interactive HTML elements.\nSee <https://biomejs.dev/linter/rules/no-noninteractive-element-to-interactive-role>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_noninteractive_element_to_interactive_role : Option < RuleFixConfiguration < biome_rule_options :: no_noninteractive_element_to_interactive_role :: NoNoninteractiveElementToInteractiveRoleOptions >> , # [doc = "Enforce that tabIndex is not assigned to non-interactive HTML elements.\nSee <https://biomejs.dev/linter/rules/no-noninteractive-tabindex>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_noninteractive_tabindex : Option < RuleFixConfiguration < biome_rule_options :: no_noninteractive_tabindex :: NoNoninteractiveTabindexOptions >> , # [doc = "Prevent the usage of positive integers on tabindex attribute.\nSee <https://biomejs.dev/linter/rules/no-positive-tabindex>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_positive_tabindex : Option < RuleFixConfiguration < biome_rule_options :: no_positive_tabindex :: NoPositiveTabindexOptions >> , # [doc = "Enforce img alt prop does not contain the word \"image\", \"picture\", or \"photo\".\nSee <https://biomejs.dev/linter/rules/no-redundant-alt>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_redundant_alt : Option < RuleConfiguration < biome_rule_options :: no_redundant_alt :: NoRedundantAltOptions >> , # [doc = "Enforce explicit role property is not the same as implicit/default role property on an element.\nSee <https://biomejs.dev/linter/rules/no-redundant-roles>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_redundant_roles : Option < RuleFixConfiguration < biome_rule_options :: no_redundant_roles :: NoRedundantRolesOptions >> , # [doc = "Enforce that static, visible elements (such as \\<div>) that have click handlers use the valid role attribute.\nSee <https://biomejs.dev/linter/rules/no-static-element-interactions>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_static_element_interactions : Option < RuleConfiguration < biome_rule_options :: no_static_element_interactions :: NoStaticElementInteractionsOptions >> , # [doc = "Enforces the usage of the title element for the svg element.\nSee <https://biomejs.dev/linter/rules/no-svg-without-title>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_svg_without_title : Option < RuleConfiguration < biome_rule_options :: no_svg_without_title :: NoSvgWithoutTitleOptions >> , # [doc = "Enforce that all elements that require alternative text have meaningful information to relay back to the end user.\nSee <https://biomejs.dev/linter/rules/use-alt-text>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_alt_text : Option < RuleConfiguration < biome_rule_options :: use_alt_text :: UseAltTextOptions >> , # [doc = "Enforce that anchors have content and that the content is accessible to screen readers.\nSee <https://biomejs.dev/linter/rules/use-anchor-content>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_anchor_content : Option < RuleFixConfiguration < biome_rule_options :: use_anchor_content :: UseAnchorContentOptions >> , # [doc = "Enforce that tabIndex is assigned to non-interactive HTML elements with aria-activedescendant.\nSee <https://biomejs.dev/linter/rules/use-aria-activedescendant-with-tabindex>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_aria_activedescendant_with_tabindex : Option < RuleFixConfiguration < biome_rule_options :: use_aria_activedescendant_with_tabindex :: UseAriaActivedescendantWithTabindexOptions >> , # [doc = "Enforce that elements with ARIA roles must have all required ARIA attributes for that role.\nSee <https://biomejs.dev/linter/rules/use-aria-props-for-role>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_aria_props_for_role : Option < RuleConfiguration < biome_rule_options :: use_aria_props_for_role :: UseAriaPropsForRoleOptions >> , # [doc = "Enforce that ARIA properties are valid for the roles that are supported by the element.\nSee <https://biomejs.dev/linter/rules/use-aria-props-supported-by-role>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_aria_props_supported_by_role : Option < RuleConfiguration < biome_rule_options :: use_aria_props_supported_by_role :: UseAriaPropsSupportedByRoleOptions >> , # [doc = "Enforces the usage and validity of the attribute type for the element button.\nSee <https://biomejs.dev/linter/rules/use-button-type>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_button_type : Option < RuleConfiguration < biome_rule_options :: use_button_type :: UseButtonTypeOptions >> , # [doc = "Elements with an interactive role and interaction handlers must be focusable.\nSee <https://biomejs.dev/linter/rules/use-focusable-interactive>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_focusable_interactive : Option < RuleConfiguration < biome_rule_options :: use_focusable_interactive :: UseFocusableInteractiveOptions >> , # [doc = "Disallow a missing generic family keyword within font families.\nSee <https://biomejs.dev/linter/rules/use-generic-font-names>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_generic_font_names : Option < RuleConfiguration < biome_rule_options :: use_generic_font_names :: UseGenericFontNamesOptions >> , # [doc = "Enforce that heading elements (h1, h2, etc.) have content and that the content is accessible to screen readers. Accessible means that it is not hidden using the aria-hidden prop.\nSee <https://biomejs.dev/linter/rules/use-heading-content>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_heading_content : Option < RuleConfiguration < biome_rule_options :: use_heading_content :: UseHeadingContentOptions >> , # [doc = "Enforce that html element has lang attribute.\nSee <https://biomejs.dev/linter/rules/use-html-lang>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_html_lang : Option < RuleConfiguration < biome_rule_options :: use_html_lang :: UseHtmlLangOptions >> , # [doc = "Enforces the usage of the attribute title for the element iframe.\nSee <https://biomejs.dev/linter/rules/use-iframe-title>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_iframe_title : Option < RuleConfiguration < biome_rule_options :: use_iframe_title :: UseIframeTitleOptions >> , # [doc = "Enforce onClick is accompanied by at least one of the following: onKeyUp, onKeyDown, onKeyPress.\nSee <https://biomejs.dev/linter/rules/use-key-with-click-events>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_key_with_click_events : Option < RuleConfiguration < biome_rule_options :: use_key_with_click_events :: UseKeyWithClickEventsOptions >> , # [doc = "Enforce onMouseOver / onMouseOut are accompanied by onFocus / onBlur.\nSee <https://biomejs.dev/linter/rules/use-key-with-mouse-events>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_key_with_mouse_events : Option < RuleConfiguration < biome_rule_options :: use_key_with_mouse_events :: UseKeyWithMouseEventsOptions >> , # [doc = "Enforces that audio and video elements must have a track for captions.\nSee <https://biomejs.dev/linter/rules/use-media-caption>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_media_caption : Option < RuleConfiguration < biome_rule_options :: use_media_caption :: UseMediaCaptionOptions >> , # [doc = "It detects the use of role attributes in JSX elements and suggests using semantic elements instead.\nSee <https://biomejs.dev/linter/rules/use-semantic-elements>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_semantic_elements : Option < RuleConfiguration < biome_rule_options :: use_semantic_elements :: UseSemanticElementsOptions >> , # [doc = "Enforce that all anchors are valid, and they are navigable elements.\nSee <https://biomejs.dev/linter/rules/use-valid-anchor>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_valid_anchor : Option < RuleConfiguration < biome_rule_options :: use_valid_anchor :: UseValidAnchorOptions >> , # [doc = "Ensures that ARIA properties aria-* are all valid.\nSee <https://biomejs.dev/linter/rules/use-valid-aria-props>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_valid_aria_props : Option < RuleFixConfiguration < biome_rule_options :: use_valid_aria_props :: UseValidAriaPropsOptions >> , # [doc = "Elements with ARIA roles must use a valid, non-abstract ARIA role.\nSee <https://biomejs.dev/linter/rules/use-valid-aria-role>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_valid_aria_role : Option < RuleFixConfiguration < biome_rule_options :: use_valid_aria_role :: UseValidAriaRoleOptions >> , # [doc = "Enforce that ARIA state and property values are valid.\nSee <https://biomejs.dev/linter/rules/use-valid-aria-values>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_valid_aria_values : Option < RuleConfiguration < biome_rule_options :: use_valid_aria_values :: UseValidAriaValuesOptions >> , # [doc = "Use valid values for the autocomplete attribute on input elements.\nSee <https://biomejs.dev/linter/rules/use-valid-autocomplete>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_valid_autocomplete : Option < RuleConfiguration < biome_rule_options :: use_valid_autocomplete :: UseValidAutocompleteOptions >> , # [doc = "Ensure that the attribute passed to the lang attribute is a correct ISO language and/or country.\nSee <https://biomejs.dev/linter/rules/use-valid-lang>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_valid_lang : Option < RuleConfiguration < biome_rule_options :: use_valid_lang :: UseValidLangOptions >> }
 impl A11y {
     const GROUP_NAME: &'static str = "a11y";
     pub(crate) const GROUP_RULES: &'static [&'static str] = &[
diff --git a/crates/biome_html_analyze/src/lint/a11y.rs b/crates/biome_html_analyze/src/lint/a11y.rs
index b276d6550d..e509af00bd 100644
--- a/crates/biome_html_analyze/src/lint/a11y.rs
+++ b/crates/biome_html_analyze/src/lint/a11y.rs
@@ -4,7 +4,6 @@
 
 use biome_analyze::declare_lint_group;
 pub mod no_access_key;
-pub mod no_autofocus;
 pub mod no_distracting_elements;
 pub mod no_header_scope;
 pub mod no_positive_tabindex;
@@ -14,4 +13,4 @@ pub mod use_button_type;
 pub mod use_html_lang;
 pub mod use_iframe_title;
 pub mod use_valid_aria_role;
-declare_lint_group! { pub A11y { name : "a11y" , rules : [self :: no_access_key :: NoAccessKey , self :: no_autofocus :: NoAutofocus , self :: no_distracting_elements :: NoDistractingElements , self :: no_header_scope :: NoHeaderScope , self :: no_positive_tabindex :: NoPositiveTabindex , self :: no_svg_without_title :: NoSvgWithoutTitle , self :: use_aria_props_for_role :: UseAriaPropsForRole , self :: use_button_type :: UseButtonType , self :: use_html_lang :: UseHtmlLang , self :: use_iframe_title :: UseIframeTitle , self :: use_valid_aria_role :: UseValidAriaRole ,] } }
+declare_lint_group! { pub A11y { name : "a11y" , rules : [self :: no_access_key :: NoAccessKey , self :: no_distracting_elements :: NoDistractingElements , self :: no_header_scope :: NoHeaderScope , self :: no_positive_tabindex :: NoPositiveTabindex , self :: no_svg_without_title :: NoSvgWithoutTitle , self :: use_aria_props_for_role :: UseAriaPropsForRole , self :: use_button_type :: UseButtonType , self :: use_html_lang :: UseHtmlLang , self :: use_iframe_title :: UseIframeTitle , self :: use_valid_aria_role :: UseValidAriaRole ,] } }
diff --git a/crates/biome_html_analyze/src/lint/a11y/no_autofocus.rs b/crates/biome_html_analyze/src/lint/a11y/no_autofocus.rs
deleted file mode 100644
index 116af8e8c3..0000000000
--- a/crates/biome_html_analyze/src/lint/a11y/no_autofocus.rs
+++ /dev/null
@@ -1,167 +0,0 @@
-use biome_analyze::{
-    Ast, FixKind, Rule, RuleDiagnostic, RuleSource, context::RuleContext, declare_lint_rule,
-};
-use biome_console::markup;
-use biome_diagnostics::Severity;
-use biome_html_syntax::element_ext::AnyHtmlTagElement;
-use biome_html_syntax::{HtmlAttribute, HtmlElement, HtmlSelfClosingElement};
-use biome_rowan::{AstNode, BatchMutationExt};
-use biome_rule_options::no_autofocus::NoAutofocusOptions;
-
-use crate::HtmlRuleAction;
-
-declare_lint_rule! {
-    /// Enforce that the `autofocus` attribute is not used on elements.
-    ///
-    /// Autofocusing elements can cause usability issues for sighted and non-sighted users, alike.
-    /// However, the `autofocus` attribute is allowed on elements inside a `dialog` element or
-    /// elements with a `popover` attribute, as these are modal contexts where autofocus is expected.
-    ///
-    /// ## Examples
-    ///
-    /// ### Invalid
-    ///
-    /// ```html,expect_diagnostic
-    /// <input autofocus />
-    /// ```
-    ///
-    /// ```html,expect_diagnostic
-    /// <input autofocus="true" />
-    /// ```
-    ///
-    /// ```html,expect_diagnostic
-    /// <textarea autofocus>content</textarea>
-    /// ```
-    ///
-    /// ### Valid
-    ///
-    /// ```html
-    /// <input />
-    /// ```
-    ///
-    /// ```html
-    /// <div popover><input autofocus /></div>
-    /// ```
-    ///
-    /// ```html
-    /// <dialog><input autofocus /></dialog>
-    /// ```
-    ///
-    /// ## Resources
-    ///
-    /// - [WHATWG HTML Standard, The autofocus attribute](https://html.spec.whatwg.org/multipage/interaction.html#attr-fe-autofocus)
-    /// - [The accessibility of HTML 5 autofocus](https://brucelawson.co.uk/2009/the-accessibility-of-html-5-autofocus/)
-    /// - [MDN Web Docs, HTMLElement: autofocus property](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/autofocus)
-    ///
-    pub NoAutofocus {
-        version: "next",
-        name: "noAutofocus",
-        language: "html",
-        sources: &[RuleSource::EslintJsxA11y("no-autofocus").same()],
-        recommended: true,
-        severity: Severity::Error,
-        fix_kind: FixKind::Unsafe,
-    }
-}
-
-impl Rule for NoAutofocus {
-    type Query = Ast<HtmlAttribute>;
-    type State = ();
-    type Signals = Option<Self::State>;
-    type Options = NoAutofocusOptions;
-
-    fn run(ctx: &RuleContext<Self>) -> Option<Self::State> {
-        let node = ctx.query();
-
-        // Check if this is an autofocus attribute
-        if !is_autofocus_attribute(node) {
-            return None;
-        }
-
-        // Check if element is inside a dialog or has popover attribute in ancestors
-        if is_inside_allowed_context(node).unwrap_or(false) {
-            return None;
-        }
-
-        Some(())
-    }
-
-    fn diagnostic(ctx: &RuleContext<Self>, _state: &Self::State) -> Option<RuleDiagnostic> {
-        let node = ctx.query();
-        Some(RuleDiagnostic::new(
-            rule_category!(),
-            node.syntax().text_trimmed_range(),
-            markup! {
-                "Avoid the "<Emphasis>"autofocus"</Emphasis>" attribute."
-            },
-        ))
-    }
-
-    fn action(ctx: &RuleContext<Self>, _state: &Self::State) -> Option<HtmlRuleAction> {
-        let node = ctx.query();
-        let mut mutation = ctx.root().begin();
-        mutation.remove_node(node.clone());
-        Some(HtmlRuleAction::new(
-            ctx.metadata().action_category(ctx.category(), ctx.group()),
-            ctx.metadata().applicability(),
-            markup! { "Remove the "<Emphasis>"autofocus"</Emphasis>" attribute." }.to_owned(),
-            mutation,
-        ))
-    }
-}
-
-/// Check if the attribute is an autofocus attribute
-fn is_autofocus_attribute(node: &HtmlAttribute) -> bool {
-    node.name().is_ok_and(|name| {
-        name.value_token()
-            .is_ok_and(|value_token| value_token.text_trimmed().eq_ignore_ascii_case("autofocus"))
-    })
-}
-
-/// Check if the element is inside an allowed context (dialog or popover)
-///
-/// Note: We skip the first [HtmlElement] (the one containing the autofocus attribute)
-/// because we only want to check if it's *inside* a dialog/popover, not if
-/// it *is* the dialog/popover itself.
-fn is_inside_allowed_context(attr: &HtmlAttribute) -> Option<bool> {
-    let mut skip_first_element = true;
-
-    // Walk up the ancestors to find if we're inside a dialog or popover
-    for ancestor in attr.syntax().ancestors() {
-        let Some(tag_element) = get_tag_element(&ancestor) else {
-            continue;
-        };
-
-        if skip_first_element {
-            skip_first_element = false;
-            continue;
-        }
-
-        if is_dialog_or_popover(&tag_element) {
-            return Some(true);
-        }
-    }
-
-    Some(false)
-}
-
-/// Extract an [AnyHtmlTagElement] from an ancestor node
-fn get_tag_element(node: &biome_html_syntax::HtmlSyntaxNode) -> Option<AnyHtmlTagElement> {
-    HtmlElement::cast_ref(node)
-        .and_then(|e| e.opening_element().ok())
-        .map(AnyHtmlTagElement::from)
-        .or_else(|| {
-            HtmlSelfClosingElement::cast_ref(node).map(|e| AnyHtmlTagElement::from(e.clone()))
-        })
-}
-
-/// Check if the tag element is a dialog or has popover attribute
-fn is_dialog_or_popover(tag_element: &AnyHtmlTagElement) -> bool {
-    let is_dialog = tag_element
-        .name()
-        .ok()
-        .and_then(|n| n.value_token().ok())
-        .is_some_and(|token| token.text_trimmed().eq_ignore_ascii_case("dialog"));
-
-    is_dialog || tag_element.find_attribute_by_name("popover").is_some()
-}
diff --git a/crates/biome_js_analyze/src/lint/suspicious/use_iterable_callback_return.rs b/crates/biome_js_analyze/src/lint/suspicious/use_iterable_callback_return.rs
index 6ce5644d2b..43cd0995c1 100644
--- a/crates/biome_js_analyze/src/lint/suspicious/use_iterable_callback_return.rs
+++ b/crates/biome_js_analyze/src/lint/suspicious/use_iterable_callback_return.rs
@@ -57,9 +57,15 @@ declare_lint_rule! {
     /// });
     /// ```
     ///
-    /// ```js,expect_diagnostic
+    /// ```js
     /// [].forEach(() => {
-    ///     return 1; // Should not return a value
+    ///     // No return value, which is correct
+    /// });
+    /// ```
+    ///
+    /// ```js,expect_diagnostic
+    /// [].filter(() => {
+    ///     // Missing required return value
     /// });
     /// ```
     ///
@@ -72,14 +78,37 @@ declare_lint_rule! {
     /// ```
     ///
     /// ```js
-    /// [].forEach(() => {
-    ///     // No return value, which is correct
-    /// });
+    /// [].forEach(() => void null); // Void return value, which doesn't trigger the rule
     /// ```
     ///
-    /// ```js
-    /// [].forEach(() => void null); // Void return value, which doesn't trigger the rule
+    /// ## Options
+    ///
+    /// ### `checkForEach`
+    ///
+    /// **Since `v2.4.0**
+    ///
+    /// Default: `true`
+    ///
+    /// When set to `false`, the rule will skip `forEach` callbacks that return a value.
+    ///
+    /// ### Examples
+    ///
+    /// ```json,options
+    /// {
+    ///     "options": {
+    ///         "checkForEach": false
+    ///     }
+    /// }
     /// ```
+    ///
+    /// ```js,use_options
+    /// [1, 2, 3].forEach((el) => {
+    ///     return el * 2;
+    /// });
+    /// ```
+    ///
+    /// When `checkForEach` is `false` (default), the above code will not trigger any diagnostic.
+    ///
     pub UseIterableCallbackReturn {
         version: "2.0.0",
         name: "useIterableCallbackReturn",
@@ -128,6 +157,10 @@ impl Rule for UseIterableCallbackReturn {
             .and_then(|member| member.as_js_name().cloned())
             .and_then(|name| name.value_token().ok())?;
 
+        if !ctx.options().check_for_each() && member_name.text_trimmed() == "forEach" {
+            return None;
+        }
+
         let method_config = ITERABLE_METHOD_INFOS.get(member_name.text_trimmed())?;
 
         let arg_position = argument_list
diff --git a/crates/biome_rule_options/src/use_iterable_callback_return.rs b/crates/biome_rule_options/src/use_iterable_callback_return.rs
index 866a2b0db3..604fc9dab2 100644
--- a/crates/biome_rule_options/src/use_iterable_callback_return.rs
+++ b/crates/biome_rule_options/src/use_iterable_callback_return.rs
@@ -3,4 +3,19 @@ use serde::{Deserialize, Serialize};
 #[derive(Default, Clone, Debug, Deserialize, Deserializable, Merge, Eq, PartialEq, Serialize)]
 #[cfg_attr(feature = "schema", derive(schemars::JsonSchema))]
 #[serde(rename_all = "camelCase", deny_unknown_fields, default)]
-pub struct UseIterableCallbackReturnOptions {}
+pub struct UseIterableCallbackReturnOptions {
+    /// When `true`, the rule reports `forEach` callbacks that return a value (default behaviour).
+    /// When `false` or unset, such callbacks are ignored.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub check_for_each: Option<bool>,
+}
+
+impl UseIterableCallbackReturnOptions {
+    pub const DEFAULT_CHECK_FOR_EACH: bool = true;
+
+    /// Returns [`Self::check_for_each`] if it is set.
+    /// Otherwise, returns [`Self::DEFAULT_CHECK_FOR_EACH`].
+    pub fn check_for_each(&self) -> bool {
+        self.check_for_each.unwrap_or(Self::DEFAULT_CHECK_FOR_EACH)
+    }
+}
diff --git a/packages/@biomejs/backend-jsonrpc/src/workspace.ts b/packages/@biomejs/backend-jsonrpc/src/workspace.ts
index 33e0bb1d18..9610484fc9 100644
--- a/packages/@biomejs/backend-jsonrpc/src/workspace.ts
+++ b/packages/@biomejs/backend-jsonrpc/src/workspace.ts
@@ -1105,7 +1105,7 @@ See <https://biomejs.dev/linter/rules/no-aria-unsupported-elements>
 	 */
 	noAriaUnsupportedElements?: NoAriaUnsupportedElementsConfiguration;
 	/**
-	* Enforce that the autofocus attribute is not used on elements.
+	* Enforce that autoFocus prop is not used on elements.
 See <https://biomejs.dev/linter/rules/no-autofocus> 
 	 */
 	noAutofocus?: NoAutofocusConfiguration;
@@ -7139,7 +7139,13 @@ export type UseGetterReturnOptions = {};
 export type UseGoogleFontDisplayOptions = {};
 export type UseGuardForInOptions = {};
 export type UseIsArrayOptions = {};
-export type UseIterableCallbackReturnOptions = {};
+export interface UseIterableCallbackReturnOptions {
+	/**
+	* When `true`, the rule reports `forEach` callbacks that return a value (default behaviour).
+When `false` or unset, such callbacks are ignored. 
+	 */
+	checkForEach?: boolean;
+}
 export type UseNamespaceKeywordOptions = {};
 export type UseNumberToFixedDigitsArgumentOptions = {};
 export type UseStaticResponseMethodsOptions = {};
diff --git a/packages/@biomejs/biome/configuration_schema.json b/packages/@biomejs/biome/configuration_schema.json
index 2fcd51667e..e22315fbb0 100644
--- a/packages/@biomejs/biome/configuration_schema.json
+++ b/packages/@biomejs/biome/configuration_schema.json
@@ -100,7 +100,7 @@
 					]
 				},
 				"noAutofocus": {
-					"description": "Enforce that the autofocus attribute is not used on elements.\nSee <https://biomejs.dev/linter/rules/no-autofocus>",
+					"description": "Enforce that autoFocus prop is not used on elements.\nSee <https://biomejs.dev/linter/rules/no-autofocus>",
 					"anyOf": [
 						{ "$ref": "#/$defs/NoAutofocusConfiguration" },
 						{ "type": "null" }
@@ -12452,6 +12452,12 @@
 		},
 		"UseIterableCallbackReturnOptions": {
 			"type": "object",
+			"properties": {
+				"checkForEach": {
+					"description": "When `true`, the rule reports `forEach` callbacks that return a value (default behaviour).\nWhen `false` or unset, such callbacks are ignored.",
+					"type": ["boolean", "null"]
+				}
+			},
 			"additionalProperties": false
 		},
 		"UseJsonImportAttributesConfiguration": {
