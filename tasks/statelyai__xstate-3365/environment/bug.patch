diff --git a/.changeset/mighty-terms-shake.md b/.changeset/mighty-terms-shake.md
deleted file mode 100644
index a89ce5a7a2..0000000000
--- a/.changeset/mighty-terms-shake.md
+++ /dev/null
@@ -1,10 +0,0 @@
----
-'@xstate/graph': patch
-'@xstate/test': patch
----
-
-The `serializeState()` path traversal option now provides 3 arguments to the function passed in:
-
-1. `state` - the current state
-2. `event` - the event that caused traversal to this state
-3. `prevState` ðŸ†• - the state before the current state (may be `undefined`)
diff --git a/packages/xstate-graph/src/graph.ts b/packages/xstate-graph/src/graph.ts
index 431e21dece..9485d54d62 100644
--- a/packages/xstate-graph/src/graph.ts
+++ b/packages/xstate-graph/src/graph.ts
@@ -85,8 +85,8 @@ const defaultValueAdjacencyMapOptions: Required<
 > = {
   events: {},
   filter: () => true,
-  serializeState: serializeMachineState,
-  serializeEvent
+  stateSerializer: serializeMachineState,
+  eventSerializer: serializeEvent
 };
 
 function getValueAdjacencyMapOptions<TState, TEvent extends EventObject>(
@@ -108,11 +108,7 @@ export function getValueAdjacencyMap<TMachine extends AnyStateMachine>(
   type TEvent = EventFrom<TMachine>;
 
   const optionsWithDefaults = getValueAdjacencyMapOptions(options);
-  const {
-    filter,
-    serializeState: stateSerializer,
-    serializeEvent: eventSerializer
-  } = optionsWithDefaults;
+  const { filter, stateSerializer, eventSerializer } = optionsWithDefaults;
   const { events } = optionsWithDefaults;
 
   const adjacency: ValueAdjacencyMap<TState, TEvent> = {};
@@ -390,9 +386,9 @@ export function getPathFromEvents<
     undefined,
     undefined
   ) as SerializedState;
-  stateMap.set(initialSerializedState, behavior.initialState);
+  stateMap.set(initialStateSerial, behavior.initialState);
 
-  let stateSerial = initialSerializedState;
+  let stateSerial = initialStateSerial;
   let state = behavior.initialState;
   for (const event of events) {
     path.push({
diff --git a/packages/xstate-graph/src/types.ts b/packages/xstate-graph/src/types.ts
index 3e4c2ebebe..dfa68cee42 100644
--- a/packages/xstate-graph/src/types.ts
+++ b/packages/xstate-graph/src/types.ts
@@ -123,8 +123,8 @@ export interface ValueAdjacencyMapOptions<TState, TEvent extends EventObject> {
       | ((state: TState) => Array<ExtractEvent<TEvent, K>>);
   };
   filter?: (state: TState) => boolean;
-  serializeState?: (state: TState) => string;
-  serializeEvent?: (event: TEvent) => string;
+  stateSerializer?: (state: TState) => string;
+  eventSerializer?: (event: TEvent) => string;
 }
 
 export interface VisitedContext<TState, TEvent> {
diff --git a/packages/xstate-graph/test/graph.test.ts b/packages/xstate-graph/test/graph.test.ts
index 4f5c3dd0a9..5f1179e924 100644
--- a/packages/xstate-graph/test/graph.test.ts
+++ b/packages/xstate-graph/test/graph.test.ts
@@ -480,7 +480,7 @@ describe('@xstate/graph', () => {
 
       const adj = getValueAdjacencyMap(counterMachine, {
         filter: (state) => state.context.count >= 0 && state.context.count <= 5,
-        serializeState: (state) => {
+        stateSerializer: (state) => {
           const ctx = {
             count: state.context.count
           };
@@ -665,37 +665,3 @@ describe('filtering', () => {
     `);
   });
 });
-
-it('should provide previous state for serializeState()', () => {
-  const machine = createMachine({
-    initial: 'a',
-    states: {
-      a: {
-        on: { toB: 'b' }
-      },
-      b: {
-        on: { toC: 'c' }
-      },
-      c: {
-        on: { toA: 'a' }
-      }
-    }
-  });
-
-  const shortestPaths = getShortestPlans(machine, {
-    serializeState: (state, event, prevState) => {
-      return `${JSON.stringify(state.value)} via ${event?.type}${
-        prevState ? ` via ${JSON.stringify(prevState.value)}` : ''
-      }`;
-    }
-  });
-
-  // Should be [0, 3]:
-  // 0 (a)
-  // 3 (a -> b -> c -> a)
-  expect(
-    shortestPaths
-      .filter((path) => path.state.matches('a'))
-      .map((plan) => plan.paths[0].steps.length)
-  ).toEqual([0, 3]);
-});
