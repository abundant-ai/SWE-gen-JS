diff --git a/examples/incremental-rendering/incremental-rendering.tsx b/examples/incremental-rendering/incremental-rendering.tsx
deleted file mode 100644
index 0048eb0..0000000
--- a/examples/incremental-rendering/incremental-rendering.tsx
+++ /dev/null
@@ -1,248 +0,0 @@
-import React, {useState, useEffect} from 'react';
-import {
-	render,
-	Text,
-	Box,
-	useInput,
-	useStdout,
-	useApp,
-} from '../../src/index.js';
-
-const rows = [
-	'Server Authentication Module - Handles JWT token validation, OAuth2 flows, and session management across distributed systems',
-	'Database Connection Pool - Maintains persistent connections to PostgreSQL cluster with automatic failover and load balancing',
-	'API Gateway Service - Routes incoming HTTP requests to microservices with rate limiting and request transformation',
-	'User Profile Manager - Caches user data in Redis with write-through policy and invalidation strategies',
-	'Payment Processing Engine - Integrates with Stripe, PayPal, and Square APIs for transaction processing',
-	'Email Notification Queue - Processes outbound emails through SendGrid with retry logic and delivery tracking',
-	'File Storage Handler - Manages S3 bucket operations with multipart uploads and CDN integration',
-	'Search Indexer Service - Maintains Elasticsearch indices with real-time document updates and reindexing',
-	'Metrics Aggregation Pipeline - Collects and processes telemetry data for Prometheus and Grafana dashboards',
-	'WebSocket Connection Manager - Handles real-time bidirectional communication for chat and notifications',
-	'Cache Invalidation Service - Coordinates distributed cache updates across Redis cluster nodes',
-	'Background Job Processor - Executes async tasks via RabbitMQ with dead letter queue handling',
-	'Session Store Manager - Persists user sessions in DynamoDB with TTL and cross-region replication',
-	'Rate Limiter Module - Enforces API quotas using token bucket algorithm with Redis backend',
-	'Content Delivery Network - Serves static assets through Cloudflare with edge caching and GZIP compression',
-	'Logging Aggregator - Streams application logs to ELK stack with structured JSON formatting',
-	'Health Check Monitor - Performs periodic service health checks with circuit breaker pattern implementation',
-	'Configuration Manager - Loads environment-specific settings from Consul with hot reload capability',
-	'Security Scanner Service - Runs automated vulnerability scans and dependency checks on deployed applications',
-	'Backup Orchestrator - Schedules and executes automated database backups with encryption and versioning',
-	'Load Balancer Controller - Manages NGINX upstream servers with health-based traffic distribution',
-	'Container Orchestration - Coordinates Docker container lifecycle via Kubernetes with auto-scaling policies',
-	'Message Bus Coordinator - Routes events through Apache Kafka topics with guaranteed delivery semantics',
-	'Analytics Data Warehouse - Aggregates business metrics in Snowflake with incremental ETL processes',
-	'API Documentation Service - Generates and serves OpenAPI specs with interactive Swagger UI',
-	'Feature Flag Manager - Controls feature rollouts using LaunchDarkly with user targeting and percentage rollouts',
-	'Audit Trail Logger - Records all user actions and system events for compliance and security analysis',
-	'Image Processing Pipeline - Resizes and optimizes uploaded images using Sharp with multiple format outputs',
-	'Geolocation Service - Resolves IP addresses to geographic coordinates using MaxMind GeoIP2 database',
-	'Recommendation Engine - Generates personalized content suggestions using collaborative filtering algorithms',
-];
-
-const generateLogLine = (index: number, value: number) => {
-	const timestamp = new Date().toLocaleTimeString();
-	const actions = [
-		'PROCESSING',
-		'COMPLETED',
-		'UPDATING',
-		'SYNCING',
-		'VALIDATING',
-		'EXECUTING',
-	];
-	const action = actions[Math.floor(Math.random() * actions.length)];
-	return `[${timestamp}] Worker-${index} ${action}: Batch=${value} Throughput=${(Math.random() * 1000).toFixed(0)}req/s Memory=${(Math.random() * 512).toFixed(1)}MB CPU=${(Math.random() * 100).toFixed(1)}%`;
-};
-
-function IncrementalRendering() {
-	const {exit} = useApp();
-	const {stdout} = useStdout();
-	const terminalHeight = stdout.rows || 24; // Default to 24 if not available
-
-	// Calculate available space for dynamic content
-	// Header box: ~9 lines (border + content)
-	// Logs box: variable (border + title + log lines)
-	// Services box: variable (border + title + services)
-	// Footer box: ~3 lines
-	// Margins: ~3 lines
-	// Total fixed: ~15 lines, so available = terminalHeight - 15
-	const availableLines = Math.max(terminalHeight - 15, 10);
-
-	// Split available space: ~30% for logs, ~70% for services
-	const logLineCount = Math.max(Math.floor(availableLines * 0.3), 3);
-	const serviceCount = Math.min(
-		Math.max(Math.floor(availableLines * 0.7), 5),
-		rows.length,
-	);
-
-	const [selectedIndex, setSelectedIndex] = useState(0);
-	const [timestamp, setTimestamp] = useState(new Date().toLocaleTimeString());
-	const [counter, setCounter] = useState(0);
-	const [fps, setFps] = useState(0);
-	const [progress1, setProgress1] = useState(0);
-	const [progress2, setProgress2] = useState(0);
-	const [progress3, setProgress3] = useState(0);
-	const [randomValue, setRandomValue] = useState(0);
-	const [logLines, setLogLines] = useState(
-		Array.from({length: logLineCount}, (_, i) => generateLogLine(i, 0)),
-	);
-
-	// Update timestamp and counter every second to show live updates
-	useEffect(() => {
-		const timer = setInterval(() => {
-			setTimestamp(new Date().toLocaleTimeString());
-			setCounter(previous => previous + 1);
-		}, 1000);
-
-		return () => {
-			clearInterval(timer);
-		};
-	}, []);
-
-	// Rapid updates to degrade performance - updates every 16ms (~60fps)
-	useEffect(() => {
-		let frameCount = 0;
-		let lastTime = Date.now();
-
-		const timer = setInterval(() => {
-			setProgress1(previous => (previous + 1) % 101);
-			setProgress2(previous => (previous + 2) % 101);
-			setProgress3(previous => (previous + 3) % 101);
-			setRandomValue(Math.floor(Math.random() * 1000));
-
-			// Update only 1-2 log lines each frame (simulating real log updates)
-			setLogLines(previous => {
-				const newLines = [...previous];
-				const updateIndex = Math.floor(Math.random() * newLines.length);
-				newLines[updateIndex] = generateLogLine(
-					updateIndex,
-					Math.floor(Math.random() * 1000),
-				);
-				return newLines;
-			});
-
-			// Calculate FPS
-			frameCount++;
-			const now = Date.now();
-			if (now - lastTime >= 1000) {
-				setFps(frameCount);
-				frameCount = 0;
-				lastTime = now;
-			}
-		}, 16); // ~60 updates per second
-
-		return () => {
-			clearInterval(timer);
-		};
-	}, []);
-
-	useInput((input, key) => {
-		if (key.upArrow) {
-			setSelectedIndex(previousIndex =>
-				previousIndex === 0 ? serviceCount - 1 : previousIndex - 1,
-			);
-		}
-
-		if (key.downArrow) {
-			setSelectedIndex(previousIndex =>
-				previousIndex === serviceCount - 1 ? 0 : previousIndex + 1,
-			);
-		}
-
-		if (input === 'q') {
-			exit();
-		}
-	});
-
-	const progressBar = (value: number) => {
-		const filled = Math.floor(value / 5);
-		const empty = 20 - filled;
-		return '█'.repeat(filled) + '░'.repeat(empty);
-	};
-
-	return (
-		<Box flexDirection="column" height="100%">
-			<Box borderStyle="round" borderColor="cyan" paddingX={2} paddingY={1}>
-				<Box flexDirection="column">
-					<Text bold color="cyan">
-						Incremental Rendering Demo - incrementalRendering={String(true)}
-					</Text>
-					<Text dimColor>
-						Use ↑/↓ arrows to navigate • Press q to quit • FPS: {fps}
-					</Text>
-					<Text>
-						Time: <Text color="green">{timestamp}</Text> • Updates:{' '}
-						<Text color="yellow">{counter}</Text> • Random:{' '}
-						<Text color="cyan">{randomValue}</Text>
-					</Text>
-					<Text>
-						Progress 1: <Text color="green">{progressBar(progress1)}</Text>{' '}
-						{progress1}%
-					</Text>
-					<Text>
-						Progress 2: <Text color="yellow">{progressBar(progress2)}</Text>{' '}
-						{progress2}%
-					</Text>
-					<Text>
-						Progress 3: <Text color="red">{progressBar(progress3)}</Text>{' '}
-						{progress3}%
-					</Text>
-				</Box>
-			</Box>
-
-			<Box
-				borderStyle="single"
-				borderColor="yellow"
-				paddingX={2}
-				paddingY={1}
-				marginTop={1}
-			>
-				<Box flexDirection="column">
-					<Text bold color="yellow">
-						Live Logs (only 1-2 lines update per frame):
-					</Text>
-					{logLines.map(line => (
-						<Text key={line} color="green">
-							{line}
-						</Text>
-					))}
-				</Box>
-			</Box>
-
-			<Box
-				borderStyle="single"
-				borderColor="gray"
-				paddingX={2}
-				paddingY={1}
-				marginTop={1}
-				flexGrow={1}
-				flexDirection="column"
-			>
-				<Text bold color="magenta">
-					System Services Monitor ({serviceCount} of {rows.length} services):
-				</Text>
-				{rows.slice(0, serviceCount).map((row, index) => {
-					const isSelected = index === selectedIndex;
-					return (
-						<Text key={row} color={isSelected ? 'blue' : 'white'}>
-							{isSelected ? '> ' : '  '}
-							{row}
-						</Text>
-					);
-				})}
-			</Box>
-
-			<Box borderStyle="round" borderColor="magenta" paddingX={2} marginTop={1}>
-				<Text>
-					Selected:{' '}
-					<Text bold color="magenta">
-						{rows.slice(0, serviceCount)[selectedIndex]}
-					</Text>
-				</Text>
-			</Box>
-		</Box>
-	);
-}
-
-render(<IncrementalRendering />, {incrementalRendering: true});
diff --git a/examples/incremental-rendering/index.ts b/examples/incremental-rendering/index.ts
deleted file mode 100644
index 1f7ee72..0000000
--- a/examples/incremental-rendering/index.ts
+++ /dev/null
@@ -1 +0,0 @@
-import './incremental-rendering.js';
diff --git a/readme.md b/readme.md
index c02d532..224484a 100644
--- a/readme.md
+++ b/readme.md
@@ -2045,14 +2045,6 @@ This controls how frequently the UI can update to prevent excessive re-rendering
 Higher values allow more frequent updates but may impact performance.
 Setting it to a lower value may be useful for components that update very frequently, to reduce CPU usage.
 
-###### incrementalRendering
-
-Type: `boolean`\
-Default: `false`
-
-Enable incremental rendering mode which only updates changed lines instead of redrawing the entire output.
-This can reduce flickering and improve performance for frequently updating UIs.
-
 #### Instance
 
 This is the object that `render()` returns.
diff --git a/src/ink.tsx b/src/ink.tsx
index 54c710a..6679e2d 100644
--- a/src/ink.tsx
+++ b/src/ink.tsx
@@ -30,7 +30,6 @@ export type Options = {
 	isScreenReaderEnabled?: boolean;
 	waitUntilExit?: () => Promise<void>;
 	maxFps?: number;
-	incrementalRendering?: boolean;
 };
 
 export default class Ink {
@@ -76,9 +75,7 @@ export default class Ink {
 				});
 
 		this.rootNode.onImmediateRender = this.onRender;
-		this.log = logUpdate.create(options.stdout, {
-			incremental: options.incrementalRendering,
-		});
+		this.log = logUpdate.create(options.stdout);
 		this.throttledLog = unthrottled
 			? this.log
 			: (throttle(this.log, undefined, {
diff --git a/src/log-update.ts b/src/log-update.ts
index b689c50..33458e0 100644
--- a/src/log-update.ts
+++ b/src/log-update.ts
@@ -9,10 +9,7 @@ export type LogUpdate = {
 	(str: string): void;
 };
 
-const createStandard = (
-	stream: Writable,
-	{showCursor = false} = {},
-): LogUpdate => {
+const create = (stream: Writable, {showCursor = false} = {}): LogUpdate => {
 	let previousLineCount = 0;
 	let previousOutput = '';
 	let hasHiddenCursor = false;
@@ -58,103 +55,5 @@ const createStandard = (
 	return render;
 };
 
-const createIncremental = (
-	stream: Writable,
-	{showCursor = false} = {},
-): LogUpdate => {
-	let previousLines: string[] = [];
-	let previousOutput = '';
-	let hasHiddenCursor = false;
-
-	const render = (str: string) => {
-		if (!showCursor && !hasHiddenCursor) {
-			cliCursor.hide();
-			hasHiddenCursor = true;
-		}
-
-		const output = str + '\n';
-		if (output === previousOutput) {
-			return;
-		}
-
-		const previousCount = previousLines.length;
-		const nextLines = output.split('\n');
-		const nextCount = nextLines.length;
-		const visibleCount = nextCount - 1;
-
-		if (output === '\n' || previousOutput.length === 0) {
-			stream.write(ansiEscapes.eraseLines(previousCount) + output);
-			previousOutput = output;
-			previousLines = nextLines;
-			return;
-		}
-
-		// We aggregate all chunks for incremental rendering into a buffer, and then write them to stdout at the end.
-		const buffer: string[] = [];
-
-		// Clear extra lines if the current content's line count is lower than the previous.
-		if (nextCount < previousCount) {
-			buffer.push(
-				// Erases the trailing lines and the final newline slot.
-				ansiEscapes.eraseLines(previousCount - nextCount + 1),
-				// Positions cursor to the top of the rendered output.
-				ansiEscapes.cursorUp(visibleCount),
-			);
-		} else {
-			buffer.push(ansiEscapes.cursorUp(previousCount - 1));
-		}
-
-		for (let i = 0; i < visibleCount; i++) {
-			// We do not write lines if the contents are the same. This prevents flickering during renders.
-			if (nextLines[i] === previousLines[i]) {
-				buffer.push(ansiEscapes.cursorNextLine);
-				continue;
-			}
-
-			buffer.push(ansiEscapes.eraseLine + nextLines[i] + '\n');
-		}
-
-		stream.write(buffer.join(''));
-
-		previousOutput = output;
-		previousLines = nextLines;
-	};
-
-	render.clear = () => {
-		stream.write(ansiEscapes.eraseLines(previousLines.length));
-		previousOutput = '';
-		previousLines = [];
-	};
-
-	render.done = () => {
-		previousOutput = '';
-		previousLines = [];
-
-		if (!showCursor) {
-			cliCursor.show();
-			hasHiddenCursor = false;
-		}
-	};
-
-	render.sync = (str: string) => {
-		const output = str + '\n';
-		previousOutput = output;
-		previousLines = output.split('\n');
-	};
-
-	return render;
-};
-
-const create = (
-	stream: Writable,
-	{showCursor = false, incremental = false} = {},
-): LogUpdate => {
-	if (incremental) {
-		return createIncremental(stream, {showCursor});
-	}
-
-	return createStandard(stream, {showCursor});
-};
-
 const logUpdate = {create};
 export default logUpdate;
diff --git a/src/render.ts b/src/render.ts
index 09c25bd..0da09fa 100644
--- a/src/render.ts
+++ b/src/render.ts
@@ -57,14 +57,6 @@ export type RenderOptions = {
 	@default 30
 	*/
 	maxFps?: number;
-
-	/**
-	Enable incremental rendering mode which only updates changed lines instead of redrawing the entire output.
-	This can reduce flickering and improve performance for frequently updating UIs.
-
-	@default false
-	*/
-	incrementalRendering?: boolean;
 };
 
 export type Instance = {
@@ -103,7 +95,6 @@ const render = (
 		exitOnCtrlC: true,
 		patchConsole: true,
 		maxFps: 30,
-		incrementalRendering: false,
 		...getOptions(options),
 	};
 
diff --git a/test/log-update.tsx b/test/log-update.tsx
deleted file mode 100644
index e1d70af..0000000
--- a/test/log-update.tsx
+++ /dev/null
@@ -1,201 +0,0 @@
-import test from 'ava';
-import ansiEscapes from 'ansi-escapes';
-import logUpdate from '../src/log-update.js';
-import createStdout from './helpers/create-stdout.js';
-
-test('standard rendering - renders and updates output', t => {
-	const stdout = createStdout();
-	const render = logUpdate.create(stdout);
-
-	render('Hello');
-	t.is((stdout.write as any).callCount, 1);
-	t.is((stdout.write as any).firstCall.args[0], 'Hello\n');
-
-	render('World');
-	t.is((stdout.write as any).callCount, 2);
-	t.true(
-		((stdout.write as any).secondCall.args[0] as string).includes('World'),
-	);
-});
-
-test('standard rendering - skips identical output', t => {
-	const stdout = createStdout();
-	const render = logUpdate.create(stdout);
-
-	render('Hello');
-	render('Hello');
-
-	t.is((stdout.write as any).callCount, 1);
-});
-
-test('incremental rendering - renders and updates output', t => {
-	const stdout = createStdout();
-	const render = logUpdate.create(stdout, {incremental: true});
-
-	render('Hello');
-	t.is((stdout.write as any).callCount, 1);
-	t.is((stdout.write as any).firstCall.args[0], 'Hello\n');
-
-	render('World');
-	t.is((stdout.write as any).callCount, 2);
-	t.true(
-		((stdout.write as any).secondCall.args[0] as string).includes('World'),
-	);
-});
-
-test('incremental rendering - skips identical output', t => {
-	const stdout = createStdout();
-	const render = logUpdate.create(stdout, {incremental: true});
-
-	render('Hello');
-	render('Hello');
-
-	t.is((stdout.write as any).callCount, 1);
-});
-
-test('incremental rendering - surgical updates', t => {
-	const stdout = createStdout();
-	const render = logUpdate.create(stdout, {incremental: true});
-
-	render('Line 1\nLine 2\nLine 3');
-	render('Line 1\nUpdated\nLine 3');
-
-	const secondCall = (stdout.write as any).secondCall.args[0] as string;
-	t.true(secondCall.includes(ansiEscapes.cursorNextLine)); // Skips unchanged lines
-	t.true(secondCall.includes('Updated')); // Only updates changed line
-	t.false(secondCall.includes('Line 1')); // Doesn't rewrite unchanged
-	t.false(secondCall.includes('Line 3')); // Doesn't rewrite unchanged
-});
-
-test('incremental rendering - clears extra lines when output shrinks', t => {
-	const stdout = createStdout();
-	const render = logUpdate.create(stdout, {incremental: true});
-
-	render('Line 1\nLine 2\nLine 3');
-	render('Line 1');
-
-	const secondCall = (stdout.write as any).secondCall.args[0] as string;
-	t.true(secondCall.includes(ansiEscapes.eraseLines(2))); // Erases 2 extra lines
-});
-
-test('incremental rendering - when output grows', t => {
-	const stdout = createStdout();
-	const render = logUpdate.create(stdout, {incremental: true});
-
-	render('Line 1');
-	render('Line 1\nLine 2\nLine 3');
-
-	const secondCall = (stdout.write as any).secondCall.args[0] as string;
-	t.true(secondCall.includes(ansiEscapes.cursorNextLine)); // Skips unchanged first line
-	t.true(secondCall.includes('Line 2')); // Adds new line
-	t.true(secondCall.includes('Line 3')); // Adds new line
-	t.false(secondCall.includes('Line 1')); // Doesn't rewrite unchanged
-});
-
-test('incremental rendering - single write call with multiple surgical updates', t => {
-	const stdout = createStdout();
-	const render = logUpdate.create(stdout, {incremental: true});
-
-	render(
-		'Line 1\nLine 2\nLine 3\nLine 4\nLine 5\nLine 6\nLine 7\nLine 8\nLine 9\nLine 10',
-	);
-	render(
-		'Line 1\nUpdated 2\nLine 3\nUpdated 4\nLine 5\nUpdated 6\nLine 7\nUpdated 8\nLine 9\nUpdated 10',
-	);
-
-	t.is((stdout.write as any).callCount, 2); // Only 2 writes total (initial + update)
-});
-
-test('incremental rendering - shrinking output keeps screen tight', t => {
-	const stdout = createStdout();
-	const render = logUpdate.create(stdout, {incremental: true});
-
-	render('Line 1\nLine 2\nLine 3');
-	render('Line 1\nLine 2');
-	render('Line 1');
-
-	const thirdCall = stdout.get();
-
-	t.is(
-		thirdCall,
-		ansiEscapes.eraseLines(2) + // Erase Line 2 and ending cursorNextLine
-			ansiEscapes.cursorUp(1) + // Move to beginning of Line 1
-			ansiEscapes.cursorNextLine, // Move to next line after Line 1
-	);
-});
-
-test('incremental rendering - clear() fully resets incremental state', t => {
-	const stdout = createStdout();
-	const render = logUpdate.create(stdout, {incremental: true});
-
-	render('Line 1\nLine 2\nLine 3');
-	render.clear();
-	render('Line 1');
-
-	const afterClear = stdout.get();
-
-	t.is(afterClear, ansiEscapes.eraseLines(0) + 'Line 1\n'); // Should do a fresh write
-});
-
-test('incremental rendering - done() resets before next render', t => {
-	const stdout = createStdout();
-	const render = logUpdate.create(stdout, {incremental: true});
-
-	render('Line 1\nLine 2\nLine 3');
-	render.done();
-	render('Line 1');
-
-	const afterDone = stdout.get();
-
-	t.is(afterDone, ansiEscapes.eraseLines(0) + 'Line 1\n'); // Should do a fresh write
-});
-
-test('incremental rendering - multiple consecutive clear() calls (should be harmless no-ops)', t => {
-	const stdout = createStdout();
-	const render = logUpdate.create(stdout, {incremental: true});
-
-	render('Line 1\nLine 2\nLine 3');
-	render.clear();
-	render.clear();
-	render.clear();
-
-	t.is((stdout.write as any).callCount, 4); // Initial render + 3 clears (each writes eraseLines)
-
-	// Verify state is properly reset after multiple clears
-	render('New content');
-	const afterClears = stdout.get();
-	t.is(afterClears, ansiEscapes.eraseLines(0) + 'New content\n'); // Should do a fresh write
-});
-
-test('incremental rendering - sync() followed by update (assert incremental path is used)', t => {
-	const stdout = createStdout();
-	const render = logUpdate.create(stdout, {incremental: true});
-
-	render.sync('Line 1\nLine 2\nLine 3');
-	t.is((stdout.write as any).callCount, 0); // The sync() call shouldn't write to stdout
-
-	render('Line 1\nUpdated\nLine 3');
-	t.is((stdout.write as any).callCount, 1);
-
-	const firstCall = (stdout.write as any).firstCall.args[0] as string;
-	t.true(firstCall.includes(ansiEscapes.cursorNextLine)); // Skips unchanged lines
-	t.true(firstCall.includes('Updated')); // Only updates changed line
-	t.false(firstCall.includes('Line 1')); // Doesn't rewrite unchanged
-	t.false(firstCall.includes('Line 3')); // Doesn't rewrite unchanged
-});
-
-test('incremental rendering - render to empty string (full clear vs early exit)', t => {
-	const stdout = createStdout();
-	const render = logUpdate.create(stdout, {incremental: true});
-
-	render('Line 1\nLine 2\nLine 3');
-	render('');
-
-	t.is((stdout.write as any).callCount, 2);
-	const secondCall = (stdout.write as any).secondCall.args[0] as string;
-	t.is(secondCall, ansiEscapes.eraseLines(4) + '\n'); // Erases all 4 lines + writes single newline
-
-	// Rendering empty string again should be skipped (identical output)
-	render('');
-	t.is((stdout.write as any).callCount, 2); // No additional write
-});
diff --git a/test/render.tsx b/test/render.tsx
index f8362e0..9493004 100644
--- a/test/render.tsx
+++ b/test/render.tsx
@@ -125,28 +125,10 @@ test.serial('erase screen where state changes', async t => {
 	const ps = term('erase-with-state-change', ['4']);
 	await ps.waitForExit();
 
-	// The final frame is between the last eraseLines sequence and cursorShow
-	// Split on cursorShow to isolate the final rendered content before the cursor is shown
-	const beforeCursorShow = ps.output.split(ansiEscapes.cursorShow)[0];
-	if (!beforeCursorShow) {
-		t.fail('beforeCursorShow is undefined');
-		return;
-	}
-
-	// Find the last occurrence of an eraseLines sequence
-	// eraseLines(1) is the minimal erase pattern used by Ink
-	const eraseLinesPattern = ansiEscapes.eraseLines(1);
-	const lastEraseIndex = beforeCursorShow.lastIndexOf(eraseLinesPattern);
-
-	const lastFrame =
-		lastEraseIndex === -1
-			? beforeCursorShow
-			: beforeCursorShow.slice(lastEraseIndex + eraseLinesPattern.length);
-
-	const lastFrameContent = stripAnsi(lastFrame);
+	const secondFrame = ps.output.split(ansiEscapes.eraseLines(3))[1];
 
 	for (const letter of ['A', 'B', 'C']) {
-		t.false(lastFrameContent.includes(letter));
+		t.false(secondFrame?.includes(letter));
 	}
 });
 
