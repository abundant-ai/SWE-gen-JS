diff --git a/README.md b/README.md
index c6a7925..11a1cc3 100644
--- a/README.md
+++ b/README.md
@@ -340,7 +340,7 @@ SchemaDescription {
   type: string,
   label: string,
   meta: object,
-  tests: Array<string>
+  tests: Array<{ name: string, params: object }>
 }
 ```
 
@@ -609,21 +609,20 @@ You can also specify more than one dependent key, in which case each value will
 
 ```javascript
 var inst = yup.object({
-      isSpecial: yup.bool(),
-      isBig: yup.bool(),
-      count: yup.number()
-        .when(['isBig', 'isSpecial'], {
-          is: true,  // alternatively: (isBig, isSpecial) => isBig && isSpecial
-          then:      yup.number().min(5),
-          otherwise: yup.number().min(0)
-        })
-    })
+  isSpecial: yup.bool(),
+  isBig: yup.bool(),
+  count: yup.number().when(['isBig', 'isSpecial'], {
+    is: true, // alternatively: (isBig, isSpecial) => isBig && isSpecial
+    then: yup.number().min(5),
+    otherwise: yup.number().min(0),
+  }),
+});
 
 inst.validate({
   isBig: true,
   isSpecial: true,
-  count: 10
-})
+  count: 10,
+});
 ```
 
 Alternatively you can provide a function that returns a schema
@@ -712,6 +711,7 @@ If an exclusive test is added to a schema with non-exclusive tests of the same n
 the previous tests are removed and further tests of the same name will replace each other.
 
 ```javascript
+var max = 64;
 var schema = yup.mixed().test({
   name: 'max',
   exclusive: true,
diff --git a/src/mixed.js b/src/mixed.js
index ec166b8..ac45454 100644
--- a/src/mixed.js
+++ b/src/mixed.js
@@ -123,7 +123,7 @@ const proto = (SchemaType.prototype = {
     // manually add the new tests to ensure
     // the deduping logic is consistent
     schema.tests.forEach(fn => {
-      next = next.test(fn.TEST);
+      next = next.test(fn.OPTIONS);
     });
 
     next._type = schema._type;
@@ -311,7 +311,7 @@ const proto = (SchemaType.prototype = {
 
   notRequired() {
     var next = this.clone();
-    next.tests = next.tests.filter(test => test.TEST_NAME !== 'required');
+    next.tests = next.tests.filter(test => test.OPTIONS.name !== 'required');
     return next;
   },
 
@@ -369,9 +369,9 @@ const proto = (SchemaType.prototype = {
     next._exclusive[opts.name] = !!opts.exclusive;
 
     next.tests = next.tests.filter(fn => {
-      if (fn.TEST_NAME === opts.name) {
+      if (fn.OPTIONS.name === opts.name) {
         if (isExclusive) return false;
-        if (fn.TEST.test === validate.TEST.test) return false;
+        if (fn.OPTIONS.test === validate.OPTIONS.test) return false;
       }
       return true;
     });
@@ -477,15 +477,17 @@ const proto = (SchemaType.prototype = {
   },
 
   describe() {
-    let next = this.clone();
+    const next = this.clone();
 
     return {
       type: next._type,
       meta: next._meta,
       label: next._label,
       tests: next.tests
-        .map(fn => fn.TEST_NAME, {})
-        .filter((n, idx, list) => list.indexOf(n) === idx),
+        .map(fn => ({ name: fn.OPTIONS.name, params: fn.OPTIONS.params }))
+        .filter(
+          (n, idx, list) => list.findIndex(c => c.name === n.name) === idx,
+        ),
     };
   },
 });
diff --git a/src/util/createValidation.js b/src/util/createValidation.js
index 48f23de..062cfe4 100644
--- a/src/util/createValidation.js
+++ b/src/util/createValidation.js
@@ -92,9 +92,7 @@ export default function createValidation(options) {
     });
   }
 
-  validate.TEST_NAME = name;
-  validate.TEST_FN = test;
-  validate.TEST = options;
+  validate.OPTIONS = options;
 
   return validate;
 }
