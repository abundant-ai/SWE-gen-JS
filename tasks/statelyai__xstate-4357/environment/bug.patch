diff --git a/.changeset/grumpy-shrimps-draw.md b/.changeset/grumpy-shrimps-draw.md
deleted file mode 100644
index 2d5e264fe6..0000000000
--- a/.changeset/grumpy-shrimps-draw.md
+++ /dev/null
@@ -1,5 +0,0 @@
----
-'xstate': patch
----
-
-Fixed an issue with not all actions of initial transitions resolving to the initial state of the machine itself being executed.
diff --git a/packages/core/src/StateMachine.ts b/packages/core/src/StateMachine.ts
index 9dc73d7447..e181a78137 100644
--- a/packages/core/src/StateMachine.ts
+++ b/packages/core/src/StateMachine.ts
@@ -15,8 +15,7 @@ import {
   resolveActionsAndContext,
   resolveStateValue,
   transitionNode,
-  isAtomicStateNode,
-  getInitialStateNodes
+  isAtomicStateNode
 } from './stateUtils.ts';
 import type {
   AreAllImplementationsAssumedToBeProvided,
@@ -456,7 +455,7 @@ export class StateMachine<
     const nextState = microstep(
       [
         {
-          target: [...getInitialStateNodes(this.root)],
+          target: [...preInitialState.configuration].filter(isAtomicStateNode),
           source: this.root,
           reenter: true,
           actions: [],
diff --git a/packages/core/src/stateUtils.ts b/packages/core/src/stateUtils.ts
index 11d25d7991..cb9fea5d22 100644
--- a/packages/core/src/stateUtils.ts
+++ b/packages/core/src/stateUtils.ts
@@ -126,9 +126,7 @@ export function getConfiguration(
   for (const s of configuration) {
     // if previously active, add existing child nodes
     if (s.type === 'compound' && (!adjList.get(s) || !adjList.get(s)!.length)) {
-      getInitialStateNodesWithTheirAncestors(s).forEach((sn) =>
-        configurationSet.add(sn)
-      );
+      getInitialStateNodes(s).forEach((sn) => configurationSet.add(sn));
     } else {
       if (s.type === 'parallel') {
         for (const child of getChildren(s)) {
@@ -137,8 +135,7 @@ export function getConfiguration(
           }
 
           if (!configurationSet.has(child)) {
-            const initialStates = getInitialStateNodesWithTheirAncestors(child);
-            for (const initialStateNode of initialStates) {
+            for (const initialStateNode of getInitialStateNodes(child)) {
               configurationSet.add(initialStateNode);
             }
           }
@@ -597,19 +594,9 @@ function isHistoryNode(
   return stateNode.type === 'history';
 }
 
-export function getInitialStateNodesWithTheirAncestors(
+export function getInitialStateNodes(
   stateNode: AnyStateNode
-) {
-  const states = getInitialStateNodes(stateNode);
-  for (const initialState of states) {
-    for (const ancestor of getProperAncestors(initialState, stateNode)) {
-      states.add(ancestor);
-    }
-  }
-  return states;
-}
-
-export function getInitialStateNodes(stateNode: AnyStateNode) {
+): Array<AnyStateNode> {
   const set = new Set<AnyStateNode>();
 
   function iter(descStateNode: AnyStateNode): void {
@@ -619,6 +606,10 @@ export function getInitialStateNodes(stateNode: AnyStateNode) {
     set.add(descStateNode);
     if (descStateNode.type === 'compound') {
       for (const targetStateNode of descStateNode.initial.target) {
+        for (const a of getProperAncestors(targetStateNode, stateNode)) {
+          set.add(a);
+        }
+
         iter(targetStateNode);
       }
     } else if (descStateNode.type === 'parallel') {
@@ -630,7 +621,7 @@ export function getInitialStateNodes(stateNode: AnyStateNode) {
 
   iter(stateNode);
 
-  return set;
+  return [...set];
 }
 /**
  * Returns the child state node from its relative `stateKey`, or throws.
diff --git a/packages/core/test/actions.test.ts b/packages/core/test/actions.test.ts
index 9b9a1a6a25..8e8b55e3db 100644
--- a/packages/core/test/actions.test.ts
+++ b/packages/core/test/actions.test.ts
@@ -2170,40 +2170,6 @@ describe('initial actions', () => {
       ]
     `);
   });
-
-  it('should execute actions of all initial transitions resolving to the initial state value', () => {
-    const spy = jest.fn();
-    const machine = createMachine({
-      initial: {
-        target: 'a',
-        actions: () => spy('root')
-      },
-      states: {
-        a: {
-          initial: {
-            target: 'a1',
-            actions: () => spy('inner')
-          },
-          states: {
-            a1: {}
-          }
-        }
-      }
-    });
-
-    createActor(machine).start();
-
-    expect(spy.mock.calls).toMatchInlineSnapshot(`
-      [
-        [
-          "root",
-        ],
-        [
-          "inner",
-        ],
-      ]
-    `);
-  });
 });
 
 describe('actions on invalid transition', () => {
