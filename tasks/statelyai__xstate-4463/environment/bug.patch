diff --git a/.changeset/grumpy-eggs-drum.md b/.changeset/grumpy-eggs-drum.md
deleted file mode 100644
index 19e1c0abdd..0000000000
--- a/.changeset/grumpy-eggs-drum.md
+++ /dev/null
@@ -1,5 +0,0 @@
----
-'xstate': patch
----
-
-`invoke` and `spawn` will now require `input` to be provided if the used actor requires it.
diff --git a/packages/core/src/actions/spawn.ts b/packages/core/src/actions/spawn.ts
index e7d785d1b4..dd411ff904 100644
--- a/packages/core/src/actions/spawn.ts
+++ b/packages/core/src/actions/spawn.ts
@@ -17,10 +17,7 @@ import {
   IsLiteralString,
   InputFrom,
   UnifiedArg,
-  Mapper,
-  RequiredActorOptions,
-  ConditionalRequired,
-  IsNotNever
+  Mapper
 } from '../types.ts';
 import { resolveReferencedActor } from '../utils.ts';
 
@@ -138,40 +135,40 @@ export interface SpawnAction<
   _out_TActor?: TActor;
 }
 
-interface SpawnActionOptions<
-  TContext extends MachineContext,
-  TExpressionEvent extends EventObject,
-  TEvent extends EventObject,
-  TActor extends ProvidedActor
-> {
-  id?: ResolvableActorId<TContext, TExpressionEvent, TEvent, TActor['id']>;
-  systemId?: string;
-  input?:
-    | Mapper<TContext, TEvent, InputFrom<TActor['logic']>, TEvent>
-    | InputFrom<TActor['logic']>;
-  syncSnapshot?: boolean;
-}
-
 type DistributeActors<
   TContext extends MachineContext,
   TExpressionEvent extends EventObject,
   TEvent extends EventObject,
   TActor extends ProvidedActor
 > = TActor extends any
-  ? ConditionalRequired<
-      [
+  ? 'id' extends keyof TActor
+    ? [
+        src: TActor['src'],
+        options: {
+          id: ResolvableActorId<
+            TContext,
+            TExpressionEvent,
+            TEvent,
+            TActor['id']
+          >;
+          systemId?: string;
+          input?:
+            | Mapper<TContext, TEvent, InputFrom<TActor['logic']>, TEvent>
+            | InputFrom<TActor['logic']>;
+          syncSnapshot?: boolean;
+        }
+      ]
+    : [
         src: TActor['src'],
-        options?: SpawnActionOptions<
-          TContext,
-          TExpressionEvent,
-          TEvent,
-          TActor
-        > & {
-          [K in RequiredActorOptions<TActor>]: unknown;
+        options?: {
+          id?: ResolvableActorId<TContext, TExpressionEvent, TEvent, string>;
+          systemId?: string;
+          input?:
+            | Mapper<TContext, TEvent, InputFrom<TActor['logic']>, TEvent>
+            | InputFrom<TActor['logic']>;
+          syncSnapshot?: boolean;
         }
-      ],
-      IsNotNever<RequiredActorOptions<TActor>>
-    >
+      ]
   : never;
 
 type SpawnArguments<
diff --git a/packages/core/src/spawn.ts b/packages/core/src/spawn.ts
index 550d4cca73..d28004703b 100644
--- a/packages/core/src/spawn.ts
+++ b/packages/core/src/spawn.ts
@@ -11,30 +11,33 @@ import {
   IsLiteralString,
   ProvidedActor,
   Snapshot,
-  TODO,
-  RequiredActorOptions,
-  IsNotNever,
-  ConditionalRequired
+  TODO
 } from './types.ts';
 import { resolveReferencedActor } from './utils.ts';
 
-type SpawnOptions<
+export type SpawnOptions<
   TActor extends ProvidedActor,
   TSrc extends TActor['src']
 > = TActor extends {
   src: TSrc;
 }
-  ? ConditionalRequired<
-      [
+  ? 'id' extends keyof TActor
+    ? [
+        options: {
+          id: TActor['id'];
+          systemId?: string;
+          input?: InputFrom<TActor['logic']>;
+          syncSnapshot?: boolean;
+        }
+      ]
+    : [
         options?: {
-          id?: TActor['id'];
+          id?: string;
           systemId?: string;
           input?: InputFrom<TActor['logic']>;
           syncSnapshot?: boolean;
-        } & { [K in RequiredActorOptions<TActor>]: unknown }
-      ],
-      IsNotNever<RequiredActorOptions<TActor>>
-    >
+        }
+      ]
   : never;
 
 export type Spawner<TActor extends ProvidedActor> = IsLiteralString<
diff --git a/packages/core/src/types.ts b/packages/core/src/types.ts
index b17636535e..1962cd990f 100644
--- a/packages/core/src/types.ts
+++ b/packages/core/src/types.ts
@@ -46,7 +46,6 @@ type ReturnTypeOrValue<T> = T extends AnyFunction ? ReturnType<T> : T;
 
 // https://github.com/microsoft/TypeScript/issues/23182#issuecomment-379091887
 export type IsNever<T> = [T] extends [never] ? true : false;
-export type IsNotNever<T> = [T] extends [never] ? false : true;
 
 export type Compute<A extends any> = { [K in keyof A]: A[K] } & unknown;
 export type Prop<T, K> = K extends keyof T ? T[K] : never;
@@ -191,10 +190,9 @@ export type NoRequiredParams<T extends ParameterizedObject> = T extends any
     : never
   : never;
 
-export type ConditionalRequired<
-  T,
-  Condition extends boolean
-> = Condition extends true ? Required<T> : T;
+type ConditionalRequired<T, Condition extends boolean> = Condition extends true
+  ? Required<T>
+  : T;
 
 export type WithDynamicParams<
   TContext extends MachineContext,
@@ -572,12 +570,6 @@ type DistributeActors<
          */
         src: TSrc;
 
-        /**
-         * The unique identifier for the invoked machine. If not specified, this
-         * will be the machine's own `id`, or the URL (from `src`).
-         */
-        id?: TSpecificActor['id'];
-
         // TODO: currently we do not enforce required inputs here
         // in a sense, we shouldn't - they could be provided within the `implementations` object
         // how do we verify if the required input has been provided?
@@ -630,7 +622,21 @@ type DistributeActors<
                 TDelay
               >
             >;
-      } & { [K in RequiredActorOptions<TSpecificActor>]: unknown }
+      } & (TSpecificActor['id'] extends string
+        ? {
+            /**
+             * The unique identifier for the invoked machine. If not specified, this
+             * will be the machine's own `id`, or the URL (from `src`).
+             */
+            id: TSpecificActor['id'];
+          }
+        : {
+            /**
+             * The unique identifier for the invoked machine. If not specified, this
+             * will be the machine's own `id`, or the URL (from `src`).
+             */
+            id?: string;
+          })
     >
   : never;
 
@@ -2266,7 +2272,3 @@ export interface ActorSystem<T extends ActorSystemInfo> {
 }
 
 export type AnyActorSystem = ActorSystem<any>;
-
-export type RequiredActorOptions<TActor extends ProvidedActor> =
-  | ('id' extends keyof TActor ? 'id' : never)
-  | (undefined extends InputFrom<TActor['logic']> ? never : 'input');
diff --git a/packages/core/test/types.test.ts b/packages/core/test/types.test.ts
index 957934e8b2..4f20645dab 100644
--- a/packages/core/test/types.test.ts
+++ b/packages/core/test/types.test.ts
@@ -1055,38 +1055,6 @@ describe('spawn action', () => {
         })
     });
   });
-
-  it(`should require input to be specified when it is required`, () => {
-    const child = fromPromise(({}: { input: number }) => Promise.resolve(100));
-
-    createMachine({
-      types: {} as {
-        actors: {
-          src: 'child';
-          logic: typeof child;
-        };
-      },
-      entry:
-        // @ts-expect-error
-        spawn('child')
-    });
-  });
-
-  it(`should not require input when it's optional`, () => {
-    const child = fromPromise(({}: { input: number | undefined }) =>
-      Promise.resolve(100)
-    );
-
-    createMachine({
-      types: {} as {
-        actors: {
-          src: 'child';
-          logic: typeof child;
-        };
-      },
-      entry: spawn('child')
-    });
-  });
 });
 
 describe('spawner in assign', () => {
@@ -1432,43 +1400,6 @@ describe('spawner in assign', () => {
       })
     });
   });
-
-  it(`should require input to be specified when it is required`, () => {
-    const child = fromPromise(({}: { input: number }) => Promise.resolve(100));
-
-    createMachine({
-      types: {} as {
-        actors: {
-          src: 'child';
-          logic: typeof child;
-        };
-      },
-      entry: assign(({ spawn }) => {
-        // @ts-expect-error
-        spawn('child');
-        return {};
-      })
-    });
-  });
-
-  it(`should not require input when it's optional`, () => {
-    const child = fromPromise(({}: { input: number | undefined }) =>
-      Promise.resolve(100)
-    );
-
-    createMachine({
-      types: {} as {
-        actors: {
-          src: 'child';
-          logic: typeof child;
-        };
-      },
-      entry: assign(({ spawn }) => {
-        spawn('child');
-        return {};
-      })
-    });
-  });
 });
 
 describe('invoke', () => {
@@ -1823,41 +1754,6 @@ describe('invoke', () => {
     noop(machine);
     expect(true).toBeTruthy();
   });
-
-  it(`should require input to be specified when it is required`, () => {
-    const child = fromPromise(({}: { input: number }) => Promise.resolve(100));
-
-    createMachine({
-      types: {} as {
-        actors: {
-          src: 'child';
-          logic: typeof child;
-        };
-      },
-      // @ts-expect-error
-      invoke: {
-        src: 'child'
-      }
-    });
-  });
-
-  it(`should not require input when it's optional`, () => {
-    const child = fromPromise(({}: { input: number | undefined }) =>
-      Promise.resolve(100)
-    );
-
-    createMachine({
-      types: {} as {
-        actors: {
-          src: 'child';
-          logic: typeof child;
-        };
-      },
-      invoke: {
-        src: 'child'
-      }
-    });
-  });
 });
 
 describe('actor implementations', () => {
