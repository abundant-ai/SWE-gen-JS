diff --git a/.changeset/grumpy-garlics-unite.md b/.changeset/grumpy-garlics-unite.md
new file mode 100644
index 0000000000..83d5af920a
--- /dev/null
+++ b/.changeset/grumpy-garlics-unite.md
@@ -0,0 +1,5 @@
+---
+"@biomejs/biome": patch
+---
+
+Fixed [#8678](https://github.com/biomejs/biome/issues/8678). Now Biome correctly parses components inside Vue, Svelte and Astro files when they have the same name of self-closing elements.
diff --git a/crates/biome_html_parser/src/parser.rs b/crates/biome_html_parser/src/parser.rs
index 537fa476da..0719e8c3dc 100644
--- a/crates/biome_html_parser/src/parser.rs
+++ b/crates/biome_html_parser/src/parser.rs
@@ -109,6 +109,7 @@ pub struct HtmlParseOptions {
     pub(crate) frontmatter: bool,
     pub(crate) text_expression: Option<TextExpressionKind>,
     pub(crate) vue: bool,
+    pub(crate) is_html: bool,
 }
 
 impl HtmlParseOptions {
@@ -143,6 +144,10 @@ impl HtmlParseOptions {
         self.vue = true;
         self
     }
+
+    pub fn is_html(&self) -> bool {
+        self.is_html
+    }
 }
 
 impl From<&HtmlFileSource> for HtmlParseOptions {
@@ -157,7 +162,7 @@ impl From<&HtmlFileSource> for HtmlParseOptions {
                 HtmlTextExpressions::Double => {
                     options = options.with_double_text_expression();
                 }
-                HtmlTextExpressions::None => {}
+                HtmlTextExpressions::None => options.is_html = true,
             },
             HtmlVariant::Astro => {
                 options = options.with_single_text_expression().with_frontmatter();
diff --git a/crates/biome_html_parser/src/syntax/mod.rs b/crates/biome_html_parser/src/syntax/mod.rs
index 1da85f760b..b581da7828 100644
--- a/crates/biome_html_parser/src/syntax/mod.rs
+++ b/crates/biome_html_parser/src/syntax/mod.rs
@@ -138,6 +138,14 @@ fn inside_tag_context(p: &HtmlParser) -> HtmlLexContext {
     }
 }
 
+fn is_possible_component(p: &HtmlParser, tag_name: &str) -> bool {
+    tag_name
+        .chars()
+        .next()
+        .is_some_and(|c| c.is_ascii_uppercase())
+        && !p.options().is_html()
+}
+
 fn parse_element(p: &mut HtmlParser) -> ParsedSyntax {
     if !p.at(T![<]) {
         return Absent;
@@ -148,7 +156,8 @@ fn parse_element(p: &mut HtmlParser) -> ParsedSyntax {
     let opening_tag_name = p.cur_text().to_string();
     let should_be_self_closing = VOID_ELEMENTS
         .iter()
-        .any(|tag| tag.eq_ignore_ascii_case(opening_tag_name.as_str()));
+        .any(|tag| tag.eq_ignore_ascii_case(opening_tag_name.as_str()))
+        && !is_possible_component(p, opening_tag_name.as_str());
     let is_embedded_language_tag = EMBEDDED_LANGUAGE_ELEMENTS
         .iter()
         .any(|tag| tag.eq_ignore_ascii_case(opening_tag_name.as_str()));
@@ -229,7 +238,8 @@ fn parse_closing_tag(p: &mut HtmlParser) -> ParsedSyntax {
     p.bump_with_context(T![/], HtmlLexContext::InsideTag);
     let should_be_self_closing = VOID_ELEMENTS
         .iter()
-        .any(|tag| tag.eq_ignore_ascii_case(p.cur_text()));
+        .any(|tag| tag.eq_ignore_ascii_case(p.cur_text()))
+        && !is_possible_component(p, p.cur_text());
     if should_be_self_closing {
         p.error(void_element_should_not_have_closing_tag(p, p.cur_range()).into_diagnostic(p));
     }
