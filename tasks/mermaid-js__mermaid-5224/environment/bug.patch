diff --git a/cypress/integration/rendering/gantt.spec.js b/cypress/integration/rendering/gantt.spec.js
index 756611008..4abde9d44 100644
--- a/cypress/integration/rendering/gantt.spec.js
+++ b/cypress/integration/rendering/gantt.spec.js
@@ -92,31 +92,6 @@ describe('Gantt diagram', () => {
       {}
     );
   });
-  it('should handle multiple dependencies syntax with after and until', () => {
-    imgSnapshotTest(
-      `
-      gantt
-      dateFormat  YYYY-MM-DD
-      axisFormat  %d/%m
-      title Adding GANTT diagram to mermaid
-      excludes weekdays 2014-01-10
-      todayMarker off
-  
-      section team's critical event
-      deadline A           :milestone, crit, deadlineA, 2024-02-01, 0
-      deadline B           :milestone, crit, deadlineB, 2024-02-15, 0
-      boss on leave        :bossaway, 2024-01-28, 2024-02-11
-  
-      section new intern
-      onboarding           :onboarding, 2024-01-02, 1w
-      literature review    :litreview, 2024-01-02, 10d
-      project A            :projectA, after onboarding litreview, until deadlineA bossaway
-      chilling             :chilling, after projectA, until deadlineA
-      project B            :projectB, after deadlineA, until deadlineB
-      `,
-      {}
-    );
-  });
   it('should FAIL redering a gantt chart for issue #1060 with invalid date', () => {
     imgSnapshotTest(
       `
diff --git a/docs/syntax/gantt.md b/docs/syntax/gantt.md
index d1a13c6fa..c96de3f3f 100644
--- a/docs/syntax/gantt.md
+++ b/docs/syntax/gantt.md
@@ -67,8 +67,8 @@ gantt
     Create tests for parser             :crit, active, 3d
     Future task in critical line        :crit, 5d
     Create tests for renderer           :2d
-    Add to mermaid                      :until isadded
-    Functionality added                 :milestone, isadded, 2014-01-25, 0d
+    Add to mermaid                      :1d
+    Functionality added                 :milestone, 2014-01-25, 0d
 
     section Documentation
     Describe gantt syntax               :active, a1, after des1, 3d
@@ -100,8 +100,8 @@ gantt
     Create tests for parser             :crit, active, 3d
     Future task in critical line        :crit, 5d
     Create tests for renderer           :2d
-    Add to mermaid                      :until isadded
-    Functionality added                 :milestone, isadded, 2014-01-25, 0d
+    Add to mermaid                      :1d
+    Functionality added                 :milestone, 2014-01-25, 0d
 
     section Documentation
     Describe gantt syntax               :active, a1, after des1, 3d
@@ -124,26 +124,18 @@ After processing the tags, the remaining metadata items are interpreted as follo
 2.  If two items are specified, the last item is interpreted as in the previous case. The first item can either specify an explicit start date/time (in the format specified by `dateFormat`) or reference another task using `after <otherTaskID> [[otherTaskID2 [otherTaskID3]]...]`. In the latter case, the start date of the task will be set according to the latest end date of any referenced task.
 3.  If three items are specified, the last two will be interpreted as in the previous case. The first item will denote the ID of the task, which can be referenced using the `later <taskID>` syntax.
 
-| Metadata syntax                                      | Start date                                          | End date                                              | ID       |
-| ---------------------------------------------------- | --------------------------------------------------- | ----------------------------------------------------- | -------- |
-| `<taskID>, <startDate>, <endDate>`                   | `startdate` as interpreted using `dateformat`       | `endDate` as interpreted using `dateformat`           | `taskID` |
-| `<taskID>, <startDate>, <length>`                    | `startdate` as interpreted using `dateformat`       | Start date + `length`                                 | `taskID` |
-| `<taskID>, after <otherTaskId>, <endDate>`           | End date of previously specified task `otherTaskID` | `endDate` as interpreted using `dateformat`           | `taskID` |
-| `<taskID>, after <otherTaskId>, <length>`            | End date of previously specified task `otherTaskID` | Start date + `length`                                 | `taskID` |
-| `<taskID>, <startDate>, until <otherTaskId>`         | `startdate` as interpreted using `dateformat`       | Start date of previously specified task `otherTaskID` | `taskID` |
-| `<taskID>, after <otherTaskId>, until <otherTaskId>` | End date of previously specified task `otherTaskID` | Start date of previously specified task `otherTaskID` | `taskID` |
-| `<startDate>, <endDate>`                             | `startdate` as interpreted using `dateformat`       | `enddate` as interpreted using `dateformat`           | n/a      |
-| `<startDate>, <length>`                              | `startdate` as interpreted using `dateformat`       | Start date + `length`                                 | n/a      |
-| `after <otherTaskID>, <endDate>`                     | End date of previously specified task `otherTaskID` | `enddate` as interpreted using `dateformat`           | n/a      |
-| `after <otherTaskID>, <length>`                      | End date of previously specified task `otherTaskID` | Start date + `length`                                 | n/a      |
-| `<startDate>, until <otherTaskId>`                   | `startdate` as interpreted using `dateformat`       | Start date of previously specified task `otherTaskID` | n/a      |
-| `after <otherTaskId>, until <otherTaskId>`           | End date of previously specified task `otherTaskID` | Start date of previously specified task `otherTaskID` | n/a      |
-| `<endDate>`                                          | End date of preceding task                          | `enddate` as interpreted using `dateformat`           | n/a      |
-| `<length>`                                           | End date of preceding task                          | Start date + `length`                                 | n/a      |
-| `until <otherTaskId>`                                | End date of preceding task                          | Start date of previously specified task `otherTaskID` | n/a      |
-
-> **Note**
-> Support for keyword `until` was added in (v\<MERMAID_RELEASE_VERSION>+). This can be used to define a task which is running until some other specific task or milestone starts.
+| Metadata syntax                            | Start date                                          | End date                                    | ID       |
+| ------------------------------------------ | --------------------------------------------------- | ------------------------------------------- | -------- |
+| `<taskID>, <startDate>, <endDate>`         | `startdate` as interpreted using `dateformat`       | `endDate` as interpreted using `dateformat` | `taskID` |
+| `<taskID>, <startDate>, <length>`          | `startdate` as interpreted using `dateformat`       | Start date + `length`                       | `taskID` |
+| `<taskID>, after <otherTaskId>, <endDate>` | End date of previously specified task `otherTaskID` | `endDate` as interpreted using `dateformat` | `taskID` |
+| `<taskID>, after <otherTaskId>, <length>`  | End date of previously specified task `otherTaskID` | Start date + `length`                       | `taskID` |
+| `<startDate>, <endDate>`                   | `startdate` as interpreted using `dateformat`       | `enddate` as interpreted using `dateformat` | n/a      |
+| `<startDate>, <length>`                    | `startdate` as interpreted using `dateformat`       | Start date + `length`                       | n/a      |
+| `after <otherTaskID>, <endDate>`           | End date of previously specified task `otherTaskID` | `enddate` as interpreted using `dateformat` | n/a      |
+| `after <otherTaskID>, <length>`            | End date of previously specified task `otherTaskID` | Start date + `length`                       | n/a      |
+| `<endDate>`                                | End date of preceding task                          | `enddate` as interpreted using `dateformat` | n/a      |
+| `<length>`                                 | End date of preceding task                          | Start date + `length`                       | n/a      |
 
 For simplicity, the table does not show the use of multiple tasks listed with the `after` keyword. Here is an example of how to use it and how it's interpreted:
 
@@ -152,7 +144,6 @@ gantt
     apple :a, 2017-07-20, 1w
     banana :crit, b, 2017-07-23, 1d
     cherry :active, c, after b a, 1d
-    kiwi   :d, 2017-07-20, until b c
 ```
 
 ```mermaid
@@ -160,7 +151,6 @@ gantt
     apple :a, 2017-07-20, 1w
     banana :crit, b, 2017-07-23, 1d
     cherry :active, c, after b a, 1d
-    kiwi   :d, 2017-07-20, until b c
 ```
 
 ### Title
@@ -559,5 +549,3 @@ gantt
     section Issue1300
     5    : 0, 5
 ```
-
-<!--- cspell:ignore isadded --->
diff --git a/packages/mermaid/src/diagrams/gantt/ganttDb.js b/packages/mermaid/src/diagrams/gantt/ganttDb.js
index b0058ff8d..86a2452e6 100644
--- a/packages/mermaid/src/diagrams/gantt/ganttDb.js
+++ b/packages/mermaid/src/diagrams/gantt/ganttDb.js
@@ -256,25 +256,32 @@ const getStartDate = function (prevTime, dateFormat, str) {
   str = str.trim();
 
   // Test for after
-  const afterRePattern = /^after\s+(?<ids>[\d\w- ]+)/;
-  const afterStatement = afterRePattern.exec(str);
+  const re = /^after\s+([\d\w- ]+)/;
+  const afterStatement = re.exec(str.trim());
 
   if (afterStatement !== null) {
     // check all after ids and take the latest
-    let latestTask = null;
-    for (const id of afterStatement.groups.ids.split(' ')) {
+    let latestEndingTask = null;
+    afterStatement[1].split(' ').forEach(function (id) {
       let task = findTaskById(id);
-      if (task !== undefined && (!latestTask || task.endTime > latestTask.endTime)) {
-        latestTask = task;
+      if (task !== undefined) {
+        if (!latestEndingTask) {
+          latestEndingTask = task;
+        } else {
+          if (task.endTime > latestEndingTask.endTime) {
+            latestEndingTask = task;
+          }
+        }
       }
-    }
+    });
 
-    if (latestTask) {
-      return latestTask.endTime;
+    if (!latestEndingTask) {
+      const dt = new Date();
+      dt.setHours(0, 0, 0, 0);
+      return dt;
+    } else {
+      return latestEndingTask.endTime;
     }
-    const today = new Date();
-    today.setHours(0, 0, 0, 0);
-    return today;
   }
 
   // Check for actual date set
@@ -337,35 +344,13 @@ const parseDuration = function (str) {
 const getEndDate = function (prevTime, dateFormat, str, inclusive = false) {
   str = str.trim();
 
-  // test for until
-  const untilRePattern = /^until\s+(?<ids>[\d\w- ]+)/;
-  const untilStatement = untilRePattern.exec(str);
-
-  if (untilStatement !== null) {
-    // check all until ids and take the earliest
-    let earliestTask = null;
-    for (const id of untilStatement.groups.ids.split(' ')) {
-      let task = findTaskById(id);
-      if (task !== undefined && (!earliestTask || task.startTime < earliestTask.startTime)) {
-        earliestTask = task;
-      }
-    }
-
-    if (earliestTask) {
-      return earliestTask.startTime;
-    }
-    const today = new Date();
-    today.setHours(0, 0, 0, 0);
-    return today;
-  }
-
-  // check for actual date
-  let parsedDate = dayjs(str, dateFormat.trim(), true);
-  if (parsedDate.isValid()) {
+  // Check for actual date
+  let mDate = dayjs(str, dateFormat.trim(), true);
+  if (mDate.isValid()) {
     if (inclusive) {
-      parsedDate = parsedDate.add(1, 'd');
+      mDate = mDate.add(1, 'd');
     }
-    return parsedDate.toDate();
+    return mDate.toDate();
   }
 
   let endTime = dayjs(prevTime);
diff --git a/packages/mermaid/src/diagrams/gantt/ganttDb.spec.ts b/packages/mermaid/src/diagrams/gantt/ganttDb.spec.ts
index 96aae0b89..416368e8f 100644
--- a/packages/mermaid/src/diagrams/gantt/ganttDb.spec.ts
+++ b/packages/mermaid/src/diagrams/gantt/ganttDb.spec.ts
@@ -140,10 +140,10 @@ describe('when using the ganttDb', function () {
 
   it('should handle relative start date based on id regardless of sections', function () {
     ganttDb.setDateFormat('YYYY-MM-DD');
-    ganttDb.addSection('sec1');
+    ganttDb.addSection('testa1');
     ganttDb.addTask('test1', 'id1,2013-01-01,2w');
     ganttDb.addTask('test2', 'id2,after id3,1d');
-    ganttDb.addSection('sec2');
+    ganttDb.addSection('testa2');
     ganttDb.addTask('test3', 'id3,after id1,2d');
 
     const tasks = ganttDb.getTasks();
@@ -158,58 +158,6 @@ describe('when using the ganttDb', function () {
     expect(tasks[2].startTime).toEqual(new Date(2013, 0, 15));
     expect(tasks[2].endTime).toEqual(new Date(2013, 0, 17));
   });
-
-  it('should handle relative end date based on id regardless of sections', function () {
-    ganttDb.setDateFormat('YYYY-MM-DD');
-    ganttDb.addSection('sec1');
-    ganttDb.addTask('task1', 'id1,2013-01-01,until id3');
-    ganttDb.addSection('sec2');
-    ganttDb.addTask('task2', 'id2,2013-01-10,until id3');
-    ganttDb.addTask('task3', 'id3,2013-02-01,2d');
-
-    const tasks = ganttDb.getTasks();
-
-    expect(tasks[0].startTime).toEqual(new Date(2013, 0, 1));
-    expect(tasks[0].endTime).toEqual(new Date(2013, 1, 1));
-    expect(tasks[0].id).toEqual('id1');
-    expect(tasks[0].task).toEqual('task1');
-
-    expect(tasks[1].id).toEqual('id2');
-    expect(tasks[1].task).toEqual('task2');
-    expect(tasks[1].startTime).toEqual(new Date(2013, 0, 10));
-    expect(tasks[1].endTime).toEqual(new Date(2013, 1, 1));
-  });
-
-  it('should handle relative start date based on multiple id', function () {
-    ganttDb.setDateFormat('YYYY-MM-DD');
-    ganttDb.addSection('sec1');
-    ganttDb.addTask('task1', 'id1,after id2 id3 id4,1d');
-    ganttDb.addTask('task2', 'id2,2013-01-01,1d');
-    ganttDb.addTask('task3', 'id3,2013-02-01,3d');
-    ganttDb.addTask('task4', 'id4,2013-02-01,2d');
-
-    const tasks = ganttDb.getTasks();
-
-    expect(tasks[0].endTime).toEqual(new Date(2013, 1, 5));
-    expect(tasks[0].id).toEqual('id1');
-    expect(tasks[0].task).toEqual('task1');
-  });
-
-  it('should handle relative end date based on multiple id', function () {
-    ganttDb.setDateFormat('YYYY-MM-DD');
-    ganttDb.addSection('sec1');
-    ganttDb.addTask('task1', 'id1,2013-01-01,until id2 id3 id4');
-    ganttDb.addTask('task2', 'id2,2013-01-11,1d');
-    ganttDb.addTask('task3', 'id3,2013-02-10,1d');
-    ganttDb.addTask('task4', 'id4,2013-02-12,1d');
-
-    const tasks = ganttDb.getTasks();
-
-    expect(tasks[0].endTime).toEqual(new Date(2013, 0, 11));
-    expect(tasks[0].id).toEqual('id1');
-    expect(tasks[0].task).toEqual('task1');
-  });
-
   it('should ignore weekends', function () {
     ganttDb.setDateFormat('YYYY-MM-DD');
     ganttDb.setExcludes('weekends 2019-02-06,friday');
diff --git a/packages/mermaid/src/diagrams/gantt/parser/gantt.spec.js b/packages/mermaid/src/diagrams/gantt/parser/gantt.spec.js
index 6665765a4..ae5f74249 100644
--- a/packages/mermaid/src/diagrams/gantt/parser/gantt.spec.js
+++ b/packages/mermaid/src/diagrams/gantt/parser/gantt.spec.js
@@ -118,38 +118,6 @@ describe('when parsing a gantt diagram it', function () {
     expect(tasks[0].id).toEqual('des1');
     expect(tasks[0].task).toEqual('Design jison grammar');
   });
-  it('should handle a task with start/end time relative to other tasks', function () {
-    const str =
-      'gantt\n' +
-      'dateFormat YYYY-MM-DD\n' +
-      'title Adding gantt diagram functionality to mermaid\n' +
-      'section Documentation\n' +
-      'task A: a, 2024-01-27, 2024-01-28\n' +
-      'task B: b, after a, 2024-01-30\n' +
-      'task C: c, 2024-01-20, until a\n' +
-      'task D: d, after c, until b';
-
-    expect(parserFnConstructor(str)).not.toThrow();
-
-    const tasks = parser.yy.getTasks();
-
-    expect(tasks[0].startTime).toEqual(new Date(2024, 0, 27));
-    expect(tasks[0].endTime).toEqual(new Date(2024, 0, 28));
-    expect(tasks[0].id).toEqual('a');
-    expect(tasks[0].task).toEqual('task A');
-    expect(tasks[1].startTime).toEqual(new Date(2024, 0, 28));
-    expect(tasks[1].endTime).toEqual(new Date(2024, 0, 30));
-    expect(tasks[1].id).toEqual('b');
-    expect(tasks[1].task).toEqual('task B');
-    expect(tasks[2].startTime).toEqual(new Date(2024, 0, 20));
-    expect(tasks[2].endTime).toEqual(new Date(2024, 0, 27));
-    expect(tasks[2].id).toEqual('c');
-    expect(tasks[2].task).toEqual('task C');
-    expect(tasks[3].startTime).toEqual(new Date(2024, 0, 27));
-    expect(tasks[3].endTime).toEqual(new Date(2024, 0, 28));
-    expect(tasks[3].id).toEqual('d');
-    expect(tasks[3].task).toEqual('task D');
-  });
   it.each(convert`
     tags                     | milestone | done     | crit     | active
     ${'milestone'}           | ${true}   | ${false} | ${false} | ${false}
diff --git a/packages/mermaid/src/docs/syntax/gantt.md b/packages/mermaid/src/docs/syntax/gantt.md
index a1139d378..15cdc6a09 100644
--- a/packages/mermaid/src/docs/syntax/gantt.md
+++ b/packages/mermaid/src/docs/syntax/gantt.md
@@ -49,8 +49,8 @@ gantt
     Create tests for parser             :crit, active, 3d
     Future task in critical line        :crit, 5d
     Create tests for renderer           :2d
-    Add to mermaid                      :until isadded
-    Functionality added                 :milestone, isadded, 2014-01-25, 0d
+    Add to mermaid                      :1d
+    Functionality added                 :milestone, 2014-01-25, 0d
 
     section Documentation
     Describe gantt syntax               :active, a1, after des1, 3d
@@ -73,27 +73,18 @@ After processing the tags, the remaining metadata items are interpreted as follo
 2. If two items are specified, the last item is interpreted as in the previous case. The first item can either specify an explicit start date/time (in the format specified by `dateFormat`) or reference another task using `after <otherTaskID> [[otherTaskID2 [otherTaskID3]]...]`. In the latter case, the start date of the task will be set according to the latest end date of any referenced task.
 3. If three items are specified, the last two will be interpreted as in the previous case. The first item will denote the ID of the task, which can be referenced using the `later <taskID>` syntax.
 
-| Metadata syntax                                      | Start date                                          | End date                                              | ID       |
-| ---------------------------------------------------- | --------------------------------------------------- | ----------------------------------------------------- | -------- |
-| `<taskID>, <startDate>, <endDate>`                   | `startdate` as interpreted using `dateformat`       | `endDate` as interpreted using `dateformat`           | `taskID` |
-| `<taskID>, <startDate>, <length>`                    | `startdate` as interpreted using `dateformat`       | Start date + `length`                                 | `taskID` |
-| `<taskID>, after <otherTaskId>, <endDate>`           | End date of previously specified task `otherTaskID` | `endDate` as interpreted using `dateformat`           | `taskID` |
-| `<taskID>, after <otherTaskId>, <length>`            | End date of previously specified task `otherTaskID` | Start date + `length`                                 | `taskID` |
-| `<taskID>, <startDate>, until <otherTaskId>`         | `startdate` as interpreted using `dateformat`       | Start date of previously specified task `otherTaskID` | `taskID` |
-| `<taskID>, after <otherTaskId>, until <otherTaskId>` | End date of previously specified task `otherTaskID` | Start date of previously specified task `otherTaskID` | `taskID` |
-| `<startDate>, <endDate>`                             | `startdate` as interpreted using `dateformat`       | `enddate` as interpreted using `dateformat`           | n/a      |
-| `<startDate>, <length>`                              | `startdate` as interpreted using `dateformat`       | Start date + `length`                                 | n/a      |
-| `after <otherTaskID>, <endDate>`                     | End date of previously specified task `otherTaskID` | `enddate` as interpreted using `dateformat`           | n/a      |
-| `after <otherTaskID>, <length>`                      | End date of previously specified task `otherTaskID` | Start date + `length`                                 | n/a      |
-| `<startDate>, until <otherTaskId>`                   | `startdate` as interpreted using `dateformat`       | Start date of previously specified task `otherTaskID` | n/a      |
-| `after <otherTaskId>, until <otherTaskId>`           | End date of previously specified task `otherTaskID` | Start date of previously specified task `otherTaskID` | n/a      |
-| `<endDate>`                                          | End date of preceding task                          | `enddate` as interpreted using `dateformat`           | n/a      |
-| `<length>`                                           | End date of preceding task                          | Start date + `length`                                 | n/a      |
-| `until <otherTaskId>`                                | End date of preceding task                          | Start date of previously specified task `otherTaskID` | n/a      |
-
-```note
-Support for keyword `until` was added in (v<MERMAID_RELEASE_VERSION>+). This can be used to define a task which is running until some other specific task or milestone starts.
-```
+| Metadata syntax                            | Start date                                          | End date                                    | ID       |
+| ------------------------------------------ | --------------------------------------------------- | ------------------------------------------- | -------- |
+| `<taskID>, <startDate>, <endDate>`         | `startdate` as interpreted using `dateformat`       | `endDate` as interpreted using `dateformat` | `taskID` |
+| `<taskID>, <startDate>, <length>`          | `startdate` as interpreted using `dateformat`       | Start date + `length`                       | `taskID` |
+| `<taskID>, after <otherTaskId>, <endDate>` | End date of previously specified task `otherTaskID` | `endDate` as interpreted using `dateformat` | `taskID` |
+| `<taskID>, after <otherTaskId>, <length>`  | End date of previously specified task `otherTaskID` | Start date + `length`                       | `taskID` |
+| `<startDate>, <endDate>`                   | `startdate` as interpreted using `dateformat`       | `enddate` as interpreted using `dateformat` | n/a      |
+| `<startDate>, <length>`                    | `startdate` as interpreted using `dateformat`       | Start date + `length`                       | n/a      |
+| `after <otherTaskID>, <endDate>`           | End date of previously specified task `otherTaskID` | `enddate` as interpreted using `dateformat` | n/a      |
+| `after <otherTaskID>, <length>`            | End date of previously specified task `otherTaskID` | Start date + `length`                       | n/a      |
+| `<endDate>`                                | End date of preceding task                          | `enddate` as interpreted using `dateformat` | n/a      |
+| `<length>`                                 | End date of preceding task                          | Start date + `length`                       | n/a      |
 
 For simplicity, the table does not show the use of multiple tasks listed with the `after` keyword. Here is an example of how to use it and how it's interpreted:
 
@@ -102,7 +93,6 @@ gantt
     apple :a, 2017-07-20, 1w
     banana :crit, b, 2017-07-23, 1d
     cherry :active, c, after b a, 1d
-    kiwi   :d, 2017-07-20, until b c
 ```
 
 ### Title
@@ -449,5 +439,3 @@ gantt
     section Issue1300
     5    : 0, 5
 ```
-
-<!--- cspell:ignore isadded --->
