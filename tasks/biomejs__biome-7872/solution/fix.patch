diff --git a/.changeset/odd-lizards-build.md b/.changeset/odd-lizards-build.md
new file mode 100644
index 0000000000..e87c5a1eb9
--- /dev/null
+++ b/.changeset/odd-lizards-build.md
@@ -0,0 +1,5 @@
+---
+"@biomejs/biome": patch
+---
+
+Fixed [#7861](https://github.com/biomejs/biome/issues/7861): The HTML parser will now accept Svelte attribute shorthand syntax in `.svelte` files.
diff --git a/AGENTS..md b/AGENTS..md
deleted file mode 120000
index eada936c1d..0000000000
--- a/AGENTS..md
+++ /dev/null
@@ -1 +0,0 @@
-CONTRIBUTING.md
\ No newline at end of file
diff --git a/CLAUDE.md b/CLAUDE.md
deleted file mode 120000
index eada936c1d..0000000000
--- a/CLAUDE.md
+++ /dev/null
@@ -1 +0,0 @@
-CONTRIBUTING.md
\ No newline at end of file
diff --git a/CLAUDE.md b/CLAUDE.md
new file mode 100644
index 0000000000..8ce8b8f0e2
--- /dev/null
+++ b/CLAUDE.md
@@ -0,0 +1,139 @@
+# CLAUDE.md
+
+This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.
+
+## Development Commands
+
+### Primary Commands (use Just task runner)
+
+```bash
+# Install required development tools
+just install-tools
+
+# Format code (Rust + TOML)
+just format
+
+# Run all tests
+just test
+
+# Run linting
+just lint
+
+# Check if ready for CI (comprehensive check)
+just ready
+
+# Generate all code-generated files
+just gen-all
+```
+
+### Cargo Commands
+
+```bash
+# Run Biome CLI in development mode
+cargo biome-cli-dev --help
+cargo biome-cli-dev check --write
+
+# Run tests for specific crate
+cargo test -p biome_html_formatter
+
+# Build in release mode
+cargo build --release
+```
+
+### Rule Development
+
+```bash
+# Create new lint rules (name must be camelCase)
+just new-js-lintrule ruleName
+just new-css-lintrule ruleName
+just new-json-lintrule ruleName
+just new-graphql-lintrule ruleName
+
+# Test specific lint rule
+just test-lintrule ruleName
+
+# Move rule from nursery to stable group
+just move-rule stable ruleName
+```
+
+## Architecture Overview
+
+**Biome** is a Rust-based monorepo implementing a high-performance web development toolchain. The architecture follows a modular, language-agnostic design.
+
+### Core Components
+
+- **biome_service**: Central workspace service providing unified APIs
+- **biome_rowan**: Lossless syntax tree foundation (preserves all source info)
+- **biome_formatter**: Pretty-printing infrastructure using intermediate representation
+- **biome_analyze**: Rule-based analysis framework with visitor patterns
+
+### Language Support Pattern
+
+Each language follows consistent crate structure:
+```
+biome_{lang}_syntax     # AST definitions
+biome_{lang}_parser     # Parser implementation
+biome_{lang}_formatter  # Formatting logic
+biome_{lang}_analyze    # Linting rules
+biome_{lang}_factory    # AST construction
+biome_{lang}_semantic   # Semantic analysis (where applicable)
+```
+
+Languages: JavaScript/TypeScript, CSS, JSON, HTML, GraphQL, Grit
+
+### Key Architectural Patterns
+
+1. **Grammar-Driven**: Uses `.ungram` files for AST generation
+2. **Code Generation**: Extensive use of `xtask/codegen` for consistency
+3. **Incremental**: Supports efficient re-parsing and re-analysis
+4. **Transport-Agnostic**: Service layer works with CLI, LSP, daemon
+5. **Capability-Based**: File handlers declare their supported operations
+
+### File Locations
+
+- Core crates: `/crates/biome_*/`
+- Grammar definitions: `/xtask/codegen/*.ungram`
+- Test snapshots: `tests/specs/` in each crate
+- Configuration: `biome_configuration/src/`
+
+### Testing Strategy
+
+- **Spec Tests**: Snapshot testing with `.snap` files (use `cargo insta`)
+- **Quick Tests**: `just test-quick package` for rapid iteration
+- **Prettier Compatibility**: Automated comparison tests
+- **Fuzz Testing**: In `/fuzz/` directory
+
+### Development Workflow
+
+1. Make changes to source code
+2. Run `just format` to format code
+3. Run `just gen-all` if modifying grammars or adding rules
+4. Run `just test` to verify changes
+5. Use `just ready` before submitting PR (runs all CI checks)
+
+### Working with Current Directory
+
+You are currently in `/crates/biome_html_formatter/` - the HTML formatter implementation. This crate:
+
+- Implements HTML/Astro/Svelte formatting
+- Follows the standard formatter architecture using `biome_formatter` IR
+- Has test files in `tests/` directory
+- Benchmark in `benches/html_formatter.rs`
+
+### Code Generation
+
+When adding new syntax nodes or rules:
+- Modify appropriate `.ungram` file in `xtask/codegen/`
+- Run `just gen-all` to regenerate code
+- Formatters, parsers, and AST definitions are auto-generated
+
+### Performance Notes
+
+- Uses arena allocation for memory efficiency
+- Implements incremental parsing/analysis
+- Zero-copy string handling where possible
+- All formatters use same IR for consistency
+
+### Additional Instructions to know how to work inside the project
+
+- General contribution instructions @CONTRIBUTING.md
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 9b0914ef2d..da6585a07a 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -5,7 +5,6 @@ We can use help in a bunch of areas and any help is greatly appreciated!
 ## Table of Contents
 
 - [ðŸš€ Contributing](#-contributing)
-  * [AI assistance notice](#ai-assistance-notice)
   * [Asking questions, making proposals](#asking-questions-making-proposals)
   * [Reporting bugs](#reporting-bugs)
   * [Getting Started](#getting-started)
@@ -44,30 +43,6 @@ We can use help in a bunch of areas and any help is greatly appreciated!
     + [Maintainers team](#maintainers-team)
     + [Past Maintainers](#past-maintainers)
 
-## AI assistance notice
-
-> [!IMPORTANT]
->
-> If you are using **any kind of AI assistance** to contribute to Biome,
-> it must be disclosed in the pull request.
-
-If you relied on AI assistance to make a pull request, you must disclose it in the
-pull request, together with the extent of the usage. For example, if you used
-AI to generate docs or tests, you must say it.
-An example disclosure:
-
-- > This PR was written primarily by Claude Code.
-- > I consulted ChatGPT to understand the codebase but the solution
-  > was fully authored manually by myself.
-
-Providing this information helps reviewers understand the context of the
-pull request and apply the right level of scrutiny, ensuring a smoother
-and more efficient review process.
-
-AI assistance isn't always perfect, even when used with the utmost care.
-
-Please be respectful to maintainers and disclose AI assistance.
-
 ## Asking questions, making proposals
 
 If you have any questions, proposals, or feedback, open a [GitHub discussion](https://github.com/biomejs/biome/discussions).
diff --git a/crates/biome_html_formatter/src/html/any/attribute.rs b/crates/biome_html_formatter/src/html/any/attribute.rs
index a52030c5a3..b1c6704f75 100644
--- a/crates/biome_html_formatter/src/html/any/attribute.rs
+++ b/crates/biome_html_formatter/src/html/any/attribute.rs
@@ -11,6 +11,7 @@ impl FormatRule<AnyHtmlAttribute> for FormatAnyHtmlAttribute {
             AnyHtmlAttribute::HtmlAttribute(node) => node.format().fmt(f),
             AnyHtmlAttribute::HtmlBogusAttribute(node) => node.format().fmt(f),
             AnyHtmlAttribute::HtmlDoubleTextExpression(node) => node.format().fmt(f),
+            AnyHtmlAttribute::HtmlSingleTextExpression(node) => node.format().fmt(f),
         }
     }
 }
diff --git a/crates/biome_html_formatter/src/html/lists/attribute_list.rs b/crates/biome_html_formatter/src/html/lists/attribute_list.rs
index 098e85b40a..26252d23f6 100644
--- a/crates/biome_html_formatter/src/html/lists/attribute_list.rs
+++ b/crates/biome_html_formatter/src/html/lists/attribute_list.rs
@@ -63,6 +63,9 @@ impl FormatRule<HtmlAttributeList> for FormatHtmlAttributeList {
                                     AnyHtmlAttribute::HtmlDoubleTextExpression(attr) => {
                                         attr.format().fmt(f)
                                     }
+                                    AnyHtmlAttribute::HtmlSingleTextExpression(attr) => {
+                                        attr.format().fmt(f)
+                                    }
                                     AnyHtmlAttribute::HtmlBogusAttribute(attr) => {
                                         attr.format().fmt(f)
                                     }
diff --git a/crates/biome_html_formatter/src/svelte/auxiliary/text_expression.rs b/crates/biome_html_formatter/src/svelte/auxiliary/text_expression.rs
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/crates/biome_html_parser/src/syntax/mod.rs b/crates/biome_html_parser/src/syntax/mod.rs
index 2b3e77be00..0a3654a825 100644
--- a/crates/biome_html_parser/src/syntax/mod.rs
+++ b/crates/biome_html_parser/src/syntax/mod.rs
@@ -312,6 +312,13 @@ fn parse_attribute(p: &mut HtmlParser) -> ParsedSyntax {
             .ok();
 
         Present(m.complete(p, HTML_ATTRIBUTE))
+    } else if p.at(T!['{']) {
+        m.abandon(p);
+        HtmlSyntaxFeatures::SingleTextExpressions.parse_exclusive_syntax(
+            p,
+            |p| parse_single_text_expression(p, HtmlLexContext::InsideTag),
+            |p: &HtmlParser<'_>, m: &CompletedMarker| disabled_svelte_prop(p, m.range(p)),
+        )
     } else {
         parse_literal(p, HTML_ATTRIBUTE_NAME).or_add_diagnostic(p, expected_attribute);
         if p.at(T![=]) {
@@ -324,7 +331,7 @@ fn parse_attribute(p: &mut HtmlParser) -> ParsedSyntax {
 }
 
 fn is_at_attribute_start(p: &mut HtmlParser) -> bool {
-    p.at(HTML_LITERAL) || p.at(T!["{{"]) || p.at(T!['{'])
+    p.at_ts(token_set![HTML_LITERAL, T!["{{"], T!['{']])
 }
 
 fn parse_literal(p: &mut HtmlParser, kind: HtmlSyntaxKind) -> ParsedSyntax {
diff --git a/crates/biome_html_parser/src/syntax/parse_error.rs b/crates/biome_html_parser/src/syntax/parse_error.rs
index e4865578bb..9d855140d8 100644
--- a/crates/biome_html_parser/src/syntax/parse_error.rs
+++ b/crates/biome_html_parser/src/syntax/parse_error.rs
@@ -13,6 +13,10 @@ pub(crate) fn disabled_interpolation(p: &HtmlParser, range: TextRange) -> ParseD
     p.err_builder("Text expressions aren't supported.", range).with_hint(markup!("Remove it or enable the parsing using the "<Emphasis>"html.parser.interpolation"</Emphasis>" option."))
 }
 
+pub(crate) fn disabled_svelte_prop(p: &HtmlParser, range: TextRange) -> ParseDiagnostic {
+    p.err_builder("This looks like Svelte syntax, but this is not a Svelte file.", range).with_hint(markup!("Remove it or rename this file to have the "<Emphasis>".svelte"</Emphasis>" file extension."))
+}
+
 pub(crate) fn expected_text_expression(
     p: &HtmlParser,
     curr_range: TextRange,
diff --git a/crates/biome_html_syntax/src/generated/nodes.rs b/crates/biome_html_syntax/src/generated/nodes.rs
index b6cbdab849..30f78b7ca4 100644
--- a/crates/biome_html_syntax/src/generated/nodes.rs
+++ b/crates/biome_html_syntax/src/generated/nodes.rs
@@ -873,6 +873,7 @@ pub enum AnyHtmlAttribute {
     HtmlAttribute(HtmlAttribute),
     HtmlBogusAttribute(HtmlBogusAttribute),
     HtmlDoubleTextExpression(HtmlDoubleTextExpression),
+    HtmlSingleTextExpression(HtmlSingleTextExpression),
 }
 impl AnyHtmlAttribute {
     pub fn as_html_attribute(&self) -> Option<&HtmlAttribute> {
@@ -893,6 +894,12 @@ impl AnyHtmlAttribute {
             _ => None,
         }
     }
+    pub fn as_html_single_text_expression(&self) -> Option<&HtmlSingleTextExpression> {
+        match &self {
+            Self::HtmlSingleTextExpression(item) => Some(item),
+            _ => None,
+        }
+    }
 }
 #[derive(Clone, PartialEq, Eq, Hash, Serialize)]
 pub enum AnyHtmlAttributeInitializer {
@@ -2121,15 +2128,24 @@ impl From<HtmlDoubleTextExpression> for AnyHtmlAttribute {
         Self::HtmlDoubleTextExpression(node)
     }
 }
+impl From<HtmlSingleTextExpression> for AnyHtmlAttribute {
+    fn from(node: HtmlSingleTextExpression) -> Self {
+        Self::HtmlSingleTextExpression(node)
+    }
+}
 impl AstNode for AnyHtmlAttribute {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> = HtmlAttribute::KIND_SET
         .union(HtmlBogusAttribute::KIND_SET)
-        .union(HtmlDoubleTextExpression::KIND_SET);
+        .union(HtmlDoubleTextExpression::KIND_SET)
+        .union(HtmlSingleTextExpression::KIND_SET);
     fn can_cast(kind: SyntaxKind) -> bool {
         matches!(
             kind,
-            HTML_ATTRIBUTE | HTML_BOGUS_ATTRIBUTE | HTML_DOUBLE_TEXT_EXPRESSION
+            HTML_ATTRIBUTE
+                | HTML_BOGUS_ATTRIBUTE
+                | HTML_DOUBLE_TEXT_EXPRESSION
+                | HTML_SINGLE_TEXT_EXPRESSION
         )
     }
     fn cast(syntax: SyntaxNode) -> Option<Self> {
@@ -2139,6 +2155,9 @@ impl AstNode for AnyHtmlAttribute {
             HTML_DOUBLE_TEXT_EXPRESSION => {
                 Self::HtmlDoubleTextExpression(HtmlDoubleTextExpression { syntax })
             }
+            HTML_SINGLE_TEXT_EXPRESSION => {
+                Self::HtmlSingleTextExpression(HtmlSingleTextExpression { syntax })
+            }
             _ => return None,
         };
         Some(res)
@@ -2148,6 +2167,7 @@ impl AstNode for AnyHtmlAttribute {
             Self::HtmlAttribute(it) => &it.syntax,
             Self::HtmlBogusAttribute(it) => &it.syntax,
             Self::HtmlDoubleTextExpression(it) => &it.syntax,
+            Self::HtmlSingleTextExpression(it) => &it.syntax,
         }
     }
     fn into_syntax(self) -> SyntaxNode {
@@ -2155,6 +2175,7 @@ impl AstNode for AnyHtmlAttribute {
             Self::HtmlAttribute(it) => it.syntax,
             Self::HtmlBogusAttribute(it) => it.syntax,
             Self::HtmlDoubleTextExpression(it) => it.syntax,
+            Self::HtmlSingleTextExpression(it) => it.syntax,
         }
     }
 }
@@ -2164,6 +2185,7 @@ impl std::fmt::Debug for AnyHtmlAttribute {
             Self::HtmlAttribute(it) => std::fmt::Debug::fmt(it, f),
             Self::HtmlBogusAttribute(it) => std::fmt::Debug::fmt(it, f),
             Self::HtmlDoubleTextExpression(it) => std::fmt::Debug::fmt(it, f),
+            Self::HtmlSingleTextExpression(it) => std::fmt::Debug::fmt(it, f),
         }
     }
 }
@@ -2173,6 +2195,7 @@ impl From<AnyHtmlAttribute> for SyntaxNode {
             AnyHtmlAttribute::HtmlAttribute(it) => it.into(),
             AnyHtmlAttribute::HtmlBogusAttribute(it) => it.into(),
             AnyHtmlAttribute::HtmlDoubleTextExpression(it) => it.into(),
+            AnyHtmlAttribute::HtmlSingleTextExpression(it) => it.into(),
         }
     }
 }
diff --git a/xtask/codegen/html.ungram b/xtask/codegen/html.ungram
index f8c0045d65..1dfa7733bd 100644
--- a/xtask/codegen/html.ungram
+++ b/xtask/codegen/html.ungram
@@ -159,6 +159,7 @@ HtmlAttributeList = AnyHtmlAttribute*
 AnyHtmlAttribute =
 	HtmlAttribute
 	| HtmlDoubleTextExpression
+	| HtmlSingleTextExpression
 	| HtmlBogusAttribute
 
 // <a href="">
