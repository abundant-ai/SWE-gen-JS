diff --git a/src/function/arithmetic/ceil.js b/src/function/arithmetic/ceil.js
index a3f40bbbe..339f0dce9 100644
--- a/src/function/arithmetic/ceil.js
+++ b/src/function/arithmetic/ceil.js
@@ -1,7 +1,7 @@
 import Decimal from 'decimal.js'
 import { factory } from '../../utils/factory.js'
 import { deepMap } from '../../utils/collection.js'
-import { isInteger, nearlyEqual } from '../../utils/number.js'
+import { nearlyEqual } from '../../utils/number.js'
 import { nearlyEqual as bigNearlyEqual } from '../../utils/bignumber/nearlyEqual.js'
 import { createMatAlgo11xS0s } from '../../type/matrix/utils/matAlgo11xS0s.js'
 import { createMatAlgo12xSfs } from '../../type/matrix/utils/matAlgo12xSfs.js'
@@ -10,37 +10,26 @@ import { createMatAlgo14xDs } from '../../type/matrix/utils/matAlgo14xDs.js'
 const name = 'ceil'
 const dependencies = ['typed', 'config', 'round', 'matrix', 'equalScalar', 'zeros', 'DenseMatrix']
 
-const bigTen = new Decimal(10)
-
 export const createCeilNumber = /* #__PURE__ */ factory(
   name, ['typed', 'config', 'round'], ({ typed, config, round }) => {
-    function _ceilNumber (x) {
-      // See ./floor.js _floorNumber for rationale here
-      const c = Math.ceil(x)
-      const r = round(x)
-      if (c === r) return c
-      if (
-        nearlyEqual(x, r, config.relTol, config.absTol) &&
-        !nearlyEqual(x, c, config.relTol, config.absTol)
-      ) {
-        return r
-      }
-      return c
-    }
-
     return typed(name, {
-      number: _ceilNumber,
-      'number, number': function (x, n) {
-        if (!isInteger(n)) {
-          throw new RangeError(
-            'number of decimals in function ceil must be an integer')
+      number: function (x) {
+        if (nearlyEqual(x, round(x), config.relTol, config.absTol)) {
+          return round(x)
+        } else {
+          return Math.ceil(x)
         }
-        if (n < 0 || n > 15) {
-          throw new RangeError(
-            'number of decimals in ceil number must be in range 0-15')
+      },
+
+      'number, number': function (x, n) {
+        if (nearlyEqual(x, round(x, n), config.relTol, config.absTol)) {
+          return round(x, n)
+        } else {
+          let [number, exponent] = `${x}e`.split('e')
+          const result = Math.ceil(Number(`${number}e${Number(exponent) + n}`));
+          [number, exponent] = `${result}e`.split('e')
+          return Number(`${number}e${Number(exponent) - n}`)
         }
-        const shift = 10 ** n
-        return _ceilNumber(x * shift) / shift
       }
     })
   }
@@ -52,15 +41,6 @@ export const createCeil = /* #__PURE__ */ factory(name, dependencies, ({ typed,
   const matAlgo14xDs = createMatAlgo14xDs({ typed })
 
   const ceilNumber = createCeilNumber({ typed, config, round })
-  function _bigCeil (x) {
-    // see ./floor.js _floorNumber for rationale
-    const bne = (a, b) => bigNearlyEqual(a, b, config.relTol, config.absTol)
-    const c = x.ceil()
-    const r = round(x)
-    if (c.eq(r)) return c
-    if (bne(x, r) && !bne(x, c)) return r
-    return c
-  }
   /**
    * Round a value towards plus infinity
    * If `x` is complex, both real and imaginary part are rounded towards plus infinity.
@@ -123,17 +103,22 @@ export const createCeil = /* #__PURE__ */ factory(name, dependencies, ({ typed,
       return x.ceil(n.toNumber())
     },
 
-    BigNumber: _bigCeil,
+    BigNumber: function (x) {
+      if (bigNearlyEqual(x, round(x), config.relTol, config.absTol)) {
+        return round(x)
+      } else {
+        return x.ceil()
+      }
+    },
 
     'BigNumber, BigNumber': function (x, n) {
-      const shift = bigTen.pow(n)
-      return _bigCeil(x.mul(shift)).div(shift)
+      if (bigNearlyEqual(x, round(x, n), config.relTol, config.absTol)) {
+        return round(x, n)
+      } else {
+        return x.toDecimalPlaces(n.toNumber(), Decimal.ROUND_CEIL)
+      }
     },
 
-    bigint: b => b,
-    'bigint, number': (b, _dummy) => b,
-    'bigint, BigNumber': (b, _dummy) => b,
-
     Fraction: function (x) {
       return x.ceil()
     },
diff --git a/src/function/arithmetic/fix.js b/src/function/arithmetic/fix.js
index 0cc47ffc0..8794adc5e 100644
--- a/src/function/arithmetic/fix.js
+++ b/src/function/arithmetic/fix.js
@@ -104,10 +104,6 @@ export const createFix = /* #__PURE__ */ factory(name, dependencies, ({ typed, C
       return x.isNegative() ? ceil(x, n) : floor(x, n)
     },
 
-    bigint: b => b,
-    'bigint, number': (b, _dummy) => b,
-    'bigint, BigNumber': (b, _dummy) => b,
-
     Fraction: function (x) {
       return x.s < 0n ? x.ceil() : x.floor()
     },
diff --git a/src/function/arithmetic/floor.js b/src/function/arithmetic/floor.js
index 752d06864..449111df7 100644
--- a/src/function/arithmetic/floor.js
+++ b/src/function/arithmetic/floor.js
@@ -1,7 +1,7 @@
 import Decimal from 'decimal.js'
 import { factory } from '../../utils/factory.js'
 import { deepMap } from '../../utils/collection.js'
-import { isInteger, nearlyEqual } from '../../utils/number.js'
+import { nearlyEqual } from '../../utils/number.js'
 import { nearlyEqual as bigNearlyEqual } from '../../utils/bignumber/nearlyEqual.js'
 import { createMatAlgo11xS0s } from '../../type/matrix/utils/matAlgo11xS0s.js'
 import { createMatAlgo12xSfs } from '../../type/matrix/utils/matAlgo12xSfs.js'
@@ -10,44 +10,26 @@ import { createMatAlgo14xDs } from '../../type/matrix/utils/matAlgo14xDs.js'
 const name = 'floor'
 const dependencies = ['typed', 'config', 'round', 'matrix', 'equalScalar', 'zeros', 'DenseMatrix']
 
-const bigTen = new Decimal(10)
-
 export const createFloorNumber = /* #__PURE__ */ factory(
   name, ['typed', 'config', 'round'], ({ typed, config, round }) => {
-    function _floorNumber (x) {
-      // First, if the floor and the round are identical we can be
-      // quite comfortable that is the best answer:
-      const f = Math.floor(x)
-      const r = round(x)
-      if (f === r) return f
-      // OK, they are different. If x is truly distinct from f but
-      // appears indistinguishable from r, presume it really is just
-      // the integer r with rounding/computation error, and return that
-      if (
-        nearlyEqual(x, r, config.relTol, config.absTol) &&
-        !nearlyEqual(x, f, config.relTol, config.absTol)
-      ) {
-        return r
-      }
-      // Otherwise (x distinct from both r and f, or indistinguishable from
-      // both r and f) may as well just return f, as that's the best
-      // candidate we can discern:
-      return f
-    }
-
     return typed(name, {
-      number: _floorNumber,
-      'number, number': function (x, n) {
-        if (!isInteger(n)) {
-          throw new RangeError(
-            'number of decimals in function floor must be an integer')
+      number: function (x) {
+        if (nearlyEqual(x, round(x), config.relTol, config.absTol)) {
+          return round(x)
+        } else {
+          return Math.floor(x)
         }
-        if (n < 0 || n > 15) {
-          throw new RangeError(
-            'number of decimals in floor number must be in range 0 - 15')
+      },
+
+      'number, number': function (x, n) {
+        if (nearlyEqual(x, round(x, n), config.relTol, config.absTol)) {
+          return round(x, n)
+        } else {
+          let [number, exponent] = `${x}e`.split('e')
+          const result = Math.floor(Number(`${number}e${Number(exponent) + n}`));
+          [number, exponent] = `${result}e`.split('e')
+          return Number(`${number}e${Number(exponent) - n}`)
         }
-        const shift = 10 ** n
-        return _floorNumber(x * shift) / shift
       }
     })
   }
@@ -59,15 +41,6 @@ export const createFloor = /* #__PURE__ */ factory(name, dependencies, ({ typed,
   const matAlgo14xDs = createMatAlgo14xDs({ typed })
 
   const floorNumber = createFloorNumber({ typed, config, round })
-  function _bigFloor (x) {
-    // see _floorNumber above for rationale
-    const bne = (a, b) => bigNearlyEqual(a, b, config.relTol, config.absTol)
-    const f = x.floor()
-    const r = round(x)
-    if (f.eq(r)) return f
-    if (bne(x, r) && !bne(x, f)) return r
-    return f
-  }
   /**
    * Round a value towards minus infinity.
    * For matrices, the function is evaluated element wise.
@@ -133,17 +106,22 @@ export const createFloor = /* #__PURE__ */ factory(name, dependencies, ({ typed,
       return x.floor(n.toNumber())
     },
 
-    BigNumber: _bigFloor,
+    BigNumber: function (x) {
+      if (bigNearlyEqual(x, round(x), config.relTol, config.absTol)) {
+        return round(x)
+      } else {
+        return x.floor()
+      }
+    },
 
     'BigNumber, BigNumber': function (x, n) {
-      const shift = bigTen.pow(n)
-      return _bigFloor(x.mul(shift)).div(shift)
+      if (bigNearlyEqual(x, round(x, n), config.relTol, config.absTol)) {
+        return round(x, n)
+      } else {
+        return x.toDecimalPlaces(n.toNumber(), Decimal.ROUND_FLOOR)
+      }
     },
 
-    bigint: b => b,
-    'bigint, number': (b, _dummy) => b,
-    'bigint, BigNumber': (b, _dummy) => b,
-
     Fraction: function (x) {
       return x.floor()
     },
diff --git a/src/function/arithmetic/round.js b/src/function/arithmetic/round.js
index 738559ce8..1f48fa13e 100644
--- a/src/function/arithmetic/round.js
+++ b/src/function/arithmetic/round.js
@@ -133,11 +133,6 @@ export const createRound = /* #__PURE__ */ factory(name, dependencies, ({ typed,
       return xSelected.toDecimalPlaces(n.toNumber())
     },
 
-    // bigints can't be rounded
-    bigint: b => b,
-    'bigint, number': (b, _dummy) => b,
-    'bigint, BigNumber': (b, _dummy) => b,
-
     Fraction: function (x) {
       return x.round()
     },
diff --git a/test/unit-tests/function/arithmetic/ceil.test.js b/test/unit-tests/function/arithmetic/ceil.test.js
index dc7e90b56..b9315d29c 100644
--- a/test/unit-tests/function/arithmetic/ceil.test.js
+++ b/test/unit-tests/function/arithmetic/ceil.test.js
@@ -37,12 +37,6 @@ describe('ceil', function () {
     approxEqual(ceil(-2.178, 2), -2.17)
   })
 
-  it('should be safe to call with a bigint', function () {
-    const b = 12345678901234567890n
-    assert.strictEqual(ceil(b), b)
-    assert.strictEqual(ceil(b, 7), b)
-  })
-
   it('should return the ceil of a big number', function () {
     assert.deepStrictEqual(ceil(bignumber(0)), bignumber(0))
     assert.deepStrictEqual(ceil(bignumber(1)), bignumber(1))
@@ -154,13 +148,6 @@ describe('ceil', function () {
     assert.deepStrictEqual(ceil(bignumber(-799999.9999999999)), bignumber(-800000))
   })
 
-  it('should not be confused by default tolerances', function () {
-    assert.strictEqual(ceil(1234567890123.4), 1234567890124)
-    assert.strictEqual(
-      ceil(bignumber('12345678901234567890.4')).toFixed(),
-      '12345678901234567891')
-  })
-
   it('should ceil units', function () {
     assert.deepStrictEqual(ceil(unit('5.01 inch'), unit('inch')), unit('6 inch'))
     assert.deepStrictEqual(ceil(unit('3.12345 cm'), 3, unit('cm')), unit('3.124 cm'))
diff --git a/test/unit-tests/function/arithmetic/fix.test.js b/test/unit-tests/function/arithmetic/fix.test.js
index 7ee7da8c7..74cf373a3 100644
--- a/test/unit-tests/function/arithmetic/fix.test.js
+++ b/test/unit-tests/function/arithmetic/fix.test.js
@@ -50,12 +50,6 @@ describe('fix', function () {
     assert.deepStrictEqual(fix(-1.888, bignumber(2)), bignumber(-1.88))
   })
 
-  it('should be safe to call with a bigint', function () {
-    const b = 12345678901234567890n
-    assert.strictEqual(fix(b), b)
-    assert.strictEqual(fix(b, 7), b)
-  })
-
   it('should round big numbers correctly', function () {
     assert.deepStrictEqual(fix(bignumber(0)), bignumber(0))
     assert.deepStrictEqual(fix(bignumber(1)), bignumber(1))
diff --git a/test/unit-tests/function/arithmetic/floor.test.js b/test/unit-tests/function/arithmetic/floor.test.js
index d2093bbb0..a8acc77f8 100644
--- a/test/unit-tests/function/arithmetic/floor.test.js
+++ b/test/unit-tests/function/arithmetic/floor.test.js
@@ -45,12 +45,6 @@ describe('floor', function () {
     assert.strictEqual(floor(-2.178, 2), -2.18)
   })
 
-  it('should be safe to call with a bigint', function () {
-    const b = 12345678901234567890n
-    assert.strictEqual(floor(b), b)
-    assert.strictEqual(floor(b, 7), b)
-  })
-
   it('should floor big numbers correctly', function () {
     assert.deepStrictEqual(floor(bignumber(0)), bignumber(0))
     assert.deepStrictEqual(floor(bignumber(1)), bignumber(1))
@@ -133,7 +127,6 @@ describe('floor', function () {
     assert.strictEqual(floor(-7.999999999999999), -8)
     assert.strictEqual(floor(30000.000000000004), 30000)
     assert.strictEqual(floor(799999.9999999999), 800000)
-    assert.strictEqual(floor(799999999.9999999), 800000000)
     assert.strictEqual(floor(-30000.000000000004), -30000)
 
     assert.strictEqual(floor(3.0000000000000004, 2), 3)
@@ -142,17 +135,9 @@ describe('floor', function () {
     assert.strictEqual(floor(-7.999999999999999, 2), -8)
     assert.strictEqual(floor(30000.000000000004, 2), 30000)
     assert.strictEqual(floor(799999.9999999999, 2), 800000)
-    assert.strictEqual(floor(799999.9999999999, 3), 800000)
     assert.strictEqual(floor(-30000.000000000004, 2), -30000)
   })
 
-  it('should not be confused by default tolerances', function () {
-    assert.strictEqual(floor(1234567890123.5), 1234567890123)
-    assert.strictEqual(
-      floor(bignumber('12345678901234567890.5')).toFixed(),
-      '12345678901234567890')
-  })
-
   it('should gracefully handle round-off errors with bignumbers', function () {
     assert.deepStrictEqual(floor(bignumber(3.0000000000000004)), bignumber(3))
     assert.deepStrictEqual(floor(bignumber(7.999999999999999)), bignumber(8))
diff --git a/test/unit-tests/function/arithmetic/round.test.js b/test/unit-tests/function/arithmetic/round.test.js
index 30b03ee21..63afdb993 100644
--- a/test/unit-tests/function/arithmetic/round.test.js
+++ b/test/unit-tests/function/arithmetic/round.test.js
@@ -72,12 +72,6 @@ describe('round', function () {
     assert.throws(function () { round(null) }, /TypeError: Unexpected type of argument/)
   })
 
-  it('should be safe to call with a bigint', function () {
-    const b = 12345678901234567890n
-    assert.strictEqual(round(b), b)
-    assert.strictEqual(round(b, 7), b)
-  })
-
   it('should round bignumbers', function () {
     assert.deepStrictEqual(round(bignumber(0.145 * 100)), bignumber(15))
     assert.deepStrictEqual(round(bignumber(0.145 * 100), bignumber(0)), bignumber(15))
