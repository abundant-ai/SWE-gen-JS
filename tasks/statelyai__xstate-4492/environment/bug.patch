diff --git a/.changeset/olive-months-shave.md b/.changeset/olive-months-shave.md
deleted file mode 100644
index 7e1b545da8..0000000000
--- a/.changeset/olive-months-shave.md
+++ /dev/null
@@ -1,5 +0,0 @@
----
-'xstate': major
----
-
-All errors caught while executing the actor should now consistently include the error in its `snapshot.error` and should be reported to the closest `error` listener.
diff --git a/README.md b/README.md
index a8ec399104..2133945e0d 100644
--- a/README.md
+++ b/README.md
@@ -82,7 +82,7 @@ const toggleMachine = createMachine({
     inactive: { on: { TOGGLE: 'active' } },
     active: {
       entry: assign({ count: ({ context }) => context.count + 1 }),
-      on: { TOGGLE: 'inactive' }
+      on: { TOGGLE: 'inactive' } 
     }
   }
 });
diff --git a/packages/core/src/StateMachine.ts b/packages/core/src/StateMachine.ts
index bd1c73e96e..46ec53d58d 100644
--- a/packages/core/src/StateMachine.ts
+++ b/packages/core/src/StateMachine.ts
@@ -2,6 +2,7 @@ import { assign } from './actions.ts';
 import { createInitEvent } from './eventUtils.ts';
 import { STATE_DELIMITER } from './constants.ts';
 import {
+  cloneMachineSnapshot,
   createMachineSnapshot,
   getPersistedState,
   MachineSnapshot
@@ -52,7 +53,11 @@ import type {
   HistoryValue,
   StateSchema
 } from './types.ts';
-import { resolveReferencedActor } from './utils.ts';
+import {
+  getAllOwnEventDescriptors,
+  isErrorActorEvent,
+  resolveReferencedActor
+} from './utils.ts';
 import { $$ACTOR_TYPE, createActor } from './interpreter.ts';
 import isDevelopment from '#is-development';
 
@@ -287,7 +292,22 @@ export class StateMachine<
     TOutput,
     TResolvedTypesMeta
   > {
-    return macrostep(snapshot, event, actorScope).state as typeof snapshot;
+    // TODO: handle error events in a better way
+    if (
+      isErrorActorEvent(event) &&
+      !getAllOwnEventDescriptors(snapshot).some(
+        (nextEvent) => nextEvent === event.type
+      )
+    ) {
+      return cloneMachineSnapshot(snapshot, {
+        status: 'error',
+        error: event.data
+      });
+    }
+
+    const { state: nextState } = macrostep(snapshot, event, actorScope);
+
+    return nextState as typeof snapshot;
   }
 
   /**
diff --git a/packages/core/src/actions/spawnChild.ts b/packages/core/src/actions/spawnChild.ts
index 976eaca202..af36152824 100644
--- a/packages/core/src/actions/spawnChild.ts
+++ b/packages/core/src/actions/spawnChild.ts
@@ -105,7 +105,12 @@ function executeSpawn(
     if (actorRef._processingStatus === ProcessingStatus.Stopped) {
       return;
     }
-    actorRef.start();
+    try {
+      actorRef.start?.();
+    } catch (err) {
+      (actorScope.self as AnyActor).send(createErrorActorEvent(id, err));
+      return;
+    }
   });
 }
 
diff --git a/packages/core/src/interpreter.ts b/packages/core/src/interpreter.ts
index c5fa809d08..d6aeeaec9b 100644
--- a/packages/core/src/interpreter.ts
+++ b/packages/core/src/interpreter.ts
@@ -206,22 +206,11 @@ export class Actor<TLogic extends AnyActorLogic>
   }
 
   private _initState(persistedState?: Snapshot<unknown>) {
-    try {
-      this._state = persistedState
-        ? this.logic.restoreState
-          ? this.logic.restoreState(persistedState, this._actorScope)
-          : persistedState
-        : this.logic.getInitialState(this._actorScope, this.options?.input);
-    } catch (err) {
-      // if we get here then it means that we assign a value to this._state that is not of the correct type
-      // we can't get the true `TSnapshot & { status: 'error'; }`, it's impossible
-      // so right now this is a lie of sorts
-      this._state = {
-        status: 'error',
-        output: undefined,
-        error: err
-      } as any;
-    }
+    this._state = persistedState
+      ? this.logic.restoreState
+        ? this.logic.restoreState(persistedState, this._actorScope)
+        : persistedState
+      : this.logic.getInitialState(this._actorScope, this.options?.input);
   }
 
   // array of functions to defer
@@ -235,48 +224,19 @@ export class Actor<TLogic extends AnyActorLogic>
     let deferredFn: (typeof this._deferred)[number] | undefined;
 
     while ((deferredFn = this._deferred.shift())) {
+      deferredFn();
+    }
+
+    for (const observer of this.observers) {
       try {
-        deferredFn();
+        observer.next?.(snapshot);
       } catch (err) {
-        // this error can only be caught when executing *initial* actions
-        // it's the only time when we call actions provided by the user through those deferreds
-        // when the actor is already running we always execute them synchronously while transitioning
-        // no "builtin deferred" should actually throw an error since they are either safe
-        // or the control flow is passed through the mailbox and errors should be caught by the `_process` used by the mailbox
-        this._deferred.length = 0;
-        this._state = {
-          ...(snapshot as any),
-          status: 'error',
-          error: err
-        };
+        reportUnhandledError(err);
       }
     }
 
     switch ((this._state as any).status) {
-      case 'active':
-        for (const observer of this.observers) {
-          try {
-            observer.next?.(snapshot);
-          } catch (err) {
-            reportUnhandledError(err);
-          }
-        }
-        break;
       case 'done':
-        // next observers are meant to be notified about done snapshots
-        // this can be seen as something that is different from how observable work
-        // but with observables `complete` callback is called without any arguments
-        // it's more ergonomic for XState to treat a done snapshot as a "next" value
-        // and the completion event as something that is separate,
-        // something that merely follows emitting that done snapshot
-        for (const observer of this.observers) {
-          try {
-            observer.next?.(snapshot);
-          } catch (err) {
-            reportUnhandledError(err);
-          }
-        }
-
         this._stopProcedure();
         this._complete();
         this._doneEvent = createDoneActorEvent(
@@ -289,7 +249,15 @@ export class Actor<TLogic extends AnyActorLogic>
 
         break;
       case 'error':
+        this._stopProcedure();
         this._error((this._state as any).error);
+        if (this._parent) {
+          this.system._relay(
+            this,
+            this._parent,
+            createErrorActorEvent(this.id, (this._state as any).error)
+          );
+        }
         break;
     }
     this.system._sendInspectionEvent({
@@ -397,7 +365,7 @@ export class Actor<TLogic extends AnyActorLogic>
       this.subscribe({
         next: (snapshot: Snapshot<unknown>) => {
           if (snapshot.status === 'active') {
-            this.system._relay(this, this._parent!, {
+            this._parent!.send({
               type: `xstate.snapshot.${this.id}`,
               snapshot
             });
@@ -433,10 +401,9 @@ export class Actor<TLogic extends AnyActorLogic>
           this._state,
           initEvent as unknown as EventFromLogic<TLogic>
         );
-        // TODO: rethink cleanup of observers, mailbox, etc
-        return this;
+      // fallthrough
       case 'error':
-        this._error((this._state as any).error);
+        // TODO: rethink cleanup of observers, mailbox, etc
         return this;
     }
 
@@ -444,12 +411,9 @@ export class Actor<TLogic extends AnyActorLogic>
       try {
         this.logic.start(this._state, this._actorScope);
       } catch (err) {
-        this._state = {
-          ...(this._state as any),
-          status: 'error',
-          error: err
-        };
+        this._stopProcedure();
         this._error(err);
+        this._parent?.send(createErrorActorEvent(this.id, err));
         return this;
       }
     }
@@ -469,6 +433,7 @@ export class Actor<TLogic extends AnyActorLogic>
   }
 
   private _process(event: EventFromLogic<TLogic>) {
+    // TODO: reexamine what happens when an action (or a guard or smth) throws
     let nextState;
     let caughtError;
     try {
@@ -481,12 +446,9 @@ export class Actor<TLogic extends AnyActorLogic>
     if (caughtError) {
       const { err } = caughtError;
 
-      this._state = {
-        ...(this._state as any),
-        status: 'error',
-        error: err
-      };
+      this._stopProcedure();
       this._error(err);
+      this._parent?.send(createErrorActorEvent(this.id, err));
       return;
     }
 
@@ -530,7 +492,7 @@ export class Actor<TLogic extends AnyActorLogic>
     }
     this.observers.clear();
   }
-  private _reportError(err: unknown): void {
+  private _error(err: unknown): void {
     if (!this.observers.size) {
       if (!this._parent) {
         reportUnhandledError(err);
@@ -553,22 +515,6 @@ export class Actor<TLogic extends AnyActorLogic>
       reportUnhandledError(err);
     }
   }
-  private _error(err: unknown): void {
-    this._stopProcedure();
-    this._reportError(err);
-    if (this._parent) {
-      this.system._relay(
-        this,
-        this._parent,
-        createErrorActorEvent(this.id, err)
-      );
-    }
-  }
-  // TODO: atm children don't belong entirely to the actor so
-  // in a way - it's not even super aware of them
-  // so we can't stop them from here but we really should!
-  // right now, they are being stopped within the machine's transition
-  // but that could throw and leave us with "orphaned" active actors
   private _stopProcedure(): this {
     if (this._processingStatus !== ProcessingStatus.Running) {
       // Actor already stopped; do nothing
diff --git a/packages/core/src/spawn.ts b/packages/core/src/spawn.ts
index 194a142d91..fdc8e53054 100644
--- a/packages/core/src/spawn.ts
+++ b/packages/core/src/spawn.ts
@@ -111,7 +111,12 @@ export function createSpawner(
       if (actorRef._processingStatus === ProcessingStatus.Stopped) {
         return;
       }
-      actorRef.start();
+      try {
+        actorRef.start?.();
+      } catch (err) {
+        actorScope.self.send(createErrorActorEvent(actorRef.id, err));
+        return;
+      }
     });
     return actorRef;
   };
diff --git a/packages/core/src/stateUtils.ts b/packages/core/src/stateUtils.ts
index 15bd269a54..52de1ca0ca 100644
--- a/packages/core/src/stateUtils.ts
+++ b/packages/core/src/stateUtils.ts
@@ -45,8 +45,7 @@ import {
   normalizeTarget,
   toArray,
   toStatePath,
-  toTransitionConfigArray,
-  isErrorActorEvent
+  toTransitionConfigArray
 } from './utils.ts';
 import { ProcessingStatus } from './interpreter.ts';
 
@@ -1644,25 +1643,7 @@ export function macrostep(
   // Assume the state is at rest (no raised events)
   // Determine the next state based on the next microstep
   if (nextEvent.type !== XSTATE_INIT) {
-    const currentEvent = nextEvent;
-    const isErr = isErrorActorEvent(currentEvent);
-
-    const transitions = selectTransitions(currentEvent, nextState);
-
-    if (isErr && !transitions.length) {
-      // TODO: we should likely only allow transitions selected by very explicit descriptors
-      // `*` shouldn't be matched, likely `xstate.error.*` shouldnt be either
-      // similarly `xstate.error.actor.*` and `xstate.error.actor.todo.*` have to be considered too
-      nextState = cloneMachineSnapshot<typeof state>(state, {
-        status: 'error',
-        error: currentEvent.data
-      });
-      states.push(nextState);
-      return {
-        state: nextState,
-        microstates: states
-      };
-    }
+    const transitions = selectTransitions(nextEvent, nextState);
     nextState = microstep(
       transitions,
       state,
diff --git a/packages/core/src/types.ts b/packages/core/src/types.ts
index 5013b97872..5b541161fd 100644
--- a/packages/core/src/types.ts
+++ b/packages/core/src/types.ts
@@ -1918,7 +1918,8 @@ export interface ActorRef<
   /** @internal */
   _send: (event: TEvent) => void;
   send: (event: TEvent) => void;
-  start: () => void;
+  // TODO: should this be optional?
+  start?: () => void;
   getSnapshot: () => TSnapshot;
   getPersistedState: () => Snapshot<unknown>;
   stop: () => void;
diff --git a/packages/core/test/actions.test.ts b/packages/core/test/actions.test.ts
index 0072c8f323..fe4a8556c8 100644
--- a/packages/core/test/actions.test.ts
+++ b/packages/core/test/actions.test.ts
@@ -3185,7 +3185,7 @@ describe('sendTo', () => {
     service.send({ type: 'EVENT', value: 'foo' });
   });
 
-  it('should error if given a string', () => {
+  it('should throw if given a string', () => {
     const machine = createMachine({
       invoke: {
         id: 'child',
@@ -3194,21 +3194,11 @@ describe('sendTo', () => {
       entry: sendTo('child', 'a string')
     });
 
-    const errorSpy = jest.fn();
-
-    const actorRef = createActor(machine);
-    actorRef.subscribe({
-      error: errorSpy
-    });
-    actorRef.start();
-
-    expect(errorSpy).toMatchMockCallsInlineSnapshot(`
-      [
-        [
-          [Error: Only event objects may be used with sendTo; use sendTo({ type: "a string" }) instead],
-        ],
-      ]
-    `);
+    expect(() => {
+      createActor(machine).start();
+    }).toThrowErrorMatchingInlineSnapshot(
+      `"Only event objects may be used with sendTo; use sendTo({ type: "a string" }) instead"`
+    );
   });
 });
 
@@ -3420,7 +3410,7 @@ describe('raise', () => {
     }, 10);
   });
 
-  it('should error if given a string', () => {
+  it('should throw if given a string', () => {
     const machine = createMachine({
       entry: raise(
         // @ts-ignore
@@ -3428,21 +3418,11 @@ describe('raise', () => {
       )
     });
 
-    const errorSpy = jest.fn();
-
-    const actorRef = createActor(machine);
-    actorRef.subscribe({
-      error: errorSpy
-    });
-    actorRef.start();
-
-    expect(errorSpy).toMatchMockCallsInlineSnapshot(`
-      [
-        [
-          [Error: Only event objects may be used with raise; use raise({ type: "a string" }) instead],
-        ],
-      ]
-    `);
+    expect(() => {
+      createActor(machine).start();
+    }).toThrowErrorMatchingInlineSnapshot(
+      `"Only event objects may be used with raise; use raise({ type: "a string" }) instead"`
+    );
   });
 });
 
diff --git a/packages/core/test/actorLogic.test.ts b/packages/core/test/actorLogic.test.ts
index ca7bc76c3a..94857d79d4 100644
--- a/packages/core/test/actorLogic.test.ts
+++ b/packages/core/test/actorLogic.test.ts
@@ -185,13 +185,13 @@ describe('promise logic (fromPromise)', () => {
       createdPromises++;
       return Promise.reject(createdPromises);
     });
-    const actorRef = createActor(promiseLogic);
-    actorRef.subscribe({ error: function preventUnhandledErrorListener() {} });
-    actorRef.start();
+    const actor = createActor(promiseLogic);
+    actor.subscribe({ error: function preventUnhandledErrorListener() {} });
+    actor.start();
 
     await new Promise((res) => setTimeout(res, 5));
 
-    const rejectedPersistedState = actorRef.getPersistedState();
+    const rejectedPersistedState = actor.getPersistedState();
     expect(rejectedPersistedState).toMatchInlineSnapshot(`
       {
         "error": 1,
@@ -202,11 +202,9 @@ describe('promise logic (fromPromise)', () => {
     `);
     expect(createdPromises).toBe(1);
 
-    const actorRef2 = createActor(promiseLogic, {
+    createActor(promiseLogic, {
       state: rejectedPersistedState
-    });
-    actorRef2.subscribe({ error: function preventUnhandledErrorListener() {} });
-    actorRef2.start();
+    }).start();
 
     expect(createdPromises).toBe(1);
   });
@@ -349,24 +347,19 @@ describe('observable logic (fromObservable)', () => {
     expect(spy).toHaveBeenCalledWith(42);
   });
 
-  it('should reject (observer .error)', () => {
-    const actor = createActor(
-      fromObservable(() => throwError(() => 'Observable error.'))
-    );
+  it('should reject (observer .error)', (done) => {
+    const actor = createActor(fromObservable(() => throwError(() => 'Error')));
     const spy = jest.fn();
 
     actor.subscribe({
-      error: spy
+      next: (snapshot) => spy(snapshot.error),
+      error: () => {
+        done();
+      }
     });
 
     actor.start();
-    expect(spy).toMatchMockCallsInlineSnapshot(`
-      [
-        [
-          "Observable error.",
-        ],
-      ]
-    `);
+    expect(spy).toHaveBeenCalledWith('Error');
   });
 
   it('should complete (observer .complete)', () => {
diff --git a/packages/core/test/errors.test.ts b/packages/core/test/errors.test.ts
index 1f70e124db..20953ffd94 100644
--- a/packages/core/test/errors.test.ts
+++ b/packages/core/test/errors.test.ts
@@ -1,12 +1,5 @@
+import { createMachine, fromCallback, fromPromise, createActor } from '../src';
 import { sleep } from '@xstate-repo/jest-utils';
-import {
-  assign,
-  createActor,
-  createMachine,
-  fromCallback,
-  fromPromise,
-  fromTransition
-} from '../src';
 
 const cleanups: (() => void)[] = [];
 function installGlobalOnErrorHandler(handler: (ev: ErrorEvent) => void) {
@@ -353,7 +346,7 @@ describe('error handling', () => {
     const actorRef = createActor(machine);
     const childActorRef = Object.values(actorRef.getSnapshot().children)[0];
     childActorRef.subscribe({
-      error: function preventUnhandledErrorListener() {}
+      error: () => {}
     });
     childActorRef.subscribe(() => {});
     actorRef.start();
@@ -386,10 +379,10 @@ describe('error handling', () => {
     const actorRef = createActor(machine);
     const childActorRef = Object.values(actorRef.getSnapshot().children)[0];
     childActorRef.subscribe({
-      error: function preventUnhandledErrorListener() {}
+      error: () => {}
     });
     childActorRef.subscribe({
-      error: function preventUnhandledErrorListener() {}
+      error: () => {}
     });
     actorRef.start();
 
@@ -419,7 +412,7 @@ describe('error handling', () => {
     const actorRef = createActor(machine);
     const childActorRef = Object.values(actorRef.getSnapshot().children)[0];
     childActorRef.subscribe({
-      error: function preventUnhandledErrorListener() {}
+      error: () => {}
     });
     childActorRef.subscribe({});
     actorRef.start();
@@ -651,7 +644,7 @@ describe('error handling', () => {
 
     const actorRef = createActor(machine);
     actorRef.subscribe({
-      error: function preventUnhandledErrorListener() {}
+      error: () => {}
     });
     actorRef.subscribe(() => {});
     actorRef.start();
@@ -705,191 +698,4 @@ describe('error handling', () => {
       }
     });
   });
-
-  it('error thrown in initial custom entry action should error the actor', () => {
-    const machine = createMachine({
-      entry: () => {
-        throw new Error('error_thrown_in_initial_entry_action');
-      }
-    });
-
-    const errorSpy = jest.fn();
-
-    const actorRef = createActor(machine);
-    actorRef.subscribe({
-      error: errorSpy
-    });
-    actorRef.start();
-
-    const snapshot = actorRef.getSnapshot();
-    expect(snapshot.status).toBe('error');
-    expect(snapshot.error).toMatchInlineSnapshot(
-      `[Error: error_thrown_in_initial_entry_action]`
-    );
-    expect(errorSpy).toMatchMockCallsInlineSnapshot(`
-      [
-        [
-          [Error: error_thrown_in_initial_entry_action],
-        ],
-      ]
-    `);
-  });
-
-  it('error thrown when resolving initial builtin entry action should error the actor immediately', () => {
-    const machine = createMachine({
-      entry: assign(() => {
-        throw new Error('error_thrown_when_resolving_initial_entry_action');
-      })
-    });
-
-    const errorSpy = jest.fn();
-
-    const actorRef = createActor(machine);
-
-    const snapshot = actorRef.getSnapshot();
-    expect(snapshot.status).toBe('error');
-    expect(snapshot.error).toMatchInlineSnapshot(
-      `[Error: error_thrown_when_resolving_initial_entry_action]`
-    );
-
-    actorRef.subscribe({
-      error: errorSpy
-    });
-    actorRef.start();
-
-    expect(errorSpy).toMatchMockCallsInlineSnapshot(`
-      [
-        [
-          [Error: error_thrown_when_resolving_initial_entry_action],
-        ],
-      ]
-    `);
-  });
-
-  it('error thrown by a custom entry action when transitioning should error the actor', () => {
-    const machine = createMachine({
-      initial: 'a',
-      states: {
-        a: {
-          on: {
-            NEXT: 'b'
-          }
-        },
-        b: {
-          entry: () => {
-            throw new Error(
-              'error_thrown_in_a_custom_entry_action_when_transitioning'
-            );
-          }
-        }
-      }
-    });
-
-    const errorSpy = jest.fn();
-
-    const actorRef = createActor(machine);
-    actorRef.subscribe({
-      error: errorSpy
-    });
-    actorRef.start();
-    actorRef.send({ type: 'NEXT' });
-
-    const snapshot = actorRef.getSnapshot();
-    expect(snapshot.status).toBe('error');
-    expect(snapshot.error).toMatchInlineSnapshot(
-      `[Error: error_thrown_in_a_custom_entry_action_when_transitioning]`
-    );
-    expect(errorSpy).toMatchMockCallsInlineSnapshot(`
-      [
-        [
-          [Error: error_thrown_in_a_custom_entry_action_when_transitioning],
-        ],
-      ]
-    `);
-  });
-
-  it(`shouldn't execute deferred initial actions that come after an action that errors`, () => {
-    const spy = jest.fn();
-
-    const machine = createMachine({
-      entry: [
-        () => {
-          throw new Error('error_thrown_in_initial_entry_action');
-        },
-        spy
-      ]
-    });
-
-    const actorRef = createActor(machine);
-    actorRef.subscribe({ error: function preventUnhandledErrorListener() {} });
-    actorRef.start();
-
-    expect(spy).toHaveBeenCalledTimes(0);
-  });
-
-  it('should error the parent on errored initial state of a child', async () => {
-    const immediateFailure = fromTransition((_) => undefined, undefined);
-    immediateFailure.getInitialState = () => ({
-      status: 'error',
-      output: undefined,
-      error: 'immediate error!',
-      context: undefined
-    });
-
-    const machine = createMachine(
-      {
-        invoke: {
-          src: 'failure'
-        }
-      },
-      {
-        actors: {
-          failure: immediateFailure
-        }
-      }
-    );
-
-    const actorRef = createActor(machine);
-    actorRef.subscribe({ error: function preventUnhandledErrorListener() {} });
-    actorRef.start();
-
-    const snapshot = actorRef.getSnapshot();
-
-    expect(snapshot.status).toBe('error');
-    expect(snapshot.error).toBe('immediate error!');
-  });
-
-  it('should error when a guard throws when transitioning', () => {
-    const spy = jest.fn();
-    const machine = createMachine({
-      initial: 'a',
-      states: {
-        a: {
-          on: {
-            NEXT: {
-              guard: () => {
-                throw new Error('error_thrown_in_guard_when_transitioning');
-              },
-              target: 'b'
-            }
-          }
-        },
-        b: {}
-      }
-    });
-
-    const actorRef = createActor(machine);
-    actorRef.subscribe({
-      error: spy
-    });
-    actorRef.start();
-    actorRef.send({ type: 'NEXT' });
-
-    const snapshot = actorRef.getSnapshot();
-    expect(snapshot.status).toBe('error');
-    expect(snapshot.error).toMatchInlineSnapshot(`
-      [Error: Unable to evaluate guard in transition for event 'NEXT' in state node '(machine).a':
-      error_thrown_in_guard_when_transitioning]
-    `);
-  });
 });
diff --git a/packages/core/test/input.test.ts b/packages/core/test/input.test.ts
index d9fb6b8496..e668ddb2f9 100644
--- a/packages/core/test/input.test.ts
+++ b/packages/core/test/input.test.ts
@@ -41,7 +41,7 @@ describe('input', () => {
     createActor(machine, { input: { greeting: 'hello' } }).start();
   });
 
-  it('should error if input is expected but not provided', () => {
+  it('should throw if input is expected but not provided', () => {
     const machine = createMachine({
       types: {} as {
         input: { greeting: string };
@@ -52,9 +52,21 @@ describe('input', () => {
       }
     });
 
-    const snapshot = createActor(machine).getSnapshot();
+    expect(() => {
+      createActor(machine).start();
+    }).toThrowError(/Cannot read properties of undefined/);
+  });
+
+  it('should not throw if input is not expected and not provided', () => {
+    const machine = createMachine({
+      context: () => {
+        return { count: 42 };
+      }
+    });
 
-    expect(snapshot.status).toBe('error');
+    expect(() => {
+      createActor(machine).start();
+    }).not.toThrowError();
   });
 
   it('should be a type error if input is not expected yet provided', () => {
diff --git a/packages/core/test/interpreter.test.ts b/packages/core/test/interpreter.test.ts
index be0cfed8a3..51017574fb 100644
--- a/packages/core/test/interpreter.test.ts
+++ b/packages/core/test/interpreter.test.ts
@@ -722,11 +722,10 @@ describe('interpreter', () => {
       }
     };
 
-    const snapshot = createActor(createMachine(invalidMachine)).getSnapshot();
-
-    expect(snapshot.status).toBe('error');
-    expect(snapshot.error).toMatchInlineSnapshot(
-      `[Error: Initial state node "create" not found on parent state node #fetchMachine]`
+    expect(() => {
+      createActor(createMachine(invalidMachine)).start();
+    }).toThrowErrorMatchingInlineSnapshot(
+      `"Initial state node "create" not found on parent state node #fetchMachine"`
     );
   });
 
diff --git a/packages/core/test/machine.test.ts b/packages/core/test/machine.test.ts
index b28f389351..b221512b13 100644
--- a/packages/core/test/machine.test.ts
+++ b/packages/core/test/machine.test.ts
@@ -95,61 +95,62 @@ describe('machine', () => {
   });
 
   describe('machine.provide', () => {
-    it('should override an action', () => {
-      const originalEntry = jest.fn();
-      const overridenEntry = jest.fn();
-
+    it('should override guards and actions', () => {
       const machine = createMachine(
         {
-          entry: 'entryAction'
+          initial: 'foo',
+          context: {
+            foo: 'bar'
+          },
+          states: {
+            foo: {
+              entry: 'entryAction',
+              on: {
+                EVENT: {
+                  target: 'bar',
+                  guard: 'someCondition'
+                }
+              }
+            },
+            bar: {}
+          }
         },
         {
           actions: {
-            entryAction: originalEntry
+            entryAction: () => {
+              throw new Error('original entry');
+            }
+          },
+          guards: {
+            someCondition: () => false
           }
         }
       );
+      let shouldThrow = true;
       const differentMachine = machine.provide({
         actions: {
-          entryAction: overridenEntry
-        }
-      });
-
-      createActor(differentMachine).start();
-
-      expect(originalEntry).toHaveBeenCalledTimes(0);
-      expect(overridenEntry).toHaveBeenCalledTimes(1);
-    });
-
-    it('should override a guard', () => {
-      const originalGuard = jest.fn().mockImplementation(() => true);
-      const overridenGuard = jest.fn().mockImplementation(() => true);
-
-      const machine = createMachine(
-        {
-          on: {
-            EVENT: {
-              guard: 'someCondition',
-              actions: () => {}
+          entryAction: () => {
+            if (shouldThrow) {
+              throw new Error('new entry');
             }
           }
         },
-        {
-          guards: {
-            someCondition: originalGuard
-          }
-        }
-      );
+        guards: { someCondition: () => true }
+      });
 
-      const differentMachine = machine.provide({
-        guards: { someCondition: overridenGuard }
+      expect(createActor(differentMachine).getSnapshot().context).toEqual({
+        foo: 'bar'
       });
 
+      expect(() => {
+        createActor(differentMachine).start();
+      }).toThrowErrorMatchingInlineSnapshot(`"new entry"`);
+
+      shouldThrow = false;
       const actorRef = createActor(differentMachine).start();
       actorRef.send({ type: 'EVENT' });
 
-      expect(originalGuard).toHaveBeenCalledTimes(0);
-      expect(overridenGuard).toHaveBeenCalledTimes(1);
+      expect(actorRef.getSnapshot().value).toEqual('bar');
     });
 
     it('should not override context if not defined', () => {
diff --git a/packages/core/test/rehydration.test.ts b/packages/core/test/rehydration.test.ts
index 4978cb1973..29dce7f77d 100644
--- a/packages/core/test/rehydration.test.ts
+++ b/packages/core/test/rehydration.test.ts
@@ -7,7 +7,6 @@ import {
   assign,
   sendTo
 } from '../src/index.ts';
-import { sleep } from '@xstate-repo/jest-utils';
 
 describe('rehydration', () => {
   describe('using persisted state', () => {
@@ -325,73 +324,6 @@ describe('rehydration', () => {
     expect(spy).toHaveBeenCalled();
   });
 
-  it('should error on a rehydrated error state', async () => {
-    const machine = createMachine(
-      {
-        invoke: {
-          src: 'failure'
-        }
-      },
-      {
-        actors: {
-          failure: fromPromise(() => Promise.reject(new Error('failure')))
-        }
-      }
-    );
-
-    const actorRef = createActor(machine);
-    actorRef.subscribe({ error: function preventUnhandledErrorListener() {} });
-    actorRef.start();
-
-    // wait a macrotask for the microtask related to the promise to be processed
-    await sleep(0);
-
-    const persistedState = actorRef.getPersistedState();
-
-    const spy = jest.fn();
-    const actorRef2 = createActor(machine, { state: persistedState });
-    actorRef2.subscribe({
-      error: spy
-    });
-    actorRef2.start();
-
-    expect(spy).toHaveBeenCalled();
-  });
-
-  it(`shouldn't re-notify the parent about the error when rehydrating`, async () => {
-    const spy = jest.fn();
-
-    const machine = createMachine(
-      {
-        invoke: {
-          src: 'failure',
-          onError: {
-            actions: spy
-          }
-        }
-      },
-      {
-        actors: {
-          failure: fromPromise(() => Promise.reject(new Error('failure')))
-        }
-      }
-    );
-
-    const actorRef = createActor(machine);
-    actorRef.start();
-
-    // wait a macrotask for the microtask related to the promise to be processed
-    await sleep(0);
-
-    const persistedState = actorRef.getPersistedState();
-    spy.mockClear();
-
-    const actorRef2 = createActor(machine, { state: persistedState });
-    actorRef2.start();
-
-    expect(spy).not.toHaveBeenCalled();
-  });
-
   it('should continue syncing snapshots', () => {
     const subject = new BehaviorSubject(0);
     const subjectLogic = fromObservable(() => subject);
diff --git a/packages/xstate-solid/src/createSpawn.ts b/packages/xstate-solid/src/createSpawn.ts
index 81e7e28d55..5e04e146bb 100644
--- a/packages/xstate-solid/src/createSpawn.ts
+++ b/packages/xstate-solid/src/createSpawn.ts
@@ -16,7 +16,7 @@ export function createSpawn<
   const actorRef = createActor(logic);
 
   if (!isServer) {
-    actorRef.start();
+    actorRef.start?.();
     onCleanup(() => actorRef!.stop?.());
   }
 
