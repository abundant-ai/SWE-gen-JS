diff --git a/docs/src/rules/no-unused-labels.md b/docs/src/rules/no-unused-labels.md
index fcbe2e179..971c56722 100644
--- a/docs/src/rules/no-unused-labels.md
+++ b/docs/src/rules/no-unused-labels.md
@@ -30,8 +30,6 @@ Such labels take up space in the code and can lead to confusion by readers.
 
 This rule is aimed at eliminating unused labels.
 
-Problems reported by this rule can be fixed automatically, except when there are any comments between the label and the following statement, or when removing a label would cause the following statement to become a directive such as `"use strict"`.
-
 Examples of **incorrect** code for this rule:
 
 ::: incorrect
diff --git a/lib/rules/dot-notation.js b/lib/rules/dot-notation.js
index 21cba54e2..78f136867 100644
--- a/lib/rules/dot-notation.js
+++ b/lib/rules/dot-notation.js
@@ -133,7 +133,8 @@ module.exports = {
                 }
                 if (
                     node.computed &&
-                    astUtils.isStaticTemplateLiteral(node.property)
+                    node.property.type === "TemplateLiteral" &&
+                    node.property.expressions.length === 0
                 ) {
                     checkComputedProperty(node, node.property.quasis[0].value.cooked);
                 }
diff --git a/lib/rules/no-restricted-modules.js b/lib/rules/no-restricted-modules.js
index 4a9b0a4c0..d79bdbe57 100644
--- a/lib/rules/no-restricted-modules.js
+++ b/lib/rules/no-restricted-modules.js
@@ -5,12 +5,6 @@
  */
 "use strict";
 
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const astUtils = require("./utils/ast-utils");
-
 //------------------------------------------------------------------------------
 // Rule Definition
 //------------------------------------------------------------------------------
@@ -122,6 +116,15 @@ module.exports = {
             return node && node.type === "Literal" && typeof node.value === "string";
         }
 
+        /**
+         * Function to check if a node is a static string template literal.
+         * @param {ASTNode} node The node to check.
+         * @returns {boolean} If the node is a string template literal.
+         */
+        function isStaticTemplateLiteral(node) {
+            return node && node.type === "TemplateLiteral" && node.expressions.length === 0;
+        }
+
         /**
          * Function to check if a node is a require call.
          * @param {ASTNode} node The node to check.
@@ -141,7 +144,7 @@ module.exports = {
                 return node.value.trim();
             }
 
-            if (astUtils.isStaticTemplateLiteral(node)) {
+            if (isStaticTemplateLiteral(node)) {
                 return node.quasis[0].value.cooked.trim();
             }
 
diff --git a/lib/rules/no-unused-labels.js b/lib/rules/no-unused-labels.js
index be06b324c..9aa1067c6 100644
--- a/lib/rules/no-unused-labels.js
+++ b/lib/rules/no-unused-labels.js
@@ -5,12 +5,6 @@
 
 "use strict";
 
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const astUtils = require("./utils/ast-utils");
-
 //------------------------------------------------------------------------------
 // Rule Definition
 //------------------------------------------------------------------------------
@@ -52,45 +46,6 @@ module.exports = {
             };
         }
 
-        /**
-         * Checks if a `LabeledStatement` node is fixable.
-         * For a node to be fixable, there must be no comments between the label and the body.
-         * Furthermore, is must be possible to remove the label without turning the body statement into a
-         * directive after other fixes are applied.
-         * @param {ASTNode} node The node to evaluate.
-         * @returns {boolean} Whether or not the node is fixable.
-         */
-        function isFixable(node) {
-
-            /*
-             * Only perform a fix if there are no comments between the label and the body. This will be the case
-             * when there is exactly one token/comment (the ":") between the label and the body.
-             */
-            if (sourceCode.getTokenAfter(node.label, { includeComments: true }) !==
-                sourceCode.getTokenBefore(node.body, { includeComments: true })) {
-                return false;
-            }
-
-            // Looking for the node's deepest ancestor which is not a `LabeledStatement`.
-            let ancestor = node.parent;
-
-            while (ancestor.type === "LabeledStatement") {
-                ancestor = ancestor.parent;
-            }
-
-            if (ancestor.type === "Program" ||
-                (ancestor.type === "BlockStatement" && astUtils.isFunction(ancestor.parent))) {
-                const { body } = node;
-
-                if (body.type === "ExpressionStatement" &&
-                    ((body.expression.type === "Literal" && typeof body.expression.value === "string") ||
-                    astUtils.isStaticTemplateLiteral(body.expression))) {
-                    return false; // potential directive
-                }
-            }
-            return true;
-        }
-
         /**
          * Removes the top of the stack.
          * At the same time, this reports the label if it's never used.
@@ -103,7 +58,19 @@ module.exports = {
                     node: node.label,
                     messageId: "unused",
                     data: node.label,
-                    fix: isFixable(node) ? fixer => fixer.removeRange([node.range[0], node.body.range[0]]) : null
+                    fix(fixer) {
+
+                        /*
+                         * Only perform a fix if there are no comments between the label and the body. This will be the case
+                         * when there is exactly one token/comment (the ":") between the label and the body.
+                         */
+                        if (sourceCode.getTokenAfter(node.label, { includeComments: true }) ===
+                                sourceCode.getTokenBefore(node.body, { includeComments: true })) {
+                            return fixer.removeRange([node.range[0], node.body.range[0]]);
+                        }
+
+                        return null;
+                    }
                 });
             }
 
diff --git a/lib/rules/prefer-regex-literals.js b/lib/rules/prefer-regex-literals.js
index eca805483..39e295064 100644
--- a/lib/rules/prefer-regex-literals.js
+++ b/lib/rules/prefer-regex-literals.js
@@ -37,6 +37,15 @@ function isRegexLiteral(node) {
     return node.type === "Literal" && Object.prototype.hasOwnProperty.call(node, "regex");
 }
 
+/**
+ * Determines whether the given node is a template literal without expressions.
+ * @param {ASTNode} node Node to check.
+ * @returns {boolean} True if the node is a template literal without expressions.
+ */
+function isStaticTemplateLiteral(node) {
+    return node.type === "TemplateLiteral" && node.expressions.length === 0;
+}
+
 const validPrecedingTokens = new Set([
     "(",
     ";",
@@ -169,7 +178,7 @@ module.exports = {
             return node.type === "TaggedTemplateExpression" &&
                 astUtils.isSpecificMemberAccess(node.tag, "String", "raw") &&
                 isGlobalReference(astUtils.skipChainExpression(node.tag).object) &&
-                astUtils.isStaticTemplateLiteral(node.quasi);
+                isStaticTemplateLiteral(node.quasi);
         }
 
         /**
@@ -182,7 +191,7 @@ module.exports = {
                 return node.value;
             }
 
-            if (astUtils.isStaticTemplateLiteral(node)) {
+            if (isStaticTemplateLiteral(node)) {
                 return node.quasis[0].value.cooked;
             }
 
@@ -200,7 +209,7 @@ module.exports = {
          */
         function isStaticString(node) {
             return isStringLiteral(node) ||
-                astUtils.isStaticTemplateLiteral(node) ||
+                isStaticTemplateLiteral(node) ||
                 isStringRawTaggedStaticTemplateLiteral(node);
         }
 
diff --git a/lib/rules/utils/ast-utils.js b/lib/rules/utils/ast-utils.js
index b6479cfa2..aed2c42f9 100644
--- a/lib/rules/utils/ast-utils.js
+++ b/lib/rules/utils/ast-utils.js
@@ -2123,15 +2123,6 @@ module.exports = {
         return OCTAL_OR_NON_OCTAL_DECIMAL_ESCAPE_PATTERN.test(rawString);
     },
 
-    /**
-     * Determines whether the given node is a template literal without expressions.
-     * @param {ASTNode} node Node to check.
-     * @returns {boolean} True if the node is a template literal without expressions.
-     */
-    isStaticTemplateLiteral(node) {
-        return node.type === "TemplateLiteral" && node.expressions.length === 0;
-    },
-
     isReferenceToGlobalVariable,
     isLogicalExpression,
     isCoalesceExpression,
diff --git a/lib/rules/valid-typeof.js b/lib/rules/valid-typeof.js
index 3818dafea..82af130f9 100644
--- a/lib/rules/valid-typeof.js
+++ b/lib/rules/valid-typeof.js
@@ -4,12 +4,6 @@
  */
 "use strict";
 
-//------------------------------------------------------------------------------
-// Requirements
-//------------------------------------------------------------------------------
-
-const astUtils = require("./utils/ast-utils");
-
 //------------------------------------------------------------------------------
 // Rule Definition
 //------------------------------------------------------------------------------
@@ -94,7 +88,7 @@ module.exports = {
                     if (parent.type === "BinaryExpression" && OPERATORS.has(parent.operator)) {
                         const sibling = parent.left === node ? parent.right : parent.left;
 
-                        if (sibling.type === "Literal" || astUtils.isStaticTemplateLiteral(sibling)) {
+                        if (sibling.type === "Literal" || sibling.type === "TemplateLiteral" && !sibling.expressions.length) {
                             const value = sibling.type === "Literal" ? sibling.value : sibling.quasis[0].value.cooked;
 
                             if (!VALID_TYPES.has(value)) {
diff --git a/lib/rules/yoda.js b/lib/rules/yoda.js
index af8f52518..60a6ad2f2 100644
--- a/lib/rules/yoda.js
+++ b/lib/rules/yoda.js
@@ -58,13 +58,22 @@ function isNegativeNumericLiteral(node) {
     );
 }
 
+/**
+ * Determines whether a node is a Template Literal which can be determined statically.
+ * @param {ASTNode} node Node to test
+ * @returns {boolean} True if the node is a Template Literal without expression.
+ */
+function isStaticTemplateLiteral(node) {
+    return node.type === "TemplateLiteral" && node.expressions.length === 0;
+}
+
 /**
  * Determines whether a non-Literal node should be treated as a single Literal node.
  * @param {ASTNode} node Node to test
  * @returns {boolean} True if the node should be treated as a single Literal node.
  */
 function looksLikeLiteral(node) {
-    return isNegativeNumericLiteral(node) || astUtils.isStaticTemplateLiteral(node);
+    return isNegativeNumericLiteral(node) || isStaticTemplateLiteral(node);
 }
 
 /**
@@ -91,7 +100,7 @@ function getNormalizedLiteral(node) {
         };
     }
 
-    if (astUtils.isStaticTemplateLiteral(node)) {
+    if (isStaticTemplateLiteral(node)) {
         return {
             type: "Literal",
             value: node.quasis[0].value.cooked,
diff --git a/tests/lib/rules/no-unused-labels.js b/tests/lib/rules/no-unused-labels.js
index 46b7b1e13..feb6c82d5 100644
--- a/tests/lib/rules/no-unused-labels.js
+++ b/tests/lib/rules/no-unused-labels.js
@@ -73,69 +73,6 @@ ruleTester.run("no-unused-labels", rule, {
             code: "A /* comment */: foo",
             output: null,
             errors: [{ messageId: "unused" }]
-        },
-
-        // https://github.com/eslint/eslint/issues/16988
-        {
-            code: 'A: "use strict"',
-            output: null,
-            errors: [{ messageId: "unused" }]
-        },
-        {
-            code: '"use strict"; foo: "bar"',
-            output: null,
-            errors: [{ messageId: "unused" }]
-        },
-        {
-            code: 'A: ("use strict")', // Parentheses may be removed by another rule.
-            output: null,
-            errors: [{ messageId: "unused" }]
-        },
-        {
-            code: "A: `use strict`", // `use strict` may be changed to "use strict" by another rule.
-            output: null,
-            parserOptions: { ecmaVersion: 6 },
-            errors: [{ messageId: "unused" }]
-        },
-        {
-            code: "if (foo) { bar: 'baz' }",
-            output: "if (foo) { 'baz' }",
-            errors: [{ messageId: "unused" }]
-        },
-        {
-            code: "A: B: 'foo'",
-            output: "B: 'foo'",
-            errors: [{ messageId: "unused" }, { messageId: "unused" }]
-        },
-        {
-            code: "A: B: C: 'foo'",
-            output: "B: C: 'foo'", // Becomes "C: 'foo'" on the second pass.
-            errors: [{ messageId: "unused" }, { messageId: "unused" }, { messageId: "unused" }]
-        },
-        {
-            code: "A: B: C: D: 'foo'",
-            output: "B: D: 'foo'", // Becomes "D: 'foo'" on the second pass.
-            errors: [
-                { messageId: "unused" },
-                { messageId: "unused" },
-                { messageId: "unused" },
-                { messageId: "unused" }]
-        },
-        {
-            code: "A: B: C: D: E: 'foo'",
-            output: "B: D: E: 'foo'", // Becomes "E: 'foo'" on the third pass.
-            errors: [
-                { messageId: "unused" },
-                { messageId: "unused" },
-                { messageId: "unused" },
-                { messageId: "unused" },
-                { messageId: "unused" }
-            ]
-        },
-        {
-            code: "A: 42",
-            output: "42",
-            errors: [{ messageId: "unused" }]
         }
 
         /*
diff --git a/tests/lib/rules/utils/ast-utils.js b/tests/lib/rules/utils/ast-utils.js
index 59486b237..b0b9cb57c 100644
--- a/tests/lib/rules/utils/ast-utils.js
+++ b/tests/lib/rules/utils/ast-utils.js
@@ -1857,22 +1857,4 @@ describe("ast-utils", () => {
             });
         });
     });
-
-    describe("isStaticTemplateLiteral", () => {
-        const expectedResults = {
-            "``": true,
-            "`foo`": true,
-            "`foo${bar}`": false,
-            "\"foo\"": false,
-            "foo`bar`": false
-        };
-
-        Object.entries(expectedResults).forEach(([code, expectedResult]) => {
-            it(`returns ${expectedResult} for ${code}`, () => {
-                const ast = espree.parse(code, { ecmaVersion: 6 });
-
-                assert.strictEqual(astUtils.isStaticTemplateLiteral(ast.body[0].expression), expectedResult);
-            });
-        });
-    });
 });
