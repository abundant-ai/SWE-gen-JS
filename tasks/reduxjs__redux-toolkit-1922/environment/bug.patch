diff --git a/docs/api/createEntityAdapter.mdx b/docs/api/createEntityAdapter.mdx
index 74f15e8b..922042ec 100644
--- a/docs/api/createEntityAdapter.mdx
+++ b/docs/api/createEntityAdapter.mdx
@@ -222,7 +222,7 @@ All three options will insert _new_ entities into the list. However they differ
 
 - `addOne` and `addMany` will do nothing with the new entity
 - `setOne` and `setMany` will completely replace the old entity with the new one. This will also get rid of any properties on the entity that are not present in the new version of said entity.
-- `upsertOne` and `upsertMany` will do a shallow copy to merge the old and new entities overwritng existing values, adding any that were not there and not touching properties not provided in the new entity.
+- `upsertOne` and `upsertMany` will do a shallow copy to merge the old and new entities overwriting existing values, adding any that were not there and not touching properties not provided in the new entity.
 
 :::
 
diff --git a/docs/rtk-query/api/created-api/hooks.mdx b/docs/rtk-query/api/created-api/hooks.mdx
index d46efff2..d6a94264 100644
--- a/docs/rtk-query/api/created-api/hooks.mdx
+++ b/docs/rtk-query/api/created-api/hooks.mdx
@@ -490,7 +490,7 @@ type UseLazyQueryOptions = {
   selectFromResult?: (result: UseQueryStateDefaultResult) => any
 }
 
-type UseLazyQueryTrigger<T> = (arg: any) => Promise<
+type UseLazyQueryTrigger<T> = (arg: any, preferCacheValue?: boolean) => Promise<
   QueryResultSelectorResult
 > & {
   arg: unknown // Whatever argument was provided to the query
@@ -559,7 +559,10 @@ type UseLazyQuerySubscriptionOptions = {
   refetchOnFocus?: boolean
 }
 
-type UseLazyQuerySubscriptionTrigger = (arg: any) => void
+type UseLazyQuerySubscriptionTrigger = (
+  arg: any,
+  preferCacheValue?: boolean
+) => void
 ```
 
 - **Parameters**
diff --git a/docs/rtk-query/api/fetchBaseQuery.mdx b/docs/rtk-query/api/fetchBaseQuery.mdx
index 389b99ef..e40ebf65 100644
--- a/docs/rtk-query/api/fetchBaseQuery.mdx
+++ b/docs/rtk-query/api/fetchBaseQuery.mdx
@@ -19,19 +19,10 @@ It takes all standard options from fetch's [`RequestInit`](https://developer.moz
   - Typically a string like `https://api.your-really-great-app.com/v1/`. If you don't provide a `baseUrl`, it defaults to a relative path from where the request is being made. You should most likely _always_ specify this.
 - `prepareHeaders` _(optional)_
 
-  - Allows you to inject headers on every request. You can specify headers at the endpoint level, but you'll typically want to set common headers like `authorization` here. As a convenience mechanism, the second argument allows you to use `getState` to access your redux store in the event you store information you'll need there such as an auth token. Additionally, it provides access to `extra`, `endpoint`, `type`, and `forced` to unlock more granular conditional behaviors.
+  - Allows you to inject headers on every request. You can specify headers at the endpoint level, but you'll typically want to set common headers like `authorization` here. As a convenience mechanism, the second argument allows you to use `getState` to access your redux store in the event you store information you'll need there such as an auth token.
 
   - ```ts title="prepareHeaders signature" no-transpile
-    ;(
-      headers: Headers,
-      api: {
-        getState: () => unknown
-        extra: unknown
-        endpoint: string
-        type: 'query' | 'mutation'
-        forced: boolean | undefined
-      }
-    ) => Headers
+    ;(headers: Headers, api: { getState: () => unknown }) => Headers
     ```
 
 - `paramsSerializer` _(optional)_
@@ -185,7 +176,7 @@ By default, `fetchBaseQuery` assumes that every request you make will be `json`,
 
 ### Parsing a Response
 
-By default, `fetchBaseQuery` assumes that every `Response` you get will be parsed as `json`. In the event that you don't want that to happen, you can specify an alternative response handler like `text`, or take complete control and use a custom function that accepts the raw `Response` object &mdash; allowing you to use any [`Body` method](https://developer.mozilla.org/en-US/docs/Web/API/Body).
+By default, `fetchBaseQuery` assumes that every `Response` you get will be parsed as `json`. In the event that you don't want that to happen, you can specify an alternative response handler like `text`, or take complete control and use a custom function that accepts the raw `Response` object &mdash; allowing you to use any [`Response` method](https://developer.mozilla.org/en-US/docs/Web/API/Response).
 
 ```ts title="Parse a Response as text"
 import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query'
diff --git a/docs/rtk-query/usage/automated-refetching.mdx b/docs/rtk-query/usage/automated-refetching.mdx
index 5a351f7c..38be5f90 100644
--- a/docs/rtk-query/usage/automated-refetching.mdx
+++ b/docs/rtk-query/usage/automated-refetching.mdx
@@ -800,7 +800,7 @@ import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query'
 import { Post, LoginResponse } from './types'
 
 const api = createApi({
-  baseQuery: fetchBaseQuery({ baseUrl: 'https://example.com' }),
+  baseQuery: fetchBaseQuery({ baseUrl: 'http://example.com' }),
   tagTypes: ['Post', 'UNAUTHORIZED', 'UNKNOWN_ERROR'],
   endpoints: (build) => ({
     postById: build.query<Post, number>({
@@ -856,7 +856,7 @@ import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query'
 import { Post, User } from './types'
 
 const api = createApi({
-  baseQuery: fetchBaseQuery({ baseUrl: 'https://example.com' }),
+  baseQuery: fetchBaseQuery({ baseUrl: 'http://example.com' }),
   tagTypes: ['Post', 'User'],
   endpoints: (build) => ({
     getPosts: build.query<Post[], void>({
@@ -920,7 +920,7 @@ function providesList<R extends { id: string | number }[], T extends string>(
 // highlight-end
 
 const api = createApi({
-  baseQuery: fetchBaseQuery({ baseUrl: 'https://example.com' }),
+  baseQuery: fetchBaseQuery({ baseUrl: 'http://example.com' }),
   tagTypes: ['Post', 'User'],
   endpoints: (build) => ({
     getPosts: build.query({
diff --git a/docs/rtk-query/usage/cache-behavior.mdx b/docs/rtk-query/usage/cache-behavior.mdx
index d66d3067..f318521c 100644
--- a/docs/rtk-query/usage/cache-behavior.mdx
+++ b/docs/rtk-query/usage/cache-behavior.mdx
@@ -67,7 +67,7 @@ function ComponentFour() {
 
 While four components are subscribed to the endpoint, there are only three distinct combinations of endpoint + query parameters. Query parameters `1` and `2` will each have a single subscriber, while query parameter `3` has two subscribers. RTK Query will make three distinct fetches; one for each unique set of query parameters per endpoint.
 
-Data is kept in the cache as long as there is at least one active subscriber interested in that endpoint + parameter combination. When the subscriber reference count reaches zero, a timer is set, and if there are no new subscriptions to that data by the time the timer expires, the cached data will be removed. The default expiration is 60 seconds, which can be configured both for the [API definition as a whole](../api/createApi.mdx#keepunuseddatafor), as well as on a [per-endpoint](../api/createApi.mdx#keepunuseddatafor-1) basis.
+Data is kept in the cache as long as at least one active subscriber is interested in that endpoint + parameter combination. When the subscriber reference count reaches zero, a timer is set, and if there are no new subscriptions to that data by the time the timer expires, the cached data will be removed. The default expiration is 60 seconds, which can be configured both for the [API definition as a whole](../api/createApi.mdx#keepunuseddatafor), as well as on a [per-endpoint](../api/createApi.mdx#keepunuseddatafor-1) basis.
 
 If 'ComponentThree' is unmounted in the example above, regardless of how much time passes, the data will remain in the cache due to 'ComponentFour' still being subscribed to the same data, and the subscribe reference count will be `1`. However, once 'ComponentFour' unmounts, the subscriber reference count will be `0`. The data will remain in the cache for the remainder of the expiration time. If no new subscription has been created before the timer expires, the cached data will finally be removed.
 
diff --git a/docs/rtk-query/usage/code-generation.mdx b/docs/rtk-query/usage/code-generation.mdx
index 355e78e5..6c735ba1 100644
--- a/docs/rtk-query/usage/code-generation.mdx
+++ b/docs/rtk-query/usage/code-generation.mdx
@@ -29,7 +29,6 @@ We provide a package for RTK Query code generation from OpenAPI schemas. It is p
 Create an empty api using `createApi` like
 
 ```ts no-transpile title="src/store/emptyApi.ts"
-
 // Or from '@reduxjs/toolkit/query' if not using the auto-generated hooks
 import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'
 
@@ -43,8 +42,7 @@ export const emptySplitApi = createApi({
 Generate a config file (json, js or ts) with contents like
 
 ```ts no-transpile title="openapi-config.ts"
-
-import { ConfigFile } from '@rtk-query/codegen-openapi'
+import type { ConfigFile } from '@rtk-query/codegen-openapi'
 
 const config: ConfigFile = {
   schemaFile: 'https://petstore3.swagger.io/api/v3/openapi.json',
@@ -67,7 +65,6 @@ npx @rtk-query/codegen-openapi openapi-config.ts
 ### Programmatic usage
 
 ```ts no-transpile title="src/store/petApi.ts"
-
 import { generateEndpoints } from '@rtk-query/codegen-openapi'
 
 const api = await generateEndpoints({
diff --git a/docs/rtk-query/usage/customizing-queries.mdx b/docs/rtk-query/usage/customizing-queries.mdx
index 208cb45b..8ae69f29 100644
--- a/docs/rtk-query/usage/customizing-queries.mdx
+++ b/docs/rtk-query/usage/customizing-queries.mdx
@@ -271,7 +271,7 @@ const axiosBaseQuery =
 const api = createApi({
   // highlight-start
   baseQuery: axiosBaseQuery({
-    baseUrl: 'https://example.com',
+    baseUrl: 'http://example.com',
   }),
   // highlight-end
   endpoints(build) {
diff --git a/docs/rtk-query/usage/queries.mdx b/docs/rtk-query/usage/queries.mdx
index 2db3a7ac..8fe9303d 100644
--- a/docs/rtk-query/usage/queries.mdx
+++ b/docs/rtk-query/usage/queries.mdx
@@ -109,9 +109,9 @@ There are 5 query-related hooks:
 3. [`useQueryState`](../api/created-api/hooks.mdx#usequerystate)
    - Returns the query state and accepts `skip` and `selectFromResult`. Reads the request status and cached data from the Redux store.
 4. [`useLazyQuery`](../api/created-api/hooks.mdx#uselazyquery)
-   - Returns a tuple with a `fetch` function, the query result, and last promise info. Similar to `useQuery`, but with manual control over when the data fetching occurs.
+   - Returns a tuple with a `trigger` function, the query result, and last promise info. Similar to `useQuery`, but with manual control over when the data fetching occurs. **Note: the `trigger` function takes a second argument of `preferCacheValue?: boolean` in the event you want to skip making a request if cached data already exists.**
 5. [`useLazyQuerySubscription`](../api/created-api/hooks.mdx#uselazyquerysubscription)
-   - Returns a tuple with a `fetch` function, and last promise info. Similar to `useQuerySubscription`, but with manual control over when the data fetching occurs.
+   - Returns a tuple with a `trigger` function, and last promise info. Similar to `useQuerySubscription`, but with manual control over when the data fetching occurs. **Note: the `trigger` function takes a second argument of `preferCacheValue?: boolean` in the event you want to skip making a request if cached data already exists.**
 
 In practice, the standard `useQuery`-based hooks such as `useGetPostQuery` will be the primary hooks used in your application, but the other hooks are available for specific use cases.
 
diff --git a/packages/rtk-query-codegen-openapi/test/config.example.js b/packages/rtk-query-codegen-openapi/test/config.example.js
index 2fe3d69c..fb2f59a1 100644
--- a/packages/rtk-query-codegen-openapi/test/config.example.js
+++ b/packages/rtk-query-codegen-openapi/test/config.example.js
@@ -1,5 +1,5 @@
 /**
- * @type {import("@rtk-incubator/rtk-query-codegen-openapi").ConfigFile}
+ * @type {import("@rtk-query/codegen-openapi").ConfigFile}
  */
 module.exports = {
   schemaFile: './fixtures/petstore.yaml',
diff --git a/packages/rtk-query-codegen-openapi/test/config.example.ts b/packages/rtk-query-codegen-openapi/test/config.example.ts
index 5cba1fa1..ab8e93b0 100644
--- a/packages/rtk-query-codegen-openapi/test/config.example.ts
+++ b/packages/rtk-query-codegen-openapi/test/config.example.ts
@@ -1,4 +1,4 @@
-import type { ConfigFile } from '@rtk-incubator/rtk-query-codegen-openapi';
+import type { ConfigFile } from '@rtk-query/codegen-openapi';
 
 const config: ConfigFile = {
   schemaFile: './fixtures/petstore.yaml',
diff --git a/packages/rtk-query-codegen-openapi/test/mocks/server.ts b/packages/rtk-query-codegen-openapi/test/mocks/server.ts
index 327246ce..daf998e8 100644
--- a/packages/rtk-query-codegen-openapi/test/mocks/server.ts
+++ b/packages/rtk-query-codegen-openapi/test/mocks/server.ts
@@ -7,10 +7,10 @@ import petstoreYAML from '../fixtures/petstore.yaml.mock';
 // This configures a request mocking server with the given request handlers.
 
 export const server = setupServer(
-  rest.get('https://example.com/echo', (req, res, ctx) =>
+  rest.get('http://example.com/echo', (req, res, ctx) =>
     res(ctx.json({ ...req, headers: req.headers.getAllHeaders() }))
   ),
-  rest.post('https://example.com/echo', (req, res, ctx) =>
+  rest.post('http://example.com/echo', (req, res, ctx) =>
     res(ctx.json({ ...req, headers: req.headers.getAllHeaders() }))
   ),
 
diff --git a/packages/rtk-query-codegen-openapi/test/tsconfig.json b/packages/rtk-query-codegen-openapi/test/tsconfig.json
index 5ba34e09..78e8e8d3 100644
--- a/packages/rtk-query-codegen-openapi/test/tsconfig.json
+++ b/packages/rtk-query-codegen-openapi/test/tsconfig.json
@@ -2,7 +2,7 @@
   "compilerOptions": {
     "paths": {
       "@/*": ["./test/fixtures/*"],
-      "@rtk-incubator/rtk-query-codegen-openapi": ["./src"]
+      "@rtk-query/codegen-openapi": ["./src"]
     },
     "allowSyntheticDefaultImports": true,
     "esModuleInterop": true,
diff --git a/packages/toolkit/package.json b/packages/toolkit/package.json
index b91ece0f..9a6b7221 100644
--- a/packages/toolkit/package.json
+++ b/packages/toolkit/package.json
@@ -47,6 +47,7 @@
     "axios": "^0.19.2",
     "console-testing-library": "^0.3.1",
     "convert-source-map": "^1.7.0",
+    "cross-fetch": "^3.1.4",
     "esbuild": "^0.11.13",
     "eslint": "^7.25.0",
     "eslint-config-prettier": "^8.3.0",
diff --git a/packages/toolkit/src/createReducer.ts b/packages/toolkit/src/createReducer.ts
index b747cdc6..06e48467 100644
--- a/packages/toolkit/src/createReducer.ts
+++ b/packages/toolkit/src/createReducer.ts
@@ -15,6 +15,9 @@ import type { NoInfer } from './tsHelpers'
  */
 export type Actions<T extends keyof any = string> = Record<T, Action>
 
+/**
+ * @deprecated use `TypeGuard` instead
+ */
 export interface ActionMatcher<A extends AnyAction> {
   (action: AnyAction): action is A
 }
diff --git a/packages/toolkit/src/mapBuilders.ts b/packages/toolkit/src/mapBuilders.ts
index 6cda0759..81d8a9ac 100644
--- a/packages/toolkit/src/mapBuilders.ts
+++ b/packages/toolkit/src/mapBuilders.ts
@@ -2,9 +2,9 @@ import type { Action, AnyAction } from 'redux'
 import type {
   CaseReducer,
   CaseReducers,
-  ActionMatcher,
   ActionMatcherDescriptionCollection,
 } from './createReducer'
+import type { TypeGuard } from './tsHelpers'
 
 export interface TypedActionCreator<Type extends string> {
   (...args: any[]): Action<Type>
@@ -96,9 +96,9 @@ const reducer = createReducer(initialState, (builder) => {
 });
 ```
    */
-  addMatcher<A extends AnyAction>(
-    matcher: ActionMatcher<A> | ((action: AnyAction) => boolean),
-    reducer: CaseReducer<State, A>
+  addMatcher<A>(
+    matcher: TypeGuard<A> | ((action: any) => boolean),
+    reducer: CaseReducer<State, A extends AnyAction ? A : A & AnyAction>
   ): Omit<ActionReducerMapBuilder<State>, 'addCase'>
 
   /**
@@ -167,9 +167,9 @@ export function executeReducerBuilderCallback<S>(
       actionsMap[type] = reducer
       return builder
     },
-    addMatcher<A extends AnyAction>(
-      matcher: ActionMatcher<A>,
-      reducer: CaseReducer<S, A>
+    addMatcher<A>(
+      matcher: TypeGuard<A>,
+      reducer: CaseReducer<S, A extends AnyAction ? A : A & AnyAction>
     ) {
       if (process.env.NODE_ENV !== 'production') {
         if (defaultCaseReducer) {
diff --git a/packages/toolkit/src/query/core/buildMiddleware/polling.ts b/packages/toolkit/src/query/core/buildMiddleware/polling.ts
index 7f5ac3a9..a30f3f4f 100644
--- a/packages/toolkit/src/query/core/buildMiddleware/polling.ts
+++ b/packages/toolkit/src/query/core/buildMiddleware/polling.ts
@@ -19,11 +19,15 @@ export const build: SubMiddlewareBuilder = ({
       timeout?: TimeoutId
       pollingInterval: number
     }> = {}
+
     return (next) =>
       (action): any => {
         const result = next(action)
 
-        if (api.internalActions.updateSubscriptionOptions.match(action)) {
+        if (
+          api.internalActions.updateSubscriptionOptions.match(action) ||
+          api.internalActions.unsubscribeQueryResult.match(action)
+        ) {
           updatePollingInterval(action.payload, mwApi)
         }
 
@@ -99,16 +103,13 @@ export const build: SubMiddlewareBuilder = ({
       }
 
       const lowestPollingInterval = findLowestPollingInterval(subscriptions)
-      const currentPoll = currentPolls[queryCacheKey]
 
       if (!Number.isFinite(lowestPollingInterval)) {
-        if (currentPoll?.timeout) {
-          clearTimeout(currentPoll.timeout)
-        }
-        delete currentPolls[queryCacheKey]
+        cleanupPollForKey(queryCacheKey)
         return
       }
 
+      const currentPoll = currentPolls[queryCacheKey]
       const nextPollTimestamp = Date.now() + lowestPollingInterval
 
       if (!currentPoll || nextPollTimestamp < currentPoll.nextPollTimestamp) {
@@ -116,10 +117,17 @@ export const build: SubMiddlewareBuilder = ({
       }
     }
 
+    function cleanupPollForKey(key: string) {
+      const existingPoll = currentPolls[key]
+      if (existingPoll?.timeout) {
+        clearTimeout(existingPoll.timeout)
+      }
+      delete currentPolls[key]
+    }
+
     function clearPolls() {
-      for (const [key, poll] of Object.entries(currentPolls)) {
-        if (poll?.timeout) clearTimeout(poll.timeout)
-        delete currentPolls[key]
+      for (const key of Object.keys(currentPolls)) {
+        cleanupPollForKey(key)
       }
     }
   }
diff --git a/packages/toolkit/src/query/core/buildThunks.ts b/packages/toolkit/src/query/core/buildThunks.ts
index 58496877..04f6e06c 100644
--- a/packages/toolkit/src/query/core/buildThunks.ts
+++ b/packages/toolkit/src/query/core/buildThunks.ts
@@ -5,9 +5,8 @@ import type {
   BaseQueryError,
   QueryReturnValue,
 } from '../baseQueryTypes'
-import { BaseQueryArg } from '../baseQueryTypes'
 import type { RootState, QueryKeys, QuerySubstateIdentifier } from './apiState'
-import { QueryStatus, CombinedState } from './apiState'
+import { QueryStatus } from './apiState'
 import type { StartQueryActionCreatorOptions } from './buildInitiate'
 import type {
   AssertTagTypes,
@@ -18,7 +17,7 @@ import type {
   QueryDefinition,
   ResultTypeFrom,
 } from '../endpointDefinitions'
-import { calculateProvidedBy, FullTagDescription } from '../endpointDefinitions'
+import { calculateProvidedBy } from '../endpointDefinitions'
 import type { AsyncThunkPayloadCreator, Draft } from '@reduxjs/toolkit'
 import {
   isAllOf,
@@ -513,7 +512,7 @@ export function calculateProvidedByThunk(
     isFulfilled(action) ? action.payload : undefined,
     isRejectedWithValue(action) ? action.payload : undefined,
     action.meta.arg.originalArgs,
-    action.meta,
+    'baseQueryMeta' in action.meta ? action.meta.baseQueryMeta : undefined,
     assertTagType
   )
 }
diff --git a/packages/toolkit/src/query/fetchBaseQuery.ts b/packages/toolkit/src/query/fetchBaseQuery.ts
index 4e1e1159..bd606b7c 100644
--- a/packages/toolkit/src/query/fetchBaseQuery.ts
+++ b/packages/toolkit/src/query/fetchBaseQuery.ts
@@ -113,10 +113,7 @@ export type FetchBaseQueryArgs = {
   baseUrl?: string
   prepareHeaders?: (
     headers: Headers,
-    api: Pick<
-      BaseQueryApi,
-      'getState' | 'extra' | 'endpoint' | 'type' | 'forced'
-    >
+    api: Pick<BaseQueryApi, 'getState' | 'endpoint' | 'type' | 'forced'>
   ) => MaybePromise<Headers>
   fetchFn?: (
     input: RequestInfo,
@@ -147,12 +144,12 @@ export type FetchBaseQueryMeta = { request: Request; response?: Response }
  *
  * @param {string} baseUrl
  * The base URL for an API service.
- * Typically in the format of https://example.com/
+ * Typically in the format of http://example.com/
  *
- * @param {(headers: Headers, api: { getState: () => unknown; extra: unknown; endpoint: string; type: 'query' | 'mutation'; forced: boolean; }) => Headers} prepareHeaders
+ * @param {(headers: Headers, api: { getState: () => unknown }) => Headers} prepareHeaders
  * An optional function that can be used to inject headers on requests.
- * Provides a Headers object, as well as most of the `BaseQueryApi` (`dispatch` is not available).
- * Useful for setting authentication or headers that need to be set conditionally.
+ * Provides a Headers object, as well as the `getState` function from the
+ * redux store. Can be useful for authentication.
  *
  * @link https://developer.mozilla.org/en-US/docs/Web/API/Headers
  *
@@ -160,7 +157,7 @@ export type FetchBaseQueryMeta = { request: Request; response?: Response }
  * Accepts a custom `fetch` function if you do not want to use the default on the window.
  * Useful in SSR environments if you need to use a library such as `isomorphic-fetch` or `cross-fetch`
  *
- * @param {(params: Record<string, unknown>) => string} paramsSerializer
+ * @param {(params: Record<string, unknown> => string} paramsSerializer
  * An optional function that can be used to stringify querystring parameters.
  */
 export function fetchBaseQuery({
@@ -181,8 +178,7 @@ export function fetchBaseQuery({
       'Warning: `fetch` is not available. Please supply a custom `fetchFn` property to use `fetchBaseQuery` on SSR environments.'
     )
   }
-  return async (arg, api) => {
-    const { signal, getState, extra, endpoint, forced, type } = api
+  return async (arg, { signal, getState, endpoint, forced, type }) => {
     let meta: FetchBaseQueryMeta | undefined
     let {
       url,
@@ -204,7 +200,7 @@ export function fetchBaseQuery({
 
     config.headers = await prepareHeaders(
       new Headers(stripUndefined(headers)),
-      { getState, extra, endpoint, forced, type }
+      { getState, endpoint, forced, type }
     )
 
     // Only set the content-type to json if appropriate. Will not be true for FormData, ArrayBuffer, Blob, etc.
diff --git a/packages/toolkit/src/query/react/buildHooks.ts b/packages/toolkit/src/query/react/buildHooks.ts
index b3a852e6..15e29779 100644
--- a/packages/toolkit/src/query/react/buildHooks.ts
+++ b/packages/toolkit/src/query/react/buildHooks.ts
@@ -185,7 +185,7 @@ export type UseLazyQueryLastPromiseInfo<
  *
  * #### Note
  *
- * When the trigger function returned from a LazyQuery, it always initiates a new request to the server even if there is cached data. Set `preferCacheValue`(the second argument to the function) as true if you want it to use cache.
+ * When the trigger function returned from a LazyQuery, it always initiates a new request to the server even if there is cached data. Set `preferCacheValue`(the second argument to the function) as `true` if you want it to immediately return a cached value if one exists.
  */
 export type UseLazyQuery<D extends QueryDefinition<any, any, any, any>> = <
   R = UseQueryStateDefaultResult<D>
diff --git a/packages/toolkit/src/query/tests/buildHooks.test.tsx b/packages/toolkit/src/query/tests/buildHooks.test.tsx
index acfc6a99..463c436d 100644
--- a/packages/toolkit/src/query/tests/buildHooks.test.tsx
+++ b/packages/toolkit/src/query/tests/buildHooks.test.tsx
@@ -1751,11 +1751,11 @@ describe('hooks with createApi defaults set', () => {
       posts = [...initialPosts]
 
       const handlers = [
-        rest.get('https://example.com/posts', (req, res, ctx) => {
+        rest.get('http://example.com/posts', (req, res, ctx) => {
           return res(ctx.json(posts))
         }),
         rest.put<Partial<Post>>(
-          'https://example.com/post/:id',
+          'http://example.com/post/:id',
           (req, res, ctx) => {
             const id = Number(req.params.id)
             const idx = posts.findIndex((post) => post.id === id)
@@ -1775,7 +1775,7 @@ describe('hooks with createApi defaults set', () => {
             return res(ctx.json(posts))
           }
         ),
-        rest.post('https://example.com/post', (req, res, ctx) => {
+        rest.post('http://example.com/post', (req, res, ctx) => {
           let post = req.body as Omit<Post, 'id'>
           startingId += 1
           posts.concat({
@@ -1799,7 +1799,7 @@ describe('hooks with createApi defaults set', () => {
     type PostsResponse = Post[]
 
     const api = createApi({
-      baseQuery: fetchBaseQuery({ baseUrl: 'https://example.com/' }),
+      baseQuery: fetchBaseQuery({ baseUrl: 'http://example.com/' }),
       tagTypes: ['Posts'],
       endpoints: (build) => ({
         getPosts: build.query<PostsResponse, void>({
diff --git a/packages/toolkit/src/query/tests/cacheCollection.test.ts b/packages/toolkit/src/query/tests/cacheCollection.test.ts
index e1b7d459..b6c3026f 100644
--- a/packages/toolkit/src/query/tests/cacheCollection.test.ts
+++ b/packages/toolkit/src/query/tests/cacheCollection.test.ts
@@ -16,7 +16,7 @@ beforeEach(() => {
 test(`query: await cleanup, defaults`, async () => {
   const { store, api } = storeForApi(
     createApi({
-      baseQuery: fetchBaseQuery({ baseUrl: 'https://example.com' }),
+      baseQuery: fetchBaseQuery({ baseUrl: 'http://example.com' }),
       endpoints: (build) => ({
         query: build.query<unknown, string>({
           query: () => '/success',
@@ -35,7 +35,7 @@ test(`query: await cleanup, defaults`, async () => {
 test(`query: await cleanup, keepUnusedDataFor set`, async () => {
   const { store, api } = storeForApi(
     createApi({
-      baseQuery: fetchBaseQuery({ baseUrl: 'https://example.com' }),
+      baseQuery: fetchBaseQuery({ baseUrl: 'http://example.com' }),
       endpoints: (build) => ({
         query: build.query<unknown, string>({
           query: () => '/success',
@@ -55,7 +55,7 @@ test(`query: await cleanup, keepUnusedDataFor set`, async () => {
 describe(`query: await cleanup, keepUnusedDataFor set`, () => {
   const { store, api } = storeForApi(
     createApi({
-      baseQuery: fetchBaseQuery({ baseUrl: 'https://example.com' }),
+      baseQuery: fetchBaseQuery({ baseUrl: 'http://example.com' }),
       endpoints: (build) => ({
         query: build.query<unknown, string>({
           query: () => '/success',
diff --git a/packages/toolkit/src/query/tests/cacheLifecycle.test.ts b/packages/toolkit/src/query/tests/cacheLifecycle.test.ts
index 86898a7e..6d01ff63 100644
--- a/packages/toolkit/src/query/tests/cacheLifecycle.test.ts
+++ b/packages/toolkit/src/query/tests/cacheLifecycle.test.ts
@@ -8,7 +8,7 @@ beforeAll(() => {
 })
 
 const api = createApi({
-  baseQuery: fetchBaseQuery({ baseUrl: 'https://example.com' }),
+  baseQuery: fetchBaseQuery({ baseUrl: 'http://example.com' }),
   endpoints: () => ({}),
 })
 const storeRef = setupApiStore(api)
diff --git a/packages/toolkit/src/query/tests/createApi.test.ts b/packages/toolkit/src/query/tests/createApi.test.ts
index 9b4071aa..a7c1fbbc 100644
--- a/packages/toolkit/src/query/tests/createApi.test.ts
+++ b/packages/toolkit/src/query/tests/createApi.test.ts
@@ -5,6 +5,8 @@ import type {
   QueryDefinition,
 } from '@reduxjs/toolkit/query'
 import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query'
+import type { FetchBaseQueryMeta } from '@reduxjs/toolkit/dist/query/fetchBaseQuery'
+
 import {
   ANY,
   expectType,
@@ -503,7 +505,7 @@ describe('additional transformResponse behaviors', () => {
   type SuccessResponse = { value: 'success' }
   type EchoResponseData = { banana: 'bread' }
   const api = createApi({
-    baseQuery: fetchBaseQuery({ baseUrl: 'https://example.com' }),
+    baseQuery: fetchBaseQuery({ baseUrl: 'http://example.com' }),
     endpoints: (build) => ({
       echo: build.mutation({
         query: () => ({ method: 'PUT', url: '/echo' }),
@@ -541,7 +543,7 @@ describe('additional transformResponse behaviors', () => {
       query: build.query<SuccessResponse & EchoResponseData, void>({
         query: () => '/success',
         transformResponse: async (response: SuccessResponse) => {
-          const res = await fetch('https://example.com/echo', {
+          const res = await fetch('http://example.com/echo', {
             method: 'POST',
             body: JSON.stringify({ banana: 'bread' }),
           }).then((res) => res.json())
@@ -640,7 +642,7 @@ describe('query endpoint lifecycles - onStart, onSuccess, onError', () => {
 
   type SuccessResponse = { value: 'success' }
   const api = createApi({
-    baseQuery: fetchBaseQuery({ baseUrl: 'https://example.com' }),
+    baseQuery: fetchBaseQuery({ baseUrl: 'http://example.com' }),
     endpoints: (build) => ({
       echo: build.mutation({
         query: () => ({ method: 'PUT', url: '/echo' }),
@@ -677,7 +679,7 @@ describe('query endpoint lifecycles - onStart, onSuccess, onError', () => {
   test('query lifecycle events fire properly', async () => {
     // We intentionally fail the first request so we can test all lifecycles
     server.use(
-      rest.get('https://example.com/success', (_, res, ctx) =>
+      rest.get('http://example.com/success', (_, res, ctx) =>
         res.once(ctx.status(500), ctx.json({ value: 'failed' }))
       )
     )
@@ -701,7 +703,7 @@ describe('query endpoint lifecycles - onStart, onSuccess, onError', () => {
   test('mutation lifecycle events fire properly', async () => {
     // We intentionally fail the first request so we can test all lifecycles
     server.use(
-      rest.post('https://example.com/success', (_, res, ctx) =>
+      rest.post('http://example.com/success', (_, res, ctx) =>
         res.once(ctx.status(500), ctx.json({ value: 'failed' }))
       )
     )
@@ -722,3 +724,42 @@ describe('query endpoint lifecycles - onStart, onSuccess, onError', () => {
     expect(storeRef.store.getState().testReducer.count).toBe(1)
   })
 })
+
+test('providesTags and invalidatesTags can use baseQueryMeta', async () => {
+  let _meta: FetchBaseQueryMeta | undefined
+
+  type SuccessResponse = { value: 'success' }
+
+  const api = createApi({
+    baseQuery: fetchBaseQuery({ baseUrl: 'http://example.com' }),
+    tagTypes: ['success'],
+    endpoints: (build) => ({
+      query: build.query<SuccessResponse, void>({
+        query: () => '/success',
+        providesTags: (_result, _error, _arg, meta) => {
+          _meta = meta
+          return ['success']
+        },
+      }),
+      mutation: build.mutation<SuccessResponse, void>({
+        query: () => ({ url: '/success', method: 'POST' }),
+        invalidatesTags: (_result, _error, _arg, meta) => {
+          _meta = meta
+          return ['success']
+        },
+      }),
+    }),
+  })
+
+  const storeRef = setupApiStore(api)
+
+  await storeRef.store.dispatch(api.endpoints.query.initiate())
+
+  expect('request' in _meta! && 'response' in _meta!).toBe(true)
+
+  _meta = undefined
+
+  await storeRef.store.dispatch(api.endpoints.mutation.initiate())
+
+  expect('request' in _meta! && 'response' in _meta!).toBe(true)
+})
diff --git a/packages/toolkit/src/query/tests/devWarnings.test.tsx b/packages/toolkit/src/query/tests/devWarnings.test.tsx
index 253c79c1..6fd53679 100644
--- a/packages/toolkit/src/query/tests/devWarnings.test.tsx
+++ b/packages/toolkit/src/query/tests/devWarnings.test.tsx
@@ -20,7 +20,7 @@ afterEach(() => {
   restore()
 })
 
-const baseUrl = 'https://example.com'
+const baseUrl = 'http://example.com'
 
 function createApis() {
   const api1 = createApi({
diff --git a/packages/toolkit/src/query/tests/errorHandling.test.tsx b/packages/toolkit/src/query/tests/errorHandling.test.tsx
index 5d19e5d1..6b599981 100644
--- a/packages/toolkit/src/query/tests/errorHandling.test.tsx
+++ b/packages/toolkit/src/query/tests/errorHandling.test.tsx
@@ -13,7 +13,7 @@ import { useDispatch } from 'react-redux'
 import type { AnyAction, ThunkDispatch } from '@reduxjs/toolkit'
 import type { BaseQueryApi } from '../baseQueryTypes'
 
-const baseQuery = fetchBaseQuery({ baseUrl: 'https://example.com' })
+const baseQuery = fetchBaseQuery({ baseUrl: 'http://example.com' })
 
 const api = createApi({
   baseQuery,
@@ -76,7 +76,7 @@ describe('fetchBaseQuery', () => {
 describe('query error handling', () => {
   test('success', async () => {
     server.use(
-      rest.get('https://example.com/query', (_, res, ctx) =>
+      rest.get('http://example.com/query', (_, res, ctx) =>
         res(ctx.json({ value: 'success' }))
       )
     )
@@ -97,7 +97,7 @@ describe('query error handling', () => {
 
   test('error', async () => {
     server.use(
-      rest.get('https://example.com/query', (_, res, ctx) =>
+      rest.get('http://example.com/query', (_, res, ctx) =>
         res(ctx.status(500), ctx.json({ value: 'error' }))
       )
     )
@@ -121,7 +121,7 @@ describe('query error handling', () => {
 
   test('success -> error', async () => {
     server.use(
-      rest.get('https://example.com/query', (_, res, ctx) =>
+      rest.get('http://example.com/query', (_, res, ctx) =>
         res(ctx.json({ value: 'success' }))
       )
     )
@@ -140,7 +140,7 @@ describe('query error handling', () => {
     )
 
     server.use(
-      rest.get('https://example.com/query', (_, res, ctx) =>
+      rest.get('http://example.com/query', (_, res, ctx) =>
         res.once(ctx.status(500), ctx.json({ value: 'error' }))
       )
     )
@@ -165,12 +165,12 @@ describe('query error handling', () => {
 
   test('error -> success', async () => {
     server.use(
-      rest.get('https://example.com/query', (_, res, ctx) =>
+      rest.get('http://example.com/query', (_, res, ctx) =>
         res(ctx.json({ value: 'success' }))
       )
     )
     server.use(
-      rest.get('https://example.com/query', (_, res, ctx) =>
+      rest.get('http://example.com/query', (_, res, ctx) =>
         res.once(ctx.status(500), ctx.json({ value: 'error' }))
       )
     )
@@ -208,7 +208,7 @@ describe('query error handling', () => {
 describe('mutation error handling', () => {
   test('success', async () => {
     server.use(
-      rest.post('https://example.com/mutation', (_, res, ctx) =>
+      rest.post('http://example.com/mutation', (_, res, ctx) =>
         res(ctx.json({ value: 'success' }))
       )
     )
@@ -233,7 +233,7 @@ describe('mutation error handling', () => {
 
   test('error', async () => {
     server.use(
-      rest.post('https://example.com/mutation', (_, res, ctx) =>
+      rest.post('http://example.com/mutation', (_, res, ctx) =>
         res(ctx.status(500), ctx.json({ value: 'error' }))
       )
     )
@@ -261,7 +261,7 @@ describe('mutation error handling', () => {
 
   test('success -> error', async () => {
     server.use(
-      rest.post('https://example.com/mutation', (_, res, ctx) =>
+      rest.post('http://example.com/mutation', (_, res, ctx) =>
         res(ctx.json({ value: 'success' }))
       )
     )
@@ -286,7 +286,7 @@ describe('mutation error handling', () => {
     }
 
     server.use(
-      rest.post('https://example.com/mutation', (_, res, ctx) =>
+      rest.post('http://example.com/mutation', (_, res, ctx) =>
         res.once(ctx.status(500), ctx.json({ value: 'error' }))
       )
     )
@@ -314,12 +314,12 @@ describe('mutation error handling', () => {
 
   test('error -> success', async () => {
     server.use(
-      rest.post('https://example.com/mutation', (_, res, ctx) =>
+      rest.post('http://example.com/mutation', (_, res, ctx) =>
         res(ctx.json({ value: 'success' }))
       )
     )
     server.use(
-      rest.post('https://example.com/mutation', (_, res, ctx) =>
+      rest.post('http://example.com/mutation', (_, res, ctx) =>
         res.once(ctx.status(500), ctx.json({ value: 'error' }))
       )
     )
@@ -403,7 +403,7 @@ describe('custom axios baseQuery', () => {
   type SuccessResponse = { value: 'success' }
   const api = createApi({
     baseQuery: axiosBaseQuery({
-      baseUrl: 'https://example.com',
+      baseUrl: 'http://example.com',
     }),
     endpoints(build) {
       return {
@@ -433,7 +433,7 @@ describe('custom axios baseQuery', () => {
 
   test('axios errors behave as expected', async () => {
     server.use(
-      rest.get('https://example.com/success', (_, res, ctx) =>
+      rest.get('http://example.com/success', (_, res, ctx) =>
         res(ctx.status(500), ctx.json({ value: 'error' }))
       )
     )
@@ -458,7 +458,7 @@ describe('error handling in a component', () => {
   const mockSuccessResponse = { value: 'success' }
 
   const api = createApi({
-    baseQuery: fetchBaseQuery({ baseUrl: 'https://example.com' }),
+    baseQuery: fetchBaseQuery({ baseUrl: 'http://example.com' }),
     endpoints: (build) => ({
       update: build.mutation<typeof mockSuccessResponse, any>({
         query: () => ({ url: 'success' }),
@@ -472,7 +472,7 @@ describe('error handling in a component', () => {
 
   test('a mutation is unwrappable and has the correct types', async () => {
     server.use(
-      rest.get('https://example.com/success', (_, res, ctx) =>
+      rest.get('http://example.com/success', (_, res, ctx) =>
         res.once(ctx.status(500), ctx.json(mockErrorResponse))
       )
     )
diff --git a/packages/toolkit/src/query/tests/fetchBaseQuery.test.tsx b/packages/toolkit/src/query/tests/fetchBaseQuery.test.tsx
index ab3a3903..9007a2dc 100644
--- a/packages/toolkit/src/query/tests/fetchBaseQuery.test.tsx
+++ b/packages/toolkit/src/query/tests/fetchBaseQuery.test.tsx
@@ -2,9 +2,7 @@ import { createSlice } from '@reduxjs/toolkit'
 import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query'
 import { setupApiStore } from './helpers'
 import { server } from './mocks/server'
-// @ts-ignore
-import nodeFetch from 'node-fetch'
-
+import { default as crossFetch } from 'cross-fetch'
 import { rest } from 'msw'
 import queryString from 'query-string'
 import type { BaseQueryApi } from '../baseQueryTypes'
@@ -15,7 +13,7 @@ const defaultHeaders: Record<string, string> = {
   delete2: '1',
 }
 
-const baseUrl = 'https://example.com'
+const baseUrl = 'http://example.com'
 
 // @ts-ignore
 const fetchFn = jest.fn<Promise<any>, any[]>(global.fetch)
@@ -138,7 +136,7 @@ describe('fetchBaseQuery', () => {
   describe('non-JSON-body', () => {
     it('success: should return data ("text" responseHandler)', async () => {
       server.use(
-        rest.get('https://example.com/success', (_, res, ctx) =>
+        rest.get('http://example.com/success', (_, res, ctx) =>
           res.once(ctx.text(`this is not json!`))
         )
       )
@@ -158,7 +156,7 @@ describe('fetchBaseQuery', () => {
 
     it('success: should fail gracefully (default="json" responseHandler)', async () => {
       server.use(
-        rest.get('https://example.com/success', (_, res, ctx) =>
+        rest.get('http://example.com/success', (_, res, ctx) =>
           res.once(ctx.text(`this is not json!`))
         )
       )
@@ -179,7 +177,7 @@ describe('fetchBaseQuery', () => {
 
     it('server error: should fail normally with a 500 status ("text" responseHandler)', async () => {
       server.use(
-        rest.get('https://example.com/error', (_, res, ctx) =>
+        rest.get('http://example.com/error', (_, res, ctx) =>
           res(ctx.status(500), ctx.text(`this is not json!`))
         )
       )
@@ -202,7 +200,7 @@ describe('fetchBaseQuery', () => {
 
     it('server error: should fail gracefully (default="json" responseHandler)', async () => {
       server.use(
-        rest.get('https://example.com/error', (_, res, ctx) =>
+        rest.get('http://example.com/error', (_, res, ctx) =>
           res(ctx.status(500), ctx.text(`this is not json!`))
         )
       )
@@ -538,54 +536,6 @@ describe('fetchBaseQuery', () => {
 
       expect(request.headers['authorization']).toBe(`Bearer ${token}`)
     })
-
-    test('prepareHeaders provides extra api information for getState, extra, endpoint, type and forced', async () => {
-      let _getState, _extra, _endpoint, _type, _forced
-
-      const baseQuery = fetchBaseQuery({
-        baseUrl,
-        fetchFn: fetchFn as any,
-        prepareHeaders: (
-          headers,
-          { getState, extra, endpoint, type, forced }
-        ) => {
-          _getState = getState
-          _endpoint = endpoint
-          _type = type
-          _forced = forced
-          _extra = extra
-
-          return headers
-        },
-      })
-
-      const fakeAuth0Client = {
-        getTokenSilently: async () => 'fakeToken',
-      }
-
-      const doRequest = async () =>
-        baseQuery(
-          { url: '/echo' },
-          {
-            signal: new AbortController().signal,
-            dispatch: storeRef.store.dispatch,
-            getState: storeRef.store.getState,
-            extra: fakeAuth0Client,
-            type: 'query',
-            forced: true,
-            endpoint: 'someEndpointName',
-          },
-          {}
-        )
-
-      await doRequest()
-
-      expect(_getState).toBeDefined()
-      expect(_endpoint).toBe('someEndpointName')
-      expect(_type).toBe('query')
-      expect(_forced).toBe(true)
-      expect(_extra).toBe(fakeAuth0Client)
-    })
   })
 
   test('lets a header be undefined', async () => {
@@ -634,13 +584,14 @@ describe('fetchBaseQuery', () => {
 
 describe('fetchFn', () => {
   test('accepts a custom fetchFn', async () => {
-    const baseUrl = 'https://example.com'
+    const baseUrl = 'http://example.com'
     const params = new URLSearchParams({ apple: 'fruit' })
 
     const baseQuery = fetchBaseQuery({
       baseUrl,
-      fetchFn: nodeFetch as any,
+      fetchFn: crossFetch,
     })
+
     let request: any
     ;({ data: request } = await baseQuery(
       { url: '/echo', params },
@@ -652,7 +603,7 @@ describe('fetchFn', () => {
   })
 
   test('respects mocking window.fetch after a fetch base query is created', async () => {
-    const baseUrl = 'https://example.com'
+    const baseUrl = 'http://example.com'
     const baseQuery = fetchBaseQuery({ baseUrl })
 
     const fakeResponse = {
diff --git a/packages/toolkit/src/query/tests/matchers.test.tsx b/packages/toolkit/src/query/tests/matchers.test.tsx
index 71aa7dea..245e9297 100644
--- a/packages/toolkit/src/query/tests/matchers.test.tsx
+++ b/packages/toolkit/src/query/tests/matchers.test.tsx
@@ -18,7 +18,7 @@ interface ArgType {
   count: 3
 }
 
-const baseQuery = fetchBaseQuery({ baseUrl: 'https://example.com' })
+const baseQuery = fetchBaseQuery({ baseUrl: 'http://example.com' })
 const api = createApi({
   baseQuery,
   endpoints(build) {
diff --git a/packages/toolkit/src/query/tests/mocks/server.ts b/packages/toolkit/src/query/tests/mocks/server.ts
index 62d1c350..22cfecdc 100644
--- a/packages/toolkit/src/query/tests/mocks/server.ts
+++ b/packages/toolkit/src/query/tests/mocks/server.ts
@@ -14,26 +14,26 @@ export const posts: Record<number, Post> = {
 }
 
 export const server = setupServer(
-  rest.get('https://example.com/echo', (req, res, ctx) =>
+  rest.get('http://example.com/echo', (req, res, ctx) =>
     res(ctx.json({ ...req, headers: req.headers.all() }))
   ),
-  rest.post('https://example.com/echo', (req, res, ctx) =>
+  rest.post('http://example.com/echo', (req, res, ctx) =>
     res(ctx.json({ ...req, headers: req.headers.all() }))
   ),
-  rest.get('https://example.com/success', (_, res, ctx) =>
+  rest.get('http://example.com/success', (_, res, ctx) =>
     res(ctx.json({ value: 'success' }))
   ),
-  rest.post('https://example.com/success', (_, res, ctx) =>
+  rest.post('http://example.com/success', (_, res, ctx) =>
     res(ctx.json({ value: 'success' }))
   ),
-  rest.get('https://example.com/empty', (_, res, ctx) => res(ctx.body(''))),
-  rest.get('https://example.com/error', (_, res, ctx) =>
+  rest.get('http://example.com/empty', (_, res, ctx) => res(ctx.body(''))),
+  rest.get('http://example.com/error', (_, res, ctx) =>
     res(ctx.status(500), ctx.json({ value: 'error' }))
   ),
-  rest.post('https://example.com/error', (_, res, ctx) =>
+  rest.post('http://example.com/error', (_, res, ctx) =>
     res(ctx.status(500), ctx.json({ value: 'error' }))
   ),
-  rest.get('https://example.com/nonstandard-error', (_, res, ctx) =>
+  rest.get('http://example.com/nonstandard-error', (_, res, ctx) =>
     res(
       ctx.status(200),
       ctx.json({
@@ -42,19 +42,19 @@ export const server = setupServer(
       })
     )
   ),
-  rest.get('https://example.com/mirror', (req, res, ctx) =>
+  rest.get('http://example.com/mirror', (req, res, ctx) =>
     res(ctx.json(req.params))
   ),
-  rest.post('https://example.com/mirror', (req, res, ctx) =>
+  rest.post('http://example.com/mirror', (req, res, ctx) =>
     res(ctx.json(req.params))
   ),
-  rest.get('https://example.com/posts/random', (req, res, ctx) => {
+  rest.get('http://example.com/posts/random', (req, res, ctx) => {
     // just simulate an api that returned a random ID
     const { id, ..._post } = posts[1]
     return res(ctx.json({ id }))
   }),
   rest.get<Post, any, { id: number }>(
-    'https://example.com/post/:id',
+    'http://example.com/post/:id',
     (req, res, ctx) => {
       return res(ctx.json(posts[req.params.id]))
     }
diff --git a/packages/toolkit/src/query/tests/polling.test.tsx b/packages/toolkit/src/query/tests/polling.test.tsx
new file mode 100644
index 00000000..af60e7c2
--- /dev/null
+++ b/packages/toolkit/src/query/tests/polling.test.tsx
@@ -0,0 +1,110 @@
+import { createApi } from '@reduxjs/toolkit/query'
+import { setupApiStore, waitMs } from './helpers'
+
+const mockBaseQuery = jest
+  .fn()
+  .mockImplementation((args: any) => ({ data: args }))
+
+const api = createApi({
+  baseQuery: mockBaseQuery,
+  tagTypes: ['Posts'],
+  endpoints: (build) => ({
+    getPosts: build.query<unknown, number>({
+      query(pageNumber) {
+        return { url: 'posts', params: pageNumber }
+      },
+      providesTags: ['Posts'],
+    }),
+  }),
+})
+const { getPosts } = api.endpoints
+
+const storeRef = setupApiStore(api)
+
+const getSubscribersForQueryCacheKey = (queryCacheKey: string) =>
+  storeRef.store.getState()[api.reducerPath].subscriptions[queryCacheKey] || {}
+const createSubscriptionGetter = (queryCacheKey: string) => () =>
+  getSubscribersForQueryCacheKey(queryCacheKey)
+
+describe('polling tests', () => {
+  it('clears intervals when seeing a resetApiState action', async () => {
+    await storeRef.store.dispatch(
+      getPosts.initiate(1, {
+        subscriptionOptions: { pollingInterval: 10 },
+        subscribe: true,
+      })
+    )
+
+    expect(mockBaseQuery).toHaveBeenCalledTimes(1)
+
+    storeRef.store.dispatch(api.util.resetApiState())
+
+    await waitMs(30)
+
+    expect(mockBaseQuery).toHaveBeenCalledTimes(1)
+  })
+
+  it('replaces polling interval when the subscription options are updated', async () => {
+    const { requestId, queryCacheKey, ...subscription } =
+      storeRef.store.dispatch(
+        getPosts.initiate(1, {
+          subscriptionOptions: { pollingInterval: 10 },
+          subscribe: true,
+        })
+      )
+
+    const getSubs = createSubscriptionGetter(queryCacheKey)
+
+    expect(Object.keys(getSubs())).toHaveLength(1)
+    expect(getSubs()[requestId].pollingInterval).toBe(10)
+
+    subscription.updateSubscriptionOptions({ pollingInterval: 20 })
+
+    expect(Object.keys(getSubs())).toHaveLength(1)
+    expect(getSubs()[requestId].pollingInterval).toBe(20)
+  })
+
+  it(`doesn't replace the interval when removing a shared query instance with a poll `, async () => {
+    const subscriptionOne = storeRef.store.dispatch(
+      getPosts.initiate(1, {
+        subscriptionOptions: { pollingInterval: 10 },
+        subscribe: true,
+      })
+    )
+
+    storeRef.store.dispatch(
+      getPosts.initiate(1, {
+        subscriptionOptions: { pollingInterval: 10 },
+        subscribe: true,
+      })
+    )
+
+    const getSubs = createSubscriptionGetter(subscriptionOne.queryCacheKey)
+
+    expect(Object.keys(getSubs())).toHaveLength(2)
+
+    subscriptionOne.unsubscribe()
+
+    expect(Object.keys(getSubs())).toHaveLength(1)
+  })
+
+  it('uses lowest specified interval when two components are mounted', async () => {
+    storeRef.store.dispatch(
+      getPosts.initiate(1, {
+        subscriptionOptions: { pollingInterval: 30000 },
+        subscribe: true,
+      })
+    )
+
+    storeRef.store.dispatch(
+      getPosts.initiate(1, {
+        subscriptionOptions: { pollingInterval: 10 },
+        subscribe: true,
+      })
+    )
+
+    await waitMs(20)
+
+    expect(mockBaseQuery.mock.calls.length).toBeGreaterThanOrEqual(2)
+  })
+})
diff --git a/packages/toolkit/src/query/tests/queryFn.test.tsx b/packages/toolkit/src/query/tests/queryFn.test.tsx
index a285cd6d..0349145b 100644
--- a/packages/toolkit/src/query/tests/queryFn.test.tsx
+++ b/packages/toolkit/src/query/tests/queryFn.test.tsx
@@ -307,7 +307,7 @@ describe('usage scenario tests', () => {
     return { collection, doc }
   }
 
-  const baseQuery = fetchBaseQuery({ baseUrl: 'https://example.com/' })
+  const baseQuery = fetchBaseQuery({ baseUrl: 'http://example.com/' })
   const api = createApi({
     baseQuery,
     endpoints: (build) => ({
diff --git a/packages/toolkit/src/query/tests/queryLifecycle.test.tsx b/packages/toolkit/src/query/tests/queryLifecycle.test.tsx
index 8bf19194..602fe2e7 100644
--- a/packages/toolkit/src/query/tests/queryLifecycle.test.tsx
+++ b/packages/toolkit/src/query/tests/queryLifecycle.test.tsx
@@ -10,7 +10,7 @@ import { server } from './mocks/server'
 import { rest } from 'msw'
 
 const api = createApi({
-  baseQuery: fetchBaseQuery({ baseUrl: 'https://example.com' }),
+  baseQuery: fetchBaseQuery({ baseUrl: 'http://example.com' }),
   endpoints: () => ({}),
 })
 const storeRef = setupApiStore(api)
@@ -397,7 +397,7 @@ test('query: updateCachedData', async () => {
   // request 2: error
   expect(onError).not.toHaveBeenCalled()
   server.use(
-    rest.get('https://example.com/success', (_, req, ctx) =>
+    rest.get('http://example.com/success', (_, req, ctx) =>
       req.once(ctx.status(500), ctx.json({ value: 'failed' }))
     )
   )
diff --git a/packages/toolkit/src/tests/mapBuilders.typetest.ts b/packages/toolkit/src/tests/mapBuilders.typetest.ts
index b807e0f8..ae930f15 100644
--- a/packages/toolkit/src/tests/mapBuilders.typetest.ts
+++ b/packages/toolkit/src/tests/mapBuilders.typetest.ts
@@ -1,9 +1,9 @@
-import type { SerializedError } from '@internal/createAsyncThunk';
+import type { SerializedError } from '@internal/createAsyncThunk'
 import { createAsyncThunk } from '@internal/createAsyncThunk'
 import { executeReducerBuilderCallback } from '@internal/mapBuilders'
 import type { AnyAction } from '@reduxjs/toolkit'
 import { createAction } from '@reduxjs/toolkit'
-import { expectType } from './helpers'
+import { expectExactType, expectType } from './helpers'
 
 /** Test:  alternative builder callback for actionMap */
 {
@@ -56,10 +56,34 @@ import { expectType } from './helpers'
       expectType<ReturnType<typeof increment>>(action)
     })
 
+    {
+      // action type is inferred when type predicate lacks `type` property
+      type PredicateWithoutTypeProperty = {
+        payload: number
+      }
+
+      builder.addMatcher(
+        (action): action is PredicateWithoutTypeProperty => true,
+        (state, action) => {
+          expectType<PredicateWithoutTypeProperty>(action)
+          expectType<AnyAction>(action)
+        }
+      )
+    }
+
     // action type defaults to AnyAction if no type predicate matcher is passed
     builder.addMatcher(
       () => true,
       (state, action) => {
+        expectExactType({} as AnyAction)(action)
+      }
+    )
+
+    // with a boolean checker, action can also be typed by type argument
+    builder.addMatcher<{ foo: boolean }>(
+      () => true,
+      (state, action) => {
+        expectType<{ foo: boolean }>(action)
         expectType<AnyAction>(action)
       }
     )
diff --git a/packages/toolkit/src/tsHelpers.ts b/packages/toolkit/src/tsHelpers.ts
index e7d622e8..e9145732 100644
--- a/packages/toolkit/src/tsHelpers.ts
+++ b/packages/toolkit/src/tsHelpers.ts
@@ -101,8 +101,12 @@ export type NoInfer<T> = [T][T extends any ? 0 : never]
 
 export type Omit<T, K extends keyof any> = Pick<T, Exclude<keyof T, K>>
 
+export interface TypeGuard<T> {
+  (value: any): value is T
+}
+
 export interface HasMatchFunction<T> {
-  match: (v: any) => v is T
+  match: TypeGuard<T>
 }
 
 export const hasMatchFunction = <T>(
@@ -112,7 +116,7 @@ export const hasMatchFunction = <T>(
 }
 
 /** @public */
-export type Matcher<T> = HasMatchFunction<T> | ((v: any) => v is T)
+export type Matcher<T> = HasMatchFunction<T> | TypeGuard<T>
 
 /** @public */
 export type ActionFromMatcher<M extends Matcher<any>> = M extends Matcher<
diff --git a/yarn.lock b/yarn.lock
index e0de772e..01ce41c8 100644
--- a/yarn.lock
+++ b/yarn.lock
@@ -5356,6 +5356,7 @@ __metadata:
     axios: ^0.19.2
     console-testing-library: ^0.3.1
     convert-source-map: ^1.7.0
+    cross-fetch: ^3.1.4
     esbuild: ^0.11.13
     eslint: ^7.25.0
     eslint-config-prettier: ^8.3.0
@@ -10259,7 +10260,7 @@ __metadata:
   languageName: node
   linkType: hard
 
-"cross-fetch@npm:3.1.4, cross-fetch@npm:^3.0.4, cross-fetch@npm:^3.0.6":
+"cross-fetch@npm:3.1.4, cross-fetch@npm:^3.0.4, cross-fetch@npm:^3.0.6, cross-fetch@npm:^3.1.4":
   version: 3.1.4
   resolution: "cross-fetch@npm:3.1.4"
   dependencies:
