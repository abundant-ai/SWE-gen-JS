diff --git a/docs/api/createEntityAdapter.mdx b/docs/api/createEntityAdapter.mdx
index 922042ec..74f15e8b 100644
--- a/docs/api/createEntityAdapter.mdx
+++ b/docs/api/createEntityAdapter.mdx
@@ -222,7 +222,7 @@ All three options will insert _new_ entities into the list. However they differ
 
 - `addOne` and `addMany` will do nothing with the new entity
 - `setOne` and `setMany` will completely replace the old entity with the new one. This will also get rid of any properties on the entity that are not present in the new version of said entity.
-- `upsertOne` and `upsertMany` will do a shallow copy to merge the old and new entities overwriting existing values, adding any that were not there and not touching properties not provided in the new entity.
+- `upsertOne` and `upsertMany` will do a shallow copy to merge the old and new entities overwritng existing values, adding any that were not there and not touching properties not provided in the new entity.
 
 :::
 
diff --git a/docs/rtk-query/api/created-api/hooks.mdx b/docs/rtk-query/api/created-api/hooks.mdx
index d6a94264..d46efff2 100644
--- a/docs/rtk-query/api/created-api/hooks.mdx
+++ b/docs/rtk-query/api/created-api/hooks.mdx
@@ -490,7 +490,7 @@ type UseLazyQueryOptions = {
   selectFromResult?: (result: UseQueryStateDefaultResult) => any
 }
 
-type UseLazyQueryTrigger<T> = (arg: any, preferCacheValue?: boolean) => Promise<
+type UseLazyQueryTrigger<T> = (arg: any) => Promise<
   QueryResultSelectorResult
 > & {
   arg: unknown // Whatever argument was provided to the query
@@ -559,10 +559,7 @@ type UseLazyQuerySubscriptionOptions = {
   refetchOnFocus?: boolean
 }
 
-type UseLazyQuerySubscriptionTrigger = (
-  arg: any,
-  preferCacheValue?: boolean
-) => void
+type UseLazyQuerySubscriptionTrigger = (arg: any) => void
 ```
 
 - **Parameters**
diff --git a/docs/rtk-query/api/fetchBaseQuery.mdx b/docs/rtk-query/api/fetchBaseQuery.mdx
index e40ebf65..389b99ef 100644
--- a/docs/rtk-query/api/fetchBaseQuery.mdx
+++ b/docs/rtk-query/api/fetchBaseQuery.mdx
@@ -19,10 +19,19 @@ It takes all standard options from fetch's [`RequestInit`](https://developer.moz
   - Typically a string like `https://api.your-really-great-app.com/v1/`. If you don't provide a `baseUrl`, it defaults to a relative path from where the request is being made. You should most likely _always_ specify this.
 - `prepareHeaders` _(optional)_
 
-  - Allows you to inject headers on every request. You can specify headers at the endpoint level, but you'll typically want to set common headers like `authorization` here. As a convenience mechanism, the second argument allows you to use `getState` to access your redux store in the event you store information you'll need there such as an auth token.
+  - Allows you to inject headers on every request. You can specify headers at the endpoint level, but you'll typically want to set common headers like `authorization` here. As a convenience mechanism, the second argument allows you to use `getState` to access your redux store in the event you store information you'll need there such as an auth token. Additionally, it provides access to `extra`, `endpoint`, `type`, and `forced` to unlock more granular conditional behaviors.
 
   - ```ts title="prepareHeaders signature" no-transpile
-    ;(headers: Headers, api: { getState: () => unknown }) => Headers
+    ;(
+      headers: Headers,
+      api: {
+        getState: () => unknown
+        extra: unknown
+        endpoint: string
+        type: 'query' | 'mutation'
+        forced: boolean | undefined
+      }
+    ) => Headers
     ```
 
 - `paramsSerializer` _(optional)_
@@ -176,7 +185,7 @@ By default, `fetchBaseQuery` assumes that every request you make will be `json`,
 
 ### Parsing a Response
 
-By default, `fetchBaseQuery` assumes that every `Response` you get will be parsed as `json`. In the event that you don't want that to happen, you can specify an alternative response handler like `text`, or take complete control and use a custom function that accepts the raw `Response` object &mdash; allowing you to use any [`Response` method](https://developer.mozilla.org/en-US/docs/Web/API/Response).
+By default, `fetchBaseQuery` assumes that every `Response` you get will be parsed as `json`. In the event that you don't want that to happen, you can specify an alternative response handler like `text`, or take complete control and use a custom function that accepts the raw `Response` object &mdash; allowing you to use any [`Body` method](https://developer.mozilla.org/en-US/docs/Web/API/Body).
 
 ```ts title="Parse a Response as text"
 import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query'
diff --git a/docs/rtk-query/usage/automated-refetching.mdx b/docs/rtk-query/usage/automated-refetching.mdx
index 38be5f90..5a351f7c 100644
--- a/docs/rtk-query/usage/automated-refetching.mdx
+++ b/docs/rtk-query/usage/automated-refetching.mdx
@@ -800,7 +800,7 @@ import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query'
 import { Post, LoginResponse } from './types'
 
 const api = createApi({
-  baseQuery: fetchBaseQuery({ baseUrl: 'http://example.com' }),
+  baseQuery: fetchBaseQuery({ baseUrl: 'https://example.com' }),
   tagTypes: ['Post', 'UNAUTHORIZED', 'UNKNOWN_ERROR'],
   endpoints: (build) => ({
     postById: build.query<Post, number>({
@@ -856,7 +856,7 @@ import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query'
 import { Post, User } from './types'
 
 const api = createApi({
-  baseQuery: fetchBaseQuery({ baseUrl: 'http://example.com' }),
+  baseQuery: fetchBaseQuery({ baseUrl: 'https://example.com' }),
   tagTypes: ['Post', 'User'],
   endpoints: (build) => ({
     getPosts: build.query<Post[], void>({
@@ -920,7 +920,7 @@ function providesList<R extends { id: string | number }[], T extends string>(
 // highlight-end
 
 const api = createApi({
-  baseQuery: fetchBaseQuery({ baseUrl: 'http://example.com' }),
+  baseQuery: fetchBaseQuery({ baseUrl: 'https://example.com' }),
   tagTypes: ['Post', 'User'],
   endpoints: (build) => ({
     getPosts: build.query({
diff --git a/docs/rtk-query/usage/cache-behavior.mdx b/docs/rtk-query/usage/cache-behavior.mdx
index f318521c..d66d3067 100644
--- a/docs/rtk-query/usage/cache-behavior.mdx
+++ b/docs/rtk-query/usage/cache-behavior.mdx
@@ -67,7 +67,7 @@ function ComponentFour() {
 
 While four components are subscribed to the endpoint, there are only three distinct combinations of endpoint + query parameters. Query parameters `1` and `2` will each have a single subscriber, while query parameter `3` has two subscribers. RTK Query will make three distinct fetches; one for each unique set of query parameters per endpoint.
 
-Data is kept in the cache as long as at least one active subscriber is interested in that endpoint + parameter combination. When the subscriber reference count reaches zero, a timer is set, and if there are no new subscriptions to that data by the time the timer expires, the cached data will be removed. The default expiration is 60 seconds, which can be configured both for the [API definition as a whole](../api/createApi.mdx#keepunuseddatafor), as well as on a [per-endpoint](../api/createApi.mdx#keepunuseddatafor-1) basis.
+Data is kept in the cache as long as there is at least one active subscriber interested in that endpoint + parameter combination. When the subscriber reference count reaches zero, a timer is set, and if there are no new subscriptions to that data by the time the timer expires, the cached data will be removed. The default expiration is 60 seconds, which can be configured both for the [API definition as a whole](../api/createApi.mdx#keepunuseddatafor), as well as on a [per-endpoint](../api/createApi.mdx#keepunuseddatafor-1) basis.
 
 If 'ComponentThree' is unmounted in the example above, regardless of how much time passes, the data will remain in the cache due to 'ComponentFour' still being subscribed to the same data, and the subscribe reference count will be `1`. However, once 'ComponentFour' unmounts, the subscriber reference count will be `0`. The data will remain in the cache for the remainder of the expiration time. If no new subscription has been created before the timer expires, the cached data will finally be removed.
 
diff --git a/docs/rtk-query/usage/code-generation.mdx b/docs/rtk-query/usage/code-generation.mdx
index 6c735ba1..355e78e5 100644
--- a/docs/rtk-query/usage/code-generation.mdx
+++ b/docs/rtk-query/usage/code-generation.mdx
@@ -29,6 +29,7 @@ We provide a package for RTK Query code generation from OpenAPI schemas. It is p
 Create an empty api using `createApi` like
 
 ```ts no-transpile title="src/store/emptyApi.ts"
+
 // Or from '@reduxjs/toolkit/query' if not using the auto-generated hooks
 import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'
 
@@ -42,7 +43,8 @@ export const emptySplitApi = createApi({
 Generate a config file (json, js or ts) with contents like
 
 ```ts no-transpile title="openapi-config.ts"
-import type { ConfigFile } from '@rtk-query/codegen-openapi'
+
+import { ConfigFile } from '@rtk-query/codegen-openapi'
 
 const config: ConfigFile = {
   schemaFile: 'https://petstore3.swagger.io/api/v3/openapi.json',
@@ -65,6 +67,7 @@ npx @rtk-query/codegen-openapi openapi-config.ts
 ### Programmatic usage
 
 ```ts no-transpile title="src/store/petApi.ts"
+
 import { generateEndpoints } from '@rtk-query/codegen-openapi'
 
 const api = await generateEndpoints({
diff --git a/docs/rtk-query/usage/customizing-queries.mdx b/docs/rtk-query/usage/customizing-queries.mdx
index 8ae69f29..208cb45b 100644
--- a/docs/rtk-query/usage/customizing-queries.mdx
+++ b/docs/rtk-query/usage/customizing-queries.mdx
@@ -271,7 +271,7 @@ const axiosBaseQuery =
 const api = createApi({
   // highlight-start
   baseQuery: axiosBaseQuery({
-    baseUrl: 'http://example.com',
+    baseUrl: 'https://example.com',
   }),
   // highlight-end
   endpoints(build) {
diff --git a/docs/rtk-query/usage/queries.mdx b/docs/rtk-query/usage/queries.mdx
index 8fe9303d..2db3a7ac 100644
--- a/docs/rtk-query/usage/queries.mdx
+++ b/docs/rtk-query/usage/queries.mdx
@@ -109,9 +109,9 @@ There are 5 query-related hooks:
 3. [`useQueryState`](../api/created-api/hooks.mdx#usequerystate)
    - Returns the query state and accepts `skip` and `selectFromResult`. Reads the request status and cached data from the Redux store.
 4. [`useLazyQuery`](../api/created-api/hooks.mdx#uselazyquery)
-   - Returns a tuple with a `trigger` function, the query result, and last promise info. Similar to `useQuery`, but with manual control over when the data fetching occurs. **Note: the `trigger` function takes a second argument of `preferCacheValue?: boolean` in the event you want to skip making a request if cached data already exists.**
+   - Returns a tuple with a `fetch` function, the query result, and last promise info. Similar to `useQuery`, but with manual control over when the data fetching occurs.
 5. [`useLazyQuerySubscription`](../api/created-api/hooks.mdx#uselazyquerysubscription)
-   - Returns a tuple with a `trigger` function, and last promise info. Similar to `useQuerySubscription`, but with manual control over when the data fetching occurs. **Note: the `trigger` function takes a second argument of `preferCacheValue?: boolean` in the event you want to skip making a request if cached data already exists.**
+   - Returns a tuple with a `fetch` function, and last promise info. Similar to `useQuerySubscription`, but with manual control over when the data fetching occurs.
 
 In practice, the standard `useQuery`-based hooks such as `useGetPostQuery` will be the primary hooks used in your application, but the other hooks are available for specific use cases.
 
diff --git a/packages/toolkit/package.json b/packages/toolkit/package.json
index 9a6b7221..b91ece0f 100644
--- a/packages/toolkit/package.json
+++ b/packages/toolkit/package.json
@@ -47,7 +47,6 @@
     "axios": "^0.19.2",
     "console-testing-library": "^0.3.1",
     "convert-source-map": "^1.7.0",
-    "cross-fetch": "^3.1.4",
     "esbuild": "^0.11.13",
     "eslint": "^7.25.0",
     "eslint-config-prettier": "^8.3.0",
diff --git a/packages/toolkit/src/createReducer.ts b/packages/toolkit/src/createReducer.ts
index 06e48467..b747cdc6 100644
--- a/packages/toolkit/src/createReducer.ts
+++ b/packages/toolkit/src/createReducer.ts
@@ -15,9 +15,6 @@ import type { NoInfer } from './tsHelpers'
  */
 export type Actions<T extends keyof any = string> = Record<T, Action>
 
-/**
- * @deprecated use `TypeGuard` instead
- */
 export interface ActionMatcher<A extends AnyAction> {
   (action: AnyAction): action is A
 }
diff --git a/packages/toolkit/src/mapBuilders.ts b/packages/toolkit/src/mapBuilders.ts
index 81d8a9ac..6cda0759 100644
--- a/packages/toolkit/src/mapBuilders.ts
+++ b/packages/toolkit/src/mapBuilders.ts
@@ -2,9 +2,9 @@ import type { Action, AnyAction } from 'redux'
 import type {
   CaseReducer,
   CaseReducers,
+  ActionMatcher,
   ActionMatcherDescriptionCollection,
 } from './createReducer'
-import type { TypeGuard } from './tsHelpers'
 
 export interface TypedActionCreator<Type extends string> {
   (...args: any[]): Action<Type>
@@ -96,9 +96,9 @@ const reducer = createReducer(initialState, (builder) => {
 });
 ```
    */
-  addMatcher<A>(
-    matcher: TypeGuard<A> | ((action: any) => boolean),
-    reducer: CaseReducer<State, A extends AnyAction ? A : A & AnyAction>
+  addMatcher<A extends AnyAction>(
+    matcher: ActionMatcher<A> | ((action: AnyAction) => boolean),
+    reducer: CaseReducer<State, A>
   ): Omit<ActionReducerMapBuilder<State>, 'addCase'>
 
   /**
@@ -167,9 +167,9 @@ export function executeReducerBuilderCallback<S>(
       actionsMap[type] = reducer
       return builder
     },
-    addMatcher<A>(
-      matcher: TypeGuard<A>,
-      reducer: CaseReducer<S, A extends AnyAction ? A : A & AnyAction>
+    addMatcher<A extends AnyAction>(
+      matcher: ActionMatcher<A>,
+      reducer: CaseReducer<S, A>
     ) {
       if (process.env.NODE_ENV !== 'production') {
         if (defaultCaseReducer) {
diff --git a/packages/toolkit/src/query/core/buildMiddleware/polling.ts b/packages/toolkit/src/query/core/buildMiddleware/polling.ts
index a30f3f4f..7f5ac3a9 100644
--- a/packages/toolkit/src/query/core/buildMiddleware/polling.ts
+++ b/packages/toolkit/src/query/core/buildMiddleware/polling.ts
@@ -19,15 +19,11 @@ export const build: SubMiddlewareBuilder = ({
       timeout?: TimeoutId
       pollingInterval: number
     }> = {}
-
     return (next) =>
       (action): any => {
         const result = next(action)
 
-        if (
-          api.internalActions.updateSubscriptionOptions.match(action) ||
-          api.internalActions.unsubscribeQueryResult.match(action)
-        ) {
+        if (api.internalActions.updateSubscriptionOptions.match(action)) {
           updatePollingInterval(action.payload, mwApi)
         }
 
@@ -103,13 +99,16 @@ export const build: SubMiddlewareBuilder = ({
       }
 
       const lowestPollingInterval = findLowestPollingInterval(subscriptions)
+      const currentPoll = currentPolls[queryCacheKey]
 
       if (!Number.isFinite(lowestPollingInterval)) {
-        cleanupPollForKey(queryCacheKey)
+        if (currentPoll?.timeout) {
+          clearTimeout(currentPoll.timeout)
+        }
+        delete currentPolls[queryCacheKey]
         return
       }
 
-      const currentPoll = currentPolls[queryCacheKey]
       const nextPollTimestamp = Date.now() + lowestPollingInterval
 
       if (!currentPoll || nextPollTimestamp < currentPoll.nextPollTimestamp) {
@@ -117,17 +116,10 @@ export const build: SubMiddlewareBuilder = ({
       }
     }
 
-    function cleanupPollForKey(key: string) {
-      const existingPoll = currentPolls[key]
-      if (existingPoll?.timeout) {
-        clearTimeout(existingPoll.timeout)
-      }
-      delete currentPolls[key]
-    }
-
     function clearPolls() {
-      for (const key of Object.keys(currentPolls)) {
-        cleanupPollForKey(key)
+      for (const [key, poll] of Object.entries(currentPolls)) {
+        if (poll?.timeout) clearTimeout(poll.timeout)
+        delete currentPolls[key]
       }
     }
   }
diff --git a/packages/toolkit/src/query/core/buildThunks.ts b/packages/toolkit/src/query/core/buildThunks.ts
index 04f6e06c..58496877 100644
--- a/packages/toolkit/src/query/core/buildThunks.ts
+++ b/packages/toolkit/src/query/core/buildThunks.ts
@@ -5,8 +5,9 @@ import type {
   BaseQueryError,
   QueryReturnValue,
 } from '../baseQueryTypes'
+import { BaseQueryArg } from '../baseQueryTypes'
 import type { RootState, QueryKeys, QuerySubstateIdentifier } from './apiState'
-import { QueryStatus } from './apiState'
+import { QueryStatus, CombinedState } from './apiState'
 import type { StartQueryActionCreatorOptions } from './buildInitiate'
 import type {
   AssertTagTypes,
@@ -17,7 +18,7 @@ import type {
   QueryDefinition,
   ResultTypeFrom,
 } from '../endpointDefinitions'
-import { calculateProvidedBy } from '../endpointDefinitions'
+import { calculateProvidedBy, FullTagDescription } from '../endpointDefinitions'
 import type { AsyncThunkPayloadCreator, Draft } from '@reduxjs/toolkit'
 import {
   isAllOf,
@@ -512,7 +513,7 @@ export function calculateProvidedByThunk(
     isFulfilled(action) ? action.payload : undefined,
     isRejectedWithValue(action) ? action.payload : undefined,
     action.meta.arg.originalArgs,
-    'baseQueryMeta' in action.meta ? action.meta.baseQueryMeta : undefined,
+    action.meta,
     assertTagType
   )
 }
diff --git a/packages/toolkit/src/query/fetchBaseQuery.ts b/packages/toolkit/src/query/fetchBaseQuery.ts
index bd606b7c..4e1e1159 100644
--- a/packages/toolkit/src/query/fetchBaseQuery.ts
+++ b/packages/toolkit/src/query/fetchBaseQuery.ts
@@ -113,7 +113,10 @@ export type FetchBaseQueryArgs = {
   baseUrl?: string
   prepareHeaders?: (
     headers: Headers,
-    api: Pick<BaseQueryApi, 'getState' | 'endpoint' | 'type' | 'forced'>
+    api: Pick<
+      BaseQueryApi,
+      'getState' | 'extra' | 'endpoint' | 'type' | 'forced'
+    >
   ) => MaybePromise<Headers>
   fetchFn?: (
     input: RequestInfo,
@@ -144,12 +147,12 @@ export type FetchBaseQueryMeta = { request: Request; response?: Response }
  *
  * @param {string} baseUrl
  * The base URL for an API service.
- * Typically in the format of http://example.com/
+ * Typically in the format of https://example.com/
  *
- * @param {(headers: Headers, api: { getState: () => unknown }) => Headers} prepareHeaders
+ * @param {(headers: Headers, api: { getState: () => unknown; extra: unknown; endpoint: string; type: 'query' | 'mutation'; forced: boolean; }) => Headers} prepareHeaders
  * An optional function that can be used to inject headers on requests.
- * Provides a Headers object, as well as the `getState` function from the
- * redux store. Can be useful for authentication.
+ * Provides a Headers object, as well as most of the `BaseQueryApi` (`dispatch` is not available).
+ * Useful for setting authentication or headers that need to be set conditionally.
  *
  * @link https://developer.mozilla.org/en-US/docs/Web/API/Headers
  *
@@ -157,7 +160,7 @@ export type FetchBaseQueryMeta = { request: Request; response?: Response }
  * Accepts a custom `fetch` function if you do not want to use the default on the window.
  * Useful in SSR environments if you need to use a library such as `isomorphic-fetch` or `cross-fetch`
  *
- * @param {(params: Record<string, unknown> => string} paramsSerializer
+ * @param {(params: Record<string, unknown>) => string} paramsSerializer
  * An optional function that can be used to stringify querystring parameters.
  */
 export function fetchBaseQuery({
@@ -178,7 +181,8 @@ export function fetchBaseQuery({
       'Warning: `fetch` is not available. Please supply a custom `fetchFn` property to use `fetchBaseQuery` on SSR environments.'
     )
   }
-  return async (arg, { signal, getState, endpoint, forced, type }) => {
+  return async (arg, api) => {
+    const { signal, getState, extra, endpoint, forced, type } = api
     let meta: FetchBaseQueryMeta | undefined
     let {
       url,
@@ -200,7 +204,7 @@ export function fetchBaseQuery({
 
     config.headers = await prepareHeaders(
       new Headers(stripUndefined(headers)),
-      { getState, endpoint, forced, type }
+      { getState, extra, endpoint, forced, type }
     )
 
     // Only set the content-type to json if appropriate. Will not be true for FormData, ArrayBuffer, Blob, etc.
diff --git a/packages/toolkit/src/query/react/buildHooks.ts b/packages/toolkit/src/query/react/buildHooks.ts
index 15e29779..b3a852e6 100644
--- a/packages/toolkit/src/query/react/buildHooks.ts
+++ b/packages/toolkit/src/query/react/buildHooks.ts
@@ -185,7 +185,7 @@ export type UseLazyQueryLastPromiseInfo<
  *
  * #### Note
  *
- * When the trigger function returned from a LazyQuery, it always initiates a new request to the server even if there is cached data. Set `preferCacheValue`(the second argument to the function) as `true` if you want it to immediately return a cached value if one exists.
+ * When the trigger function returned from a LazyQuery, it always initiates a new request to the server even if there is cached data. Set `preferCacheValue`(the second argument to the function) as true if you want it to use cache.
  */
 export type UseLazyQuery<D extends QueryDefinition<any, any, any, any>> = <
   R = UseQueryStateDefaultResult<D>
diff --git a/packages/toolkit/src/tsHelpers.ts b/packages/toolkit/src/tsHelpers.ts
index e9145732..e7d622e8 100644
--- a/packages/toolkit/src/tsHelpers.ts
+++ b/packages/toolkit/src/tsHelpers.ts
@@ -101,12 +101,8 @@ export type NoInfer<T> = [T][T extends any ? 0 : never]
 
 export type Omit<T, K extends keyof any> = Pick<T, Exclude<keyof T, K>>
 
-export interface TypeGuard<T> {
-  (value: any): value is T
-}
-
 export interface HasMatchFunction<T> {
-  match: TypeGuard<T>
+  match: (v: any) => v is T
 }
 
 export const hasMatchFunction = <T>(
@@ -116,7 +112,7 @@ export const hasMatchFunction = <T>(
 }
 
 /** @public */
-export type Matcher<T> = HasMatchFunction<T> | TypeGuard<T>
+export type Matcher<T> = HasMatchFunction<T> | ((v: any) => v is T)
 
 /** @public */
 export type ActionFromMatcher<M extends Matcher<any>> = M extends Matcher<
diff --git a/yarn.lock b/yarn.lock
index 01ce41c8..e0de772e 100644
--- a/yarn.lock
+++ b/yarn.lock
@@ -5356,7 +5356,6 @@ __metadata:
     axios: ^0.19.2
     console-testing-library: ^0.3.1
     convert-source-map: ^1.7.0
-    cross-fetch: ^3.1.4
     esbuild: ^0.11.13
     eslint: ^7.25.0
     eslint-config-prettier: ^8.3.0
@@ -10260,7 +10259,7 @@ __metadata:
   languageName: node
   linkType: hard
 
-"cross-fetch@npm:3.1.4, cross-fetch@npm:^3.0.4, cross-fetch@npm:^3.0.6, cross-fetch@npm:^3.1.4":
+"cross-fetch@npm:3.1.4, cross-fetch@npm:^3.0.4, cross-fetch@npm:^3.0.6":
   version: 3.1.4
   resolution: "cross-fetch@npm:3.1.4"
   dependencies:
