diff --git a/.changeset/fast-gorillas-build.md b/.changeset/fast-gorillas-build.md
deleted file mode 100644
index c3037422f..000000000
--- a/.changeset/fast-gorillas-build.md
+++ /dev/null
@@ -1,5 +0,0 @@
----
-'@keystone-6/fields-document': patch
----
-
-Fixes pasting plain text in the document editor removing markdown link definition and usages 
diff --git a/.changeset/light-balloons-repair.md b/.changeset/light-balloons-repair.md
new file mode 100644
index 000000000..ce540580b
--- /dev/null
+++ b/.changeset/light-balloons-repair.md
@@ -0,0 +1,5 @@
+---
+'@keystone-6/core': minor
+---
+
+Adds a new `multiselect` field type
diff --git a/docs/pages/docs/apis/fields.mdx b/docs/pages/docs/apis/fields.mdx
index d44794478..d816583f4 100644
--- a/docs/pages/docs/apis/fields.mdx
+++ b/docs/pages/docs/apis/fields.mdx
@@ -544,6 +544,58 @@ export default config({
 });
 ```
 
+### multiselect
+
+A `multiselect` field represents the selection of a set of values from the defined `options`.
+Values can be either strings, integers, or enum values, as determined by the `type` option.
+This will determine their GraphQL data type.
+Unlike the `select` field, the `type` will not change the database type, `multiselect` fields are always stored as a json array in the database.
+
+Options:
+
+- `type` (default: `'string'`): Sets the type of the values of this field.
+  Must be one of `['string', 'enum', 'integer']`.
+- `options`: An array of `{ label, value }`.
+  `label` is a string to be displayed in the Admin UI.
+  `value` is either a `string` (for `{ type: 'string' }` or `{ type: 'enum' }`), or a `number` (for `{ type: 'integer' }`).
+  The `value` will be used in the GraphQL API and stored in the database.
+- `defaultValue` (default: `[]`): This value will be used for the field when creating items if no explicit value is set.
+- `db.map`: Adds a [Prisma `@map`](https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference#map) attribute to this field which changes the column name in the database
+- `graphql.read.isNonNull` (default: `false`): If you have no read access control and you don't intend to add any in the future,
+  you can set this to true and the output field will be non-nullable. This is only allowed when you have no read access control because otherwise,
+  when access is denied, `null` will be returned which will cause an error since the field is non-nullable and the error
+  will propagate up until a nullable field is found which means the entire item will be unreadable and when doing an `items` query, all the items will be unreadable.
+- `graphql.create.isNonNull` (default: `false`): If you have no create access control and you want to explicitly show that this is field is non-nullable in the create input
+  you can set this to true and the create field will be non-nullable and have a default value at the GraphQL level.
+  This is only allowed when you have no create access control because otherwise, the item will always fail access control
+  if a user doesn't have access to create the particular field regardless of whether or not they specify the field in the create.
+
+```typescript
+import { config, list } from '@keystone-6/core';
+import { multiselect } from '@keystone-6/core/fields';
+
+export default config({
+  lists: {
+    ListName: list({
+      fields: {
+        fieldName: multiselect({
+          type: 'enum',
+          options: [
+            { label: '...', value: '...' },
+            /* ... */
+          ],
+          defaultValue: ['...'],
+          db: { map: 'my_multiselect' },
+        }),
+        /* ... */
+      },
+    }),
+    /* ... */
+  },
+  /* ... */
+});
+```
+
 ### text
 
 A `text` field represents a string value.
diff --git a/packages/core/fields/types/multiselect/views/package.json b/packages/core/fields/types/multiselect/views/package.json
new file mode 100644
index 000000000..ec84a47fc
--- /dev/null
+++ b/packages/core/fields/types/multiselect/views/package.json
@@ -0,0 +1,4 @@
+{
+  "main": "dist/keystone-6-core-fields-types-multiselect-views.cjs.js",
+  "module": "dist/keystone-6-core-fields-types-multiselect-views.esm.js"
+}
diff --git a/packages/core/src/fields/index.ts b/packages/core/src/fields/index.ts
index 0874f6195..a9000cef3 100644
--- a/packages/core/src/fields/index.ts
+++ b/packages/core/src/fields/index.ts
@@ -28,3 +28,5 @@ export { virtual } from './types/virtual';
 export type { VirtualFieldConfig } from './types/virtual';
 export { calendarDay } from './types/calendarDay';
 export type { CalendarDayFieldConfig } from './types/calendarDay';
+export { multiselect } from './types/multiselect';
+export type { MultiselectFieldConfig } from './types/multiselect';
diff --git a/packages/core/src/fields/types/multiselect/index.ts b/packages/core/src/fields/types/multiselect/index.ts
new file mode 100644
index 000000000..073847e25
--- /dev/null
+++ b/packages/core/src/fields/types/multiselect/index.ts
@@ -0,0 +1,210 @@
+import inflection from 'inflection';
+import { humanize } from '../../../lib/utils';
+import {
+  BaseListTypeInfo,
+  FieldTypeFunc,
+  CommonFieldConfig,
+  FieldData,
+  jsonFieldTypePolyfilledForSQLite,
+} from '../../../types';
+import { graphql } from '../../..';
+import { assertCreateIsNonNullAllowed, assertReadIsNonNullAllowed } from '../../non-null-graphql';
+import { resolveView } from '../../resolve-view';
+import { userInputError } from '../../../lib/core/graphql-errors';
+
+export type MultiselectFieldConfig<ListTypeInfo extends BaseListTypeInfo> =
+  CommonFieldConfig<ListTypeInfo> &
+    (
+      | {
+          /**
+           * When a value is provided as just a string, it will be formatted in the same way
+           * as field labels are to create the label.
+           */
+          options: readonly ({ label: string; value: string } | string)[];
+          /**
+           * If `enum` is provided on SQLite, it will use an enum in GraphQL but a string in the database.
+           */
+          type?: 'string' | 'enum';
+          defaultValue?: readonly string[];
+        }
+      | {
+          options: readonly { label: string; value: number }[];
+          type: 'integer';
+          defaultValue?: readonly number[];
+        }
+    ) & {
+      graphql?: {
+        create?: {
+          isNonNull?: boolean;
+        };
+        read?: {
+          isNonNull?: boolean;
+        };
+      };
+      db?: {
+        map?: string;
+      };
+    };
+
+// These are the max and min values available to a 32 bit signed integer
+const MAX_INT = 2147483647;
+const MIN_INT = -2147483648;
+
+export const multiselect =
+  <ListTypeInfo extends BaseListTypeInfo>({
+    ui,
+    defaultValue = [],
+    ...config
+  }: MultiselectFieldConfig<ListTypeInfo>): FieldTypeFunc<ListTypeInfo> =>
+  meta => {
+    if ((config as any).isIndexed === 'unique') {
+      throw Error("isIndexed: 'unique' is not a supported option for field type multiselect");
+    }
+    const fieldLabel = config.label ?? humanize(meta.fieldKey);
+    assertReadIsNonNullAllowed(meta, config, false);
+
+    assertCreateIsNonNullAllowed(meta, config);
+
+    const output = <T extends graphql.NullableOutputType>(type: T) =>
+      config.graphql?.read?.isNonNull ? graphql.nonNull(nonNullList(type)) : nonNullList(type);
+
+    const create = <T extends graphql.NullableInputType>(type: T) => {
+      const list = nonNullList(type);
+      if (config.graphql?.read?.isNonNull) {
+        return graphql.arg({
+          type: graphql.nonNull(list),
+          defaultValue: defaultValue as any,
+        });
+      }
+      return graphql.arg({ type: list });
+    };
+
+    const resolveCreate = <T extends string | number>(val: T[] | null | undefined): T[] => {
+      const resolved = resolveUpdate(val);
+      if (resolved === undefined) {
+        return defaultValue as T[];
+      }
+      return resolved;
+    };
+    const resolveUpdate = <T extends string | number>(
+      val: T[] | null | undefined
+    ): T[] | undefined => {
+      if (val === null) {
+        throw userInputError('multiselect fields cannot be set to null');
+      }
+      return val;
+    };
+
+    const transformedConfig = configToOptionsAndGraphQLType(config, meta);
+
+    const possibleValues = new Set(transformedConfig.options.map(x => x.value));
+    if (possibleValues.size !== transformedConfig.options.length) {
+      throw new Error(
+        `The multiselect field at ${meta.listKey}.${meta.fieldKey} has duplicate options, this is not allowed`
+      );
+    }
+
+    return jsonFieldTypePolyfilledForSQLite(
+      meta.provider,
+      {
+        ui,
+        hooks: {
+          ...config.hooks,
+          async validateInput(args) {
+            const selectedValues: readonly (string | number)[] | undefined =
+              args.inputData[meta.fieldKey];
+            if (selectedValues !== undefined) {
+              for (const value of selectedValues) {
+                if (!possibleValues.has(value)) {
+                  args.addValidationError(`${value} is not a possible value for ${fieldLabel}`);
+                }
+              }
+              const uniqueValues = new Set(selectedValues);
+              if (uniqueValues.size !== selectedValues.length) {
+                args.addValidationError(`${fieldLabel} must have a unique set of options selected`);
+              }
+            }
+
+            await config.hooks?.validateInput?.(args);
+          },
+        },
+        views: resolveView('multiselect/views'),
+        getAdminMeta: () => ({
+          options: transformedConfig.options,
+          type: config.type ?? 'string',
+          defaultValue: [],
+        }),
+        input: {
+          create: { arg: create(transformedConfig.graphqlType), resolve: resolveCreate },
+          update: {
+            arg: graphql.arg({ type: nonNullList(transformedConfig.graphqlType) }),
+            resolve: resolveUpdate,
+          },
+        },
+        output: graphql.field({
+          type: output(transformedConfig.graphqlType),
+          resolve({ value }) {
+            return value as any;
+          },
+        }),
+      },
+      {
+        mode: 'required',
+        map: config?.db?.map,
+        default: { kind: 'literal', value: JSON.stringify(defaultValue) },
+      }
+    );
+  };
+
+function configToOptionsAndGraphQLType(
+  config: MultiselectFieldConfig<BaseListTypeInfo>,
+  meta: FieldData
+) {
+  if (config.type === 'integer') {
+    if (
+      config.options.some(
+        ({ value }) => !Number.isInteger(value) || value > MAX_INT || value < MIN_INT
+      )
+    ) {
+      throw new Error(
+        `The multiselect field at ${meta.listKey}.${meta.fieldKey} specifies integer values that are outside the range of a 32 bit signed integer`
+      );
+    }
+    return {
+      type: 'integer' as const,
+      graphqlType: graphql.Int,
+      options: config.options,
+    };
+  }
+
+  const options = config.options.map(option => {
+    if (typeof option === 'string') {
+      return {
+        label: humanize(option),
+        value: option,
+      };
+    }
+    return option;
+  });
+
+  if (config.type === 'enum') {
+    const enumName = `${meta.listKey}${inflection.classify(meta.fieldKey)}Type`;
+    const graphqlType = graphql.enum({
+      name: enumName,
+      values: graphql.enumValues(options.map(x => x.value)),
+    });
+    return {
+      type: 'enum' as const,
+      graphqlType,
+      options,
+    };
+  }
+  return {
+    type: 'string' as const,
+    graphqlType: graphql.String,
+    options,
+  };
+}
+
+const nonNullList = <T extends graphql.NullableType>(type: T) =>
+  graphql.list(graphql.nonNull(type));
diff --git a/packages/core/src/fields/types/multiselect/views/index.tsx b/packages/core/src/fields/types/multiselect/views/index.tsx
new file mode 100644
index 000000000..a87c7a25a
--- /dev/null
+++ b/packages/core/src/fields/types/multiselect/views/index.tsx
@@ -0,0 +1,107 @@
+/** @jsxRuntime classic */
+/** @jsx jsx */
+import { Fragment } from 'react';
+import { jsx } from '@keystone-ui/core';
+import { FieldContainer, FieldDescription, FieldLabel, MultiSelect } from '@keystone-ui/fields';
+import {
+  CardValueComponent,
+  CellComponent,
+  FieldController,
+  FieldControllerConfig,
+  FieldProps,
+} from '../../../../types';
+import { CellContainer, CellLink } from '../../../../admin-ui/components';
+
+export const Field = ({ field, value, onChange, autoFocus }: FieldProps<typeof controller>) => {
+  return (
+    <FieldContainer>
+      <Fragment>
+        <FieldLabel htmlFor={field.path}>{field.label}</FieldLabel>
+        <FieldDescription id={`${field.path}-description`}>{field.description}</FieldDescription>
+        <MultiSelect
+          id={field.path}
+          isClearable
+          autoFocus={autoFocus}
+          options={field.options}
+          isDisabled={onChange === undefined}
+          onChange={newVal => {
+            onChange?.(newVal);
+          }}
+          value={value}
+          aria-describedby={field.description === null ? undefined : `${field.path}-description`}
+          portalMenu
+        />
+      </Fragment>
+    </FieldContainer>
+  );
+};
+
+export const Cell: CellComponent<typeof controller> = ({ item, field, linkTo }) => {
+  const value: readonly string[] | readonly number[] = item[field.path] ?? [];
+  const label = value.map(value => field.valuesToOptionsWithStringValues[value].label).join(', ');
+  return linkTo ? <CellLink {...linkTo}>{label}</CellLink> : <CellContainer>{label}</CellContainer>;
+};
+Cell.supportsLinkTo = true;
+
+export const CardValue: CardValueComponent<typeof controller> = ({ item, field }) => {
+  const value: readonly string[] | readonly number[] = item[field.path] ?? [];
+  const label = value.map(value => field.valuesToOptionsWithStringValues[value].label).join(', ');
+
+  return (
+    <FieldContainer>
+      <FieldLabel>{field.label}</FieldLabel>
+      {label}
+    </FieldContainer>
+  );
+};
+
+export type AdminMultiSelectFieldMeta = {
+  options: readonly { label: string; value: string | number }[];
+  type: 'string' | 'integer' | 'enum';
+  defaultValue: string[] | number[];
+};
+
+type Config = FieldControllerConfig<AdminMultiSelectFieldMeta>;
+
+type Option = { label: string; value: string };
+
+type Value = readonly Option[];
+
+export const controller = (
+  config: Config
+): FieldController<Value, Option[]> & {
+  options: Option[];
+  type: 'string' | 'integer' | 'enum';
+  valuesToOptionsWithStringValues: Record<string, Option>;
+} => {
+  const optionsWithStringValues = config.fieldMeta.options.map(x => ({
+    label: x.label,
+    value: x.value.toString(),
+  }));
+
+  const valuesToOptionsWithStringValues = Object.fromEntries(
+    optionsWithStringValues.map(option => [option.value, option])
+  );
+
+  const parseValue = (value: string) =>
+    config.fieldMeta.type === 'integer' ? parseInt(value) : value;
+
+  return {
+    path: config.path,
+    label: config.label,
+    description: config.description,
+    graphqlSelection: config.path,
+    defaultValue: config.fieldMeta.defaultValue.map(x => valuesToOptionsWithStringValues[x]),
+    type: config.fieldMeta.type,
+    options: optionsWithStringValues,
+    valuesToOptionsWithStringValues,
+    deserialize: data => {
+      // if we get null from the GraphQL API (which will only happen if field read access control failed)
+      // we'll just show it as nothing being selected for now.
+      const values: readonly string[] | readonly number[] = data[config.path] ?? [];
+      const selectedOptions = values.map(x => valuesToOptionsWithStringValues[x]);
+      return selectedOptions;
+    },
+    serialize: value => ({ [config.path]: value.map(x => parseValue(x.value)) }),
+  };
+};
diff --git a/packages/fields-document/package.json b/packages/fields-document/package.json
index 7b37028e5..f870db185 100644
--- a/packages/fields-document/package.json
+++ b/packages/fields-document/package.json
@@ -45,6 +45,7 @@
     "io-ts-excess": "^1.0.1",
     "is-hotkey": "^0.2.0",
     "match-sorter": "^6.3.1",
+    "mdast-util-definitions": "^4.0.0",
     "mdast-util-from-markdown": "^0.8.5",
     "mdast-util-gfm-autolink-literal": "^0.1.3",
     "mdast-util-gfm-strikethrough": "^0.2.3",
diff --git a/packages/fields-document/src/DocumentEditor/pasting/markdown.ts b/packages/fields-document/src/DocumentEditor/pasting/markdown.ts
index 2a97da8dc..452027172 100644
--- a/packages/fields-document/src/DocumentEditor/pasting/markdown.ts
+++ b/packages/fields-document/src/DocumentEditor/pasting/markdown.ts
@@ -6,6 +6,7 @@ import autoLinkLiteralMarkdownSyntax from 'micromark-extension-gfm-autolink-lite
 // @ts-ignore
 import gfmStrikethroughFromMarkdownExtension from 'mdast-util-gfm-strikethrough/from-markdown';
 import gfmStrikethroughMarkdownSyntax from 'micromark-extension-gfm-strikethrough';
+import definitions from 'mdast-util-definitions';
 import { Descendant } from 'slate';
 import { getTextNodeForCurrentlyActiveMarks, addMarkToChildren } from './utils';
 
@@ -16,19 +17,22 @@ const markdownConfig = {
 
 export function deserializeMarkdown(markdown: string) {
   const root = mdASTUtilFromMarkdown(markdown, markdownConfig);
+  const getDefinition = definitions(root);
   let nodes = root.children;
   if (nodes.length === 1 && nodes[0].type === 'paragraph') {
     nodes = nodes[0].children;
   }
-  return deserializeChildren(nodes, markdown);
+  return deserializeChildren(nodes, getDefinition);
 }
 
+type GetDefinition = ReturnType<typeof definitions>;
+
 type MDNode = ReturnType<typeof mdASTUtilFromMarkdown>['children'][number];
 
-function deserializeChildren(nodes: MDNode[], input: string) {
+function deserializeChildren(nodes: MDNode[], getDefinition: GetDefinition) {
   const outputNodes: Descendant[] = [];
   for (const node of nodes) {
-    const result = deserializeMarkdownNode(node, input);
+    const result = deserializeMarkdownNode(node, getDefinition);
     if (result.length) {
       outputNodes.push(...result);
     }
@@ -39,17 +43,26 @@ function deserializeChildren(nodes: MDNode[], input: string) {
   return outputNodes;
 }
 
-function deserializeMarkdownNode(node: MDNode, input: string): Descendant[] {
+function deserializeMarkdownNode(node: MDNode, getDefinition: GetDefinition): Descendant[] {
   switch (node.type) {
     case 'blockquote': {
-      return [{ type: 'blockquote', children: deserializeChildren(node.children, input) }];
+      return [{ type: 'blockquote', children: deserializeChildren(node.children, getDefinition) }];
+    }
+    case 'linkReference': {
+      return [
+        {
+          type: 'link',
+          href: getDefinition(node.identifier)?.url || '',
+          children: deserializeChildren(node.children, getDefinition),
+        },
+      ];
     }
     case 'link': {
       return [
         {
           type: 'link',
           href: node.url,
-          children: deserializeChildren(node.children, input),
+          children: deserializeChildren(node.children, getDefinition),
         },
       ];
     }
@@ -57,14 +70,14 @@ function deserializeMarkdownNode(node: MDNode, input: string): Descendant[] {
       return [{ type: 'code', children: [{ text: node.value }] }];
     }
     case 'paragraph': {
-      return [{ type: 'paragraph', children: deserializeChildren(node.children, input) }];
+      return [{ type: 'paragraph', children: deserializeChildren(node.children, getDefinition) }];
     }
     case 'heading': {
       return [
         {
           type: 'heading',
           level: node.depth,
-          children: deserializeChildren(node.children, input),
+          children: deserializeChildren(node.children, getDefinition),
         },
       ];
     }
@@ -72,12 +85,22 @@ function deserializeMarkdownNode(node: MDNode, input: string): Descendant[] {
       return [
         {
           type: node.ordered ? 'ordered-list' : 'unordered-list',
-          children: deserializeChildren(node.children, input),
+          children: deserializeChildren(node.children, getDefinition),
         },
       ];
     }
+    case 'imageReference': {
+      return [
+        getTextNodeForCurrentlyActiveMarks(
+          `![${node.alt || ''}](${getDefinition(node.identifier)?.url || ''})`
+        ),
+      ];
+    }
+    case 'image': {
+      return [getTextNodeForCurrentlyActiveMarks(`![${node.alt || ''}](${node.url})`)];
+    }
     case 'listItem': {
-      return [{ type: 'list-item', children: deserializeChildren(node.children, input) }];
+      return [{ type: 'list-item', children: deserializeChildren(node.children, getDefinition) }];
     }
     case 'thematicBreak': {
       return [{ type: 'divider', children: [{ text: '' }] }];
@@ -86,29 +109,28 @@ function deserializeMarkdownNode(node: MDNode, input: string): Descendant[] {
       return [getTextNodeForCurrentlyActiveMarks('\n')];
     }
     case 'delete': {
-      return addMarkToChildren('strikethrough', () => deserializeChildren(node.children, input));
+      return addMarkToChildren('strikethrough', () =>
+        deserializeChildren(node.children, getDefinition)
+      );
     }
     case 'strong': {
-      return addMarkToChildren('bold', () => deserializeChildren(node.children, input));
+      return addMarkToChildren('bold', () => deserializeChildren(node.children, getDefinition));
     }
     case 'emphasis': {
-      return addMarkToChildren('italic', () => deserializeChildren(node.children, input));
+      return addMarkToChildren('italic', () => deserializeChildren(node.children, getDefinition));
     }
     case 'inlineCode': {
       return addMarkToChildren('code', () => [getTextNodeForCurrentlyActiveMarks(node.value)]);
     }
-    // while it might be nice if we parsed the html here
+    // while it would be nice if we parsed the html here
     // it's a bit more complicated than just parsing the html
     // because an html node might just be an opening/closing node
     // but we just have an opening/closing node here
     // not the opening and closing and children
+    case 'html':
     case 'text': {
       return [getTextNodeForCurrentlyActiveMarks(node.value)];
     }
   }
-  return [
-    getTextNodeForCurrentlyActiveMarks(
-      input.slice(node.position!.start.offset, node.position!.end.offset)
-    ),
-  ];
+  return [];
 }
diff --git a/yarn.lock b/yarn.lock
index f48b51e38..e57e765f8 100644
--- a/yarn.lock
+++ b/yarn.lock
@@ -9750,6 +9750,13 @@ mdast-util-compact@^1.0.0:
   dependencies:
     unist-util-visit "^1.1.0"
 
+mdast-util-definitions@^4.0.0:
+  version "4.0.0"
+  resolved "https://registry.yarnpkg.com/mdast-util-definitions/-/mdast-util-definitions-4.0.0.tgz#c5c1a84db799173b4dcf7643cda999e440c24db2"
+  integrity sha512-k8AJ6aNnUkB7IE+5azR9h81O5EQ/cTDXtWdMq9Kk5KcEW/8ritU5CeLg/9HhOC++nALHBlaogJ5jz0Ybk3kPMQ==
+  dependencies:
+    unist-util-visit "^2.0.0"
+
 mdast-util-definitions@^5.0.0:
   version "5.1.1"
   resolved "https://registry.yarnpkg.com/mdast-util-definitions/-/mdast-util-definitions-5.1.1.tgz#2c1d684b28e53f84938bb06317944bee8efa79db"
@@ -13908,6 +13915,15 @@ unist-util-visit@^1.0.0, unist-util-visit@^1.1.0:
   dependencies:
     unist-util-visit-parents "^2.0.0"
 
+unist-util-visit@^2.0.0:
+  version "2.0.3"
+  resolved "https://registry.yarnpkg.com/unist-util-visit/-/unist-util-visit-2.0.3.tgz#c3703893146df47203bb8a9795af47d7b971208c"
+  integrity sha512-iJ4/RczbJMkD0712mGktuGpm/U4By4FfDonL7N/9tATGIF4imikjOuagyMY53tnZq3NP6BcmlrHhEKAfGWjh7Q==
+  dependencies:
+    "@types/unist" "^2.0.0"
+    unist-util-is "^4.0.0"
+    unist-util-visit-parents "^3.0.0"
+
 unist-util-visit@^4.0.0:
   version "4.1.0"
   resolved "https://registry.yarnpkg.com/unist-util-visit/-/unist-util-visit-4.1.0.tgz#f41e407a9e94da31594e6b1c9811c51ab0b3d8f5"
