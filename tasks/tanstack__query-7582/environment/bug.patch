diff --git a/docs/config.json b/docs/config.json
index 60cf48e8f..637cad210 100644
--- a/docs/config.json
+++ b/docs/config.json
@@ -658,14 +658,6 @@
               "label": "infiniteQueryOptions",
               "to": "framework/react/reference/infiniteQueryOptions"
             },
-            {
-              "label": "usePrefetchQuery",
-              "to": "framework/react/reference/usePrefetchQuery"
-            },
-            {
-              "label": "usePrefetchInfiniteQuery",
-              "to": "framework/react/reference/usePrefetchInfiniteQuery"
-            },
             {
               "label": "QueryErrorResetBoundary",
               "to": "framework/react/reference/QueryErrorResetBoundary"
diff --git a/docs/framework/react/guides/prefetching.md b/docs/framework/react/guides/prefetching.md
index 50626d305..75a5e55a1 100644
--- a/docs/framework/react/guides/prefetching.md
+++ b/docs/framework/react/guides/prefetching.md
@@ -196,41 +196,45 @@ This starts fetching `'article-comments'` immediately and flattens the waterfall
 
 [//]: # 'Suspense'
 
-If you want to prefetch together with Suspense, you will have to do things a bit differently. You can't use `useSuspenseQueries` to prefetch, since the prefetch would block the component from rendering. You also can not use `useQuery` for the prefetch, because that wouldn't start the prefetch until after suspenseful query had resolved. For this scenario, you can use the [`usePrefetchQuery`](../reference/usePrefetchQuery) or the [`usePrefetchInfiniteQuery`](../reference/usePrefetchInfiniteQuery) hooks available in the library.
-
-You can now use `useSuspenseQuery` in the component that actually needs the data. You _might_ want to wrap this later component in its own `<Suspense>` boundary so the "secondary" query we are prefetching does not block rendering of the "primary" data.
+If you want to prefetch together with Suspense, you will have to do things a bit differently. You can't use `useSuspenseQueries` to prefetch, since the prefetch would block the component from rendering. You also can not use `useQuery` for the prefetch, because that wouldn't start the prefetch until after suspenseful query had resolved. What you can do is add a small `usePrefetchQuery` function (we might add this to the library itself at a later point):
 
 ```tsx
-function App() {
-  usePrefetchQuery({
-    queryKey: ['articles'],
-    queryFn: (...args) => {
-      return getArticles(...args)
-    },
-  })
+function usePrefetchQuery(options) {
+  const queryClient = useQueryClient()
 
-  return (
-    <Suspense fallback="Loading articles...">
-      <Articles />
-    </Suspense>
-  )
+  // This happens in render, but is safe to do because ensureQueryData
+  // only fetches if there is no data in the cache for this query. This
+  // means we know no observers are watching the data so the side effect
+  // is not observable, which is safe.
+  if (!queryClient.getQueryState(options.queryKey)) {
+    queryClient.ensureQueryData(options).catch(() => {
+      // Avoid uncaught error
+    })
+  }
 }
+```
 
-function Articles() {
-  const { data: articles } = useSuspenseQuery({
-    queryKey: ['articles'],
-    queryFn: (...args) => {
-      return getArticles(...args)
-    },
-  })
+This approach works with both `useQuery` and `useSuspenseQuery`, so feel free to use it as an alternative to the `useQuery({ ..., notifyOnChangeProps: [] })` approach as well. The only tradeoff is that the above function will never fetch and _update_ existing data in the cache if it's stale, but this will usually happen in the later query anyway.
 
-  return articles.map((article) => (
-    <div key={articleData.id}>
-      <ArticleHeader article={article} />
-      <ArticleBody article={article} />
-    </div>
-  ))
-}
+You can now use `useSuspenseQuery` in the component that actually needs the data. You _might_ want to wrap this later component in its own `<Suspense>` boundary so the "secondary" query we are prefetching does not block rendering of the "primary" data.
+
+```tsx
+// Prefetch
+usePrefetchQuery({
+  queryKey: ['article-comments', id],
+  queryFn: getArticleCommentsById,
+})
+
+const { data: articleResult } = useSuspenseQuery({
+  queryKey: ['article', id],
+  queryFn: getArticleById,
+})
+
+// In nested component:
+const { data: commentsResult } = useSuspenseQuery({
+  queryKey: ['article-comments', id],
+  queryFn: getArticleCommentsById,
+})
 ```
 
 Another way is to prefetch inside of the query function. This makes sense if you know that every time an article is fetched it's very likely comments will also be needed. For this, we'll use `queryClient.prefetchQuery`:
@@ -265,7 +269,6 @@ useEffect(() => {
 
 To recap, if you want to prefetch a query during the component lifecycle, there are a few different ways to do it, pick the one that suits your situation best:
 
-- Prefetch before a suspense boundary using `usePrefetchQuery` or `usePrefetchInfiniteQuery` hooks
 - Use `useQuery` or `useSuspenseQueries` and ignore the result
 - Prefetch inside the query function
 - Prefetch in an effect
diff --git a/docs/framework/react/reference/usePrefetchInfiniteQuery.md b/docs/framework/react/reference/usePrefetchInfiniteQuery.md
deleted file mode 100644
index 2791ec444..000000000
--- a/docs/framework/react/reference/usePrefetchInfiniteQuery.md
+++ /dev/null
@@ -1,37 +0,0 @@
----
-id: usePrefetchInfiniteQuery
-title: usePrefetchInfiniteQuery
----
-
-```tsx
-const result = usePrefetchInfiniteQuery(options)
-```
-
-**Options**
-
-You can pass everything to `usePrefetchInfiniteQuery` that you can pass to [`queryClient.prefetchInfiniteQuery`](../../../reference/QueryClient#queryclientprefetchinfinitequery). Remember that some of them are required as below:
-
-- `queryKey: QueryKey`
-
-  - **Required**
-  - The query key to prefetch during render
-
-- `queryFn: (context: QueryFunctionContext) => Promise<TData>`
-
-  - **Required, but only if no default query function has been defined** See [Default Query Function](../../guides/default-query-function) for more information.
-
-- `initialPageParam: TPageParam`
-
-  - **Required**
-  - The default page param to use when fetching the first page.
-
-- `getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => TPageParam | undefined | null`
-
-  - **Required**
-  - When new data is received for this query, this function receives both the last page of the infinite list of data and the full array of all pages, as well as pageParam information.
-  - It should return a **single variable** that will be passed as the last optional parameter to your query function.
-  - Return `undefined` or `null` to indicate there is no next page available.
-
-- **Returns**
-
-The `usePrefetchInfiniteQuery` does not return anything, it should be used just to fire a prefetch during render, before a suspense boundary that wraps a component that uses [`useSuspenseInfiniteQuery`](../reference/useSuspenseInfiniteQuery)
diff --git a/docs/framework/react/reference/usePrefetchQuery.md b/docs/framework/react/reference/usePrefetchQuery.md
deleted file mode 100644
index f7b12a42f..000000000
--- a/docs/framework/react/reference/usePrefetchQuery.md
+++ /dev/null
@@ -1,24 +0,0 @@
----
-id: usePrefetchQuery
-title: usePrefetchQuery
----
-
-```tsx
-const result = usePrefetchQuery(options)
-```
-
-**Options**
-
-You can pass everything to `usePrefetchQuery` that you can pass to [`queryClient.prefetchQuery`](../../../reference/QueryClient#queryclientprefetchquery). Remember that some of them are required as below:
-
-- `queryKey: QueryKey`
-
-  - **Required**
-  - The query key to prefetch during render
-
-- `queryFn: (context: QueryFunctionContext) => Promise<TData>`
-  - **Required, but only if no default query function has been defined** See [Default Query Function](../../guides/default-query-function) for more information.
-
-**Returns**
-
-The `usePrefetchQuery` does not return anything, it should be used just to fire a prefetch during render, before a suspense boundary that wraps a component that uses [`useSuspenseQuery`](../reference/useSuspenseQuery).
diff --git a/packages/react-query/src/__tests__/prefetch.test-d.tsx b/packages/react-query/src/__tests__/prefetch.test-d.tsx
deleted file mode 100644
index 34ab8bc64..000000000
--- a/packages/react-query/src/__tests__/prefetch.test-d.tsx
+++ /dev/null
@@ -1,80 +0,0 @@
-import { describe, expectTypeOf, it } from 'vitest'
-import { usePrefetchInfiniteQuery, usePrefetchQuery } from '../prefetch'
-
-describe('usePrefetchQuery', () => {
-  it('should return nothing', () => {
-    const result = usePrefetchQuery({
-      queryKey: ['key'],
-      queryFn: () => Promise.resolve(5),
-    })
-
-    expectTypeOf(result).toEqualTypeOf<void>()
-  })
-
-  it('should not allow refetchInterval, enabled or throwOnError options', () => {
-    usePrefetchQuery({
-      queryKey: ['key'],
-      queryFn: () => Promise.resolve(5),
-      // @ts-expect-error TS2345
-      refetchInterval: 1000,
-    })
-
-    usePrefetchQuery({
-      queryKey: ['key'],
-      queryFn: () => Promise.resolve(5),
-      // @ts-expect-error TS2345
-      enabled: true,
-    })
-
-    usePrefetchQuery({
-      queryKey: ['key'],
-      queryFn: () => Promise.resolve(5),
-      // @ts-expect-error TS2345
-      throwOnError: true,
-    })
-  })
-})
-
-describe('useInfinitePrefetchQuery', () => {
-  it('should return nothing', () => {
-    const result = usePrefetchInfiniteQuery({
-      queryKey: ['key'],
-      queryFn: () => Promise.resolve(5),
-      initialPageParam: 1,
-      getNextPageParam: () => 1,
-    })
-
-    expectTypeOf(result).toEqualTypeOf<void>()
-  })
-
-  it('should require initialPageParam and getNextPageParam', () => {
-    // @ts-expect-error TS2345
-    usePrefetchInfiniteQuery({
-      queryKey: ['key'],
-      queryFn: () => Promise.resolve(5),
-    })
-  })
-
-  it('should not allow refetchInterval, enabled or throwOnError options', () => {
-    usePrefetchQuery({
-      queryKey: ['key'],
-      queryFn: () => Promise.resolve(5),
-      // @ts-expect-error TS2345
-      refetchInterval: 1000,
-    })
-
-    usePrefetchQuery({
-      queryKey: ['key'],
-      queryFn: () => Promise.resolve(5),
-      // @ts-expect-error TS2345
-      enabled: true,
-    })
-
-    usePrefetchQuery({
-      queryKey: ['key'],
-      queryFn: () => Promise.resolve(5),
-      // @ts-expect-error TS2345
-      throwOnError: true,
-    })
-  })
-})
diff --git a/packages/react-query/src/__tests__/prefetch.test.tsx b/packages/react-query/src/__tests__/prefetch.test.tsx
deleted file mode 100644
index 760047782..000000000
--- a/packages/react-query/src/__tests__/prefetch.test.tsx
+++ /dev/null
@@ -1,434 +0,0 @@
-import { describe, expect, it, vi } from 'vitest'
-import React from 'react'
-import { fireEvent, waitFor } from '@testing-library/react'
-import { ErrorBoundary } from 'react-error-boundary'
-import {
-  QueryCache,
-  usePrefetchInfiniteQuery,
-  usePrefetchQuery,
-  useQueryErrorResetBoundary,
-  useSuspenseInfiniteQuery,
-  useSuspenseQuery,
-} from '..'
-import { createQueryClient, queryKey, renderWithClient, sleep } from './utils'
-
-import type { InfiniteData, UseInfiniteQueryOptions, UseQueryOptions } from '..'
-import type { Mock } from 'vitest'
-
-const generateQueryFn = (data: string) =>
-  vi.fn<any, Promise<string>>().mockImplementation(async () => {
-    await sleep(10)
-
-    return data
-  })
-
-const generateInfiniteQueryOptions = (
-  data: Array<{ data: string; currentPage: number; totalPages: number }>,
-) => {
-  let currentPage = 0
-
-  return {
-    queryFn: vi
-      .fn<any, Promise<(typeof data)[number]>>()
-      .mockImplementation(async () => {
-        const currentPageData = data[currentPage]
-        if (!currentPageData) {
-          throw new Error('No data defined for page ' + currentPage)
-        }
-
-        await sleep(10)
-        currentPage++
-
-        return currentPageData
-      }),
-    initialPageParam: 1,
-    getNextPageParam: (lastPage: (typeof data)[number]) =>
-      lastPage.currentPage === lastPage.totalPages
-        ? undefined
-        : lastPage.currentPage + 1,
-  }
-}
-
-describe('usePrefetchQuery', () => {
-  const queryCache = new QueryCache()
-  const queryClient = createQueryClient({ queryCache })
-
-  function Suspended<TData = unknown>(props: {
-    queryOpts: UseQueryOptions<TData, Error, TData, Array<string>>
-    children?: React.ReactNode
-  }) {
-    const state = useSuspenseQuery(props.queryOpts)
-
-    return (
-      <div>
-        <div>data: {String(state.data)}</div>
-        {props.children}
-      </div>
-    )
-  }
-
-  it('should prefetch query if query state does not exist', async () => {
-    const queryOpts = {
-      queryKey: queryKey(),
-      queryFn: generateQueryFn('prefetchQuery'),
-    }
-
-    const componentQueryOpts = {
-      ...queryOpts,
-      queryFn: generateQueryFn('useSuspenseQuery'),
-    }
-
-    function App() {
-      usePrefetchQuery(queryOpts)
-
-      return (
-        <React.Suspense fallback="Loading...">
-          <Suspended queryOpts={componentQueryOpts} />
-        </React.Suspense>
-      )
-    }
-
-    const rendered = renderWithClient(queryClient, <App />)
-
-    await waitFor(() => rendered.getByText('data: prefetchQuery'))
-    expect(queryOpts.queryFn).toHaveBeenCalledTimes(1)
-  })
-
-  it('should not prefetch query if query state exists', async () => {
-    const queryOpts = {
-      queryKey: queryKey(),
-      queryFn: generateQueryFn('The usePrefetchQuery hook is smart!'),
-    }
-
-    function App() {
-      usePrefetchQuery(queryOpts)
-
-      return (
-        <React.Suspense fallback="Loading...">
-          <Suspended queryOpts={queryOpts} />
-        </React.Suspense>
-      )
-    }
-
-    await queryClient.fetchQuery(queryOpts)
-    queryOpts.queryFn.mockClear()
-    const rendered = renderWithClient(queryClient, <App />)
-
-    expect(rendered.queryByText('fetching: true')).not.toBeInTheDocument()
-    await waitFor(() =>
-      rendered.getByText('data: The usePrefetchQuery hook is smart!'),
-    )
-    expect(queryOpts.queryFn).not.toHaveBeenCalled()
-  })
-
-  it('should let errors fall through and not refetch failed queries', async () => {
-    const queryFn = generateQueryFn('Not an error')
-
-    const queryOpts = {
-      queryKey: queryKey(),
-      queryFn,
-    }
-
-    queryFn.mockImplementationOnce(async () => {
-      await sleep(10)
-
-      throw new Error('Oops! Server error!')
-    })
-
-    function App() {
-      usePrefetchQuery(queryOpts)
-
-      return (
-        <ErrorBoundary fallbackRender={() => <div>Oops!</div>}>
-          <React.Suspense fallback="Loading...">
-            <Suspended queryOpts={queryOpts} />
-          </React.Suspense>
-        </ErrorBoundary>
-      )
-    }
-
-    await queryClient.prefetchQuery(queryOpts)
-    queryFn.mockClear()
-    const rendered = renderWithClient(queryClient, <App />)
-
-    await waitFor(() => rendered.getByText('Oops!'))
-    expect(rendered.queryByText('data: Not an error')).not.toBeInTheDocument()
-    expect(queryOpts.queryFn).not.toHaveBeenCalled()
-  })
-
-  it('should not create an endless loop when using inside a suspense boundary', async () => {
-    const queryFn = generateQueryFn('prefetchedQuery')
-
-    const queryOpts = {
-      queryKey: queryKey(),
-      queryFn,
-    }
-
-    function Prefetch({ children }: { children: React.ReactNode }) {
-      usePrefetchQuery(queryOpts)
-      return <>{children}</>
-    }
-
-    function App() {
-      return (
-        <React.Suspense>
-          <Prefetch>
-            <Suspended queryOpts={queryOpts} />
-          </Prefetch>
-        </React.Suspense>
-      )
-    }
-
-    const rendered = renderWithClient(queryClient, <App />)
-    await waitFor(() => rendered.getByText('data: prefetchedQuery'))
-    expect(queryOpts.queryFn).toHaveBeenCalledTimes(1)
-  })
-
-  it('should be able to recover from errors and try fetching again', async () => {
-    const queryFn = generateQueryFn('This is fine :dog: :fire:')
-
-    const queryOpts = {
-      queryKey: queryKey(),
-      queryFn,
-    }
-
-    queryFn.mockImplementationOnce(async () => {
-      await sleep(10)
-
-      throw new Error('Oops! Server error!')
-    })
-
-    function App() {
-      const { reset } = useQueryErrorResetBoundary()
-      usePrefetchQuery(queryOpts)
-
-      return (
-        <ErrorBoundary
-          onReset={reset}
-          fallbackRender={({ resetErrorBoundary }) => (
-            <div>
-              <div>Oops!</div>
-              <button onClick={resetErrorBoundary}>Try again</button>
-            </div>
-          )}
-        >
-          <React.Suspense fallback="Loading...">
-            <Suspended queryOpts={queryOpts} />
-          </React.Suspense>
-        </ErrorBoundary>
-      )
-    }
-
-    await queryClient.prefetchQuery(queryOpts)
-    queryFn.mockClear()
-
-    const rendered = renderWithClient(queryClient, <App />)
-
-    await waitFor(() => rendered.getByText('Oops!'))
-    fireEvent.click(rendered.getByText('Try again'))
-    await waitFor(() => rendered.getByText('data: This is fine :dog: :fire:'))
-    expect(queryOpts.queryFn).toHaveBeenCalledTimes(1)
-  })
-
-  it('should not create a suspense waterfall if prefetch is fired', async () => {
-    const firstQueryOpts = {
-      queryKey: queryKey(),
-      queryFn: generateQueryFn('Prefetch is nice!'),
-    }
-
-    const secondQueryOpts = {
-      queryKey: queryKey(),
-      queryFn: generateQueryFn('Prefetch is really nice!!'),
-    }
-
-    const thirdQueryOpts = {
-      queryKey: queryKey(),
-      queryFn: generateQueryFn('Prefetch does not create waterfalls!!'),
-    }
-
-    const Fallback = vi.fn().mockImplementation(() => <div>Loading...</div>)
-
-    function App() {
-      usePrefetchQuery(firstQueryOpts)
-      usePrefetchQuery(secondQueryOpts)
-      usePrefetchQuery(thirdQueryOpts)
-
-      return (
-        <React.Suspense fallback={<Fallback />}>
-          <Suspended queryOpts={firstQueryOpts}>
-            <Suspended queryOpts={secondQueryOpts}>
-              <Suspended queryOpts={thirdQueryOpts} />
-            </Suspended>
-          </Suspended>
-        </React.Suspense>
-      )
-    }
-
-    const rendered = renderWithClient(queryClient, <App />)
-    expect(
-      queryClient.getQueryState(firstQueryOpts.queryKey)?.fetchStatus,
-    ).toBe('fetching')
-    expect(
-      queryClient.getQueryState(secondQueryOpts.queryKey)?.fetchStatus,
-    ).toBe('fetching')
-    expect(
-      queryClient.getQueryState(thirdQueryOpts.queryKey)?.fetchStatus,
-    ).toBe('fetching')
-    await waitFor(() => rendered.getByText('Loading...'))
-    await waitFor(() => rendered.getByText('data: Prefetch is nice!'))
-    await waitFor(() => rendered.getByText('data: Prefetch is really nice!!'))
-    await waitFor(() =>
-      rendered.getByText('data: Prefetch does not create waterfalls!!'),
-    )
-    expect(Fallback).toHaveBeenCalledTimes(1)
-    expect(firstQueryOpts.queryFn).toHaveBeenCalledTimes(1)
-    expect(secondQueryOpts.queryFn).toHaveBeenCalledTimes(1)
-    expect(thirdQueryOpts.queryFn).toHaveBeenCalledTimes(1)
-  })
-})
-
-describe('usePrefetchInfiniteQuery', () => {
-  const queryCache = new QueryCache()
-  const queryClient = createQueryClient({ queryCache })
-
-  const Fallback = vi.fn().mockImplementation(() => <div>Loading...</div>)
-
-  function Suspended<T = unknown>(props: {
-    queryOpts: UseInfiniteQueryOptions<
-      T,
-      Error,
-      InfiniteData<T>,
-      any,
-      Array<string>,
-      any
-    >
-    renderPage: (page: T) => React.JSX.Element
-  }) {
-    const state = useSuspenseInfiniteQuery(props.queryOpts)
-
-    return (
-      <div>
-        {state.data.pages.map((page) => props.renderPage(page))}
-        <button onClick={() => state.fetchNextPage()}>Next Page</button>
-      </div>
-    )
-  }
-
-  it('should prefetch an infinite query if query state does not exist', async () => {
-    const data = [
-      { data: 'Do you fetch on render?', currentPage: 1, totalPages: 3 },
-      { data: 'Or do you render as you fetch?', currentPage: 2, totalPages: 3 },
-      {
-        data: 'Either way, Tanstack Query helps you!',
-        currentPage: 3,
-        totalPages: 3,
-      },
-    ]
-
-    const queryOpts = {
-      queryKey: queryKey(),
-      ...generateInfiniteQueryOptions(data),
-    }
-
-    function App() {
-      usePrefetchInfiniteQuery({ ...queryOpts, pages: data.length })
-
-      return (
-        <React.Suspense fallback={<Fallback />}>
-          <Suspended
-            queryOpts={queryOpts}
-            renderPage={(page) => <div>data: {page.data}</div>}
-          />
-        </React.Suspense>
-      )
-    }
-
-    const rendered = renderWithClient(queryClient, <App />)
-
-    await waitFor(() => rendered.getByText('data: Do you fetch on render?'))
-    fireEvent.click(rendered.getByText('Next Page'))
-    await waitFor(() =>
-      rendered.getByText('data: Or do you render as you fetch?'),
-    )
-    fireEvent.click(rendered.getByText('Next Page'))
-    await waitFor(() =>
-      rendered.getByText('data: Either way, Tanstack Query helps you!'),
-    )
-    expect(Fallback).toHaveBeenCalledTimes(1)
-    expect(queryOpts.queryFn).toHaveBeenCalledTimes(3)
-  })
-
-  it('should not display fallback if the query cache is already populated', async () => {
-    const queryOpts = {
-      queryKey: queryKey(),
-      ...generateInfiniteQueryOptions([
-        { data: 'Prefetch rocks!', currentPage: 1, totalPages: 3 },
-        { data: 'No waterfalls, boy!', currentPage: 2, totalPages: 3 },
-        { data: 'Tanstack Query #ftw', currentPage: 3, totalPages: 3 },
-      ]),
-    }
-
-    await queryClient.prefetchInfiniteQuery({ ...queryOpts, pages: 3 })
-    ;(queryOpts.queryFn as Mock).mockClear()
-
-    function App() {
-      usePrefetchInfiniteQuery(queryOpts)
-
-      return (
-        <React.Suspense fallback={<Fallback />}>
-          <Suspended
-            queryOpts={queryOpts}
-            renderPage={(page) => <div>data: {page.data}</div>}
-          />
-        </React.Suspense>
-      )
-    }
-
-    const rendered = renderWithClient(queryClient, <App />)
-
-    await waitFor(() => rendered.getByText('data: Prefetch rocks!'))
-    fireEvent.click(rendered.getByText('Next Page'))
-    await waitFor(() => rendered.getByText('data: No waterfalls, boy!'))
-    fireEvent.click(rendered.getByText('Next Page'))
-    await waitFor(() => rendered.getByText('data: Tanstack Query #ftw'))
-    expect(queryOpts.queryFn).not.toHaveBeenCalled()
-    expect(Fallback).not.toHaveBeenCalled()
-  })
-
-  it('should not create an endless loop when using inside a suspense boundary', async () => {
-    const queryOpts = {
-      queryKey: queryKey(),
-      ...generateInfiniteQueryOptions([
-        { data: 'Infinite Page 1', currentPage: 1, totalPages: 3 },
-        { data: 'Infinite Page 2', currentPage: 1, totalPages: 3 },
-        { data: 'Infinite Page 3', currentPage: 1, totalPages: 3 },
-      ]),
-    }
-
-    function Prefetch({ children }: { children: React.ReactNode }) {
-      usePrefetchInfiniteQuery(queryOpts)
-      return <>{children}</>
-    }
-
-    function App() {
-      return (
-        <React.Suspense>
-          <Prefetch>
-            <Suspended
-              queryOpts={queryOpts}
-              renderPage={(page) => <div>data: {page.data}</div>}
-            />
-          </Prefetch>
-        </React.Suspense>
-      )
-    }
-
-    const rendered = renderWithClient(queryClient, <App />)
-    await waitFor(() => rendered.getByText('data: Infinite Page 1'))
-    fireEvent.click(rendered.getByText('Next Page'))
-    await waitFor(() => rendered.getByText('data: Infinite Page 2'))
-    fireEvent.click(rendered.getByText('Next Page'))
-    await waitFor(() => rendered.getByText('data: Infinite Page 3'))
-    expect(queryOpts.queryFn).toHaveBeenCalledTimes(3)
-  })
-})
diff --git a/packages/react-query/src/index.ts b/packages/react-query/src/index.ts
index 2450b6a66..926c673a6 100644
--- a/packages/react-query/src/index.ts
+++ b/packages/react-query/src/index.ts
@@ -15,7 +15,6 @@ export type {
   SuspenseQueriesResults,
   SuspenseQueriesOptions,
 } from './useSuspenseQueries'
-export { usePrefetchQuery, usePrefetchInfiniteQuery } from './prefetch'
 export { queryOptions } from './queryOptions'
 export type {
   DefinedInitialDataOptions,
diff --git a/packages/react-query/src/prefetch.ts b/packages/react-query/src/prefetch.ts
deleted file mode 100644
index 4bc1f9bec..000000000
--- a/packages/react-query/src/prefetch.ts
+++ /dev/null
@@ -1,42 +0,0 @@
-import { useQueryClient } from './QueryClientProvider'
-import type {
-  DefaultError,
-  FetchInfiniteQueryOptions,
-  FetchQueryOptions,
-  QueryKey,
-} from '@tanstack/query-core'
-
-export function usePrefetchQuery<
-  TQueryFnData = unknown,
-  TError = DefaultError,
-  TData = TQueryFnData,
-  TQueryKey extends QueryKey = QueryKey,
->(options: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>) {
-  const queryClient = useQueryClient()
-
-  if (!queryClient.getQueryState(options.queryKey)) {
-    queryClient.prefetchQuery(options)
-  }
-}
-
-export function usePrefetchInfiniteQuery<
-  TQueryFnData = unknown,
-  TError = DefaultError,
-  TData = TQueryFnData,
-  TQueryKey extends QueryKey = QueryKey,
-  TPageParam = unknown,
->(
-  options: FetchInfiniteQueryOptions<
-    TQueryFnData,
-    TError,
-    TData,
-    TQueryKey,
-    TPageParam
-  >,
-) {
-  const queryClient = useQueryClient()
-
-  if (!queryClient.getQueryState(options.queryKey)) {
-    queryClient.prefetchInfiniteQuery(options)
-  }
-}
