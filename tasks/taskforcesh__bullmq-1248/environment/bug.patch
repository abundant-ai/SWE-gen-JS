diff --git a/docs/gitbook/guide/jobs/repeatable.md b/docs/gitbook/guide/jobs/repeatable.md
index 2e77393d29..22913d2eeb 100644
--- a/docs/gitbook/guide/jobs/repeatable.md
+++ b/docs/gitbook/guide/jobs/repeatable.md
@@ -31,7 +31,7 @@ await myQueue.add(
   { color: 'yellow' },
   {
     repeat: {
-      pattern: '* 15 3 * * *',
+      cron: '* 15 3 * * *',
     },
   },
 );
@@ -108,72 +108,3 @@ For instance, let's say that you have a job that is repeated every second, but t
 In this particular example, the worker will pick up the next job and also add the next repeatable job delayed 1 second since that is the repeatable interval. The worker will require 5 seconds to process the job, and if there is only 1 worker available then the next job will need to wait a full 5 seconds before it can be processed.
 
 On the other hand, if there were 5 workers available, then they will most likely be able to process all the repeatable jobs with the desired frequency of one job per second.
-
-# Repeat Strategy
-
-By default, we are using [cron-parser](https://www.npmjs.com/package/cron-parser) in the default repeat strategy for cron expressions.
-
-It is possible to define a different strategy to schedule repeatable jobs. For example we can create a custom one for RRULE:
-
-```typescript
-import { Queue, QueueScheduler, Worker } from 'bullmq';
-import { rrulestr } from 'rrule';
-
-const settings = {
-  repeatStrategy: (millis, opts) => {
-    const currentDate =
-      opts.startDate && new Date(opts.startDate) > new Date(millis)
-        ? new Date(opts.startDate)
-        : new Date(millis);
-    const rrule = rrulestr(opts.pattern);
-    if (rrule.origOptions.count && !rrule.origOptions.dtstart) {
-      throw new Error('DTSTART must be defined to use COUNT with rrule');
-    }
-
-    const next_occurrence = rrule.after(currentDate, false);
-    return next_occurrence?.getTime();
-  },
-};
-
-const myQueueScheduler = new QueueScheduler('Paint');
-const myQueue = new Queue('Paint', { settings });
-
-// Repeat job every 10 seconds
-await myQueue.add(
-  'bird',
-  { color: 'bird' },
-  {
-    repeat: {
-      pattern: 'RRULE:FREQ=SECONDLY;INTERVAL=;WKST=MO',
-    },
-    jobId: 'colibri',
-  },
-);
-
-await myQueue.add(
-  'bird',
-  { color: 'bird' },
-  {
-    repeat: {
-      pattern: 'RRULE:FREQ=SECONDLY;INTERVAL=;WKST=MO',
-    },
-    jobId: 'pigeon',
-  },
-);
-
-const worker = new Worker(
-  'Paint',
-  async () => {
-    doSomething();
-  },
-  { settings },
-);
-```
-
-{% hint style="warning" %}
-As you may notice, repeat strategy setting should be provided in Queue and Worker classes. The reason we need in both places is because the first time we add the job to the Queue we need to calculate when is the next iteration, but after that the Worker takes over and we use the worker settings.
-{% endhint %}
-
-{% hint style="info" %}
-Repeat strategy function receives an optional jobName parameter as the 3rd one.
-{% endhint %}
diff --git a/package.json b/package.json
index d7d52140a9..31e6f156ee 100644
--- a/package.json
+++ b/package.json
@@ -100,7 +100,6 @@
     "prettier": "^2.7.1",
     "pretty-quick": "^3.1.3",
     "rimraf": "^3.0.2",
-    "rrule": "^2.6.9",
     "semantic-release": "^19.0.3",
     "sinon": "^14.0.0",
     "test-console": "^2.0.0",
diff --git a/src/classes/repeat.ts b/src/classes/repeat.ts
index 0951c3cd8e..d6cd95cc4c 100644
--- a/src/classes/repeat.ts
+++ b/src/classes/repeat.ts
@@ -1,25 +1,10 @@
-import { parseExpression } from 'cron-parser';
 import { createHash } from 'crypto';
-import { JobsOptions, RepeatBaseOptions, RepeatOptions } from '../interfaces';
-import { RepeatStrategy } from '../types';
+import { JobsOptions, RepeatOptions } from '../interfaces';
 import { Job } from './job';
 import { QueueBase } from './queue-base';
-import { RedisConnection } from './redis-connection';
+import { parseExpression } from 'cron-parser';
 
 export class Repeat extends QueueBase {
-  private repeatStrategy: RepeatStrategy;
-
-  constructor(
-    name: string,
-    opts?: RepeatBaseOptions,
-    Connection?: typeof RedisConnection,
-  ) {
-    super(name, opts, Connection);
-
-    this.repeatStrategy =
-      (opts.settings && opts.settings.repeatStrategy) || getNextMillis;
-  }
-
   async addNextRepeatableJob<T = any, R = any, N extends string = string>(
     name: N,
     data: T,
@@ -48,11 +33,10 @@ export class Repeat extends QueueBase {
 
     now = prevMillis < now ? now : prevMillis;
 
-    const nextMillis = await this.repeatStrategy(now, repeatOpts, name);
-    const pattern = repeatOpts.pattern || repeatOpts.cron;
+    const nextMillis = getNextMillis(now, repeatOpts);
 
     const hasImmediately =
-      (repeatOpts.every || pattern) && repeatOpts.immediately;
+      (repeatOpts.every || repeatOpts.cron) && repeatOpts.immediately;
     const offset = hasImmediately ? now - nextMillis : undefined;
     if (nextMillis) {
       // We store the undecorated opts.jobId into the repeat options
@@ -159,9 +143,8 @@ export class Repeat extends QueueBase {
     return this.scripts.removeRepeatable(repeatJobId, repeatJobKey);
   }
 
-  private keyToData(key: string, next?: number) {
+  private keyToData(key: string) {
     const data = key.split(':');
-    const pattern = data.slice(4).join(':') || null;
 
     return {
       key,
@@ -169,9 +152,7 @@ export class Repeat extends QueueBase {
       id: data[1] || null,
       endDate: parseInt(data[2]) || null,
       tz: data[3] || null,
-      cron: pattern,
-      pattern,
-      next,
+      cron: data[4],
     };
   }
 
@@ -185,7 +166,16 @@ export class Repeat extends QueueBase {
 
     const jobs = [];
     for (let i = 0; i < result.length; i += 2) {
-      jobs.push(this.keyToData(result[i], parseInt(result[i + 1])));
+      const data = result[i].split(':');
+      jobs.push({
+        key: result[i],
+        name: data[0],
+        id: data[1] || null,
+        endDate: parseInt(data[2]) || null,
+        tz: data[3] || null,
+        cron: data[4],
+        next: parseInt(result[i + 1]),
+      });
     }
     return jobs;
   }
@@ -211,18 +201,16 @@ function getRepeatJobId(
 function getRepeatKey(name: string, repeat: RepeatOptions) {
   const endDate = repeat.endDate ? new Date(repeat.endDate).getTime() : '';
   const tz = repeat.tz || '';
-  const pattern = repeat.pattern || repeat.cron;
-  const suffix = (pattern ? pattern : String(repeat.every)) || '';
+  const suffix = (repeat.cron ? repeat.cron : String(repeat.every)) || '';
   const jobId = repeat.jobId ? repeat.jobId : '';
 
   return `${name}:${jobId}:${endDate}:${tz}:${suffix}`;
 }
 
-export const getNextMillis = (millis: number, opts: RepeatOptions): number => {
-  const pattern = opts.pattern || opts.cron;
-  if (pattern && opts.every) {
+function getNextMillis(millis: number, opts: RepeatOptions) {
+  if (opts.cron && opts.every) {
     throw new Error(
-      'Both .cron (or .pattern) and .every options are defined for this repeatable job',
+      'Both .cron and .every options are defined for this repeatable job',
     );
   }
 
@@ -237,7 +225,7 @@ export const getNextMillis = (millis: number, opts: RepeatOptions): number => {
     opts.startDate && new Date(opts.startDate) > new Date(millis)
       ? new Date(opts.startDate)
       : new Date(millis);
-  const interval = parseExpression(pattern, {
+  const interval = parseExpression(opts.cron, {
     ...opts,
     currentDate,
   });
@@ -247,7 +235,7 @@ export const getNextMillis = (millis: number, opts: RepeatOptions): number => {
   } catch (e) {
     // Ignore error
   }
-};
+}
 
 function md5(str: string) {
   return createHash('md5').update(str).digest('hex');
diff --git a/src/interfaces/advanced-options.ts b/src/interfaces/advanced-options.ts
index 8a1bddd58e..29c0c797cb 100644
--- a/src/interfaces/advanced-options.ts
+++ b/src/interfaces/advanced-options.ts
@@ -1,13 +1,4 @@
-import { RepeatStrategy } from '../types';
-
-export interface AdvancedRepeatOptions {
-  /**
-   * A set of custom cron strategies keyed by name.
-   */
-  repeatStrategy?: RepeatStrategy;
-}
-
-export interface AdvancedOptions extends AdvancedRepeatOptions {
+export interface AdvancedOptions {
   /**
    * A set of custom backoff strategies keyed by name.
    */
diff --git a/src/interfaces/queue-options.ts b/src/interfaces/queue-options.ts
index 174ba7041f..df58775976 100644
--- a/src/interfaces/queue-options.ts
+++ b/src/interfaces/queue-options.ts
@@ -1,4 +1,3 @@
-import { AdvancedRepeatOptions } from './advanced-options';
 import { BaseJobOptions } from './jobs-options';
 import { ConnectionOptions } from './redis-options';
 
@@ -63,15 +62,6 @@ export interface QueueOptions extends QueueBaseOptions {
       maxLen: number;
     };
   };
-
-  settings?: AdvancedRepeatOptions;
-}
-
-/**
- * Options for the Repeat class.
- */
-export interface RepeatBaseOptions extends QueueBaseOptions {
-  settings?: AdvancedRepeatOptions;
 }
 
 /**
diff --git a/src/interfaces/repeat-options.ts b/src/interfaces/repeat-options.ts
index ec337c1142..074153701a 100644
--- a/src/interfaces/repeat-options.ts
+++ b/src/interfaces/repeat-options.ts
@@ -7,14 +7,9 @@ import { ParserOptions } from 'cron-parser';
  */
 export interface RepeatOptions extends Omit<ParserOptions, 'iterator'> {
   /**
-   * @deprecated Use pattern option instead.
    * A cron pattern
    */
   cron?: string;
-  /**
-   * A repeat pattern
-   */
-  pattern?: string;
   /**
    * Number of times the job should repeat at max.
    */
diff --git a/src/types/index.ts b/src/types/index.ts
index e8213fb49a..958c20493f 100644
--- a/src/types/index.ts
+++ b/src/types/index.ts
@@ -1,4 +1,3 @@
-export * from './repeat-strategy';
 export * from './finished-status';
 export * from './job-json-sandbox';
 export * from './job-type';
diff --git a/src/types/repeat-strategy.ts b/src/types/repeat-strategy.ts
deleted file mode 100644
index cef79824b2..0000000000
--- a/src/types/repeat-strategy.ts
+++ /dev/null
@@ -1,7 +0,0 @@
-import { RepeatOptions } from '../interfaces/repeat-options';
-
-export type RepeatStrategy = (
-  millis: number,
-  opts: RepeatOptions,
-  name?: string,
-) => number;
diff --git a/tests/test_repeat.ts b/tests/test_repeat.ts
index cb9260f14f..dc44142ccf 100644
--- a/tests/test_repeat.ts
+++ b/tests/test_repeat.ts
@@ -3,14 +3,12 @@ import { default as IORedis } from 'ioredis';
 import { beforeEach, describe, it } from 'mocha';
 import * as sinon from 'sinon';
 import { v4 } from 'uuid';
-import { rrulestr } from 'rrule';
 import {
   Job,
   Queue,
   QueueEvents,
   QueueScheduler,
   Repeat,
-  getNextMillis,
   Worker,
 } from '../src/classes';
 import { JobsOptions } from '../src/interfaces';
@@ -164,7 +162,6 @@ describe('repeat', function () {
         endDate: 12345,
         tz: null,
         cron: '10 * * * * *',
-        pattern: '10 * * * * *',
         next: 10000,
       })
       .and.to.deep.include({
@@ -174,7 +171,6 @@ describe('repeat', function () {
         endDate: 610000,
         tz: null,
         cron: '2 10 * * * *',
-        pattern: '2 10 * * * *',
         next: 602000,
       })
       .and.to.deep.include({
@@ -184,7 +180,6 @@ describe('repeat', function () {
         endDate: null,
         tz: 'Africa/Accra',
         cron: '2 * * 4 * *',
-        pattern: '2 * * 4 * *',
         next: 259202000,
       })
       .and.to.deep.include({
@@ -194,7 +189,6 @@ describe('repeat', function () {
         endDate: null,
         tz: 'Africa/Abidjan',
         cron: '1 * * 5 * *',
-        pattern: '1 * * 5 * *',
         next: 345601000,
       });
   });
@@ -208,7 +202,7 @@ describe('repeat', function () {
 
     const worker = new Worker(
       queueName,
-      async () => {
+      async job => {
         this.clock.tick(nextTick);
       },
       { connection },
@@ -261,7 +255,7 @@ describe('repeat', function () {
 
     const worker = new Worker(
       queueName,
-      async () => {
+      async job => {
         this.clock.tick(nextTick);
       },
       { connection },
@@ -329,7 +323,7 @@ describe('repeat', function () {
       { foo: 'bar' },
       {
         repeat: {
-          pattern: '*/2 * * * * *',
+          cron: '*/2 * * * * *',
           startDate: new Date('2017-02-07 9:22:00'),
         },
       },
@@ -428,195 +422,6 @@ describe('repeat', function () {
     delayStub.restore();
   });
 
-  describe('when custom cron strategy is provided', function () {
-    it('should repeat every 2 seconds', async function () {
-      this.timeout(20000);
-      const settings = {
-        repeatStrategy: (millis, opts) => {
-          const currentDate =
-            opts.startDate && new Date(opts.startDate) > new Date(millis)
-              ? new Date(opts.startDate)
-              : new Date(millis);
-          const rrule = rrulestr(opts.pattern);
-          if (rrule.origOptions.count && !rrule.origOptions.dtstart) {
-            throw new Error('DTSTART must be defined to use COUNT with rrule');
-          }
-
-          const next_occurrence = rrule.after(currentDate, false);
-          return next_occurrence?.getTime();
-        },
-      };
-      const currentQueue = new Queue(queueName, { connection, settings });
-      const queueScheduler = new QueueScheduler(queueName, { connection });
-      await queueScheduler.waitUntilReady();
-
-      const nextTick = 2 * ONE_SECOND + 100;
-
-      const worker = new Worker(
-        queueName,
-        async () => {
-          this.clock.tick(nextTick);
-        },
-        { connection, settings },
-      );
-      const delayStub = sinon.stub(worker, 'delay').callsFake(async () => {});
-
-      const date = new Date('2017-02-07 9:24:00');
-      this.clock.setSystemTime(date);
-
-      await currentQueue.add(
-        'test',
-        { foo: 'bar' },
-        {
-          repeat: {
-            pattern: 'RRULE:FREQ=SECONDLY;INTERVAL=2;WKST=MO',
-          },
-        },
-      );
-
-      this.clock.tick(nextTick);
-
-      let prev: any;
-      let counter = 0;
-
-      const completing = new Promise<void>(resolve => {
-        worker.on('completed', async job => {
-          if (prev) {
-            expect(prev.timestamp).to.be.lt(job.timestamp);
-            expect(job.timestamp - prev.timestamp).to.be.gte(2000);
-          }
-          prev = job;
-          counter++;
-          if (counter == 5) {
-            resolve();
-          }
-        });
-      });
-
-      await completing;
-      await currentQueue.close();
-      await worker.close();
-      await queueScheduler.close();
-      delayStub.restore();
-    });
-
-    describe('when differentiating strategy by job name', function () {
-      it('should repeat every 2 seconds', async function () {
-        this.timeout(10000);
-        const settings = {
-          repeatStrategy: (millis, opts, name) => {
-            if (name === 'rrule') {
-              const currentDate =
-                opts.startDate && new Date(opts.startDate) > new Date(millis)
-                  ? new Date(opts.startDate)
-                  : new Date(millis);
-              const rrule = rrulestr(opts.cron);
-              if (rrule.origOptions.count && !rrule.origOptions.dtstart) {
-                throw new Error(
-                  'DTSTART must be defined to use COUNT with rrule',
-                );
-              }
-
-              const next_occurrence = rrule.after(currentDate, false);
-              return next_occurrence?.getTime();
-            } else {
-              return getNextMillis(millis, opts);
-            }
-          },
-        };
-        const currentQueue = new Queue(queueName, { connection, settings });
-        const queueScheduler = new QueueScheduler(queueName, { connection });
-        await queueScheduler.waitUntilReady();
-
-        const nextTick = 2 * ONE_SECOND + 100;
-
-        const worker = new Worker(
-          queueName,
-          async () => {
-            this.clock.tick(nextTick);
-          },
-          { connection, settings },
-        );
-        const delayStub = sinon.stub(worker, 'delay').callsFake(async () => {});
-
-        const date = new Date('2017-02-07 9:24:00');
-        this.clock.setSystemTime(date);
-
-        const repeat = {
-          cron: 'RRULE:FREQ=SECONDLY;INTERVAL=2;WKST=MO',
-        };
-        await currentQueue.add(
-          'rrule',
-          { foo: 'bar' },
-          {
-            repeat,
-          },
-        );
-
-        this.clock.tick(nextTick);
-
-        let prev: any;
-        let counter = 0;
-
-        const completing = new Promise<void>(resolve => {
-          worker.on('completed', async job => {
-            if (prev) {
-              expect(prev.timestamp).to.be.lt(job.timestamp);
-              expect(job.timestamp - prev.timestamp).to.be.gte(2000);
-            }
-            prev = job;
-            counter++;
-            if (counter == 5) {
-              const removed = await queue.removeRepeatable('rrule', repeat);
-              expect(removed).to.be.true;
-
-              resolve();
-            }
-          });
-        });
-
-        await completing;
-
-        await queue.add(
-          'test',
-          { foo: 'bar' },
-          {
-            repeat: {
-              cron: '*/2 * * * * *',
-              startDate: new Date('2017-02-07 9:24:05'),
-            },
-          },
-        );
-
-        this.clock.tick(nextTick);
-
-        let prev2: Job;
-        let counter2 = 0;
-
-        const completing2 = new Promise<void>(resolve => {
-          worker.on('completed', async job => {
-            if (prev2) {
-              expect(prev2.timestamp).to.be.lt(job.timestamp);
-              expect(job.timestamp - prev2.timestamp).to.be.gte(2000);
-            }
-            prev2 = job;
-            counter2++;
-            if (counter2 == 5) {
-              resolve();
-            }
-          });
-        });
-
-        await completing2;
-
-        await currentQueue.close();
-        await worker.close();
-        await queueScheduler.close();
-        delayStub.restore();
-      });
-    });
-  });
-
   it('should repeat every 2 seconds and start immediately', async function () {
     const queueScheduler = new QueueScheduler(queueName, { connection });
     await queueScheduler.waitUntilReady();
@@ -1302,7 +1107,7 @@ describe('repeat', function () {
         { repeat: { every: 5000, cron: '* /1 * * * * *' } },
       ),
     ).to.be.rejectedWith(
-      'Both .cron (or .pattern) and .every options are defined for this repeatable job',
+      'Both .cron and .every options are defined for this repeatable job',
     );
   });
 
diff --git a/yarn.lock b/yarn.lock
index 2b09556f51..27c1df4bbd 100644
--- a/yarn.lock
+++ b/yarn.lock
@@ -5837,15 +5837,6 @@ rimraf@^3.0.0, rimraf@^3.0.2:
   dependencies:
     glob "^7.1.3"
 
-rrule@^2.6.9:
-  version "2.6.9"
-  resolved "https://registry.yarnpkg.com/rrule/-/rrule-2.6.9.tgz#8ee4ee261451e84852741f92ded769245580744a"
-  integrity sha512-PE4ErZDMfAcRnc1B35bZgPGS9mbn7Z9bKDgk6+XgrIwvBjeWk7JVEYsqKwHYTrDGzsHPtZTpaon8IyeKzAhj5w==
-  dependencies:
-    tslib "^1.10.0"
-  optionalDependencies:
-    luxon "^1.21.3"
-
 run-async@^2.4.0:
   version "2.4.1"
   resolved "https://registry.yarnpkg.com/run-async/-/run-async-2.4.1.tgz#8440eccf99ea3e70bd409d49aab88e10c189a455"
