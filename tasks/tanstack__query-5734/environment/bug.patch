diff --git a/docs/react/react-native.md b/docs/react/react-native.md
index c325353c6..6380e97a8 100644
--- a/docs/react/react-native.md
+++ b/docs/react/react-native.md
@@ -76,64 +76,3 @@ export function useRefreshOnFocus<T>(refetch: () => Promise<T>) {
 ```
 
 In the above code, `refetch` is skipped the first time because `useFocusEffect` calls our callback on mount in addition to screen focus.
-
-## Disable re-renders on out of focus Screens
-
-In some situations, including performance concerns, you may want to stop re-renders when a React Native screen gets out of focus. To achieve this we can use `useFocusEffect` from `@react-navigation/native` together with the `notifyOnChangeProps` query option.
-
-This custom hook provides a `notifyOnChangeProps` option that will return an empty array whenever a screen goes out of focus - effectively stopping any re-renders on that scenario. Whenever the screens gets in focus again, the behavior goes back to normal.
-
-```tsx
-import React from 'react'
-import { NotifyOnChangeProps } from '@tanstack/query-core'
-import { useFocusEffect } from '@react-navigation/native'
-
-export function useFocusNotifyOnChangeProps(notifyOnChangeProps?: NotifyOnChangeProps) {
-  const focusedRef = React.useRef(true)
-
-  useFocusEffect(
-    React.useCallback(() => {
-      focusedRef.current = true
-
-      return () => {
-        focusedRef.current = false
-      }
-    }, [])
-  )
-
-  return () => {
-    if (!focusedRef.current) {
-      return []
-    }
-
-    if (typeof notifyOnChangeProps === 'function') {
-      return notifyOnChangeProps()
-    }
-
-    return notifyOnChangeProps.current
-  }
-}
-```
-
-In the above code, `useFocusEffect` is used to change the value of a reference that the callback will use as a condition.
-
-The argument is wrapped in a reference to also guarantee that the returned callback always keeps the same reference.
-
-Example usage:
-
-```tsx
-function MyComponent() {
-  const notifyOnChangeProps = useFocusNotifyOnChangeProps();
-
-  const { dataUpdatedAt } = useQuery({
-    queryKey: ['myKey'],
-    queryFn: async () => {
-      const response = await fetch('https://api.github.com/repos/tannerlinsley/react-query');
-      return response.json();
-    },
-    notifyOnChangeProps,
-  });
-
-  return <div>DataUpdatedAt: {dataUpdatedAt}</div>;
-};
-```
diff --git a/docs/react/reference/useQuery.md b/docs/react/reference/useQuery.md
index 3f366b7e4..c1f17f09a 100644
--- a/docs/react/reference/useQuery.md
+++ b/docs/react/reference/useQuery.md
@@ -131,12 +131,11 @@ const {
   - If set to `false`, the query will not refetch on reconnect.
   - If set to `"always"`, the query will always refetch on reconnect.
   - If set to a function, the function will be executed with the query to compute the value
-- `notifyOnChangeProps: string[] | "all" | (() => string[] | "all")`
+- `notifyOnChangeProps: string[] | "all"`
   - Optional
   - If set, the component will only re-render if any of the listed properties change.
   - If set to `['data', 'error']` for example, the component will only re-render when the `data` or `error` properties change.
   - If set to `"all"`, the component will opt-out of smart tracking and re-render whenever a query is updated.
-  - If set to a function, the function will be executed to compute the list of properties.
   - By default, access to properties will be tracked, and the component will only re-render when one of the tracked properties change.
 - `onSuccess: (data: TData) => void`
   - **Deprecated** - this callback will be removed in the next major version
diff --git a/packages/query-core/src/queryObserver.ts b/packages/query-core/src/queryObserver.ts
index e85973a60..7d6879529 100644
--- a/packages/query-core/src/queryObserver.ts
+++ b/packages/query-core/src/queryObserver.ts
@@ -637,21 +637,15 @@ export class QueryObserver<
       }
 
       const { notifyOnChangeProps } = this.options
-      const notifyOnChangePropsValue =
-        typeof notifyOnChangeProps === 'function'
-          ? notifyOnChangeProps()
-          : notifyOnChangeProps
 
       if (
-        notifyOnChangePropsValue === 'all' ||
-        (!notifyOnChangePropsValue && !this.trackedProps.size)
+        notifyOnChangeProps === 'all' ||
+        (!notifyOnChangeProps && !this.trackedProps.size)
       ) {
         return true
       }
 
-      const includedProps = new Set(
-        notifyOnChangePropsValue ?? this.trackedProps,
-      )
+      const includedProps = new Set(notifyOnChangeProps ?? this.trackedProps)
 
       if (this.options.useErrorBoundary) {
         includedProps.add('error')
diff --git a/packages/query-core/src/types.ts b/packages/query-core/src/types.ts
index 2513d711d..057cb40d6 100644
--- a/packages/query-core/src/types.ts
+++ b/packages/query-core/src/types.ts
@@ -55,11 +55,6 @@ export interface QueryMeta {
 
 export type NetworkMode = 'online' | 'always' | 'offlineFirst'
 
-export type NotifyOnChangeProps =
-  | Array<keyof InfiniteQueryObserverResult>
-  | 'all'
-  | (() => Array<keyof InfiniteQueryObserverResult> | 'all')
-
 export interface QueryOptions<
   TQueryFnData = unknown,
   TError = unknown,
@@ -205,10 +200,9 @@ export interface QueryObserverOptions<
    * If set, the component will only re-render if any of the listed properties change.
    * When set to `['data', 'error']`, the component will only re-render when the `data` or `error` properties change.
    * When set to `'all'`, the component will re-render whenever a query is updated.
-   * When set to a function, the function will be executed to compute the list of properties.
    * By default, access to properties will be tracked, and the component will only re-render when one of the tracked properties change.
    */
-  notifyOnChangeProps?: NotifyOnChangeProps
+  notifyOnChangeProps?: Array<keyof InfiniteQueryObserverResult> | 'all'
   /**
    * This callback will fire any time the query successfully fetches new data.
    *
diff --git a/packages/react-query/src/__tests__/useQuery.test.tsx b/packages/react-query/src/__tests__/useQuery.test.tsx
index efe33951e..592349def 100644
--- a/packages/react-query/src/__tests__/useQuery.test.tsx
+++ b/packages/react-query/src/__tests__/useQuery.test.tsx
@@ -1018,6 +1018,46 @@ describe('useQuery', () => {
     expect(states[1]).toMatchObject({ data: 'test' })
   })
 
+  it('should not re-render when it should only re-render only data change and the selected data did not change', async () => {
+    const key = queryKey()
+    const states: UseQueryResult<string>[] = []
+
+    function Page() {
+      const state = useQuery(key, () => ({ name: 'test' }), {
+        select: (data) => data.name,
+        notifyOnChangeProps: ['data'],
+      })
+
+      states.push(state)
+
+      return (
+        <div>
+          <div>{state.data}</div>
+          <button onClick={() => state.refetch()}>refetch</button>
+        </div>
+      )
+    }
+
+    const rendered = renderWithClient(queryClient, <Page />)
+
+    await waitFor(() => {
+      rendered.getByText('test')
+    })
+
+    fireEvent.click(rendered.getByRole('button', { name: 'refetch' }))
+
+    await waitFor(() => {
+      rendered.getByText('test')
+    })
+
+    expect(states[0]).toMatchObject({ data: undefined })
+    expect(states[1]).toMatchObject({ data: 'test' })
+
+    // make sure no additional renders happen
+    await sleep(50)
+    expect(states.length).toBe(2)
+  })
+
   it('should throw an error when a selector throws', async () => {
     const key = queryKey()
     const states: UseQueryResult<string>[] = []
@@ -2183,267 +2223,60 @@ describe('useQuery', () => {
     expect(states[2]).toMatchObject({ isStale: true })
   })
 
-  describe('notifyOnChangeProps', () => {
-    it('should not re-render when it should only re-render on data changes and the data did not change', async () => {
-      const key = queryKey()
-      const states: UseQueryResult<string>[] = []
-
-      function Page() {
-        const state = useQuery(
-          key,
-          async () => {
-            await sleep(5)
-            return 'test'
-          },
-          {
-            notifyOnChangeProps: ['data'],
-          },
-        )
-
-        states.push(state)
-
-        return (
-          <>
-            <button
-              onClick={async () => {
-                await state.refetch()
-              }}
-            >
-              refetch
-            </button>
-
-            <div>{state.data}</div>
-          </>
-        )
-      }
-
-      const rendered = renderWithClient(queryClient, <Page />)
-
-      await waitFor(() => {
-        rendered.getByText('test')
-      })
-
-      fireEvent.click(rendered.getByRole('button', { name: 'refetch' }))
-
-      // sleep is required to make sure no additional renders happen after click
-      await sleep(20)
-
-      expect(states.length).toBe(2)
-      expect(states[0]).toMatchObject({
-        data: undefined,
-        status: 'loading',
-        isFetching: true,
-      })
-      expect(states[1]).toMatchObject({
-        data: 'test',
-        status: 'success',
-        isFetching: false,
-      })
-    })
-
-    it('should not re-render when it should only re-render only data change and the selected data did not change', async () => {
-      const key = queryKey()
-      const states: UseQueryResult<string>[] = []
+  it('should not re-render when it should only re-render on data changes and the data did not change', async () => {
+    const key = queryKey()
+    const states: UseQueryResult<string>[] = []
 
-      function Page() {
-        const state = useQuery(key, () => ({ name: 'test' }), {
-          select: (data) => data.name,
+    function Page() {
+      const state = useQuery(
+        key,
+        async () => {
+          await sleep(5)
+          return 'test'
+        },
+        {
           notifyOnChangeProps: ['data'],
-        })
-
-        states.push(state)
-
-        return (
-          <div>
-            <div>{state.data}</div>
-            <button onClick={() => state.refetch()}>refetch</button>
-          </div>
-        )
-      }
-
-      const rendered = renderWithClient(queryClient, <Page />)
+        },
+      )
 
-      await waitFor(() => {
-        rendered.getByText('test')
-      })
+      states.push(state)
 
-      fireEvent.click(rendered.getByRole('button', { name: 'refetch' }))
+      return (
+        <>
+          <button
+            onClick={async () => {
+              await state.refetch()
+            }}
+          >
+            refetch
+          </button>
 
-      await waitFor(() => {
-        rendered.getByText('test')
-      })
+          <div>{state.data}</div>
+        </>
+      )
+    }
 
-      expect(states[0]).toMatchObject({ data: undefined })
-      expect(states[1]).toMatchObject({ data: 'test' })
+    const rendered = renderWithClient(queryClient, <Page />)
 
-      // make sure no additional renders happen
-      await sleep(50)
-      expect(states.length).toBe(2)
+    await waitFor(() => {
+      rendered.getByText('test')
     })
 
-    // See https://github.com/TanStack/query/discussions/5588
-    describe('function', () => {
-      it('should not re-render when it should only re-render on data changes and the data did not change', async () => {
-        const key = queryKey()
-        const states: UseQueryResult<string>[] = []
-
-        function Page() {
-          const state = useQuery(
-            key,
-            async () => {
-              await sleep(5)
-              return 'test'
-            },
-            {
-              notifyOnChangeProps: () => ['data'],
-            },
-          )
-
-          states.push(state)
-
-          return (
-            <>
-              <button
-                onClick={async () => {
-                  await state.refetch()
-                }}
-              >
-                refetch
-              </button>
-
-              <div>{state.data}</div>
-            </>
-          )
-        }
-
-        const rendered = renderWithClient(queryClient, <Page />)
-
-        await waitFor(() => {
-          rendered.getByText('test')
-        })
-
-        fireEvent.click(rendered.getByRole('button', { name: 'refetch' }))
-
-        // sleep is required to make sure no additional renders happen after click
-        await sleep(20)
-
-        expect(states.length).toBe(2)
-        expect(states[0]).toMatchObject({
-          data: undefined,
-          status: 'loading',
-          isFetching: true,
-        })
-        expect(states[1]).toMatchObject({
-          data: 'test',
-          status: 'success',
-          isFetching: false,
-        })
-      })
-
-      it('should not re-render when change props are not actively being tracked', async () => {
-        const key = queryKey()
-        const states: UseQueryResult<string>[] = []
-
-        function Page() {
-          const fetchCounterRef = React.useRef(0)
-          const trackChangesRef = React.useRef(true)
-
-          const notifyOnChangeProps = React.useCallback(() => {
-            return trackChangesRef.current ? 'all' : []
-          }, [])
-
-          const state = useQuery(
-            key,
-            async () => {
-              await sleep(5)
-              fetchCounterRef.current++
-              return `fetch counter: ${fetchCounterRef.current}`
-            },
-            {
-              notifyOnChangeProps,
-            },
-          )
-
-          states.push(state)
-
-          return (
-            <>
-              <button
-                onClick={async () => {
-                  await state.refetch()
-                }}
-              >
-                refetch
-              </button>
-              <button
-                onClick={() => {
-                  trackChangesRef.current = true
-                }}
-              >
-                enableTracking
-              </button>
-              <button
-                onClick={() => {
-                  trackChangesRef.current = false
-                }}
-              >
-                disableTracking
-              </button>
-
-              <div>{state.data}</div>
-            </>
-          )
-        }
-
-        const rendered = renderWithClient(queryClient, <Page />)
-        await waitFor(() => {
-          rendered.getByText('fetch counter: 1')
-        })
-
-        expect(states.length).toBe(2)
-        expect(states[0]).toMatchObject({
-          data: undefined,
-          isFetching: true,
-          status: 'loading',
-        })
-        expect(states[1]).toMatchObject({
-          data: 'fetch counter: 1',
-          status: 'success',
-          isFetching: false,
-        })
-
-        // disable tracking and refetch to check for re-renders
-        fireEvent.click(
-          rendered.getByRole('button', { name: 'disableTracking' }),
-        )
-        fireEvent.click(rendered.getByRole('button', { name: 'refetch' }))
-
-        // sleep is required to make sure no additional renders happen after click
-        await sleep(20)
-        // still expect to only have two re-renders from the initial fetch
-        expect(states.length).toBe(2)
-
-        // enable tracking and refetch to check for re-renders
-        fireEvent.click(
-          rendered.getByRole('button', { name: 'enableTracking' }),
-        )
-        fireEvent.click(rendered.getByRole('button', { name: 'refetch' }))
+    fireEvent.click(rendered.getByRole('button', { name: 'refetch' }))
 
-        // sleep is required to make sure no additional renders happen after click
-        await sleep(20)
+    // sleep is required to make sure no additional renders happen after click
+    await sleep(20)
 
-        expect(states.length).toBe(4)
-        expect(states[2]).toMatchObject({
-          data: 'fetch counter: 2',
-          status: 'success',
-          isFetching: true,
-        })
-        expect(states[3]).toMatchObject({
-          data: 'fetch counter: 3',
-          status: 'success',
-          isFetching: false,
-        })
-      })
+    expect(states.length).toBe(2)
+    expect(states[0]).toMatchObject({
+      data: undefined,
+      status: 'loading',
+      isFetching: true,
+    })
+    expect(states[1]).toMatchObject({
+      data: 'test',
+      status: 'success',
+      isFetching: false,
     })
   })
 
