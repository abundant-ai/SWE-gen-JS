diff --git a/es5.js b/es5.js
index 9388521..8533f67 100644
--- a/es5.js
+++ b/es5.js
@@ -12,10 +12,31 @@ let autoFreeze = true
  *
  * @export
  * @param {any} baseState - the state to start with
- * @param {Function} thunk - function that receives a proxy of the base state as first argument and which can be freely modified
+ * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified
  * @returns {any} a new state, or the base state if nothing was modified
  */
-function produce(baseState, thunk) {
+function produce(baseState, producer) {
+    // curried invocation
+    if (arguments.length === 1) {
+        const producer = baseState
+        // prettier-ignore
+        if (typeof producer !== "function") throw new Error("if produce is called with 1 argument, the first argument should be a function")
+        return function() {
+            const args = arguments
+            return produce(args[0], draft => {
+                args[0] = draft // blegh!
+                baseState.apply(null, args)
+            })
+        }
+    }
+
+    // prettier-ignore
+    {
+        if (arguments.length !== 2)  throw new Error("produce expects 1 or 2 arguments, got " + arguments.length)
+        if (!isProxyable(baseState)) throw new Error("the first argument to produce should be a plain object or array, got " + (typeof baseState))
+        if (typeof producer !== "function") throw new Error("the second argument to produce should be a function")
+    }
+
     let finalizing = false
     let finished = false
     const descriptors = {}
@@ -171,7 +192,7 @@ function produce(baseState, thunk) {
     // create proxy for root
     const rootClone = createProxy(undefined, baseState)
     // execute the thunk
-    const maybeVoidReturn = thunk(rootClone)
+    const maybeVoidReturn = producer(rootClone)
     //values either than undefined will trigger warning;
     !Object.is(maybeVoidReturn, undefined) &&
         console.warn(
diff --git a/immer.js b/immer.js
index 8f7c279..e98c4f9 100644
--- a/immer.js
+++ b/immer.js
@@ -72,16 +72,36 @@ const arrayTraps = {
 }
 
 /**
- * Immer takes a state, and runs a function against it.
+ * produce takes a state, and runs a function against it.
  * That function can freely mutate the state, as it will create copies-on-write.
  * This means that the original state will stay unchanged, and once the function finishes, the modified state is returned
  *
  * @export
  * @param {any} baseState - the state to start with
- * @param {Function} thunk - function that receives a proxy of the base state as first argument and which can be freely modified
+ * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified
  * @returns {any} a new state, or the base state if nothing was modified
  */
-function produce(baseState, thunk) {
+function produce(baseState, producer) {
+    // curried invocation
+    if (arguments.length === 1) {
+        const producer = baseState
+        // prettier-ignore
+        if (typeof producer !== "function") throw new Error("if produce is called with 1 argument, the first argument should be a function")
+        return function() {
+            const args = arguments
+            return produce(args[0], draft => {
+                args[0] = draft // blegh!
+                baseState.apply(null, args)
+            })
+        }
+    }
+
+    // prettier-ignore
+    {
+        if (arguments.length !== 2)  throw new Error("produce expects 1 or 2 arguments, got " + arguments.length)
+        if (!isProxyable(baseState)) throw new Error("the first argument to produce should be a plain object or array, got " + (typeof baseState))
+        if (typeof producer !== "function") throw new Error("the second argument to produce should be a function")
+    }
     const revocableProxies = []
 
     class State {
@@ -146,9 +166,9 @@ function produce(baseState, thunk) {
         markChanged() {
             if (!this.modified) {
                 this.modified = true
-                this.copy = Array.isArray(this.base) // TODO: eliminate those isArray checks?
+                this.copy = Array.isArray(this.base)
                     ? this.base.slice()
-                    : Object.assign({}, this.base)
+                    : Object.assign({}, this.base) // TODO: eliminate those isArray checks?
                 Object.assign(this.copy, this.proxies) // yup that works for arrays as well
                 if (this.parent) this.parent.markChanged()
             }
@@ -201,7 +221,7 @@ function produce(baseState, thunk) {
     // create proxy for root
     const rootClone = createProxy(undefined, baseState)
     // execute the thunk
-    const maybeVoidReturn = thunk(rootClone)
+    const maybeVoidReturn = producer(rootClone)
     //values either than undefined will trigger warning;
     !Object.is(maybeVoidReturn, undefined) &&
         console.warn(
diff --git a/index.d.ts b/index.d.ts
index edea9cb..7dbf7a0 100644
--- a/index.d.ts
+++ b/index.d.ts
@@ -3,14 +3,30 @@
  * That function can freely mutate the state, as it will create copies-on-write.
  * This means that the original state will stay unchanged, and once the function finishes, the modified state is returned
  *
+ * If only one argument is passed, this is interpreted as the recipe, and will create a curried function that will execute the recipe
+ * any time it is called with a base state
+ *
  * @param currentState - the state to start with
  * @param thunk - function that receives a proxy of the current state as first argument and which can be freely modified
  * @returns The next state: a new state, or the current state if nothing was modified
  */
 export default function<S = any>(
     currentState: S,
-    thunk: (draftState: S) => void,
+    recipe: (draftState: S) => void
 ): S
+// curried invocations
+export default function<S = any, A = any, B = any, C = any>(
+    recipe: (draftState: S, a: A, b: B, c: C) => void
+): (currentState: S, a: A, b: B, c: C) => S
+export default function<S = any, A = any, B = any>(
+    recipe: (draftState: S, a: A, b: B) => void
+): (currentState: S, a: A, b: B) => S
+export default function<S = any, A = any>(
+    recipe: (draftState: S, a: A) => void
+): (currentState: S) => S
+export default function<S = any>(
+    recipe: (draftState: S, ...extraArgs: any[]) => void
+): (currentState: S, ...extraArgs: any[]) => S
 
 /**
  * Automatically freezes any state trees generated by immer.
@@ -18,4 +34,4 @@ export default function<S = any>(
  * This comes with a performance impact, so it is recommended to disable this option in production.
  * It is by default enabled.
  */
-export function setAutoFreeze(autoFreeze: boolean): void;
+export function setAutoFreeze(autoFreeze: boolean): void
diff --git a/readme.md b/readme.md
index 25a4e20..b8a0200 100644
--- a/readme.md
+++ b/readme.md
@@ -5,7 +5,6 @@
 [![code style: prettier](https://img.shields.io/badge/code_style-prettier-ff69b4.svg)](https://github.com/prettier/prettier)
 [![Donate](https://img.shields.io/badge/Donate-PayPal-green.svg)](https://mobx.js.org/donate.html)
 
-
 _Create the next immutable state tree by simply modifying the current tree_
 
 ---
@@ -24,18 +23,16 @@ This means that you can interact with your data by simply modifying it, while ke
 
 Using Immer is like having a personal assistant; he takes a letter (the current state), and gives you a copy (draft) to jot changes onto. Once you are done, the assistant will take your draft and produce the real immutable, final letter for you (the next state).
 
-A mindful reader might notice that this is quite similar to `withMutations` of ImmutableJS. It is indeed, but generalized and applicable to plain, native JavaScript data structures (arrays and objects) without further needing any library.
-
-## Installation
-
-`npm install immer`
+A mindful reader might notice that this is quite similar to `withMutations` of ImmutableJS. It is indeed, but generalized and applied to plain, native JavaScript data structures (arrays and objects) without further needing any library.
 
 ## API
 
-The Immer package exposes a single function, which typically, but not necessarily is called `produce`:
+The Immer package exposes a default function that does all the work.
 
 `produce(currentState, producer: (draftState) => void): nextState`
 
+There is also a curried overload that is explained [below](#currying)
+
 ## Example
 
 ```javascript
@@ -47,7 +44,7 @@ const baseState = [
         done: true
     },
     {
-        todo: "Try Immer",
+        todo: "Try immer",
         done: false
     }
 ]
@@ -58,7 +55,7 @@ const nextState = produce(baseState, draftState => {
 })
 ```
 
-The interesting thing about `produce` is that, the `baseState` will be untouched, but the `nextState` will reflect all changes made to `draftState`.
+The interesting thing about Immer is that the `baseState` will be untouched, but the `nextState` will reflect all changes made to `draftState`.
 
 ```javascript
 // the new item is only added to the next state,
@@ -76,110 +73,118 @@ expect(nextState[0]).toBe(baseState[0])
 expect(nextState[1]).not.toBe(baseState[1])
 ```
 
-## Using Immer on older JavaScript environments
-
-By default Immer tries to use proxies for optimal performance.
-However, on older JavaScript engines `Proxy` is not available.
-For example, Microsoft Internet Explorer or React Native on Android.
-In these cases, import the ES5 compatibile implementation first, which is a bit slower (see below) but semantically equivalent:
-
-```javascript
-import produce from "immer/es5"
-```
-
 ## Benefits
 
-* Use the languageÂ© to construct create your next state
-* Use JavaScript native arrays and object
-* Automatic immutability; any state tree produced by Immer will by defualt be deeply frozen
-* Strongly typed, no string based paths etc
-* Deep updates are trivial
-* Small, dependency free library with minimal api surface
-* No accidental mutations of current state, but intentional mutations of a draft state
-
-## Auto freezing
-
- Immer automatically freezes any state trees that are modified using `produce`.
- This protects against accidental modifications of the state tree outside of a producer function.
- This comes with a performance impact, so it is recommended to disable this option in production.
- It is by default enabled.
+* Immutability with normal JavaScript objects and arrays. No new APIs to learn!
+* Strongly typed, no string based paths selectors etc.
+* Structural sharing out of the box
+* Object freezing out of the box
+* Deep updates are a breeze
+* Boilerplate reduction. Less noise, more concise code.
 
- Use `setAutoFreeze(true / false)` to turn this feature on or off.
+Read further to see all these benefits explained.
 
 ## Reducer Example
 
-Here is a simple example of the difference that this approach could make in practice.
-The todo reducers from the official Redux [todos-with-undo example](https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/todos-with-undo)
-
-_Note, this is just a sample application of the Immer package. Immer is not just designed to simplify Redux reducers. It can be used in any context where you have an immutable data tree that you want to clone and modify (with structural sharing)_
+Here is a simple example of the difference that Immer could make in practice.
 
 ```javascript
-const todo = (state, action) => {
+// Redux reducer
+// Shortened, based on: https://github.com/reactjs/redux/blob/master/examples/shopping-cart/src/reducers/products.js
+const byId = (state, action) => {
   switch (action.type) {
-    case 'ADD_TODO':
-      return {
-        id: action.id,
-        text: action.text,
-        completed: false
-      }
-    case 'TOGGLE_TODO':
-      if (state.id !== action.id) {
-        return state
-      }
-
+    case RECEIVE_PRODUCTS:
       return {
         ...state,
-        completed: !state.completed
+        ...action.products.reduce((obj, product) => {
+          obj[product.id] = product
+          return obj
+        }, {})
       }
     default:
       return state
   }
 }
-
-const todos = (state = [], action) => {
-  switch (action.type) {
-    case 'ADD_TODO':
-      return [
-        ...state,
-        todo(undefined, action)
-      ]
-    case 'TOGGLE_TODO':
-      return state.map(t =>
-        todo(t, action)
-      )
-    default:
-      return state
-  }
-}
 ```
 
-When using Immer, that simply [becomes](https://codesandbox.io/s/xl11qpo9mp):
+After using Immer, that simply becomes:
 
 ```javascript
 import produce from 'immer'
 
-const todos = (state = [], action) =>
-  // produce produces nextState from draftState and returns it
-  produce(state, draftState => {
+const byId = (state, action) =>
+  produce(state, draft => {
     switch (action.type) {
-      case 'ADD_TODO':
-        draftState.push({
-          id: action.id,
-          text: action.text,
-          completed: false
+      case RECEIVE_PRODUCTS:
+        action.products.forEach(product => {
+          draft[product.id] = product
         })
-        return
-      case 'TOGGLE_TODO':
-        const todo = draftState.find(todo => todo.id === action.id)
-        todo.completed = !todo.completed
-        return
     }
   })
 ```
 
-Creating middleware or a reducer wrapper that applies `produce` automatically is left as exercise for the reader :-).
+Note that it is not needed to handle the default case, a producer that doesn't do anything will simply return the original state.
 
----
+_Note, creating Redux reducer is just a sample application of the Immer package.
+Immer is not just designed to simplify Redux reducers.
+It can be used in any context where you have an immutable data tree that you want to clone and modify (with structural sharing)_
+
+## Currying
+
+`produce` can be called with one or two arguments.
+The one argument version is intended to be used as currying. This means that you get a pre-pound producer, that only needs a state to produce the value from.
+The producer function get's passed in the draft, and any further arguments that were passed to the curried function.
+
+For example:
+
+```javascript
+// mapper will be of signature (state, index) => state
+const mapper = produce((draft, index) => {
+    draft.index = index
+})
+
+// example usage
+console.dir([{}, {}, {}].map(mapper))
+//[{index: 0}, {index: 1}, {index: 2}])
+```
+
+This mechanism can also nicely be leveraged to further simplify our example reducer:
+
+```javascript
+const byId = produce((draft, action) => {
+  switch (action.type) {
+    case RECEIVE_PRODUCTS:
+    action.products.forEach(product => {
+        draft[product.id] = product
+    })
+  }
+})
+```
+
+Note that `state` is now factored out (the created reducer will accept a state, and invoke the bound producer with it).
+One think to keep in mind; you cannot use this construction to initialize an uninitialized state. E.g. `draft = {}` doesn't do anything useful.
+
+
+## Auto freezing
+
+ Immer automatically freezes any state trees that are modified using `produce`.
+ This protects against accidental modifications of the state tree outside of a producer.
+ This comes with a performance impact, so it is recommended to disable this option in production.
+ It is by default enabled.
+ Use `setAutoFreeze(true / false)` to turn this feature on or off.
+
+## Using Immer on older JavaScript environments
+
+By default `produce` tries to use proxies for optimal performance.
+However, on older JavaScript engines `Proxy` is not available.
+For example, Microsoft Internet Explorer or React Native on Android.
+In these cases, import the ES5 compatibile implementation first, which is a bit slower (see below) but semantically equivalent:
+
+```javascript
+import immer from "immer/es5"
+```
+
+## More reducer examples
 
 Here are some typical reducer examples, take from the Redux [Immutable Update Patterns](https://redux.js.org/docs/recipes/reducers/ImmutableUpdatePatterns.html) page, and their Immer counter part.
 These examples are semantically equivalent and produce the exact same state.
@@ -223,6 +228,7 @@ function updateObjectInArray(array, action) {
             // This isn't the item we care about - keep it as-is
             return item;
         }
+
         // Otherwise, this is the one we want - return an updated value
         return {
             ...item,
@@ -235,24 +241,23 @@ function updateObjectInArray(array, action) {
 function updateObjectInArray(array, action) {
     return produce(array, draft => {
         draft[action.index] = { ...item, ...action.item}
-        // Or, alternatively:
+        // Alternatively, since arbitrarily deep updates are supported:
         // Object.assign(draft[action.index], action.item)
     })
 }
 ```
 
-## Limitations
-
-* Currently, only tree shaped states are supported. Cycles could potentially be supported as well (PR's welcome)
-* Currently, only supports plain objects and arrays. Non-plain data structures (like `Map`, `Set`) not (yet). (PR's welcome)
-
-## Pitfalls:
+## Pitfalls
 
+* Currently, Immer only supports plain objects and arrays. PRs are welcome for more language built-in types like `Map` and `Set`.
 * Immer only processes native arrays and plain objects (with a prototype of `null` or `Object`). Any other type of value will be treated verbatim! So if you modify a `Map` or `Buffer`  or whatever complex object from the draft state, it will be that very same object in both the base state as the next state. In such cases, make sure to always produce fresh instances if you want to keep your state truly immutable.
-* Make sure to modify the draft state you get passed in in the callback function, not the original current state that was passed as the first argument to `produce`!
-* Since immer uses proxies, reading huge amounts of data from state comes with an overhead. If this ever becomes an issue (measure before you optimize!), do the current state analysis before entering the producer or read from the `currentState` rather than the `draftState`
+* Since Immer uses proxies, reading huge amounts of data from state comes with an overhead (especially in the ES5 implementation). If this ever becomes an issue (measure before you optimize!), do the current state analysis before entering the producer function or read from the `currentState` rather than the `draftState`
 * Some debuggers (at least Node 6 is known) have trouble debugging when Proxies are in play. Node 8 is known to work correctly.
 
+## How does Immer work?
+
+Read the (second part of the) [introduction blog](https://medium.com/@mweststrate/9d73d8f71cb3).
+
 ## Performance
 
 Here is a [simple benchmark](__tests__/performance.js) on the performance of Immer.
@@ -266,7 +271,7 @@ Use `yarn test:perf`  to reproduce them locally.
 
 Some observations:
 * The _mutate_, and _deepclone, mutate_ benchmarks establish a baseline on how expensive changing the data is, without immutability (or structural sharing in the deep clone case).
-* The _reduce_ and _naive reducer_ are implemented in typical Redux style reducers. The "smart" implementation slices the collection first, and then maps and freezes only the relevant todos. The "naive" implementation just maps over and processes the entire collection.
+* The _reducer_ and _naive reducer_ are implemented in typical Redux style reducers. The "smart" implementation slices the collection first, and then maps and freezes only the relevant todos. The "naive" implementation just maps over and processes the entire collection.
 * Immer with proxies is roughly speaking twice as slow as a hand written reducer. This is in practice negligible.
 * Immer is roughly as fast as ImmutableJS. However, the _immutableJS + toJS_ makes clear the cost that often needs to be paid later; converting the immutableJS objects back to plain objects, to be able to pass them to components, over the network etc... (And there is also the upfront cost of converting data received from e.g. the server to immutable JS)
 * The ES5 implementation of Immer is significantly slower. For most reducers this won't matter, but reducers that process large amounts of data might benefit from not (or only partially) using an Immer producer. Luckily, Immer is fully opt-in.
@@ -275,3 +280,7 @@ Some observations:
 ## Credits
 
 Special thanks goes to @Mendix, which supports it's employees to experiment completely freely two full days a month, which formed the kick-start for this project.
+
+## Donations
+
+A significant part of my OSS work is unpaid. So [donations](https://mobx.js.org/donate.html) are greatly appreciated :)
