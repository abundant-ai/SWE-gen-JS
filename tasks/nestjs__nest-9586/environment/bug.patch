diff --git a/integration/module-utils/src/integration.module-definition.ts b/integration/module-utils/src/integration.module-definition.ts
new file mode 100644
index 000000000..89d7a9842
--- /dev/null
+++ b/integration/module-utils/src/integration.module-definition.ts
@@ -0,0 +1,17 @@
+import { ConfigurableModuleBuilder } from '@nestjs/common';
+import { IntegrationModuleOptions } from './interfaces/integration-module-options.interface';
+
+export const { ConfigurableModuleClass, MODULE_OPTIONS_TOKEN } =
+  new ConfigurableModuleBuilder<IntegrationModuleOptions>()
+    .setClassMethodName('forRoot')
+    .setFactoryMethodName('construct')
+    .setExtras(
+      {
+        isGlobal: true,
+      },
+      (definition, extras) => ({
+        ...definition,
+        global: extras.isGlobal,
+      }),
+    )
+    .build();
diff --git a/integration/module-utils/src/integration.module.ts b/integration/module-utils/src/integration.module.ts
new file mode 100644
index 000000000..3b994f4bd
--- /dev/null
+++ b/integration/module-utils/src/integration.module.ts
@@ -0,0 +1,16 @@
+import { Inject, Module } from '@nestjs/common';
+import {
+  ConfigurableModuleClass,
+  MODULE_OPTIONS_TOKEN,
+} from './integration.module-definition';
+import { IntegrationModuleOptions } from './interfaces/integration-module-options.interface';
+
+@Module({})
+export class IntegrationModule extends ConfigurableModuleClass {
+  constructor(
+    @Inject(MODULE_OPTIONS_TOKEN)
+    public readonly options: IntegrationModuleOptions,
+  ) {
+    super();
+  }
+}
diff --git a/integration/module-utils/src/interfaces/integration-module-options.interface.ts b/integration/module-utils/src/interfaces/integration-module-options.interface.ts
new file mode 100644
index 000000000..802e02076
--- /dev/null
+++ b/integration/module-utils/src/interfaces/integration-module-options.interface.ts
@@ -0,0 +1,4 @@
+export interface IntegrationModuleOptions {
+  url: string;
+  secure?: boolean;
+}
diff --git a/integration/module-utils/test/integration-module.spec.ts b/integration/module-utils/test/integration-module.spec.ts
new file mode 100644
index 000000000..ea22a71c5
--- /dev/null
+++ b/integration/module-utils/test/integration-module.spec.ts
@@ -0,0 +1,47 @@
+import { Test } from '@nestjs/testing';
+import { expect } from 'chai';
+import { IntegrationModule } from '../src/integration.module';
+
+describe('Module utils (ConfigurableModuleBuilder)', () => {
+  it('should auto-generate "forRoot" method', async () => {
+    const moduleRef = await Test.createTestingModule({
+      imports: [
+        IntegrationModule.forRoot({
+          isGlobal: true,
+          url: 'test_url',
+          secure: false,
+        }),
+      ],
+    }).compile();
+
+    const integrationModule = moduleRef.get(IntegrationModule);
+
+    expect(integrationModule.options).to.deep.equal({
+      url: 'test_url',
+      secure: false,
+    });
+  });
+
+  it('should auto-generate "forRootAsync" method', async () => {
+    const moduleRef = await Test.createTestingModule({
+      imports: [
+        IntegrationModule.forRootAsync({
+          isGlobal: true,
+          useFactory: () => {
+            return {
+              url: 'test_url',
+              secure: false,
+            };
+          },
+        }),
+      ],
+    }).compile();
+
+    const integrationModule = moduleRef.get(IntegrationModule);
+
+    expect(integrationModule.options).to.deep.equal({
+      url: 'test_url',
+      secure: false,
+    });
+  });
+});
diff --git a/integration/module-utils/tsconfig.json b/integration/module-utils/tsconfig.json
new file mode 100644
index 000000000..c6354c564
--- /dev/null
+++ b/integration/module-utils/tsconfig.json
@@ -0,0 +1,22 @@
+{
+  "compilerOptions": {
+    "module": "commonjs",
+    "declaration": false,
+    "noImplicitAny": false,
+    "removeComments": true,
+    "noLib": false,
+    "emitDecoratorMetadata": true,
+    "experimentalDecorators": true,
+    "target": "es6",
+    "sourceMap": true,
+    "allowJs": true,
+    "outDir": "./dist"
+  },
+  "include": [
+    "src/**/*",
+    "e2e/**/*"
+  ],
+  "exclude": [
+    "node_modules",
+  ]
+}
\ No newline at end of file
diff --git a/package-lock.json b/package-lock.json
index 4f7c42bb1..b0ea489df 100644
Binary files a/package-lock.json and b/package-lock.json differ
diff --git a/packages/common/cache/cache.constants.ts b/packages/common/cache/cache.constants.ts
index 0ecf5c94e..799547a7b 100644
--- a/packages/common/cache/cache.constants.ts
+++ b/packages/common/cache/cache.constants.ts
@@ -1,4 +1,3 @@
 export const CACHE_MANAGER = 'CACHE_MANAGER';
-export const CACHE_MODULE_OPTIONS = 'CACHE_MODULE_OPTIONS';
 export const CACHE_KEY_METADATA = 'cache_module:cache_key';
 export const CACHE_TTL_METADATA = 'cache_module:cache_ttl';
diff --git a/packages/common/cache/cache.module-definition.ts b/packages/common/cache/cache.module-definition.ts
new file mode 100644
index 000000000..25d74e986
--- /dev/null
+++ b/packages/common/cache/cache.module-definition.ts
@@ -0,0 +1,12 @@
+import { ConfigurableModuleBuilder } from '../module-utils';
+import {
+  CacheModuleOptions,
+  CacheOptionsFactory,
+} from './interfaces/cache-module.interface';
+
+export const { ConfigurableModuleClass, MODULE_OPTIONS_TOKEN } =
+  new ConfigurableModuleBuilder<CacheModuleOptions>({
+    moduleName: 'Cache',
+  })
+    .setFactoryMethodName('createCacheOptions' as keyof CacheOptionsFactory)
+    .build();
diff --git a/packages/common/cache/cache.module.ts b/packages/common/cache/cache.module.ts
index 4e2c63d48..992f98f03 100644
--- a/packages/common/cache/cache.module.ts
+++ b/packages/common/cache/cache.module.ts
@@ -1,11 +1,11 @@
 import { Module } from '../decorators';
-import { DynamicModule, Provider } from '../interfaces';
-import { CACHE_MANAGER, CACHE_MODULE_OPTIONS } from './cache.constants';
+import { DynamicModule } from '../interfaces';
+import { CACHE_MANAGER } from './cache.constants';
+import { ConfigurableModuleClass } from './cache.module-definition';
 import { createCacheManager } from './cache.providers';
 import {
   CacheModuleAsyncOptions,
   CacheModuleOptions,
-  CacheOptionsFactory,
 } from './interfaces/cache-module.interface';
 
 /**
@@ -19,7 +19,7 @@ import {
   providers: [createCacheManager()],
   exports: [CACHE_MANAGER],
 })
-export class CacheModule {
+export class CacheModule extends ConfigurableModuleClass {
   /**
    * Configure the cache manager statically.
    *
@@ -31,9 +31,8 @@ export class CacheModule {
     options: CacheModuleOptions<StoreConfig> = {} as any,
   ): DynamicModule {
     return {
-      module: CacheModule,
       global: options.isGlobal,
-      providers: [{ provide: CACHE_MODULE_OPTIONS, useValue: options }],
+      ...super.register(options),
     };
   }
 
@@ -48,47 +47,11 @@ export class CacheModule {
   static registerAsync<
     StoreConfig extends Record<any, any> = Record<string, any>,
   >(options: CacheModuleAsyncOptions<StoreConfig>): DynamicModule {
+    const moduleDefinition = super.registerAsync(options);
     return {
-      module: CacheModule,
       global: options.isGlobal,
-      imports: options.imports,
-      providers: [
-        ...this.createAsyncProviders<StoreConfig>(options),
-        ...(options.extraProviders || []),
-      ],
-    };
-  }
-
-  private static createAsyncProviders<StoreConfig extends Record<any, any>>(
-    options: CacheModuleAsyncOptions<StoreConfig>,
-  ): Provider[] {
-    if (options.useExisting || options.useFactory) {
-      return [this.createAsyncOptionsProvider(options)];
-    }
-    return [
-      this.createAsyncOptionsProvider(options),
-      {
-        provide: options.useClass,
-        useClass: options.useClass,
-      },
-    ];
-  }
-
-  private static createAsyncOptionsProvider<
-    StoreConfig extends Record<any, any>,
-  >(options: CacheModuleAsyncOptions<StoreConfig>): Provider {
-    if (options.useFactory) {
-      return {
-        provide: CACHE_MODULE_OPTIONS,
-        useFactory: options.useFactory,
-        inject: options.inject || [],
-      };
-    }
-    return {
-      provide: CACHE_MODULE_OPTIONS,
-      useFactory: async (optionsFactory: CacheOptionsFactory<StoreConfig>) =>
-        optionsFactory.createCacheOptions(),
-      inject: [options.useExisting || options.useClass],
+      ...moduleDefinition,
+      providers: moduleDefinition.providers.concat(options.extraProviders),
     };
   }
 }
diff --git a/packages/common/cache/cache.providers.ts b/packages/common/cache/cache.providers.ts
index 2e6df398d..4aaacf0f5 100644
--- a/packages/common/cache/cache.providers.ts
+++ b/packages/common/cache/cache.providers.ts
@@ -1,6 +1,7 @@
 import { Provider } from '../interfaces';
 import { loadPackage } from '../utils/load-package.util';
-import { CACHE_MANAGER, CACHE_MODULE_OPTIONS } from './cache.constants';
+import { CACHE_MANAGER } from './cache.constants';
+import { MODULE_OPTIONS_TOKEN } from './cache.module-definition';
 import { defaultCacheOptions } from './default-options';
 import { CacheManagerOptions } from './interfaces/cache-manager.interface';
 
@@ -31,6 +32,6 @@ export function createCacheManager(): Provider {
             ...(options || {}),
           });
     },
-    inject: [CACHE_MODULE_OPTIONS],
+    inject: [MODULE_OPTIONS_TOKEN],
   };
 }
diff --git a/packages/common/cache/interfaces/cache-module.interface.ts b/packages/common/cache/interfaces/cache-module.interface.ts
index 5beb769c8..a5fd220cc 100644
--- a/packages/common/cache/interfaces/cache-module.interface.ts
+++ b/packages/common/cache/interfaces/cache-module.interface.ts
@@ -1,4 +1,5 @@
-import { ModuleMetadata, Provider, Type } from '../../interfaces';
+import { Provider, Type } from '../../interfaces';
+import { ConfigurableModuleAsyncOptions } from '../../module-utils';
 import { CacheManagerOptions } from './cache-manager.interface';
 
 export type CacheModuleOptions<
@@ -39,7 +40,10 @@ export interface CacheOptionsFactory<
  */
 export interface CacheModuleAsyncOptions<
   StoreConfig extends Record<any, any> = Record<string, any>,
-> extends Pick<ModuleMetadata, 'imports'> {
+> extends ConfigurableModuleAsyncOptions<
+    CacheModuleOptions<StoreConfig>,
+    keyof CacheOptionsFactory
+  > {
   /**
    * Injection token resolving to an existing provider. The provider must implement
    * the `CacheOptionsFactory` interface.
@@ -63,6 +67,9 @@ export interface CacheModuleAsyncOptions<
    * Dependencies that a Factory may inject.
    */
   inject?: any[];
+  /**
+   * Extra providers to be registered within a scope of this module.
+   */
   extraProviders?: Provider[];
   /**
    * If "true', register `CacheModule` as a global module.
diff --git a/packages/common/http/http.constants.ts b/packages/common/http/http.constants.ts
index 21f6d8499..d69880b18 100644
--- a/packages/common/http/http.constants.ts
+++ b/packages/common/http/http.constants.ts
@@ -1,3 +1 @@
 export const AXIOS_INSTANCE_TOKEN = 'AXIOS_INSTANCE_TOKEN';
-export const HTTP_MODULE_ID = 'HTTP_MODULE_ID';
-export const HTTP_MODULE_OPTIONS = 'HTTP_MODULE_OPTIONS';
diff --git a/packages/common/http/http.module-definition.ts b/packages/common/http/http.module-definition.ts
new file mode 100644
index 000000000..708d8f701
--- /dev/null
+++ b/packages/common/http/http.module-definition.ts
@@ -0,0 +1,23 @@
+import { Provider } from '../interfaces';
+import { ConfigurableModuleBuilder } from '../module-utils';
+import { HttpModuleOptions } from './interfaces';
+
+export const {
+  ConfigurableModuleClass,
+  MODULE_OPTIONS_TOKEN,
+  ASYNC_OPTIONS_TYPE,
+} = new ConfigurableModuleBuilder<HttpModuleOptions>({
+  moduleName: 'Http',
+  alwaysTransient: true,
+})
+  .setFactoryMethodName('createHttpOptions')
+  .setExtras<{ extraProviders?: Provider[] }>(
+    {
+      extraProviders: [],
+    },
+    (definition, extras) => ({
+      ...definition,
+      providers: definition.providers.concat(extras?.extraProviders),
+    }),
+  )
+  .build();
diff --git a/packages/common/http/http.module.ts b/packages/common/http/http.module.ts
index cc0367673..a2e46b464 100644
--- a/packages/common/http/http.module.ts
+++ b/packages/common/http/http.module.ts
@@ -1,18 +1,14 @@
 import Axios from 'axios';
 import { Module } from '../decorators/modules/module.decorator';
-import { DynamicModule, Provider } from '../interfaces';
-import { randomStringGenerator } from '../utils/random-string-generator.util';
+import { DynamicModule } from '../interfaces';
+import { AXIOS_INSTANCE_TOKEN } from './http.constants';
 import {
-  AXIOS_INSTANCE_TOKEN,
-  HTTP_MODULE_ID,
-  HTTP_MODULE_OPTIONS,
-} from './http.constants';
+  ASYNC_OPTIONS_TYPE,
+  ConfigurableModuleClass,
+  MODULE_OPTIONS_TOKEN,
+} from './http.module-definition';
 import { HttpService } from './http.service';
-import {
-  HttpModuleAsyncOptions,
-  HttpModuleOptions,
-  HttpModuleOptionsFactory,
-} from './interfaces';
+import { HttpModuleOptions } from './interfaces';
 
 /**
  * @deprecated "HttpModule" (from the "@nestjs/common" package) is deprecated and will be removed in the next major release. Please, use the "@nestjs/axios" package instead.
@@ -27,73 +23,17 @@ import {
   ],
   exports: [HttpService],
 })
-export class HttpModule {
-  static register(config: HttpModuleOptions): DynamicModule {
-    return {
-      module: HttpModule,
-      providers: [
-        {
-          provide: AXIOS_INSTANCE_TOKEN,
-          useValue: Axios.create(config),
-        },
-        {
-          provide: HTTP_MODULE_ID,
-          useValue: randomStringGenerator(),
-        },
-      ],
-    };
-  }
-
-  static registerAsync(options: HttpModuleAsyncOptions): DynamicModule {
+export class HttpModule extends ConfigurableModuleClass {
+  static registerAsync(options: typeof ASYNC_OPTIONS_TYPE): DynamicModule {
     return {
-      module: HttpModule,
-      imports: options.imports,
+      ...super.registerAsync(options),
       providers: [
-        ...this.createAsyncProviders(options),
         {
           provide: AXIOS_INSTANCE_TOKEN,
           useFactory: (config: HttpModuleOptions) => Axios.create(config),
-          inject: [HTTP_MODULE_OPTIONS],
+          inject: [MODULE_OPTIONS_TOKEN],
         },
-        {
-          provide: HTTP_MODULE_ID,
-          useValue: randomStringGenerator(),
-        },
-        ...(options.extraProviders || []),
       ],
     };
   }
-
-  private static createAsyncProviders(
-    options: HttpModuleAsyncOptions,
-  ): Provider[] {
-    if (options.useExisting || options.useFactory) {
-      return [this.createAsyncOptionsProvider(options)];
-    }
-    return [
-      this.createAsyncOptionsProvider(options),
-      {
-        provide: options.useClass,
-        useClass: options.useClass,
-      },
-    ];
-  }
-
-  private static createAsyncOptionsProvider(
-    options: HttpModuleAsyncOptions,
-  ): Provider {
-    if (options.useFactory) {
-      return {
-        provide: HTTP_MODULE_OPTIONS,
-        useFactory: options.useFactory,
-        inject: options.inject || [],
-      };
-    }
-    return {
-      provide: HTTP_MODULE_OPTIONS,
-      useFactory: async (optionsFactory: HttpModuleOptionsFactory) =>
-        optionsFactory.createHttpOptions(),
-      inject: [options.useExisting || options.useClass],
-    };
-  }
 }
diff --git a/packages/common/http/interfaces/http-module.interface.ts b/packages/common/http/interfaces/http-module.interface.ts
index 794f9385c..02b147d86 100644
--- a/packages/common/http/interfaces/http-module.interface.ts
+++ b/packages/common/http/interfaces/http-module.interface.ts
@@ -1,19 +1,3 @@
 import { AxiosRequestConfig } from 'axios';
-import { ModuleMetadata, Provider, Type } from '../../interfaces';
 
 export type HttpModuleOptions = AxiosRequestConfig;
-
-export interface HttpModuleOptionsFactory {
-  createHttpOptions(): Promise<HttpModuleOptions> | HttpModuleOptions;
-}
-
-export interface HttpModuleAsyncOptions
-  extends Pick<ModuleMetadata, 'imports'> {
-  useExisting?: Type<HttpModuleOptionsFactory>;
-  useClass?: Type<HttpModuleOptionsFactory>;
-  useFactory?: (
-    ...args: any[]
-  ) => Promise<HttpModuleOptions> | HttpModuleOptions;
-  inject?: any[];
-  extraProviders?: Provider[];
-}
diff --git a/packages/common/index.ts b/packages/common/index.ts
index 0fe073784..350464899 100644
--- a/packages/common/index.ts
+++ b/packages/common/index.ts
@@ -61,6 +61,7 @@ export {
   WsExceptionFilter,
   WsMessageHandler,
 } from './interfaces';
+export * from './module-utils';
 export * from './pipes';
 export * from './serializer';
 export * from './services';
diff --git a/packages/common/interfaces/modules/provider.interface.ts b/packages/common/interfaces/modules/provider.interface.ts
index 39406c1e2..ba6d86da2 100644
--- a/packages/common/interfaces/modules/provider.interface.ts
+++ b/packages/common/interfaces/modules/provider.interface.ts
@@ -46,6 +46,12 @@ export interface ClassProvider<T = any> {
    * Optional enum defining lifetime of the provider that is injected.
    */
   scope?: Scope;
+  /**
+   * This option is only available on factory providers!
+   *
+   * @see [Use factory](https://docs.nestjs.com/fundamentals/custom-providers#factory-providers-usefactory)
+   */
+  inject?: never;
 }
 
 /**
@@ -72,6 +78,12 @@ export interface ValueProvider<T = any> {
    * Instance of a provider to be injected.
    */
   useValue: T;
+  /**
+   * This option is only available on factory providers!
+   *
+   * @see [Use factory](https://docs.nestjs.com/fundamentals/custom-providers#factory-providers-usefactory)
+   */
+  inject?: never;
 }
 
 /**
@@ -102,7 +114,7 @@ export interface FactoryProvider<T = any> {
   /**
    * Factory function that returns an instance of the provider to be injected.
    */
-  useFactory: (...args: any[]) => T;
+  useFactory: (...args: any[]) => T | Promise<T>;
   /**
    * Optional list of providers to be injected into the context of the Factory function.
    */
diff --git a/packages/common/module-utils/configurable-module.builder.ts b/packages/common/module-utils/configurable-module.builder.ts
new file mode 100644
index 000000000..0e3f1318f
--- /dev/null
+++ b/packages/common/module-utils/configurable-module.builder.ts
@@ -0,0 +1,330 @@
+import { DynamicModule, Provider } from '../interfaces';
+import { Logger } from '../services/logger.service';
+import { randomStringGenerator } from '../utils/random-string-generator.util';
+import {
+  ASYNC_METHOD_SUFFIX,
+  CONFIGURABLE_MODULE_ID,
+  DEFAULT_FACTORY_CLASS_METHOD_KEY,
+  DEFAULT_METHOD_KEY,
+} from './constants';
+import {
+  ConfigurableModuleAsyncOptions,
+  ConfigurableModuleCls,
+  ConfigurableModuleOptionsFactory,
+} from './interfaces';
+import { ConfigurableModuleHost } from './interfaces/configurable-module-host.interface';
+import { generateOptionsInjectionToken } from './utils/generate-options-injection-token.util';
+
+/**
+ * @publicApi
+ */
+export interface ConfigurableModuleBuilderOptions {
+  /**
+   * Specified what injection token should be used for the module options provider.
+   * By default, an auto-generated UUID will be used.
+   */
+  optionsInjectionToken?: string | symbol;
+  /**
+   * By default, an UUID will be used as a module options provider token.
+   * Explicitly specifying the "moduleName" will instruct the "ConfigurableModuleBuilder"
+   * to use a more descriptive provider token.
+   *
+   * For example, if `moduleName: "Cache"` then auto-generated provider token will be "CACHE_MODULE_OPTIONS".
+   */
+  moduleName?: string;
+  /**
+   * Indicates whether module should always be "transient", meaning,
+   * every time you call the static method to construct a dynamic module,
+   * regardless of what arguments you pass in, a new "unique" module will be created.
+   *
+   * @default false
+   */
+  alwaysTransient?: boolean;
+}
+
+/**
+ * Factory that lets you create configurable modules and
+ * provides a way to reduce the majority of dynamic module boilerplate.
+ *
+ * @publicApi
+ */
+export class ConfigurableModuleBuilder<
+  ModuleOptions,
+  StaticMethodKey extends string = typeof DEFAULT_METHOD_KEY,
+  FactoryClassMethodKey extends string = typeof DEFAULT_FACTORY_CLASS_METHOD_KEY,
+  ExtraModuleDefinitionOptions = {},
+> {
+  protected staticMethodKey: StaticMethodKey;
+  protected factoryClassMethodKey: FactoryClassMethodKey;
+  protected extras: ExtraModuleDefinitionOptions;
+  protected transformModuleDefinition: (
+    definition: DynamicModule,
+    extraOptions: ExtraModuleDefinitionOptions,
+  ) => DynamicModule;
+
+  protected readonly logger = new Logger(ConfigurableModuleBuilder.name);
+
+  constructor(
+    protected readonly options: ConfigurableModuleBuilderOptions = {},
+    parentBuilder?: ConfigurableModuleBuilder<ModuleOptions>,
+  ) {
+    if (parentBuilder) {
+      this.staticMethodKey = parentBuilder.staticMethodKey as StaticMethodKey;
+      this.factoryClassMethodKey =
+        parentBuilder.factoryClassMethodKey as FactoryClassMethodKey;
+      this.transformModuleDefinition = parentBuilder.transformModuleDefinition;
+      this.extras = parentBuilder.extras as ExtraModuleDefinitionOptions;
+    }
+  }
+
+  /**
+   * Registers the "extras" object (a set of extra options that can be used to modify the dynamic module definition).
+   * Values you specify within the "extras" object will be used as default values (that can be overriden by module consumers).
+   *
+   * This method also applies the so-called "module definition transform function" that takes the auto-generated
+   * dynamic module object ("DynamicModule") and the actual consumer "extras" object as input parameters.
+   * The "extras" object consists of values explicitly specified by module consumers and default values.
+   *
+   * @example
+   * ```typescript
+   * .setExtras<{ isGlobal?: boolean }>({ isGlobal: false }, (definition, extras) =>
+   *    ({ ...definition, global: extras.isGlobal })
+   * )
+   * ```
+   */
+  setExtras<ExtraModuleDefinitionOptions>(
+    extras: ExtraModuleDefinitionOptions,
+    transformDefinition: (
+      definition: DynamicModule,
+      extras: ExtraModuleDefinitionOptions,
+    ) => DynamicModule,
+  ) {
+    const builder = new ConfigurableModuleBuilder<
+      ModuleOptions,
+      StaticMethodKey,
+      FactoryClassMethodKey,
+      ExtraModuleDefinitionOptions
+    >(this.options, this as any);
+    builder.extras = extras;
+    builder.transformModuleDefinition = transformDefinition;
+    return builder;
+  }
+
+  /**
+   * Dynamic modules must expose public static methods that let you pass in
+   * configuration parameters (control the module's behavior from the outside).
+   * Some frequently used names that you may have seen in other modules are:
+   * "forRoot", "forFeature", "register", "configure".
+   *
+   * This method "setClassMethodName" lets you specify the name of the
+   * method that will be auto-generated.
+   *
+   * @param key name of the method
+   */
+  setClassMethodName<StaticMethodKey extends string>(key: StaticMethodKey) {
+    const builder = new ConfigurableModuleBuilder<
+      ModuleOptions,
+      StaticMethodKey,
+      FactoryClassMethodKey,
+      ExtraModuleDefinitionOptions
+    >(this.options, this as any);
+    builder.staticMethodKey = key;
+    return builder;
+  }
+
+  /**
+   * Asynchronously configured modules (that rely on other modules, i.e. "ConfigModule")
+   * let you pass the configuration factory class that will be registered and instantiated as a provider.
+   * This provider then will be used to retrieve the module's configuration. To provide the configuration,
+   * the corresponding factory method must be implemented.
+   *
+   * This method ("setFactoryMethodName") lets you control what method name will have to be
+   * implemented by the config factory (default is "create").
+   *
+   * @param key name of the method
+   */
+  setFactoryMethodName<FactoryClassMethodKey extends string>(
+    key: FactoryClassMethodKey,
+  ) {
+    const builder = new ConfigurableModuleBuilder<
+      ModuleOptions,
+      StaticMethodKey,
+      FactoryClassMethodKey,
+      ExtraModuleDefinitionOptions
+    >(this.options, this as any);
+    builder.factoryClassMethodKey = key;
+    return builder;
+  }
+
+  /**
+   * Returns an object consisting of multiple properties that lets you
+   * easily construct dynamic configurable modules. See "ConfigurableModuleHost" interface for more details.
+   */
+  build(): ConfigurableModuleHost<
+    ModuleOptions,
+    StaticMethodKey,
+    FactoryClassMethodKey,
+    ExtraModuleDefinitionOptions
+  > {
+    this.staticMethodKey ??= DEFAULT_METHOD_KEY as StaticMethodKey;
+    this.factoryClassMethodKey ??=
+      DEFAULT_FACTORY_CLASS_METHOD_KEY as FactoryClassMethodKey;
+    this.options.optionsInjectionToken ??= this.options.moduleName
+      ? this.constructInjectionTokenString()
+      : generateOptionsInjectionToken();
+    this.transformModuleDefinition ??= definition => definition;
+
+    return {
+      ConfigurableModuleClass:
+        this.createConfigurableModuleCls<ModuleOptions>(),
+      MODULE_OPTIONS_TOKEN: this.options.optionsInjectionToken,
+      ASYNC_OPTIONS_TYPE: this.createTypeProxy('ASYNC_OPTIONS_TYPE'),
+      OPTIONS_TYPE: this.createTypeProxy('OPTIONS_TYPE'),
+    };
+  }
+
+  private constructInjectionTokenString(): string {
+    const moduleNameInSnakeCase = this.options.moduleName
+      .trim()
+      .split(/(?=[A-Z])/)
+      .join('_')
+      .toUpperCase();
+    return `${moduleNameInSnakeCase}_MODULE_OPTIONS`;
+  }
+
+  private createConfigurableModuleCls<ModuleOptions>(): ConfigurableModuleCls<
+    ModuleOptions,
+    StaticMethodKey,
+    FactoryClassMethodKey
+  > {
+    // eslint-disable-next-line @typescript-eslint/no-this-alias
+    const self = this;
+    const asyncMethodKey = this.staticMethodKey + ASYNC_METHOD_SUFFIX;
+
+    class InternalModuleClass {
+      static [self.staticMethodKey](
+        options: ModuleOptions & ExtraModuleDefinitionOptions,
+      ): DynamicModule {
+        const providers = [
+          {
+            provide: self.options.optionsInjectionToken,
+            useValue: this.omitExtras(options, self.extras),
+          },
+        ];
+        if (self.options.alwaysTransient) {
+          providers.push({
+            provide: CONFIGURABLE_MODULE_ID,
+            useValue: randomStringGenerator(),
+          });
+        }
+        return self.transformModuleDefinition(
+          {
+            module: this,
+            providers,
+          },
+          options,
+        );
+      }
+
+      static [asyncMethodKey](
+        options: ConfigurableModuleAsyncOptions<ModuleOptions> &
+          ExtraModuleDefinitionOptions,
+      ): DynamicModule {
+        const providers = this.createAsyncProviders(options);
+        if (self.options.alwaysTransient) {
+          providers.push({
+            provide: CONFIGURABLE_MODULE_ID,
+            useValue: randomStringGenerator(),
+          });
+        }
+        return self.transformModuleDefinition(
+          {
+            module: this,
+            imports: options.imports || [],
+            providers,
+          },
+          options,
+        );
+      }
+
+      private static omitExtras(
+        input: ModuleOptions & ExtraModuleDefinitionOptions,
+        extras: ExtraModuleDefinitionOptions | undefined,
+      ): ModuleOptions {
+        if (!extras) {
+          return input;
+        }
+        const moduleOptions = {};
+        const extrasKeys = Object.keys(extras);
+
+        Object.keys(input)
+          .filter(key => !extrasKeys.includes(key))
+          .forEach(key => {
+            moduleOptions[key] = input[key];
+          });
+        return moduleOptions as ModuleOptions;
+      }
+
+      private static createAsyncProviders(
+        options: ConfigurableModuleAsyncOptions<ModuleOptions>,
+      ): Provider[] {
+        if (options.useExisting || options.useFactory) {
+          return [this.createAsyncOptionsProvider(options)];
+        }
+        return [
+          this.createAsyncOptionsProvider(options),
+          {
+            provide: options.useClass,
+            useClass: options.useClass,
+          },
+        ];
+      }
+
+      private static createAsyncOptionsProvider(
+        options: ConfigurableModuleAsyncOptions<ModuleOptions>,
+      ): Provider {
+        if (options.useFactory) {
+          return {
+            provide: self.options.optionsInjectionToken,
+            useFactory: options.useFactory,
+            inject: options.inject || [],
+          };
+        }
+        return {
+          provide: self.options.optionsInjectionToken,
+          useFactory: async (
+            optionsFactory: ConfigurableModuleOptionsFactory<
+              ModuleOptions,
+              FactoryClassMethodKey
+            >,
+          ) =>
+            await optionsFactory[
+              self.factoryClassMethodKey as keyof typeof optionsFactory
+            ](),
+          inject: [options.useExisting || options.useClass],
+        };
+      }
+    }
+    return InternalModuleClass as unknown as ConfigurableModuleCls<
+      ModuleOptions,
+      StaticMethodKey,
+      FactoryClassMethodKey
+    >;
+  }
+
+  private createTypeProxy(
+    typeName: 'OPTIONS_TYPE' | 'ASYNC_OPTIONS_TYPE' | 'OptionsFactoryInterface',
+  ) {
+    const proxy = new Proxy(
+      {},
+      {
+        get: () => {
+          throw new Error(
+            `"${typeName}" is not supposed to be used as a value.`,
+          );
+        },
+      },
+    );
+    return proxy as any;
+  }
+}
diff --git a/packages/common/module-utils/constants.ts b/packages/common/module-utils/constants.ts
new file mode 100644
index 000000000..2d97c0c8c
--- /dev/null
+++ b/packages/common/module-utils/constants.ts
@@ -0,0 +1,5 @@
+export const DEFAULT_METHOD_KEY = 'register';
+export const DEFAULT_FACTORY_CLASS_METHOD_KEY = 'create';
+
+export const ASYNC_METHOD_SUFFIX = 'Async';
+export const CONFIGURABLE_MODULE_ID = 'CONFIGURABLE_MODULE_ID';
diff --git a/packages/common/module-utils/index.ts b/packages/common/module-utils/index.ts
new file mode 100644
index 000000000..4393992bd
--- /dev/null
+++ b/packages/common/module-utils/index.ts
@@ -0,0 +1,2 @@
+export * from './configurable-module.builder';
+export * from './interfaces';
diff --git a/packages/common/module-utils/interfaces/configurable-module-async-options.interface.ts b/packages/common/module-utils/interfaces/configurable-module-async-options.interface.ts
new file mode 100644
index 000000000..56f7040e4
--- /dev/null
+++ b/packages/common/module-utils/interfaces/configurable-module-async-options.interface.ts
@@ -0,0 +1,51 @@
+import { FactoryProvider, ModuleMetadata, Type } from '../../interfaces';
+import { DEFAULT_FACTORY_CLASS_METHOD_KEY } from '../constants';
+
+/**
+ * Interface that must be implemented by the module options factory class.
+ * Method key varies depending on the "FactoryClassMethodKey" type argument.
+ *
+ * @publicApi
+ */
+export type ConfigurableModuleOptionsFactory<
+  ModuleOptions,
+  FactoryClassMethodKey extends string,
+> = Record<
+  `${FactoryClassMethodKey}`,
+  () => Promise<ModuleOptions> | ModuleOptions
+>;
+
+/**
+ * Interface that represents the module async options object
+ * Factory method name varies depending on the "FactoryClassMethodKey" type argument.
+ *
+ * @publicApi
+ */
+export interface ConfigurableModuleAsyncOptions<
+  ModuleOptions,
+  FactoryClassMethodKey extends string = typeof DEFAULT_FACTORY_CLASS_METHOD_KEY,
+> extends Pick<ModuleMetadata, 'imports'> {
+  /**
+   * Injection token resolving to an existing provider. The provider must implement
+   * the corresponding interface.
+   */
+  useExisting?: Type<
+    ConfigurableModuleOptionsFactory<ModuleOptions, FactoryClassMethodKey>
+  >;
+  /**
+   * Injection token resolving to a class that will be instantiated as a provider.
+   * The class must implement the corresponding interface.
+   */
+  useClass?: Type<
+    ConfigurableModuleOptionsFactory<ModuleOptions, FactoryClassMethodKey>
+  >;
+  /**
+   * Function returning options (or a Promise resolving to options) to configure the
+   * cache module.
+   */
+  useFactory?: (...args: unknown[]) => Promise<ModuleOptions> | ModuleOptions;
+  /**
+   * Dependencies that a Factory may inject.
+   */
+  inject?: FactoryProvider['inject'];
+}
diff --git a/packages/common/module-utils/interfaces/configurable-module-cls.interface.ts b/packages/common/module-utils/interfaces/configurable-module-cls.interface.ts
new file mode 100644
index 000000000..e01c706be
--- /dev/null
+++ b/packages/common/module-utils/interfaces/configurable-module-cls.interface.ts
@@ -0,0 +1,35 @@
+import { DynamicModule } from '../../interfaces';
+import {
+  DEFAULT_FACTORY_CLASS_METHOD_KEY,
+  DEFAULT_METHOD_KEY,
+} from '../constants';
+import { ConfigurableModuleAsyncOptions } from './configurable-module-async-options.interface';
+
+/**
+ * Class that represents a blueprint/prototype for a configurable Nest module.
+ * This class provides static methods for constructing dynamic modules. Their names
+ * can be controlled through the "MethodKey" type argument.
+ *
+ * @publicApi
+ */
+export type ConfigurableModuleCls<
+  ModuleOptions,
+  MethodKey extends string = typeof DEFAULT_METHOD_KEY,
+  FactoryClassMethodKey extends string = typeof DEFAULT_FACTORY_CLASS_METHOD_KEY,
+  ExtraModuleDefinitionOptions = {},
+> = {
+  new (): any;
+} & Record<
+  `${MethodKey}`,
+  (options: ModuleOptions & ExtraModuleDefinitionOptions) => DynamicModule
+> &
+  Record<
+    `${MethodKey}Async`,
+    (
+      options: ConfigurableModuleAsyncOptions<
+        ModuleOptions,
+        FactoryClassMethodKey
+      > &
+        ExtraModuleDefinitionOptions,
+    ) => DynamicModule
+  >;
diff --git a/packages/common/module-utils/interfaces/configurable-module-host.interface.ts b/packages/common/module-utils/interfaces/configurable-module-host.interface.ts
new file mode 100644
index 000000000..6a652ecce
--- /dev/null
+++ b/packages/common/module-utils/interfaces/configurable-module-host.interface.ts
@@ -0,0 +1,77 @@
+import { ConfigurableModuleAsyncOptions } from './configurable-module-async-options.interface';
+import { ConfigurableModuleCls } from './configurable-module-cls.interface';
+
+/**
+ * Configurable module host. See properties for more details
+ *
+ * @publicApi
+ */
+export interface ConfigurableModuleHost<
+  ModuleOptions = Record<string, unknown>,
+  MethodKey extends string = string,
+  FactoryClassMethodKey extends string = string,
+  ExtraModuleDefinitionOptions = {},
+> {
+  /**
+   * Class that represents a blueprint/prototype for a configurable Nest module.
+   * This class provides static methods for constructing dynamic modules. Their names
+   * can be controlled through the "MethodKey" type argument.
+   *
+   * Your module class should inherit from this class to make the static methods available.
+   *
+   * @example
+   * ```typescript
+   * @Module({})
+   * class IntegrationModule extends ConfigurableModuleCls {
+   *  // ...
+   * }
+   * ```
+   */
+  ConfigurableModuleClass: ConfigurableModuleCls<
+    ModuleOptions,
+    MethodKey,
+    FactoryClassMethodKey,
+    ExtraModuleDefinitionOptions
+  >;
+  /**
+   * Module options provider token. Can be used to inject the "options object" to
+   * providers registered within the host module.
+   */
+  MODULE_OPTIONS_TOKEN: string | symbol;
+  /**
+   * Can be used to auto-infer the compound "async module options" type.
+   * Note: this property is not supposed to be used as a value.
+   *
+   * @example
+   * ```typescript
+   * @Module({})
+   * class IntegrationModule extends ConfigurableModuleCls {
+   *  static module = initializer(IntegrationModule);
+   *
+   * static registerAsync(options: typeof ASYNC_OPTIONS_TYPE): DynamicModule {
+   *  return super.registerAsync(options);
+   * }
+   * ```
+   */
+  ASYNC_OPTIONS_TYPE: ConfigurableModuleAsyncOptions<
+    ModuleOptions,
+    FactoryClassMethodKey
+  > &
+    ExtraModuleDefinitionOptions;
+  /**
+   * Can be used to auto-infer the compound "module options" type (options interface + extra module definition options).
+   * Note: this property is not supposed to be used as a value.
+   *
+   * @example
+   * ```typescript
+   * @Module({})
+   * class IntegrationModule extends ConfigurableModuleCls {
+   *  static module = initializer(IntegrationModule);
+   *
+   * static register(options: typeof OPTIONS_TYPE): DynamicModule {
+   *  return super.register(options);
+   * }
+   * ```
+   */
+  OPTIONS_TYPE: ModuleOptions & ExtraModuleDefinitionOptions;
+}
diff --git a/packages/common/module-utils/interfaces/index.ts b/packages/common/module-utils/interfaces/index.ts
new file mode 100644
index 000000000..35c523076
--- /dev/null
+++ b/packages/common/module-utils/interfaces/index.ts
@@ -0,0 +1,3 @@
+export * from './configurable-module-async-options.interface';
+export * from './configurable-module-cls.interface';
+export * from './configurable-module-host.interface';
diff --git a/packages/common/module-utils/utils/generate-options-injection-token.util.ts b/packages/common/module-utils/utils/generate-options-injection-token.util.ts
new file mode 100644
index 000000000..259a6afa3
--- /dev/null
+++ b/packages/common/module-utils/utils/generate-options-injection-token.util.ts
@@ -0,0 +1,6 @@
+import { randomStringGenerator } from '../../utils/random-string-generator.util';
+
+export function generateOptionsInjectionToken() {
+  const hash = randomStringGenerator();
+  return `CONFIGURABLE_MODULE_OPTIONS[${hash}]`;
+}
diff --git a/packages/common/pipes/parse-uuid.pipe.ts b/packages/common/pipes/parse-uuid.pipe.ts
index 2679e8f93..81fe2b4c1 100644
--- a/packages/common/pipes/parse-uuid.pipe.ts
+++ b/packages/common/pipes/parse-uuid.pipe.ts
@@ -9,7 +9,7 @@ import {
   ErrorHttpStatusCode,
   HttpErrorByCode,
 } from '../utils/http-error-by-code.util';
-import { isUUID } from '../utils/is-uuid';
+import { isString } from '../utils/shared.utils';
 
 export interface ParseUUIDPipeOptions {
   version?: '3' | '4' | '5';
@@ -19,6 +19,12 @@ export interface ParseUUIDPipeOptions {
 
 @Injectable()
 export class ParseUUIDPipe implements PipeTransform<string> {
+  protected static uuidRegExps = {
+    3: /^[0-9A-F]{8}-[0-9A-F]{4}-3[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i,
+    4: /^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
+    5: /^[0-9A-F]{8}-[0-9A-F]{4}-5[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
+    all: /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i,
+  };
   private readonly version: '3' | '4' | '5';
   protected exceptionFactory: (errors: string) => any;
 
@@ -35,14 +41,23 @@ export class ParseUUIDPipe implements PipeTransform<string> {
       exceptionFactory ||
       (error => new HttpErrorByCode[errorHttpStatusCode](error));
   }
+
   async transform(value: string, metadata: ArgumentMetadata): Promise<string> {
-    if (!isUUID(value, this.version)) {
+    if (!this.isUUID(value, this.version)) {
       throw this.exceptionFactory(
-        `Validation failed (uuid ${
-          this.version ? 'v' + this.version : ''
+        `Validation failed (uuid${
+          this.version ? ` v ${this.version}` : ''
         } is expected)`,
       );
     }
     return value;
   }
+
+  protected isUUID(str: unknown, version = 'all') {
+    if (!isString(str)) {
+      throw this.exceptionFactory('The value passed as UUID is not a string');
+    }
+    const pattern = ParseUUIDPipe.uuidRegExps[version];
+    return pattern?.test(str);
+  }
 }
diff --git a/packages/common/test/module-utils/configurable-module.builder.spec.ts b/packages/common/test/module-utils/configurable-module.builder.spec.ts
new file mode 100644
index 000000000..3d3623271
--- /dev/null
+++ b/packages/common/test/module-utils/configurable-module.builder.spec.ts
@@ -0,0 +1,112 @@
+import { expect } from 'chai';
+import { Provider } from '../../interfaces';
+import { ConfigurableModuleBuilder } from '../../module-utils';
+
+describe('ConfigurableModuleBuilder', () => {
+  describe('setExtras', () => {
+    it('should apply module definition transformer function and return typed builder', () => {
+      const { ConfigurableModuleClass } = new ConfigurableModuleBuilder()
+        .setExtras(
+          { isGlobal: false },
+          (definition, extras: { isGlobal: boolean }) => ({
+            ...definition,
+            global: extras.isGlobal,
+          }),
+        )
+        .build();
+
+      expect(
+        ConfigurableModuleClass.register({
+          // No type error
+          isGlobal: true,
+        }),
+      ).to.deep.include({
+        global: true,
+      });
+    });
+  });
+  describe('setClassMethodName', () => {
+    it('should set static class method name and return typed builder', () => {
+      const { ConfigurableModuleClass } = new ConfigurableModuleBuilder()
+        .setClassMethodName('forRoot')
+        .build();
+
+      expect(ConfigurableModuleClass.forRoot).to.not.be.undefined;
+      expect(ConfigurableModuleClass.forRootAsync).to.not.be.undefined;
+      expect((ConfigurableModuleClass as any).register).to.be.undefined;
+    });
+  });
+  describe('setFactoryMethodName', () => {
+    it('should set configuration factory class method name and return typed builder', () => {
+      const { ConfigurableModuleClass } = new ConfigurableModuleBuilder()
+        .setFactoryMethodName('createOptions')
+        .build();
+
+      expect(
+        ConfigurableModuleClass.registerAsync({
+          useClass: class {
+            // No type error
+            createOptions() {}
+          },
+        }),
+      ).to.not.be.undefined;
+    });
+  });
+  describe('build', () => {
+    it('should return a fully typed "ConfigurableModuleClass"', () => {
+      type ExtraConfig = { isGlobal?: boolean; extraProviders: Provider[] };
+
+      const {
+        ConfigurableModuleClass,
+        OPTIONS_TYPE,
+        ASYNC_OPTIONS_TYPE,
+        MODULE_OPTIONS_TOKEN,
+      } = new ConfigurableModuleBuilder({
+        moduleName: 'RandomTest',
+        alwaysTransient: true,
+      })
+        .setFactoryMethodName('createOptions')
+        .setClassMethodName('forFeature')
+        .setExtras<ExtraConfig>(
+          { isGlobal: false, extraProviders: [] },
+          (definition, extras) => ({
+            ...definition,
+            global: extras.isGlobal,
+            providers: definition.providers?.concat(extras.extraProviders),
+          }),
+        )
+        .build();
+
+      const definition = ConfigurableModuleClass.forFeatureAsync({
+        useFactory: () => {},
+        isGlobal: true,
+        extraProviders: ['test' as any],
+      });
+
+      expect(definition.global).to.equal(true);
+      expect(definition.providers).to.have.length(3);
+      expect(definition.providers).to.deep.contain('test');
+      expect(MODULE_OPTIONS_TOKEN).to.equal('RANDOM_TEST_MODULE_OPTIONS');
+      expect((definition.providers[0] as any).provide).to.equal(
+        'RANDOM_TEST_MODULE_OPTIONS',
+      );
+
+      try {
+        expect(ASYNC_OPTIONS_TYPE.imports).to.equal(undefined);
+      } catch (err) {
+        expect(err).to.be.instanceOf(Error);
+        expect(err.message).to.equal(
+          '"ASYNC_OPTIONS_TYPE" is not supposed to be used as a value.',
+        );
+      }
+      try {
+        expect(OPTIONS_TYPE.isGlobal).to.equal(undefined);
+      } catch (err) {
+        expect(err).to.be.instanceOf(Error);
+        expect(err.message).to.equal(
+          '"OPTIONS_TYPE" is not supposed to be used as a value.',
+        );
+      }
+    });
+  });
+});
diff --git a/packages/common/test/pipes/parse-int.pipe.spec.ts b/packages/common/test/pipes/parse-int.pipe.spec.ts
index 3bb7ab185..d9d78de27 100644
--- a/packages/common/test/pipes/parse-int.pipe.spec.ts
+++ b/packages/common/test/pipes/parse-int.pipe.spec.ts
@@ -1,4 +1,3 @@
-import * as sinon from 'sinon';
 import { expect } from 'chai';
 import { ArgumentMetadata } from '../../interfaces';
 import { ParseIntPipe } from '../../pipes/parse-int.pipe';
diff --git a/packages/common/test/pipes/parse-uuid.pipe.spec.ts b/packages/common/test/pipes/parse-uuid.pipe.spec.ts
index 3f6cb79fb..bcb3a76b3 100644
--- a/packages/common/test/pipes/parse-uuid.pipe.spec.ts
+++ b/packages/common/test/pipes/parse-uuid.pipe.spec.ts
@@ -1,9 +1,18 @@
 import { expect } from 'chai';
+import { HttpStatus } from '../../enums';
+import { HttpException } from '../../exceptions';
 import { ArgumentMetadata } from '../../interfaces';
 import { ParseUUIDPipe } from '../../pipes/parse-uuid.pipe';
 
+class TestException extends HttpException {
+  constructor() {
+    super('This is a TestException', HttpStatus.I_AM_A_TEAPOT);
+  }
+}
+
 describe('ParseUUIDPipe', () => {
   let target: ParseUUIDPipe;
+  const exceptionFactory = (error: any) => new TestException();
 
   describe('transform', () => {
     const v3 = 'e8b5a51d-11c8-3310-a6ab-367563f20686';
@@ -12,53 +21,80 @@ describe('ParseUUIDPipe', () => {
 
     describe('when validation passes', () => {
       it('should return string if value is uuid v3, v4 or v5', async () => {
-        target = new ParseUUIDPipe();
+        target = new ParseUUIDPipe({ exceptionFactory });
         expect(await target.transform(v3, {} as ArgumentMetadata)).to.equal(v3);
         expect(await target.transform(v4, {} as ArgumentMetadata)).to.equal(v4);
         expect(await target.transform(v5, {} as ArgumentMetadata)).to.equal(v5);
       });
 
       it('should return string if value is uuid v3', async () => {
-        target = new ParseUUIDPipe({ version: '3' });
+        target = new ParseUUIDPipe({ version: '3', exceptionFactory });
         expect(await target.transform(v3, {} as ArgumentMetadata)).to.equal(v3);
       });
 
       it('should return string if value is uuid v4', async () => {
-        target = new ParseUUIDPipe({ version: '4' });
+        target = new ParseUUIDPipe({ version: '4', exceptionFactory });
         expect(await target.transform(v4, {} as ArgumentMetadata)).to.equal(v4);
       });
 
       it('should return string if value is uuid v5', async () => {
-        target = new ParseUUIDPipe({ version: '5' });
+        target = new ParseUUIDPipe({ version: '5', exceptionFactory });
         expect(await target.transform(v5, {} as ArgumentMetadata)).to.equal(v5);
       });
     });
 
     describe('when validation fails', () => {
       it('should throw an error', async () => {
-        target = new ParseUUIDPipe();
-        expect(target.transform('123a', {} as ArgumentMetadata)).to.be.rejected;
+        target = new ParseUUIDPipe({ exceptionFactory });
+        await expect(
+          target.transform('123a', {} as ArgumentMetadata),
+        ).to.be.rejectedWith(TestException);
+      });
+
+      it('should throw an error - not a string', async () => {
+        target = new ParseUUIDPipe({ exceptionFactory });
+        await expect(
+          target.transform(undefined, {} as ArgumentMetadata),
+        ).to.be.rejectedWith(TestException);
       });
 
       it('should throw an error - v3', async () => {
-        target = new ParseUUIDPipe({ version: '3' });
-        expect(target.transform('123a', {} as ArgumentMetadata)).to.be.rejected;
-        expect(target.transform(v4, {} as ArgumentMetadata)).to.be.rejected;
-        expect(target.transform(v5, {} as ArgumentMetadata)).to.be.rejected;
+        target = new ParseUUIDPipe({ version: '3', exceptionFactory });
+        await expect(
+          target.transform('123a', {} as ArgumentMetadata),
+        ).to.be.rejectedWith(TestException);
+        await expect(
+          target.transform(v4, {} as ArgumentMetadata),
+        ).to.be.rejectedWith(TestException);
+        await expect(
+          target.transform(v5, {} as ArgumentMetadata),
+        ).to.be.rejectedWith(TestException);
       });
 
       it('should throw an error - v4', async () => {
-        target = new ParseUUIDPipe({ version: '4' });
-        expect(target.transform('123a', {} as ArgumentMetadata)).to.be.rejected;
-        expect(target.transform(v3, {} as ArgumentMetadata)).to.be.rejected;
-        expect(target.transform(v5, {} as ArgumentMetadata)).to.be.rejected;
+        target = new ParseUUIDPipe({ version: '4', exceptionFactory });
+        await expect(
+          target.transform('123a', {} as ArgumentMetadata),
+        ).to.be.rejectedWith(TestException);
+        await expect(
+          target.transform(v3, {} as ArgumentMetadata),
+        ).to.be.rejectedWith(TestException);
+        await expect(
+          target.transform(v5, {} as ArgumentMetadata),
+        ).to.be.rejectedWith(TestException);
       });
 
       it('should throw an error - v5 ', async () => {
-        target = new ParseUUIDPipe({ version: '5' });
-        expect(target.transform('123a', {} as ArgumentMetadata)).to.be.rejected;
-        expect(target.transform(v3, {} as ArgumentMetadata)).to.be.rejected;
-        expect(target.transform(v4, {} as ArgumentMetadata)).to.be.rejected;
+        target = new ParseUUIDPipe({ version: '5', exceptionFactory });
+        await expect(
+          target.transform('123a', {} as ArgumentMetadata),
+        ).to.be.rejectedWith(TestException);
+        await expect(
+          target.transform(v3, {} as ArgumentMetadata),
+        ).to.be.rejectedWith(TestException);
+        await expect(
+          target.transform(v4, {} as ArgumentMetadata),
+        ).to.be.rejectedWith(TestException);
       });
     });
   });
diff --git a/packages/common/utils/is-uuid.ts b/packages/common/utils/is-uuid.ts
deleted file mode 100644
index 0e9572f4d..000000000
--- a/packages/common/utils/is-uuid.ts
+++ /dev/null
@@ -1,17 +0,0 @@
-import { BadRequestException } from '../exceptions';
-import { isString } from './shared.utils';
-
-const uuid = {
-  3: /^[0-9A-F]{8}-[0-9A-F]{4}-3[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i,
-  4: /^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
-  5: /^[0-9A-F]{8}-[0-9A-F]{4}-5[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
-  all: /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i,
-};
-
-export function isUUID(str: any, version = 'all') {
-  if (!isString(str)) {
-    throw new BadRequestException('The value passed as UUID is not a string');
-  }
-  const pattern = uuid[version];
-  return pattern && pattern.test(str);
-}
diff --git a/packages/core/router/router-explorer.ts b/packages/core/router/router-explorer.ts
index ee509718b..ab0517dc5 100644
--- a/packages/core/router/router-explorer.ts
+++ b/packages/core/router/router-explorer.ts
@@ -338,8 +338,7 @@ export class RouterExplorer {
       return router.applyVersionFilter(handler, version, versioningOptions);
     }
     /**
-     * This can be removed in the next major release.
-     * Left for backward-compatibility.
+     * TODO(v9): This was left for backward-compatibility and can be removed.
      */
     return <TRequest extends Record<string, any> = any, TResponse = any>(
       req: TRequest,
@@ -403,9 +402,16 @@ export class RouterExplorer {
 
         const acceptHeaderVersionParameter = acceptHeaderValue
           ? acceptHeaderValue.split(';')[1]
-          : '';
+          : undefined;
 
-        if (acceptHeaderVersionParameter) {
+        // No version was supplied
+        if (isUndefined(acceptHeaderVersionParameter)) {
+          if (Array.isArray(version)) {
+            if (version.includes(VERSION_NEUTRAL)) {
+              return handler(req, res, next);
+            }
+          }
+        } else {
           const headerVersion = acceptHeaderVersionParameter.split(
             versioningOptions.key,
           )[1];
@@ -427,7 +433,14 @@ export class RouterExplorer {
           req.headers?.[versioningOptions.header] ||
           req.headers?.[versioningOptions.header.toLowerCase()];
 
-        if (customHeaderVersionParameter) {
+        // No version was supplied
+        if (isUndefined(customHeaderVersionParameter)) {
+          if (Array.isArray(version)) {
+            if (version.includes(VERSION_NEUTRAL)) {
+              return handler(req, res, next);
+            }
+          }
+        } else {
           if (Array.isArray(version)) {
             if (version.includes(customHeaderVersionParameter)) {
               return handler(req, res, next);
diff --git a/packages/core/router/router-response-controller.ts b/packages/core/router/router-response-controller.ts
index 008eea5a8..4128e7fca 100644
--- a/packages/core/router/router-response-controller.ts
+++ b/packages/core/router/router-response-controller.ts
@@ -5,9 +5,9 @@ import {
   RequestMethod,
   MessageEvent,
 } from '@nestjs/common';
-import { isFunction, isObject } from '@nestjs/common/utils/shared.utils';
+import { isObject } from '@nestjs/common/utils/shared.utils';
 import { IncomingMessage } from 'http';
-import { EMPTY, lastValueFrom, Observable } from 'rxjs';
+import { EMPTY, lastValueFrom, Observable, isObservable } from 'rxjs';
 import { catchError, debounce, map } from 'rxjs/operators';
 import {
   AdditionalHeaders,
@@ -64,7 +64,7 @@ export class RouterResponseController {
   }
 
   public async transformToResult(resultOrDeferred: any) {
-    if (resultOrDeferred && isFunction(resultOrDeferred.subscribe)) {
+    if (isObservable(resultOrDeferred)) {
       return lastValueFrom(resultOrDeferred);
     }
     return resultOrDeferred;
@@ -152,8 +152,8 @@ export class RouterResponseController {
     });
   }
 
-  private assertObservable(result: any) {
-    if (!isFunction(result.subscribe)) {
+  private assertObservable(value: any) {
+    if (!isObservable(value)) {
       throw new ReferenceError(
         'You must return an Observable stream to use Server-Sent Events (SSE).',
       );
diff --git a/packages/core/test/router/router-explorer.spec.ts b/packages/core/test/router/router-explorer.spec.ts
index e1977f36e..5f5343210 100644
--- a/packages/core/test/router/router-explorer.spec.ts
+++ b/packages/core/test/router/router-explorer.spec.ts
@@ -365,38 +365,38 @@ describe('RouterExplorer', () => {
   });
 
   describe('applyVersionFilter', () => {
-    describe('when the version is VERSION_NEUTRAL', () => {
-      it('should return the handler', () => {
-        const version = VERSION_NEUTRAL as VersionValue;
-        const versioningOptions: VersioningOptions = {
-          type: VersioningType.URI,
-        };
-        const handler = sinon.stub();
+    describe('when the versioning type is URI', () => {
+      describe('and the version is VERSION_NEUTRAL', () => {
+        it('should return the handler', () => {
+          const version: VersionValue = VERSION_NEUTRAL;
+          const versioningOptions: RoutePathMetadata['versioningOptions'] = {
+            type: VersioningType.URI,
+          };
+          const handler = sinon.stub();
 
-        const routePathMetadata: RoutePathMetadata = {
-          methodVersion: version,
-          versioningOptions,
-        };
-        const versionFilter = (routerBuilder as any).applyVersionFilter(
-          null,
-          routePathMetadata,
-          handler,
-        );
+          const routePathMetadata: RoutePathMetadata = {
+            methodVersion: version,
+            versioningOptions,
+          };
+          const versionFilter = (routerBuilder as any).applyVersionFilter(
+            null,
+            routePathMetadata,
+            handler,
+          );
 
-        const req = {};
-        const res = {};
-        const next = sinon.stub();
+          const req = {};
+          const res = {};
+          const next = sinon.stub();
 
-        versionFilter(req, res, next);
+          versionFilter(req, res, next);
 
-        expect(handler.calledWith(req, res, next)).to.be.true;
+          expect(handler.calledWith(req, res, next)).to.be.true;
+        });
       });
-    });
 
-    describe('when the versioning type is URI', () => {
       it('should return the handler', () => {
         const version = '1';
-        const versioningOptions: VersioningOptions = {
+        const versioningOptions: RoutePathMetadata['versioningOptions'] = {
           type: VersioningType.URI,
         };
         const handler = sinon.stub();
@@ -423,7 +423,7 @@ describe('RouterExplorer', () => {
     describe('when the versioning type is MEDIA_TYPE', () => {
       it('should return next if there is no Media Type header', () => {
         const version = '1';
-        const versioningOptions: VersioningOptions = {
+        const versioningOptions: RoutePathMetadata['versioningOptions'] = {
           type: VersioningType.MEDIA_TYPE,
           key: 'v=',
         };
@@ -450,7 +450,7 @@ describe('RouterExplorer', () => {
 
       it('should return next if there is no version in the Media Type header', () => {
         const version = '1';
-        const versioningOptions: VersioningOptions = {
+        const versioningOptions: RoutePathMetadata['versioningOptions'] = {
           type: VersioningType.MEDIA_TYPE,
           key: 'v=',
         };
@@ -476,9 +476,64 @@ describe('RouterExplorer', () => {
       });
 
       describe('when the handler version is an array', () => {
+        describe('and the version has VERSION_NEUTRAL', () => {
+          it('should return the handler if there is no version in the Media Type header', () => {
+            const version: VersionValue = [VERSION_NEUTRAL];
+            const versioningOptions: RoutePathMetadata['versioningOptions'] = {
+              type: VersioningType.MEDIA_TYPE,
+              key: 'v=',
+            };
+            const handler = sinon.stub();
+
+            const routePathMetadata: RoutePathMetadata = {
+              methodVersion: version,
+              versioningOptions,
+            };
+            const versionFilter = (routerBuilder as any).applyVersionFilter(
+              null,
+              routePathMetadata,
+              handler,
+            );
+
+            const req = {};
+            const res = {};
+            const next = sinon.stub();
+
+            versionFilter(req, res, next);
+
+            expect(handler.calledWith(req, res, next)).to.be.true;
+          });
+          it('should return next if the version in the Media Type header does not match the handler version', () => {
+            const version: VersionValue = ['1', '2', VERSION_NEUTRAL];
+            const versioningOptions: RoutePathMetadata['versioningOptions'] = {
+              type: VersioningType.MEDIA_TYPE,
+              key: 'v=',
+            };
+            const handler = sinon.stub();
+
+            const routePathMetadata: RoutePathMetadata = {
+              methodVersion: version,
+              versioningOptions,
+            };
+            const versionFilter = (routerBuilder as any).applyVersionFilter(
+              null,
+              routePathMetadata,
+              handler,
+            );
+
+            const req = { headers: { accept: 'application/json;v=3' } };
+            const res = {};
+            const next = sinon.stub();
+
+            versionFilter(req, res, next);
+
+            expect(next.called).to.be.true;
+          });
+        });
+
         it('should return next if the version in the Media Type header does not match the handler version', () => {
           const version = ['1', '2'];
-          const versioningOptions: VersioningOptions = {
+          const versioningOptions: RoutePathMetadata['versioningOptions'] = {
             type: VersioningType.MEDIA_TYPE,
             key: 'v=',
           };
@@ -505,7 +560,7 @@ describe('RouterExplorer', () => {
 
         it('should return the handler if the version in the Media Type header matches the handler version', () => {
           const version = ['1', '2'];
-          const versioningOptions: VersioningOptions = {
+          const versioningOptions: RoutePathMetadata['versioningOptions'] = {
             type: VersioningType.MEDIA_TYPE,
             key: 'v=',
           };
@@ -534,7 +589,7 @@ describe('RouterExplorer', () => {
       describe('when the handler version is a string', () => {
         it('should return next if the version in the Media Type header does not match the handler version', () => {
           const version = '1';
-          const versioningOptions: VersioningOptions = {
+          const versioningOptions: RoutePathMetadata['versioningOptions'] = {
             type: VersioningType.MEDIA_TYPE,
             key: 'v=',
           };
@@ -561,7 +616,7 @@ describe('RouterExplorer', () => {
 
         it('should return the handler if the version in the Media Type header matches the handler version', () => {
           const version = '1';
-          const versioningOptions: VersioningOptions = {
+          const versioningOptions: RoutePathMetadata['versioningOptions'] = {
             type: VersioningType.MEDIA_TYPE,
             key: 'v=',
           };
@@ -767,7 +822,7 @@ describe('RouterExplorer', () => {
     describe('when the versioning type is HEADER', () => {
       it('should return next if there is no Custom Header', () => {
         const version = '1';
-        const versioningOptions: VersioningOptions = {
+        const versioningOptions: RoutePathMetadata['versioningOptions'] = {
           type: VersioningType.HEADER,
           header: 'X-API-Version',
         };
@@ -794,7 +849,7 @@ describe('RouterExplorer', () => {
 
       it('should return next if there is no version in the Custom Header', () => {
         const version = '1';
-        const versioningOptions: VersioningOptions = {
+        const versioningOptions: RoutePathMetadata['versioningOptions'] = {
           type: VersioningType.HEADER,
           header: 'X-API-Version',
         };
@@ -820,9 +875,64 @@ describe('RouterExplorer', () => {
       });
 
       describe('when the handler version is an array', () => {
+        describe('and the version has VERSION_NEUTRAL', () => {
+          it('should return the handler if there is no version in the Custom Header', () => {
+            const version: VersionValue = [VERSION_NEUTRAL];
+            const versioningOptions: RoutePathMetadata['versioningOptions'] = {
+              type: VersioningType.HEADER,
+              header: 'X-API-Version',
+            };
+            const handler = sinon.stub();
+
+            const routePathMetadata: RoutePathMetadata = {
+              methodVersion: version,
+              versioningOptions,
+            };
+            const versionFilter = (routerBuilder as any).applyVersionFilter(
+              null,
+              routePathMetadata,
+              handler,
+            );
+
+            const req = {};
+            const res = {};
+            const next = sinon.stub();
+
+            versionFilter(req, res, next);
+
+            expect(handler.calledWith(req, res, next)).to.be.true;
+          });
+          it('should return next if the version in the Custom Header does not match the handler version', () => {
+            const version: VersionValue = ['1', '2', VERSION_NEUTRAL];
+            const versioningOptions: RoutePathMetadata['versioningOptions'] = {
+              type: VersioningType.HEADER,
+              header: 'X-API-Version',
+            };
+            const handler = sinon.stub();
+
+            const routePathMetadata: RoutePathMetadata = {
+              methodVersion: version,
+              versioningOptions,
+            };
+            const versionFilter = (routerBuilder as any).applyVersionFilter(
+              null,
+              routePathMetadata,
+              handler,
+            );
+
+            const req = { headers: { 'X-API-Version': '3' } };
+            const res = {};
+            const next = sinon.stub();
+
+            versionFilter(req, res, next);
+
+            expect(next.called).to.be.true;
+          });
+        });
+
         it('should return next if the version in the Custom Header does not match the handler version', () => {
           const version = ['1', '2'];
-          const versioningOptions: VersioningOptions = {
+          const versioningOptions: RoutePathMetadata['versioningOptions'] = {
             type: VersioningType.HEADER,
             header: 'X-API-Version',
           };
@@ -849,7 +959,7 @@ describe('RouterExplorer', () => {
 
         it('should return the handler if the version in the Custom Header matches the handler version', () => {
           const version = ['1', '2'];
-          const versioningOptions: VersioningOptions = {
+          const versioningOptions: RoutePathMetadata['versioningOptions'] = {
             type: VersioningType.HEADER,
             header: 'X-API-Version',
           };
@@ -878,7 +988,7 @@ describe('RouterExplorer', () => {
       describe('when the handler version is a string', () => {
         it('should return next if the version in the Custom Header does not match the handler version', () => {
           const version = '1';
-          const versioningOptions: VersioningOptions = {
+          const versioningOptions: RoutePathMetadata['versioningOptions'] = {
             type: VersioningType.HEADER,
             header: 'X-API-Version',
           };
@@ -905,7 +1015,7 @@ describe('RouterExplorer', () => {
 
         it('should return the handler if the version in the Custom Header matches the handler version', () => {
           const version = '1';
-          const versioningOptions: VersioningOptions = {
+          const versioningOptions: RoutePathMetadata['versioningOptions'] = {
             type: VersioningType.HEADER,
             header: 'X-API-Version',
           };
diff --git a/packages/core/test/router/router-response-controller.spec.ts b/packages/core/test/router/router-response-controller.spec.ts
index ebe155639..fbc3d3490 100644
--- a/packages/core/test/router/router-response-controller.spec.ts
+++ b/packages/core/test/router/router-response-controller.spec.ts
@@ -71,13 +71,13 @@ describe('RouterResponseController', () => {
   describe('transformToResult', () => {
     describe('when resultOrDeferred', () => {
       describe('is Promise', () => {
-        it('should return Promise', async () => {
+        it('should return Promise that resolves to the value resolved by the input Promise', async () => {
           const value = 100;
           expect(
             await routerResponseController.transformToResult(
               Promise.resolve(value),
             ),
-          ).to.be.eq(100);
+          ).to.be.eq(value);
         });
       });
 
@@ -88,16 +88,25 @@ describe('RouterResponseController', () => {
             await routerResponseController.transformToResult(
               of(1, 2, 3, lastValue),
             ),
-          ).to.be.eq(100);
+          ).to.be.eq(lastValue);
         });
       });
 
-      describe('is value', () => {
-        it('should return Promise', async () => {
+      describe('is an object that has the method `subscribe`', () => {
+        it('should return a Promise that resolves to the input value', async () => {
+          const value = { subscribe() {} };
+          expect(
+            await routerResponseController.transformToResult(value),
+          ).to.equal(value);
+        });
+      });
+
+      describe('is an ordinary value', () => {
+        it('should return a Promise that resolves to the input value', async () => {
           const value = 100;
           expect(
             await routerResponseController.transformToResult(value),
-          ).to.be.eq(100);
+          ).to.be.eq(value);
         });
       });
     });
diff --git a/packages/microservices/constants.ts b/packages/microservices/constants.ts
index a47c40762..3e65795a7 100644
--- a/packages/microservices/constants.ts
+++ b/packages/microservices/constants.ts
@@ -38,10 +38,8 @@ export const RQM_DEFAULT_NOACK = true;
 export const RQM_DEFAULT_PERSISTENT = false;
 export const GRPC_DEFAULT_PROTO_LOADER = '@grpc/proto-loader';
 
-export const NO_EVENT_HANDLER = (text: TemplateStringsArray, pattern: string) =>
-  `There is no matching event handler defined in the remote service. Event pattern: ${pattern}`;
 export const NO_MESSAGE_HANDLER = `There is no matching message handler defined in the remote service.`;
-
+export const NO_EVENT_HANDLER = `There is no matching event handler defined in the remote service.`;
 export const DISCONNECTED_RMQ_MESSAGE = `Disconnected from RMQ. Trying to reconnect.`;
 
 export const KAFKA_DEFAULT_CLIENT = 'nestjs-consumer';
diff --git a/packages/microservices/context/rpc-proxy.ts b/packages/microservices/context/rpc-proxy.ts
index 521d5b7cd..081167f62 100644
--- a/packages/microservices/context/rpc-proxy.ts
+++ b/packages/microservices/context/rpc-proxy.ts
@@ -1,5 +1,5 @@
 import { ExecutionContextHost } from '@nestjs/core/helpers/execution-context-host';
-import { isObservable, Observable } from 'rxjs';
+import { Observable, isObservable } from 'rxjs';
 import { catchError } from 'rxjs/operators';
 import { RpcExceptionsHandler } from '../exceptions/rpc-exceptions-handler';
 
diff --git a/packages/microservices/ctx-host/kafka.context.ts b/packages/microservices/ctx-host/kafka.context.ts
index 54c80475a..922ccb9c5 100644
--- a/packages/microservices/ctx-host/kafka.context.ts
+++ b/packages/microservices/ctx-host/kafka.context.ts
@@ -1,12 +1,7 @@
-import { Consumer, KafkaMessage } from '../external/kafka.interface';
+import { KafkaMessage } from '../external/kafka.interface';
 import { BaseRpcContext } from './base-rpc.context';
 
-type KafkaContextArgs = [
-  message: KafkaMessage,
-  partition: number,
-  topic: string,
-  consumer: Consumer,
-];
+type KafkaContextArgs = [KafkaMessage, number, string];
 
 export class KafkaContext extends BaseRpcContext<KafkaContextArgs> {
   constructor(args: KafkaContextArgs) {
@@ -33,11 +28,4 @@ export class KafkaContext extends BaseRpcContext<KafkaContextArgs> {
   getTopic() {
     return this.args[2];
   }
-
-  /**
-   * Returns the Kafka consumer reference.
-   */
-  getConsumer() {
-    return this.args[3];
-  }
 }
diff --git a/packages/microservices/decorators/event-pattern.decorator.ts b/packages/microservices/decorators/event-pattern.decorator.ts
index 34708b007..b44825d63 100644
--- a/packages/microservices/decorators/event-pattern.decorator.ts
+++ b/packages/microservices/decorators/event-pattern.decorator.ts
@@ -48,7 +48,11 @@ export const EventPattern: {
     key: string | symbol,
     descriptor: PropertyDescriptor,
   ) => {
-    Reflect.defineMetadata(PATTERN_METADATA, metadata, descriptor.value);
+    Reflect.defineMetadata(
+      PATTERN_METADATA,
+      [].concat(metadata),
+      descriptor.value,
+    );
     Reflect.defineMetadata(
       PATTERN_HANDLER_METADATA,
       PatternHandler.EVENT,
diff --git a/packages/microservices/decorators/message-pattern.decorator.ts b/packages/microservices/decorators/message-pattern.decorator.ts
index 3e17d8569..6cb4ed1d8 100644
--- a/packages/microservices/decorators/message-pattern.decorator.ts
+++ b/packages/microservices/decorators/message-pattern.decorator.ts
@@ -62,7 +62,11 @@ export const MessagePattern: {
     key: string | symbol,
     descriptor: PropertyDescriptor,
   ) => {
-    Reflect.defineMetadata(PATTERN_METADATA, metadata, descriptor.value);
+    Reflect.defineMetadata(
+      PATTERN_METADATA,
+      [].concat(metadata),
+      descriptor.value,
+    );
     Reflect.defineMetadata(
       PATTERN_HANDLER_METADATA,
       PatternHandler.MESSAGE,
diff --git a/packages/microservices/deserializers/kafka-request.deserializer.ts b/packages/microservices/deserializers/kafka-request.deserializer.ts
deleted file mode 100644
index 99dae3119..000000000
--- a/packages/microservices/deserializers/kafka-request.deserializer.ts
+++ /dev/null
@@ -1,21 +0,0 @@
-import { IncomingEvent, IncomingRequest } from '../interfaces';
-import { KafkaRequest } from '../serializers/kafka-request.serializer';
-import { IncomingRequestDeserializer } from './incoming-request.deserializer';
-
-export class KafkaRequestDeserializer extends IncomingRequestDeserializer {
-  mapToSchema(
-    data: KafkaRequest,
-    options?: Record<string, any>,
-  ): IncomingRequest | IncomingEvent {
-    if (!options) {
-      return {
-        pattern: undefined,
-        data: undefined,
-      };
-    }
-    return {
-      pattern: options.channel,
-      data: data?.value ?? data,
-    };
-  }
-}
diff --git a/packages/microservices/exceptions/index.ts b/packages/microservices/exceptions/index.ts
index 73e4c3176..dd6e4d298 100644
--- a/packages/microservices/exceptions/index.ts
+++ b/packages/microservices/exceptions/index.ts
@@ -1,3 +1,2 @@
 export * from './base-rpc-exception-filter';
-export * from './kafka-retriable-exception';
 export * from './rpc-exception';
diff --git a/packages/microservices/exceptions/kafka-retriable-exception.ts b/packages/microservices/exceptions/kafka-retriable-exception.ts
deleted file mode 100644
index c62194a2e..000000000
--- a/packages/microservices/exceptions/kafka-retriable-exception.ts
+++ /dev/null
@@ -1,17 +0,0 @@
-import { RpcException } from './rpc-exception';
-
-/**
- * Exception that instructs Kafka driver to instead of introspecting
- * error processing flow and sending serialized error message to the consumer,
- * force bubble it up to the "eachMessage" callback of the underlying "kafkajs" package
- * (even if interceptors are applied, or an observable stream is returned from the message handler).
- *
- * A transient exception that if retried may succeed.
- *
- * @publicApi
- */
-export class KafkaRetriableException extends RpcException {
-  public getError(): string | object {
-    return this;
-  }
-}
diff --git a/packages/microservices/listener-metadata-explorer.ts b/packages/microservices/listener-metadata-explorer.ts
index 83e8f04c2..66ddffaf0 100644
--- a/packages/microservices/listener-metadata-explorer.ts
+++ b/packages/microservices/listener-metadata-explorer.ts
@@ -20,7 +20,7 @@ export interface ClientProperties {
 }
 
 export interface EventOrMessageListenerDefinition {
-  pattern: PatternMetadata;
+  patterns: PatternMetadata[];
   methodKey: string;
   isEventHandler: boolean;
   targetCallback: (...args: any[]) => any;
@@ -58,13 +58,13 @@ export class ListenerMetadataExplorer {
     if (isUndefined(handlerType)) {
       return;
     }
-    const pattern = Reflect.getMetadata(PATTERN_METADATA, targetCallback);
+    const patterns = Reflect.getMetadata(PATTERN_METADATA, targetCallback);
     const transport = Reflect.getMetadata(TRANSPORT_METADATA, targetCallback);
     const extras = Reflect.getMetadata(PATTERN_EXTRAS_METADATA, targetCallback);
     return {
       methodKey,
       targetCallback,
-      pattern,
+      patterns,
       transport,
       extras,
       isEventHandler: handlerType === PatternHandler.EVENT,
diff --git a/packages/microservices/listeners-controller.ts b/packages/microservices/listeners-controller.ts
index 7687ccf46..abc77d597 100644
--- a/packages/microservices/listeners-controller.ts
+++ b/packages/microservices/listeners-controller.ts
@@ -71,8 +71,20 @@ export class ListenersController {
           isUndefined(server.transportId) ||
           transport === server.transportId,
       )
+      .reduce((acc, handler) => {
+        handler.patterns.forEach(pattern =>
+          acc.push({ ...handler, patterns: [pattern] }),
+        );
+        return acc;
+      }, [])
       .forEach(
-        ({ pattern, targetCallback, methodKey, extras, isEventHandler }) => {
+        ({
+          patterns: [pattern],
+          targetCallback,
+          methodKey,
+          extras,
+          isEventHandler,
+        }) => {
           if (isStatic) {
             const proxy = this.contextCreator.create(
               instance as object,
diff --git a/packages/microservices/microservices-module.ts b/packages/microservices/microservices-module.ts
index 54632e412..735fda9fe 100644
--- a/packages/microservices/microservices-module.ts
+++ b/packages/microservices/microservices-module.ts
@@ -24,12 +24,13 @@ export class MicroservicesModule {
   private listenersController: ListenersController;
 
   public register(container: NestContainer, config: ApplicationConfig) {
+    const rpcProxy = new RpcProxy();
     const exceptionFiltersContext = new ExceptionFiltersContext(
       container,
       config,
     );
     const contextCreator = new RpcContextCreator(
-      new RpcProxy(),
+      rpcProxy,
       exceptionFiltersContext,
       new PipesContextCreator(container, config),
       new PipesConsumer(),
diff --git a/packages/microservices/server/server-kafka.ts b/packages/microservices/server/server-kafka.ts
index 880af956d..829d30d91 100644
--- a/packages/microservices/server/server-kafka.ts
+++ b/packages/microservices/server/server-kafka.ts
@@ -1,17 +1,14 @@
 import { Logger } from '@nestjs/common/services/logger.service';
 import { isNil } from '@nestjs/common/utils/shared.utils';
-import { isObservable, lastValueFrom, Observable, ReplaySubject } from 'rxjs';
+import { Observable } from 'rxjs';
 import {
   KAFKA_DEFAULT_BROKER,
   KAFKA_DEFAULT_CLIENT,
   KAFKA_DEFAULT_GROUP,
-  NO_EVENT_HANDLER,
   NO_MESSAGE_HANDLER,
 } from '../constants';
 import { KafkaContext } from '../ctx-host';
-import { KafkaRequestDeserializer } from '../deserializers/kafka-request.deserializer';
 import { KafkaHeaders, Transport } from '../enums';
-import { KafkaRetriableException } from '../exceptions';
 import {
   BrokersFunction,
   Consumer,
@@ -29,7 +26,6 @@ import {
   CustomTransportStrategy,
   KafkaOptions,
   OutgoingResponse,
-  ReadPacket,
 } from '../interfaces';
 import { KafkaRequestSerializer } from '../serializers/kafka-request.serializer';
 import { Server } from './server';
@@ -166,7 +162,6 @@ export class ServerKafka extends Server implements CustomTransportStrategy {
       rawMessage,
       payload.partition,
       payload.topic,
-      this.consumer,
     ]);
     const handler = this.getHandlerByPattern(packet.pattern);
     // if the correlation id or reply topic is not set
@@ -191,37 +186,7 @@ export class ServerKafka extends Server implements CustomTransportStrategy {
     const response$ = this.transformToObservable(
       await handler(packet.data, kafkaContext),
     );
-
-    const replayStream$ = new ReplaySubject();
-    await this.combineStreamsAndThrowIfRetriable(response$, replayStream$);
-
-    this.send(replayStream$, publish);
-  }
-
-  private combineStreamsAndThrowIfRetriable(
-    response$: Observable<any>,
-    replayStream$: ReplaySubject<unknown>,
-  ) {
-    return new Promise<void>((resolve, reject) => {
-      let isPromiseResolved = false;
-      response$.subscribe({
-        next: val => {
-          replayStream$.next(val);
-          if (!isPromiseResolved) {
-            isPromiseResolved = true;
-            resolve();
-          }
-        },
-        error: err => {
-          if (err instanceof KafkaRetriableException && !isPromiseResolved) {
-            isPromiseResolved = true;
-            reject(err);
-          }
-          replayStream$.error(err);
-        },
-        complete: () => replayStream$.complete(),
-      });
-    });
+    response$ && this.send(response$, publish);
   }
 
   public async sendMessage(
@@ -263,12 +228,9 @@ export class ServerKafka extends Server implements CustomTransportStrategy {
     if (!outgoingResponse.err) {
       return;
     }
-    const stringifiedError =
-      typeof outgoingResponse.err === 'object'
-        ? JSON.stringify(outgoingResponse.err)
-        : outgoingResponse.err;
-    outgoingMessage.headers[KafkaHeaders.NEST_ERR] =
-      Buffer.from(stringifiedError);
+    outgoingMessage.headers[KafkaHeaders.NEST_ERR] = Buffer.from(
+      outgoingResponse.err,
+    );
   }
 
   public assignCorrelationIdHeader(
@@ -289,27 +251,8 @@ export class ServerKafka extends Server implements CustomTransportStrategy {
     outgoingMessage.partition = parseFloat(replyPartition);
   }
 
-  public async handleEvent(
-    pattern: string,
-    packet: ReadPacket,
-    context: KafkaContext,
-  ): Promise<any> {
-    const handler = this.getHandlerByPattern(pattern);
-    if (!handler) {
-      return this.logger.error(NO_EVENT_HANDLER`${pattern}`);
-    }
-    const resultOrStream = await handler(packet.data, context);
-    if (isObservable(resultOrStream)) {
-      await lastValueFrom(resultOrStream);
-    }
-  }
-
   protected initializeSerializer(options: KafkaOptions['options']) {
     this.serializer =
       (options && options.serializer) || new KafkaRequestSerializer();
   }
-
-  protected initializeDeserializer(options: KafkaOptions['options']) {
-    this.deserializer = options?.deserializer ?? new KafkaRequestDeserializer();
-  }
 }
diff --git a/packages/microservices/server/server.ts b/packages/microservices/server/server.ts
index 4e8ee9bf6..b36bcfa3a 100644
--- a/packages/microservices/server/server.ts
+++ b/packages/microservices/server/server.ts
@@ -111,7 +111,9 @@ export abstract class Server {
   ): Promise<any> {
     const handler = this.getHandlerByPattern(pattern);
     if (!handler) {
-      return this.logger.error(NO_EVENT_HANDLER`${pattern}`);
+      return this.logger.error(
+        `${NO_EVENT_HANDLER} Event pattern: ${JSON.stringify(pattern)}.`,
+      );
     }
     const resultOrStream = await handler(packet.data, context);
     if (isObservable(resultOrStream)) {
diff --git a/packages/microservices/test/ctx-host/kafka.context.spec.ts b/packages/microservices/test/ctx-host/kafka.context.spec.ts
index 5f350a635..9c0c1b312 100644
--- a/packages/microservices/test/ctx-host/kafka.context.spec.ts
+++ b/packages/microservices/test/ctx-host/kafka.context.spec.ts
@@ -1,15 +1,13 @@
 import { expect } from 'chai';
 import { KafkaContext } from '../../ctx-host';
-import { Consumer, KafkaMessage } from '../../external/kafka.interface';
+import { KafkaMessage } from '../../external/kafka.interface';
 
 describe('KafkaContext', () => {
-  const args = ['test', { test: true }, undefined, { test: 'consumer' }];
+  const args = ['test', { test: true }];
   let context: KafkaContext;
 
   beforeEach(() => {
-    context = new KafkaContext(
-      args as [KafkaMessage, number, string, Consumer],
-    );
+    context = new KafkaContext(args as [KafkaMessage, number, string]);
   });
   describe('getTopic', () => {
     it('should return topic', () => {
@@ -26,9 +24,4 @@ describe('KafkaContext', () => {
       expect(context.getMessage()).to.be.eql(args[0]);
     });
   });
-  describe('getConsumer', () => {
-    it('should return consumer instance', () => {
-      expect(context.getConsumer()).to.deep.eq({ test: 'consumer' });
-    });
-  });
 });
diff --git a/packages/microservices/test/decorators/event-pattern.decorator.spec.ts b/packages/microservices/test/decorators/event-pattern.decorator.spec.ts
index edd238d0a..dbfb07696 100644
--- a/packages/microservices/test/decorators/event-pattern.decorator.spec.ts
+++ b/packages/microservices/test/decorators/event-pattern.decorator.spec.ts
@@ -9,14 +9,24 @@ import { EventPattern } from '../../decorators/event-pattern.decorator';
 
 describe('@EventPattern', () => {
   const pattern = { role: 'test' };
+  const patternSecond = { role: 'test2' };
+  const patternThird = { role: 'test3' };
   const extras = { param: 'value' };
   class TestComponent {
     @EventPattern(pattern, undefined, extras)
     public static test() {}
+
+    @EventPattern(patternSecond, undefined, extras)
+    @EventPattern(patternThird, undefined, extras)
+    public static testOnlyThird() {}
+
+    @EventPattern([patternSecond, patternThird], undefined, extras)
+    public static testBoth() {}
   }
   it(`should enhance method with ${PATTERN_METADATA} metadata`, () => {
     const metadata = Reflect.getMetadata(PATTERN_METADATA, TestComponent.test);
-    expect(metadata).to.be.eql(pattern);
+    expect(metadata.length).to.equal(1);
+    expect(metadata[0]).to.be.eql(pattern);
   });
   it(`should enhance method with ${PATTERN_EXTRAS_METADATA} metadata`, () => {
     const metadata = Reflect.getMetadata(
@@ -25,6 +35,23 @@ describe('@EventPattern', () => {
     );
     expect(metadata).to.be.deep.equal(extras);
   });
+  it(`should enhance method with last ${PATTERN_METADATA} metadata`, () => {
+    const metadata = Reflect.getMetadata(
+      PATTERN_METADATA,
+      TestComponent.testOnlyThird,
+    );
+    expect(metadata.length).to.equal(1);
+    expect(metadata[0]).to.be.eql(patternSecond);
+  });
+  it(`should enhance method with both ${PATTERN_METADATA} metadata`, () => {
+    const metadata = Reflect.getMetadata(
+      PATTERN_METADATA,
+      TestComponent.testBoth,
+    );
+    expect(metadata.length).to.equal(2);
+    expect(metadata[0]).to.be.eql(patternSecond);
+    expect(metadata[1]).to.be.eql(patternThird);
+  });
 
   describe('decorator overloads', () => {
     class TestComponent1 {
@@ -45,7 +72,7 @@ describe('@EventPattern', () => {
     }
 
     it(`should enhance method with ${PATTERN_METADATA} metadata`, () => {
-      const metadataArg = Reflect.getMetadata(
+      const [metadataArg] = Reflect.getMetadata(
         PATTERN_METADATA,
         TestComponent1.test,
       );
@@ -63,7 +90,7 @@ describe('@EventPattern', () => {
     });
 
     it(`should enhance method with ${PATTERN_METADATA}, ${TRANSPORT_METADATA} metadata`, () => {
-      const metadataArg = Reflect.getMetadata(
+      const [metadataArg] = Reflect.getMetadata(
         PATTERN_METADATA,
         TestComponent2.test,
       );
@@ -81,7 +108,7 @@ describe('@EventPattern', () => {
     });
 
     it(`should enhance method with ${PATTERN_METADATA}, ${PATTERN_EXTRAS_METADATA} metadata`, () => {
-      const metadataArg = Reflect.getMetadata(
+      const [metadataArg] = Reflect.getMetadata(
         PATTERN_METADATA,
         TestComponent3.test,
       );
@@ -100,7 +127,7 @@ describe('@EventPattern', () => {
 
     it(`should enhance method with ${PATTERN_METADATA}, ${TRANSPORT_METADATA} and \
 ${PATTERN_EXTRAS_METADATA} metadata`, () => {
-      const metadataArg = Reflect.getMetadata(
+      const [metadataArg] = Reflect.getMetadata(
         PATTERN_METADATA,
         TestComponent4.test,
       );
diff --git a/packages/microservices/test/decorators/message-pattern.decorator.spec.ts b/packages/microservices/test/decorators/message-pattern.decorator.spec.ts
index 5edabc211..d8b62d2f5 100644
--- a/packages/microservices/test/decorators/message-pattern.decorator.spec.ts
+++ b/packages/microservices/test/decorators/message-pattern.decorator.spec.ts
@@ -21,7 +21,10 @@ describe('@MessagePattern', () => {
     public static test() {}
   }
   it(`should enhance method with ${PATTERN_METADATA} metadata`, () => {
-    const metadata = Reflect.getMetadata(PATTERN_METADATA, TestComponent.test);
+    const [metadata] = Reflect.getMetadata(
+      PATTERN_METADATA,
+      TestComponent.test,
+    );
     expect(metadata).to.be.eql(pattern);
   });
   it(`should enhance method with ${PATTERN_EXTRAS_METADATA} metadata`, () => {
@@ -51,7 +54,7 @@ describe('@MessagePattern', () => {
     }
 
     it(`should enhance method with ${PATTERN_METADATA} metadata`, () => {
-      const metadataArg = Reflect.getMetadata(
+      const [metadataArg] = Reflect.getMetadata(
         PATTERN_METADATA,
         TestComponent1.test,
       );
@@ -69,7 +72,7 @@ describe('@MessagePattern', () => {
     });
 
     it(`should enhance method with ${PATTERN_METADATA}, ${TRANSPORT_METADATA} metadata`, () => {
-      const metadataArg = Reflect.getMetadata(
+      const [metadataArg] = Reflect.getMetadata(
         PATTERN_METADATA,
         TestComponent2.test,
       );
@@ -87,7 +90,7 @@ describe('@MessagePattern', () => {
     });
 
     it(`should enhance method with ${PATTERN_METADATA}, ${PATTERN_EXTRAS_METADATA} metadata`, () => {
-      const metadataArg = Reflect.getMetadata(
+      const [metadataArg] = Reflect.getMetadata(
         PATTERN_METADATA,
         TestComponent3.test,
       );
@@ -106,7 +109,7 @@ describe('@MessagePattern', () => {
 
     it(`should enhance method with ${PATTERN_METADATA}, ${TRANSPORT_METADATA} and \
 ${PATTERN_EXTRAS_METADATA} metadata`, () => {
-      const metadataArg = Reflect.getMetadata(
+      const [metadataArg] = Reflect.getMetadata(
         PATTERN_METADATA,
         TestComponent4.test,
       );
@@ -139,7 +142,7 @@ describe('@GrpcMethod', () => {
 
   it('should derive method and service name', () => {
     const svc = new TestService();
-    const metadata = Reflect.getMetadata(PATTERN_METADATA, svc.test);
+    const [metadata] = Reflect.getMetadata(PATTERN_METADATA, svc.test);
     expect(metadata).to.be.eql({
       service: TestService.name,
       rpc: 'Test',
@@ -149,7 +152,7 @@ describe('@GrpcMethod', () => {
 
   it('should derive method', () => {
     const svc = new TestService();
-    const metadata = Reflect.getMetadata(PATTERN_METADATA, svc.test2);
+    const [metadata] = Reflect.getMetadata(PATTERN_METADATA, svc.test2);
     expect(metadata).to.be.eql({
       service: 'TestService2',
       rpc: 'Test2',
@@ -159,7 +162,7 @@ describe('@GrpcMethod', () => {
 
   it('should override both method and service', () => {
     const svc = new TestService();
-    const metadata = Reflect.getMetadata(PATTERN_METADATA, svc.test3);
+    const [metadata] = Reflect.getMetadata(PATTERN_METADATA, svc.test3);
     expect(metadata).to.be.eql({
       service: 'TestService2',
       rpc: 'Test2',
@@ -182,7 +185,7 @@ describe('@GrpcStreamMethod', () => {
 
   it('should derive method and service name', () => {
     const svc = new TestService();
-    const metadata = Reflect.getMetadata(PATTERN_METADATA, svc.test);
+    const [metadata] = Reflect.getMetadata(PATTERN_METADATA, svc.test);
     expect(metadata).to.be.eql({
       service: TestService.name,
       rpc: 'Test',
@@ -192,7 +195,7 @@ describe('@GrpcStreamMethod', () => {
 
   it('should derive method', () => {
     const svc = new TestService();
-    const metadata = Reflect.getMetadata(PATTERN_METADATA, svc.test2);
+    const [metadata] = Reflect.getMetadata(PATTERN_METADATA, svc.test2);
     expect(metadata).to.be.eql({
       service: 'TestService2',
       rpc: 'Test2',
@@ -202,7 +205,7 @@ describe('@GrpcStreamMethod', () => {
 
   it('should override both method and service', () => {
     const svc = new TestService();
-    const metadata = Reflect.getMetadata(PATTERN_METADATA, svc.test3);
+    const [metadata] = Reflect.getMetadata(PATTERN_METADATA, svc.test3);
     expect(metadata).to.be.eql({
       service: 'TestService2',
       rpc: 'Test2',
@@ -225,7 +228,7 @@ describe('@GrpcStreamCall', () => {
 
   it('should derive method and service name', () => {
     const svc = new TestService();
-    const metadata = Reflect.getMetadata(PATTERN_METADATA, svc.test);
+    const [metadata] = Reflect.getMetadata(PATTERN_METADATA, svc.test);
     expect(metadata).to.be.eql({
       service: TestService.name,
       rpc: 'Test',
@@ -235,7 +238,7 @@ describe('@GrpcStreamCall', () => {
 
   it('should derive method', () => {
     const svc = new TestService();
-    const metadata = Reflect.getMetadata(PATTERN_METADATA, svc.test2);
+    const [metadata] = Reflect.getMetadata(PATTERN_METADATA, svc.test2);
     expect(metadata).to.be.eql({
       service: 'TestService2',
       rpc: 'Test2',
@@ -245,7 +248,7 @@ describe('@GrpcStreamCall', () => {
 
   it('should override both method and service', () => {
     const svc = new TestService();
-    const metadata = Reflect.getMetadata(PATTERN_METADATA, svc.test3);
+    const [metadata] = Reflect.getMetadata(PATTERN_METADATA, svc.test3);
     expect(metadata).to.be.eql({
       service: 'TestService2',
       rpc: 'Test2',
diff --git a/packages/microservices/test/listeners-controller.spec.ts b/packages/microservices/test/listeners-controller.spec.ts
index b23b13c16..af02d8161 100644
--- a/packages/microservices/test/listeners-controller.spec.ts
+++ b/packages/microservices/test/listeners-controller.spec.ts
@@ -74,8 +74,8 @@ describe('ListenersController', () => {
 
   describe('registerPatternHandlers', () => {
     const handlers = [
-      { pattern: 'test', targetCallback: 'tt' },
-      { pattern: 'test2', targetCallback: '2', isEventHandler: true },
+      { patterns: ['test'], targetCallback: 'tt' },
+      { patterns: ['test2'], targetCallback: '2', isEventHandler: true },
     ];
 
     beforeEach(() => {
@@ -89,7 +89,7 @@ describe('ListenersController', () => {
     it(`should call "addHandler" method of server for each pattern handler with same transport`, () => {
       const serverHandlers = [
         {
-          pattern: { cmd: 'test' },
+          patterns: [{ cmd: 'test' }],
           targetCallback: 'tt',
           transport: Transport.TCP,
         },
@@ -101,8 +101,12 @@ describe('ListenersController', () => {
     });
     it(`should call "addHandler" method of server without transportID for each pattern handler with any transport value`, () => {
       const serverHandlers = [
-        { pattern: { cmd: 'test' }, targetCallback: 'tt' },
-        { pattern: 'test2', targetCallback: '2', transport: Transport.KAFKA },
+        { patterns: [{ cmd: 'test' }], targetCallback: 'tt' },
+        {
+          patterns: ['test2'],
+          targetCallback: '2',
+          transport: Transport.KAFKA,
+        },
       ];
       explorer.expects('explore').returns(serverHandlers);
       instance.registerPatternHandlers(new InstanceWrapper(), server, '');
@@ -110,10 +114,14 @@ describe('ListenersController', () => {
     });
     it(`should call "addHandler" method of server with transportID for each pattern handler with self transport and without transport`, () => {
       const serverHandlers = [
-        { pattern: 'test', targetCallback: 'tt' },
-        { pattern: 'test2', targetCallback: '2', transport: Transport.KAFKA },
+        { patterns: ['test'], targetCallback: 'tt' },
         {
-          pattern: { cmd: 'test3' },
+          patterns: ['test2'],
+          targetCallback: '2',
+          transport: Transport.KAFKA,
+        },
+        {
+          patterns: [{ cmd: 'test3' }],
           targetCallback: '3',
           transport: Transport.TCP,
         },
@@ -143,7 +151,11 @@ describe('ListenersController', () => {
     });
     it(`should call "addHandler" method of server with extras data`, () => {
       const serverHandlers = [
-        { pattern: 'test', targetCallback: 'tt', extras: { param: 'value' } },
+        {
+          patterns: ['test'],
+          targetCallback: 'tt',
+          extras: { param: 'value' },
+        },
       ];
       explorer.expects('explore').returns(serverHandlers);
       instance.registerPatternHandlers(new InstanceWrapper(), serverTCP, '');
@@ -193,7 +205,7 @@ describe('ListenersController', () => {
       const module = {
         controllers: new Map(),
       } as any;
-      const pattern = {};
+      const patterns = [{}];
       const wrapper = new InstanceWrapper({ instance: { [methodKey]: {} } });
 
       it('should pass all arguments to the proxy chain', async () => {
@@ -202,7 +214,7 @@ describe('ListenersController', () => {
           .callsFake(() => Promise.resolve({}));
         const handler = instance.createRequestScopedHandler(
           wrapper,
-          pattern,
+          patterns,
           module,
           moduleKey,
           methodKey,
@@ -221,7 +233,7 @@ describe('ListenersController', () => {
       const module = {
         controllers: new Map(),
       } as any;
-      const pattern = {};
+      const patterns = [{}];
       const wrapper = new InstanceWrapper({ instance: { [methodKey]: {} } });
 
       it('should delegete error to exception filters', async () => {
@@ -230,7 +242,7 @@ describe('ListenersController', () => {
         });
         const handler = instance.createRequestScopedHandler(
           wrapper,
-          pattern,
+          patterns,
           module,
           moduleKey,
           methodKey,
diff --git a/packages/microservices/test/listeners-metadata-explorer.spec.ts b/packages/microservices/test/listeners-metadata-explorer.spec.ts
index 985365f9a..2bb04a763 100644
--- a/packages/microservices/test/listeners-metadata-explorer.spec.ts
+++ b/packages/microservices/test/listeners-metadata-explorer.spec.ts
@@ -2,15 +2,20 @@ import { expect } from 'chai';
 import * as sinon from 'sinon';
 import { MetadataScanner } from '../../core/metadata-scanner';
 import { Client } from '../decorators/client.decorator';
+import { EventPattern } from '../decorators/event-pattern.decorator';
 import { MessagePattern } from '../decorators/message-pattern.decorator';
 import { Transport } from '../enums/transport.enum';
 import { ListenerMetadataExplorer } from '../listener-metadata-explorer';
 
 describe('ListenerMetadataExplorer', () => {
-  const pattern = { pattern: 'test' };
-  const secPattern = { role: '2', cmd: 'm' };
+  const msgPattern = { pattern: 'testMsg' };
+  const firstMultipleMsgPattern = { pattern: 'testMultipleMsg1' };
+  const secondMultipleMsgPattern = { pattern: 'testMultipleMsg2' };
   const clientMetadata = {};
   const clientSecMetadata = { transport: Transport.REDIS };
+  const evtPattern = { role: 'testEvt' };
+  const firstMultipleEvtPattern = { role: 'testMultipleEvt1' };
+  const secondMultipleEvtPattern = { role: 'testMultipleEvt2' };
 
   class Test {
     @Client(clientMetadata as any)
@@ -25,11 +30,17 @@ describe('ListenerMetadataExplorer', () => {
 
     constructor() {}
 
-    @MessagePattern(pattern)
-    public test() {}
+    @MessagePattern(msgPattern)
+    public testMessage() {}
 
-    @MessagePattern(secPattern)
-    public testSec() {}
+    @MessagePattern([firstMultipleMsgPattern, secondMultipleMsgPattern])
+    public testMultipleMessage() {}
+
+    @EventPattern(evtPattern)
+    public testEvent() {}
+
+    @EventPattern([firstMultipleEvtPattern, secondMultipleEvtPattern])
+    public testMultipleEvent() {}
 
     public noPattern() {}
   }
@@ -66,20 +77,77 @@ describe('ListenerMetadataExplorer', () => {
       );
       expect(metadata).to.eq(undefined);
     });
-    it(`should return pattern properties when "handlerType" metadata is not undefined`, () => {
-      const metadata = instance.exploreMethodMetadata(
-        Object.getPrototypeOf(test),
-        'test',
-      );
-      expect(metadata).to.have.keys([
-        'isEventHandler',
-        'methodKey',
-        'targetCallback',
-        'pattern',
-        'transport',
-        'extras',
-      ]);
-      expect(metadata.pattern).to.eql(pattern);
+
+    describe('@MessagePattern', () => {
+      it(`should return pattern properties when "handlerType" metadata is not undefined`, () => {
+        const metadata = instance.exploreMethodMetadata(
+          Object.getPrototypeOf(test),
+          'testMessage',
+        );
+        expect(metadata).to.have.keys([
+          'isEventHandler',
+          'methodKey',
+          'targetCallback',
+          'patterns',
+          'transport',
+          'extras',
+        ]);
+        expect(metadata.patterns.length).to.eql(1);
+        expect(metadata.patterns[0]).to.eql(msgPattern);
+      });
+      it(`should return multiple patterns when more than one is declared`, () => {
+        const metadata = instance.exploreMethodMetadata(
+          Object.getPrototypeOf(test),
+          'testMultipleMessage',
+        );
+        expect(metadata).to.have.keys([
+          'isEventHandler',
+          'methodKey',
+          'targetCallback',
+          'patterns',
+          'transport',
+          'extras',
+        ]);
+        expect(metadata.patterns.length).to.eql(2);
+        expect(metadata.patterns[0]).to.eql(firstMultipleMsgPattern);
+        expect(metadata.patterns[1]).to.eql(secondMultipleMsgPattern);
+      });
+    });
+
+    describe('@EventPattern', () => {
+      it(`should return pattern properties when "handlerType" metadata is not undefined`, () => {
+        const metadata = instance.exploreMethodMetadata(
+          Object.getPrototypeOf(test),
+          'testEvent',
+        );
+        expect(metadata).to.have.keys([
+          'isEventHandler',
+          'methodKey',
+          'targetCallback',
+          'patterns',
+          'transport',
+          'extras',
+        ]);
+        expect(metadata.patterns.length).to.eql(1);
+        expect(metadata.patterns[0]).to.eql(evtPattern);
+      });
+      it(`should return multiple patterns when more than one is declared`, () => {
+        const metadata = instance.exploreMethodMetadata(
+          Object.getPrototypeOf(test),
+          'testMultipleEvent',
+        );
+        expect(metadata).to.have.keys([
+          'isEventHandler',
+          'methodKey',
+          'targetCallback',
+          'patterns',
+          'transport',
+          'extras',
+        ]);
+        expect(metadata.patterns.length).to.eql(2);
+        expect(metadata.patterns[0]).to.eql(firstMultipleEvtPattern);
+        expect(metadata.patterns[1]).to.eql(secondMultipleEvtPattern);
+      });
     });
   });
   describe('scanForClientHooks', () => {
diff --git a/packages/microservices/test/server/server-kafka.spec.ts b/packages/microservices/test/server/server-kafka.spec.ts
index da129d56d..f4ab1eab0 100644
--- a/packages/microservices/test/server/server-kafka.spec.ts
+++ b/packages/microservices/test/server/server-kafka.spec.ts
@@ -1,5 +1,5 @@
 import { Logger } from '@nestjs/common';
-import { AssertionError, expect } from 'chai';
+import { expect } from 'chai';
 import * as sinon from 'sinon';
 import { NO_MESSAGE_HANDLER } from '../../constants';
 import { KafkaHeaders } from '../../enums';
@@ -277,7 +277,6 @@ describe('ServerKafka', () => {
 
       sinon.stub(server, 'getPublisher').callsFake(() => getPublisherSpy);
     });
-
     it('should call "handleEvent" if correlation identifier is not present', async () => {
       const handleEventSpy = sinon.spy(server, 'handleEvent');
       await server.handleMessage(eventPayload);
@@ -290,42 +289,6 @@ describe('ServerKafka', () => {
       expect(handleEventSpy.called).to.be.true;
     });
 
-    it('should call event handler when "handleEvent" is called', async () => {
-      const messageHandler = sinon.mock();
-      const context = { test: true } as any;
-      const messageData = 'some data';
-      sinon.stub(server, 'getHandlerByPattern').callsFake(() => messageHandler);
-
-      await server.handleEvent(
-        topic,
-        { data: messageData, pattern: topic },
-        context,
-      );
-      expect(messageHandler.calledWith(messageData, context)).to.be.true;
-    });
-
-    it('should not catch error thrown by event handler as part of "handleEvent"', async () => {
-      const error = new Error('handler error');
-      const messageHandler = sinon.mock().throwsException(error);
-      sinon.stub(server, 'getHandlerByPattern').callsFake(() => messageHandler);
-
-      try {
-        await server.handleEvent(
-          topic,
-          { data: 'some data', pattern: topic },
-          {} as any,
-        );
-
-        // code should not be executed
-        expect(true).to.be.false;
-      } catch (e) {
-        if (e instanceof AssertionError) {
-          throw e;
-        }
-        expect(e).to.be.eq(error);
-      }
-    });
-
     it('should call "handleEvent" if correlation identifier and reply topic are present but the handler is of type eventHandler', async () => {
       const handler = sinon.spy();
       (handler as any).isEventHandler = true;
@@ -357,7 +320,6 @@ describe('ServerKafka', () => {
         }),
       ).to.be.true;
     });
-
     it(`should call handler with expected arguments`, async () => {
       const handler = sinon.spy();
       (server as any).messageHandlers = objectToMap({
diff --git a/packages/platform-express/adapters/express-adapter.ts b/packages/platform-express/adapters/express-adapter.ts
index 7a832e0ff..b8dcf9340 100644
--- a/packages/platform-express/adapters/express-adapter.ts
+++ b/packages/platform-express/adapters/express-adapter.ts
@@ -19,6 +19,7 @@ import {
   isNil,
   isObject,
   isString,
+  isUndefined,
 } from '@nestjs/common/utils/shared.utils';
 import { AbstractHttpAdapter } from '@nestjs/core/adapters/http-adapter';
 import { RouterMethodFactory } from '@nestjs/core/helpers/router-method-factory';
@@ -256,9 +257,16 @@ export class ExpressAdapter extends AbstractHttpAdapter {
 
         const acceptHeaderVersionParameter = acceptHeaderValue
           ? acceptHeaderValue.split(';')[1]
-          : '';
+          : undefined;
 
-        if (acceptHeaderVersionParameter) {
+        // No version was supplied
+        if (isUndefined(acceptHeaderVersionParameter)) {
+          if (Array.isArray(version)) {
+            if (version.includes(VERSION_NEUTRAL)) {
+              return handler(req, res, next);
+            }
+          }
+        } else {
           const headerVersion = acceptHeaderVersionParameter.split(
             versioningOptions.key,
           )[1];
@@ -280,7 +288,14 @@ export class ExpressAdapter extends AbstractHttpAdapter {
           req.headers?.[versioningOptions.header] ||
           req.headers?.[versioningOptions.header.toLowerCase()];
 
-        if (customHeaderVersionParameter) {
+        // No version was supplied
+        if (isUndefined(customHeaderVersionParameter)) {
+          if (Array.isArray(version)) {
+            if (version.includes(VERSION_NEUTRAL)) {
+              return handler(req, res, next);
+            }
+          }
+        } else {
           if (Array.isArray(version)) {
             if (version.includes(customHeaderVersionParameter)) {
               return handler(req, res, next);
diff --git a/packages/platform-fastify/adapters/fastify-adapter.ts b/packages/platform-fastify/adapters/fastify-adapter.ts
index fe668b1c3..ebf64274e 100644
--- a/packages/platform-fastify/adapters/fastify-adapter.ts
+++ b/packages/platform-fastify/adapters/fastify-adapter.ts
@@ -154,12 +154,9 @@ export class FastifyAdapter<
           ? acceptHeaderValue.split(';')[1]
           : '';
 
-        if (acceptHeaderVersionParameter) {
-          const headerVersion = acceptHeaderVersionParameter.split(
-            this.versioningOptions.key,
-          )[1];
-          return headerVersion;
-        }
+        return isUndefined(acceptHeaderVersionParameter)
+          ? VERSION_NEUTRAL // No version was supplied
+          : acceptHeaderVersionParameter.split(this.versioningOptions.key)[1];
       }
       // Header Versioning Handler
       else if (this.versioningOptions.type === VersioningType.HEADER) {
@@ -167,9 +164,9 @@ export class FastifyAdapter<
           req.headers?.[this.versioningOptions.header] ||
           req.headers?.[this.versioningOptions.header.toLowerCase()];
 
-        if (customHeaderVersionParameter) {
-          return customHeaderVersionParameter;
-        }
+        return isUndefined(customHeaderVersionParameter)
+          ? VERSION_NEUTRAL // No version was supplied
+          : customHeaderVersionParameter;
       }
       // Custom Versioning Handler
       else if (this.versioningOptions.type === VersioningType.CUSTOM) {
diff --git a/packages/websockets/test/web-sockets-controller.spec.ts b/packages/websockets/test/web-sockets-controller.spec.ts
index 68503abb0..659afff09 100644
--- a/packages/websockets/test/web-sockets-controller.spec.ts
+++ b/packages/websockets/test/web-sockets-controller.spec.ts
@@ -345,7 +345,7 @@ describe('WebSocketsController', () => {
                 Promise.resolve(Promise.resolve(value)),
               ),
             ),
-          ).to.be.eq(100);
+          ).to.be.eq(value);
         });
       });
 
@@ -356,18 +356,29 @@ describe('WebSocketsController', () => {
             await lastValueFrom(
               await instance.pickResult(Promise.resolve(of(value))),
             ),
-          ).to.be.eq(100);
+          ).to.be.eq(value);
         });
       });
 
-      describe('is a value', () => {
+      describe('is an object that has the method `subscribe`', () => {
+        it('should return Promise<Observable>', async () => {
+          const value = { subscribe() {} };
+          expect(
+            await lastValueFrom(
+              await instance.pickResult(Promise.resolve(value)),
+            ),
+          ).to.equal(value);
+        });
+      });
+
+      describe('is an ordinary value', () => {
         it('should return Promise<Observable>', async () => {
           const value = 100;
           expect(
             await lastValueFrom(
               await instance.pickResult(Promise.resolve(value)),
             ),
-          ).to.be.eq(100);
+          ).to.be.eq(value);
         });
       });
     });
diff --git a/packages/websockets/web-sockets-controller.ts b/packages/websockets/web-sockets-controller.ts
index 75e790c82..d01811e17 100644
--- a/packages/websockets/web-sockets-controller.ts
+++ b/packages/websockets/web-sockets-controller.ts
@@ -1,9 +1,14 @@
 import { Type } from '@nestjs/common/interfaces/type.interface';
 import { Logger } from '@nestjs/common/services/logger.service';
-import { isFunction } from '@nestjs/common/utils/shared.utils';
 import { ApplicationConfig } from '@nestjs/core/application-config';
 import { MetadataScanner } from '@nestjs/core/metadata-scanner';
-import { from as fromPromise, Observable, of, Subject } from 'rxjs';
+import {
+  from as fromPromise,
+  Observable,
+  isObservable,
+  of,
+  Subject,
+} from 'rxjs';
 import { distinctUntilChanged, mergeAll } from 'rxjs/operators';
 import { GATEWAY_OPTIONS, PORT_METADATA } from './constants';
 import { WsContextCreator } from './context/ws-context-creator';
@@ -158,7 +163,7 @@ export class WebSocketsController {
     deferredResult: Promise<any>,
   ): Promise<Observable<any>> {
     const result = await deferredResult;
-    if (result && isFunction(result.subscribe)) {
+    if (isObservable(result)) {
       return result;
     }
     if (result instanceof Promise) {
