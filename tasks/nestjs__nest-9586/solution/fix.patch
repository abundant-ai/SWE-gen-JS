diff --git a/integration/module-utils/src/integration.module-definition.ts b/integration/module-utils/src/integration.module-definition.ts
deleted file mode 100644
index 89d7a9842..000000000
--- a/integration/module-utils/src/integration.module-definition.ts
+++ /dev/null
@@ -1,17 +0,0 @@
-import { ConfigurableModuleBuilder } from '@nestjs/common';
-import { IntegrationModuleOptions } from './interfaces/integration-module-options.interface';
-
-export const { ConfigurableModuleClass, MODULE_OPTIONS_TOKEN } =
-  new ConfigurableModuleBuilder<IntegrationModuleOptions>()
-    .setClassMethodName('forRoot')
-    .setFactoryMethodName('construct')
-    .setExtras(
-      {
-        isGlobal: true,
-      },
-      (definition, extras) => ({
-        ...definition,
-        global: extras.isGlobal,
-      }),
-    )
-    .build();
diff --git a/integration/module-utils/src/integration.module.ts b/integration/module-utils/src/integration.module.ts
deleted file mode 100644
index 3b994f4bd..000000000
--- a/integration/module-utils/src/integration.module.ts
+++ /dev/null
@@ -1,16 +0,0 @@
-import { Inject, Module } from '@nestjs/common';
-import {
-  ConfigurableModuleClass,
-  MODULE_OPTIONS_TOKEN,
-} from './integration.module-definition';
-import { IntegrationModuleOptions } from './interfaces/integration-module-options.interface';
-
-@Module({})
-export class IntegrationModule extends ConfigurableModuleClass {
-  constructor(
-    @Inject(MODULE_OPTIONS_TOKEN)
-    public readonly options: IntegrationModuleOptions,
-  ) {
-    super();
-  }
-}
diff --git a/integration/module-utils/src/interfaces/integration-module-options.interface.ts b/integration/module-utils/src/interfaces/integration-module-options.interface.ts
deleted file mode 100644
index 802e02076..000000000
--- a/integration/module-utils/src/interfaces/integration-module-options.interface.ts
+++ /dev/null
@@ -1,4 +0,0 @@
-export interface IntegrationModuleOptions {
-  url: string;
-  secure?: boolean;
-}
diff --git a/integration/module-utils/tsconfig.json b/integration/module-utils/tsconfig.json
deleted file mode 100644
index c6354c564..000000000
--- a/integration/module-utils/tsconfig.json
+++ /dev/null
@@ -1,22 +0,0 @@
-{
-  "compilerOptions": {
-    "module": "commonjs",
-    "declaration": false,
-    "noImplicitAny": false,
-    "removeComments": true,
-    "noLib": false,
-    "emitDecoratorMetadata": true,
-    "experimentalDecorators": true,
-    "target": "es6",
-    "sourceMap": true,
-    "allowJs": true,
-    "outDir": "./dist"
-  },
-  "include": [
-    "src/**/*",
-    "e2e/**/*"
-  ],
-  "exclude": [
-    "node_modules",
-  ]
-}
\ No newline at end of file
diff --git a/package-lock.json b/package-lock.json
index b0ea489df..4f7c42bb1 100644
Binary files a/package-lock.json and b/package-lock.json differ
diff --git a/packages/common/cache/cache.constants.ts b/packages/common/cache/cache.constants.ts
index 799547a7b..0ecf5c94e 100644
--- a/packages/common/cache/cache.constants.ts
+++ b/packages/common/cache/cache.constants.ts
@@ -1,3 +1,4 @@
 export const CACHE_MANAGER = 'CACHE_MANAGER';
+export const CACHE_MODULE_OPTIONS = 'CACHE_MODULE_OPTIONS';
 export const CACHE_KEY_METADATA = 'cache_module:cache_key';
 export const CACHE_TTL_METADATA = 'cache_module:cache_ttl';
diff --git a/packages/common/cache/cache.module-definition.ts b/packages/common/cache/cache.module-definition.ts
deleted file mode 100644
index 25d74e986..000000000
--- a/packages/common/cache/cache.module-definition.ts
+++ /dev/null
@@ -1,12 +0,0 @@
-import { ConfigurableModuleBuilder } from '../module-utils';
-import {
-  CacheModuleOptions,
-  CacheOptionsFactory,
-} from './interfaces/cache-module.interface';
-
-export const { ConfigurableModuleClass, MODULE_OPTIONS_TOKEN } =
-  new ConfigurableModuleBuilder<CacheModuleOptions>({
-    moduleName: 'Cache',
-  })
-    .setFactoryMethodName('createCacheOptions' as keyof CacheOptionsFactory)
-    .build();
diff --git a/packages/common/cache/cache.module.ts b/packages/common/cache/cache.module.ts
index 992f98f03..4e2c63d48 100644
--- a/packages/common/cache/cache.module.ts
+++ b/packages/common/cache/cache.module.ts
@@ -1,11 +1,11 @@
 import { Module } from '../decorators';
-import { DynamicModule } from '../interfaces';
-import { CACHE_MANAGER } from './cache.constants';
-import { ConfigurableModuleClass } from './cache.module-definition';
+import { DynamicModule, Provider } from '../interfaces';
+import { CACHE_MANAGER, CACHE_MODULE_OPTIONS } from './cache.constants';
 import { createCacheManager } from './cache.providers';
 import {
   CacheModuleAsyncOptions,
   CacheModuleOptions,
+  CacheOptionsFactory,
 } from './interfaces/cache-module.interface';
 
 /**
@@ -19,7 +19,7 @@ import {
   providers: [createCacheManager()],
   exports: [CACHE_MANAGER],
 })
-export class CacheModule extends ConfigurableModuleClass {
+export class CacheModule {
   /**
    * Configure the cache manager statically.
    *
@@ -31,8 +31,9 @@ export class CacheModule extends ConfigurableModuleClass {
     options: CacheModuleOptions<StoreConfig> = {} as any,
   ): DynamicModule {
     return {
+      module: CacheModule,
       global: options.isGlobal,
-      ...super.register(options),
+      providers: [{ provide: CACHE_MODULE_OPTIONS, useValue: options }],
     };
   }
 
@@ -47,11 +48,47 @@ export class CacheModule extends ConfigurableModuleClass {
   static registerAsync<
     StoreConfig extends Record<any, any> = Record<string, any>,
   >(options: CacheModuleAsyncOptions<StoreConfig>): DynamicModule {
-    const moduleDefinition = super.registerAsync(options);
     return {
+      module: CacheModule,
       global: options.isGlobal,
-      ...moduleDefinition,
-      providers: moduleDefinition.providers.concat(options.extraProviders),
+      imports: options.imports,
+      providers: [
+        ...this.createAsyncProviders<StoreConfig>(options),
+        ...(options.extraProviders || []),
+      ],
+    };
+  }
+
+  private static createAsyncProviders<StoreConfig extends Record<any, any>>(
+    options: CacheModuleAsyncOptions<StoreConfig>,
+  ): Provider[] {
+    if (options.useExisting || options.useFactory) {
+      return [this.createAsyncOptionsProvider(options)];
+    }
+    return [
+      this.createAsyncOptionsProvider(options),
+      {
+        provide: options.useClass,
+        useClass: options.useClass,
+      },
+    ];
+  }
+
+  private static createAsyncOptionsProvider<
+    StoreConfig extends Record<any, any>,
+  >(options: CacheModuleAsyncOptions<StoreConfig>): Provider {
+    if (options.useFactory) {
+      return {
+        provide: CACHE_MODULE_OPTIONS,
+        useFactory: options.useFactory,
+        inject: options.inject || [],
+      };
+    }
+    return {
+      provide: CACHE_MODULE_OPTIONS,
+      useFactory: async (optionsFactory: CacheOptionsFactory<StoreConfig>) =>
+        optionsFactory.createCacheOptions(),
+      inject: [options.useExisting || options.useClass],
     };
   }
 }
diff --git a/packages/common/cache/cache.providers.ts b/packages/common/cache/cache.providers.ts
index 4aaacf0f5..2e6df398d 100644
--- a/packages/common/cache/cache.providers.ts
+++ b/packages/common/cache/cache.providers.ts
@@ -1,7 +1,6 @@
 import { Provider } from '../interfaces';
 import { loadPackage } from '../utils/load-package.util';
-import { CACHE_MANAGER } from './cache.constants';
-import { MODULE_OPTIONS_TOKEN } from './cache.module-definition';
+import { CACHE_MANAGER, CACHE_MODULE_OPTIONS } from './cache.constants';
 import { defaultCacheOptions } from './default-options';
 import { CacheManagerOptions } from './interfaces/cache-manager.interface';
 
@@ -32,6 +31,6 @@ export function createCacheManager(): Provider {
             ...(options || {}),
           });
     },
-    inject: [MODULE_OPTIONS_TOKEN],
+    inject: [CACHE_MODULE_OPTIONS],
   };
 }
diff --git a/packages/common/cache/interfaces/cache-module.interface.ts b/packages/common/cache/interfaces/cache-module.interface.ts
index a5fd220cc..5beb769c8 100644
--- a/packages/common/cache/interfaces/cache-module.interface.ts
+++ b/packages/common/cache/interfaces/cache-module.interface.ts
@@ -1,5 +1,4 @@
-import { Provider, Type } from '../../interfaces';
-import { ConfigurableModuleAsyncOptions } from '../../module-utils';
+import { ModuleMetadata, Provider, Type } from '../../interfaces';
 import { CacheManagerOptions } from './cache-manager.interface';
 
 export type CacheModuleOptions<
@@ -40,10 +39,7 @@ export interface CacheOptionsFactory<
  */
 export interface CacheModuleAsyncOptions<
   StoreConfig extends Record<any, any> = Record<string, any>,
-> extends ConfigurableModuleAsyncOptions<
-    CacheModuleOptions<StoreConfig>,
-    keyof CacheOptionsFactory
-  > {
+> extends Pick<ModuleMetadata, 'imports'> {
   /**
    * Injection token resolving to an existing provider. The provider must implement
    * the `CacheOptionsFactory` interface.
@@ -67,9 +63,6 @@ export interface CacheModuleAsyncOptions<
    * Dependencies that a Factory may inject.
    */
   inject?: any[];
-  /**
-   * Extra providers to be registered within a scope of this module.
-   */
   extraProviders?: Provider[];
   /**
    * If "true', register `CacheModule` as a global module.
diff --git a/packages/common/http/http.constants.ts b/packages/common/http/http.constants.ts
index d69880b18..21f6d8499 100644
--- a/packages/common/http/http.constants.ts
+++ b/packages/common/http/http.constants.ts
@@ -1 +1,3 @@
 export const AXIOS_INSTANCE_TOKEN = 'AXIOS_INSTANCE_TOKEN';
+export const HTTP_MODULE_ID = 'HTTP_MODULE_ID';
+export const HTTP_MODULE_OPTIONS = 'HTTP_MODULE_OPTIONS';
diff --git a/packages/common/http/http.module-definition.ts b/packages/common/http/http.module-definition.ts
deleted file mode 100644
index 708d8f701..000000000
--- a/packages/common/http/http.module-definition.ts
+++ /dev/null
@@ -1,23 +0,0 @@
-import { Provider } from '../interfaces';
-import { ConfigurableModuleBuilder } from '../module-utils';
-import { HttpModuleOptions } from './interfaces';
-
-export const {
-  ConfigurableModuleClass,
-  MODULE_OPTIONS_TOKEN,
-  ASYNC_OPTIONS_TYPE,
-} = new ConfigurableModuleBuilder<HttpModuleOptions>({
-  moduleName: 'Http',
-  alwaysTransient: true,
-})
-  .setFactoryMethodName('createHttpOptions')
-  .setExtras<{ extraProviders?: Provider[] }>(
-    {
-      extraProviders: [],
-    },
-    (definition, extras) => ({
-      ...definition,
-      providers: definition.providers.concat(extras?.extraProviders),
-    }),
-  )
-  .build();
diff --git a/packages/common/http/http.module.ts b/packages/common/http/http.module.ts
index a2e46b464..cc0367673 100644
--- a/packages/common/http/http.module.ts
+++ b/packages/common/http/http.module.ts
@@ -1,14 +1,18 @@
 import Axios from 'axios';
 import { Module } from '../decorators/modules/module.decorator';
-import { DynamicModule } from '../interfaces';
-import { AXIOS_INSTANCE_TOKEN } from './http.constants';
+import { DynamicModule, Provider } from '../interfaces';
+import { randomStringGenerator } from '../utils/random-string-generator.util';
 import {
-  ASYNC_OPTIONS_TYPE,
-  ConfigurableModuleClass,
-  MODULE_OPTIONS_TOKEN,
-} from './http.module-definition';
+  AXIOS_INSTANCE_TOKEN,
+  HTTP_MODULE_ID,
+  HTTP_MODULE_OPTIONS,
+} from './http.constants';
 import { HttpService } from './http.service';
-import { HttpModuleOptions } from './interfaces';
+import {
+  HttpModuleAsyncOptions,
+  HttpModuleOptions,
+  HttpModuleOptionsFactory,
+} from './interfaces';
 
 /**
  * @deprecated "HttpModule" (from the "@nestjs/common" package) is deprecated and will be removed in the next major release. Please, use the "@nestjs/axios" package instead.
@@ -23,17 +27,73 @@ import { HttpModuleOptions } from './interfaces';
   ],
   exports: [HttpService],
 })
-export class HttpModule extends ConfigurableModuleClass {
-  static registerAsync(options: typeof ASYNC_OPTIONS_TYPE): DynamicModule {
+export class HttpModule {
+  static register(config: HttpModuleOptions): DynamicModule {
+    return {
+      module: HttpModule,
+      providers: [
+        {
+          provide: AXIOS_INSTANCE_TOKEN,
+          useValue: Axios.create(config),
+        },
+        {
+          provide: HTTP_MODULE_ID,
+          useValue: randomStringGenerator(),
+        },
+      ],
+    };
+  }
+
+  static registerAsync(options: HttpModuleAsyncOptions): DynamicModule {
     return {
-      ...super.registerAsync(options),
+      module: HttpModule,
+      imports: options.imports,
       providers: [
+        ...this.createAsyncProviders(options),
         {
           provide: AXIOS_INSTANCE_TOKEN,
           useFactory: (config: HttpModuleOptions) => Axios.create(config),
-          inject: [MODULE_OPTIONS_TOKEN],
+          inject: [HTTP_MODULE_OPTIONS],
         },
+        {
+          provide: HTTP_MODULE_ID,
+          useValue: randomStringGenerator(),
+        },
+        ...(options.extraProviders || []),
       ],
     };
   }
+
+  private static createAsyncProviders(
+    options: HttpModuleAsyncOptions,
+  ): Provider[] {
+    if (options.useExisting || options.useFactory) {
+      return [this.createAsyncOptionsProvider(options)];
+    }
+    return [
+      this.createAsyncOptionsProvider(options),
+      {
+        provide: options.useClass,
+        useClass: options.useClass,
+      },
+    ];
+  }
+
+  private static createAsyncOptionsProvider(
+    options: HttpModuleAsyncOptions,
+  ): Provider {
+    if (options.useFactory) {
+      return {
+        provide: HTTP_MODULE_OPTIONS,
+        useFactory: options.useFactory,
+        inject: options.inject || [],
+      };
+    }
+    return {
+      provide: HTTP_MODULE_OPTIONS,
+      useFactory: async (optionsFactory: HttpModuleOptionsFactory) =>
+        optionsFactory.createHttpOptions(),
+      inject: [options.useExisting || options.useClass],
+    };
+  }
 }
diff --git a/packages/common/http/interfaces/http-module.interface.ts b/packages/common/http/interfaces/http-module.interface.ts
index 02b147d86..794f9385c 100644
--- a/packages/common/http/interfaces/http-module.interface.ts
+++ b/packages/common/http/interfaces/http-module.interface.ts
@@ -1,3 +1,19 @@
 import { AxiosRequestConfig } from 'axios';
+import { ModuleMetadata, Provider, Type } from '../../interfaces';
 
 export type HttpModuleOptions = AxiosRequestConfig;
+
+export interface HttpModuleOptionsFactory {
+  createHttpOptions(): Promise<HttpModuleOptions> | HttpModuleOptions;
+}
+
+export interface HttpModuleAsyncOptions
+  extends Pick<ModuleMetadata, 'imports'> {
+  useExisting?: Type<HttpModuleOptionsFactory>;
+  useClass?: Type<HttpModuleOptionsFactory>;
+  useFactory?: (
+    ...args: any[]
+  ) => Promise<HttpModuleOptions> | HttpModuleOptions;
+  inject?: any[];
+  extraProviders?: Provider[];
+}
diff --git a/packages/common/index.ts b/packages/common/index.ts
index 350464899..0fe073784 100644
--- a/packages/common/index.ts
+++ b/packages/common/index.ts
@@ -61,7 +61,6 @@ export {
   WsExceptionFilter,
   WsMessageHandler,
 } from './interfaces';
-export * from './module-utils';
 export * from './pipes';
 export * from './serializer';
 export * from './services';
diff --git a/packages/common/interfaces/modules/provider.interface.ts b/packages/common/interfaces/modules/provider.interface.ts
index ba6d86da2..39406c1e2 100644
--- a/packages/common/interfaces/modules/provider.interface.ts
+++ b/packages/common/interfaces/modules/provider.interface.ts
@@ -46,12 +46,6 @@ export interface ClassProvider<T = any> {
    * Optional enum defining lifetime of the provider that is injected.
    */
   scope?: Scope;
-  /**
-   * This option is only available on factory providers!
-   *
-   * @see [Use factory](https://docs.nestjs.com/fundamentals/custom-providers#factory-providers-usefactory)
-   */
-  inject?: never;
 }
 
 /**
@@ -78,12 +72,6 @@ export interface ValueProvider<T = any> {
    * Instance of a provider to be injected.
    */
   useValue: T;
-  /**
-   * This option is only available on factory providers!
-   *
-   * @see [Use factory](https://docs.nestjs.com/fundamentals/custom-providers#factory-providers-usefactory)
-   */
-  inject?: never;
 }
 
 /**
@@ -114,7 +102,7 @@ export interface FactoryProvider<T = any> {
   /**
    * Factory function that returns an instance of the provider to be injected.
    */
-  useFactory: (...args: any[]) => T | Promise<T>;
+  useFactory: (...args: any[]) => T;
   /**
    * Optional list of providers to be injected into the context of the Factory function.
    */
diff --git a/packages/common/module-utils/configurable-module.builder.ts b/packages/common/module-utils/configurable-module.builder.ts
deleted file mode 100644
index 0e3f1318f..000000000
--- a/packages/common/module-utils/configurable-module.builder.ts
+++ /dev/null
@@ -1,330 +0,0 @@
-import { DynamicModule, Provider } from '../interfaces';
-import { Logger } from '../services/logger.service';
-import { randomStringGenerator } from '../utils/random-string-generator.util';
-import {
-  ASYNC_METHOD_SUFFIX,
-  CONFIGURABLE_MODULE_ID,
-  DEFAULT_FACTORY_CLASS_METHOD_KEY,
-  DEFAULT_METHOD_KEY,
-} from './constants';
-import {
-  ConfigurableModuleAsyncOptions,
-  ConfigurableModuleCls,
-  ConfigurableModuleOptionsFactory,
-} from './interfaces';
-import { ConfigurableModuleHost } from './interfaces/configurable-module-host.interface';
-import { generateOptionsInjectionToken } from './utils/generate-options-injection-token.util';
-
-/**
- * @publicApi
- */
-export interface ConfigurableModuleBuilderOptions {
-  /**
-   * Specified what injection token should be used for the module options provider.
-   * By default, an auto-generated UUID will be used.
-   */
-  optionsInjectionToken?: string | symbol;
-  /**
-   * By default, an UUID will be used as a module options provider token.
-   * Explicitly specifying the "moduleName" will instruct the "ConfigurableModuleBuilder"
-   * to use a more descriptive provider token.
-   *
-   * For example, if `moduleName: "Cache"` then auto-generated provider token will be "CACHE_MODULE_OPTIONS".
-   */
-  moduleName?: string;
-  /**
-   * Indicates whether module should always be "transient", meaning,
-   * every time you call the static method to construct a dynamic module,
-   * regardless of what arguments you pass in, a new "unique" module will be created.
-   *
-   * @default false
-   */
-  alwaysTransient?: boolean;
-}
-
-/**
- * Factory that lets you create configurable modules and
- * provides a way to reduce the majority of dynamic module boilerplate.
- *
- * @publicApi
- */
-export class ConfigurableModuleBuilder<
-  ModuleOptions,
-  StaticMethodKey extends string = typeof DEFAULT_METHOD_KEY,
-  FactoryClassMethodKey extends string = typeof DEFAULT_FACTORY_CLASS_METHOD_KEY,
-  ExtraModuleDefinitionOptions = {},
-> {
-  protected staticMethodKey: StaticMethodKey;
-  protected factoryClassMethodKey: FactoryClassMethodKey;
-  protected extras: ExtraModuleDefinitionOptions;
-  protected transformModuleDefinition: (
-    definition: DynamicModule,
-    extraOptions: ExtraModuleDefinitionOptions,
-  ) => DynamicModule;
-
-  protected readonly logger = new Logger(ConfigurableModuleBuilder.name);
-
-  constructor(
-    protected readonly options: ConfigurableModuleBuilderOptions = {},
-    parentBuilder?: ConfigurableModuleBuilder<ModuleOptions>,
-  ) {
-    if (parentBuilder) {
-      this.staticMethodKey = parentBuilder.staticMethodKey as StaticMethodKey;
-      this.factoryClassMethodKey =
-        parentBuilder.factoryClassMethodKey as FactoryClassMethodKey;
-      this.transformModuleDefinition = parentBuilder.transformModuleDefinition;
-      this.extras = parentBuilder.extras as ExtraModuleDefinitionOptions;
-    }
-  }
-
-  /**
-   * Registers the "extras" object (a set of extra options that can be used to modify the dynamic module definition).
-   * Values you specify within the "extras" object will be used as default values (that can be overriden by module consumers).
-   *
-   * This method also applies the so-called "module definition transform function" that takes the auto-generated
-   * dynamic module object ("DynamicModule") and the actual consumer "extras" object as input parameters.
-   * The "extras" object consists of values explicitly specified by module consumers and default values.
-   *
-   * @example
-   * ```typescript
-   * .setExtras<{ isGlobal?: boolean }>({ isGlobal: false }, (definition, extras) =>
-   *    ({ ...definition, global: extras.isGlobal })
-   * )
-   * ```
-   */
-  setExtras<ExtraModuleDefinitionOptions>(
-    extras: ExtraModuleDefinitionOptions,
-    transformDefinition: (
-      definition: DynamicModule,
-      extras: ExtraModuleDefinitionOptions,
-    ) => DynamicModule,
-  ) {
-    const builder = new ConfigurableModuleBuilder<
-      ModuleOptions,
-      StaticMethodKey,
-      FactoryClassMethodKey,
-      ExtraModuleDefinitionOptions
-    >(this.options, this as any);
-    builder.extras = extras;
-    builder.transformModuleDefinition = transformDefinition;
-    return builder;
-  }
-
-  /**
-   * Dynamic modules must expose public static methods that let you pass in
-   * configuration parameters (control the module's behavior from the outside).
-   * Some frequently used names that you may have seen in other modules are:
-   * "forRoot", "forFeature", "register", "configure".
-   *
-   * This method "setClassMethodName" lets you specify the name of the
-   * method that will be auto-generated.
-   *
-   * @param key name of the method
-   */
-  setClassMethodName<StaticMethodKey extends string>(key: StaticMethodKey) {
-    const builder = new ConfigurableModuleBuilder<
-      ModuleOptions,
-      StaticMethodKey,
-      FactoryClassMethodKey,
-      ExtraModuleDefinitionOptions
-    >(this.options, this as any);
-    builder.staticMethodKey = key;
-    return builder;
-  }
-
-  /**
-   * Asynchronously configured modules (that rely on other modules, i.e. "ConfigModule")
-   * let you pass the configuration factory class that will be registered and instantiated as a provider.
-   * This provider then will be used to retrieve the module's configuration. To provide the configuration,
-   * the corresponding factory method must be implemented.
-   *
-   * This method ("setFactoryMethodName") lets you control what method name will have to be
-   * implemented by the config factory (default is "create").
-   *
-   * @param key name of the method
-   */
-  setFactoryMethodName<FactoryClassMethodKey extends string>(
-    key: FactoryClassMethodKey,
-  ) {
-    const builder = new ConfigurableModuleBuilder<
-      ModuleOptions,
-      StaticMethodKey,
-      FactoryClassMethodKey,
-      ExtraModuleDefinitionOptions
-    >(this.options, this as any);
-    builder.factoryClassMethodKey = key;
-    return builder;
-  }
-
-  /**
-   * Returns an object consisting of multiple properties that lets you
-   * easily construct dynamic configurable modules. See "ConfigurableModuleHost" interface for more details.
-   */
-  build(): ConfigurableModuleHost<
-    ModuleOptions,
-    StaticMethodKey,
-    FactoryClassMethodKey,
-    ExtraModuleDefinitionOptions
-  > {
-    this.staticMethodKey ??= DEFAULT_METHOD_KEY as StaticMethodKey;
-    this.factoryClassMethodKey ??=
-      DEFAULT_FACTORY_CLASS_METHOD_KEY as FactoryClassMethodKey;
-    this.options.optionsInjectionToken ??= this.options.moduleName
-      ? this.constructInjectionTokenString()
-      : generateOptionsInjectionToken();
-    this.transformModuleDefinition ??= definition => definition;
-
-    return {
-      ConfigurableModuleClass:
-        this.createConfigurableModuleCls<ModuleOptions>(),
-      MODULE_OPTIONS_TOKEN: this.options.optionsInjectionToken,
-      ASYNC_OPTIONS_TYPE: this.createTypeProxy('ASYNC_OPTIONS_TYPE'),
-      OPTIONS_TYPE: this.createTypeProxy('OPTIONS_TYPE'),
-    };
-  }
-
-  private constructInjectionTokenString(): string {
-    const moduleNameInSnakeCase = this.options.moduleName
-      .trim()
-      .split(/(?=[A-Z])/)
-      .join('_')
-      .toUpperCase();
-    return `${moduleNameInSnakeCase}_MODULE_OPTIONS`;
-  }
-
-  private createConfigurableModuleCls<ModuleOptions>(): ConfigurableModuleCls<
-    ModuleOptions,
-    StaticMethodKey,
-    FactoryClassMethodKey
-  > {
-    // eslint-disable-next-line @typescript-eslint/no-this-alias
-    const self = this;
-    const asyncMethodKey = this.staticMethodKey + ASYNC_METHOD_SUFFIX;
-
-    class InternalModuleClass {
-      static [self.staticMethodKey](
-        options: ModuleOptions & ExtraModuleDefinitionOptions,
-      ): DynamicModule {
-        const providers = [
-          {
-            provide: self.options.optionsInjectionToken,
-            useValue: this.omitExtras(options, self.extras),
-          },
-        ];
-        if (self.options.alwaysTransient) {
-          providers.push({
-            provide: CONFIGURABLE_MODULE_ID,
-            useValue: randomStringGenerator(),
-          });
-        }
-        return self.transformModuleDefinition(
-          {
-            module: this,
-            providers,
-          },
-          options,
-        );
-      }
-
-      static [asyncMethodKey](
-        options: ConfigurableModuleAsyncOptions<ModuleOptions> &
-          ExtraModuleDefinitionOptions,
-      ): DynamicModule {
-        const providers = this.createAsyncProviders(options);
-        if (self.options.alwaysTransient) {
-          providers.push({
-            provide: CONFIGURABLE_MODULE_ID,
-            useValue: randomStringGenerator(),
-          });
-        }
-        return self.transformModuleDefinition(
-          {
-            module: this,
-            imports: options.imports || [],
-            providers,
-          },
-          options,
-        );
-      }
-
-      private static omitExtras(
-        input: ModuleOptions & ExtraModuleDefinitionOptions,
-        extras: ExtraModuleDefinitionOptions | undefined,
-      ): ModuleOptions {
-        if (!extras) {
-          return input;
-        }
-        const moduleOptions = {};
-        const extrasKeys = Object.keys(extras);
-
-        Object.keys(input)
-          .filter(key => !extrasKeys.includes(key))
-          .forEach(key => {
-            moduleOptions[key] = input[key];
-          });
-        return moduleOptions as ModuleOptions;
-      }
-
-      private static createAsyncProviders(
-        options: ConfigurableModuleAsyncOptions<ModuleOptions>,
-      ): Provider[] {
-        if (options.useExisting || options.useFactory) {
-          return [this.createAsyncOptionsProvider(options)];
-        }
-        return [
-          this.createAsyncOptionsProvider(options),
-          {
-            provide: options.useClass,
-            useClass: options.useClass,
-          },
-        ];
-      }
-
-      private static createAsyncOptionsProvider(
-        options: ConfigurableModuleAsyncOptions<ModuleOptions>,
-      ): Provider {
-        if (options.useFactory) {
-          return {
-            provide: self.options.optionsInjectionToken,
-            useFactory: options.useFactory,
-            inject: options.inject || [],
-          };
-        }
-        return {
-          provide: self.options.optionsInjectionToken,
-          useFactory: async (
-            optionsFactory: ConfigurableModuleOptionsFactory<
-              ModuleOptions,
-              FactoryClassMethodKey
-            >,
-          ) =>
-            await optionsFactory[
-              self.factoryClassMethodKey as keyof typeof optionsFactory
-            ](),
-          inject: [options.useExisting || options.useClass],
-        };
-      }
-    }
-    return InternalModuleClass as unknown as ConfigurableModuleCls<
-      ModuleOptions,
-      StaticMethodKey,
-      FactoryClassMethodKey
-    >;
-  }
-
-  private createTypeProxy(
-    typeName: 'OPTIONS_TYPE' | 'ASYNC_OPTIONS_TYPE' | 'OptionsFactoryInterface',
-  ) {
-    const proxy = new Proxy(
-      {},
-      {
-        get: () => {
-          throw new Error(
-            `"${typeName}" is not supposed to be used as a value.`,
-          );
-        },
-      },
-    );
-    return proxy as any;
-  }
-}
diff --git a/packages/common/module-utils/constants.ts b/packages/common/module-utils/constants.ts
deleted file mode 100644
index 2d97c0c8c..000000000
--- a/packages/common/module-utils/constants.ts
+++ /dev/null
@@ -1,5 +0,0 @@
-export const DEFAULT_METHOD_KEY = 'register';
-export const DEFAULT_FACTORY_CLASS_METHOD_KEY = 'create';
-
-export const ASYNC_METHOD_SUFFIX = 'Async';
-export const CONFIGURABLE_MODULE_ID = 'CONFIGURABLE_MODULE_ID';
diff --git a/packages/common/module-utils/index.ts b/packages/common/module-utils/index.ts
deleted file mode 100644
index 4393992bd..000000000
--- a/packages/common/module-utils/index.ts
+++ /dev/null
@@ -1,2 +0,0 @@
-export * from './configurable-module.builder';
-export * from './interfaces';
diff --git a/packages/common/module-utils/interfaces/configurable-module-async-options.interface.ts b/packages/common/module-utils/interfaces/configurable-module-async-options.interface.ts
deleted file mode 100644
index 56f7040e4..000000000
--- a/packages/common/module-utils/interfaces/configurable-module-async-options.interface.ts
+++ /dev/null
@@ -1,51 +0,0 @@
-import { FactoryProvider, ModuleMetadata, Type } from '../../interfaces';
-import { DEFAULT_FACTORY_CLASS_METHOD_KEY } from '../constants';
-
-/**
- * Interface that must be implemented by the module options factory class.
- * Method key varies depending on the "FactoryClassMethodKey" type argument.
- *
- * @publicApi
- */
-export type ConfigurableModuleOptionsFactory<
-  ModuleOptions,
-  FactoryClassMethodKey extends string,
-> = Record<
-  `${FactoryClassMethodKey}`,
-  () => Promise<ModuleOptions> | ModuleOptions
->;
-
-/**
- * Interface that represents the module async options object
- * Factory method name varies depending on the "FactoryClassMethodKey" type argument.
- *
- * @publicApi
- */
-export interface ConfigurableModuleAsyncOptions<
-  ModuleOptions,
-  FactoryClassMethodKey extends string = typeof DEFAULT_FACTORY_CLASS_METHOD_KEY,
-> extends Pick<ModuleMetadata, 'imports'> {
-  /**
-   * Injection token resolving to an existing provider. The provider must implement
-   * the corresponding interface.
-   */
-  useExisting?: Type<
-    ConfigurableModuleOptionsFactory<ModuleOptions, FactoryClassMethodKey>
-  >;
-  /**
-   * Injection token resolving to a class that will be instantiated as a provider.
-   * The class must implement the corresponding interface.
-   */
-  useClass?: Type<
-    ConfigurableModuleOptionsFactory<ModuleOptions, FactoryClassMethodKey>
-  >;
-  /**
-   * Function returning options (or a Promise resolving to options) to configure the
-   * cache module.
-   */
-  useFactory?: (...args: unknown[]) => Promise<ModuleOptions> | ModuleOptions;
-  /**
-   * Dependencies that a Factory may inject.
-   */
-  inject?: FactoryProvider['inject'];
-}
diff --git a/packages/common/module-utils/interfaces/configurable-module-cls.interface.ts b/packages/common/module-utils/interfaces/configurable-module-cls.interface.ts
deleted file mode 100644
index e01c706be..000000000
--- a/packages/common/module-utils/interfaces/configurable-module-cls.interface.ts
+++ /dev/null
@@ -1,35 +0,0 @@
-import { DynamicModule } from '../../interfaces';
-import {
-  DEFAULT_FACTORY_CLASS_METHOD_KEY,
-  DEFAULT_METHOD_KEY,
-} from '../constants';
-import { ConfigurableModuleAsyncOptions } from './configurable-module-async-options.interface';
-
-/**
- * Class that represents a blueprint/prototype for a configurable Nest module.
- * This class provides static methods for constructing dynamic modules. Their names
- * can be controlled through the "MethodKey" type argument.
- *
- * @publicApi
- */
-export type ConfigurableModuleCls<
-  ModuleOptions,
-  MethodKey extends string = typeof DEFAULT_METHOD_KEY,
-  FactoryClassMethodKey extends string = typeof DEFAULT_FACTORY_CLASS_METHOD_KEY,
-  ExtraModuleDefinitionOptions = {},
-> = {
-  new (): any;
-} & Record<
-  `${MethodKey}`,
-  (options: ModuleOptions & ExtraModuleDefinitionOptions) => DynamicModule
-> &
-  Record<
-    `${MethodKey}Async`,
-    (
-      options: ConfigurableModuleAsyncOptions<
-        ModuleOptions,
-        FactoryClassMethodKey
-      > &
-        ExtraModuleDefinitionOptions,
-    ) => DynamicModule
-  >;
diff --git a/packages/common/module-utils/interfaces/configurable-module-host.interface.ts b/packages/common/module-utils/interfaces/configurable-module-host.interface.ts
deleted file mode 100644
index 6a652ecce..000000000
--- a/packages/common/module-utils/interfaces/configurable-module-host.interface.ts
+++ /dev/null
@@ -1,77 +0,0 @@
-import { ConfigurableModuleAsyncOptions } from './configurable-module-async-options.interface';
-import { ConfigurableModuleCls } from './configurable-module-cls.interface';
-
-/**
- * Configurable module host. See properties for more details
- *
- * @publicApi
- */
-export interface ConfigurableModuleHost<
-  ModuleOptions = Record<string, unknown>,
-  MethodKey extends string = string,
-  FactoryClassMethodKey extends string = string,
-  ExtraModuleDefinitionOptions = {},
-> {
-  /**
-   * Class that represents a blueprint/prototype for a configurable Nest module.
-   * This class provides static methods for constructing dynamic modules. Their names
-   * can be controlled through the "MethodKey" type argument.
-   *
-   * Your module class should inherit from this class to make the static methods available.
-   *
-   * @example
-   * ```typescript
-   * @Module({})
-   * class IntegrationModule extends ConfigurableModuleCls {
-   *  // ...
-   * }
-   * ```
-   */
-  ConfigurableModuleClass: ConfigurableModuleCls<
-    ModuleOptions,
-    MethodKey,
-    FactoryClassMethodKey,
-    ExtraModuleDefinitionOptions
-  >;
-  /**
-   * Module options provider token. Can be used to inject the "options object" to
-   * providers registered within the host module.
-   */
-  MODULE_OPTIONS_TOKEN: string | symbol;
-  /**
-   * Can be used to auto-infer the compound "async module options" type.
-   * Note: this property is not supposed to be used as a value.
-   *
-   * @example
-   * ```typescript
-   * @Module({})
-   * class IntegrationModule extends ConfigurableModuleCls {
-   *  static module = initializer(IntegrationModule);
-   *
-   * static registerAsync(options: typeof ASYNC_OPTIONS_TYPE): DynamicModule {
-   *  return super.registerAsync(options);
-   * }
-   * ```
-   */
-  ASYNC_OPTIONS_TYPE: ConfigurableModuleAsyncOptions<
-    ModuleOptions,
-    FactoryClassMethodKey
-  > &
-    ExtraModuleDefinitionOptions;
-  /**
-   * Can be used to auto-infer the compound "module options" type (options interface + extra module definition options).
-   * Note: this property is not supposed to be used as a value.
-   *
-   * @example
-   * ```typescript
-   * @Module({})
-   * class IntegrationModule extends ConfigurableModuleCls {
-   *  static module = initializer(IntegrationModule);
-   *
-   * static register(options: typeof OPTIONS_TYPE): DynamicModule {
-   *  return super.register(options);
-   * }
-   * ```
-   */
-  OPTIONS_TYPE: ModuleOptions & ExtraModuleDefinitionOptions;
-}
diff --git a/packages/common/module-utils/interfaces/index.ts b/packages/common/module-utils/interfaces/index.ts
deleted file mode 100644
index 35c523076..000000000
--- a/packages/common/module-utils/interfaces/index.ts
+++ /dev/null
@@ -1,3 +0,0 @@
-export * from './configurable-module-async-options.interface';
-export * from './configurable-module-cls.interface';
-export * from './configurable-module-host.interface';
diff --git a/packages/common/module-utils/utils/generate-options-injection-token.util.ts b/packages/common/module-utils/utils/generate-options-injection-token.util.ts
deleted file mode 100644
index 259a6afa3..000000000
--- a/packages/common/module-utils/utils/generate-options-injection-token.util.ts
+++ /dev/null
@@ -1,6 +0,0 @@
-import { randomStringGenerator } from '../../utils/random-string-generator.util';
-
-export function generateOptionsInjectionToken() {
-  const hash = randomStringGenerator();
-  return `CONFIGURABLE_MODULE_OPTIONS[${hash}]`;
-}
diff --git a/packages/common/pipes/parse-uuid.pipe.ts b/packages/common/pipes/parse-uuid.pipe.ts
index 81fe2b4c1..2679e8f93 100644
--- a/packages/common/pipes/parse-uuid.pipe.ts
+++ b/packages/common/pipes/parse-uuid.pipe.ts
@@ -9,7 +9,7 @@ import {
   ErrorHttpStatusCode,
   HttpErrorByCode,
 } from '../utils/http-error-by-code.util';
-import { isString } from '../utils/shared.utils';
+import { isUUID } from '../utils/is-uuid';
 
 export interface ParseUUIDPipeOptions {
   version?: '3' | '4' | '5';
@@ -19,12 +19,6 @@ export interface ParseUUIDPipeOptions {
 
 @Injectable()
 export class ParseUUIDPipe implements PipeTransform<string> {
-  protected static uuidRegExps = {
-    3: /^[0-9A-F]{8}-[0-9A-F]{4}-3[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i,
-    4: /^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
-    5: /^[0-9A-F]{8}-[0-9A-F]{4}-5[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
-    all: /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i,
-  };
   private readonly version: '3' | '4' | '5';
   protected exceptionFactory: (errors: string) => any;
 
@@ -41,23 +35,14 @@ export class ParseUUIDPipe implements PipeTransform<string> {
       exceptionFactory ||
       (error => new HttpErrorByCode[errorHttpStatusCode](error));
   }
-
   async transform(value: string, metadata: ArgumentMetadata): Promise<string> {
-    if (!this.isUUID(value, this.version)) {
+    if (!isUUID(value, this.version)) {
       throw this.exceptionFactory(
-        `Validation failed (uuid${
-          this.version ? ` v ${this.version}` : ''
+        `Validation failed (uuid ${
+          this.version ? 'v' + this.version : ''
         } is expected)`,
       );
     }
     return value;
   }
-
-  protected isUUID(str: unknown, version = 'all') {
-    if (!isString(str)) {
-      throw this.exceptionFactory('The value passed as UUID is not a string');
-    }
-    const pattern = ParseUUIDPipe.uuidRegExps[version];
-    return pattern?.test(str);
-  }
 }
diff --git a/packages/common/utils/is-uuid.ts b/packages/common/utils/is-uuid.ts
new file mode 100644
index 000000000..0e9572f4d
--- /dev/null
+++ b/packages/common/utils/is-uuid.ts
@@ -0,0 +1,17 @@
+import { BadRequestException } from '../exceptions';
+import { isString } from './shared.utils';
+
+const uuid = {
+  3: /^[0-9A-F]{8}-[0-9A-F]{4}-3[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i,
+  4: /^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
+  5: /^[0-9A-F]{8}-[0-9A-F]{4}-5[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
+  all: /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i,
+};
+
+export function isUUID(str: any, version = 'all') {
+  if (!isString(str)) {
+    throw new BadRequestException('The value passed as UUID is not a string');
+  }
+  const pattern = uuid[version];
+  return pattern && pattern.test(str);
+}
diff --git a/packages/core/router/router-explorer.ts b/packages/core/router/router-explorer.ts
index ab0517dc5..ee509718b 100644
--- a/packages/core/router/router-explorer.ts
+++ b/packages/core/router/router-explorer.ts
@@ -338,7 +338,8 @@ export class RouterExplorer {
       return router.applyVersionFilter(handler, version, versioningOptions);
     }
     /**
-     * TODO(v9): This was left for backward-compatibility and can be removed.
+     * This can be removed in the next major release.
+     * Left for backward-compatibility.
      */
     return <TRequest extends Record<string, any> = any, TResponse = any>(
       req: TRequest,
@@ -402,16 +403,9 @@ export class RouterExplorer {
 
         const acceptHeaderVersionParameter = acceptHeaderValue
           ? acceptHeaderValue.split(';')[1]
-          : undefined;
+          : '';
 
-        // No version was supplied
-        if (isUndefined(acceptHeaderVersionParameter)) {
-          if (Array.isArray(version)) {
-            if (version.includes(VERSION_NEUTRAL)) {
-              return handler(req, res, next);
-            }
-          }
-        } else {
+        if (acceptHeaderVersionParameter) {
           const headerVersion = acceptHeaderVersionParameter.split(
             versioningOptions.key,
           )[1];
@@ -433,14 +427,7 @@ export class RouterExplorer {
           req.headers?.[versioningOptions.header] ||
           req.headers?.[versioningOptions.header.toLowerCase()];
 
-        // No version was supplied
-        if (isUndefined(customHeaderVersionParameter)) {
-          if (Array.isArray(version)) {
-            if (version.includes(VERSION_NEUTRAL)) {
-              return handler(req, res, next);
-            }
-          }
-        } else {
+        if (customHeaderVersionParameter) {
           if (Array.isArray(version)) {
             if (version.includes(customHeaderVersionParameter)) {
               return handler(req, res, next);
diff --git a/packages/core/router/router-response-controller.ts b/packages/core/router/router-response-controller.ts
index 4128e7fca..008eea5a8 100644
--- a/packages/core/router/router-response-controller.ts
+++ b/packages/core/router/router-response-controller.ts
@@ -5,9 +5,9 @@ import {
   RequestMethod,
   MessageEvent,
 } from '@nestjs/common';
-import { isObject } from '@nestjs/common/utils/shared.utils';
+import { isFunction, isObject } from '@nestjs/common/utils/shared.utils';
 import { IncomingMessage } from 'http';
-import { EMPTY, lastValueFrom, Observable, isObservable } from 'rxjs';
+import { EMPTY, lastValueFrom, Observable } from 'rxjs';
 import { catchError, debounce, map } from 'rxjs/operators';
 import {
   AdditionalHeaders,
@@ -64,7 +64,7 @@ export class RouterResponseController {
   }
 
   public async transformToResult(resultOrDeferred: any) {
-    if (isObservable(resultOrDeferred)) {
+    if (resultOrDeferred && isFunction(resultOrDeferred.subscribe)) {
       return lastValueFrom(resultOrDeferred);
     }
     return resultOrDeferred;
@@ -152,8 +152,8 @@ export class RouterResponseController {
     });
   }
 
-  private assertObservable(value: any) {
-    if (!isObservable(value)) {
+  private assertObservable(result: any) {
+    if (!isFunction(result.subscribe)) {
       throw new ReferenceError(
         'You must return an Observable stream to use Server-Sent Events (SSE).',
       );
diff --git a/packages/microservices/constants.ts b/packages/microservices/constants.ts
index 3e65795a7..a47c40762 100644
--- a/packages/microservices/constants.ts
+++ b/packages/microservices/constants.ts
@@ -38,8 +38,10 @@ export const RQM_DEFAULT_NOACK = true;
 export const RQM_DEFAULT_PERSISTENT = false;
 export const GRPC_DEFAULT_PROTO_LOADER = '@grpc/proto-loader';
 
+export const NO_EVENT_HANDLER = (text: TemplateStringsArray, pattern: string) =>
+  `There is no matching event handler defined in the remote service. Event pattern: ${pattern}`;
 export const NO_MESSAGE_HANDLER = `There is no matching message handler defined in the remote service.`;
-export const NO_EVENT_HANDLER = `There is no matching event handler defined in the remote service.`;
+
 export const DISCONNECTED_RMQ_MESSAGE = `Disconnected from RMQ. Trying to reconnect.`;
 
 export const KAFKA_DEFAULT_CLIENT = 'nestjs-consumer';
diff --git a/packages/microservices/context/rpc-proxy.ts b/packages/microservices/context/rpc-proxy.ts
index 081167f62..521d5b7cd 100644
--- a/packages/microservices/context/rpc-proxy.ts
+++ b/packages/microservices/context/rpc-proxy.ts
@@ -1,5 +1,5 @@
 import { ExecutionContextHost } from '@nestjs/core/helpers/execution-context-host';
-import { Observable, isObservable } from 'rxjs';
+import { isObservable, Observable } from 'rxjs';
 import { catchError } from 'rxjs/operators';
 import { RpcExceptionsHandler } from '../exceptions/rpc-exceptions-handler';
 
diff --git a/packages/microservices/ctx-host/kafka.context.ts b/packages/microservices/ctx-host/kafka.context.ts
index 922ccb9c5..54c80475a 100644
--- a/packages/microservices/ctx-host/kafka.context.ts
+++ b/packages/microservices/ctx-host/kafka.context.ts
@@ -1,7 +1,12 @@
-import { KafkaMessage } from '../external/kafka.interface';
+import { Consumer, KafkaMessage } from '../external/kafka.interface';
 import { BaseRpcContext } from './base-rpc.context';
 
-type KafkaContextArgs = [KafkaMessage, number, string];
+type KafkaContextArgs = [
+  message: KafkaMessage,
+  partition: number,
+  topic: string,
+  consumer: Consumer,
+];
 
 export class KafkaContext extends BaseRpcContext<KafkaContextArgs> {
   constructor(args: KafkaContextArgs) {
@@ -28,4 +33,11 @@ export class KafkaContext extends BaseRpcContext<KafkaContextArgs> {
   getTopic() {
     return this.args[2];
   }
+
+  /**
+   * Returns the Kafka consumer reference.
+   */
+  getConsumer() {
+    return this.args[3];
+  }
 }
diff --git a/packages/microservices/decorators/event-pattern.decorator.ts b/packages/microservices/decorators/event-pattern.decorator.ts
index b44825d63..34708b007 100644
--- a/packages/microservices/decorators/event-pattern.decorator.ts
+++ b/packages/microservices/decorators/event-pattern.decorator.ts
@@ -48,11 +48,7 @@ export const EventPattern: {
     key: string | symbol,
     descriptor: PropertyDescriptor,
   ) => {
-    Reflect.defineMetadata(
-      PATTERN_METADATA,
-      [].concat(metadata),
-      descriptor.value,
-    );
+    Reflect.defineMetadata(PATTERN_METADATA, metadata, descriptor.value);
     Reflect.defineMetadata(
       PATTERN_HANDLER_METADATA,
       PatternHandler.EVENT,
diff --git a/packages/microservices/decorators/message-pattern.decorator.ts b/packages/microservices/decorators/message-pattern.decorator.ts
index 6cb4ed1d8..3e17d8569 100644
--- a/packages/microservices/decorators/message-pattern.decorator.ts
+++ b/packages/microservices/decorators/message-pattern.decorator.ts
@@ -62,11 +62,7 @@ export const MessagePattern: {
     key: string | symbol,
     descriptor: PropertyDescriptor,
   ) => {
-    Reflect.defineMetadata(
-      PATTERN_METADATA,
-      [].concat(metadata),
-      descriptor.value,
-    );
+    Reflect.defineMetadata(PATTERN_METADATA, metadata, descriptor.value);
     Reflect.defineMetadata(
       PATTERN_HANDLER_METADATA,
       PatternHandler.MESSAGE,
diff --git a/packages/microservices/deserializers/kafka-request.deserializer.ts b/packages/microservices/deserializers/kafka-request.deserializer.ts
new file mode 100644
index 000000000..99dae3119
--- /dev/null
+++ b/packages/microservices/deserializers/kafka-request.deserializer.ts
@@ -0,0 +1,21 @@
+import { IncomingEvent, IncomingRequest } from '../interfaces';
+import { KafkaRequest } from '../serializers/kafka-request.serializer';
+import { IncomingRequestDeserializer } from './incoming-request.deserializer';
+
+export class KafkaRequestDeserializer extends IncomingRequestDeserializer {
+  mapToSchema(
+    data: KafkaRequest,
+    options?: Record<string, any>,
+  ): IncomingRequest | IncomingEvent {
+    if (!options) {
+      return {
+        pattern: undefined,
+        data: undefined,
+      };
+    }
+    return {
+      pattern: options.channel,
+      data: data?.value ?? data,
+    };
+  }
+}
diff --git a/packages/microservices/exceptions/index.ts b/packages/microservices/exceptions/index.ts
index dd6e4d298..73e4c3176 100644
--- a/packages/microservices/exceptions/index.ts
+++ b/packages/microservices/exceptions/index.ts
@@ -1,2 +1,3 @@
 export * from './base-rpc-exception-filter';
+export * from './kafka-retriable-exception';
 export * from './rpc-exception';
diff --git a/packages/microservices/exceptions/kafka-retriable-exception.ts b/packages/microservices/exceptions/kafka-retriable-exception.ts
new file mode 100644
index 000000000..c62194a2e
--- /dev/null
+++ b/packages/microservices/exceptions/kafka-retriable-exception.ts
@@ -0,0 +1,17 @@
+import { RpcException } from './rpc-exception';
+
+/**
+ * Exception that instructs Kafka driver to instead of introspecting
+ * error processing flow and sending serialized error message to the consumer,
+ * force bubble it up to the "eachMessage" callback of the underlying "kafkajs" package
+ * (even if interceptors are applied, or an observable stream is returned from the message handler).
+ *
+ * A transient exception that if retried may succeed.
+ *
+ * @publicApi
+ */
+export class KafkaRetriableException extends RpcException {
+  public getError(): string | object {
+    return this;
+  }
+}
diff --git a/packages/microservices/listener-metadata-explorer.ts b/packages/microservices/listener-metadata-explorer.ts
index 66ddffaf0..83e8f04c2 100644
--- a/packages/microservices/listener-metadata-explorer.ts
+++ b/packages/microservices/listener-metadata-explorer.ts
@@ -20,7 +20,7 @@ export interface ClientProperties {
 }
 
 export interface EventOrMessageListenerDefinition {
-  patterns: PatternMetadata[];
+  pattern: PatternMetadata;
   methodKey: string;
   isEventHandler: boolean;
   targetCallback: (...args: any[]) => any;
@@ -58,13 +58,13 @@ export class ListenerMetadataExplorer {
     if (isUndefined(handlerType)) {
       return;
     }
-    const patterns = Reflect.getMetadata(PATTERN_METADATA, targetCallback);
+    const pattern = Reflect.getMetadata(PATTERN_METADATA, targetCallback);
     const transport = Reflect.getMetadata(TRANSPORT_METADATA, targetCallback);
     const extras = Reflect.getMetadata(PATTERN_EXTRAS_METADATA, targetCallback);
     return {
       methodKey,
       targetCallback,
-      patterns,
+      pattern,
       transport,
       extras,
       isEventHandler: handlerType === PatternHandler.EVENT,
diff --git a/packages/microservices/listeners-controller.ts b/packages/microservices/listeners-controller.ts
index abc77d597..7687ccf46 100644
--- a/packages/microservices/listeners-controller.ts
+++ b/packages/microservices/listeners-controller.ts
@@ -71,20 +71,8 @@ export class ListenersController {
           isUndefined(server.transportId) ||
           transport === server.transportId,
       )
-      .reduce((acc, handler) => {
-        handler.patterns.forEach(pattern =>
-          acc.push({ ...handler, patterns: [pattern] }),
-        );
-        return acc;
-      }, [])
       .forEach(
-        ({
-          patterns: [pattern],
-          targetCallback,
-          methodKey,
-          extras,
-          isEventHandler,
-        }) => {
+        ({ pattern, targetCallback, methodKey, extras, isEventHandler }) => {
           if (isStatic) {
             const proxy = this.contextCreator.create(
               instance as object,
diff --git a/packages/microservices/microservices-module.ts b/packages/microservices/microservices-module.ts
index 735fda9fe..54632e412 100644
--- a/packages/microservices/microservices-module.ts
+++ b/packages/microservices/microservices-module.ts
@@ -24,13 +24,12 @@ export class MicroservicesModule {
   private listenersController: ListenersController;
 
   public register(container: NestContainer, config: ApplicationConfig) {
-    const rpcProxy = new RpcProxy();
     const exceptionFiltersContext = new ExceptionFiltersContext(
       container,
       config,
     );
     const contextCreator = new RpcContextCreator(
-      rpcProxy,
+      new RpcProxy(),
       exceptionFiltersContext,
       new PipesContextCreator(container, config),
       new PipesConsumer(),
diff --git a/packages/microservices/server/server-kafka.ts b/packages/microservices/server/server-kafka.ts
index 829d30d91..880af956d 100644
--- a/packages/microservices/server/server-kafka.ts
+++ b/packages/microservices/server/server-kafka.ts
@@ -1,14 +1,17 @@
 import { Logger } from '@nestjs/common/services/logger.service';
 import { isNil } from '@nestjs/common/utils/shared.utils';
-import { Observable } from 'rxjs';
+import { isObservable, lastValueFrom, Observable, ReplaySubject } from 'rxjs';
 import {
   KAFKA_DEFAULT_BROKER,
   KAFKA_DEFAULT_CLIENT,
   KAFKA_DEFAULT_GROUP,
+  NO_EVENT_HANDLER,
   NO_MESSAGE_HANDLER,
 } from '../constants';
 import { KafkaContext } from '../ctx-host';
+import { KafkaRequestDeserializer } from '../deserializers/kafka-request.deserializer';
 import { KafkaHeaders, Transport } from '../enums';
+import { KafkaRetriableException } from '../exceptions';
 import {
   BrokersFunction,
   Consumer,
@@ -26,6 +29,7 @@ import {
   CustomTransportStrategy,
   KafkaOptions,
   OutgoingResponse,
+  ReadPacket,
 } from '../interfaces';
 import { KafkaRequestSerializer } from '../serializers/kafka-request.serializer';
 import { Server } from './server';
@@ -162,6 +166,7 @@ export class ServerKafka extends Server implements CustomTransportStrategy {
       rawMessage,
       payload.partition,
       payload.topic,
+      this.consumer,
     ]);
     const handler = this.getHandlerByPattern(packet.pattern);
     // if the correlation id or reply topic is not set
@@ -186,7 +191,37 @@ export class ServerKafka extends Server implements CustomTransportStrategy {
     const response$ = this.transformToObservable(
       await handler(packet.data, kafkaContext),
     );
-    response$ && this.send(response$, publish);
+
+    const replayStream$ = new ReplaySubject();
+    await this.combineStreamsAndThrowIfRetriable(response$, replayStream$);
+
+    this.send(replayStream$, publish);
+  }
+
+  private combineStreamsAndThrowIfRetriable(
+    response$: Observable<any>,
+    replayStream$: ReplaySubject<unknown>,
+  ) {
+    return new Promise<void>((resolve, reject) => {
+      let isPromiseResolved = false;
+      response$.subscribe({
+        next: val => {
+          replayStream$.next(val);
+          if (!isPromiseResolved) {
+            isPromiseResolved = true;
+            resolve();
+          }
+        },
+        error: err => {
+          if (err instanceof KafkaRetriableException && !isPromiseResolved) {
+            isPromiseResolved = true;
+            reject(err);
+          }
+          replayStream$.error(err);
+        },
+        complete: () => replayStream$.complete(),
+      });
+    });
   }
 
   public async sendMessage(
@@ -228,9 +263,12 @@ export class ServerKafka extends Server implements CustomTransportStrategy {
     if (!outgoingResponse.err) {
       return;
     }
-    outgoingMessage.headers[KafkaHeaders.NEST_ERR] = Buffer.from(
-      outgoingResponse.err,
-    );
+    const stringifiedError =
+      typeof outgoingResponse.err === 'object'
+        ? JSON.stringify(outgoingResponse.err)
+        : outgoingResponse.err;
+    outgoingMessage.headers[KafkaHeaders.NEST_ERR] =
+      Buffer.from(stringifiedError);
   }
 
   public assignCorrelationIdHeader(
@@ -251,8 +289,27 @@ export class ServerKafka extends Server implements CustomTransportStrategy {
     outgoingMessage.partition = parseFloat(replyPartition);
   }
 
+  public async handleEvent(
+    pattern: string,
+    packet: ReadPacket,
+    context: KafkaContext,
+  ): Promise<any> {
+    const handler = this.getHandlerByPattern(pattern);
+    if (!handler) {
+      return this.logger.error(NO_EVENT_HANDLER`${pattern}`);
+    }
+    const resultOrStream = await handler(packet.data, context);
+    if (isObservable(resultOrStream)) {
+      await lastValueFrom(resultOrStream);
+    }
+  }
+
   protected initializeSerializer(options: KafkaOptions['options']) {
     this.serializer =
       (options && options.serializer) || new KafkaRequestSerializer();
   }
+
+  protected initializeDeserializer(options: KafkaOptions['options']) {
+    this.deserializer = options?.deserializer ?? new KafkaRequestDeserializer();
+  }
 }
diff --git a/packages/microservices/server/server.ts b/packages/microservices/server/server.ts
index b36bcfa3a..4e8ee9bf6 100644
--- a/packages/microservices/server/server.ts
+++ b/packages/microservices/server/server.ts
@@ -111,9 +111,7 @@ export abstract class Server {
   ): Promise<any> {
     const handler = this.getHandlerByPattern(pattern);
     if (!handler) {
-      return this.logger.error(
-        `${NO_EVENT_HANDLER} Event pattern: ${JSON.stringify(pattern)}.`,
-      );
+      return this.logger.error(NO_EVENT_HANDLER`${pattern}`);
     }
     const resultOrStream = await handler(packet.data, context);
     if (isObservable(resultOrStream)) {
diff --git a/packages/platform-express/adapters/express-adapter.ts b/packages/platform-express/adapters/express-adapter.ts
index b8dcf9340..7a832e0ff 100644
--- a/packages/platform-express/adapters/express-adapter.ts
+++ b/packages/platform-express/adapters/express-adapter.ts
@@ -19,7 +19,6 @@ import {
   isNil,
   isObject,
   isString,
-  isUndefined,
 } from '@nestjs/common/utils/shared.utils';
 import { AbstractHttpAdapter } from '@nestjs/core/adapters/http-adapter';
 import { RouterMethodFactory } from '@nestjs/core/helpers/router-method-factory';
@@ -257,16 +256,9 @@ export class ExpressAdapter extends AbstractHttpAdapter {
 
         const acceptHeaderVersionParameter = acceptHeaderValue
           ? acceptHeaderValue.split(';')[1]
-          : undefined;
+          : '';
 
-        // No version was supplied
-        if (isUndefined(acceptHeaderVersionParameter)) {
-          if (Array.isArray(version)) {
-            if (version.includes(VERSION_NEUTRAL)) {
-              return handler(req, res, next);
-            }
-          }
-        } else {
+        if (acceptHeaderVersionParameter) {
           const headerVersion = acceptHeaderVersionParameter.split(
             versioningOptions.key,
           )[1];
@@ -288,14 +280,7 @@ export class ExpressAdapter extends AbstractHttpAdapter {
           req.headers?.[versioningOptions.header] ||
           req.headers?.[versioningOptions.header.toLowerCase()];
 
-        // No version was supplied
-        if (isUndefined(customHeaderVersionParameter)) {
-          if (Array.isArray(version)) {
-            if (version.includes(VERSION_NEUTRAL)) {
-              return handler(req, res, next);
-            }
-          }
-        } else {
+        if (customHeaderVersionParameter) {
           if (Array.isArray(version)) {
             if (version.includes(customHeaderVersionParameter)) {
               return handler(req, res, next);
diff --git a/packages/platform-fastify/adapters/fastify-adapter.ts b/packages/platform-fastify/adapters/fastify-adapter.ts
index ebf64274e..fe668b1c3 100644
--- a/packages/platform-fastify/adapters/fastify-adapter.ts
+++ b/packages/platform-fastify/adapters/fastify-adapter.ts
@@ -154,9 +154,12 @@ export class FastifyAdapter<
           ? acceptHeaderValue.split(';')[1]
           : '';
 
-        return isUndefined(acceptHeaderVersionParameter)
-          ? VERSION_NEUTRAL // No version was supplied
-          : acceptHeaderVersionParameter.split(this.versioningOptions.key)[1];
+        if (acceptHeaderVersionParameter) {
+          const headerVersion = acceptHeaderVersionParameter.split(
+            this.versioningOptions.key,
+          )[1];
+          return headerVersion;
+        }
       }
       // Header Versioning Handler
       else if (this.versioningOptions.type === VersioningType.HEADER) {
@@ -164,9 +167,9 @@ export class FastifyAdapter<
           req.headers?.[this.versioningOptions.header] ||
           req.headers?.[this.versioningOptions.header.toLowerCase()];
 
-        return isUndefined(customHeaderVersionParameter)
-          ? VERSION_NEUTRAL // No version was supplied
-          : customHeaderVersionParameter;
+        if (customHeaderVersionParameter) {
+          return customHeaderVersionParameter;
+        }
       }
       // Custom Versioning Handler
       else if (this.versioningOptions.type === VersioningType.CUSTOM) {
diff --git a/packages/websockets/web-sockets-controller.ts b/packages/websockets/web-sockets-controller.ts
index d01811e17..75e790c82 100644
--- a/packages/websockets/web-sockets-controller.ts
+++ b/packages/websockets/web-sockets-controller.ts
@@ -1,14 +1,9 @@
 import { Type } from '@nestjs/common/interfaces/type.interface';
 import { Logger } from '@nestjs/common/services/logger.service';
+import { isFunction } from '@nestjs/common/utils/shared.utils';
 import { ApplicationConfig } from '@nestjs/core/application-config';
 import { MetadataScanner } from '@nestjs/core/metadata-scanner';
-import {
-  from as fromPromise,
-  Observable,
-  isObservable,
-  of,
-  Subject,
-} from 'rxjs';
+import { from as fromPromise, Observable, of, Subject } from 'rxjs';
 import { distinctUntilChanged, mergeAll } from 'rxjs/operators';
 import { GATEWAY_OPTIONS, PORT_METADATA } from './constants';
 import { WsContextCreator } from './context/ws-context-creator';
@@ -163,7 +158,7 @@ export class WebSocketsController {
     deferredResult: Promise<any>,
   ): Promise<Observable<any>> {
     const result = await deferredResult;
-    if (isObservable(result)) {
+    if (result && isFunction(result.subscribe)) {
       return result;
     }
     if (result instanceof Promise) {
