diff --git a/docs/guides/05-handling-errors.md b/docs/guides/05-handling-errors.md
index 22a7098..c92e3f7 100644
--- a/docs/guides/05-handling-errors.md
+++ b/docs/guides/05-handling-errors.md
@@ -25,6 +25,13 @@ assert(data, User)
 // StructError: At path: email -- Expected a string, but received: false
 ```
 
+You can also specify your own message for more clarity. In this case the original message will be preserved in [Error.cause](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error/cause).
+
+```ts
+assert(data, User, "The user is invalid!");
+// StructError: The user is invalid!
+```
+
 In addition to the error message, the `error` object will have a bunch of useful properties on it:
 
 ```ts
diff --git a/docs/reference/core.md b/docs/reference/core.md
index 5985a61..6477b69 100644
--- a/docs/reference/core.md
+++ b/docs/reference/core.md
@@ -2,25 +2,25 @@
 
 ### `assert`
 
-`assert<T>(value: unknown, struct: Struct<T>) => asserts value is T`
+`assert<T>(value: unknown, struct: Struct<T>, message?: string) => asserts value is T`
 
 ```ts
-assert(value, User)
+assert(value, User, 'The user is invalid!')
 ```
 
-Assert that `value` is valid according to a `struct`. If the value is invalid a [`StructError`](./errors.md#structerror) will be thrown.
+Assert that `value` is valid according to a `struct`. If the value is invalid a [`StructError`](./errors.md#structerror) will be thrown (the optional `message` parameter allows you to override error's message).
 
 > ðŸ¤– When using TypeScript `assert` acts as an [assertion function](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#assertion-functions), so you can ensure that after calling it the type of the `value` matches the shape of the struct.
 
 ### `create`
 
-`create<T>(value: unknown, struct: Struct<T>) => T`
+`create<T>(value: unknown, struct: Struct<T>, message?: string) => T`
 
 ```ts
-const user = create(value, User)
+const user = create(value, User, 'Unable to create a user!')
 ```
 
-Create a `value` using the coercion logic that is built-in to the struct, returning the newly coerced value. If the value is invalid a [`StructError`](./errors.md#structerror) will be thrown.
+Create a `value` using the coercion logic that is built-in to the struct, returning the newly coerced value. If the value is invalid a [`StructError`](./errors.md#structerror) will be thrown (the optional `message` parameter allows you to override error's message).
 
 > ðŸ¤– If you want coercion logic like defaulted values, you **must** call this helper before running validation.
 
@@ -40,13 +40,13 @@ Test that `value` is valid, returning a boolean representing whether it is valid
 
 ### `mask`
 
-`mask<T>(value: unknown, struct: Struct<T>) => T`
+`mask<T>(value: unknown, struct: Struct<T>, message?: string) => T`
 
 ```ts
-const user = mask(value, User)
+const user = mask(value, User, 'The value is incompatible with type User!')
 ```
 
-Mask a `value`, returning a new value containing only properties defined by a `struct`. Conceptually this is similar to `create`, except that extra properties are omitted from the newly created value instead of throwing a [`StructError`](./errors.md#structerror).
+Mask a `value`, returning a new value containing only properties defined by a `struct`. Conceptually this is similar to `create`, except that extra properties are omitted from the newly created value instead of throwing a [`StructError`](./errors.md#structerror). If an error is thrown anyway, the optional `message` parameter allows you to override its message.
 
 Note that when `mask` is used with `type` â€” given that `type` signals to the core that an object might have arbitrary additional properties â€” unknown properties will be retained in the returned value.
 
@@ -63,4 +63,4 @@ const [err, user] = validate(value, User)
 
 Validate `value`, returning a result tuple. If the value is invalid the first element will be a [`StructError`](./errors.md#structerror). Otherwise, the first element will be `undefined` and the second element will be a value that is guaranteed to match the struct.
 
-You can pass `{ coerce: true }` as the third argument to enable coercion of the input value.
+You can pass `{ coerce: true }` as the third argument to enable coercion of the input value. As well as pass `{ message: 'Your custom error message' }` to override the message of the [`StructError`](./errors.md#structerror).
diff --git a/docs/reference/errors.md b/docs/reference/errors.md
index d3ecb3f..43582ab 100644
--- a/docs/reference/errors.md
+++ b/docs/reference/errors.md
@@ -28,7 +28,7 @@ Each error thrown includes the following properties:
 | `path`       | `Array<string \| number>`       | `['address', 'street']`                                                        | The path to the invalid value relative to the root value.                                                                                                                                                              |
 | `type`       | `string`                        | `'date'` / `'object'` / â€¦                                                      | The expected type of the invalid value. This is a string of the struct that failed validation (eg. `string`, `date`, `object`).                                                                                        |
 | `value`      | `any`                           | `false`                                                                        | The invalid value.                                                                                                                                                                                                     |
-
+| `cause`      | `string \| undefined`           | `Expected a string, but received: 42`                                          | If a custom message is specified, the original one will be preserved in this property (complies with [standard](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error/cause)).        |
 ### Multiple Errors
 
 The error thrown by Superstruct is always the first validation failure that was encountered, because this makes for convenient and simple logic in the majority of cases. However, the `failures` property is available with a list of all of the validation failures that occurred in case you want to add support for multiple error handling.
diff --git a/src/error.ts b/src/error.ts
index e5b0f2f..663470d 100644
--- a/src/error.ts
+++ b/src/error.ts
@@ -8,6 +8,7 @@ export type Failure = {
   type: string
   refinement: string | undefined
   message: string
+  explanation?: string
   branch: Array<any>
   path: Array<any>
 }
@@ -33,11 +34,12 @@ export class StructError extends TypeError {
 
   constructor(failure: Failure, failures: () => Generator<Failure>) {
     let cached: Array<Failure> | undefined
-    const { message, ...rest } = failure
+    const { message, explanation, ...rest } = failure
     const { path } = failure
     const msg =
       path.length === 0 ? message : `At path: ${path.join('.')} -- ${message}`
-    super(msg)
+    super(explanation ?? msg)
+    if (explanation != null) this.cause = msg
     Object.assign(this, rest)
     this.name = this.constructor.name
     this.failures = () => {
diff --git a/src/struct.ts b/src/struct.ts
index c3ad533..b482fd3 100644
--- a/src/struct.ts
+++ b/src/struct.ts
@@ -64,16 +64,16 @@ export class Struct<T = unknown, S = unknown> {
    * Assert that a value passes the struct's validation, throwing if it doesn't.
    */
 
-  assert(value: unknown): asserts value is T {
-    return assert(value, this)
+  assert(value: unknown, message?: string): asserts value is T {
+    return assert(value, this, message)
   }
 
   /**
    * Create a value with the struct's coercion logic, then validate it.
    */
 
-  create(value: unknown): T {
-    return create(value, this)
+  create(value: unknown, message?: string): T {
+    return create(value, this, message)
   }
 
   /**
@@ -89,8 +89,8 @@ export class Struct<T = unknown, S = unknown> {
    * properties defined by the struct's schema.
    */
 
-  mask(value: unknown): T {
-    return mask(value, this)
+  mask(value: unknown, message?: string): T {
+    return mask(value, this, message)
   }
 
   /**
@@ -106,6 +106,7 @@ export class Struct<T = unknown, S = unknown> {
     value: unknown,
     options: {
       coerce?: boolean
+      message?: string
     } = {}
   ): [StructError, undefined] | [undefined, T] {
     return validate(value, this, options)
@@ -118,9 +119,10 @@ export class Struct<T = unknown, S = unknown> {
 
 export function assert<T, S>(
   value: unknown,
-  struct: Struct<T, S>
+  struct: Struct<T, S>,
+  message?: string
 ): asserts value is T {
-  const result = validate(value, struct)
+  const result = validate(value, struct, { message })
 
   if (result[0]) {
     throw result[0]
@@ -131,8 +133,12 @@ export function assert<T, S>(
  * Create a value with the coercion logic of struct and validate it.
  */
 
-export function create<T, S>(value: unknown, struct: Struct<T, S>): T {
-  const result = validate(value, struct, { coerce: true })
+export function create<T, S>(
+  value: unknown,
+  struct: Struct<T, S>,
+  message?: string
+): T {
+  const result = validate(value, struct, { coerce: true, message })
 
   if (result[0]) {
     throw result[0]
@@ -145,8 +151,12 @@ export function create<T, S>(value: unknown, struct: Struct<T, S>): T {
  * Mask a value, returning only the subset of properties defined by a struct.
  */
 
-export function mask<T, S>(value: unknown, struct: Struct<T, S>): T {
-  const result = validate(value, struct, { coerce: true, mask: true })
+export function mask<T, S>(
+  value: unknown,
+  struct: Struct<T, S>,
+  message?: string
+): T {
+  const result = validate(value, struct, { coerce: true, mask: true, message })
 
   if (result[0]) {
     throw result[0]
@@ -175,6 +185,7 @@ export function validate<T, S>(
   options: {
     coerce?: boolean
     mask?: boolean
+    message?: string
   } = {}
 ): [StructError, undefined] | [undefined, T] {
   const tuples = run(value, struct, options)
diff --git a/src/utils.ts b/src/utils.ts
index 0455b30..6264dd0 100644
--- a/src/utils.ts
+++ b/src/utils.ts
@@ -127,6 +127,7 @@ export function* run<T, S>(
     branch?: any[]
     coerce?: boolean
     mask?: boolean
+    message?: string
   } = {}
 ): IterableIterator<[Failure, undefined] | [undefined, T]> {
   const { path = [], branch = [value], coerce = false, mask = false } = options
@@ -153,6 +154,7 @@ export function* run<T, S>(
   let status: 'valid' | 'not_refined' | 'not_valid' = 'valid'
 
   for (const failure of struct.validator(value, ctx)) {
+    failure.explanation = options.message
     status = 'not_valid'
     yield [failure, undefined]
   }
@@ -163,6 +165,7 @@ export function* run<T, S>(
       branch: k === undefined ? branch : [...branch, v],
       coerce,
       mask,
+      message: options.message,
     })
 
     for (const t of ts) {
@@ -187,6 +190,7 @@ export function* run<T, S>(
 
   if (status !== 'not_valid') {
     for (const failure of struct.refiner(value as T, ctx)) {
+      failure.explanation = options.message
       status = 'not_refined'
       yield [failure, undefined]
     }
