diff --git a/docs/guides/05-handling-errors.md b/docs/guides/05-handling-errors.md
index c92e3f7..22a7098 100644
--- a/docs/guides/05-handling-errors.md
+++ b/docs/guides/05-handling-errors.md
@@ -25,13 +25,6 @@ assert(data, User)
 // StructError: At path: email -- Expected a string, but received: false
 ```
 
-You can also specify your own message for more clarity. In this case the original message will be preserved in [Error.cause](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error/cause).
-
-```ts
-assert(data, User, "The user is invalid!");
-// StructError: The user is invalid!
-```
-
 In addition to the error message, the `error` object will have a bunch of useful properties on it:
 
 ```ts
diff --git a/docs/reference/core.md b/docs/reference/core.md
index 6477b69..5985a61 100644
--- a/docs/reference/core.md
+++ b/docs/reference/core.md
@@ -2,25 +2,25 @@
 
 ### `assert`
 
-`assert<T>(value: unknown, struct: Struct<T>, message?: string) => asserts value is T`
+`assert<T>(value: unknown, struct: Struct<T>) => asserts value is T`
 
 ```ts
-assert(value, User, 'The user is invalid!')
+assert(value, User)
 ```
 
-Assert that `value` is valid according to a `struct`. If the value is invalid a [`StructError`](./errors.md#structerror) will be thrown (the optional `message` parameter allows you to override error's message).
+Assert that `value` is valid according to a `struct`. If the value is invalid a [`StructError`](./errors.md#structerror) will be thrown.
 
 > ðŸ¤– When using TypeScript `assert` acts as an [assertion function](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#assertion-functions), so you can ensure that after calling it the type of the `value` matches the shape of the struct.
 
 ### `create`
 
-`create<T>(value: unknown, struct: Struct<T>, message?: string) => T`
+`create<T>(value: unknown, struct: Struct<T>) => T`
 
 ```ts
-const user = create(value, User, 'Unable to create a user!')
+const user = create(value, User)
 ```
 
-Create a `value` using the coercion logic that is built-in to the struct, returning the newly coerced value. If the value is invalid a [`StructError`](./errors.md#structerror) will be thrown (the optional `message` parameter allows you to override error's message).
+Create a `value` using the coercion logic that is built-in to the struct, returning the newly coerced value. If the value is invalid a [`StructError`](./errors.md#structerror) will be thrown.
 
 > ðŸ¤– If you want coercion logic like defaulted values, you **must** call this helper before running validation.
 
@@ -40,13 +40,13 @@ Test that `value` is valid, returning a boolean representing whether it is valid
 
 ### `mask`
 
-`mask<T>(value: unknown, struct: Struct<T>, message?: string) => T`
+`mask<T>(value: unknown, struct: Struct<T>) => T`
 
 ```ts
-const user = mask(value, User, 'The value is incompatible with type User!')
+const user = mask(value, User)
 ```
 
-Mask a `value`, returning a new value containing only properties defined by a `struct`. Conceptually this is similar to `create`, except that extra properties are omitted from the newly created value instead of throwing a [`StructError`](./errors.md#structerror). If an error is thrown anyway, the optional `message` parameter allows you to override its message.
+Mask a `value`, returning a new value containing only properties defined by a `struct`. Conceptually this is similar to `create`, except that extra properties are omitted from the newly created value instead of throwing a [`StructError`](./errors.md#structerror).
 
 Note that when `mask` is used with `type` â€” given that `type` signals to the core that an object might have arbitrary additional properties â€” unknown properties will be retained in the returned value.
 
@@ -63,4 +63,4 @@ const [err, user] = validate(value, User)
 
 Validate `value`, returning a result tuple. If the value is invalid the first element will be a [`StructError`](./errors.md#structerror). Otherwise, the first element will be `undefined` and the second element will be a value that is guaranteed to match the struct.
 
-You can pass `{ coerce: true }` as the third argument to enable coercion of the input value. As well as pass `{ message: 'Your custom error message' }` to override the message of the [`StructError`](./errors.md#structerror).
+You can pass `{ coerce: true }` as the third argument to enable coercion of the input value.
diff --git a/docs/reference/errors.md b/docs/reference/errors.md
index 43582ab..d3ecb3f 100644
--- a/docs/reference/errors.md
+++ b/docs/reference/errors.md
@@ -28,7 +28,7 @@ Each error thrown includes the following properties:
 | `path`       | `Array<string \| number>`       | `['address', 'street']`                                                        | The path to the invalid value relative to the root value.                                                                                                                                                              |
 | `type`       | `string`                        | `'date'` / `'object'` / â€¦                                                      | The expected type of the invalid value. This is a string of the struct that failed validation (eg. `string`, `date`, `object`).                                                                                        |
 | `value`      | `any`                           | `false`                                                                        | The invalid value.                                                                                                                                                                                                     |
-| `cause`      | `string \| undefined`           | `Expected a string, but received: 42`                                          | If a custom message is specified, the original one will be preserved in this property (complies with [standard](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error/cause)).        |
+
 ### Multiple Errors
 
 The error thrown by Superstruct is always the first validation failure that was encountered, because this makes for convenient and simple logic in the majority of cases. However, the `failures` property is available with a list of all of the validation failures that occurred in case you want to add support for multiple error handling.
diff --git a/src/error.ts b/src/error.ts
index 663470d..e5b0f2f 100644
--- a/src/error.ts
+++ b/src/error.ts
@@ -8,7 +8,6 @@ export type Failure = {
   type: string
   refinement: string | undefined
   message: string
-  explanation?: string
   branch: Array<any>
   path: Array<any>
 }
@@ -34,12 +33,11 @@ export class StructError extends TypeError {
 
   constructor(failure: Failure, failures: () => Generator<Failure>) {
     let cached: Array<Failure> | undefined
-    const { message, explanation, ...rest } = failure
+    const { message, ...rest } = failure
     const { path } = failure
     const msg =
       path.length === 0 ? message : `At path: ${path.join('.')} -- ${message}`
-    super(explanation ?? msg)
-    if (explanation != null) this.cause = msg
+    super(msg)
     Object.assign(this, rest)
     this.name = this.constructor.name
     this.failures = () => {
diff --git a/src/struct.ts b/src/struct.ts
index b482fd3..c3ad533 100644
--- a/src/struct.ts
+++ b/src/struct.ts
@@ -64,16 +64,16 @@ export class Struct<T = unknown, S = unknown> {
    * Assert that a value passes the struct's validation, throwing if it doesn't.
    */
 
-  assert(value: unknown, message?: string): asserts value is T {
-    return assert(value, this, message)
+  assert(value: unknown): asserts value is T {
+    return assert(value, this)
   }
 
   /**
    * Create a value with the struct's coercion logic, then validate it.
    */
 
-  create(value: unknown, message?: string): T {
-    return create(value, this, message)
+  create(value: unknown): T {
+    return create(value, this)
   }
 
   /**
@@ -89,8 +89,8 @@ export class Struct<T = unknown, S = unknown> {
    * properties defined by the struct's schema.
    */
 
-  mask(value: unknown, message?: string): T {
-    return mask(value, this, message)
+  mask(value: unknown): T {
+    return mask(value, this)
   }
 
   /**
@@ -106,7 +106,6 @@ export class Struct<T = unknown, S = unknown> {
     value: unknown,
     options: {
       coerce?: boolean
-      message?: string
     } = {}
   ): [StructError, undefined] | [undefined, T] {
     return validate(value, this, options)
@@ -119,10 +118,9 @@ export class Struct<T = unknown, S = unknown> {
 
 export function assert<T, S>(
   value: unknown,
-  struct: Struct<T, S>,
-  message?: string
+  struct: Struct<T, S>
 ): asserts value is T {
-  const result = validate(value, struct, { message })
+  const result = validate(value, struct)
 
   if (result[0]) {
     throw result[0]
@@ -133,12 +131,8 @@ export function assert<T, S>(
  * Create a value with the coercion logic of struct and validate it.
  */
 
-export function create<T, S>(
-  value: unknown,
-  struct: Struct<T, S>,
-  message?: string
-): T {
-  const result = validate(value, struct, { coerce: true, message })
+export function create<T, S>(value: unknown, struct: Struct<T, S>): T {
+  const result = validate(value, struct, { coerce: true })
 
   if (result[0]) {
     throw result[0]
@@ -151,12 +145,8 @@ export function create<T, S>(
  * Mask a value, returning only the subset of properties defined by a struct.
  */
 
-export function mask<T, S>(
-  value: unknown,
-  struct: Struct<T, S>,
-  message?: string
-): T {
-  const result = validate(value, struct, { coerce: true, mask: true, message })
+export function mask<T, S>(value: unknown, struct: Struct<T, S>): T {
+  const result = validate(value, struct, { coerce: true, mask: true })
 
   if (result[0]) {
     throw result[0]
@@ -185,7 +175,6 @@ export function validate<T, S>(
   options: {
     coerce?: boolean
     mask?: boolean
-    message?: string
   } = {}
 ): [StructError, undefined] | [undefined, T] {
   const tuples = run(value, struct, options)
diff --git a/src/utils.ts b/src/utils.ts
index 6264dd0..0455b30 100644
--- a/src/utils.ts
+++ b/src/utils.ts
@@ -127,7 +127,6 @@ export function* run<T, S>(
     branch?: any[]
     coerce?: boolean
     mask?: boolean
-    message?: string
   } = {}
 ): IterableIterator<[Failure, undefined] | [undefined, T]> {
   const { path = [], branch = [value], coerce = false, mask = false } = options
@@ -154,7 +153,6 @@ export function* run<T, S>(
   let status: 'valid' | 'not_refined' | 'not_valid' = 'valid'
 
   for (const failure of struct.validator(value, ctx)) {
-    failure.explanation = options.message
     status = 'not_valid'
     yield [failure, undefined]
   }
@@ -165,7 +163,6 @@ export function* run<T, S>(
       branch: k === undefined ? branch : [...branch, v],
       coerce,
       mask,
-      message: options.message,
     })
 
     for (const t of ts) {
@@ -190,7 +187,6 @@ export function* run<T, S>(
 
   if (status !== 'not_valid') {
     for (const failure of struct.refiner(value as T, ctx)) {
-      failure.explanation = options.message
       status = 'not_refined'
       yield [failure, undefined]
     }
diff --git a/test/api/assert.ts b/test/api/assert.ts
index 65d55a5..756e9db 100644
--- a/test/api/assert.ts
+++ b/test/api/assert.ts
@@ -27,11 +27,4 @@ describe('assert', () => {
       string().assert(42)
     }, StructError)
   })
-
-  it('custom error message', () => {
-    throws(() => string().assert(42, 'Not a string!'), {
-      cause: 'Expected a string, but received: 42',
-      message: 'Not a string!',
-    })
-  })
 })
diff --git a/test/api/create.ts b/test/api/create.ts
index 873d30e..2bc466f 100644
--- a/test/api/create.ts
+++ b/test/api/create.ts
@@ -1,4 +1,4 @@
-import { strictEqual, deepEqual, deepStrictEqual, throws } from 'assert'
+import { strictEqual, deepEqual, deepStrictEqual } from 'assert'
 import {
   type,
   optional,
@@ -51,11 +51,4 @@ describe('create', () => {
       c: undefined,
     })
   })
-
-  it('custom error message', () => {
-    throws(() => string().create(42, 'Not a string!'), {
-      cause: 'Expected a string, but received: 42',
-      message: 'Not a string!',
-    })
-  })
 })
diff --git a/test/api/mask.ts b/test/api/mask.ts
index c054d97..f801caa 100644
--- a/test/api/mask.ts
+++ b/test/api/mask.ts
@@ -82,11 +82,4 @@ describe('mask', () => {
     deepStrictEqual(mask(value, S), { id: '1' })
     deepStrictEqual(value, { id: '1', unknown: true })
   })
-
-  it('custom error message', () => {
-    throws(() => string().mask(42, 'Not a string!'), {
-      cause: 'Expected a string, but received: 42',
-      message: 'Not a string!',
-    })
-  })
 })
diff --git a/test/api/validate.ts b/test/api/validate.ts
index cb6d878..2890d4b 100644
--- a/test/api/validate.ts
+++ b/test/api/validate.ts
@@ -34,7 +34,6 @@ describe('validate', () => {
         message: 'Expected a string, but received: 42',
         path: [],
         branch: [42],
-        explanation: undefined,
       },
     ])
   })
@@ -53,7 +52,6 @@ describe('validate', () => {
         message: 'Expected a string, but received: 42',
         path: [],
         branch: [42],
-        explanation: undefined,
       },
     ])
   })
@@ -67,13 +65,6 @@ describe('validate', () => {
     )
   })
 
-  it('custom error message', () => {
-    const S = string()
-    const [err] = S.validate(42, { message: 'Validation failed!' })
-    strictEqual(err?.message, 'Validation failed!')
-    strictEqual(err?.cause, 'Expected a string, but received: 42')
-  })
-
   it('early exit', () => {
     let ranA = false
     let ranB = false
