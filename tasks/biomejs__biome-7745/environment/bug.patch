diff --git a/.changeset/breezy-suns-leave.md b/.changeset/breezy-suns-leave.md
deleted file mode 100644
index 84f3fc9d48..0000000000
--- a/.changeset/breezy-suns-leave.md
+++ /dev/null
@@ -1,5 +0,0 @@
----
-"@biomejs/biome": minor
----
-
-Added `ignore` option to `noUnknownAtRules`. If an unknown at-rule matches any of the items provided in `ignore`, a diagnostic won't be emitted.
diff --git a/.changeset/stupid-groups-grow.md b/.changeset/stupid-groups-grow.md
new file mode 100644
index 0000000000..1a33f29217
--- /dev/null
+++ b/.changeset/stupid-groups-grow.md
@@ -0,0 +1,9 @@
+---
+"@biomejs/biome": minor
+---
+
+Added linting and assist support for `.html` files, with addition of two new configurations:
+- `html.linter.enabled`
+- `html.assist.enabled`
+
+The HTML linter, in this release, only contains the rule `noHeaderScope`. More rules will be released in the upcoming releases.
diff --git a/.changeset/upset-impalas-grab.md b/.changeset/upset-impalas-grab.md
new file mode 100644
index 0000000000..7a27e22c92
--- /dev/null
+++ b/.changeset/upset-impalas-grab.md
@@ -0,0 +1,12 @@
+---
+"@biomejs/biome": minor
+---
+
+Added **experimental** full support for HTML, Vue, Svelte and Astro files. In this release, the HTML parser
+has been enhanced, and it's now able to parse `.vue`, `.svelte` and `.astro` files.
+
+This means that now Biome is able to lint and format the JavaScript (TypeScript), HTML and CSS code that is contained in these files.
+
+Now that the main architecture is stable and working, in the upcoming patches and minors we will also fix possible inaccuracies and edge cases coming from existing lint rules, such as `noUnusedVariables` inside `<script>` blocks or frontmatter.
+
+The support is considered experimental because there might be cases that aren't fine-parsed yet, hence causing possible inaccuracies when it comes to formatting and linting.
diff --git a/.changeset/wise-forks-hide.md b/.changeset/wise-forks-hide.md
new file mode 100644
index 0000000000..a2a197e520
--- /dev/null
+++ b/.changeset/wise-forks-hide.md
@@ -0,0 +1,18 @@
+---
+"@biomejs/biome": minor
+---
+
+Added a new option called `html.interpolation`. This option enables the parsing of text expressions (or interpolation) in HTML files.
+
+The following `file.html` will be correctly formatted:
+
+```html
+<!-- file.html -->
+<div>
+  Hello {{ name }}!
+  <p>Your balance is: {{ account.balance }}</p>
+  <button>{{ isLoading ? "Loading..." : "Submit" }}</button>
+</div>
+```
+
+To note that `html.interpolation` only parses text expressions that are delimited by double curly braces (`{{ }}`). The content of expressions is parsed as normal text.
diff --git a/crates/biome_cli/src/execute/process_file.rs b/crates/biome_cli/src/execute/process_file.rs
index 019cf01c29..978d3c6465 100644
--- a/crates/biome_cli/src/execute/process_file.rs
+++ b/crates/biome_cli/src/execute/process_file.rs
@@ -197,14 +197,15 @@ pub(crate) fn process_file(ctx: &TraversalOptions, biome_path: &BiomePath) -> Fi
                 suppress,
                 suppression_reason.as_deref(),
                 categories.build(),
+                &file_features,
             )
         }
         TraversalMode::Format { .. } => {
             // the unsupported case should be handled already at this point
-            format(shared_context, biome_path.clone())
+            format(shared_context, biome_path.clone(), &file_features)
         }
         TraversalMode::Check { .. } | TraversalMode::CI { .. } => {
-            check_file(shared_context, biome_path.clone(), file_features)
+            check_file(shared_context, biome_path.clone(), &file_features)
         }
         TraversalMode::Migrate { .. } => {
             unreachable!("The migration should not be called for this file")
diff --git a/crates/biome_cli/src/execute/process_file/check.rs b/crates/biome_cli/src/execute/process_file/check.rs
index aef9c788c1..ff69d8162b 100644
--- a/crates/biome_cli/src/execute/process_file/check.rs
+++ b/crates/biome_cli/src/execute/process_file/check.rs
@@ -11,7 +11,7 @@ use biome_service::workspace::FeaturesSupported;
 pub(crate) fn check_file<'ctx>(
     ctx: &'ctx SharedTraversalOptions<'ctx, '_>,
     path: BiomePath,
-    file_features: FeaturesSupported,
+    file_features: &FeaturesSupported,
 ) -> FileResult {
     let mut has_failures = false;
     let mut workspace_file = WorkspaceFile::new(ctx, path)?;
@@ -34,8 +34,14 @@ pub(crate) fn check_file<'ctx>(
         categories = categories.with_assist();
     }
 
-    let analyzer_result =
-        analyze_with_guard(ctx, &mut workspace_file, false, None, categories.build());
+    let analyzer_result = analyze_with_guard(
+        ctx,
+        &mut workspace_file,
+        false,
+        None,
+        categories.build(),
+        file_features,
+    );
 
     let mut changed = false;
     // To reduce duplication of the same error on format and lint_and_assist
@@ -67,7 +73,7 @@ pub(crate) fn check_file<'ctx>(
         if ctx.execution.should_skip_parse_errors() && skipped_parse_error {
             // Parse errors are already skipped during the analyze phase, so no need to do it here.
         } else {
-            let format_result = format_with_guard(ctx, &mut workspace_file);
+            let format_result = format_with_guard(ctx, &mut workspace_file, file_features);
             match format_result {
                 Ok(status) => {
                     if status.is_changed() {
diff --git a/crates/biome_cli/src/execute/process_file/format.rs b/crates/biome_cli/src/execute/process_file/format.rs
index ce324721d3..c24f5aaf92 100644
--- a/crates/biome_cli/src/execute/process_file/format.rs
+++ b/crates/biome_cli/src/execute/process_file/format.rs
@@ -7,13 +7,17 @@ use biome_analyze::RuleCategoriesBuilder;
 use biome_diagnostics::{Diagnostic, DiagnosticExt, Error, Severity, category};
 use biome_fs::{BiomePath, TraversalContext};
 use biome_service::diagnostics::FileTooLarge;
-use biome_service::file_handlers::{AstroFileHandler, SvelteFileHandler, VueFileHandler};
+use biome_service::file_handlers::astro::AstroFileHandler;
+use biome_service::file_handlers::svelte::SvelteFileHandler;
+use biome_service::file_handlers::vue::VueFileHandler;
+use biome_service::workspace::FeaturesSupported;
 use tracing::{debug, instrument};
 
 #[instrument(name = "cli_format", level = "debug", skip(ctx, path))]
 pub(crate) fn format<'ctx>(
     ctx: &'ctx SharedTraversalOptions<'ctx, '_>,
     path: BiomePath,
+    features_supported: &FeaturesSupported,
 ) -> FileResult {
     let mut workspace_file = WorkspaceFile::new(ctx, path)?;
     let result = workspace_file.guard().check_file_size()?;
@@ -25,7 +29,7 @@ pub(crate) fn format<'ctx>(
         );
         Ok(FileStatus::Ignored)
     } else {
-        format_with_guard(ctx, &mut workspace_file)
+        format_with_guard(ctx, &mut workspace_file, features_supported)
     }
 }
 
@@ -33,6 +37,7 @@ pub(crate) fn format<'ctx>(
 pub(crate) fn format_with_guard<'ctx>(
     ctx: &'ctx SharedTraversalOptions<'ctx, '_>,
     workspace_file: &mut WorkspaceFile,
+    features_supported: &FeaturesSupported,
 ) -> FileResult {
     let diagnostics_result = workspace_file
         .guard()
@@ -87,27 +92,29 @@ pub(crate) fn format_with_guard<'ctx>(
 
     let mut output = printed.into_code();
 
-    match workspace_file.as_extension() {
-        Some("astro") => {
-            if output.is_empty() {
-                return Ok(FileStatus::Unchanged);
+    if !features_supported.supports_full_html_support() {
+        match workspace_file.as_extension() {
+            Some("astro") => {
+                if output.is_empty() {
+                    return Ok(FileStatus::Unchanged);
+                }
+                output = AstroFileHandler::output(input.as_str(), output.as_str());
             }
-            output = AstroFileHandler::output(input.as_str(), output.as_str());
-        }
-        Some("vue") => {
-            if output.is_empty() {
-                return Ok(FileStatus::Unchanged);
+            Some("vue") => {
+                if output.is_empty() {
+                    return Ok(FileStatus::Unchanged);
+                }
+                output = VueFileHandler::output(input.as_str(), output.as_str());
             }
-            output = VueFileHandler::output(input.as_str(), output.as_str());
-        }
 
-        Some("svelte") => {
-            if output.is_empty() {
-                return Ok(FileStatus::Unchanged);
+            Some("svelte") => {
+                if output.is_empty() {
+                    return Ok(FileStatus::Unchanged);
+                }
+                output = SvelteFileHandler::output(input.as_str(), output.as_str());
             }
-            output = SvelteFileHandler::output(input.as_str(), output.as_str());
+            _ => {}
         }
-        _ => {}
     }
 
     debug!("Format output is different from input: {}", output != input);
diff --git a/crates/biome_cli/src/execute/process_file/lint_and_assist.rs b/crates/biome_cli/src/execute/process_file/lint_and_assist.rs
index a025e4fcbe..21aacf6213 100644
--- a/crates/biome_cli/src/execute/process_file/lint_and_assist.rs
+++ b/crates/biome_cli/src/execute/process_file/lint_and_assist.rs
@@ -7,7 +7,10 @@ use biome_diagnostics::{Diagnostic, DiagnosticExt, Error, Severity, category};
 use biome_fs::{BiomePath, TraversalContext};
 use biome_rowan::TextSize;
 use biome_service::diagnostics::FileTooLarge;
-use biome_service::file_handlers::{AstroFileHandler, SvelteFileHandler, VueFileHandler};
+use biome_service::file_handlers::astro::AstroFileHandler;
+use biome_service::file_handlers::svelte::SvelteFileHandler;
+use biome_service::file_handlers::vue::VueFileHandler;
+use biome_service::workspace::FeaturesSupported;
 use tracing::{info, instrument};
 
 /// Lints a single file and returns a [FileResult]
@@ -18,6 +21,7 @@ pub(crate) fn lint_and_assist<'ctx>(
     suppress: bool,
     suppression_reason: Option<&str>,
     categories: RuleCategories,
+    features_supported: &FeaturesSupported,
 ) -> FileResult {
     let mut workspace_file = WorkspaceFile::new(ctx, path)?;
     let result = workspace_file.guard().check_file_size()?;
@@ -35,6 +39,7 @@ pub(crate) fn lint_and_assist<'ctx>(
             suppress,
             suppression_reason,
             categories,
+            features_supported,
         )
     }
 }
@@ -47,6 +52,7 @@ pub(crate) fn analyze_with_guard<'ctx>(
     suppress: bool,
     suppression_reason: Option<&str>,
     categories: RuleCategories,
+    features_supported: &FeaturesSupported,
 ) -> FileResult {
     let mut input = workspace_file.input()?;
     let mut changed = false;
@@ -91,17 +97,19 @@ pub(crate) fn analyze_with_guard<'ctx>(
 
         let mut output = fix_result.code;
 
-        match workspace_file.as_extension() {
-            Some("astro") => {
-                output = AstroFileHandler::output(input.as_str(), output.as_str());
+        if !features_supported.supports_full_html_support() {
+            match workspace_file.as_extension() {
+                Some("astro") => {
+                    output = AstroFileHandler::output(input.as_str(), output.as_str());
+                }
+                Some("vue") => {
+                    output = VueFileHandler::output(input.as_str(), output.as_str());
+                }
+                Some("svelte") => {
+                    output = SvelteFileHandler::output(input.as_str(), output.as_str());
+                }
+                _ => {}
             }
-            Some("vue") => {
-                output = VueFileHandler::output(input.as_str(), output.as_str());
-            }
-            Some("svelte") => {
-                output = SvelteFileHandler::output(input.as_str(), output.as_str());
-            }
-            _ => {}
         }
         if output != input {
             changed = true;
@@ -130,11 +138,15 @@ pub(crate) fn analyze_with_guard<'ctx>(
         && pull_diagnostics_result.skipped_diagnostics == 0;
 
     if !no_diagnostics {
-        let offset = match workspace_file.as_extension() {
-            Some("vue") => VueFileHandler::start(input.as_str()),
-            Some("astro") => AstroFileHandler::start(input.as_str()),
-            Some("svelte") => SvelteFileHandler::start(input.as_str()),
-            _ => None,
+        let offset = if features_supported.supports_full_html_support() {
+            None
+        } else {
+            match workspace_file.as_extension() {
+                Some("vue") => VueFileHandler::start(input.as_str()),
+                Some("astro") => AstroFileHandler::start(input.as_str()),
+                Some("svelte") => SvelteFileHandler::start(input.as_str()),
+                _ => None,
+            }
         };
 
         ctx.push_message(Message::Diagnostics {
diff --git a/crates/biome_cli/src/execute/process_file/search.rs b/crates/biome_cli/src/execute/process_file/search.rs
index d28078d8ba..65122f3c77 100644
--- a/crates/biome_cli/src/execute/process_file/search.rs
+++ b/crates/biome_cli/src/execute/process_file/search.rs
@@ -35,7 +35,7 @@ pub(crate) fn search_with_guard<'ctx>(
 ) -> FileResult {
     let _ = tracing::info_span!("Search ", path =? workspace_file.path).entered();
 
-    let file_source = DocumentFileSource::from_path(workspace_file.path.as_path());
+    let file_source = DocumentFileSource::from_path(workspace_file.path.as_path(), false);
     let pattern_language = match &_ctx.execution.traversal_mode {
         TraversalMode::Search {
             language: Some(pattern_language),
diff --git a/crates/biome_cli/src/execute/std_in.rs b/crates/biome_cli/src/execute/std_in.rs
index 1420358c88..6972f7750e 100644
--- a/crates/biome_cli/src/execute/std_in.rs
+++ b/crates/biome_cli/src/execute/std_in.rs
@@ -78,11 +78,15 @@ pub(crate) fn run<'a>(
             })?;
 
             let code = printed.into_code();
-            let output = match biome_path.extension() {
-                Some("astro") => AstroFileHandler::output(content, code.as_str()),
-                Some("vue") => VueFileHandler::output(content, code.as_str()),
-                Some("svelte") => SvelteFileHandler::output(content, code.as_str()),
-                _ => code,
+            let output = if !file_features.supports_full_html_support() {
+                match biome_path.extension() {
+                    Some("astro") => AstroFileHandler::output(content, code.as_str()),
+                    Some("vue") => VueFileHandler::output(content, code.as_str()),
+                    Some("svelte") => SvelteFileHandler::output(content, code.as_str()),
+                    _ => code,
+                }
+            } else {
+                code
             };
             console.append(markup! {
                 {output}
@@ -174,11 +178,15 @@ pub(crate) fn run<'a>(
                 rule_categories: rule_categories.build(),
             })?;
             let code = fix_file_result.code;
-            let output = match biome_path.extension() {
-                Some("astro") => AstroFileHandler::output(&new_content, code.as_str()),
-                Some("vue") => VueFileHandler::output(&new_content, code.as_str()),
-                Some("svelte") => SvelteFileHandler::output(&new_content, code.as_str()),
-                _ => code,
+            let output = if !file_features.supports_full_html_support() {
+                match biome_path.extension() {
+                    Some("astro") => AstroFileHandler::output(&new_content, code.as_str()),
+                    Some("vue") => VueFileHandler::output(&new_content, code.as_str()),
+                    Some("svelte") => SvelteFileHandler::output(&new_content, code.as_str()),
+                    _ => code,
+                }
+            } else {
+                code
             };
             if output != new_content {
                 version += 1;
@@ -198,11 +206,15 @@ pub(crate) fn run<'a>(
                 path: biome_path.clone(),
             })?;
             let code = printed.into_code();
-            let output = match biome_path.extension() {
-                Some("astro") => AstroFileHandler::output(&new_content, code.as_str()),
-                Some("vue") => VueFileHandler::output(&new_content, code.as_str()),
-                Some("svelte") => SvelteFileHandler::output(&new_content, code.as_str()),
-                _ => code,
+            let output = if !file_features.supports_full_html_support() {
+                match biome_path.extension() {
+                    Some("astro") => AstroFileHandler::output(&new_content, code.as_str()),
+                    Some("vue") => VueFileHandler::output(&new_content, code.as_str()),
+                    Some("svelte") => SvelteFileHandler::output(&new_content, code.as_str()),
+                    _ => code,
+                }
+            } else {
+                code
             };
             if (mode.is_safe_fixes_enabled() || mode.is_safe_and_unsafe_fixes_enabled())
                 && output != new_content
diff --git a/crates/biome_cli/tests/cases/handle_astro_files.rs b/crates/biome_cli/tests/cases/handle_astro_files.rs
index 12a3611b92..604dd4b998 100644
--- a/crates/biome_cli/tests/cases/handle_astro_files.rs
+++ b/crates/biome_cli/tests/cases/handle_astro_files.rs
@@ -13,34 +13,17 @@ statement ( ) ;
 ---
 <div></div>"#;
 
-const ASTRO_FILE_FORMATTED: &str = r#"---
-import { something } from "file.astro";
-
-statement();
----
-<div></div>"#;
-
 const ASTRO_FILE_DEBUGGER_BEFORE: &str = r#"---
 debugger;
 ---
 <div></div>"#;
 
-const ASTRO_FILE_DEBUGGER_AFTER: &str = r#"---
----
-<div></div>"#;
-
 const ASTRO_FILE_USELESS_RENAME_BEFORE: &str = r#"---
 import {a as a} from 'mod';
 export { a };
 ---
 <div></div>"#;
 
-const ASTRO_FILE_USELESS_RENAME_AFTER: &str = r#"---
-import {a} from 'mod';
-export { a };
----
-<div></div>"#;
-
 const ASTRO_FILE_IMPORTS_BEFORE: &str = r#"---
 import { getLocale } from "astro:i18n";
 import { Code } from "astro:components";
@@ -63,7 +46,7 @@ const ASTRO_FILE_CHECK_BEFORE: &str = r#"---
 import {a as a} from 'mod';
 import {    something } from "file.astro";
 debugger;
-statement ( ) ;
+something ( ) ;
 var foo: string = "";
 ---
 <div></div>"#;
@@ -204,6 +187,54 @@ fn lint_astro_files() {
     ));
 }
 
+#[test]
+fn full_support() {
+    let fs = MemoryFileSystem::default();
+    let mut console = BufferConsole::default();
+
+    fs.insert(
+        "biome.json".into(),
+        r#"{ "html": { "formatter": {"enabled": true}, "linter": {"enabled": true}, "experimentalFullSupportEnabled": true } }"#.as_bytes(),
+    );
+
+    let astro_file_path = Utf8Path::new("file.astro");
+    fs.insert(
+        astro_file_path.into(),
+        r#"---
+import z from "zod";
+import { sure } from "sure.js";
+import s from "src/utils";
+
+let schema = z.object().optional();
+schema + sure()
+---
+
+<html><head><title>Astro</title></head><body></body></html>
+
+<style>
+#id { font-family: comic-sans } .class { background: red}
+</style>
+"#
+        .as_bytes(),
+    );
+
+    let (fs, result) = run_cli(
+        fs,
+        &mut console,
+        Args::from(["check", "--write", "--unsafe", astro_file_path.as_str()].as_slice()),
+    );
+
+    assert!(result.is_err(), "run_cli returned {result:?}");
+
+    assert_cli_snapshot(SnapshotPayload::new(
+        module_path!(),
+        "full_support",
+        fs,
+        console,
+        result,
+    ));
+}
+
 #[test]
 fn lint_and_fix_astro_files() {
     let fs = MemoryFileSystem::default();
@@ -339,17 +370,6 @@ fn format_stdin_successfully() {
 
     assert!(result.is_ok(), "run_cli returned {result:?}");
 
-    let message = console
-        .out_buffer
-        .first()
-        .expect("Console should have written a message");
-
-    let content = markup_to_string(markup! {
-        {message.content}
-    });
-
-    assert_eq!(content, ASTRO_FILE_FORMATTED);
-
     assert_cli_snapshot(SnapshotPayload::new(
         module_path!(),
         "format_stdin_successfully",
@@ -374,17 +394,6 @@ fn format_stdin_write_successfully() {
 
     assert!(result.is_ok(), "run_cli returned {result:?}");
 
-    let message = console
-        .out_buffer
-        .first()
-        .expect("Console should have written a message");
-
-    let content = markup_to_string(markup! {
-        {message.content}
-    });
-
-    assert_eq!(content, ASTRO_FILE_FORMATTED);
-
     assert_cli_snapshot(SnapshotPayload::new(
         module_path!(),
         "format_stdin_write_successfully",
@@ -448,17 +457,6 @@ fn lint_stdin_write_successfully() {
 
     assert!(result.is_ok(), "run_cli returned {result:?}");
 
-    let message = console
-        .out_buffer
-        .first()
-        .expect("Console should have written a message");
-
-    let content = markup_to_string(markup! {
-        {message.content}
-    });
-
-    assert_eq!(content, ASTRO_FILE_USELESS_RENAME_AFTER);
-
     assert_cli_snapshot(SnapshotPayload::new(
         module_path!(),
         "lint_stdin_write_successfully",
@@ -494,17 +492,6 @@ fn lint_stdin_write_unsafe_successfully() {
 
     assert!(result.is_ok(), "run_cli returned {result:?}");
 
-    let message = console
-        .out_buffer
-        .first()
-        .expect("Console should have written a message");
-
-    let content = markup_to_string(markup! {
-        {message.content}
-    });
-
-    assert_eq!(content, ASTRO_FILE_DEBUGGER_AFTER);
-
     assert_cli_snapshot(SnapshotPayload::new(
         module_path!(),
         "lint_stdin_write_unsafe_successfully",
diff --git a/crates/biome_cli/tests/cases/handle_svelte_files.rs b/crates/biome_cli/tests/cases/handle_svelte_files.rs
index 6804469d0d..161bc3d36f 100644
--- a/crates/biome_cli/tests/cases/handle_svelte_files.rs
+++ b/crates/biome_cli/tests/cases/handle_svelte_files.rs
@@ -213,6 +213,107 @@ fn format_svelte_carriage_return_line_feed_files() {
     ));
 }
 
+#[test]
+fn full_support() {
+    let fs = MemoryFileSystem::default();
+    let mut console = BufferConsole::default();
+
+    fs.insert(
+        "biome.json".into(),
+        r#"{ "html": { "formatter": {"enabled": true}, "linter": {"enabled": true}, "experimentalFullSupportEnabled": true } }"#.as_bytes(),
+    );
+
+    let astro_file_path = Utf8Path::new("file.svelte");
+    fs.insert(
+        astro_file_path.into(),
+        r#"<script>
+import z from "zod";
+import { sure } from "sure.js";
+import s from "src/utils";
+
+let schema = z.object().optional();
+schema + sure()
+</script>
+
+<html><head><title>Svelte</title></head><body></body></html>
+
+<style>
+#id { font-family: comic-sans } .class { background: red}
+</style>
+"#
+        .as_bytes(),
+    );
+
+    let (fs, result) = run_cli(
+        fs,
+        &mut console,
+        Args::from(["check", "--write", "--unsafe", astro_file_path.as_str()].as_slice()),
+    );
+
+    assert!(result.is_err(), "run_cli returned {result:?}");
+
+    assert_cli_snapshot(SnapshotPayload::new(
+        module_path!(),
+        "full_support",
+        fs,
+        console,
+        result,
+    ));
+}
+
+#[test]
+fn full_support_ts() {
+    let fs = MemoryFileSystem::default();
+    let mut console = BufferConsole::default();
+
+    fs.insert(
+        "biome.json".into(),
+        r#"{ "html": { "formatter": {"enabled": true}, "linter": {"enabled": true}, "experimentalFullSupportEnabled": true } }"#.as_bytes(),
+    );
+
+    let astro_file_path = Utf8Path::new("file.svelte");
+    fs.insert(
+        astro_file_path.into(),
+        r#"<script lang="ts">
+import z from "zod";
+import { sure } from "sure.js";
+import s from "src/utils";
+
+interface Props {
+    title: string;
+}
+
+let schema = z.object().optional();
+schema + sure();
+const props: Props = { title: "Hello" };
+</script>
+
+<html><head><title>Svelte</title></head><body></body></html>
+
+<style>
+#id { font-family: comic-sans } .class { background: red}
+</style>
+"#
+        .as_bytes(),
+    );
+
+    let (fs, result) = run_cli(
+        fs,
+        &mut console,
+        Args::from(["check", "--write", "--unsafe", astro_file_path.as_str()].as_slice()),
+    );
+
+    assert!(result.is_err(), "run_cli returned {result:?}");
+
+    assert_cli_snapshot(SnapshotPayload::new(
+        module_path!(),
+        "full_support_ts",
+        fs,
+        console,
+        result,
+    ));
+}
+
 #[test]
 fn format_stdin_successfully() {
     let fs = MemoryFileSystem::default();
diff --git a/crates/biome_cli/tests/cases/handle_vue_files.rs b/crates/biome_cli/tests/cases/handle_vue_files.rs
index 764c9cea64..1c98fb509f 100644
--- a/crates/biome_cli/tests/cases/handle_vue_files.rs
+++ b/crates/biome_cli/tests/cases/handle_vue_files.rs
@@ -1,5 +1,5 @@
 use crate::run_cli;
-use crate::snap_test::{SnapshotPayload, assert_cli_snapshot, assert_file_contents};
+use crate::snap_test::{SnapshotPayload, assert_cli_snapshot};
 use biome_console::BufferConsole;
 use biome_fs::MemoryFileSystem;
 use bpaf::Args;
@@ -45,12 +45,6 @@ import * as vueUse from "vue-use";
 </script>
 <template></template>"#;
 
-const VUE_FILE_IMPORTS_AFTER: &str = r#"<script setup lang="ts">
-import * as vueUse from "vue-use";
-import Button from "./components/Button.vue";
-</script>
-<template></template>"#;
-
 const VUE_CARRIAGE_RETURN_LINE_FEED_FILE_UNFORMATTED: &str =
     "<script>\r\n  const a    = \"b\";\r\n</script>\r\n<template></template>";
 
@@ -107,8 +101,6 @@ fn format_vue_implicit_js_files() {
 
     assert!(result.is_err(), "run_cli returned {result:?}");
 
-    assert_file_contents(&fs, vue_file_path, VUE_IMPLICIT_JS_FILE_UNFORMATTED);
-
     assert_cli_snapshot(SnapshotPayload::new(
         module_path!(),
         "format_vue_implicit_js_files",
@@ -165,8 +157,6 @@ fn format_vue_explicit_js_files() {
 
     assert!(result.is_err(), "run_cli returned {result:?}");
 
-    assert_file_contents(&fs, vue_file_path, VUE_EXPLICIT_JS_FILE_UNFORMATTED);
-
     assert_cli_snapshot(SnapshotPayload::new(
         module_path!(),
         "format_vue_explicit_js_files",
@@ -220,8 +210,6 @@ fn format_empty_vue_js_files_write() {
 
     assert!(result.is_ok(), "run_cli returned {result:?}");
 
-    assert_file_contents(&fs, vue_file_path, "<template></template>");
-
     assert_cli_snapshot(SnapshotPayload::new(
         module_path!(),
         "format_empty_vue_js_files_write",
@@ -247,8 +235,6 @@ fn format_vue_ts_files() {
 
     assert!(result.is_err(), "run_cli returned {result:?}");
 
-    assert_file_contents(&fs, vue_file_path, VUE_TS_FILE_UNFORMATTED);
-
     assert_cli_snapshot(SnapshotPayload::new(
         module_path!(),
         "format_vue_ts_files",
@@ -299,8 +285,6 @@ fn format_empty_vue_ts_files_write() {
 
     assert!(result.is_ok(), "run_cli returned {result:?}");
 
-    assert_file_contents(&fs, vue_file_path, "<template></template>");
-
     assert_cli_snapshot(SnapshotPayload::new(
         module_path!(),
         "format_empty_vue_ts_files_write",
@@ -329,12 +313,6 @@ fn format_vue_carriage_return_line_feed_files() {
 
     assert!(result.is_err(), "run_cli returned {result:?}");
 
-    assert_file_contents(
-        &fs,
-        vue_file_path,
-        VUE_CARRIAGE_RETURN_LINE_FEED_FILE_UNFORMATTED,
-    );
-
     assert_cli_snapshot(SnapshotPayload::new(
         module_path!(),
         "format_vue_carriage_return_line_feed_files",
@@ -363,8 +341,6 @@ fn format_vue_generic_component_files() {
 
     assert!(result.is_err(), "run_cli returned {result:?}");
 
-    assert_file_contents(&fs, vue_file_path, VUE_GENERIC_COMPONENT_FILE_UNFORMATTED);
-
     assert_cli_snapshot(SnapshotPayload::new(
         module_path!(),
         "format_vue_generic_component_files",
@@ -448,8 +424,6 @@ fn sorts_imports_check() {
 
     assert!(result.is_err(), "run_cli returned {result:?}");
 
-    assert_file_contents(&fs, vue_file_path, VUE_FILE_IMPORTS_BEFORE);
-
     assert_cli_snapshot(SnapshotPayload::new(
         module_path!(),
         "sorts_imports_check",
@@ -484,8 +458,6 @@ fn sorts_imports_write() {
 
     assert!(result.is_ok(), "run_cli returned {result:?}");
 
-    assert_file_contents(&fs, vue_file_path, VUE_FILE_IMPORTS_AFTER);
-
     assert_cli_snapshot(SnapshotPayload::new(
         module_path!(),
         "sorts_imports_write",
@@ -495,6 +467,107 @@ fn sorts_imports_write() {
     ));
 }
 
+#[test]
+fn full_support() {
+    let fs = MemoryFileSystem::default();
+    let mut console = BufferConsole::default();
+
+    fs.insert(
+        "biome.json".into(),
+        r#"{ "html": { "formatter": {"enabled": true}, "linter": {"enabled": true}, "experimentalFullSupportEnabled": true } }"#.as_bytes(),
+    );
+
+    let astro_file_path = Utf8Path::new("file.vue");
+    fs.insert(
+        astro_file_path.into(),
+        r#"<script>
+import z from "zod";
+import { sure } from "sure.js";
+import s from "src/utils";
+
+let schema = z.object().optional();
+schema + sure()
+</script>
+
+<html><head><title>Svelte</title></head><body></body></html>
+
+<style>
+#id { font-family: comic-sans } .class { background: red}
+</style>
+"#
+        .as_bytes(),
+    );
+
+    let (fs, result) = run_cli(
+        fs,
+        &mut console,
+        Args::from(["check", "--write", "--unsafe", astro_file_path.as_str()].as_slice()),
+    );
+
+    assert!(result.is_err(), "run_cli returned {result:?}");
+
+    assert_cli_snapshot(SnapshotPayload::new(
+        module_path!(),
+        "full_support",
+        fs,
+        console,
+        result,
+    ));
+}
+
+#[test]
+fn full_support_ts() {
+    let fs = MemoryFileSystem::default();
+    let mut console = BufferConsole::default();
+
+    fs.insert(
+        "biome.json".into(),
+        r#"{ "html": { "formatter": {"enabled": true}, "linter": {"enabled": true}, "experimentalFullSupportEnabled": true } }"#.as_bytes(),
+    );
+
+    let astro_file_path = Utf8Path::new("file.vue");
+    fs.insert(
+        astro_file_path.into(),
+        r#"<script lang="ts">
+import z from "zod";
+import { sure } from "sure.js";
+import s from "src/utils";
+
+interface Props {
+    title: string;
+}
+
+let schema = z.object().optional();
+schema + sure();
+const props: Props = { title: "Hello" };
+</script>
+
+<html><head><title>Svelte</title></head><body></body></html>
+
+<style>
+#id { font-family: comic-sans } .class { background: red}
+</style>
+"#
+        .as_bytes(),
+    );
+
+    let (fs, result) = run_cli(
+        fs,
+        &mut console,
+        Args::from(["check", "--write", "--unsafe", astro_file_path.as_str()].as_slice()),
+    );
+
+    assert!(result.is_err(), "run_cli returned {result:?}");
+
+    assert_cli_snapshot(SnapshotPayload::new(
+        module_path!(),
+        "full_support_ts",
+        fs,
+        console,
+        result,
+    ));
+}
+
 #[test]
 fn format_stdin_successfully() {
     let fs = MemoryFileSystem::default();
@@ -719,8 +792,6 @@ fn vue_compiler_macros_as_globals() {
         Args::from(["lint", vue_file_path.as_str()].as_slice()),
     );
 
-    assert_file_contents(&fs, vue_file_path, VUE_TS_FILE_SETUP_GLOBALS);
-
     assert_cli_snapshot(SnapshotPayload::new(
         module_path!(),
         "vue_compiler_macros_as_globals",
diff --git a/crates/biome_cli/tests/cases/indent_script_and_style.rs b/crates/biome_cli/tests/cases/indent_script_and_style.rs
index 3c36d36c99..0220cb9e60 100644
--- a/crates/biome_cli/tests/cases/indent_script_and_style.rs
+++ b/crates/biome_cli/tests/cases/indent_script_and_style.rs
@@ -1,5 +1,5 @@
 use crate::run_cli;
-use crate::snap_test::{SnapshotPayload, assert_cli_snapshot, assert_file_contents};
+use crate::snap_test::{SnapshotPayload, assert_cli_snapshot};
 use biome_console::BufferConsole;
 use biome_fs::MemoryFileSystem;
 use bpaf::Args;
@@ -21,18 +21,6 @@ statement ( ) ;
 </script>
 <template></template>"#;
 
-const VUE_FILE_FORMATTED_INDENTED: &str = r#"<script>
-	import { something } from "file.vue";
-	statement();
-</script>
-<template></template>"#;
-
-const VUE_FILE_FORMATTED_UNINDENTED: &str = r#"<script>
-import { something } from "file.vue";
-statement();
-</script>
-<template></template>"#;
-
 #[test]
 fn unindent_vue_by_default() {
     let fs = MemoryFileSystem::default();
@@ -49,8 +37,6 @@ fn unindent_vue_by_default() {
 
     assert!(result.is_ok(), "run_cli returned {result:?}");
 
-    assert_file_contents(&fs, vue_file_path, VUE_FILE_FORMATTED_UNINDENTED);
-
     assert_cli_snapshot(SnapshotPayload::new(
         module_path!(),
         "unindent_vue_by_default",
@@ -83,8 +69,6 @@ fn indent_vue_by_cli() {
 
     assert!(result.is_ok(), "run_cli returned {result:?}");
 
-    assert_file_contents(&fs, vue_file_path, VUE_FILE_FORMATTED_INDENTED);
-
     assert_cli_snapshot(SnapshotPayload::new(
         module_path!(),
         "indent_vue_by_cli",
@@ -112,8 +96,6 @@ fn indent_vue_by_config() {
 
     assert!(result.is_ok(), "run_cli returned {result:?}");
 
-    assert_file_contents(&fs, vue_file_path, VUE_FILE_FORMATTED_INDENTED);
-
     assert_cli_snapshot(SnapshotPayload::new(
         module_path!(),
         "indent_vue_by_config",
@@ -129,18 +111,6 @@ statement ( ) ;
 </script>
 <div></div>"#;
 
-const SVELTE_FILE_FORMATTED_INDENTED: &str = r#"<script>
-	import { something } from "file.svelte";
-	statement();
-</script>
-<div></div>"#;
-
-const SVELTE_FILE_FORMATTED_UNINDENTED: &str = r#"<script>
-import { something } from "file.svelte";
-statement();
-</script>
-<div></div>"#;
-
 #[test]
 fn unindent_svelte_by_default() {
     let fs = MemoryFileSystem::default();
@@ -157,8 +127,6 @@ fn unindent_svelte_by_default() {
 
     assert!(result.is_ok(), "run_cli returned {result:?}");
 
-    assert_file_contents(&fs, svelte_file_path, SVELTE_FILE_FORMATTED_UNINDENTED);
-
     assert_cli_snapshot(SnapshotPayload::new(
         module_path!(),
         "indent_svelte_by_default",
@@ -191,8 +159,6 @@ fn indent_svelte_by_cli() {
 
     assert!(result.is_ok(), "run_cli returned {result:?}");
 
-    assert_file_contents(&fs, svelte_file_path, SVELTE_FILE_FORMATTED_INDENTED);
-
     assert_cli_snapshot(SnapshotPayload::new(
         module_path!(),
         "indent_svelte_by_cli",
@@ -220,8 +186,6 @@ fn indent_svelte_by_config() {
 
     assert!(result.is_ok(), "run_cli returned {result:?}");
 
-    assert_file_contents(&fs, svelte_file_path, SVELTE_FILE_FORMATTED_INDENTED);
-
     assert_cli_snapshot(SnapshotPayload::new(
         module_path!(),
         "indent_svelte_by_config",
diff --git a/crates/biome_cli/tests/commands/format.rs b/crates/biome_cli/tests/commands/format.rs
index 68478f8391..505fbad5d6 100644
--- a/crates/biome_cli/tests/commands/format.rs
+++ b/crates/biome_cli/tests/commands/format.rs
@@ -3061,8 +3061,6 @@ fn format_empty_svelte_js_files_write() {
 
     assert!(result.is_ok(), "run_cli returned {result:?}");
 
-    assert_file_contents(&fs, svelte_file_path, "<div></div>");
-
     assert_cli_snapshot(SnapshotPayload::new(
         module_path!(),
         "format_empty_svelte_js_files_write",
@@ -3146,8 +3144,6 @@ fn format_empty_svelte_ts_files_write() {
 
     assert!(result.is_ok(), "run_cli returned {result:?}");
 
-    assert_file_contents(&fs, svelte_file_path, "<script></script>");
-
     assert_cli_snapshot(SnapshotPayload::new(
         module_path!(),
         "format_empty_svelte_ts_files_write",
@@ -3419,9 +3415,8 @@ fn applies_custom_bracket_spacing_for_graphql() {
     ));
 }
 
-/// Change this when HTML formatting is enabled by default
 #[test]
-fn html_disabled_by_default() {
+fn html_enabled_by_default() {
     let fs = MemoryFileSystem::default();
     let mut console = BufferConsole::default();
 
@@ -3434,17 +3429,11 @@ fn html_disabled_by_default() {
         Args::from(["format", "--write", file_path.as_str()].as_slice()),
     );
 
-    assert!(result.is_err(), "run_cli returned {result:?}");
-    assert!(matches!(
-        result,
-        Err(biome_cli::CliDiagnostic::NoFilesWereProcessed(_))
-    ));
-
-    assert_file_contents(&fs, file_path, "<!DOCTYPE HTML>");
+    assert!(result.is_ok(), "run_cli returned {result:?}");
 
     assert_cli_snapshot(SnapshotPayload::new(
         module_path!(),
-        "html_disabled_by_default",
+        "html_enabled_by_default",
         fs,
         console,
         result,
diff --git a/crates/biome_cli/tests/snapshots/main_cases_handle_astro_files/check_stdin_successfully.snap b/crates/biome_cli/tests/snapshots/main_cases_handle_astro_files/check_stdin_successfully.snap
index 11f58f5080..ae06582d97 100644
--- a/crates/biome_cli/tests/snapshots/main_cases_handle_astro_files/check_stdin_successfully.snap
+++ b/crates/biome_cli/tests/snapshots/main_cases_handle_astro_files/check_stdin_successfully.snap
@@ -9,7 +9,7 @@ expression: redactor(content)
 import {a as a} from 'mod';
 import {    something } from "file.astro";
 debugger;
-statement ( ) ;
+something ( ) ;
 var foo: string = "";
 ---
 <div></div>
@@ -33,7 +33,7 @@ stdin ━━━━━━━━━━━━━━━━━━━━━━━━
 import {a as a} from 'mod';
 import {    something } from "file.astro";
 debugger;
-statement ( ) ;
+something ( ) ;
 var foo: string = "";
 ---
 <div></div>
diff --git a/crates/biome_cli/tests/snapshots/main_cases_handle_astro_files/check_stdin_write_successfully.snap b/crates/biome_cli/tests/snapshots/main_cases_handle_astro_files/check_stdin_write_successfully.snap
index eadc402d61..1a7599f26d 100644
--- a/crates/biome_cli/tests/snapshots/main_cases_handle_astro_files/check_stdin_write_successfully.snap
+++ b/crates/biome_cli/tests/snapshots/main_cases_handle_astro_files/check_stdin_write_successfully.snap
@@ -9,7 +9,7 @@ expression: redactor(content)
 import {a as a} from 'mod';
 import {    something } from "file.astro";
 debugger;
-statement ( ) ;
+something ( ) ;
 var foo: string = "";
 ---
 <div></div>
@@ -23,7 +23,7 @@ import { something } from "file.astro";
 import { a } from "mod";
 
 debugger;
-statement();
+something();
 var foo: string = "";
 ---
 <div></div>
diff --git a/crates/biome_cli/tests/snapshots/main_cases_handle_astro_files/check_stdin_write_unsafe_successfully.snap b/crates/biome_cli/tests/snapshots/main_cases_handle_astro_files/check_stdin_write_unsafe_successfully.snap
index 13196f4165..b1412d62ed 100644
--- a/crates/biome_cli/tests/snapshots/main_cases_handle_astro_files/check_stdin_write_unsafe_successfully.snap
+++ b/crates/biome_cli/tests/snapshots/main_cases_handle_astro_files/check_stdin_write_unsafe_successfully.snap
@@ -9,7 +9,7 @@ expression: redactor(content)
 import {a as a} from 'mod';
 import {    something } from "file.astro";
 debugger;
-statement ( ) ;
+something ( ) ;
 var foo: string = "";
 ---
 <div></div>
@@ -19,7 +19,9 @@ var foo: string = "";
 
 ```block
 ---
-statement();
+import { something } from "file.astro";
+
+something();
 var _foo: string = "";
 ---
 <div></div>
diff --git a/crates/biome_cli/tests/snapshots/main_cases_handle_astro_files/format_astro_carriage_return_line_feed_files.snap b/crates/biome_cli/tests/snapshots/main_cases_handle_astro_files/format_astro_carriage_return_line_feed_files.snap
index f55a27c641..0033e4387e 100644
--- a/crates/biome_cli/tests/snapshots/main_cases_handle_astro_files/format_astro_carriage_return_line_feed_files.snap
+++ b/crates/biome_cli/tests/snapshots/main_cases_handle_astro_files/format_astro_carriage_return_line_feed_files.snap
@@ -1,6 +1,6 @@
 ---
 source: crates/biome_cli/tests/snap_test.rs
-expression: content
+expression: redactor(content)
 ---
 ## `file.astro`
 
diff --git a/crates/biome_cli/tests/snapshots/main_cases_handle_astro_files/format_empty_astro_files_write.snap b/crates/biome_cli/tests/snapshots/main_cases_handle_astro_files/format_empty_astro_files_write.snap
index e89ea40892..824c6b4362 100644
--- a/crates/biome_cli/tests/snapshots/main_cases_handle_astro_files/format_empty_astro_files_write.snap
+++ b/crates/biome_cli/tests/snapshots/main_cases_handle_astro_files/format_empty_astro_files_write.snap
@@ -1,6 +1,6 @@
 ---
 source: crates/biome_cli/tests/snap_test.rs
-expression: content
+expression: redactor(content)
 ---
 ## `file.astro`
 
diff --git a/crates/biome_cli/tests/snapshots/main_cases_handle_astro_files/format_stdin_successfully.snap b/crates/biome_cli/tests/snapshots/main_cases_handle_astro_files/format_stdin_successfully.snap
index f35db9c9f4..e4f13aa7ff 100644
--- a/crates/biome_cli/tests/snapshots/main_cases_handle_astro_files/format_stdin_successfully.snap
+++ b/crates/biome_cli/tests/snapshots/main_cases_handle_astro_files/format_stdin_successfully.snap
@@ -1,6 +1,6 @@
 ---
 source: crates/biome_cli/tests/snap_test.rs
-expression: content
+expression: redactor(content)
 ---
 # Input messages
 
diff --git a/crates/biome_cli/tests/snapshots/main_cases_handle_astro_files/full_support.snap b/crates/biome_cli/tests/snapshots/main_cases_handle_astro_files/full_support.snap
new file mode 100644
index 0000000000..630710ed97
--- /dev/null
+++ b/crates/biome_cli/tests/snapshots/main_cases_handle_astro_files/full_support.snap
@@ -0,0 +1,84 @@
+---
+source: crates/biome_cli/tests/snap_test.rs
+expression: redactor(content)
+---
+## `biome.json`
+
+```json
+{
+  "html": {
+    "formatter": { "enabled": true },
+    "linter": { "enabled": true },
+    "experimentalFullSupportEnabled": true
+  }
+}
+```
+
+## `file.astro`
+
+```astro
+---
+import { sure } from "sure.js";
+import z from "zod";
+
+const schema = z.object().optional();
+schema + sure();
+---
+<html>
+	<head>
+		<title>Astro</title>
+	</head>
+	<body></body>
+</html>
+
+<style>
+#id {
+	font-family: comic-sans;
+}
+.class {
+	background: red;
+}
+</style>
+
+```
+
+# Termination Message
+
+```block
+check ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
+
+  × Some errors were emitted while running checks.
+  
+
+
+```
+
+# Emitted Messages
+
+```block
+file.astro:13:20 lint/a11y/useGenericFontNames ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
+
+  × Generic font family missing.
+  
+    12 │ <style>
+  > 13 │ #id { font-family: comic-sans } .class { background: red}
+       │                    ^^^^^^^^^^
+    14 │ </style>
+    15 │ 
+  
+  i Consider adding a generic font family as a fallback.
+  
+  i For examples and more information, see the MDN Web Docs
+  
+  - serif
+  - sans-serif
+  - monospace
+  - etc.
+  
+
+```
+
+```block
+Checked 1 file in <TIME>. Fixed 1 file.
+Found 1 error.
+```
diff --git a/crates/biome_cli/tests/snapshots/main_cases_handle_astro_files/lint_and_fix_astro_files.snap b/crates/biome_cli/tests/snapshots/main_cases_handle_astro_files/lint_and_fix_astro_files.snap
index 4aa0b34043..f90d5b6ed9 100644
--- a/crates/biome_cli/tests/snapshots/main_cases_handle_astro_files/lint_and_fix_astro_files.snap
+++ b/crates/biome_cli/tests/snapshots/main_cases_handle_astro_files/lint_and_fix_astro_files.snap
@@ -1,6 +1,6 @@
 ---
 source: crates/biome_cli/tests/snap_test.rs
-expression: content
+expression: redactor(content)
 ---
 ## `file.astro`
 
diff --git a/crates/biome_cli/tests/snapshots/main_cases_handle_astro_files/lint_astro_files.snap b/crates/biome_cli/tests/snapshots/main_cases_handle_astro_files/lint_astro_files.snap
index 3e17496446..572c72c540 100644
--- a/crates/biome_cli/tests/snapshots/main_cases_handle_astro_files/lint_astro_files.snap
+++ b/crates/biome_cli/tests/snapshots/main_cases_handle_astro_files/lint_astro_files.snap
@@ -1,6 +1,6 @@
 ---
 source: crates/biome_cli/tests/snap_test.rs
-expression: content
+expression: redactor(content)
 ---
 ## `file.astro`
 
diff --git a/crates/biome_cli/tests/snapshots/main_cases_handle_astro_files/lint_stdin_write_unsafe_successfully.snap b/crates/biome_cli/tests/snapshots/main_cases_handle_astro_files/lint_stdin_write_unsafe_successfully.snap
index b7f146f1f1..1d7e582f82 100644
--- a/crates/biome_cli/tests/snapshots/main_cases_handle_astro_files/lint_stdin_write_unsafe_successfully.snap
+++ b/crates/biome_cli/tests/snapshots/main_cases_handle_astro_files/lint_stdin_write_unsafe_successfully.snap
@@ -1,6 +1,6 @@
 ---
 source: crates/biome_cli/tests/snap_test.rs
-expression: content
+expression: redactor(content)
 ---
 # Input messages
 
diff --git a/crates/biome_cli/tests/snapshots/main_cases_handle_astro_files/sorts_imports_check.snap b/crates/biome_cli/tests/snapshots/main_cases_handle_astro_files/sorts_imports_check.snap
index e731a08d51..9140b7f914 100644
--- a/crates/biome_cli/tests/snapshots/main_cases_handle_astro_files/sorts_imports_check.snap
+++ b/crates/biome_cli/tests/snapshots/main_cases_handle_astro_files/sorts_imports_check.snap
@@ -1,7 +1,6 @@
 ---
 source: crates/biome_cli/tests/snap_test.rs
 expression: redactor(content)
-snapshot_kind: text
 ---
 ## `file.astro`
 
diff --git a/crates/biome_cli/tests/snapshots/main_cases_handle_astro_files/sorts_imports_write.snap b/crates/biome_cli/tests/snapshots/main_cases_handle_astro_files/sorts_imports_write.snap
index 37f6a314f2..04482f71c1 100644
--- a/crates/biome_cli/tests/snapshots/main_cases_handle_astro_files/sorts_imports_write.snap
+++ b/crates/biome_cli/tests/snapshots/main_cases_handle_astro_files/sorts_imports_write.snap
@@ -1,6 +1,6 @@
 ---
 source: crates/biome_cli/tests/snap_test.rs
-expression: content
+expression: redactor(content)
 ---
 ## `file.astro`
 
diff --git a/crates/biome_cli/tests/snapshots/main_cases_handle_svelte_files/full_support.snap b/crates/biome_cli/tests/snapshots/main_cases_handle_svelte_files/full_support.snap
new file mode 100644
index 0000000000..99a9ef12eb
--- /dev/null
+++ b/crates/biome_cli/tests/snapshots/main_cases_handle_svelte_files/full_support.snap
@@ -0,0 +1,85 @@
+---
+source: crates/biome_cli/tests/snap_test.rs
+expression: redactor(content)
+---
+## `biome.json`
+
+```json
+{
+  "html": {
+    "formatter": { "enabled": true },
+    "linter": { "enabled": true },
+    "experimentalFullSupportEnabled": true
+  }
+}
+```
+
+## `file.svelte`
+
+```svelte
+<script>
+import { sure } from "sure.js";
+import z from "zod";
+
+const schema = z.object().optional();
+schema + sure();
+</script>
+
+<html>
+	<head>
+		<title>Svelte</title>
+	</head>
+	<body></body>
+</html>
+
+<style>
+#id {
+	font-family: comic-sans;
+}
+.class {
+	background: red;
+}
+</style>
+
+```
+
+# Termination Message
+
+```block
+check ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
+
+  × Some errors were emitted while running checks.
+  
+
+
+```
+
+# Emitted Messages
+
+```block
+file.svelte:12:20 lint/a11y/useGenericFontNames ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
+
+  × Generic font family missing.
+  
+    11 │ <style>
+  > 12 │ #id { font-family: comic-sans } .class { background: red}
+       │                    ^^^^^^^^^^
+    13 │ </style>
+    14 │ 
+  
+  i Consider adding a generic font family as a fallback.
+  
+  i For examples and more information, see the MDN Web Docs
+  
+  - serif
+  - sans-serif
+  - monospace
+  - etc.
+  
+
+```
+
+```block
+Checked 1 file in <TIME>. Fixed 1 file.
+Found 1 error.
+```
diff --git a/crates/biome_cli/tests/snapshots/main_cases_handle_svelte_files/full_support_ts.snap b/crates/biome_cli/tests/snapshots/main_cases_handle_svelte_files/full_support_ts.snap
new file mode 100644
index 0000000000..7881c62ba9
--- /dev/null
+++ b/crates/biome_cli/tests/snapshots/main_cases_handle_svelte_files/full_support_ts.snap
@@ -0,0 +1,90 @@
+---
+source: crates/biome_cli/tests/snap_test.rs
+expression: redactor(content)
+---
+## `biome.json`
+
+```json
+{
+  "html": {
+    "formatter": { "enabled": true },
+    "linter": { "enabled": true },
+    "experimentalFullSupportEnabled": true
+  }
+}
+```
+
+## `file.svelte`
+
+```svelte
+<script lang="ts">
+import { sure } from "sure.js";
+import z from "zod";
+
+interface Props {
+	title: string;
+}
+
+const schema = z.object().optional();
+schema + sure();
+const _props: Props = { title: "Hello" };
+</script>
+
+<html>
+	<head>
+		<title>Svelte</title>
+	</head>
+	<body></body>
+</html>
+
+<style>
+#id {
+	font-family: comic-sans;
+}
+.class {
+	background: red;
+}
+</style>
+
+```
+
+# Termination Message
+
+```block
+check ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
+
+  × Some errors were emitted while running checks.
+  
+
+
+```
+
+# Emitted Messages
+
+```block
+file.svelte:17:20 lint/a11y/useGenericFontNames ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
+
+  × Generic font family missing.
+  
+    16 │ <style>
+  > 17 │ #id { font-family: comic-sans } .class { background: red}
+       │                    ^^^^^^^^^^
+    18 │ </style>
+    19 │ 
+  
+  i Consider adding a generic font family as a fallback.
+  
+  i For examples and more information, see the MDN Web Docs
+  
+  - serif
+  - sans-serif
+  - monospace
+  - etc.
+  
+
+```
+
+```block
+Checked 1 file in <TIME>. Fixed 1 file.
+Found 1 error.
+```
diff --git a/crates/biome_cli/tests/snapshots/main_cases_handle_svelte_files/lint_stdin_write_successfully.snap b/crates/biome_cli/tests/snapshots/main_cases_handle_svelte_files/lint_stdin_write_successfully.snap
index 84c51eb6a9..40619a1053 100644
--- a/crates/biome_cli/tests/snapshots/main_cases_handle_svelte_files/lint_stdin_write_successfully.snap
+++ b/crates/biome_cli/tests/snapshots/main_cases_handle_svelte_files/lint_stdin_write_successfully.snap
@@ -1,7 +1,6 @@
 ---
 source: crates/biome_cli/tests/snap_test.rs
-expression: content
-snapshot_kind: text
+expression: redactor(content)
 ---
 # Input messages
 
diff --git a/crates/biome_cli/tests/snapshots/main_cases_handle_svelte_files/sorts_imports_check.snap b/crates/biome_cli/tests/snapshots/main_cases_handle_svelte_files/sorts_imports_check.snap
index 9b22556301..41c27b373f 100644
--- a/crates/biome_cli/tests/snapshots/main_cases_handle_svelte_files/sorts_imports_check.snap
+++ b/crates/biome_cli/tests/snapshots/main_cases_handle_svelte_files/sorts_imports_check.snap
@@ -1,7 +1,6 @@
 ---
 source: crates/biome_cli/tests/snap_test.rs
 expression: redactor(content)
-snapshot_kind: text
 ---
 ## `file.svelte`
 
diff --git a/crates/biome_cli/tests/snapshots/main_cases_handle_vue_files/format_empty_vue_js_files_write.snap b/crates/biome_cli/tests/snapshots/main_cases_handle_vue_files/format_empty_vue_js_files_write.snap
index a863cdf105..52fd60cca9 100644
--- a/crates/biome_cli/tests/snapshots/main_cases_handle_vue_files/format_empty_vue_js_files_write.snap
+++ b/crates/biome_cli/tests/snapshots/main_cases_handle_vue_files/format_empty_vue_js_files_write.snap
@@ -1,6 +1,6 @@
 ---
 source: crates/biome_cli/tests/snap_test.rs
-expression: content
+expression: redactor(content)
 ---
 ## `file.vue`
 
diff --git a/crates/biome_cli/tests/snapshots/main_cases_handle_vue_files/format_empty_vue_ts_files_write.snap b/crates/biome_cli/tests/snapshots/main_cases_handle_vue_files/format_empty_vue_ts_files_write.snap
index a863cdf105..52fd60cca9 100644
--- a/crates/biome_cli/tests/snapshots/main_cases_handle_vue_files/format_empty_vue_ts_files_write.snap
+++ b/crates/biome_cli/tests/snapshots/main_cases_handle_vue_files/format_empty_vue_ts_files_write.snap
@@ -1,6 +1,6 @@
 ---
 source: crates/biome_cli/tests/snap_test.rs
-expression: content
+expression: redactor(content)
 ---
 ## `file.vue`
 
diff --git a/crates/biome_cli/tests/snapshots/main_cases_handle_vue_files/full_support.snap b/crates/biome_cli/tests/snapshots/main_cases_handle_vue_files/full_support.snap
new file mode 100644
index 0000000000..e9836d5bd5
--- /dev/null
+++ b/crates/biome_cli/tests/snapshots/main_cases_handle_vue_files/full_support.snap
@@ -0,0 +1,85 @@
+---
+source: crates/biome_cli/tests/snap_test.rs
+expression: redactor(content)
+---
+## `biome.json`
+
+```json
+{
+  "html": {
+    "formatter": { "enabled": true },
+    "linter": { "enabled": true },
+    "experimentalFullSupportEnabled": true
+  }
+}
+```
+
+## `file.vue`
+
+```vue
+<script>
+import { sure } from "sure.js";
+import z from "zod";
+
+const schema = z.object().optional();
+schema + sure();
+</script>
+
+<html>
+	<head>
+		<title>Svelte</title>
+	</head>
+	<body></body>
+</html>
+
+<style>
+#id {
+	font-family: comic-sans;
+}
+.class {
+	background: red;
+}
+</style>
+
+```
+
+# Termination Message
+
+```block
+check ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
+
+  × Some errors were emitted while running checks.
+  
+
+
+```
+
+# Emitted Messages
+
+```block
+file.vue:12:20 lint/a11y/useGenericFontNames ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
+
+  × Generic font family missing.
+  
+    11 │ <style>
+  > 12 │ #id { font-family: comic-sans } .class { background: red}
+       │                    ^^^^^^^^^^
+    13 │ </style>
+    14 │ 
+  
+  i Consider adding a generic font family as a fallback.
+  
+  i For examples and more information, see the MDN Web Docs
+  
+  - serif
+  - sans-serif
+  - monospace
+  - etc.
+  
+
+```
+
+```block
+Checked 1 file in <TIME>. Fixed 1 file.
+Found 1 error.
+```
diff --git a/crates/biome_cli/tests/snapshots/main_cases_handle_vue_files/full_support_ts.snap b/crates/biome_cli/tests/snapshots/main_cases_handle_vue_files/full_support_ts.snap
new file mode 100644
index 0000000000..f35c33f606
--- /dev/null
+++ b/crates/biome_cli/tests/snapshots/main_cases_handle_vue_files/full_support_ts.snap
@@ -0,0 +1,90 @@
+---
+source: crates/biome_cli/tests/snap_test.rs
+expression: redactor(content)
+---
+## `biome.json`
+
+```json
+{
+  "html": {
+    "formatter": { "enabled": true },
+    "linter": { "enabled": true },
+    "experimentalFullSupportEnabled": true
+  }
+}
+```
+
+## `file.vue`
+
+```vue
+<script lang="ts">
+import { sure } from "sure.js";
+import z from "zod";
+
+interface Props {
+	title: string;
+}
+
+const schema = z.object().optional();
+schema + sure();
+const _props: Props = { title: "Hello" };
+</script>
+
+<html>
+	<head>
+		<title>Svelte</title>
+	</head>
+	<body></body>
+</html>
+
+<style>
+#id {
+	font-family: comic-sans;
+}
+.class {
+	background: red;
+}
+</style>
+
+```
+
+# Termination Message
+
+```block
+check ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
+
+  × Some errors were emitted while running checks.
+  
+
+
+```
+
+# Emitted Messages
+
+```block
+file.vue:17:20 lint/a11y/useGenericFontNames ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
+
+  × Generic font family missing.
+  
+    16 │ <style>
+  > 17 │ #id { font-family: comic-sans } .class { background: red}
+       │                    ^^^^^^^^^^
+    18 │ </style>
+    19 │ 
+  
+  i Consider adding a generic font family as a fallback.
+  
+  i For examples and more information, see the MDN Web Docs
+  
+  - serif
+  - sans-serif
+  - monospace
+  - etc.
+  
+
+```
+
+```block
+Checked 1 file in <TIME>. Fixed 1 file.
+Found 1 error.
+```
diff --git a/crates/biome_cli/tests/snapshots/main_cases_handle_vue_files/lint_stdin_write_successfully.snap b/crates/biome_cli/tests/snapshots/main_cases_handle_vue_files/lint_stdin_write_successfully.snap
index 1d3412d134..4bb448cc15 100644
--- a/crates/biome_cli/tests/snapshots/main_cases_handle_vue_files/lint_stdin_write_successfully.snap
+++ b/crates/biome_cli/tests/snapshots/main_cases_handle_vue_files/lint_stdin_write_successfully.snap
@@ -1,7 +1,6 @@
 ---
 source: crates/biome_cli/tests/snap_test.rs
-expression: content
-snapshot_kind: text
+expression: redactor(content)
 ---
 # Input messages
 
diff --git a/crates/biome_cli/tests/snapshots/main_cases_handle_vue_files/sorts_imports_check.snap b/crates/biome_cli/tests/snapshots/main_cases_handle_vue_files/sorts_imports_check.snap
index ecd150cc83..6f4ad5095a 100644
--- a/crates/biome_cli/tests/snapshots/main_cases_handle_vue_files/sorts_imports_check.snap
+++ b/crates/biome_cli/tests/snapshots/main_cases_handle_vue_files/sorts_imports_check.snap
@@ -1,7 +1,6 @@
 ---
 source: crates/biome_cli/tests/snap_test.rs
 expression: redactor(content)
-snapshot_kind: text
 ---
 ## `file.vue`
 
diff --git a/crates/biome_cli/tests/snapshots/main_commands_format/format_empty_svelte_js_files_write.snap b/crates/biome_cli/tests/snapshots/main_commands_format/format_empty_svelte_js_files_write.snap
index 0967789e5a..bec248a1f0 100644
--- a/crates/biome_cli/tests/snapshots/main_commands_format/format_empty_svelte_js_files_write.snap
+++ b/crates/biome_cli/tests/snapshots/main_commands_format/format_empty_svelte_js_files_write.snap
@@ -1,6 +1,6 @@
 ---
 source: crates/biome_cli/tests/snap_test.rs
-expression: content
+expression: redactor(content)
 ---
 ## `file.svelte`
 
diff --git a/crates/biome_cli/tests/snapshots/main_commands_format/format_empty_svelte_ts_files_write.snap b/crates/biome_cli/tests/snapshots/main_commands_format/format_empty_svelte_ts_files_write.snap
index 38d54fd8b8..c89bfa4d1f 100644
--- a/crates/biome_cli/tests/snapshots/main_commands_format/format_empty_svelte_ts_files_write.snap
+++ b/crates/biome_cli/tests/snapshots/main_commands_format/format_empty_svelte_ts_files_write.snap
@@ -1,7 +1,6 @@
 ---
 source: crates/biome_cli/tests/snap_test.rs
 expression: redactor(content)
-snapshot_kind: text
 ---
 ## `file.svelte`
 
diff --git a/crates/biome_cli/tests/snapshots/main_commands_format/html_disabled_by_default.snap b/crates/biome_cli/tests/snapshots/main_commands_format/html_disabled_by_default.snap
deleted file mode 100644
index 43ad1adcb1..0000000000
--- a/crates/biome_cli/tests/snapshots/main_commands_format/html_disabled_by_default.snap
+++ /dev/null
@@ -1,32 +0,0 @@
----
-source: crates/biome_cli/tests/snap_test.rs
-expression: redactor(content)
----
-## `file.html`
-
-```html
-<!DOCTYPE HTML>
-```
-
-# Termination Message
-
-```block
-format ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
-
-  × No files were processed in the specified paths.
-  
-  i Check your biome.json or biome.jsonc to ensure the paths are not ignored by the configuration.
-  
-  i These paths were provided but ignored:
-  
-  - file.html
-  
-
-
-```
-
-# Emitted Messages
-
-```block
-Formatted 0 files in <TIME>. No fixes applied.
-```
diff --git a/crates/biome_cli/tests/snapshots/main_commands_format/html_enabled_by_default.snap b/crates/biome_cli/tests/snapshots/main_commands_format/html_enabled_by_default.snap
new file mode 100644
index 0000000000..9eb152938e
--- /dev/null
+++ b/crates/biome_cli/tests/snapshots/main_commands_format/html_enabled_by_default.snap
@@ -0,0 +1,16 @@
+---
+source: crates/biome_cli/tests/snap_test.rs
+expression: redactor(content)
+---
+## `file.html`
+
+```html
+<!DOCTYPE html>
+
+```
+
+# Emitted Messages
+
+```block
+Formatted 1 file in <TIME>. Fixed 1 file.
+```
diff --git a/crates/biome_configuration/src/analyzer/mod.rs b/crates/biome_configuration/src/analyzer/mod.rs
index a35685699b..653dece2ac 100644
--- a/crates/biome_configuration/src/analyzer/mod.rs
+++ b/crates/biome_configuration/src/analyzer/mod.rs
@@ -501,7 +501,7 @@ impl<'de> serde::Deserialize<'de> for AnalyzerSelector {
 #[cfg(feature = "schema")]
 impl schemars::JsonSchema for AnalyzerSelector {
     fn schema_name() -> String {
-        "Selector".to_string()
+        "AnalyzerSelector".to_string()
     }
     fn json_schema(generator: &mut schemars::r#gen::SchemaGenerator) -> schemars::schema::Schema {
         String::json_schema(generator)
diff --git a/crates/biome_configuration/src/html.rs b/crates/biome_configuration/src/html.rs
index ed2d83e716..3a4494ca70 100644
--- a/crates/biome_configuration/src/html.rs
+++ b/crates/biome_configuration/src/html.rs
@@ -9,6 +9,8 @@ use biome_html_formatter::context::{
 use bpaf::Bpaf;
 use serde::{Deserialize, Serialize};
 
+pub type ExperimentalFullSupportEnabled = Bool<false>;
+
 /// Options applied to HTML files
 #[derive(
     Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize, Bpaf, Deserializable, Merge,
@@ -16,6 +18,11 @@ use serde::{Deserialize, Serialize};
 #[cfg_attr(feature = "schema", derive(schemars::JsonSchema))]
 #[serde(rename_all = "camelCase", default, deny_unknown_fields)]
 pub struct HtmlConfiguration {
+    /// Enables full support for HTML, Vue, Svelte and Astro files.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    #[bpaf(hide)]
+    pub experimental_full_support_enabled: Option<ExperimentalFullSupportEnabled>,
+
     /// HTML parsing options
     #[bpaf(hide, pure(Default::default()))]
     #[serde(skip_serializing_if = "Option::is_none")]
@@ -37,8 +44,8 @@ pub struct HtmlConfiguration {
 }
 
 pub type HtmlFormatterEnabled = Bool<false>; // Keep it disabled by default while experimental.
-pub type HtmlLinterEnabled = Bool<false>;
-pub type HtmlAssistEnabled = Bool<false>;
+pub type HtmlLinterEnabled = Bool<true>;
+pub type HtmlAssistEnabled = Bool<true>;
 pub type HtmlParseInterpolation = Bool<false>;
 
 /// Options that changes how the HTML parser behaves
diff --git a/crates/biome_css_analyze/src/lint/suspicious/no_unknown_at_rules.rs b/crates/biome_css_analyze/src/lint/suspicious/no_unknown_at_rules.rs
index 169e8cdc62..254fb7b5c5 100644
--- a/crates/biome_css_analyze/src/lint/suspicious/no_unknown_at_rules.rs
+++ b/crates/biome_css_analyze/src/lint/suspicious/no_unknown_at_rules.rs
@@ -32,40 +32,14 @@ declare_lint_rule! {
     /// @charset 'UTF-8';
     /// ```
     ///
-     /// ```css
-     /// @media (max-width: 960px) {
-     ///   body {
-     ///     font-size: 13px;
-     ///   }
-     /// }
-     /// ```
-     ///
-     /// ## Options
-     ///
-     /// ### `ignore`
-     ///
-     /// A list of unknown at-rule names to ignore (case-insensitive).
-     ///
-     /// ```json,options
-     /// {
-     ///   "options": {
-     ///     "ignore": [
-     ///       "custom-at-rule",
-     ///       "my-custom-rule"
-     ///     ]
-     ///   }
-     /// }
-     /// ```
-     ///
-     /// #### Valid
-     ///
-     /// ```css,use_options
-     /// @custom-at-rule {}
-     /// @my-custom-rule {
-     ///   color: red;
-     /// }
-     /// ```
-     pub NoUnknownAtRules {
+    /// ```css
+    /// @media (max-width: 960px) {
+    ///   body {
+    ///     font-size: 13px;
+    ///   }
+    /// }
+    /// ```
+    pub NoUnknownAtRules {
         version: "2.0.0",
         name: "noUnknownAtRules",
         language: "css",
@@ -79,16 +53,6 @@ declare_node_union! {
   pub AnyUnknownAtRule = CssUnknownBlockAtRule | CssUnknownValueAtRule
 }
 
-/// Determines if the given unknown at-rule name should be ignored.
-fn should_ignore(name: &str, options: &NoUnknownAtRulesOptions) -> bool {
-    for ignore_pattern in &options.ignore {
-        if name.eq_ignore_ascii_case(ignore_pattern) {
-            return true;
-        }
-    }
-    false
-}
-
 pub struct NoUnknownAtRuleState {
     range: TextRange,
     name: String,
@@ -106,16 +70,9 @@ impl Rule for NoUnknownAtRules {
             AnyUnknownAtRule::CssUnknownBlockAtRule(rule) => rule.name().ok()?,
             AnyUnknownAtRule::CssUnknownValueAtRule(rule) => rule.name().ok()?,
         };
-        let name = rule.value_token().ok()?.text_trimmed().to_string();
-
-        // Check if this unknown at-rule should be ignored
-        if should_ignore(&name, ctx.options()) {
-            return None;
-        }
-
         Some(NoUnknownAtRuleState {
             range: rule.range(),
-            name,
+            name: rule.value_token().ok()?.text_trimmed().to_string(),
         })
     }
 
diff --git a/crates/biome_css_analyze/tests/specs/suspicious/noUnknownAtRules/valid_with_ignore.css b/crates/biome_css_analyze/tests/specs/suspicious/noUnknownAtRules/valid_with_ignore.css
deleted file mode 100644
index f70ee1f0ed..0000000000
--- a/crates/biome_css_analyze/tests/specs/suspicious/noUnknownAtRules/valid_with_ignore.css
+++ /dev/null
@@ -1,13 +0,0 @@
-/* should not generate diagnostics */
-
-/* These should be valid because they're in the ignore list */
-@custom-at-rule {}
-@MyCustomRule {
-  color: red;
-}
-@mycustomrule {
-  color: red;
-}
-@another-custom-rule {
-  font-size: 14px;
-}
\ No newline at end of file
diff --git a/crates/biome_css_analyze/tests/specs/suspicious/noUnknownAtRules/valid_with_ignore.css.snap b/crates/biome_css_analyze/tests/specs/suspicious/noUnknownAtRules/valid_with_ignore.css.snap
deleted file mode 100644
index f073d666a3..0000000000
--- a/crates/biome_css_analyze/tests/specs/suspicious/noUnknownAtRules/valid_with_ignore.css.snap
+++ /dev/null
@@ -1,20 +0,0 @@
----
-source: crates/biome_css_analyze/tests/spec_tests.rs
-expression: valid_with_ignore.css
----
-# Input
-```css
-/* should not generate diagnostics */
-
-/* These should be valid because they're in the ignore list */
-@custom-at-rule {}
-@MyCustomRule {
-  color: red;
-}
-@mycustomrule {
-  color: red;
-}
-@another-custom-rule {
-  font-size: 14px;
-}
-```
diff --git a/crates/biome_css_analyze/tests/specs/suspicious/noUnknownAtRules/valid_with_ignore.options.json b/crates/biome_css_analyze/tests/specs/suspicious/noUnknownAtRules/valid_with_ignore.options.json
deleted file mode 100644
index 8d757d9bfa..0000000000
--- a/crates/biome_css_analyze/tests/specs/suspicious/noUnknownAtRules/valid_with_ignore.options.json
+++ /dev/null
@@ -1,15 +0,0 @@
-{
-  "$schema": "../../../../../../packages/@biomejs/biome/configuration_schema.json",
-  "linter": {
-    "rules": {
-      "suspicious": {
-        "noUnknownAtRules": {
-          "level": "error",
-          "options": {
-            "ignore": ["custom-at-rule", "MyCustomRule", "another-custom-rule"]
-          }
-        }
-      }
-    }
-  }
-}
\ No newline at end of file
diff --git a/crates/biome_formatter_test/src/spec.rs b/crates/biome_formatter_test/src/spec.rs
index 480c592ced..d918e4ff51 100644
--- a/crates/biome_formatter_test/src/spec.rs
+++ b/crates/biome_formatter_test/src/spec.rs
@@ -280,9 +280,13 @@ where
                 panic!("Configuration is invalid");
             }
 
-            let format_language = self
-                .language
-                .to_format_language(&settings, &DocumentFileSource::from_path(input_file));
+            let format_language = self.language.to_format_language(
+                &settings,
+                &DocumentFileSource::from_path(
+                    input_file,
+                    settings.experimental_full_html_support_enabled(),
+                ),
+            );
 
             let (mut output_code, printed) = self.formatted(&parsed, format_language.clone());
 
diff --git a/crates/biome_html_factory/src/generated/node_factory.rs b/crates/biome_html_factory/src/generated/node_factory.rs
index baf4a7c301..224504a5da 100644
--- a/crates/biome_html_factory/src/generated/node_factory.rs
+++ b/crates/biome_html_factory/src/generated/node_factory.rs
@@ -6,37 +6,40 @@ use biome_html_syntax::{
     HtmlSyntaxToken as SyntaxToken, *,
 };
 use biome_rowan::AstNode;
-pub fn astro_frontmatter_element(
-    l_fence_token: SyntaxToken,
-    r_fence_token: SyntaxToken,
-) -> AstroFrontmatterElementBuilder {
-    AstroFrontmatterElementBuilder {
-        l_fence_token,
-        r_fence_token,
+pub fn astro_embedded_content() -> AstroEmbeddedContentBuilder {
+    AstroEmbeddedContentBuilder {
         content_token: None,
     }
 }
-pub struct AstroFrontmatterElementBuilder {
-    l_fence_token: SyntaxToken,
-    r_fence_token: SyntaxToken,
+pub struct AstroEmbeddedContentBuilder {
     content_token: Option<SyntaxToken>,
 }
-impl AstroFrontmatterElementBuilder {
+impl AstroEmbeddedContentBuilder {
     pub fn with_content_token(mut self, content_token: SyntaxToken) -> Self {
         self.content_token = Some(content_token);
         self
     }
-    pub fn build(self) -> AstroFrontmatterElement {
-        AstroFrontmatterElement::unwrap_cast(SyntaxNode::new_detached(
-            HtmlSyntaxKind::ASTRO_FRONTMATTER_ELEMENT,
-            [
-                Some(SyntaxElement::Token(self.l_fence_token)),
-                self.content_token.map(|token| SyntaxElement::Token(token)),
-                Some(SyntaxElement::Token(self.r_fence_token)),
-            ],
+    pub fn build(self) -> AstroEmbeddedContent {
+        AstroEmbeddedContent::unwrap_cast(SyntaxNode::new_detached(
+            HtmlSyntaxKind::ASTRO_EMBEDDED_CONTENT,
+            [self.content_token.map(|token| SyntaxElement::Token(token))],
         ))
     }
 }
+pub fn astro_frontmatter_element(
+    l_fence_token: SyntaxToken,
+    content: AstroEmbeddedContent,
+    r_fence_token: SyntaxToken,
+) -> AstroFrontmatterElement {
+    AstroFrontmatterElement::unwrap_cast(SyntaxNode::new_detached(
+        HtmlSyntaxKind::ASTRO_FRONTMATTER_ELEMENT,
+        [
+            Some(SyntaxElement::Token(l_fence_token)),
+            Some(SyntaxElement::Node(content.into_syntax())),
+            Some(SyntaxElement::Token(r_fence_token)),
+        ],
+    ))
+}
 pub fn html_attribute(name: HtmlAttributeName) -> HtmlAttributeBuilder {
     HtmlAttributeBuilder {
         name,
diff --git a/crates/biome_html_factory/src/generated/syntax_factory.rs b/crates/biome_html_factory/src/generated/syntax_factory.rs
index ff6a33d039..ea8791c8ef 100644
--- a/crates/biome_html_factory/src/generated/syntax_factory.rs
+++ b/crates/biome_html_factory/src/generated/syntax_factory.rs
@@ -21,6 +21,25 @@ impl SyntaxFactory for HtmlSyntaxFactory {
             | HTML_BOGUS_TEXT_EXPRESSION => {
                 RawSyntaxNode::new(kind, children.into_iter().map(Some))
             }
+            ASTRO_EMBEDDED_CONTENT => {
+                let mut elements = (&children).into_iter();
+                let mut slots: RawNodeSlots<1usize> = RawNodeSlots::default();
+                let mut current_element = elements.next();
+                if let Some(element) = &current_element
+                    && element.kind() == HTML_LITERAL
+                {
+                    slots.mark_present();
+                    current_element = elements.next();
+                }
+                slots.next_slot();
+                if current_element.is_some() {
+                    return RawSyntaxNode::new(
+                        ASTRO_EMBEDDED_CONTENT.to_bogus(),
+                        children.into_iter().map(Some),
+                    );
+                }
+                slots.into_node(ASTRO_EMBEDDED_CONTENT, children)
+            }
             ASTRO_FRONTMATTER_ELEMENT => {
                 let mut elements = (&children).into_iter();
                 let mut slots: RawNodeSlots<3usize> = RawNodeSlots::default();
@@ -33,7 +52,7 @@ impl SyntaxFactory for HtmlSyntaxFactory {
                 }
                 slots.next_slot();
                 if let Some(element) = &current_element
-                    && element.kind() == HTML_LITERAL
+                    && AstroEmbeddedContent::can_cast(element.kind())
                 {
                     slots.mark_present();
                     current_element = elements.next();
diff --git a/crates/biome_html_formatter/src/astro/auxiliary/embedded_content.rs b/crates/biome_html_formatter/src/astro/auxiliary/embedded_content.rs
new file mode 100644
index 0000000000..b89a03a45a
--- /dev/null
+++ b/crates/biome_html_formatter/src/astro/auxiliary/embedded_content.rs
@@ -0,0 +1,22 @@
+use crate::prelude::*;
+use biome_deserialize::TextRange;
+use biome_html_syntax::AstroEmbeddedContent;
+use biome_rowan::AstNode;
+#[derive(Debug, Clone, Default)]
+pub(crate) struct FormatAstroEmbeddedContent;
+impl FormatNodeRule<AstroEmbeddedContent> for FormatAstroEmbeddedContent {
+    fn fmt_fields(&self, node: &AstroEmbeddedContent, f: &mut HtmlFormatter) -> FormatResult<()> {
+        format_html_verbatim_node(node.syntax()).fmt(f)
+    }
+
+    fn embedded_node_range(
+        &self,
+        node: &AstroEmbeddedContent,
+        f: &mut HtmlFormatter,
+    ) -> Option<TextRange> {
+        if !f.context().should_delegate_fmt_embedded_nodes() {
+            return None;
+        }
+        Some(node.range())
+    }
+}
diff --git a/crates/biome_html_formatter/src/astro/auxiliary/frontmatter_element.rs b/crates/biome_html_formatter/src/astro/auxiliary/frontmatter_element.rs
index 059ec17452..5aaf99aebe 100644
--- a/crates/biome_html_formatter/src/astro/auxiliary/frontmatter_element.rs
+++ b/crates/biome_html_formatter/src/astro/auxiliary/frontmatter_element.rs
@@ -12,16 +12,12 @@ impl FormatNodeRule<AstroFrontmatterElement> for FormatAstroFrontmatterElement {
     ) -> FormatResult<()> {
         let AstroFrontmatterElementFields {
             l_fence_token,
-            content_token,
+            content,
             r_fence_token,
         } = node.as_fields();
 
         write!(f, [l_fence_token.format(), hard_line_break()])?;
-
-        if let Some(content_token) = content_token {
-            write!(f, [content_token.format(), hard_line_break()])?;
-        }
-
+        write!(f, [content.format(), hard_line_break()])?;
         write!(f, [r_fence_token.format()])?;
 
         Ok(())
diff --git a/crates/biome_html_formatter/src/astro/auxiliary/mod.rs b/crates/biome_html_formatter/src/astro/auxiliary/mod.rs
index e51bcc0e90..8eb6037e95 100644
--- a/crates/biome_html_formatter/src/astro/auxiliary/mod.rs
+++ b/crates/biome_html_formatter/src/astro/auxiliary/mod.rs
@@ -1,3 +1,4 @@
 //! This is a generated file. Don't modify it by hand! Run 'cargo codegen formatter' to re-generate the file.
 
+pub(crate) mod embedded_content;
 pub(crate) mod frontmatter_element;
diff --git a/crates/biome_html_formatter/src/generated.rs b/crates/biome_html_formatter/src/generated.rs
index d157094a37..d2ffc6624e 100644
--- a/crates/biome_html_formatter/src/generated.rs
+++ b/crates/biome_html_formatter/src/generated.rs
@@ -6,6 +6,44 @@ use crate::{
     AsFormat, FormatBogusNodeRule, FormatNodeRule, HtmlFormatContext, HtmlFormatter, IntoFormat,
 };
 use biome_formatter::{FormatOwnedWithRule, FormatRefWithRule, FormatResult, FormatRule};
+impl FormatRule<biome_html_syntax::AstroEmbeddedContent>
+    for crate::astro::auxiliary::embedded_content::FormatAstroEmbeddedContent
+{
+    type Context = HtmlFormatContext;
+    #[inline(always)]
+    fn fmt(
+        &self,
+        node: &biome_html_syntax::AstroEmbeddedContent,
+        f: &mut HtmlFormatter,
+    ) -> FormatResult<()> {
+        FormatNodeRule::<biome_html_syntax::AstroEmbeddedContent>::fmt(self, node, f)
+    }
+}
+impl AsFormat<HtmlFormatContext> for biome_html_syntax::AstroEmbeddedContent {
+    type Format<'a> = FormatRefWithRule<
+        'a,
+        biome_html_syntax::AstroEmbeddedContent,
+        crate::astro::auxiliary::embedded_content::FormatAstroEmbeddedContent,
+    >;
+    fn format(&self) -> Self::Format<'_> {
+        FormatRefWithRule::new(
+            self,
+            crate::astro::auxiliary::embedded_content::FormatAstroEmbeddedContent::default(),
+        )
+    }
+}
+impl IntoFormat<HtmlFormatContext> for biome_html_syntax::AstroEmbeddedContent {
+    type Format = FormatOwnedWithRule<
+        biome_html_syntax::AstroEmbeddedContent,
+        crate::astro::auxiliary::embedded_content::FormatAstroEmbeddedContent,
+    >;
+    fn into_format(self) -> Self::Format {
+        FormatOwnedWithRule::new(
+            self,
+            crate::astro::auxiliary::embedded_content::FormatAstroEmbeddedContent::default(),
+        )
+    }
+}
 impl FormatRule<biome_html_syntax::AstroFrontmatterElement>
     for crate::astro::auxiliary::frontmatter_element::FormatAstroFrontmatterElement
 {
diff --git a/crates/biome_html_parser/src/syntax/astro.rs b/crates/biome_html_parser/src/syntax/astro.rs
index b6a5809a49..26673a0818 100644
--- a/crates/biome_html_parser/src/syntax/astro.rs
+++ b/crates/biome_html_parser/src/syntax/astro.rs
@@ -1,7 +1,9 @@
 use crate::parser::HtmlParser;
 use crate::syntax::parse_error::expected_closed_fence;
 use crate::token_source::HtmlLexContext;
-use biome_html_syntax::HtmlSyntaxKind::{ASTRO_FRONTMATTER_ELEMENT, FENCE, HTML_LITERAL};
+use biome_html_syntax::HtmlSyntaxKind::{
+    ASTRO_EMBEDDED_CONTENT, ASTRO_FRONTMATTER_ELEMENT, FENCE, HTML_LITERAL,
+};
 use biome_html_syntax::T;
 use biome_parser::Parser;
 use biome_parser::prelude::ParsedSyntax;
@@ -18,11 +20,19 @@ pub(crate) fn parse_astro_fence(p: &mut HtmlParser) -> ParsedSyntax {
         let c = m.complete(p, ASTRO_FRONTMATTER_ELEMENT);
         return ParsedSyntax::Present(c);
     }
-    if p.at(HTML_LITERAL) {
-        p.bump_with_context(HTML_LITERAL, HtmlLexContext::AstroFencedCodeBlock);
-    }
+    parse_astro_embedded(p).ok();
     p.expect(T![---]);
 
     let c = m.complete(p, ASTRO_FRONTMATTER_ELEMENT);
     ParsedSyntax::Present(c)
 }
+
+pub(crate) fn parse_astro_embedded(p: &mut HtmlParser) -> ParsedSyntax {
+    if !p.at(HTML_LITERAL) {
+        return Absent;
+    }
+    let m = p.start();
+    p.bump_with_context(HTML_LITERAL, HtmlLexContext::AstroFencedCodeBlock);
+
+    ParsedSyntax::Present(m.complete(p, ASTRO_EMBEDDED_CONTENT))
+}
diff --git a/crates/biome_html_parser/tests/html_specs/error/astro/attribute_expression.astro.snap b/crates/biome_html_parser/tests/html_specs/error/astro/attribute_expression.astro.snap
index a371d16ed4..e4f6472744 100644
--- a/crates/biome_html_parser/tests/html_specs/error/astro/attribute_expression.astro.snap
+++ b/crates/biome_html_parser/tests/html_specs/error/astro/attribute_expression.astro.snap
@@ -22,7 +22,9 @@ HtmlRoot {
     bom_token: missing (optional),
     frontmatter: AstroFrontmatterElement {
         l_fence_token: FENCE@0..3 "---" [] [],
-        content_token: HTML_LITERAL@3..31 "const foo = \"lorem ipsum\";\n" [Newline("\n")] [],
+        content: AstroEmbeddedContent {
+            content_token: HTML_LITERAL@3..31 "const foo = \"lorem ipsum\";\n" [Newline("\n")] [],
+        },
         r_fence_token: FENCE@31..34 "---" [] [],
     },
     directive: missing (optional),
@@ -97,7 +99,8 @@ HtmlRoot {
   0: (empty)
   1: ASTRO_FRONTMATTER_ELEMENT@0..34
     0: FENCE@0..3 "---" [] []
-    1: HTML_LITERAL@3..31 "const foo = \"lorem ipsum\";\n" [Newline("\n")] []
+    1: ASTRO_EMBEDDED_CONTENT@3..31
+      0: HTML_LITERAL@3..31 "const foo = \"lorem ipsum\";\n" [Newline("\n")] []
     2: FENCE@31..34 "---" [] []
   2: (empty)
   3: HTML_ELEMENT_LIST@34..71
diff --git a/crates/biome_html_parser/tests/html_specs/error/frontmatter.html.snap b/crates/biome_html_parser/tests/html_specs/error/frontmatter.html.snap
index 59bae0bfa5..1e2dcdaa09 100644
--- a/crates/biome_html_parser/tests/html_specs/error/frontmatter.html.snap
+++ b/crates/biome_html_parser/tests/html_specs/error/frontmatter.html.snap
@@ -22,7 +22,9 @@ HtmlRoot {
     frontmatter: AstroBogusFrontmatter {
         items: [
             FENCE@0..3 "---" [] [],
-            HTML_LITERAL@3..16 "layout: foo\n" [Newline("\n")] [],
+            AstroEmbeddedContent {
+                content_token: HTML_LITERAL@3..16 "layout: foo\n" [Newline("\n")] [],
+            },
             FENCE@16..19 "---" [] [],
         ],
     },
@@ -81,7 +83,8 @@ HtmlRoot {
   0: (empty)
   1: ASTRO_BOGUS_FRONTMATTER@0..19
     0: FENCE@0..3 "---" [] []
-    1: HTML_LITERAL@3..16 "layout: foo\n" [Newline("\n")] []
+    1: ASTRO_EMBEDDED_CONTENT@3..16
+      0: HTML_LITERAL@3..16 "layout: foo\n" [Newline("\n")] []
     2: FENCE@16..19 "---" [] []
   2: (empty)
   3: HTML_ELEMENT_LIST@19..64
diff --git a/crates/biome_html_parser/tests/html_specs/error/frontmatter_bogus.html.snap b/crates/biome_html_parser/tests/html_specs/error/frontmatter_bogus.html.snap
index a0a87055fb..15f2d3a8b1 100644
--- a/crates/biome_html_parser/tests/html_specs/error/frontmatter_bogus.html.snap
+++ b/crates/biome_html_parser/tests/html_specs/error/frontmatter_bogus.html.snap
@@ -24,7 +24,9 @@ HtmlRoot {
     frontmatter: AstroBogusFrontmatter {
         items: [
             FENCE@0..3 "---" [] [],
-            HTML_LITERAL@3..20 "const b = \"bar\"\n" [Newline("\n")] [],
+            AstroEmbeddedContent {
+                content_token: HTML_LITERAL@3..20 "const b = \"bar\"\n" [Newline("\n")] [],
+            },
             FENCE@20..23 "---" [] [],
         ],
     },
@@ -100,7 +102,8 @@ HtmlRoot {
   0: (empty)
   1: ASTRO_BOGUS_FRONTMATTER@0..23
     0: FENCE@0..3 "---" [] []
-    1: HTML_LITERAL@3..20 "const b = \"bar\"\n" [Newline("\n")] []
+    1: ASTRO_EMBEDDED_CONTENT@3..20
+      0: HTML_LITERAL@3..20 "const b = \"bar\"\n" [Newline("\n")] []
     2: FENCE@20..23 "---" [] []
   2: (empty)
   3: HTML_ELEMENT_LIST@23..68
diff --git a/crates/biome_html_parser/tests/html_specs/error/missing_fence.astro.snap b/crates/biome_html_parser/tests/html_specs/error/missing_fence.astro.snap
index 5d48969638..8954e097dd 100644
--- a/crates/biome_html_parser/tests/html_specs/error/missing_fence.astro.snap
+++ b/crates/biome_html_parser/tests/html_specs/error/missing_fence.astro.snap
@@ -19,7 +19,7 @@ HtmlRoot {
     bom_token: missing (optional),
     frontmatter: AstroFrontmatterElement {
         l_fence_token: FENCE@0..3 "---" [] [],
-        content_token: missing (optional),
+        content: missing (required),
         r_fence_token: missing (required),
     },
     directive: missing (optional),
diff --git a/crates/biome_html_parser/tests/html_specs/ok/astro/attribute_expression.astro.snap b/crates/biome_html_parser/tests/html_specs/ok/astro/attribute_expression.astro.snap
index 1f43377eed..256d56051e 100644
--- a/crates/biome_html_parser/tests/html_specs/ok/astro/attribute_expression.astro.snap
+++ b/crates/biome_html_parser/tests/html_specs/ok/astro/attribute_expression.astro.snap
@@ -22,7 +22,9 @@ HtmlRoot {
     bom_token: missing (optional),
     frontmatter: AstroFrontmatterElement {
         l_fence_token: FENCE@0..3 "---" [] [],
-        content_token: HTML_LITERAL@3..31 "const foo = \"lorem ipsum\";\n" [Newline("\n")] [],
+        content: AstroEmbeddedContent {
+            content_token: HTML_LITERAL@3..31 "const foo = \"lorem ipsum\";\n" [Newline("\n")] [],
+        },
         r_fence_token: FENCE@31..34 "---" [] [],
     },
     directive: missing (optional),
@@ -94,7 +96,8 @@ HtmlRoot {
   0: (empty)
   1: ASTRO_FRONTMATTER_ELEMENT@0..34
     0: FENCE@0..3 "---" [] []
-    1: HTML_LITERAL@3..31 "const foo = \"lorem ipsum\";\n" [Newline("\n")] []
+    1: ASTRO_EMBEDDED_CONTENT@3..31
+      0: HTML_LITERAL@3..31 "const foo = \"lorem ipsum\";\n" [Newline("\n")] []
     2: FENCE@31..34 "---" [] []
   2: (empty)
   3: HTML_ELEMENT_LIST@34..73
diff --git a/crates/biome_html_parser/tests/html_specs/ok/with_fence.astro.snap b/crates/biome_html_parser/tests/html_specs/ok/with_fence.astro.snap
index 842ceebed5..fa935d1608 100644
--- a/crates/biome_html_parser/tests/html_specs/ok/with_fence.astro.snap
+++ b/crates/biome_html_parser/tests/html_specs/ok/with_fence.astro.snap
@@ -27,7 +27,9 @@ HtmlRoot {
     bom_token: missing (optional),
     frontmatter: AstroFrontmatterElement {
         l_fence_token: FENCE@0..3 "---" [] [],
-        content_token: HTML_LITERAL@3..33 "const hello = \"hello world\";\n" [Newline("\n")] [],
+        content: AstroEmbeddedContent {
+            content_token: HTML_LITERAL@3..33 "const hello = \"hello world\";\n" [Newline("\n")] [],
+        },
         r_fence_token: FENCE@33..36 "---" [] [],
     },
     directive: missing (optional),
@@ -150,7 +152,8 @@ HtmlRoot {
   0: (empty)
   1: ASTRO_FRONTMATTER_ELEMENT@0..36
     0: FENCE@0..3 "---" [] []
-    1: HTML_LITERAL@3..33 "const hello = \"hello world\";\n" [Newline("\n")] []
+    1: ASTRO_EMBEDDED_CONTENT@3..33
+      0: HTML_LITERAL@3..33 "const hello = \"hello world\";\n" [Newline("\n")] []
     2: FENCE@33..36 "---" [] []
   2: (empty)
   3: HTML_ELEMENT_LIST@36..140
diff --git a/crates/biome_html_syntax/src/element_ext.rs b/crates/biome_html_syntax/src/element_ext.rs
index 1252d40e0b..c3e08d5ef8 100644
--- a/crates/biome_html_syntax/src/element_ext.rs
+++ b/crates/biome_html_syntax/src/element_ext.rs
@@ -1,8 +1,8 @@
 use crate::{
-    AnyHtmlElement, HtmlAttribute, HtmlElement, HtmlSelfClosingElement, ScriptType,
-    inner_string_text,
+    AnyHtmlElement, AstroEmbeddedContent, HtmlAttribute, HtmlElement, HtmlEmbeddedContent,
+    HtmlSelfClosingElement, HtmlSyntaxToken, ScriptType, inner_string_text,
 };
-use biome_rowan::{AstNodeList, SyntaxResult, TokenText};
+use biome_rowan::{AstNodeList, SyntaxResult, TokenText, declare_node_union};
 
 /// https://html.spec.whatwg.org/#void-elements
 const VOID_ELEMENTS: &[&str] = &[
@@ -185,7 +185,7 @@ impl HtmlElement {
     }
 
     /// Returns `true` if the element is a `<script lang="ts">`
-    pub fn is_typescript_lang(&self) -> SyntaxResult<bool> {
+    pub fn is_typescript_lang(&self) -> bool {
         let is_script = self.is_script_tag();
         let lang_attribute = self.find_attribute_by_name("lang");
         let is_lang_typescript = lang_attribute.is_some_and(|attribute| {
@@ -199,7 +199,25 @@ impl HtmlElement {
                     text.eq_ignore_ascii_case("ts")
                 })
         });
-        Ok(is_script && is_lang_typescript)
+        is_script && is_lang_typescript
+    }
+
+    /// Returns `true` if the element is a `<style lang="sass">` or `<style lang="scss">`
+    pub fn is_sass_lang(&self) -> bool {
+        let is_style = self.is_style_tag();
+        let lang_attribute = self.find_attribute_by_name("lang");
+        let is_lang_typescript = lang_attribute.is_some_and(|attribute| {
+            attribute
+                .initializer()
+                .and_then(|initializer| initializer.value().ok())
+                .and_then(|value| value.as_html_string().cloned())
+                .and_then(|value| value.value_token().ok())
+                .is_some_and(|token| {
+                    let text = inner_string_text(&token);
+                    text.eq_ignore_ascii_case("sass") || text.eq_ignore_ascii_case("scss")
+                })
+        });
+        is_style && is_lang_typescript
     }
 }
 
@@ -268,3 +286,16 @@ mod tests {
         assert!(element.is_javascript_tag());
     }
 }
+
+declare_node_union! {
+    pub AnyEmbeddedContent = HtmlEmbeddedContent | AstroEmbeddedContent
+}
+
+impl AnyEmbeddedContent {
+    pub fn value_token(&self) -> Option<HtmlSyntaxToken> {
+        match self {
+            Self::HtmlEmbeddedContent(node) => node.value_token().ok(),
+            Self::AstroEmbeddedContent(node) => node.content_token(),
+        }
+    }
+}
diff --git a/crates/biome_html_syntax/src/file_source.rs b/crates/biome_html_syntax/src/file_source.rs
index 50662160bf..2328c417f8 100644
--- a/crates/biome_html_syntax/src/file_source.rs
+++ b/crates/biome_html_syntax/src/file_source.rs
@@ -133,7 +133,7 @@ impl HtmlFileSource {
         match language_id {
             "html" => Ok(Self::html()),
             "astro" => Ok(Self::astro()),
-            "vue" => Ok(Self::vue()),
+            "vuejs" | "vue" => Ok(Self::vue()),
             "svelte" => Ok(Self::svelte()),
             _ => Err(FileSourceError::UnknownLanguageId),
         }
diff --git a/crates/biome_html_syntax/src/generated/kind.rs b/crates/biome_html_syntax/src/generated/kind.rs
index 61a5270415..da52952ad0 100644
--- a/crates/biome_html_syntax/src/generated/kind.rs
+++ b/crates/biome_html_syntax/src/generated/kind.rs
@@ -42,6 +42,7 @@ pub enum HtmlSyntaxKind {
     HTML_SELF_CLOSING_TAG,
     HTML_ELEMENT,
     ASTRO_FRONTMATTER_ELEMENT,
+    ASTRO_EMBEDDED_CONTENT,
     HTML_OPENING_ELEMENT,
     HTML_CLOSING_ELEMENT,
     HTML_SELF_CLOSING_ELEMENT,
diff --git a/crates/biome_html_syntax/src/generated/macros.rs b/crates/biome_html_syntax/src/generated/macros.rs
index 71179950f5..5aec3e8bff 100644
--- a/crates/biome_html_syntax/src/generated/macros.rs
+++ b/crates/biome_html_syntax/src/generated/macros.rs
@@ -16,6 +16,10 @@ macro_rules! map_syntax_node {
     ($ node : expr , $ pattern : pat => $ body : expr) => {
         match $node {
             node => match $crate::HtmlSyntaxNode::kind(&node) {
+                $crate::HtmlSyntaxKind::ASTRO_EMBEDDED_CONTENT => {
+                    let $pattern = unsafe { $crate::AstroEmbeddedContent::new_unchecked(node) };
+                    $body
+                }
                 $crate::HtmlSyntaxKind::ASTRO_FRONTMATTER_ELEMENT => {
                     let $pattern = unsafe { $crate::AstroFrontmatterElement::new_unchecked(node) };
                     $body
diff --git a/crates/biome_html_syntax/src/generated/nodes.rs b/crates/biome_html_syntax/src/generated/nodes.rs
index 47922befd7..b6cbdab849 100644
--- a/crates/biome_html_syntax/src/generated/nodes.rs
+++ b/crates/biome_html_syntax/src/generated/nodes.rs
@@ -20,6 +20,41 @@ use std::fmt::{Debug, Formatter};
 #[doc = r" the slots are not statically known."]
 pub(crate) const SLOT_MAP_EMPTY_VALUE: u8 = u8::MAX;
 #[derive(Clone, PartialEq, Eq, Hash)]
+pub struct AstroEmbeddedContent {
+    pub(crate) syntax: SyntaxNode,
+}
+impl AstroEmbeddedContent {
+    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
+    #[doc = r""]
+    #[doc = r" # Safety"]
+    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
+    #[doc = r" or a match on [SyntaxNode::kind]"]
+    #[inline]
+    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
+        Self { syntax }
+    }
+    pub fn as_fields(&self) -> AstroEmbeddedContentFields {
+        AstroEmbeddedContentFields {
+            content_token: self.content_token(),
+        }
+    }
+    pub fn content_token(&self) -> Option<SyntaxToken> {
+        support::token(&self.syntax, 0usize)
+    }
+}
+impl Serialize for AstroEmbeddedContent {
+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
+    where
+        S: Serializer,
+    {
+        self.as_fields().serialize(serializer)
+    }
+}
+#[derive(Serialize)]
+pub struct AstroEmbeddedContentFields {
+    pub content_token: Option<SyntaxToken>,
+}
+#[derive(Clone, PartialEq, Eq, Hash)]
 pub struct AstroFrontmatterElement {
     pub(crate) syntax: SyntaxNode,
 }
@@ -36,15 +71,15 @@ impl AstroFrontmatterElement {
     pub fn as_fields(&self) -> AstroFrontmatterElementFields {
         AstroFrontmatterElementFields {
             l_fence_token: self.l_fence_token(),
-            content_token: self.content_token(),
+            content: self.content(),
             r_fence_token: self.r_fence_token(),
         }
     }
     pub fn l_fence_token(&self) -> SyntaxResult<SyntaxToken> {
         support::required_token(&self.syntax, 0usize)
     }
-    pub fn content_token(&self) -> Option<SyntaxToken> {
-        support::token(&self.syntax, 1usize)
+    pub fn content(&self) -> SyntaxResult<AstroEmbeddedContent> {
+        support::required_node(&self.syntax, 1usize)
     }
     pub fn r_fence_token(&self) -> SyntaxResult<SyntaxToken> {
         support::required_token(&self.syntax, 2usize)
@@ -61,7 +96,7 @@ impl Serialize for AstroFrontmatterElement {
 #[derive(Serialize)]
 pub struct AstroFrontmatterElementFields {
     pub l_fence_token: SyntaxResult<SyntaxToken>,
-    pub content_token: Option<SyntaxToken>,
+    pub content: SyntaxResult<AstroEmbeddedContent>,
     pub r_fence_token: SyntaxResult<SyntaxToken>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
@@ -970,6 +1005,56 @@ impl AnyHtmlTextExpression {
         }
     }
 }
+impl AstNode for AstroEmbeddedContent {
+    type Language = Language;
+    const KIND_SET: SyntaxKindSet<Language> =
+        SyntaxKindSet::from_raw(RawSyntaxKind(ASTRO_EMBEDDED_CONTENT as u16));
+    fn can_cast(kind: SyntaxKind) -> bool {
+        kind == ASTRO_EMBEDDED_CONTENT
+    }
+    fn cast(syntax: SyntaxNode) -> Option<Self> {
+        if Self::can_cast(syntax.kind()) {
+            Some(Self { syntax })
+        } else {
+            None
+        }
+    }
+    fn syntax(&self) -> &SyntaxNode {
+        &self.syntax
+    }
+    fn into_syntax(self) -> SyntaxNode {
+        self.syntax
+    }
+}
+impl std::fmt::Debug for AstroEmbeddedContent {
+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+        thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
+        let current_depth = DEPTH.get();
+        let result = if current_depth < 16 {
+            DEPTH.set(current_depth + 1);
+            f.debug_struct("AstroEmbeddedContent")
+                .field(
+                    "content_token",
+                    &support::DebugOptionalElement(self.content_token()),
+                )
+                .finish()
+        } else {
+            f.debug_struct("AstroEmbeddedContent").finish()
+        };
+        DEPTH.set(current_depth);
+        result
+    }
+}
+impl From<AstroEmbeddedContent> for SyntaxNode {
+    fn from(n: AstroEmbeddedContent) -> Self {
+        n.syntax
+    }
+}
+impl From<AstroEmbeddedContent> for SyntaxElement {
+    fn from(n: AstroEmbeddedContent) -> Self {
+        n.syntax.into()
+    }
+}
 impl AstNode for AstroFrontmatterElement {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
@@ -1002,10 +1087,7 @@ impl std::fmt::Debug for AstroFrontmatterElement {
                     "l_fence_token",
                     &support::DebugSyntaxResult(self.l_fence_token()),
                 )
-                .field(
-                    "content_token",
-                    &support::DebugOptionalElement(self.content_token()),
-                )
+                .field("content", &support::DebugSyntaxResult(self.content()))
                 .field(
                     "r_fence_token",
                     &support::DebugSyntaxResult(self.r_fence_token()),
@@ -2446,6 +2528,11 @@ impl std::fmt::Display for AnyHtmlTextExpression {
         std::fmt::Display::fmt(self.syntax(), f)
     }
 }
+impl std::fmt::Display for AstroEmbeddedContent {
+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+        std::fmt::Display::fmt(self.syntax(), f)
+    }
+}
 impl std::fmt::Display for AstroFrontmatterElement {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         std::fmt::Display::fmt(self.syntax(), f)
diff --git a/crates/biome_html_syntax/src/generated/nodes_mut.rs b/crates/biome_html_syntax/src/generated/nodes_mut.rs
index b20bd803d6..35e79229c0 100644
--- a/crates/biome_html_syntax/src/generated/nodes_mut.rs
+++ b/crates/biome_html_syntax/src/generated/nodes_mut.rs
@@ -3,6 +3,14 @@
 use crate::{HtmlSyntaxToken as SyntaxToken, generated::nodes::*};
 use biome_rowan::AstNode;
 use std::iter::once;
+impl AstroEmbeddedContent {
+    pub fn with_content_token(self, element: Option<SyntaxToken>) -> Self {
+        Self::unwrap_cast(
+            self.syntax
+                .splice_slots(0usize..=0usize, once(element.map(|element| element.into()))),
+        )
+    }
+}
 impl AstroFrontmatterElement {
     pub fn with_l_fence_token(self, element: SyntaxToken) -> Self {
         Self::unwrap_cast(
@@ -10,10 +18,10 @@ impl AstroFrontmatterElement {
                 .splice_slots(0usize..=0usize, once(Some(element.into()))),
         )
     }
-    pub fn with_content_token(self, element: Option<SyntaxToken>) -> Self {
+    pub fn with_content(self, element: AstroEmbeddedContent) -> Self {
         Self::unwrap_cast(
             self.syntax
-                .splice_slots(1usize..=1usize, once(element.map(|element| element.into()))),
+                .splice_slots(1usize..=1usize, once(Some(element.into_syntax().into()))),
         )
     }
     pub fn with_r_fence_token(self, element: SyntaxToken) -> Self {
diff --git a/crates/biome_js_analyze/tests/spec_tests.rs b/crates/biome_js_analyze/tests/spec_tests.rs
index c033e3e304..6dae00de38 100644
--- a/crates/biome_js_analyze/tests/spec_tests.rs
+++ b/crates/biome_js_analyze/tests/spec_tests.rs
@@ -6,11 +6,10 @@ use biome_diagnostics::advice::CodeSuggestionAdvice;
 use biome_fs::OsFileSystem;
 use biome_js_analyze::JsAnalyzerServices;
 use biome_js_parser::{JsParserOptions, parse};
-use biome_js_syntax::{AnyJsRoot, EmbeddingKind, JsFileSource, JsLanguage, ModuleKind};
+use biome_js_syntax::{AnyJsRoot, JsFileSource, JsLanguage, ModuleKind};
 use biome_package::PackageType;
 use biome_plugin_loader::AnalyzerGritPlugin;
 use biome_rowan::{AstNode, FileSourceError};
-use biome_service::file_handlers::VueFileHandler;
 use biome_test_utils::{
     CheckActionType, assert_diagnostics_expectation_comment, assert_errors_are_absent,
     code_fix_to_string, create_analyzer_options, diagnostic_to_string,
@@ -117,24 +116,10 @@ fn run_test(input: &'static str, _: &str, _: &str, _: &str) {
             return;
         };
 
-        // TODO: Remove once we have full support of vue files
-        // This is needed to set the language to TypeScript for Vue files
-        // because we can't do it in <script> definition in the current implementation.
-        let source_type = if source_type.as_embedding_kind().is_vue() {
-            JsFileSource::ts().with_embedding_kind(EmbeddingKind::Vue)
-        } else {
-            source_type
-        };
-        let input_code = if source_type.as_embedding_kind().is_vue() {
-            VueFileHandler::input(&input_code)
-        } else {
-            input_code.as_str()
-        };
-
         // if source_type.
         analyze_and_snap(
             &mut snapshot,
-            input_code,
+            &input_code,
             source_type,
             filter,
             file_name,
diff --git a/crates/biome_js_syntax/src/file_source.rs b/crates/biome_js_syntax/src/file_source.rs
index d07a264dfc..7bb3ca96d5 100644
--- a/crates/biome_js_syntax/src/file_source.rs
+++ b/crates/biome_js_syntax/src/file_source.rs
@@ -148,7 +148,8 @@ pub struct JsFileSource {
     variant: LanguageVariant,
     module_kind: ModuleKind,
     version: LanguageVersion,
-    /// Used to mark if the source is being used for an Astro, Svelte or Vue file
+    /// Used to mark if the JavaScript is embedded inside some particular files. This affects the parsing.
+    /// For example, if inside an Astro file, a top-level return statement is allowed.
     embedding_kind: EmbeddingKind,
 }
 
@@ -199,7 +200,6 @@ impl JsFileSource {
         }
     }
 
-    /// Astro file definition
     pub fn astro() -> Self {
         Self::ts().with_embedding_kind(EmbeddingKind::Astro)
     }
@@ -343,6 +343,7 @@ impl JsFileSource {
             "vue" => Ok(Self::vue()),
             // TODO: Remove once we have full support of svelte files
             "svelte" => Ok(Self::svelte()),
+
             _ => Err(FileSourceError::UnknownExtension),
         }
     }
@@ -372,7 +373,7 @@ impl JsFileSource {
             // TODO: Remove once we have full support of astro files
             "astro" => Ok(Self::astro()),
             // TODO: Remove once we have full support of vue files
-            "vue" => Ok(Self::vue()),
+            "vue" | "vuejs" => Ok(Self::vue()),
             // TODO: Remove once we have full support of svelte files
             "svelte" => Ok(Self::svelte()),
             _ => Err(FileSourceError::UnknownLanguageId),
diff --git a/crates/biome_lsp/src/handlers/analysis.rs b/crates/biome_lsp/src/handlers/analysis.rs
index b36b0d03a3..6fb7620df4 100644
--- a/crates/biome_lsp/src/handlers/analysis.rs
+++ b/crates/biome_lsp/src/handlers/analysis.rs
@@ -14,7 +14,9 @@ use biome_line_index::LineIndex;
 use biome_lsp_converters::from_proto;
 use biome_rowan::{TextRange, TextSize};
 use biome_service::WorkspaceError;
-use biome_service::file_handlers::{AstroFileHandler, SvelteFileHandler, VueFileHandler};
+use biome_service::file_handlers::astro::AstroFileHandler;
+use biome_service::file_handlers::svelte::SvelteFileHandler;
+use biome_service::file_handlers::vue::VueFileHandler;
 use biome_service::workspace::{
     CheckFileSizeParams, FeaturesBuilder, FileFeaturesResult, FixFileMode, FixFileParams,
     GetFileContentParams, IgnoreKind, PathIsIgnoredParams, PullActionsParams,
@@ -124,6 +126,7 @@ pub(crate) fn code_actions(
         Some("svelte") => SvelteFileHandler::start(content.as_str()),
         _ => None,
     };
+
     let cursor_range = from_proto::text_range(&doc.line_index, params.range, position_encoding)
         .with_context(|| {
             format!(
@@ -145,7 +148,6 @@ pub(crate) fn code_actions(
     } else {
         cursor_range
     };
-
     debug!("Cursor range {:?}", &cursor_range);
     let result = match session.workspace.pull_actions(PullActionsParams {
         project_key: doc.project_key,
@@ -181,7 +183,7 @@ pub(crate) fn code_actions(
     // document if the action category "source.fixAll" was explicitly requested
     // by the language client
     let fix_all = if has_fix_all {
-        fix_all(session, &url, path, &doc.line_index, &diagnostics, offset)?
+        fix_all(session, &url, path, &doc.line_index, &diagnostics, None)?
     } else {
         None
     };
@@ -241,7 +243,6 @@ pub(crate) fn code_actions(
                 position_encoding,
                 &diagnostics,
                 action,
-                offset,
             )
             .ok()?;
 
@@ -354,24 +355,26 @@ fn fix_all(
         suppression_reason: None,
         rule_categories: categories.build(),
     })?;
-
-    let output = match path.as_path().extension() {
-        Some(extension) => {
-            let input = session.workspace.get_file_content(GetFileContentParams {
-                project_key: doc.project_key,
-                path: path.clone(),
-            })?;
-            match extension {
-                "astro" => AstroFileHandler::output(input.as_str(), fixed.code.as_str()),
-                "vue" => VueFileHandler::output(input.as_str(), fixed.code.as_str()),
-                "svelte" => SvelteFileHandler::output(input.as_str(), fixed.code.as_str()),
-                _ => fixed.code,
+    let output = if file_features.supports_full_html_support() {
+        fixed.code
+    } else {
+        match path.as_path().extension() {
+            Some(extension) => {
+                let input = session.workspace.get_file_content(GetFileContentParams {
+                    project_key: doc.project_key,
+                    path: path.clone(),
+                })?;
+                match extension {
+                    "astro" => AstroFileHandler::output(input.as_str(), fixed.code.as_str()),
+                    "vue" => VueFileHandler::output(input.as_str(), fixed.code.as_str()),
+                    "svelte" => SvelteFileHandler::output(input.as_str(), fixed.code.as_str()),
+                    _ => fixed.code,
+                }
             }
-        }
 
-        _ => fixed.code,
+            _ => fixed.code,
+        }
     };
-
     if fixed.actions.is_empty() {
         return Ok(None);
     }
diff --git a/crates/biome_lsp/src/handlers/formatting.rs b/crates/biome_lsp/src/handlers/formatting.rs
index 29cb47a5ec..c039ab4da2 100644
--- a/crates/biome_lsp/src/handlers/formatting.rs
+++ b/crates/biome_lsp/src/handlers/formatting.rs
@@ -5,7 +5,9 @@ use anyhow::Context;
 use biome_fs::BiomePath;
 use biome_lsp_converters::from_proto;
 use biome_rowan::{TextLen, TextRange, TextSize};
-use biome_service::file_handlers::{AstroFileHandler, SvelteFileHandler, VueFileHandler};
+use biome_service::file_handlers::astro::AstroFileHandler;
+use biome_service::file_handlers::svelte::SvelteFileHandler;
+use biome_service::file_handlers::vue::VueFileHandler;
 use biome_service::workspace::{
     CheckFileSizeParams, FeaturesBuilder, FeaturesSupported, FileFeaturesResult, FormatFileParams,
     FormatOnTypeParams, FormatRangeParams, GetFileContentParams, IgnoreKind, PathIsIgnoredParams,
@@ -76,17 +78,19 @@ pub(crate) fn format(
         if output.is_empty() {
             return Ok(None);
         }
-        match path.extension() {
-            Some("astro") => {
-                output = AstroFileHandler::output(input.as_str(), output.as_str());
+        if !file_features.supports_full_html_support() {
+            match path.extension() {
+                Some("astro") => {
+                    output = AstroFileHandler::output(input.as_str(), output.as_str());
+                }
+                Some("vue") => {
+                    output = VueFileHandler::output(input.as_str(), output.as_str());
+                }
+                Some("svelte") => {
+                    output = SvelteFileHandler::output(input.as_str(), output.as_str());
+                }
+                _ => {}
             }
-            Some("vue") => {
-                output = VueFileHandler::output(input.as_str(), output.as_str());
-            }
-            Some("svelte") => {
-                output = SvelteFileHandler::output(input.as_str(), output.as_str());
-            }
-            _ => {}
         }
 
         let indels = biome_text_edit::TextEdit::from_unicode_words(input.as_str(), output.as_str());
@@ -161,6 +165,7 @@ pub(crate) fn format_range(
             project_key: doc.project_key,
             path: path.clone(),
         })?;
+
         let offset = match path.extension() {
             Some("vue") => VueFileHandler::start(content.as_str()),
             Some("astro") => AstroFileHandler::start(content.as_str()),
diff --git a/crates/biome_lsp/src/server.tests.rs b/crates/biome_lsp/src/server.tests.rs
index f68b83e857..5c711f7ce3 100644
--- a/crates/biome_lsp/src/server.tests.rs
+++ b/crates/biome_lsp/src/server.tests.rs
@@ -4040,7 +4040,8 @@ let useConst = "Astro Test";
                 r#"---
 const useConst = "Astro Test";
 ---
-<!doctype html>"#,
+<!doctype html>
+"#,
             ),
         }],
     );
diff --git a/crates/biome_lsp/src/session.rs b/crates/biome_lsp/src/session.rs
index 26ffd208b6..82cd9c9c4b 100644
--- a/crates/biome_lsp/src/session.rs
+++ b/crates/biome_lsp/src/session.rs
@@ -16,11 +16,10 @@ use biome_service::WorkspaceError;
 use biome_service::configuration::{
     LoadedConfiguration, ProjectScanComputer, load_configuration, load_editorconfig,
 };
-use biome_service::file_handlers::{AstroFileHandler, SvelteFileHandler, VueFileHandler};
 use biome_service::projects::ProjectKey;
 use biome_service::workspace::{
-    FeaturesBuilder, GetFileContentParams, OpenProjectParams, OpenProjectResult,
-    PullDiagnosticsParams, SupportsFeatureParams,
+    FeaturesBuilder, OpenProjectParams, OpenProjectResult, PullDiagnosticsParams,
+    SupportsFeatureParams,
 };
 use biome_service::workspace::{FileFeaturesResult, ServiceNotification};
 use biome_service::workspace::{RageEntry, RageParams, RageResult, UpdateSettingsParams};
@@ -447,17 +446,6 @@ impl Session {
                 pull_code_actions: false,
             })?;
 
-            let content = self.workspace.get_file_content(GetFileContentParams {
-                project_key: doc.project_key,
-                path: biome_path.clone(),
-            })?;
-            let offset = match biome_path.extension() {
-                Some("vue") => VueFileHandler::start(content.as_str()),
-                Some("astro") => AstroFileHandler::start(content.as_str()),
-                Some("svelte") => SvelteFileHandler::start(content.as_str()),
-                _ => None,
-            };
-
             result
                 .diagnostics
                 .into_iter()
@@ -467,7 +455,7 @@ impl Session {
                         &url,
                         &doc.line_index,
                         self.position_encoding(),
-                        offset,
+                        None,
                     ) {
                         Ok(diag) => Some(diag),
                         Err(err) => {
diff --git a/crates/biome_lsp/src/utils.rs b/crates/biome_lsp/src/utils.rs
index 051ce45571..57b442bc09 100644
--- a/crates/biome_lsp/src/utils.rs
+++ b/crates/biome_lsp/src/utils.rs
@@ -100,7 +100,6 @@ pub(crate) fn code_fix_to_lsp(
     position_encoding: PositionEncoding,
     diagnostics: &[lsp::Diagnostic],
     action: CodeAction,
-    offset: Option<u32>,
 ) -> Result<lsp::CodeAction> {
     // Mark diagnostics emitted by the same rule as resolved by this action
     let diagnostics: Vec<_> = action
@@ -135,6 +134,7 @@ pub(crate) fn code_fix_to_lsp(
     let suggestion = action.suggestion;
 
     let mut changes = HashMap::new();
+    let offset = action.offset.map(u32::from);
     let edits = text_edit(line_index, suggestion.suggestion, position_encoding, offset)?;
 
     changes.insert(url.clone(), edits);
diff --git a/crates/biome_rule_options/src/no_unknown_at_rules.rs b/crates/biome_rule_options/src/no_unknown_at_rules.rs
index 8f1deb0e2f..9de9c73e89 100644
--- a/crates/biome_rule_options/src/no_unknown_at_rules.rs
+++ b/crates/biome_rule_options/src/no_unknown_at_rules.rs
@@ -1,10 +1,6 @@
 use biome_deserialize_macros::Deserializable;
 use serde::{Deserialize, Serialize};
-#[derive(Clone, Debug, Deserialize, Deserializable, Eq, PartialEq, Serialize, Default)]
+#[derive(Default, Clone, Debug, Deserialize, Deserializable, Eq, PartialEq, Serialize)]
 #[cfg_attr(feature = "schema", derive(schemars::JsonSchema))]
 #[serde(rename_all = "camelCase", deny_unknown_fields, default)]
-pub struct NoUnknownAtRulesOptions {
-    /// A list of unknown at-rule names to ignore (case-insensitive).
-    #[serde(skip_serializing_if = "Vec::is_empty")]
-    pub ignore: Vec<String>,
-}
+pub struct NoUnknownAtRulesOptions {}
diff --git a/crates/biome_ruledoc_utils/src/codeblock.rs b/crates/biome_ruledoc_utils/src/codeblock.rs
index a3f8ed504c..f6746fcc37 100644
--- a/crates/biome_ruledoc_utils/src/codeblock.rs
+++ b/crates/biome_ruledoc_utils/src/codeblock.rs
@@ -94,7 +94,7 @@ impl CodeBlock {
     }
 
     pub fn document_file_source(&self) -> DocumentFileSource {
-        DocumentFileSource::from_extension(&self.tag)
+        DocumentFileSource::from_extension(&self.tag, false)
     }
 
     /// Returns the block's file path, but only if one was set explicitly using
@@ -138,7 +138,8 @@ impl FromStr for CodeBlock {
 
                         code_block.file_path = Some(normalize_file_path(path));
                     } else {
-                        if DocumentFileSource::from_extension(token) == DocumentFileSource::Unknown
+                        if DocumentFileSource::from_extension(token, false)
+                            == DocumentFileSource::Unknown
                         {
                             bail!("Unrecognised attribute in code block: {token}");
                         }
diff --git a/crates/biome_service/src/diagnostics.rs b/crates/biome_service/src/diagnostics.rs
index a4a97db6df..a0816195ff 100644
--- a/crates/biome_service/src/diagnostics.rs
+++ b/crates/biome_service/src/diagnostics.rs
@@ -513,7 +513,7 @@ impl Diagnostic for QueryDiagnostic {
 }
 
 pub fn extension_error(path: &BiomePath) -> WorkspaceError {
-    let file_source = DocumentFileSource::from_path(path);
+    let file_source = DocumentFileSource::from_path(path, false);
     WorkspaceError::source_file_not_supported(
         file_source,
         path.clone().to_string(),
diff --git a/crates/biome_service/src/file_handlers/css.rs b/crates/biome_service/src/file_handlers/css.rs
index 8845c5040e..1b3a3c0350 100644
--- a/crates/biome_service/src/file_handlers/css.rs
+++ b/crates/biome_service/src/file_handlers/css.rs
@@ -601,6 +601,7 @@ pub(crate) fn code_actions(params: CodeActionsParams) -> PullActionsResult {
         suppression_reason,
         plugins,
         categories,
+        action_offset,
     } = params;
     let _ = debug_span!("Code actions CSS", range =? range, path =? path).entered();
     let tree = parse.tree();
@@ -640,6 +641,7 @@ pub(crate) fn code_actions(params: CodeActionsParams) -> PullActionsResult {
                 rule_name: item
                     .rule_name
                     .map(|(group, name)| (Cow::Borrowed(group), Cow::Borrowed(name))),
+                offset: action_offset,
                 suggestion: item.suggestion,
             }
         }));
diff --git a/crates/biome_service/src/file_handlers/graphql.rs b/crates/biome_service/src/file_handlers/graphql.rs
index 1ddb5f04de..33213f7a79 100644
--- a/crates/biome_service/src/file_handlers/graphql.rs
+++ b/crates/biome_service/src/file_handlers/graphql.rs
@@ -482,6 +482,7 @@ pub(crate) fn code_actions(params: CodeActionsParams) -> PullActionsResult {
         enabled_rules: rules,
         plugins: _,
         categories,
+        action_offset,
     } = params;
     let _ = debug_span!("Code actions GraphQL", range =? range, path =? path).entered();
     let tree = parse.tree();
@@ -525,6 +526,7 @@ pub(crate) fn code_actions(params: CodeActionsParams) -> PullActionsResult {
                     .rule_name
                     .map(|(group, name)| (Cow::Borrowed(group), Cow::Borrowed(name))),
                 suggestion: item.suggestion,
+                offset: action_offset,
             }
         }));
 
diff --git a/crates/biome_service/src/file_handlers/html.rs b/crates/biome_service/src/file_handlers/html.rs
index 650227b068..700037ff89 100644
--- a/crates/biome_service/src/file_handlers/html.rs
+++ b/crates/biome_service/src/file_handlers/html.rs
@@ -36,9 +36,12 @@ use biome_html_formatter::{
     format_node,
 };
 use biome_html_parser::{HtmlParseOptions, parse_html_with_cache};
-use biome_html_syntax::{HtmlElement, HtmlEmbeddedContent, HtmlLanguage, HtmlRoot, HtmlSyntaxNode};
+use biome_html_syntax::element_ext::AnyEmbeddedContent;
+use biome_html_syntax::{
+    AstroEmbeddedContent, HtmlElement, HtmlLanguage, HtmlRoot, HtmlSyntaxNode,
+};
 use biome_js_parser::parse_js_with_offset_and_cache;
-use biome_js_syntax::{JsFileSource, JsLanguage};
+use biome_js_syntax::{EmbeddingKind, JsFileSource, JsLanguage};
 use biome_json_parser::parse_json_with_offset_and_cache;
 use biome_json_syntax::{JsonFileSource, JsonLanguage};
 use biome_parser::AnyParse;
@@ -391,7 +394,19 @@ fn parse_embedded_nodes(
 
     // Walk through all HTML elements looking for script tags and style tags
     for element in html_root.syntax().descendants() {
-        let Some(element) = HtmlElement::cast(element) else {
+        if let Some(astro_embedded_content) = AstroEmbeddedContent::cast_ref(&element) {
+            let result = parse_astro_embedded_script(
+                astro_embedded_content.clone(),
+                cache,
+                biome_path,
+                settings,
+            );
+            if let Some((content, file_source)) = result {
+                nodes.push((content.into(), file_source));
+            }
+        }
+
+        let Some(element) = HtmlElement::cast_ref(&element) else {
             continue;
         };
 
@@ -423,6 +438,35 @@ fn parse_embedded_nodes(
     ParseEmbedResult { nodes }
 }
 
+pub(crate) fn parse_astro_embedded_script(
+    element: AstroEmbeddedContent,
+    cache: &mut NodeCache,
+    path: &BiomePath,
+    settings: &Settings,
+) -> Option<(EmbeddedSnippet<JsLanguage>, DocumentFileSource)> {
+    let content = element.content_token()?;
+    let file_source = JsFileSource::ts().with_embedding_kind(EmbeddingKind::Astro);
+    let document_file_source = DocumentFileSource::Js(file_source);
+    let options = settings.parse_options::<JsLanguage>(path, &document_file_source);
+    let parse = parse_js_with_offset_and_cache(
+        content.text(),
+        content.text_range().start(),
+        file_source,
+        options,
+        cache,
+    );
+
+    Some((
+        EmbeddedSnippet::new(
+            parse.into(),
+            element.range(),
+            content.text_trimmed_range(),
+            content.text_range().start(),
+        ),
+        document_file_source,
+    ))
+}
+
 pub(crate) fn parse_embedded_script(
     element: HtmlElement,
     cache: &mut NodeCache,
@@ -433,13 +477,17 @@ pub(crate) fn parse_embedded_script(
     let html_file_source = html_file_source.to_html_file_source()?;
     if element.is_javascript_tag() {
         let file_source = if html_file_source.is_svelte() || html_file_source.is_vue() {
-            if element.is_typescript_lang().unwrap_or_default() {
+            let mut file_source = if element.is_typescript_lang() {
                 JsFileSource::ts()
             } else {
                 JsFileSource::js_module()
+            };
+            if html_file_source.is_svelte() {
+                file_source = file_source.with_embedding_kind(EmbeddingKind::Svelte);
+            } else if html_file_source.is_vue() {
+                file_source = file_source.with_embedding_kind(EmbeddingKind::Vue);
             }
-        } else if html_file_source.is_astro() {
-            JsFileSource::ts()
+            file_source
         } else {
             let is_module = element.is_javascript_module().unwrap_or_default();
             if is_module {
@@ -482,6 +530,7 @@ pub(crate) fn parse_embedded_script(
     }
 }
 
+/// Parses embedded style, but it skips it if it contains SASS language
 pub(crate) fn parse_embedded_style(
     element: HtmlElement,
     cache: &mut NodeCache,
@@ -494,6 +543,11 @@ pub(crate) fn parse_embedded_style(
             return None;
         }
 
+        // We don't support SASS
+        if element.is_sass_lang() {
+            return None;
+        }
+
         let file_source = DocumentFileSource::Css(CssFileSource::css());
         let content = element.children().iter().next().and_then(|child| {
             let child = child.as_any_html_content()?;
@@ -720,6 +774,7 @@ pub(crate) fn code_actions(params: CodeActionsParams) -> PullActionsResult {
         enabled_rules: rules,
         plugins: _,
         categories,
+        action_offset,
     } = params;
     let _ = debug_span!("Code actions HTML", range =? range, path =? path).entered();
     let tree = parse.tree();
@@ -757,6 +812,7 @@ pub(crate) fn code_actions(params: CodeActionsParams) -> PullActionsResult {
                     .rule_name
                     .map(|(group, name)| (Cow::Borrowed(group), Cow::Borrowed(name))),
                 suggestion: item.suggestion,
+                offset: action_offset,
             }
         }));
 
@@ -879,7 +935,7 @@ pub(crate) fn fix_all(params: FixAllParams) -> Result<FixFileResult, WorkspaceEr
                             &params.document_file_source,
                         ),
                         tree.syntax(),
-                        true,
+                        false,
                     )?
                     .print()?
                     .into_code()
@@ -907,7 +963,7 @@ pub(crate) fn update_snippets(
     let iterator = tree
         .syntax()
         .descendants()
-        .filter_map(HtmlEmbeddedContent::cast);
+        .filter_map(AnyEmbeddedContent::cast);
 
     for element in iterator {
         let Some(snippet) = new_snippets
@@ -917,7 +973,7 @@ pub(crate) fn update_snippets(
             continue;
         };
 
-        if let Ok(value_token) = element.value_token() {
+        if let Some(value_token) = element.value_token() {
             let new_token = ident(snippet.new_code.as_str());
             mutation.replace_token(value_token, new_token);
         }
diff --git a/crates/biome_service/src/file_handlers/javascript.rs b/crates/biome_service/src/file_handlers/javascript.rs
index 324e8659dc..915d5f1971 100644
--- a/crates/biome_service/src/file_handlers/javascript.rs
+++ b/crates/biome_service/src/file_handlers/javascript.rs
@@ -793,6 +793,7 @@ pub(crate) fn code_actions(params: CodeActionsParams) -> PullActionsResult {
         enabled_rules: rules,
         plugins,
         categories,
+        action_offset,
     } = params;
     let _ = debug_span!("Code actions JavaScript", range =? range, path =? path).entered();
     let tree = parse.tree();
@@ -840,6 +841,7 @@ pub(crate) fn code_actions(params: CodeActionsParams) -> PullActionsResult {
                         .rule_name
                         .map(|(group, name)| (Cow::Borrowed(group), Cow::Borrowed(name))),
                     suggestion: item.suggestion,
+                    offset: action_offset,
                 }
             }));
 
diff --git a/crates/biome_service/src/file_handlers/json.rs b/crates/biome_service/src/file_handlers/json.rs
index a2eab315aa..f35f97ed77 100644
--- a/crates/biome_service/src/file_handlers/json.rs
+++ b/crates/biome_service/src/file_handlers/json.rs
@@ -573,6 +573,7 @@ fn code_actions(params: CodeActionsParams) -> PullActionsResult {
         suppression_reason,
         plugins: _,
         categories,
+        action_offset,
     } = params;
 
     let _ = debug_span!("Code actions JSON",  range =? range, path =? path).entered();
@@ -612,6 +613,7 @@ fn code_actions(params: CodeActionsParams) -> PullActionsResult {
                     .rule_name
                     .map(|(group, name)| (Cow::Borrowed(group), Cow::Borrowed(name))),
                 suggestion: item.suggestion,
+                offset: action_offset,
             }
         }));
 
diff --git a/crates/biome_service/src/file_handlers/mod.rs b/crates/biome_service/src/file_handlers/mod.rs
index 35144f46df..2001b46387 100644
--- a/crates/biome_service/src/file_handlers/mod.rs
+++ b/crates/biome_service/src/file_handlers/mod.rs
@@ -4,11 +4,11 @@ use self::{
 };
 use crate::WorkspaceError;
 use crate::diagnostics::{QueryDiagnostic, SearchError};
-pub use crate::file_handlers::astro::{ASTRO_FENCE, AstroFileHandler};
+pub use crate::file_handlers::astro::AstroFileHandler;
 use crate::file_handlers::graphql::GraphqlFileHandler;
 use crate::file_handlers::ignore::IgnoreFileHandler;
-pub use crate::file_handlers::svelte::{SVELTE_FENCE, SvelteFileHandler};
-pub use crate::file_handlers::vue::{VUE_FENCE, VueFileHandler};
+pub use crate::file_handlers::svelte::SvelteFileHandler;
+pub use crate::file_handlers::vue::VueFileHandler;
 use crate::settings::Settings;
 use crate::workspace::{
     AnyEmbeddedSnippet, FixFileMode, FixFileResult, GetSyntaxTreeResult, PullActionsResult,
@@ -55,7 +55,7 @@ use std::borrow::Cow;
 use std::sync::Arc;
 use tracing::instrument;
 
-mod astro;
+pub mod astro;
 pub(crate) mod css;
 pub(crate) mod graphql;
 pub(crate) mod grit;
@@ -63,9 +63,9 @@ pub(crate) mod html;
 mod ignore;
 pub(crate) mod javascript;
 pub(crate) mod json;
-mod svelte;
+pub mod svelte;
 mod unknown;
-mod vue;
+pub mod vue;
 
 #[cfg_attr(feature = "schema", derive(schemars::JsonSchema))]
 #[derive(
@@ -122,41 +122,72 @@ impl From<GritFileSource> for DocumentFileSource {
 
 impl From<&Utf8Path> for DocumentFileSource {
     fn from(path: &Utf8Path) -> Self {
-        Self::from_path(path)
+        Self::from_path(path, false)
     }
 }
 
 impl DocumentFileSource {
-    fn try_from_well_known(path: &Utf8Path) -> Result<Self, FileSourceError> {
+    fn try_from_well_known(
+        path: &Utf8Path,
+        experimental_full_html_support: bool,
+    ) -> Result<Self, FileSourceError> {
         if let Ok(file_source) = JsonFileSource::try_from_well_known(path) {
             return Ok(file_source.into());
         }
-        if let Ok(file_source) = JsFileSource::try_from_well_known(path) {
-            return Ok(file_source.into());
+        if experimental_full_html_support {
+            if let Ok(file_source) = HtmlFileSource::try_from_well_known(path) {
+                return Ok(file_source.into());
+            }
+            if let Ok(file_source) = JsFileSource::try_from_well_known(path) {
+                return Ok(file_source.into());
+            }
+        } else {
+            if let Ok(file_source) = JsFileSource::try_from_well_known(path) {
+                return Ok(file_source.into());
+            }
+            if let Ok(file_source) = HtmlFileSource::try_from_well_known(path) {
+                return Ok(file_source.into());
+            }
         }
+
         if let Ok(file_source) = CssFileSource::try_from_well_known(path) {
             return Ok(file_source.into());
         }
         if let Ok(file_source) = GraphqlFileSource::try_from_well_known(path) {
             return Ok(file_source.into());
         }
-        if let Ok(file_source) = HtmlFileSource::try_from_well_known(path) {
-            return Ok(file_source.into());
-        }
 
         Err(FileSourceError::UnknownFileName)
     }
 
     /// Returns the document file source corresponding to this file name from well-known files
-    pub fn from_well_known(path: &Utf8Path) -> Self {
-        Self::try_from_well_known(path).unwrap_or(Self::Unknown)
-    }
+    pub fn from_well_known(path: &Utf8Path, experimental_full_html_support: bool) -> Self {
+        Self::try_from_well_known(path, experimental_full_html_support).unwrap_or(Self::Unknown)
+    }
+
+    fn try_from_extension(
+        extension: &str,
+        experimental_full_html_support: bool,
+    ) -> Result<Self, FileSourceError> {
+        // Order here is important
+        if experimental_full_html_support {
+            if let Ok(file_source) = HtmlFileSource::try_from_extension(extension) {
+                return Ok(file_source.into());
+            }
+            if let Ok(file_source) = JsFileSource::try_from_extension(extension) {
+                return Ok(file_source.into());
+            }
+        } else {
+            if let Ok(file_source) = JsFileSource::try_from_extension(extension) {
+                return Ok(file_source.into());
+            }
 
-    fn try_from_extension(extension: &str) -> Result<Self, FileSourceError> {
-        if let Ok(file_source) = JsonFileSource::try_from_extension(extension) {
-            return Ok(file_source.into());
+            if let Ok(file_source) = HtmlFileSource::try_from_extension(extension) {
+                return Ok(file_source.into());
+            }
         }
-        if let Ok(file_source) = JsFileSource::try_from_extension(extension) {
+
+        if let Ok(file_source) = JsonFileSource::try_from_extension(extension) {
             return Ok(file_source.into());
         }
         if let Ok(file_source) = CssFileSource::try_from_extension(extension) {
@@ -165,9 +196,7 @@ impl DocumentFileSource {
         if let Ok(file_source) = GraphqlFileSource::try_from_extension(extension) {
             return Ok(file_source.into());
         }
-        if let Ok(file_source) = HtmlFileSource::try_from_extension(extension) {
-            return Ok(file_source.into());
-        }
+
         if let Ok(file_source) = GritFileSource::try_from_extension(extension) {
             return Ok(file_source.into());
         }
@@ -175,8 +204,8 @@ impl DocumentFileSource {
     }
 
     /// Returns the document file source corresponding to this file extension
-    pub fn from_extension(extension: &str) -> Self {
-        Self::try_from_extension(extension).unwrap_or(Self::Unknown)
+    pub fn from_extension(extension: &str, experimental_full_html_support: bool) -> Self {
+        Self::try_from_extension(extension, experimental_full_html_support).unwrap_or(Self::Unknown)
     }
 
     #[instrument(level = "debug", fields(result))]
@@ -212,8 +241,11 @@ impl DocumentFileSource {
         Self::try_from_language_id(language_id).unwrap_or(Self::Unknown)
     }
 
-    pub(crate) fn try_from_path(path: &Utf8Path) -> Result<Self, FileSourceError> {
-        if let Ok(file_source) = Self::try_from_well_known(path) {
+    pub(crate) fn try_from_path(
+        path: &Utf8Path,
+        experimental_full_html_support: bool,
+    ) -> Result<Self, FileSourceError> {
+        if let Ok(file_source) = Self::try_from_well_known(path, experimental_full_html_support) {
             return Ok(file_source);
         }
 
@@ -244,12 +276,12 @@ impl DocumentFileSource {
                 .ok_or(FileSourceError::MissingFileExtension)?,
         };
 
-        Self::try_from_extension(extension.as_ref())
+        Self::try_from_extension(extension.as_ref(), experimental_full_html_support)
     }
 
     /// Returns the document file source corresponding to the file path
-    pub fn from_path(path: &Utf8Path) -> Self {
-        Self::try_from_path(path).unwrap_or(Self::Unknown)
+    pub fn from_path(path: &Utf8Path, experimental_full_html_support: bool) -> Self {
+        Self::try_from_path(path, experimental_full_html_support).unwrap_or(Self::Unknown)
     }
 
     /// Returns the document file source if it's not unknown, otherwise returns `other`.
@@ -334,25 +366,16 @@ impl DocumentFileSource {
         }
     }
 
-    /// Convert the file source from a JS file source into an HTML-like file source, if the file belongs to an HTML-like language.
-    pub fn to_htmlish(&self) -> Self {
-        match self {
-            Self::Js(js) => match js.as_embedding_kind() {
-                EmbeddingKind::Astro => Self::Html(HtmlFileSource::astro()),
-                EmbeddingKind::Vue => Self::Html(HtmlFileSource::vue()),
-                EmbeddingKind::Svelte => Self::Html(HtmlFileSource::svelte()),
-                EmbeddingKind::None => Self::Unknown,
-            },
-            _ => Self::Unknown,
-        }
-    }
-
     /// The file can be parsed
     pub fn can_parse(path: &Utf8Path) -> bool {
         let file_source = Self::from(path);
         match file_source {
-            Self::Js(_) => true,
-            Self::Css(_) | Self::Graphql(_) | Self::Json(_) | Self::Html(_) | Self::Grit(_) => true,
+            Self::Js(_)
+            | Self::Css(_)
+            | Self::Graphql(_)
+            | Self::Json(_)
+            | Self::Html(_)
+            | Self::Grit(_) => true,
             Self::Ignore => false,
             Self::Unknown => false,
         }
@@ -374,8 +397,8 @@ impl DocumentFileSource {
     }
 
     /// Whether this file can contain embedded nodes
-    pub fn can_contain_embeds(path: &Utf8Path) -> bool {
-        let file_source = Self::from(path);
+    pub fn can_contain_embeds(path: &Utf8Path, experimental_full_html_support: bool) -> bool {
+        let file_source = Self::from_path(path, experimental_full_html_support);
         match file_source {
             Self::Html(_) => true,
             Self::Js(_)
@@ -650,6 +673,7 @@ pub(crate) struct CodeActionsParams<'a> {
     pub(crate) enabled_rules: &'a [AnalyzerSelector],
     pub(crate) plugins: AnalyzerPluginVec,
     pub(crate) categories: RuleCategories,
+    pub(crate) action_offset: Option<TextSize>,
 }
 
 pub(crate) struct UpdateSnippetsNodes {
@@ -702,6 +726,7 @@ type FormatEmbedded = fn(
     Vec<FormatEmbedNode>,
 ) -> Result<Printed, WorkspaceError>;
 
+#[derive(Debug)]
 pub(crate) struct FormatEmbedNode {
     pub(crate) range: TextRange,
     pub(crate) node: AnyParse,
@@ -774,8 +799,8 @@ impl Features {
             json: JsonFileHandler {},
             css: CssFileHandler {},
             astro: AstroFileHandler {},
-            vue: VueFileHandler {},
             svelte: SvelteFileHandler {},
+            vue: VueFileHandler {},
             graphql: GraphqlFileHandler {},
             html: HtmlFileHandler {},
             grit: GritFileHandler {},
@@ -787,6 +812,7 @@ impl Features {
     /// Returns the [Capabilities] associated with a [BiomePath]
     pub(crate) fn get_capabilities(&self, language_hint: DocumentFileSource) -> Capabilities {
         match language_hint {
+            // TODO: remove match once we remove vue/astro/svelte handlers
             DocumentFileSource::Js(source) => match source.as_embedding_kind() {
                 EmbeddingKind::Astro => self.astro.capabilities(),
                 EmbeddingKind::Vue => self.vue.capabilities(),
@@ -907,36 +933,6 @@ pub(crate) fn search(
     Ok(matches)
 }
 
-#[test]
-fn test_svelte_script_lang() {
-    const SVELTE_JS_SCRIPT_OPENING_TAG: &str = r#"<script>"#;
-    const SVELTE_TS_SCRIPT_OPENING_TAG: &str = r#"<script lang="ts">"#;
-    const SVELTE_CONTEXT_MODULE_JS_SCRIPT_OPENING_TAG: &str = r#"<script context="module">"#;
-    const SVELTE_CONTEXT_MODULE_TS_SCRIPT_OPENING_TAG: &str =
-        r#"<script context="module" lang="ts">"#;
-
-    assert!(
-        parse_lang_from_script_opening_tag(SVELTE_JS_SCRIPT_OPENING_TAG)
-            .0
-            .is_javascript()
-    );
-    assert!(
-        parse_lang_from_script_opening_tag(SVELTE_TS_SCRIPT_OPENING_TAG)
-            .0
-            .is_typescript()
-    );
-    assert!(
-        parse_lang_from_script_opening_tag(SVELTE_CONTEXT_MODULE_JS_SCRIPT_OPENING_TAG)
-            .0
-            .is_javascript()
-    );
-    assert!(
-        parse_lang_from_script_opening_tag(SVELTE_CONTEXT_MODULE_TS_SCRIPT_OPENING_TAG)
-            .0
-            .is_typescript()
-    );
-}
-
 /// Type meant to register all the syntax rules for each language supported by Biome
 ///
 /// When a new language is introduced, it must be implemented it. Syntax rules aren't negotiable via configuration, so it's safe
@@ -1663,59 +1659,3 @@ impl<'b> AnalyzerVisitorBuilder<'b> {
         (enabled_rules, disabled_rules, analyzer_options)
     }
 }
-
-#[test]
-fn test_vue_script_lang() {
-    const VUE_JS_SCRIPT_OPENING_TAG: &str = r#"<script>"#;
-    const VUE_TS_SCRIPT_OPENING_TAG: &str = r#"<script lang="ts">"#;
-    const VUE_TSX_SCRIPT_OPENING_TAG: &str = r#"<script lang="tsx">"#;
-    const VUE_JSX_SCRIPT_OPENING_TAG: &str = r#"<script lang="jsx">"#;
-    const VUE_SETUP_JS_SCRIPT_OPENING_TAG: &str = r#"<script setup>"#;
-    const VUE_SETUP_TS_SCRIPT_OPENING_TAG: &str = r#"<script setup lang="ts">"#;
-
-    assert!(
-        parse_lang_from_script_opening_tag(VUE_JS_SCRIPT_OPENING_TAG)
-            .0
-            .is_javascript()
-    );
-    assert!(
-        parse_lang_from_script_opening_tag(VUE_JS_SCRIPT_OPENING_TAG)
-            .1
-            .is_standard()
-    );
-    assert!(
-        parse_lang_from_script_opening_tag(VUE_TS_SCRIPT_OPENING_TAG)
-            .0
-            .is_typescript()
-    );
-    assert!(
-        parse_lang_from_script_opening_tag(VUE_TS_SCRIPT_OPENING_TAG)
-            .1
-            .is_standard()
-    );
-    assert!(
-        parse_lang_from_script_opening_tag(VUE_JSX_SCRIPT_OPENING_TAG)
-            .0
-            .is_javascript()
-    );
-    assert!(
-        parse_lang_from_script_opening_tag(VUE_JSX_SCRIPT_OPENING_TAG)
-            .1
-            .is_jsx()
-    );
-    assert!(
-        parse_lang_from_script_opening_tag(VUE_TSX_SCRIPT_OPENING_TAG)
-            .0
-            .is_typescript()
-    );
-    assert!(
-        parse_lang_from_script_opening_tag(VUE_SETUP_JS_SCRIPT_OPENING_TAG)
-            .0
-            .is_javascript()
-    );
-    assert!(
-        parse_lang_from_script_opening_tag(VUE_SETUP_TS_SCRIPT_OPENING_TAG)
-            .0
-            .is_typescript()
-    );
-}
diff --git a/crates/biome_service/src/file_handlers/svelte.rs b/crates/biome_service/src/file_handlers/svelte.rs
index ed406ae4ea..fbe3ead301 100644
--- a/crates/biome_service/src/file_handlers/svelte.rs
+++ b/crates/biome_service/src/file_handlers/svelte.rs
@@ -148,8 +148,7 @@ fn format(
     settings: &Settings,
 ) -> Result<Printed, WorkspaceError> {
     let options = settings.format_options::<JsLanguage>(biome_path, document_file_source);
-    let html_options =
-        settings.format_options::<HtmlLanguage>(biome_path, &document_file_source.to_htmlish());
+    let html_options = settings.format_options::<HtmlLanguage>(biome_path, document_file_source);
     let indent_amount = if *html_options.indent_script_and_style() {
         1
     } else {
diff --git a/crates/biome_service/src/file_handlers/vue.rs b/crates/biome_service/src/file_handlers/vue.rs
index 2540f55ff0..aa0ff53a5e 100644
--- a/crates/biome_service/src/file_handlers/vue.rs
+++ b/crates/biome_service/src/file_handlers/vue.rs
@@ -148,8 +148,7 @@ fn format(
     settings: &Settings,
 ) -> Result<Printed, WorkspaceError> {
     let options = settings.format_options::<JsLanguage>(biome_path, document_file_source);
-    let html_options =
-        settings.format_options::<HtmlLanguage>(biome_path, &document_file_source.to_htmlish());
+    let html_options = settings.format_options::<HtmlLanguage>(biome_path, document_file_source);
     let indent_amount = if *html_options.indent_script_and_style() {
         1
     } else {
diff --git a/crates/biome_service/src/settings.rs b/crates/biome_service/src/settings.rs
index e3a1fe5fe6..947f0934b4 100644
--- a/crates/biome_service/src/settings.rs
+++ b/crates/biome_service/src/settings.rs
@@ -6,7 +6,7 @@ use biome_configuration::analyzer::{LinterEnabled, RuleDomains};
 use biome_configuration::bool::Bool;
 use biome_configuration::diagnostics::InvalidIgnorePattern;
 use biome_configuration::formatter::{FormatWithErrorsEnabled, FormatterEnabled};
-use biome_configuration::html::HtmlConfiguration;
+use biome_configuration::html::{ExperimentalFullSupportEnabled, HtmlConfiguration};
 use biome_configuration::javascript::JsxRuntime;
 use biome_configuration::max_size::MaxSize;
 use biome_configuration::plugins::Plugins;
@@ -73,9 +73,18 @@ pub struct Settings {
     pub override_settings: OverrideSettings,
     /// The VCS settings of the project
     pub vcs_settings: VcsSettings,
+
+    // TODO: remove once HTML full support is stable
+    pub experimental_full_html_support: Option<ExperimentalFullSupportEnabled>,
 }
 
 impl Settings {
+    pub fn experimental_full_html_support_enabled(&self) -> bool {
+        self.experimental_full_html_support
+            .unwrap_or_default()
+            .value()
+    }
+
     pub fn source(&self) -> Option<Configuration> {
         self.source.as_ref().map(|source| {
             let (config, _) = source.deref().clone();
@@ -142,7 +151,8 @@ impl Settings {
         }
         // html settings
         if let Some(html) = configuration.html {
-            self.languages.html = html.into()
+            self.experimental_full_html_support = html.experimental_full_support_enabled;
+            self.languages.html = html.into();
         }
 
         // plugin settings
@@ -304,6 +314,7 @@ impl Settings {
             FeatureKind::Format => &self.formatter.includes,
             FeatureKind::Lint => &self.linter.includes,
             FeatureKind::Assist => &self.assist.includes,
+            FeatureKind::HtmlFullSupport => return false,
             FeatureKind::Search => return false, // There is no search-specific config.
             FeatureKind::Debug => return false,
         };
diff --git a/crates/biome_service/src/workspace.rs b/crates/biome_service/src/workspace.rs
index 5727ce8276..c3df2fdf47 100644
--- a/crates/biome_service/src/workspace.rs
+++ b/crates/biome_service/src/workspace.rs
@@ -130,13 +130,14 @@ pub struct SupportsFeatureResult {
 pub struct FeaturesSupported([SupportKind; NUM_FEATURE_KINDS]);
 
 impl FeaturesSupported {
-    /// By default, all features are not supported by a file.
+    /// By default, a file does not support all features.
     const WORKSPACE_FEATURES: [SupportKind; NUM_FEATURE_KINDS] = [
         SupportKind::FileNotSupported,
         SupportKind::FileNotSupported,
         SupportKind::FileNotSupported,
         SupportKind::FileNotSupported,
         SupportKind::FileNotSupported,
+        SupportKind::FileNotSupported,
     ];
 
     #[inline]
@@ -218,6 +219,12 @@ impl FeaturesSupported {
             }
         }
 
+        if let Some(experimental_full_html_support) = settings.experimental_full_html_support
+            && experimental_full_html_support.value()
+        {
+            self.insert(FeatureKind::HtmlFullSupport, SupportKind::Supported);
+        }
+
         debug!("The file has the following feature sets: {:?}", &self);
 
         self
@@ -267,6 +274,11 @@ impl FeaturesSupported {
         self.supports(FeatureKind::Search)
     }
 
+    // TODO: remove once html full support is stable
+    pub fn supports_full_html_support(&self) -> bool {
+        self.supports(FeatureKind::HtmlFullSupport)
+    }
+
     /// Returns the [`SupportKind`] for the given `feature`, but only if it is
     /// not enabled.
     #[inline(always)]
@@ -536,9 +548,11 @@ pub enum FeatureKind {
     Search,
     Assist,
     Debug,
+    // TODO: remove once full HTML support is stable
+    HtmlFullSupport,
 }
 
-pub const NUM_FEATURE_KINDS: usize = 5;
+pub const NUM_FEATURE_KINDS: usize = 6;
 
 impl Display for FeatureKind {
     fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
@@ -548,6 +562,7 @@ impl Display for FeatureKind {
             Self::Search => write!(f, "Search"),
             Self::Assist => write!(f, "Assist"),
             Self::Debug => write!(f, "Debug"),
+            Self::HtmlFullSupport => write!(f, "HtmlFullSupport"),
         }
     }
 }
@@ -565,6 +580,7 @@ impl FeatureKind {
             2 => Self::Search,
             3 => Self::Assist,
             4 => Self::Debug,
+            5 => Self::HtmlFullSupport,
             _ => unreachable!("invalid index for FeatureKind"),
         }
     }
@@ -578,6 +594,7 @@ impl FeatureKind {
             Self::Search => 2,
             Self::Assist => 3,
             Self::Debug => 4,
+            Self::HtmlFullSupport => 5,
         }
     }
 }
@@ -606,6 +623,7 @@ impl Debug for FeatureName {
                 FeatureKind::Search => list.entry(&"Search"),
                 FeatureKind::Assist => list.entry(&"Assist"),
                 FeatureKind::Debug => list.entry(&"Debug"),
+                FeatureKind::HtmlFullSupport => list.entry(&"HtmlFullSupport"),
             };
         }
         list.finish()
@@ -969,6 +987,7 @@ pub struct CodeAction {
     pub category: ActionCategory,
     pub rule_name: Option<(Cow<'static, str>, Cow<'static, str>)>,
     pub suggestion: CodeSuggestion,
+    pub offset: Option<TextSize>,
 }
 
 #[derive(Debug, serde::Serialize, serde::Deserialize)]
diff --git a/crates/biome_service/src/workspace/server.rs b/crates/biome_service/src/workspace/server.rs
index dd748e48c6..15413228f9 100644
--- a/crates/biome_service/src/workspace/server.rs
+++ b/crates/biome_service/src/workspace/server.rs
@@ -210,19 +210,30 @@ impl WorkspaceServer {
     }
 
     /// Gets the supported capabilities for a given file path.
-    fn get_file_capabilities(&self, path: &BiomePath) -> Capabilities {
-        let language = self.get_file_source(path);
+    fn get_file_capabilities(
+        &self,
+        path: &BiomePath,
+        experimental_full_html_support: bool,
+    ) -> Capabilities {
+        let language = self.get_file_source(path, experimental_full_html_support);
         self.features.get_capabilities(language)
     }
 
     /// Retrieves the supported language of a file.
-    fn get_file_source(&self, path: &Utf8Path) -> DocumentFileSource {
+    fn get_file_source(
+        &self,
+        path: &Utf8Path,
+        experimental_full_html_support: bool,
+    ) -> DocumentFileSource {
         self.documents
             .pin()
             .get(path)
             .map(|doc| doc.file_source_index)
             .and_then(|index| self.get_source(index))
-            .unwrap_or(DocumentFileSource::from_path(path))
+            .unwrap_or(DocumentFileSource::from_path(
+                path,
+                experimental_full_html_support,
+            ))
     }
 
     /// Returns an error factory function for unsupported features at a given
@@ -232,9 +243,10 @@ impl WorkspaceServer {
         path: &'a Utf8Path,
     ) -> impl FnOnce() -> WorkspaceError + 'a {
         move || {
-            let file_source = self.get_file_source(path);
+            // For simplicity and avoid too many changes, we hardcode the support to false
+            let file_source = self.get_file_source(path, false);
 
-            let language = DocumentFileSource::from_path(path).or(file_source);
+            let language = DocumentFileSource::from_path(path, false).or(file_source);
             WorkspaceError::source_file_not_supported(
                 language,
                 path.to_string(),
@@ -288,13 +300,16 @@ impl WorkspaceServer {
             return Ok(Default::default());
         }
 
-        let mut source = document_file_source.unwrap_or(DocumentFileSource::from_path(&path));
-
         let settings = self
             .projects
             .get_settings_based_on_path(project_key, &path)
             .ok_or_else(WorkspaceError::no_project)?;
 
+        let mut source = document_file_source.unwrap_or(DocumentFileSource::from_path(
+            &path,
+            settings.experimental_full_html_support_enabled(),
+        ));
+
         if let DocumentFileSource::Js(js) = &mut source {
             match path.extension() {
                 Some("js") => {
@@ -363,8 +378,10 @@ impl WorkspaceServer {
         };
         // Second-pass parsing for HTML files with embedded JavaScript and CSS
         // content.
-        let embedded_snippets = if DocumentFileSource::can_contain_embeds(path.as_path())
-            && let Some(Ok(any_parse)) = &syntax
+        let embedded_snippets = if DocumentFileSource::can_contain_embeds(
+            path.as_path(),
+            settings.experimental_full_html_support_enabled(),
+        ) && let Some(Ok(any_parse)) = &syntax
         {
             // Second-pass parsing for HTML files with embedded JavaScript and CSS content
 
@@ -523,7 +540,8 @@ impl WorkspaceServer {
         settings: &Settings,
     ) -> Result<Vec<AnyEmbeddedSnippet>, WorkspaceError> {
         let mut embedded_nodes = Vec::new();
-        let capabilities = self.get_file_capabilities(path);
+        let capabilities =
+            self.get_file_capabilities(path, settings.experimental_full_html_support_enabled());
         let Some(parse_embedded) = capabilities.parser.parse_embedded_nodes else {
             return Ok(Default::default());
         };
@@ -1078,7 +1096,14 @@ impl Workspace for WorkspaceServer {
         &self,
         params: SupportsFeatureParams,
     ) -> Result<FileFeaturesResult, WorkspaceError> {
-        let language = self.get_file_source(&params.path);
+        let settings = self
+            .projects
+            .get_settings_based_on_path(params.project_key, &params.path)
+            .ok_or_else(WorkspaceError::no_project)?;
+        let language = self.get_file_source(
+            &params.path,
+            settings.experimental_full_html_support_enabled(),
+        );
         let capabilities = self.features.get_capabilities(language);
 
         self.projects.get_file_features(
@@ -1116,7 +1141,14 @@ impl Workspace for WorkspaceServer {
         &self,
         params: GetSyntaxTreeParams,
     ) -> Result<GetSyntaxTreeResult, WorkspaceError> {
-        let capabilities = self.get_file_capabilities(&params.path);
+        let settings = self
+            .projects
+            .get_settings_based_on_path(params.project_key, &params.path)
+            .ok_or_else(WorkspaceError::no_project)?;
+        let capabilities = self.get_file_capabilities(
+            &params.path,
+            settings.experimental_full_html_support_enabled(),
+        );
         let debug_syntax_tree = capabilities
             .debug
             .debug_syntax_tree
@@ -1133,7 +1165,14 @@ impl Workspace for WorkspaceServer {
         &self,
         params: GetControlFlowGraphParams,
     ) -> Result<String, WorkspaceError> {
-        let capabilities = self.get_file_capabilities(&params.path);
+        let settings = self
+            .projects
+            .get_settings_based_on_path(params.project_key, &params.path)
+            .ok_or_else(WorkspaceError::no_project)?;
+        let capabilities = self.get_file_capabilities(
+            &params.path,
+            settings.experimental_full_html_support_enabled(),
+        );
         let debug_control_flow = capabilities
             .debug
             .debug_control_flow
@@ -1146,28 +1185,41 @@ impl Workspace for WorkspaceServer {
     }
 
     fn get_formatter_ir(&self, params: GetFormatterIRParams) -> Result<String, WorkspaceError> {
-        let capabilities = self.get_file_capabilities(&params.path);
-        let debug_formatter_ir = capabilities
-            .debug
-            .debug_formatter_ir
-            .ok_or_else(self.build_capability_error(&params.path))?;
         let settings = self
             .projects
             .get_settings_based_on_path(params.project_key, &params.path)
             .ok_or_else(WorkspaceError::no_project)?;
+        let capabilities = self.get_file_capabilities(
+            &params.path,
+            settings.experimental_full_html_support_enabled(),
+        );
+        let debug_formatter_ir = capabilities
+            .debug
+            .debug_formatter_ir
+            .ok_or_else(self.build_capability_error(&params.path))?;
         let parse = self.get_parse(&params.path)?;
         if !settings.format_with_errors_enabled_for_this_file_path(&params.path)
             && parse.has_errors()
         {
             return Err(WorkspaceError::format_with_errors_disabled());
         }
-        let document_file_source = self.get_file_source(&params.path);
+        let document_file_source = self.get_file_source(
+            &params.path,
+            settings.experimental_full_html_support_enabled(),
+        );
 
         debug_formatter_ir(&params.path, &document_file_source, parse, &settings)
     }
 
     fn get_type_info(&self, params: GetTypeInfoParams) -> Result<String, WorkspaceError> {
-        let capabilities = self.get_file_capabilities(&params.path);
+        let settings = self
+            .projects
+            .get_settings_based_on_path(params.project_key, &params.path)
+            .ok_or_else(WorkspaceError::no_project)?;
+        let capabilities = self.get_file_capabilities(
+            &params.path,
+            settings.experimental_full_html_support_enabled(),
+        );
         let debug_type_info = capabilities
             .debug
             .debug_type_info
@@ -1181,7 +1233,14 @@ impl Workspace for WorkspaceServer {
         &self,
         params: GetRegisteredTypesParams,
     ) -> Result<String, WorkspaceError> {
-        let capabilities = self.get_file_capabilities(&params.path);
+        let settings = self
+            .projects
+            .get_settings_based_on_path(params.project_key, &params.path)
+            .ok_or_else(WorkspaceError::no_project)?;
+        let capabilities = self.get_file_capabilities(
+            &params.path,
+            settings.experimental_full_html_support_enabled(),
+        );
         let debug_registered_types = capabilities
             .debug
             .debug_registered_types
@@ -1192,7 +1251,14 @@ impl Workspace for WorkspaceServer {
     }
 
     fn get_semantic_model(&self, params: GetSemanticModelParams) -> Result<String, WorkspaceError> {
-        let capabilities = self.get_file_capabilities(&params.path);
+        let settings = self
+            .projects
+            .get_settings_based_on_path(params.project_key, &params.path)
+            .ok_or_else(WorkspaceError::no_project)?;
+        let capabilities = self.get_file_capabilities(
+            &params.path,
+            settings.experimental_full_html_support_enabled(),
+        );
         let debug_semantic_model = capabilities
             .debug
             .debug_semantic_model
@@ -1272,10 +1338,14 @@ impl Workspace for WorkspaceServer {
 
         let parsed = self.parse(&path, &content, &settings, index, &mut node_cache)?;
         let root = parsed.any_parse.unwrap_as_send_node();
-        let document_source = self.get_file_source(&path);
+        let document_source =
+            self.get_file_source(&path, settings.experimental_full_html_support_enabled());
 
         // Second-pass parsing for HTML files with embedded JavaScript and CSS content
-        let embedded_snippets = if DocumentFileSource::can_contain_embeds(path.as_path()) {
+        let embedded_snippets = if DocumentFileSource::can_contain_embeds(
+            path.as_path(),
+            settings.experimental_full_html_support_enabled(),
+        ) {
             // Second-pass parsing for HTML files with embedded JavaScript and CSS content
             let mut node_cache = NodeCache::default();
             self.parse_embedded_language_snippets(
@@ -1365,18 +1435,18 @@ impl Workspace for WorkspaceServer {
             enabled_rules,
             pull_code_actions,
         } = params;
+        let settings = self
+            .projects
+            .get_settings_based_on_path(project_key, &path)
+            .ok_or_else(WorkspaceError::no_project)?;
         let (parse, embedded_snippets) = self.get_parse_with_snippets(&path)?;
-        let language = self.get_file_source(&path);
+        let language =
+            self.get_file_source(&path, settings.experimental_full_html_support_enabled());
         let capabilities = self.features.get_capabilities(language);
         let (diagnostics, errors, skipped_diagnostics) = if (categories.is_lint()
             || categories.is_assist())
             && let Some(lint) = capabilities.analyzer.lint
         {
-            let settings = self
-                .projects
-                .get_settings_based_on_path(project_key, &path)
-                .ok_or_else(WorkspaceError::no_project)?;
-
             let plugins = if categories.is_lint() {
                 self.get_analyzer_plugins_for_project(
                     settings.source_path().unwrap_or_default().as_path(),
@@ -1500,18 +1570,20 @@ impl Workspace for WorkspaceServer {
             enabled_rules,
             categories,
         } = params;
-        let capabilities = self.get_file_capabilities(&path);
+        let settings = self
+            .projects
+            .get_settings_based_on_path(project_key, &path)
+            .ok_or_else(WorkspaceError::no_project)?;
+        let capabilities =
+            self.get_file_capabilities(&path, settings.experimental_full_html_support_enabled());
         let code_actions = capabilities
             .analyzer
             .code_actions
             .ok_or_else(self.build_capability_error(&path))?;
 
         let (parse, embedded_snippets) = self.get_parse_with_snippets(&path)?;
-        let language = self.get_file_source(&path);
-        let settings = self
-            .projects
-            .get_settings_based_on_path(project_key, &path)
-            .ok_or_else(WorkspaceError::no_project)?;
+        let language =
+            self.get_file_source(&path, settings.experimental_full_html_support_enabled());
         let mut result = code_actions(CodeActionsParams {
             parse,
             range,
@@ -1526,6 +1598,7 @@ impl Workspace for WorkspaceServer {
             enabled_rules: &enabled_rules,
             plugins: Vec::new(),
             categories,
+            action_offset: None,
         });
 
         for embedded_snippet in embedded_snippets {
@@ -1551,6 +1624,7 @@ impl Workspace for WorkspaceServer {
                 enabled_rules: &enabled_rules,
                 plugins: Vec::new(),
                 categories,
+                action_offset: Some(embedded_snippet.content_offset()),
             });
 
             result.actions.extend(embedded_actions_result.actions);
@@ -1569,7 +1643,14 @@ impl Workspace for WorkspaceServer {
         )
     )]
     fn format_file(&self, params: FormatFileParams) -> Result<Printed, WorkspaceError> {
-        let capabilities = self.get_file_capabilities(&params.path);
+        let settings = self
+            .projects
+            .get_settings_based_on_path(params.project_key, &params.path)
+            .ok_or_else(WorkspaceError::no_project)?;
+        let capabilities = self.get_file_capabilities(
+            &params.path,
+            settings.experimental_full_html_support_enabled(),
+        );
 
         let format = capabilities
             .formatter
@@ -1578,11 +1659,6 @@ impl Workspace for WorkspaceServer {
 
         let format_embedded = capabilities.formatter.format_embedded;
 
-        let settings = self
-            .projects
-            .get_settings_based_on_path(params.project_key, &params.path)
-            .ok_or_else(WorkspaceError::no_project)?;
-
         let (parse, embedded_nodes) = self.get_parse_with_embedded_format_nodes(&params.path)?;
 
         if !settings.format_with_errors_enabled_for_this_file_path(&params.path)
@@ -1591,7 +1667,10 @@ impl Workspace for WorkspaceServer {
             return Err(WorkspaceError::format_with_errors_disabled());
         }
 
-        let document_file_source = self.get_file_source(&params.path);
+        let document_file_source = self.get_file_source(
+            &params.path,
+            settings.experimental_full_html_support_enabled(),
+        );
         if !embedded_nodes.is_empty() {
             let format_embedded =
                 format_embedded.ok_or_else(self.build_capability_error(&params.path))?;
@@ -1608,22 +1687,28 @@ impl Workspace for WorkspaceServer {
 
     #[instrument(level = "debug", skip(self, params))]
     fn format_range(&self, params: FormatRangeParams) -> Result<Printed, WorkspaceError> {
-        let capabilities = self.get_file_capabilities(&params.path);
-        let format_range = capabilities
-            .formatter
-            .format_range
-            .ok_or_else(self.build_capability_error(&params.path))?;
         let settings = self
             .projects
             .get_settings_based_on_path(params.project_key, &params.path)
             .ok_or_else(WorkspaceError::no_project)?;
+        let capabilities = self.get_file_capabilities(
+            &params.path,
+            settings.experimental_full_html_support_enabled(),
+        );
+        let format_range = capabilities
+            .formatter
+            .format_range
+            .ok_or_else(self.build_capability_error(&params.path))?;
         let parse = self.get_parse(&params.path)?;
         if !settings.format_with_errors_enabled_for_this_file_path(&params.path)
             && parse.has_errors()
         {
             return Err(WorkspaceError::format_with_errors_disabled());
         }
-        let document_file_source = self.get_file_source(&params.path);
+        let document_file_source = self.get_file_source(
+            &params.path,
+            settings.experimental_full_html_support_enabled(),
+        );
         format_range(
             &params.path,
             &document_file_source,
@@ -1635,23 +1720,29 @@ impl Workspace for WorkspaceServer {
 
     #[instrument(level = "debug", skip(self, params))]
     fn format_on_type(&self, params: FormatOnTypeParams) -> Result<Printed, WorkspaceError> {
-        let capabilities = self.get_file_capabilities(&params.path);
+        let settings = self
+            .projects
+            .get_settings_based_on_path(params.project_key, &params.path)
+            .ok_or_else(WorkspaceError::no_project)?;
+        let capabilities = self.get_file_capabilities(
+            &params.path,
+            settings.experimental_full_html_support_enabled(),
+        );
         let format_on_type = capabilities
             .formatter
             .format_on_type
             .ok_or_else(self.build_capability_error(&params.path))?;
 
-        let settings = self
-            .projects
-            .get_settings_based_on_path(params.project_key, &params.path)
-            .ok_or_else(WorkspaceError::no_project)?;
         let parse = self.get_parse(&params.path)?;
         if !settings.format_with_errors_enabled_for_this_file_path(&params.path)
             && parse.has_errors()
         {
             return Err(WorkspaceError::format_with_errors_disabled());
         }
-        let document_file_source = self.get_file_source(&params.path);
+        let document_file_source = self.get_file_source(
+            &params.path,
+            settings.experimental_full_html_support_enabled(),
+        );
 
         format_on_type(
             &params.path,
@@ -1686,7 +1777,12 @@ impl Workspace for WorkspaceServer {
             suppression_reason,
         } = params;
 
-        let capabilities = self.get_file_capabilities(&path);
+        let settings = self
+            .projects
+            .get_settings_based_on_path(project_key, &path)
+            .ok_or_else(WorkspaceError::no_project)?;
+        let capabilities =
+            self.get_file_capabilities(&path, settings.experimental_full_html_support_enabled());
 
         let fix_all = capabilities
             .analyzer
@@ -1695,17 +1791,14 @@ impl Workspace for WorkspaceServer {
 
         let (mut parse, embedded_snippets) = self.get_parse_with_snippets(&path)?;
 
-        let settings = self
-            .projects
-            .get_settings_based_on_path(project_key, &path)
-            .ok_or_else(WorkspaceError::no_project)?;
         let plugins = self
             .get_analyzer_plugins_for_project(
                 settings.source_path().unwrap_or_default().as_path(),
                 &settings.get_plugins_for_path(&path),
             )
             .map_err(WorkspaceError::plugin_errors)?;
-        let language = self.get_file_source(&path);
+        let language =
+            self.get_file_source(&path, settings.experimental_full_html_support_enabled());
         let plugins = if rule_categories.contains(RuleCategory::Lint) {
             plugins
         } else {
@@ -1789,8 +1882,15 @@ impl Workspace for WorkspaceServer {
         })
     }
 
-    fn rename(&self, params: super::RenameParams) -> Result<RenameResult, WorkspaceError> {
-        let capabilities = self.get_file_capabilities(&params.path);
+    fn rename(&self, params: RenameParams) -> Result<RenameResult, WorkspaceError> {
+        let settings = self
+            .projects
+            .get_settings_based_on_path(params.project_key, &params.path)
+            .ok_or_else(WorkspaceError::no_project)?;
+        let capabilities = self.get_file_capabilities(
+            &params.path,
+            settings.experimental_full_html_support_enabled(),
+        );
         let rename = capabilities
             .analyzer
             .rename
@@ -1864,12 +1964,17 @@ impl Workspace for WorkspaceServer {
             pattern,
         }: SearchPatternParams,
     ) -> Result<SearchResults, WorkspaceError> {
+        let settings = self
+            .projects
+            .get_settings_based_on_path(project_key, &path)
+            .ok_or_else(WorkspaceError::no_project)?;
         let patterns = self.patterns.pin();
         let query = patterns
             .get(&pattern)
             .ok_or_else(WorkspaceError::invalid_pattern)?;
 
-        let capabilities = self.get_file_capabilities(&path);
+        let capabilities =
+            self.get_file_capabilities(&path, settings.experimental_full_html_support_enabled());
         let search = capabilities
             .search
             .search
@@ -1880,13 +1985,14 @@ impl Workspace for WorkspaceServer {
             .ok_or_else(WorkspaceError::no_project)?;
         let parse = self.get_parse(&path)?;
 
-        let document_file_source = self.get_file_source(&path);
+        let document_file_source =
+            self.get_file_source(&path, settings.experimental_full_html_support_enabled());
         let matches = search(&path, &document_file_source, parse, query, &settings)?;
 
         Ok(SearchResults { path, matches })
     }
 
-    fn drop_pattern(&self, params: super::DropPatternParams) -> Result<(), WorkspaceError> {
+    fn drop_pattern(&self, params: DropPatternParams) -> Result<(), WorkspaceError> {
         self.patterns.pin().remove(&params.pattern);
         Ok(())
     }
diff --git a/crates/biome_service/src/workspace/server.tests.rs b/crates/biome_service/src/workspace/server.tests.rs
index 26950bad3c..22714f6990 100644
--- a/crates/biome_service/src/workspace/server.tests.rs
+++ b/crates/biome_service/src/workspace/server.tests.rs
@@ -270,7 +270,7 @@ function Foo({cond}) {
         })
         .unwrap();
 
-    let ts_file_source = workspace.get_file_source("/project/a.ts".into());
+    let ts_file_source = workspace.get_file_source("/project/a.ts".into(), false);
     let ts = ts_file_source.to_js_file_source().expect("JS file source");
     assert!(ts.is_typescript());
     assert!(!ts.is_jsx());
@@ -279,7 +279,7 @@ function Foo({cond}) {
         Err(error) => panic!("File not available: {error}"),
     }
 
-    let js_file_source = workspace.get_file_source("/project/a.js".into());
+    let js_file_source = workspace.get_file_source("/project/a.js".into(), false);
     let js = js_file_source.to_js_file_source().expect("JS file source");
     assert!(!js.is_typescript());
     assert!(js.is_jsx());
@@ -382,7 +382,7 @@ function Foo({cond}) {
         })
         .unwrap();
 
-    let js_file_source = workspace.get_file_source("/project/a.js".into());
+    let js_file_source = workspace.get_file_source("/project/a.js".into(), false);
     let js = js_file_source.to_js_file_source().expect("JS file source");
     assert!(!js.is_typescript());
     assert!(!js.is_jsx());
@@ -391,7 +391,7 @@ function Foo({cond}) {
         Err(error) => panic!("File not available: {error}"),
     }
 
-    let jsx_file_source = workspace.get_file_source("/project/a.jsx".into());
+    let jsx_file_source = workspace.get_file_source("/project/a.jsx".into(), false);
     let jsx = jsx_file_source.to_js_file_source().expect("JS file source");
     assert!(!jsx.is_typescript());
     assert!(jsx.is_jsx());
diff --git a/crates/biome_test_utils/src/lib.rs b/crates/biome_test_utils/src/lib.rs
index 4984696762..cd01c2626a 100644
--- a/crates/biome_test_utils/src/lib.rs
+++ b/crates/biome_test_utils/src/lib.rs
@@ -86,7 +86,10 @@ pub fn create_analyzer_options<L: ServiceLanguage>(
             &L::lookup_settings(&settings.languages).linter,
             L::resolve_environment(&settings),
             &BiomePath::new(input_file),
-            &DocumentFileSource::from_path(input_file),
+            &DocumentFileSource::from_path(
+                input_file,
+                settings.experimental_full_html_support_enabled(),
+            ),
             None,
         )
     }
@@ -130,7 +133,10 @@ where
             .merge_with_configuration(configuration, None)
             .unwrap();
 
-        let document_file_source = DocumentFileSource::from_path(input_file);
+        let document_file_source = DocumentFileSource::from_path(
+            input_file,
+            settings.experimental_full_html_support_enabled(),
+        );
         settings.format_options::<L>(&input_file.into(), &document_file_source)
     }
 }
@@ -191,7 +197,7 @@ fn get_js_like_paths_in_dir(dir: &Utf8Path) -> Vec<BiomePath> {
             if path.is_dir() {
                 get_js_like_paths_in_dir(&path)
             } else {
-                DocumentFileSource::from_well_known(&path)
+                DocumentFileSource::from_well_known(&path, false)
                     .is_javascript_like()
                     .then(|| BiomePath::new(path))
                     .into_iter()
diff --git a/packages/@biomejs/backend-jsonrpc/src/workspace.ts b/packages/@biomejs/backend-jsonrpc/src/workspace.ts
index 9a270f969f..7be5a6207b 100644
--- a/packages/@biomejs/backend-jsonrpc/src/workspace.ts
+++ b/packages/@biomejs/backend-jsonrpc/src/workspace.ts
@@ -8,7 +8,13 @@ export interface SupportsFeatureParams {
 export type FeatureName = FeatureKind[];
 export type BiomePath = string;
 export type ProjectKey = number;
-export type FeatureKind = "format" | "lint" | "search" | "assist" | "debug";
+export type FeatureKind =
+	| "format"
+	| "lint"
+	| "search"
+	| "assist"
+	| "debug"
+	| "htmlFullSupport";
 export interface FileFeaturesResult {
 	featuresSupported: FeaturesSupported;
 }
@@ -245,6 +251,10 @@ export interface GritConfiguration {
  */
 export interface HtmlConfiguration {
 	assist?: HtmlAssistConfiguration;
+	/**
+	 * Enables full support for HTML, Vue, Svelte and Astro files.
+	 */
+	experimentalFullSupportEnabled?: Bool;
 	/**
 	 * HTML formatter options
 	 */
@@ -8555,12 +8565,7 @@ export interface NoTemplateCurlyInStringOptions {}
 export interface NoThenPropertyOptions {}
 export interface NoTsIgnoreOptions {}
 export interface NoUnassignedVariablesOptions {}
-export interface NoUnknownAtRulesOptions {
-	/**
-	 * A list of unknown at-rule names to ignore (case-insensitive).
-	 */
-	ignore: string[];
-}
+export interface NoUnknownAtRulesOptions {}
 export interface NoUnsafeDeclarationMergingOptions {}
 export interface NoUnsafeNegationOptions {}
 export interface NoUselessEscapeInStringOptions {}
@@ -9416,7 +9421,7 @@ export type DocumentFileSource =
 	| { Grit: GritFileSource };
 export interface JsFileSource {
 	/**
-	 * Used to mark if the source is being used for an Astro, Svelte or Vue file
+	 * Used to mark if the JavaScript is embedded inside some particular files. This affects the parsing. For example, if inside an Astro file, a top-level return statement is allowed.
 	 */
 	embedding_kind: EmbeddingKind;
 	language: Language;
@@ -9598,17 +9603,18 @@ export interface PullDiagnosticsParams {
 	/**
 	 * Rules to apply on top of the configuration
 	 */
-	enabledRules?: Selector[];
-	only?: Selector[];
+	enabledRules?: AnalyzerSelector[];
+	only?: AnalyzerSelector[];
 	path: BiomePath;
 	projectKey: ProjectKey;
 	/**
 	 * When `false` the diagnostics, don't have code frames of the code actions (fixes, suppressions, etc.)
 	 */
 	pullCodeActions: boolean;
-	skip?: Selector[];
+	skip?: AnalyzerSelector[];
 }
 export type RuleCategories = RuleCategory[];
+export type AnalyzerSelector = string;
 export type RuleCategory = "syntax" | "lint" | "action" | "transformation";
 export interface PullDiagnosticsResult {
 	diagnostics: Diagnostic[];
@@ -9617,12 +9623,12 @@ export interface PullDiagnosticsResult {
 }
 export interface PullActionsParams {
 	categories?: RuleCategories;
-	enabledRules?: Selector[];
-	only?: Selector[];
+	enabledRules?: AnalyzerSelector[];
+	only?: AnalyzerSelector[];
 	path: BiomePath;
 	projectKey: ProjectKey;
 	range?: TextRange;
-	skip?: Selector[];
+	skip?: AnalyzerSelector[];
 	suppressionReason?: string;
 }
 export interface PullActionsResult {
@@ -9630,6 +9636,7 @@ export interface PullActionsResult {
 }
 export interface CodeAction {
 	category: ActionCategory;
+	offset?: TextSize;
 	ruleName?: [string, string];
 	suggestion: CodeSuggestion;
 }
@@ -9717,14 +9724,14 @@ export interface FixFileParams {
 	/**
 	 * Rules to apply to the file
 	 */
-	enabledRules?: Selector[];
+	enabledRules?: AnalyzerSelector[];
 	fixFileMode: FixFileMode;
-	only?: Selector[];
+	only?: AnalyzerSelector[];
 	path: BiomePath;
 	projectKey: ProjectKey;
 	ruleCategories: RuleCategories;
 	shouldFormat: boolean;
-	skip?: Selector[];
+	skip?: AnalyzerSelector[];
 	suppressionReason?: string;
 }
 /**
diff --git a/packages/@biomejs/biome/configuration_schema.json b/packages/@biomejs/biome/configuration_schema.json
index ae2bb79438..a1821b3d47 100644
--- a/packages/@biomejs/biome/configuration_schema.json
+++ b/packages/@biomejs/biome/configuration_schema.json
@@ -1863,6 +1863,10 @@
 						{ "type": "null" }
 					]
 				},
+				"experimentalFullSupportEnabled": {
+					"description": "Enables full support for HTML, Vue, Svelte and Astro files.",
+					"anyOf": [{ "$ref": "#/definitions/Bool" }, { "type": "null" }]
+				},
 				"formatter": {
 					"description": "HTML formatter options",
 					"anyOf": [
@@ -4466,13 +4470,6 @@
 		},
 		"NoUnknownAtRulesOptions": {
 			"type": "object",
-			"properties": {
-				"ignore": {
-					"description": "A list of unknown at-rule names to ignore (case-insensitive).",
-					"type": "array",
-					"items": { "type": "string" }
-				}
-			},
 			"additionalProperties": false
 		},
 		"NoUnknownFunctionConfiguration": {
diff --git a/xtask/codegen/html.ungram b/xtask/codegen/html.ungram
index ea7aa639c5..f8c0045d65 100644
--- a/xtask/codegen/html.ungram
+++ b/xtask/codegen/html.ungram
@@ -144,9 +144,12 @@ AnyAstroFrontmatterElement =
 
 AstroFrontmatterElement =
 	l_fence: '---'
-	content: 'html_literal'?
+	content: AstroEmbeddedContent
 	r_fence: '---'
 
+AstroEmbeddedContent =
+	content: 'html_literal'?
+
 // ==================================
 // Attributes
 // ==================================
diff --git a/xtask/codegen/src/html_kinds_src.rs b/xtask/codegen/src/html_kinds_src.rs
index e0b58e6453..22dd5a1c9c 100644
--- a/xtask/codegen/src/html_kinds_src.rs
+++ b/xtask/codegen/src/html_kinds_src.rs
@@ -31,6 +31,7 @@ pub const HTML_KINDS_SRC: KindsSrc = KindsSrc {
         "HTML_SELF_CLOSING_TAG",
         "HTML_ELEMENT",
         "ASTRO_FRONTMATTER_ELEMENT",
+        "ASTRO_EMBEDDED_CONTENT",
         "HTML_OPENING_ELEMENT",
         "HTML_CLOSING_ELEMENT",
         "HTML_SELF_CLOSING_ELEMENT",
diff --git a/xtask/rules_check/src/lib.rs b/xtask/rules_check/src/lib.rs
index d4a48da6f6..03077a85cc 100644
--- a/xtask/rules_check/src/lib.rs
+++ b/xtask/rules_check/src/lib.rs
@@ -405,8 +405,8 @@ fn assert_lint(
                 });
             }
         }
-        DocumentFileSource::Html(..) => {
-            let parse = biome_html_parser::parse_html(code, HtmlParseOptions::default());
+        DocumentFileSource::Html(source) => {
+            let parse = biome_html_parser::parse_html(code, HtmlParseOptions::from(&source));
 
             if parse.has_errors() {
                 for diag in parse.into_diagnostics() {
