diff --git a/.changeset/breezy-suns-leave.md b/.changeset/breezy-suns-leave.md
new file mode 100644
index 0000000000..84f3fc9d48
--- /dev/null
+++ b/.changeset/breezy-suns-leave.md
@@ -0,0 +1,5 @@
+---
+"@biomejs/biome": minor
+---
+
+Added `ignore` option to `noUnknownAtRules`. If an unknown at-rule matches any of the items provided in `ignore`, a diagnostic won't be emitted.
diff --git a/.changeset/stupid-groups-grow.md b/.changeset/stupid-groups-grow.md
deleted file mode 100644
index 1a33f29217..0000000000
--- a/.changeset/stupid-groups-grow.md
+++ /dev/null
@@ -1,9 +0,0 @@
----
-"@biomejs/biome": minor
----
-
-Added linting and assist support for `.html` files, with addition of two new configurations:
-- `html.linter.enabled`
-- `html.assist.enabled`
-
-The HTML linter, in this release, only contains the rule `noHeaderScope`. More rules will be released in the upcoming releases.
diff --git a/.changeset/upset-impalas-grab.md b/.changeset/upset-impalas-grab.md
deleted file mode 100644
index 7a27e22c92..0000000000
--- a/.changeset/upset-impalas-grab.md
+++ /dev/null
@@ -1,12 +0,0 @@
----
-"@biomejs/biome": minor
----
-
-Added **experimental** full support for HTML, Vue, Svelte and Astro files. In this release, the HTML parser
-has been enhanced, and it's now able to parse `.vue`, `.svelte` and `.astro` files.
-
-This means that now Biome is able to lint and format the JavaScript (TypeScript), HTML and CSS code that is contained in these files.
-
-Now that the main architecture is stable and working, in the upcoming patches and minors we will also fix possible inaccuracies and edge cases coming from existing lint rules, such as `noUnusedVariables` inside `<script>` blocks or frontmatter.
-
-The support is considered experimental because there might be cases that aren't fine-parsed yet, hence causing possible inaccuracies when it comes to formatting and linting.
diff --git a/.changeset/wise-forks-hide.md b/.changeset/wise-forks-hide.md
deleted file mode 100644
index a2a197e520..0000000000
--- a/.changeset/wise-forks-hide.md
+++ /dev/null
@@ -1,18 +0,0 @@
----
-"@biomejs/biome": minor
----
-
-Added a new option called `html.interpolation`. This option enables the parsing of text expressions (or interpolation) in HTML files.
-
-The following `file.html` will be correctly formatted:
-
-```html
-<!-- file.html -->
-<div>
-  Hello {{ name }}!
-  <p>Your balance is: {{ account.balance }}</p>
-  <button>{{ isLoading ? "Loading..." : "Submit" }}</button>
-</div>
-```
-
-To note that `html.interpolation` only parses text expressions that are delimited by double curly braces (`{{ }}`). The content of expressions is parsed as normal text.
diff --git a/crates/biome_cli/src/execute/process_file.rs b/crates/biome_cli/src/execute/process_file.rs
index 978d3c6465..019cf01c29 100644
--- a/crates/biome_cli/src/execute/process_file.rs
+++ b/crates/biome_cli/src/execute/process_file.rs
@@ -197,15 +197,14 @@ pub(crate) fn process_file(ctx: &TraversalOptions, biome_path: &BiomePath) -> Fi
                 suppress,
                 suppression_reason.as_deref(),
                 categories.build(),
-                &file_features,
             )
         }
         TraversalMode::Format { .. } => {
             // the unsupported case should be handled already at this point
-            format(shared_context, biome_path.clone(), &file_features)
+            format(shared_context, biome_path.clone())
         }
         TraversalMode::Check { .. } | TraversalMode::CI { .. } => {
-            check_file(shared_context, biome_path.clone(), &file_features)
+            check_file(shared_context, biome_path.clone(), file_features)
         }
         TraversalMode::Migrate { .. } => {
             unreachable!("The migration should not be called for this file")
diff --git a/crates/biome_cli/src/execute/process_file/check.rs b/crates/biome_cli/src/execute/process_file/check.rs
index ff69d8162b..aef9c788c1 100644
--- a/crates/biome_cli/src/execute/process_file/check.rs
+++ b/crates/biome_cli/src/execute/process_file/check.rs
@@ -11,7 +11,7 @@ use biome_service::workspace::FeaturesSupported;
 pub(crate) fn check_file<'ctx>(
     ctx: &'ctx SharedTraversalOptions<'ctx, '_>,
     path: BiomePath,
-    file_features: &FeaturesSupported,
+    file_features: FeaturesSupported,
 ) -> FileResult {
     let mut has_failures = false;
     let mut workspace_file = WorkspaceFile::new(ctx, path)?;
@@ -34,14 +34,8 @@ pub(crate) fn check_file<'ctx>(
         categories = categories.with_assist();
     }
 
-    let analyzer_result = analyze_with_guard(
-        ctx,
-        &mut workspace_file,
-        false,
-        None,
-        categories.build(),
-        file_features,
-    );
+    let analyzer_result =
+        analyze_with_guard(ctx, &mut workspace_file, false, None, categories.build());
 
     let mut changed = false;
     // To reduce duplication of the same error on format and lint_and_assist
@@ -73,7 +67,7 @@ pub(crate) fn check_file<'ctx>(
         if ctx.execution.should_skip_parse_errors() && skipped_parse_error {
             // Parse errors are already skipped during the analyze phase, so no need to do it here.
         } else {
-            let format_result = format_with_guard(ctx, &mut workspace_file, file_features);
+            let format_result = format_with_guard(ctx, &mut workspace_file);
             match format_result {
                 Ok(status) => {
                     if status.is_changed() {
diff --git a/crates/biome_cli/src/execute/process_file/format.rs b/crates/biome_cli/src/execute/process_file/format.rs
index c24f5aaf92..ce324721d3 100644
--- a/crates/biome_cli/src/execute/process_file/format.rs
+++ b/crates/biome_cli/src/execute/process_file/format.rs
@@ -7,17 +7,13 @@ use biome_analyze::RuleCategoriesBuilder;
 use biome_diagnostics::{Diagnostic, DiagnosticExt, Error, Severity, category};
 use biome_fs::{BiomePath, TraversalContext};
 use biome_service::diagnostics::FileTooLarge;
-use biome_service::file_handlers::astro::AstroFileHandler;
-use biome_service::file_handlers::svelte::SvelteFileHandler;
-use biome_service::file_handlers::vue::VueFileHandler;
-use biome_service::workspace::FeaturesSupported;
+use biome_service::file_handlers::{AstroFileHandler, SvelteFileHandler, VueFileHandler};
 use tracing::{debug, instrument};
 
 #[instrument(name = "cli_format", level = "debug", skip(ctx, path))]
 pub(crate) fn format<'ctx>(
     ctx: &'ctx SharedTraversalOptions<'ctx, '_>,
     path: BiomePath,
-    features_supported: &FeaturesSupported,
 ) -> FileResult {
     let mut workspace_file = WorkspaceFile::new(ctx, path)?;
     let result = workspace_file.guard().check_file_size()?;
@@ -29,7 +25,7 @@ pub(crate) fn format<'ctx>(
         );
         Ok(FileStatus::Ignored)
     } else {
-        format_with_guard(ctx, &mut workspace_file, features_supported)
+        format_with_guard(ctx, &mut workspace_file)
     }
 }
 
@@ -37,7 +33,6 @@ pub(crate) fn format<'ctx>(
 pub(crate) fn format_with_guard<'ctx>(
     ctx: &'ctx SharedTraversalOptions<'ctx, '_>,
     workspace_file: &mut WorkspaceFile,
-    features_supported: &FeaturesSupported,
 ) -> FileResult {
     let diagnostics_result = workspace_file
         .guard()
@@ -92,29 +87,27 @@ pub(crate) fn format_with_guard<'ctx>(
 
     let mut output = printed.into_code();
 
-    if !features_supported.supports_full_html_support() {
-        match workspace_file.as_extension() {
-            Some("astro") => {
-                if output.is_empty() {
-                    return Ok(FileStatus::Unchanged);
-                }
-                output = AstroFileHandler::output(input.as_str(), output.as_str());
+    match workspace_file.as_extension() {
+        Some("astro") => {
+            if output.is_empty() {
+                return Ok(FileStatus::Unchanged);
             }
-            Some("vue") => {
-                if output.is_empty() {
-                    return Ok(FileStatus::Unchanged);
-                }
-                output = VueFileHandler::output(input.as_str(), output.as_str());
+            output = AstroFileHandler::output(input.as_str(), output.as_str());
+        }
+        Some("vue") => {
+            if output.is_empty() {
+                return Ok(FileStatus::Unchanged);
             }
+            output = VueFileHandler::output(input.as_str(), output.as_str());
+        }
 
-            Some("svelte") => {
-                if output.is_empty() {
-                    return Ok(FileStatus::Unchanged);
-                }
-                output = SvelteFileHandler::output(input.as_str(), output.as_str());
+        Some("svelte") => {
+            if output.is_empty() {
+                return Ok(FileStatus::Unchanged);
             }
-            _ => {}
+            output = SvelteFileHandler::output(input.as_str(), output.as_str());
         }
+        _ => {}
     }
 
     debug!("Format output is different from input: {}", output != input);
diff --git a/crates/biome_cli/src/execute/process_file/lint_and_assist.rs b/crates/biome_cli/src/execute/process_file/lint_and_assist.rs
index 21aacf6213..a025e4fcbe 100644
--- a/crates/biome_cli/src/execute/process_file/lint_and_assist.rs
+++ b/crates/biome_cli/src/execute/process_file/lint_and_assist.rs
@@ -7,10 +7,7 @@ use biome_diagnostics::{Diagnostic, DiagnosticExt, Error, Severity, category};
 use biome_fs::{BiomePath, TraversalContext};
 use biome_rowan::TextSize;
 use biome_service::diagnostics::FileTooLarge;
-use biome_service::file_handlers::astro::AstroFileHandler;
-use biome_service::file_handlers::svelte::SvelteFileHandler;
-use biome_service::file_handlers::vue::VueFileHandler;
-use biome_service::workspace::FeaturesSupported;
+use biome_service::file_handlers::{AstroFileHandler, SvelteFileHandler, VueFileHandler};
 use tracing::{info, instrument};
 
 /// Lints a single file and returns a [FileResult]
@@ -21,7 +18,6 @@ pub(crate) fn lint_and_assist<'ctx>(
     suppress: bool,
     suppression_reason: Option<&str>,
     categories: RuleCategories,
-    features_supported: &FeaturesSupported,
 ) -> FileResult {
     let mut workspace_file = WorkspaceFile::new(ctx, path)?;
     let result = workspace_file.guard().check_file_size()?;
@@ -39,7 +35,6 @@ pub(crate) fn lint_and_assist<'ctx>(
             suppress,
             suppression_reason,
             categories,
-            features_supported,
         )
     }
 }
@@ -52,7 +47,6 @@ pub(crate) fn analyze_with_guard<'ctx>(
     suppress: bool,
     suppression_reason: Option<&str>,
     categories: RuleCategories,
-    features_supported: &FeaturesSupported,
 ) -> FileResult {
     let mut input = workspace_file.input()?;
     let mut changed = false;
@@ -97,19 +91,17 @@ pub(crate) fn analyze_with_guard<'ctx>(
 
         let mut output = fix_result.code;
 
-        if !features_supported.supports_full_html_support() {
-            match workspace_file.as_extension() {
-                Some("astro") => {
-                    output = AstroFileHandler::output(input.as_str(), output.as_str());
-                }
-                Some("vue") => {
-                    output = VueFileHandler::output(input.as_str(), output.as_str());
-                }
-                Some("svelte") => {
-                    output = SvelteFileHandler::output(input.as_str(), output.as_str());
-                }
-                _ => {}
+        match workspace_file.as_extension() {
+            Some("astro") => {
+                output = AstroFileHandler::output(input.as_str(), output.as_str());
             }
+            Some("vue") => {
+                output = VueFileHandler::output(input.as_str(), output.as_str());
+            }
+            Some("svelte") => {
+                output = SvelteFileHandler::output(input.as_str(), output.as_str());
+            }
+            _ => {}
         }
         if output != input {
             changed = true;
@@ -138,15 +130,11 @@ pub(crate) fn analyze_with_guard<'ctx>(
         && pull_diagnostics_result.skipped_diagnostics == 0;
 
     if !no_diagnostics {
-        let offset = if features_supported.supports_full_html_support() {
-            None
-        } else {
-            match workspace_file.as_extension() {
-                Some("vue") => VueFileHandler::start(input.as_str()),
-                Some("astro") => AstroFileHandler::start(input.as_str()),
-                Some("svelte") => SvelteFileHandler::start(input.as_str()),
-                _ => None,
-            }
+        let offset = match workspace_file.as_extension() {
+            Some("vue") => VueFileHandler::start(input.as_str()),
+            Some("astro") => AstroFileHandler::start(input.as_str()),
+            Some("svelte") => SvelteFileHandler::start(input.as_str()),
+            _ => None,
         };
 
         ctx.push_message(Message::Diagnostics {
diff --git a/crates/biome_cli/src/execute/process_file/search.rs b/crates/biome_cli/src/execute/process_file/search.rs
index 65122f3c77..d28078d8ba 100644
--- a/crates/biome_cli/src/execute/process_file/search.rs
+++ b/crates/biome_cli/src/execute/process_file/search.rs
@@ -35,7 +35,7 @@ pub(crate) fn search_with_guard<'ctx>(
 ) -> FileResult {
     let _ = tracing::info_span!("Search ", path =? workspace_file.path).entered();
 
-    let file_source = DocumentFileSource::from_path(workspace_file.path.as_path(), false);
+    let file_source = DocumentFileSource::from_path(workspace_file.path.as_path());
     let pattern_language = match &_ctx.execution.traversal_mode {
         TraversalMode::Search {
             language: Some(pattern_language),
diff --git a/crates/biome_cli/src/execute/std_in.rs b/crates/biome_cli/src/execute/std_in.rs
index 6972f7750e..1420358c88 100644
--- a/crates/biome_cli/src/execute/std_in.rs
+++ b/crates/biome_cli/src/execute/std_in.rs
@@ -78,15 +78,11 @@ pub(crate) fn run<'a>(
             })?;
 
             let code = printed.into_code();
-            let output = if !file_features.supports_full_html_support() {
-                match biome_path.extension() {
-                    Some("astro") => AstroFileHandler::output(content, code.as_str()),
-                    Some("vue") => VueFileHandler::output(content, code.as_str()),
-                    Some("svelte") => SvelteFileHandler::output(content, code.as_str()),
-                    _ => code,
-                }
-            } else {
-                code
+            let output = match biome_path.extension() {
+                Some("astro") => AstroFileHandler::output(content, code.as_str()),
+                Some("vue") => VueFileHandler::output(content, code.as_str()),
+                Some("svelte") => SvelteFileHandler::output(content, code.as_str()),
+                _ => code,
             };
             console.append(markup! {
                 {output}
@@ -178,15 +174,11 @@ pub(crate) fn run<'a>(
                 rule_categories: rule_categories.build(),
             })?;
             let code = fix_file_result.code;
-            let output = if !file_features.supports_full_html_support() {
-                match biome_path.extension() {
-                    Some("astro") => AstroFileHandler::output(&new_content, code.as_str()),
-                    Some("vue") => VueFileHandler::output(&new_content, code.as_str()),
-                    Some("svelte") => SvelteFileHandler::output(&new_content, code.as_str()),
-                    _ => code,
-                }
-            } else {
-                code
+            let output = match biome_path.extension() {
+                Some("astro") => AstroFileHandler::output(&new_content, code.as_str()),
+                Some("vue") => VueFileHandler::output(&new_content, code.as_str()),
+                Some("svelte") => SvelteFileHandler::output(&new_content, code.as_str()),
+                _ => code,
             };
             if output != new_content {
                 version += 1;
@@ -206,15 +198,11 @@ pub(crate) fn run<'a>(
                 path: biome_path.clone(),
             })?;
             let code = printed.into_code();
-            let output = if !file_features.supports_full_html_support() {
-                match biome_path.extension() {
-                    Some("astro") => AstroFileHandler::output(&new_content, code.as_str()),
-                    Some("vue") => VueFileHandler::output(&new_content, code.as_str()),
-                    Some("svelte") => SvelteFileHandler::output(&new_content, code.as_str()),
-                    _ => code,
-                }
-            } else {
-                code
+            let output = match biome_path.extension() {
+                Some("astro") => AstroFileHandler::output(&new_content, code.as_str()),
+                Some("vue") => VueFileHandler::output(&new_content, code.as_str()),
+                Some("svelte") => SvelteFileHandler::output(&new_content, code.as_str()),
+                _ => code,
             };
             if (mode.is_safe_fixes_enabled() || mode.is_safe_and_unsafe_fixes_enabled())
                 && output != new_content
diff --git a/crates/biome_configuration/src/analyzer/mod.rs b/crates/biome_configuration/src/analyzer/mod.rs
index 653dece2ac..a35685699b 100644
--- a/crates/biome_configuration/src/analyzer/mod.rs
+++ b/crates/biome_configuration/src/analyzer/mod.rs
@@ -501,7 +501,7 @@ impl<'de> serde::Deserialize<'de> for AnalyzerSelector {
 #[cfg(feature = "schema")]
 impl schemars::JsonSchema for AnalyzerSelector {
     fn schema_name() -> String {
-        "AnalyzerSelector".to_string()
+        "Selector".to_string()
     }
     fn json_schema(generator: &mut schemars::r#gen::SchemaGenerator) -> schemars::schema::Schema {
         String::json_schema(generator)
diff --git a/crates/biome_configuration/src/html.rs b/crates/biome_configuration/src/html.rs
index 3a4494ca70..ed2d83e716 100644
--- a/crates/biome_configuration/src/html.rs
+++ b/crates/biome_configuration/src/html.rs
@@ -9,8 +9,6 @@ use biome_html_formatter::context::{
 use bpaf::Bpaf;
 use serde::{Deserialize, Serialize};
 
-pub type ExperimentalFullSupportEnabled = Bool<false>;
-
 /// Options applied to HTML files
 #[derive(
     Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize, Bpaf, Deserializable, Merge,
@@ -18,11 +16,6 @@ pub type ExperimentalFullSupportEnabled = Bool<false>;
 #[cfg_attr(feature = "schema", derive(schemars::JsonSchema))]
 #[serde(rename_all = "camelCase", default, deny_unknown_fields)]
 pub struct HtmlConfiguration {
-    /// Enables full support for HTML, Vue, Svelte and Astro files.
-    #[serde(skip_serializing_if = "Option::is_none")]
-    #[bpaf(hide)]
-    pub experimental_full_support_enabled: Option<ExperimentalFullSupportEnabled>,
-
     /// HTML parsing options
     #[bpaf(hide, pure(Default::default()))]
     #[serde(skip_serializing_if = "Option::is_none")]
@@ -44,8 +37,8 @@ pub struct HtmlConfiguration {
 }
 
 pub type HtmlFormatterEnabled = Bool<false>; // Keep it disabled by default while experimental.
-pub type HtmlLinterEnabled = Bool<true>;
-pub type HtmlAssistEnabled = Bool<true>;
+pub type HtmlLinterEnabled = Bool<false>;
+pub type HtmlAssistEnabled = Bool<false>;
 pub type HtmlParseInterpolation = Bool<false>;
 
 /// Options that changes how the HTML parser behaves
diff --git a/crates/biome_css_analyze/src/lint/suspicious/no_unknown_at_rules.rs b/crates/biome_css_analyze/src/lint/suspicious/no_unknown_at_rules.rs
index 254fb7b5c5..169e8cdc62 100644
--- a/crates/biome_css_analyze/src/lint/suspicious/no_unknown_at_rules.rs
+++ b/crates/biome_css_analyze/src/lint/suspicious/no_unknown_at_rules.rs
@@ -32,14 +32,40 @@ declare_lint_rule! {
     /// @charset 'UTF-8';
     /// ```
     ///
-    /// ```css
-    /// @media (max-width: 960px) {
-    ///   body {
-    ///     font-size: 13px;
-    ///   }
-    /// }
-    /// ```
-    pub NoUnknownAtRules {
+     /// ```css
+     /// @media (max-width: 960px) {
+     ///   body {
+     ///     font-size: 13px;
+     ///   }
+     /// }
+     /// ```
+     ///
+     /// ## Options
+     ///
+     /// ### `ignore`
+     ///
+     /// A list of unknown at-rule names to ignore (case-insensitive).
+     ///
+     /// ```json,options
+     /// {
+     ///   "options": {
+     ///     "ignore": [
+     ///       "custom-at-rule",
+     ///       "my-custom-rule"
+     ///     ]
+     ///   }
+     /// }
+     /// ```
+     ///
+     /// #### Valid
+     ///
+     /// ```css,use_options
+     /// @custom-at-rule {}
+     /// @my-custom-rule {
+     ///   color: red;
+     /// }
+     /// ```
+     pub NoUnknownAtRules {
         version: "2.0.0",
         name: "noUnknownAtRules",
         language: "css",
@@ -53,6 +79,16 @@ declare_node_union! {
   pub AnyUnknownAtRule = CssUnknownBlockAtRule | CssUnknownValueAtRule
 }
 
+/// Determines if the given unknown at-rule name should be ignored.
+fn should_ignore(name: &str, options: &NoUnknownAtRulesOptions) -> bool {
+    for ignore_pattern in &options.ignore {
+        if name.eq_ignore_ascii_case(ignore_pattern) {
+            return true;
+        }
+    }
+    false
+}
+
 pub struct NoUnknownAtRuleState {
     range: TextRange,
     name: String,
@@ -70,9 +106,16 @@ impl Rule for NoUnknownAtRules {
             AnyUnknownAtRule::CssUnknownBlockAtRule(rule) => rule.name().ok()?,
             AnyUnknownAtRule::CssUnknownValueAtRule(rule) => rule.name().ok()?,
         };
+        let name = rule.value_token().ok()?.text_trimmed().to_string();
+
+        // Check if this unknown at-rule should be ignored
+        if should_ignore(&name, ctx.options()) {
+            return None;
+        }
+
         Some(NoUnknownAtRuleState {
             range: rule.range(),
-            name: rule.value_token().ok()?.text_trimmed().to_string(),
+            name,
         })
     }
 
diff --git a/crates/biome_formatter_test/src/spec.rs b/crates/biome_formatter_test/src/spec.rs
index d918e4ff51..480c592ced 100644
--- a/crates/biome_formatter_test/src/spec.rs
+++ b/crates/biome_formatter_test/src/spec.rs
@@ -280,13 +280,9 @@ where
                 panic!("Configuration is invalid");
             }
 
-            let format_language = self.language.to_format_language(
-                &settings,
-                &DocumentFileSource::from_path(
-                    input_file,
-                    settings.experimental_full_html_support_enabled(),
-                ),
-            );
+            let format_language = self
+                .language
+                .to_format_language(&settings, &DocumentFileSource::from_path(input_file));
 
             let (mut output_code, printed) = self.formatted(&parsed, format_language.clone());
 
diff --git a/crates/biome_html_factory/src/generated/node_factory.rs b/crates/biome_html_factory/src/generated/node_factory.rs
index 224504a5da..baf4a7c301 100644
--- a/crates/biome_html_factory/src/generated/node_factory.rs
+++ b/crates/biome_html_factory/src/generated/node_factory.rs
@@ -6,40 +6,37 @@ use biome_html_syntax::{
     HtmlSyntaxToken as SyntaxToken, *,
 };
 use biome_rowan::AstNode;
-pub fn astro_embedded_content() -> AstroEmbeddedContentBuilder {
-    AstroEmbeddedContentBuilder {
+pub fn astro_frontmatter_element(
+    l_fence_token: SyntaxToken,
+    r_fence_token: SyntaxToken,
+) -> AstroFrontmatterElementBuilder {
+    AstroFrontmatterElementBuilder {
+        l_fence_token,
+        r_fence_token,
         content_token: None,
     }
 }
-pub struct AstroEmbeddedContentBuilder {
+pub struct AstroFrontmatterElementBuilder {
+    l_fence_token: SyntaxToken,
+    r_fence_token: SyntaxToken,
     content_token: Option<SyntaxToken>,
 }
-impl AstroEmbeddedContentBuilder {
+impl AstroFrontmatterElementBuilder {
     pub fn with_content_token(mut self, content_token: SyntaxToken) -> Self {
         self.content_token = Some(content_token);
         self
     }
-    pub fn build(self) -> AstroEmbeddedContent {
-        AstroEmbeddedContent::unwrap_cast(SyntaxNode::new_detached(
-            HtmlSyntaxKind::ASTRO_EMBEDDED_CONTENT,
-            [self.content_token.map(|token| SyntaxElement::Token(token))],
+    pub fn build(self) -> AstroFrontmatterElement {
+        AstroFrontmatterElement::unwrap_cast(SyntaxNode::new_detached(
+            HtmlSyntaxKind::ASTRO_FRONTMATTER_ELEMENT,
+            [
+                Some(SyntaxElement::Token(self.l_fence_token)),
+                self.content_token.map(|token| SyntaxElement::Token(token)),
+                Some(SyntaxElement::Token(self.r_fence_token)),
+            ],
         ))
     }
 }
-pub fn astro_frontmatter_element(
-    l_fence_token: SyntaxToken,
-    content: AstroEmbeddedContent,
-    r_fence_token: SyntaxToken,
-) -> AstroFrontmatterElement {
-    AstroFrontmatterElement::unwrap_cast(SyntaxNode::new_detached(
-        HtmlSyntaxKind::ASTRO_FRONTMATTER_ELEMENT,
-        [
-            Some(SyntaxElement::Token(l_fence_token)),
-            Some(SyntaxElement::Node(content.into_syntax())),
-            Some(SyntaxElement::Token(r_fence_token)),
-        ],
-    ))
-}
 pub fn html_attribute(name: HtmlAttributeName) -> HtmlAttributeBuilder {
     HtmlAttributeBuilder {
         name,
diff --git a/crates/biome_html_factory/src/generated/syntax_factory.rs b/crates/biome_html_factory/src/generated/syntax_factory.rs
index ea8791c8ef..ff6a33d039 100644
--- a/crates/biome_html_factory/src/generated/syntax_factory.rs
+++ b/crates/biome_html_factory/src/generated/syntax_factory.rs
@@ -21,25 +21,6 @@ impl SyntaxFactory for HtmlSyntaxFactory {
             | HTML_BOGUS_TEXT_EXPRESSION => {
                 RawSyntaxNode::new(kind, children.into_iter().map(Some))
             }
-            ASTRO_EMBEDDED_CONTENT => {
-                let mut elements = (&children).into_iter();
-                let mut slots: RawNodeSlots<1usize> = RawNodeSlots::default();
-                let mut current_element = elements.next();
-                if let Some(element) = &current_element
-                    && element.kind() == HTML_LITERAL
-                {
-                    slots.mark_present();
-                    current_element = elements.next();
-                }
-                slots.next_slot();
-                if current_element.is_some() {
-                    return RawSyntaxNode::new(
-                        ASTRO_EMBEDDED_CONTENT.to_bogus(),
-                        children.into_iter().map(Some),
-                    );
-                }
-                slots.into_node(ASTRO_EMBEDDED_CONTENT, children)
-            }
             ASTRO_FRONTMATTER_ELEMENT => {
                 let mut elements = (&children).into_iter();
                 let mut slots: RawNodeSlots<3usize> = RawNodeSlots::default();
@@ -52,7 +33,7 @@ impl SyntaxFactory for HtmlSyntaxFactory {
                 }
                 slots.next_slot();
                 if let Some(element) = &current_element
-                    && AstroEmbeddedContent::can_cast(element.kind())
+                    && element.kind() == HTML_LITERAL
                 {
                     slots.mark_present();
                     current_element = elements.next();
diff --git a/crates/biome_html_formatter/src/astro/auxiliary/embedded_content.rs b/crates/biome_html_formatter/src/astro/auxiliary/embedded_content.rs
deleted file mode 100644
index b89a03a45a..0000000000
--- a/crates/biome_html_formatter/src/astro/auxiliary/embedded_content.rs
+++ /dev/null
@@ -1,22 +0,0 @@
-use crate::prelude::*;
-use biome_deserialize::TextRange;
-use biome_html_syntax::AstroEmbeddedContent;
-use biome_rowan::AstNode;
-#[derive(Debug, Clone, Default)]
-pub(crate) struct FormatAstroEmbeddedContent;
-impl FormatNodeRule<AstroEmbeddedContent> for FormatAstroEmbeddedContent {
-    fn fmt_fields(&self, node: &AstroEmbeddedContent, f: &mut HtmlFormatter) -> FormatResult<()> {
-        format_html_verbatim_node(node.syntax()).fmt(f)
-    }
-
-    fn embedded_node_range(
-        &self,
-        node: &AstroEmbeddedContent,
-        f: &mut HtmlFormatter,
-    ) -> Option<TextRange> {
-        if !f.context().should_delegate_fmt_embedded_nodes() {
-            return None;
-        }
-        Some(node.range())
-    }
-}
diff --git a/crates/biome_html_formatter/src/astro/auxiliary/frontmatter_element.rs b/crates/biome_html_formatter/src/astro/auxiliary/frontmatter_element.rs
index 5aaf99aebe..059ec17452 100644
--- a/crates/biome_html_formatter/src/astro/auxiliary/frontmatter_element.rs
+++ b/crates/biome_html_formatter/src/astro/auxiliary/frontmatter_element.rs
@@ -12,12 +12,16 @@ impl FormatNodeRule<AstroFrontmatterElement> for FormatAstroFrontmatterElement {
     ) -> FormatResult<()> {
         let AstroFrontmatterElementFields {
             l_fence_token,
-            content,
+            content_token,
             r_fence_token,
         } = node.as_fields();
 
         write!(f, [l_fence_token.format(), hard_line_break()])?;
-        write!(f, [content.format(), hard_line_break()])?;
+
+        if let Some(content_token) = content_token {
+            write!(f, [content_token.format(), hard_line_break()])?;
+        }
+
         write!(f, [r_fence_token.format()])?;
 
         Ok(())
diff --git a/crates/biome_html_formatter/src/astro/auxiliary/mod.rs b/crates/biome_html_formatter/src/astro/auxiliary/mod.rs
index 8eb6037e95..e51bcc0e90 100644
--- a/crates/biome_html_formatter/src/astro/auxiliary/mod.rs
+++ b/crates/biome_html_formatter/src/astro/auxiliary/mod.rs
@@ -1,4 +1,3 @@
 //! This is a generated file. Don't modify it by hand! Run 'cargo codegen formatter' to re-generate the file.
 
-pub(crate) mod embedded_content;
 pub(crate) mod frontmatter_element;
diff --git a/crates/biome_html_formatter/src/generated.rs b/crates/biome_html_formatter/src/generated.rs
index d2ffc6624e..d157094a37 100644
--- a/crates/biome_html_formatter/src/generated.rs
+++ b/crates/biome_html_formatter/src/generated.rs
@@ -6,44 +6,6 @@ use crate::{
     AsFormat, FormatBogusNodeRule, FormatNodeRule, HtmlFormatContext, HtmlFormatter, IntoFormat,
 };
 use biome_formatter::{FormatOwnedWithRule, FormatRefWithRule, FormatResult, FormatRule};
-impl FormatRule<biome_html_syntax::AstroEmbeddedContent>
-    for crate::astro::auxiliary::embedded_content::FormatAstroEmbeddedContent
-{
-    type Context = HtmlFormatContext;
-    #[inline(always)]
-    fn fmt(
-        &self,
-        node: &biome_html_syntax::AstroEmbeddedContent,
-        f: &mut HtmlFormatter,
-    ) -> FormatResult<()> {
-        FormatNodeRule::<biome_html_syntax::AstroEmbeddedContent>::fmt(self, node, f)
-    }
-}
-impl AsFormat<HtmlFormatContext> for biome_html_syntax::AstroEmbeddedContent {
-    type Format<'a> = FormatRefWithRule<
-        'a,
-        biome_html_syntax::AstroEmbeddedContent,
-        crate::astro::auxiliary::embedded_content::FormatAstroEmbeddedContent,
-    >;
-    fn format(&self) -> Self::Format<'_> {
-        FormatRefWithRule::new(
-            self,
-            crate::astro::auxiliary::embedded_content::FormatAstroEmbeddedContent::default(),
-        )
-    }
-}
-impl IntoFormat<HtmlFormatContext> for biome_html_syntax::AstroEmbeddedContent {
-    type Format = FormatOwnedWithRule<
-        biome_html_syntax::AstroEmbeddedContent,
-        crate::astro::auxiliary::embedded_content::FormatAstroEmbeddedContent,
-    >;
-    fn into_format(self) -> Self::Format {
-        FormatOwnedWithRule::new(
-            self,
-            crate::astro::auxiliary::embedded_content::FormatAstroEmbeddedContent::default(),
-        )
-    }
-}
 impl FormatRule<biome_html_syntax::AstroFrontmatterElement>
     for crate::astro::auxiliary::frontmatter_element::FormatAstroFrontmatterElement
 {
diff --git a/crates/biome_html_parser/src/syntax/astro.rs b/crates/biome_html_parser/src/syntax/astro.rs
index 26673a0818..b6a5809a49 100644
--- a/crates/biome_html_parser/src/syntax/astro.rs
+++ b/crates/biome_html_parser/src/syntax/astro.rs
@@ -1,9 +1,7 @@
 use crate::parser::HtmlParser;
 use crate::syntax::parse_error::expected_closed_fence;
 use crate::token_source::HtmlLexContext;
-use biome_html_syntax::HtmlSyntaxKind::{
-    ASTRO_EMBEDDED_CONTENT, ASTRO_FRONTMATTER_ELEMENT, FENCE, HTML_LITERAL,
-};
+use biome_html_syntax::HtmlSyntaxKind::{ASTRO_FRONTMATTER_ELEMENT, FENCE, HTML_LITERAL};
 use biome_html_syntax::T;
 use biome_parser::Parser;
 use biome_parser::prelude::ParsedSyntax;
@@ -20,19 +18,11 @@ pub(crate) fn parse_astro_fence(p: &mut HtmlParser) -> ParsedSyntax {
         let c = m.complete(p, ASTRO_FRONTMATTER_ELEMENT);
         return ParsedSyntax::Present(c);
     }
-    parse_astro_embedded(p).ok();
+    if p.at(HTML_LITERAL) {
+        p.bump_with_context(HTML_LITERAL, HtmlLexContext::AstroFencedCodeBlock);
+    }
     p.expect(T![---]);
 
     let c = m.complete(p, ASTRO_FRONTMATTER_ELEMENT);
     ParsedSyntax::Present(c)
 }
-
-pub(crate) fn parse_astro_embedded(p: &mut HtmlParser) -> ParsedSyntax {
-    if !p.at(HTML_LITERAL) {
-        return Absent;
-    }
-    let m = p.start();
-    p.bump_with_context(HTML_LITERAL, HtmlLexContext::AstroFencedCodeBlock);
-
-    ParsedSyntax::Present(m.complete(p, ASTRO_EMBEDDED_CONTENT))
-}
diff --git a/crates/biome_html_syntax/src/element_ext.rs b/crates/biome_html_syntax/src/element_ext.rs
index c3e08d5ef8..1252d40e0b 100644
--- a/crates/biome_html_syntax/src/element_ext.rs
+++ b/crates/biome_html_syntax/src/element_ext.rs
@@ -1,8 +1,8 @@
 use crate::{
-    AnyHtmlElement, AstroEmbeddedContent, HtmlAttribute, HtmlElement, HtmlEmbeddedContent,
-    HtmlSelfClosingElement, HtmlSyntaxToken, ScriptType, inner_string_text,
+    AnyHtmlElement, HtmlAttribute, HtmlElement, HtmlSelfClosingElement, ScriptType,
+    inner_string_text,
 };
-use biome_rowan::{AstNodeList, SyntaxResult, TokenText, declare_node_union};
+use biome_rowan::{AstNodeList, SyntaxResult, TokenText};
 
 /// https://html.spec.whatwg.org/#void-elements
 const VOID_ELEMENTS: &[&str] = &[
@@ -185,7 +185,7 @@ impl HtmlElement {
     }
 
     /// Returns `true` if the element is a `<script lang="ts">`
-    pub fn is_typescript_lang(&self) -> bool {
+    pub fn is_typescript_lang(&self) -> SyntaxResult<bool> {
         let is_script = self.is_script_tag();
         let lang_attribute = self.find_attribute_by_name("lang");
         let is_lang_typescript = lang_attribute.is_some_and(|attribute| {
@@ -199,25 +199,7 @@ impl HtmlElement {
                     text.eq_ignore_ascii_case("ts")
                 })
         });
-        is_script && is_lang_typescript
-    }
-
-    /// Returns `true` if the element is a `<style lang="sass">` or `<style lang="scss">`
-    pub fn is_sass_lang(&self) -> bool {
-        let is_style = self.is_style_tag();
-        let lang_attribute = self.find_attribute_by_name("lang");
-        let is_lang_typescript = lang_attribute.is_some_and(|attribute| {
-            attribute
-                .initializer()
-                .and_then(|initializer| initializer.value().ok())
-                .and_then(|value| value.as_html_string().cloned())
-                .and_then(|value| value.value_token().ok())
-                .is_some_and(|token| {
-                    let text = inner_string_text(&token);
-                    text.eq_ignore_ascii_case("sass") || text.eq_ignore_ascii_case("scss")
-                })
-        });
-        is_style && is_lang_typescript
+        Ok(is_script && is_lang_typescript)
     }
 }
 
@@ -286,16 +268,3 @@ mod tests {
         assert!(element.is_javascript_tag());
     }
 }
-
-declare_node_union! {
-    pub AnyEmbeddedContent = HtmlEmbeddedContent | AstroEmbeddedContent
-}
-
-impl AnyEmbeddedContent {
-    pub fn value_token(&self) -> Option<HtmlSyntaxToken> {
-        match self {
-            Self::HtmlEmbeddedContent(node) => node.value_token().ok(),
-            Self::AstroEmbeddedContent(node) => node.content_token(),
-        }
-    }
-}
diff --git a/crates/biome_html_syntax/src/file_source.rs b/crates/biome_html_syntax/src/file_source.rs
index 2328c417f8..50662160bf 100644
--- a/crates/biome_html_syntax/src/file_source.rs
+++ b/crates/biome_html_syntax/src/file_source.rs
@@ -133,7 +133,7 @@ impl HtmlFileSource {
         match language_id {
             "html" => Ok(Self::html()),
             "astro" => Ok(Self::astro()),
-            "vuejs" | "vue" => Ok(Self::vue()),
+            "vue" => Ok(Self::vue()),
             "svelte" => Ok(Self::svelte()),
             _ => Err(FileSourceError::UnknownLanguageId),
         }
diff --git a/crates/biome_html_syntax/src/generated/kind.rs b/crates/biome_html_syntax/src/generated/kind.rs
index da52952ad0..61a5270415 100644
--- a/crates/biome_html_syntax/src/generated/kind.rs
+++ b/crates/biome_html_syntax/src/generated/kind.rs
@@ -42,7 +42,6 @@ pub enum HtmlSyntaxKind {
     HTML_SELF_CLOSING_TAG,
     HTML_ELEMENT,
     ASTRO_FRONTMATTER_ELEMENT,
-    ASTRO_EMBEDDED_CONTENT,
     HTML_OPENING_ELEMENT,
     HTML_CLOSING_ELEMENT,
     HTML_SELF_CLOSING_ELEMENT,
diff --git a/crates/biome_html_syntax/src/generated/macros.rs b/crates/biome_html_syntax/src/generated/macros.rs
index 5aec3e8bff..71179950f5 100644
--- a/crates/biome_html_syntax/src/generated/macros.rs
+++ b/crates/biome_html_syntax/src/generated/macros.rs
@@ -16,10 +16,6 @@ macro_rules! map_syntax_node {
     ($ node : expr , $ pattern : pat => $ body : expr) => {
         match $node {
             node => match $crate::HtmlSyntaxNode::kind(&node) {
-                $crate::HtmlSyntaxKind::ASTRO_EMBEDDED_CONTENT => {
-                    let $pattern = unsafe { $crate::AstroEmbeddedContent::new_unchecked(node) };
-                    $body
-                }
                 $crate::HtmlSyntaxKind::ASTRO_FRONTMATTER_ELEMENT => {
                     let $pattern = unsafe { $crate::AstroFrontmatterElement::new_unchecked(node) };
                     $body
diff --git a/crates/biome_html_syntax/src/generated/nodes.rs b/crates/biome_html_syntax/src/generated/nodes.rs
index b6cbdab849..47922befd7 100644
--- a/crates/biome_html_syntax/src/generated/nodes.rs
+++ b/crates/biome_html_syntax/src/generated/nodes.rs
@@ -20,41 +20,6 @@ use std::fmt::{Debug, Formatter};
 #[doc = r" the slots are not statically known."]
 pub(crate) const SLOT_MAP_EMPTY_VALUE: u8 = u8::MAX;
 #[derive(Clone, PartialEq, Eq, Hash)]
-pub struct AstroEmbeddedContent {
-    pub(crate) syntax: SyntaxNode,
-}
-impl AstroEmbeddedContent {
-    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
-    #[doc = r""]
-    #[doc = r" # Safety"]
-    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
-    #[doc = r" or a match on [SyntaxNode::kind]"]
-    #[inline]
-    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
-        Self { syntax }
-    }
-    pub fn as_fields(&self) -> AstroEmbeddedContentFields {
-        AstroEmbeddedContentFields {
-            content_token: self.content_token(),
-        }
-    }
-    pub fn content_token(&self) -> Option<SyntaxToken> {
-        support::token(&self.syntax, 0usize)
-    }
-}
-impl Serialize for AstroEmbeddedContent {
-    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
-    where
-        S: Serializer,
-    {
-        self.as_fields().serialize(serializer)
-    }
-}
-#[derive(Serialize)]
-pub struct AstroEmbeddedContentFields {
-    pub content_token: Option<SyntaxToken>,
-}
-#[derive(Clone, PartialEq, Eq, Hash)]
 pub struct AstroFrontmatterElement {
     pub(crate) syntax: SyntaxNode,
 }
@@ -71,15 +36,15 @@ impl AstroFrontmatterElement {
     pub fn as_fields(&self) -> AstroFrontmatterElementFields {
         AstroFrontmatterElementFields {
             l_fence_token: self.l_fence_token(),
-            content: self.content(),
+            content_token: self.content_token(),
             r_fence_token: self.r_fence_token(),
         }
     }
     pub fn l_fence_token(&self) -> SyntaxResult<SyntaxToken> {
         support::required_token(&self.syntax, 0usize)
     }
-    pub fn content(&self) -> SyntaxResult<AstroEmbeddedContent> {
-        support::required_node(&self.syntax, 1usize)
+    pub fn content_token(&self) -> Option<SyntaxToken> {
+        support::token(&self.syntax, 1usize)
     }
     pub fn r_fence_token(&self) -> SyntaxResult<SyntaxToken> {
         support::required_token(&self.syntax, 2usize)
@@ -96,7 +61,7 @@ impl Serialize for AstroFrontmatterElement {
 #[derive(Serialize)]
 pub struct AstroFrontmatterElementFields {
     pub l_fence_token: SyntaxResult<SyntaxToken>,
-    pub content: SyntaxResult<AstroEmbeddedContent>,
+    pub content_token: Option<SyntaxToken>,
     pub r_fence_token: SyntaxResult<SyntaxToken>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
@@ -1005,56 +970,6 @@ impl AnyHtmlTextExpression {
         }
     }
 }
-impl AstNode for AstroEmbeddedContent {
-    type Language = Language;
-    const KIND_SET: SyntaxKindSet<Language> =
-        SyntaxKindSet::from_raw(RawSyntaxKind(ASTRO_EMBEDDED_CONTENT as u16));
-    fn can_cast(kind: SyntaxKind) -> bool {
-        kind == ASTRO_EMBEDDED_CONTENT
-    }
-    fn cast(syntax: SyntaxNode) -> Option<Self> {
-        if Self::can_cast(syntax.kind()) {
-            Some(Self { syntax })
-        } else {
-            None
-        }
-    }
-    fn syntax(&self) -> &SyntaxNode {
-        &self.syntax
-    }
-    fn into_syntax(self) -> SyntaxNode {
-        self.syntax
-    }
-}
-impl std::fmt::Debug for AstroEmbeddedContent {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
-        let current_depth = DEPTH.get();
-        let result = if current_depth < 16 {
-            DEPTH.set(current_depth + 1);
-            f.debug_struct("AstroEmbeddedContent")
-                .field(
-                    "content_token",
-                    &support::DebugOptionalElement(self.content_token()),
-                )
-                .finish()
-        } else {
-            f.debug_struct("AstroEmbeddedContent").finish()
-        };
-        DEPTH.set(current_depth);
-        result
-    }
-}
-impl From<AstroEmbeddedContent> for SyntaxNode {
-    fn from(n: AstroEmbeddedContent) -> Self {
-        n.syntax
-    }
-}
-impl From<AstroEmbeddedContent> for SyntaxElement {
-    fn from(n: AstroEmbeddedContent) -> Self {
-        n.syntax.into()
-    }
-}
 impl AstNode for AstroFrontmatterElement {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
@@ -1087,7 +1002,10 @@ impl std::fmt::Debug for AstroFrontmatterElement {
                     "l_fence_token",
                     &support::DebugSyntaxResult(self.l_fence_token()),
                 )
-                .field("content", &support::DebugSyntaxResult(self.content()))
+                .field(
+                    "content_token",
+                    &support::DebugOptionalElement(self.content_token()),
+                )
                 .field(
                     "r_fence_token",
                     &support::DebugSyntaxResult(self.r_fence_token()),
@@ -2528,11 +2446,6 @@ impl std::fmt::Display for AnyHtmlTextExpression {
         std::fmt::Display::fmt(self.syntax(), f)
     }
 }
-impl std::fmt::Display for AstroEmbeddedContent {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        std::fmt::Display::fmt(self.syntax(), f)
-    }
-}
 impl std::fmt::Display for AstroFrontmatterElement {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         std::fmt::Display::fmt(self.syntax(), f)
diff --git a/crates/biome_html_syntax/src/generated/nodes_mut.rs b/crates/biome_html_syntax/src/generated/nodes_mut.rs
index 35e79229c0..b20bd803d6 100644
--- a/crates/biome_html_syntax/src/generated/nodes_mut.rs
+++ b/crates/biome_html_syntax/src/generated/nodes_mut.rs
@@ -3,14 +3,6 @@
 use crate::{HtmlSyntaxToken as SyntaxToken, generated::nodes::*};
 use biome_rowan::AstNode;
 use std::iter::once;
-impl AstroEmbeddedContent {
-    pub fn with_content_token(self, element: Option<SyntaxToken>) -> Self {
-        Self::unwrap_cast(
-            self.syntax
-                .splice_slots(0usize..=0usize, once(element.map(|element| element.into()))),
-        )
-    }
-}
 impl AstroFrontmatterElement {
     pub fn with_l_fence_token(self, element: SyntaxToken) -> Self {
         Self::unwrap_cast(
@@ -18,10 +10,10 @@ impl AstroFrontmatterElement {
                 .splice_slots(0usize..=0usize, once(Some(element.into()))),
         )
     }
-    pub fn with_content(self, element: AstroEmbeddedContent) -> Self {
+    pub fn with_content_token(self, element: Option<SyntaxToken>) -> Self {
         Self::unwrap_cast(
             self.syntax
-                .splice_slots(1usize..=1usize, once(Some(element.into_syntax().into()))),
+                .splice_slots(1usize..=1usize, once(element.map(|element| element.into()))),
         )
     }
     pub fn with_r_fence_token(self, element: SyntaxToken) -> Self {
diff --git a/crates/biome_js_syntax/src/file_source.rs b/crates/biome_js_syntax/src/file_source.rs
index 7bb3ca96d5..d07a264dfc 100644
--- a/crates/biome_js_syntax/src/file_source.rs
+++ b/crates/biome_js_syntax/src/file_source.rs
@@ -148,8 +148,7 @@ pub struct JsFileSource {
     variant: LanguageVariant,
     module_kind: ModuleKind,
     version: LanguageVersion,
-    /// Used to mark if the JavaScript is embedded inside some particular files. This affects the parsing.
-    /// For example, if inside an Astro file, a top-level return statement is allowed.
+    /// Used to mark if the source is being used for an Astro, Svelte or Vue file
     embedding_kind: EmbeddingKind,
 }
 
@@ -200,6 +199,7 @@ impl JsFileSource {
         }
     }
 
+    /// Astro file definition
     pub fn astro() -> Self {
         Self::ts().with_embedding_kind(EmbeddingKind::Astro)
     }
@@ -343,7 +343,6 @@ impl JsFileSource {
             "vue" => Ok(Self::vue()),
             // TODO: Remove once we have full support of svelte files
             "svelte" => Ok(Self::svelte()),
-
             _ => Err(FileSourceError::UnknownExtension),
         }
     }
@@ -373,7 +372,7 @@ impl JsFileSource {
             // TODO: Remove once we have full support of astro files
             "astro" => Ok(Self::astro()),
             // TODO: Remove once we have full support of vue files
-            "vue" | "vuejs" => Ok(Self::vue()),
+            "vue" => Ok(Self::vue()),
             // TODO: Remove once we have full support of svelte files
             "svelte" => Ok(Self::svelte()),
             _ => Err(FileSourceError::UnknownLanguageId),
diff --git a/crates/biome_lsp/src/handlers/analysis.rs b/crates/biome_lsp/src/handlers/analysis.rs
index 6fb7620df4..b36b0d03a3 100644
--- a/crates/biome_lsp/src/handlers/analysis.rs
+++ b/crates/biome_lsp/src/handlers/analysis.rs
@@ -14,9 +14,7 @@ use biome_line_index::LineIndex;
 use biome_lsp_converters::from_proto;
 use biome_rowan::{TextRange, TextSize};
 use biome_service::WorkspaceError;
-use biome_service::file_handlers::astro::AstroFileHandler;
-use biome_service::file_handlers::svelte::SvelteFileHandler;
-use biome_service::file_handlers::vue::VueFileHandler;
+use biome_service::file_handlers::{AstroFileHandler, SvelteFileHandler, VueFileHandler};
 use biome_service::workspace::{
     CheckFileSizeParams, FeaturesBuilder, FileFeaturesResult, FixFileMode, FixFileParams,
     GetFileContentParams, IgnoreKind, PathIsIgnoredParams, PullActionsParams,
@@ -126,7 +124,6 @@ pub(crate) fn code_actions(
         Some("svelte") => SvelteFileHandler::start(content.as_str()),
         _ => None,
     };
-
     let cursor_range = from_proto::text_range(&doc.line_index, params.range, position_encoding)
         .with_context(|| {
             format!(
@@ -148,6 +145,7 @@ pub(crate) fn code_actions(
     } else {
         cursor_range
     };
+
     debug!("Cursor range {:?}", &cursor_range);
     let result = match session.workspace.pull_actions(PullActionsParams {
         project_key: doc.project_key,
@@ -183,7 +181,7 @@ pub(crate) fn code_actions(
     // document if the action category "source.fixAll" was explicitly requested
     // by the language client
     let fix_all = if has_fix_all {
-        fix_all(session, &url, path, &doc.line_index, &diagnostics, None)?
+        fix_all(session, &url, path, &doc.line_index, &diagnostics, offset)?
     } else {
         None
     };
@@ -243,6 +241,7 @@ pub(crate) fn code_actions(
                 position_encoding,
                 &diagnostics,
                 action,
+                offset,
             )
             .ok()?;
 
@@ -355,26 +354,24 @@ fn fix_all(
         suppression_reason: None,
         rule_categories: categories.build(),
     })?;
-    let output = if file_features.supports_full_html_support() {
-        fixed.code
-    } else {
-        match path.as_path().extension() {
-            Some(extension) => {
-                let input = session.workspace.get_file_content(GetFileContentParams {
-                    project_key: doc.project_key,
-                    path: path.clone(),
-                })?;
-                match extension {
-                    "astro" => AstroFileHandler::output(input.as_str(), fixed.code.as_str()),
-                    "vue" => VueFileHandler::output(input.as_str(), fixed.code.as_str()),
-                    "svelte" => SvelteFileHandler::output(input.as_str(), fixed.code.as_str()),
-                    _ => fixed.code,
-                }
-            }
 
-            _ => fixed.code,
+    let output = match path.as_path().extension() {
+        Some(extension) => {
+            let input = session.workspace.get_file_content(GetFileContentParams {
+                project_key: doc.project_key,
+                path: path.clone(),
+            })?;
+            match extension {
+                "astro" => AstroFileHandler::output(input.as_str(), fixed.code.as_str()),
+                "vue" => VueFileHandler::output(input.as_str(), fixed.code.as_str()),
+                "svelte" => SvelteFileHandler::output(input.as_str(), fixed.code.as_str()),
+                _ => fixed.code,
+            }
         }
+
+        _ => fixed.code,
     };
+
     if fixed.actions.is_empty() {
         return Ok(None);
     }
diff --git a/crates/biome_lsp/src/handlers/formatting.rs b/crates/biome_lsp/src/handlers/formatting.rs
index c039ab4da2..29cb47a5ec 100644
--- a/crates/biome_lsp/src/handlers/formatting.rs
+++ b/crates/biome_lsp/src/handlers/formatting.rs
@@ -5,9 +5,7 @@ use anyhow::Context;
 use biome_fs::BiomePath;
 use biome_lsp_converters::from_proto;
 use biome_rowan::{TextLen, TextRange, TextSize};
-use biome_service::file_handlers::astro::AstroFileHandler;
-use biome_service::file_handlers::svelte::SvelteFileHandler;
-use biome_service::file_handlers::vue::VueFileHandler;
+use biome_service::file_handlers::{AstroFileHandler, SvelteFileHandler, VueFileHandler};
 use biome_service::workspace::{
     CheckFileSizeParams, FeaturesBuilder, FeaturesSupported, FileFeaturesResult, FormatFileParams,
     FormatOnTypeParams, FormatRangeParams, GetFileContentParams, IgnoreKind, PathIsIgnoredParams,
@@ -78,19 +76,17 @@ pub(crate) fn format(
         if output.is_empty() {
             return Ok(None);
         }
-        if !file_features.supports_full_html_support() {
-            match path.extension() {
-                Some("astro") => {
-                    output = AstroFileHandler::output(input.as_str(), output.as_str());
-                }
-                Some("vue") => {
-                    output = VueFileHandler::output(input.as_str(), output.as_str());
-                }
-                Some("svelte") => {
-                    output = SvelteFileHandler::output(input.as_str(), output.as_str());
-                }
-                _ => {}
+        match path.extension() {
+            Some("astro") => {
+                output = AstroFileHandler::output(input.as_str(), output.as_str());
             }
+            Some("vue") => {
+                output = VueFileHandler::output(input.as_str(), output.as_str());
+            }
+            Some("svelte") => {
+                output = SvelteFileHandler::output(input.as_str(), output.as_str());
+            }
+            _ => {}
         }
 
         let indels = biome_text_edit::TextEdit::from_unicode_words(input.as_str(), output.as_str());
@@ -165,7 +161,6 @@ pub(crate) fn format_range(
             project_key: doc.project_key,
             path: path.clone(),
         })?;
-
         let offset = match path.extension() {
             Some("vue") => VueFileHandler::start(content.as_str()),
             Some("astro") => AstroFileHandler::start(content.as_str()),
diff --git a/crates/biome_lsp/src/server.tests.rs b/crates/biome_lsp/src/server.tests.rs
index 5c711f7ce3..f68b83e857 100644
--- a/crates/biome_lsp/src/server.tests.rs
+++ b/crates/biome_lsp/src/server.tests.rs
@@ -4040,8 +4040,7 @@ let useConst = "Astro Test";
                 r#"---
 const useConst = "Astro Test";
 ---
-<!doctype html>
-"#,
+<!doctype html>"#,
             ),
         }],
     );
diff --git a/crates/biome_lsp/src/session.rs b/crates/biome_lsp/src/session.rs
index 82cd9c9c4b..26ffd208b6 100644
--- a/crates/biome_lsp/src/session.rs
+++ b/crates/biome_lsp/src/session.rs
@@ -16,10 +16,11 @@ use biome_service::WorkspaceError;
 use biome_service::configuration::{
     LoadedConfiguration, ProjectScanComputer, load_configuration, load_editorconfig,
 };
+use biome_service::file_handlers::{AstroFileHandler, SvelteFileHandler, VueFileHandler};
 use biome_service::projects::ProjectKey;
 use biome_service::workspace::{
-    FeaturesBuilder, OpenProjectParams, OpenProjectResult, PullDiagnosticsParams,
-    SupportsFeatureParams,
+    FeaturesBuilder, GetFileContentParams, OpenProjectParams, OpenProjectResult,
+    PullDiagnosticsParams, SupportsFeatureParams,
 };
 use biome_service::workspace::{FileFeaturesResult, ServiceNotification};
 use biome_service::workspace::{RageEntry, RageParams, RageResult, UpdateSettingsParams};
@@ -446,6 +447,17 @@ impl Session {
                 pull_code_actions: false,
             })?;
 
+            let content = self.workspace.get_file_content(GetFileContentParams {
+                project_key: doc.project_key,
+                path: biome_path.clone(),
+            })?;
+            let offset = match biome_path.extension() {
+                Some("vue") => VueFileHandler::start(content.as_str()),
+                Some("astro") => AstroFileHandler::start(content.as_str()),
+                Some("svelte") => SvelteFileHandler::start(content.as_str()),
+                _ => None,
+            };
+
             result
                 .diagnostics
                 .into_iter()
@@ -455,7 +467,7 @@ impl Session {
                         &url,
                         &doc.line_index,
                         self.position_encoding(),
-                        None,
+                        offset,
                     ) {
                         Ok(diag) => Some(diag),
                         Err(err) => {
diff --git a/crates/biome_lsp/src/utils.rs b/crates/biome_lsp/src/utils.rs
index 57b442bc09..051ce45571 100644
--- a/crates/biome_lsp/src/utils.rs
+++ b/crates/biome_lsp/src/utils.rs
@@ -100,6 +100,7 @@ pub(crate) fn code_fix_to_lsp(
     position_encoding: PositionEncoding,
     diagnostics: &[lsp::Diagnostic],
     action: CodeAction,
+    offset: Option<u32>,
 ) -> Result<lsp::CodeAction> {
     // Mark diagnostics emitted by the same rule as resolved by this action
     let diagnostics: Vec<_> = action
@@ -134,7 +135,6 @@ pub(crate) fn code_fix_to_lsp(
     let suggestion = action.suggestion;
 
     let mut changes = HashMap::new();
-    let offset = action.offset.map(u32::from);
     let edits = text_edit(line_index, suggestion.suggestion, position_encoding, offset)?;
 
     changes.insert(url.clone(), edits);
diff --git a/crates/biome_rule_options/src/no_unknown_at_rules.rs b/crates/biome_rule_options/src/no_unknown_at_rules.rs
index 9de9c73e89..8f1deb0e2f 100644
--- a/crates/biome_rule_options/src/no_unknown_at_rules.rs
+++ b/crates/biome_rule_options/src/no_unknown_at_rules.rs
@@ -1,6 +1,10 @@
 use biome_deserialize_macros::Deserializable;
 use serde::{Deserialize, Serialize};
-#[derive(Default, Clone, Debug, Deserialize, Deserializable, Eq, PartialEq, Serialize)]
+#[derive(Clone, Debug, Deserialize, Deserializable, Eq, PartialEq, Serialize, Default)]
 #[cfg_attr(feature = "schema", derive(schemars::JsonSchema))]
 #[serde(rename_all = "camelCase", deny_unknown_fields, default)]
-pub struct NoUnknownAtRulesOptions {}
+pub struct NoUnknownAtRulesOptions {
+    /// A list of unknown at-rule names to ignore (case-insensitive).
+    #[serde(skip_serializing_if = "Vec::is_empty")]
+    pub ignore: Vec<String>,
+}
diff --git a/crates/biome_ruledoc_utils/src/codeblock.rs b/crates/biome_ruledoc_utils/src/codeblock.rs
index f6746fcc37..a3f8ed504c 100644
--- a/crates/biome_ruledoc_utils/src/codeblock.rs
+++ b/crates/biome_ruledoc_utils/src/codeblock.rs
@@ -94,7 +94,7 @@ impl CodeBlock {
     }
 
     pub fn document_file_source(&self) -> DocumentFileSource {
-        DocumentFileSource::from_extension(&self.tag, false)
+        DocumentFileSource::from_extension(&self.tag)
     }
 
     /// Returns the block's file path, but only if one was set explicitly using
@@ -138,8 +138,7 @@ impl FromStr for CodeBlock {
 
                         code_block.file_path = Some(normalize_file_path(path));
                     } else {
-                        if DocumentFileSource::from_extension(token, false)
-                            == DocumentFileSource::Unknown
+                        if DocumentFileSource::from_extension(token) == DocumentFileSource::Unknown
                         {
                             bail!("Unrecognised attribute in code block: {token}");
                         }
diff --git a/crates/biome_service/src/diagnostics.rs b/crates/biome_service/src/diagnostics.rs
index a0816195ff..a4a97db6df 100644
--- a/crates/biome_service/src/diagnostics.rs
+++ b/crates/biome_service/src/diagnostics.rs
@@ -513,7 +513,7 @@ impl Diagnostic for QueryDiagnostic {
 }
 
 pub fn extension_error(path: &BiomePath) -> WorkspaceError {
-    let file_source = DocumentFileSource::from_path(path, false);
+    let file_source = DocumentFileSource::from_path(path);
     WorkspaceError::source_file_not_supported(
         file_source,
         path.clone().to_string(),
diff --git a/crates/biome_service/src/file_handlers/css.rs b/crates/biome_service/src/file_handlers/css.rs
index 1b3a3c0350..8845c5040e 100644
--- a/crates/biome_service/src/file_handlers/css.rs
+++ b/crates/biome_service/src/file_handlers/css.rs
@@ -601,7 +601,6 @@ pub(crate) fn code_actions(params: CodeActionsParams) -> PullActionsResult {
         suppression_reason,
         plugins,
         categories,
-        action_offset,
     } = params;
     let _ = debug_span!("Code actions CSS", range =? range, path =? path).entered();
     let tree = parse.tree();
@@ -641,7 +640,6 @@ pub(crate) fn code_actions(params: CodeActionsParams) -> PullActionsResult {
                 rule_name: item
                     .rule_name
                     .map(|(group, name)| (Cow::Borrowed(group), Cow::Borrowed(name))),
-                offset: action_offset,
                 suggestion: item.suggestion,
             }
         }));
diff --git a/crates/biome_service/src/file_handlers/graphql.rs b/crates/biome_service/src/file_handlers/graphql.rs
index 33213f7a79..1ddb5f04de 100644
--- a/crates/biome_service/src/file_handlers/graphql.rs
+++ b/crates/biome_service/src/file_handlers/graphql.rs
@@ -482,7 +482,6 @@ pub(crate) fn code_actions(params: CodeActionsParams) -> PullActionsResult {
         enabled_rules: rules,
         plugins: _,
         categories,
-        action_offset,
     } = params;
     let _ = debug_span!("Code actions GraphQL", range =? range, path =? path).entered();
     let tree = parse.tree();
@@ -526,7 +525,6 @@ pub(crate) fn code_actions(params: CodeActionsParams) -> PullActionsResult {
                     .rule_name
                     .map(|(group, name)| (Cow::Borrowed(group), Cow::Borrowed(name))),
                 suggestion: item.suggestion,
-                offset: action_offset,
             }
         }));
 
diff --git a/crates/biome_service/src/file_handlers/html.rs b/crates/biome_service/src/file_handlers/html.rs
index 700037ff89..650227b068 100644
--- a/crates/biome_service/src/file_handlers/html.rs
+++ b/crates/biome_service/src/file_handlers/html.rs
@@ -36,12 +36,9 @@ use biome_html_formatter::{
     format_node,
 };
 use biome_html_parser::{HtmlParseOptions, parse_html_with_cache};
-use biome_html_syntax::element_ext::AnyEmbeddedContent;
-use biome_html_syntax::{
-    AstroEmbeddedContent, HtmlElement, HtmlLanguage, HtmlRoot, HtmlSyntaxNode,
-};
+use biome_html_syntax::{HtmlElement, HtmlEmbeddedContent, HtmlLanguage, HtmlRoot, HtmlSyntaxNode};
 use biome_js_parser::parse_js_with_offset_and_cache;
-use biome_js_syntax::{EmbeddingKind, JsFileSource, JsLanguage};
+use biome_js_syntax::{JsFileSource, JsLanguage};
 use biome_json_parser::parse_json_with_offset_and_cache;
 use biome_json_syntax::{JsonFileSource, JsonLanguage};
 use biome_parser::AnyParse;
@@ -394,19 +391,7 @@ fn parse_embedded_nodes(
 
     // Walk through all HTML elements looking for script tags and style tags
     for element in html_root.syntax().descendants() {
-        if let Some(astro_embedded_content) = AstroEmbeddedContent::cast_ref(&element) {
-            let result = parse_astro_embedded_script(
-                astro_embedded_content.clone(),
-                cache,
-                biome_path,
-                settings,
-            );
-            if let Some((content, file_source)) = result {
-                nodes.push((content.into(), file_source));
-            }
-        }
-
-        let Some(element) = HtmlElement::cast_ref(&element) else {
+        let Some(element) = HtmlElement::cast(element) else {
             continue;
         };
 
@@ -438,35 +423,6 @@ fn parse_embedded_nodes(
     ParseEmbedResult { nodes }
 }
 
-pub(crate) fn parse_astro_embedded_script(
-    element: AstroEmbeddedContent,
-    cache: &mut NodeCache,
-    path: &BiomePath,
-    settings: &Settings,
-) -> Option<(EmbeddedSnippet<JsLanguage>, DocumentFileSource)> {
-    let content = element.content_token()?;
-    let file_source = JsFileSource::ts().with_embedding_kind(EmbeddingKind::Astro);
-    let document_file_source = DocumentFileSource::Js(file_source);
-    let options = settings.parse_options::<JsLanguage>(path, &document_file_source);
-    let parse = parse_js_with_offset_and_cache(
-        content.text(),
-        content.text_range().start(),
-        file_source,
-        options,
-        cache,
-    );
-
-    Some((
-        EmbeddedSnippet::new(
-            parse.into(),
-            element.range(),
-            content.text_trimmed_range(),
-            content.text_range().start(),
-        ),
-        document_file_source,
-    ))
-}
-
 pub(crate) fn parse_embedded_script(
     element: HtmlElement,
     cache: &mut NodeCache,
@@ -477,17 +433,13 @@ pub(crate) fn parse_embedded_script(
     let html_file_source = html_file_source.to_html_file_source()?;
     if element.is_javascript_tag() {
         let file_source = if html_file_source.is_svelte() || html_file_source.is_vue() {
-            let mut file_source = if element.is_typescript_lang() {
+            if element.is_typescript_lang().unwrap_or_default() {
                 JsFileSource::ts()
             } else {
                 JsFileSource::js_module()
-            };
-            if html_file_source.is_svelte() {
-                file_source = file_source.with_embedding_kind(EmbeddingKind::Svelte);
-            } else if html_file_source.is_vue() {
-                file_source = file_source.with_embedding_kind(EmbeddingKind::Vue);
             }
-            file_source
+        } else if html_file_source.is_astro() {
+            JsFileSource::ts()
         } else {
             let is_module = element.is_javascript_module().unwrap_or_default();
             if is_module {
@@ -530,7 +482,6 @@ pub(crate) fn parse_embedded_script(
     }
 }
 
-/// Parses embedded style, but it skips it if it contains SASS language
 pub(crate) fn parse_embedded_style(
     element: HtmlElement,
     cache: &mut NodeCache,
@@ -543,11 +494,6 @@ pub(crate) fn parse_embedded_style(
             return None;
         }
 
-        // We don't support SASS
-        if element.is_sass_lang() {
-            return None;
-        }
-
         let file_source = DocumentFileSource::Css(CssFileSource::css());
         let content = element.children().iter().next().and_then(|child| {
             let child = child.as_any_html_content()?;
@@ -774,7 +720,6 @@ pub(crate) fn code_actions(params: CodeActionsParams) -> PullActionsResult {
         enabled_rules: rules,
         plugins: _,
         categories,
-        action_offset,
     } = params;
     let _ = debug_span!("Code actions HTML", range =? range, path =? path).entered();
     let tree = parse.tree();
@@ -812,7 +757,6 @@ pub(crate) fn code_actions(params: CodeActionsParams) -> PullActionsResult {
                     .rule_name
                     .map(|(group, name)| (Cow::Borrowed(group), Cow::Borrowed(name))),
                 suggestion: item.suggestion,
-                offset: action_offset,
             }
         }));
 
@@ -935,7 +879,7 @@ pub(crate) fn fix_all(params: FixAllParams) -> Result<FixFileResult, WorkspaceEr
                             &params.document_file_source,
                         ),
                         tree.syntax(),
-                        false,
+                        true,
                     )?
                     .print()?
                     .into_code()
@@ -963,7 +907,7 @@ pub(crate) fn update_snippets(
     let iterator = tree
         .syntax()
         .descendants()
-        .filter_map(AnyEmbeddedContent::cast);
+        .filter_map(HtmlEmbeddedContent::cast);
 
     for element in iterator {
         let Some(snippet) = new_snippets
@@ -973,7 +917,7 @@ pub(crate) fn update_snippets(
             continue;
         };
 
-        if let Some(value_token) = element.value_token() {
+        if let Ok(value_token) = element.value_token() {
             let new_token = ident(snippet.new_code.as_str());
             mutation.replace_token(value_token, new_token);
         }
diff --git a/crates/biome_service/src/file_handlers/javascript.rs b/crates/biome_service/src/file_handlers/javascript.rs
index 915d5f1971..324e8659dc 100644
--- a/crates/biome_service/src/file_handlers/javascript.rs
+++ b/crates/biome_service/src/file_handlers/javascript.rs
@@ -793,7 +793,6 @@ pub(crate) fn code_actions(params: CodeActionsParams) -> PullActionsResult {
         enabled_rules: rules,
         plugins,
         categories,
-        action_offset,
     } = params;
     let _ = debug_span!("Code actions JavaScript", range =? range, path =? path).entered();
     let tree = parse.tree();
@@ -841,7 +840,6 @@ pub(crate) fn code_actions(params: CodeActionsParams) -> PullActionsResult {
                         .rule_name
                         .map(|(group, name)| (Cow::Borrowed(group), Cow::Borrowed(name))),
                     suggestion: item.suggestion,
-                    offset: action_offset,
                 }
             }));
 
diff --git a/crates/biome_service/src/file_handlers/json.rs b/crates/biome_service/src/file_handlers/json.rs
index f35f97ed77..a2eab315aa 100644
--- a/crates/biome_service/src/file_handlers/json.rs
+++ b/crates/biome_service/src/file_handlers/json.rs
@@ -573,7 +573,6 @@ fn code_actions(params: CodeActionsParams) -> PullActionsResult {
         suppression_reason,
         plugins: _,
         categories,
-        action_offset,
     } = params;
 
     let _ = debug_span!("Code actions JSON",  range =? range, path =? path).entered();
@@ -613,7 +612,6 @@ fn code_actions(params: CodeActionsParams) -> PullActionsResult {
                     .rule_name
                     .map(|(group, name)| (Cow::Borrowed(group), Cow::Borrowed(name))),
                 suggestion: item.suggestion,
-                offset: action_offset,
             }
         }));
 
diff --git a/crates/biome_service/src/file_handlers/mod.rs b/crates/biome_service/src/file_handlers/mod.rs
index 2001b46387..35144f46df 100644
--- a/crates/biome_service/src/file_handlers/mod.rs
+++ b/crates/biome_service/src/file_handlers/mod.rs
@@ -4,11 +4,11 @@ use self::{
 };
 use crate::WorkspaceError;
 use crate::diagnostics::{QueryDiagnostic, SearchError};
-pub use crate::file_handlers::astro::AstroFileHandler;
+pub use crate::file_handlers::astro::{ASTRO_FENCE, AstroFileHandler};
 use crate::file_handlers::graphql::GraphqlFileHandler;
 use crate::file_handlers::ignore::IgnoreFileHandler;
-pub use crate::file_handlers::svelte::SvelteFileHandler;
-pub use crate::file_handlers::vue::VueFileHandler;
+pub use crate::file_handlers::svelte::{SVELTE_FENCE, SvelteFileHandler};
+pub use crate::file_handlers::vue::{VUE_FENCE, VueFileHandler};
 use crate::settings::Settings;
 use crate::workspace::{
     AnyEmbeddedSnippet, FixFileMode, FixFileResult, GetSyntaxTreeResult, PullActionsResult,
@@ -55,7 +55,7 @@ use std::borrow::Cow;
 use std::sync::Arc;
 use tracing::instrument;
 
-pub mod astro;
+mod astro;
 pub(crate) mod css;
 pub(crate) mod graphql;
 pub(crate) mod grit;
@@ -63,9 +63,9 @@ pub(crate) mod html;
 mod ignore;
 pub(crate) mod javascript;
 pub(crate) mod json;
-pub mod svelte;
+mod svelte;
 mod unknown;
-pub mod vue;
+mod vue;
 
 #[cfg_attr(feature = "schema", derive(schemars::JsonSchema))]
 #[derive(
@@ -122,81 +122,52 @@ impl From<GritFileSource> for DocumentFileSource {
 
 impl From<&Utf8Path> for DocumentFileSource {
     fn from(path: &Utf8Path) -> Self {
-        Self::from_path(path, false)
+        Self::from_path(path)
     }
 }
 
 impl DocumentFileSource {
-    fn try_from_well_known(
-        path: &Utf8Path,
-        experimental_full_html_support: bool,
-    ) -> Result<Self, FileSourceError> {
+    fn try_from_well_known(path: &Utf8Path) -> Result<Self, FileSourceError> {
         if let Ok(file_source) = JsonFileSource::try_from_well_known(path) {
             return Ok(file_source.into());
         }
-        if experimental_full_html_support {
-            if let Ok(file_source) = HtmlFileSource::try_from_well_known(path) {
-                return Ok(file_source.into());
-            }
-            if let Ok(file_source) = JsFileSource::try_from_well_known(path) {
-                return Ok(file_source.into());
-            }
-        } else {
-            if let Ok(file_source) = JsFileSource::try_from_well_known(path) {
-                return Ok(file_source.into());
-            }
-            if let Ok(file_source) = HtmlFileSource::try_from_well_known(path) {
-                return Ok(file_source.into());
-            }
+        if let Ok(file_source) = JsFileSource::try_from_well_known(path) {
+            return Ok(file_source.into());
         }
-
         if let Ok(file_source) = CssFileSource::try_from_well_known(path) {
             return Ok(file_source.into());
         }
         if let Ok(file_source) = GraphqlFileSource::try_from_well_known(path) {
             return Ok(file_source.into());
         }
+        if let Ok(file_source) = HtmlFileSource::try_from_well_known(path) {
+            return Ok(file_source.into());
+        }
 
         Err(FileSourceError::UnknownFileName)
     }
 
     /// Returns the document file source corresponding to this file name from well-known files
-    pub fn from_well_known(path: &Utf8Path, experimental_full_html_support: bool) -> Self {
-        Self::try_from_well_known(path, experimental_full_html_support).unwrap_or(Self::Unknown)
-    }
-
-    fn try_from_extension(
-        extension: &str,
-        experimental_full_html_support: bool,
-    ) -> Result<Self, FileSourceError> {
-        // Order here is important
-        if experimental_full_html_support {
-            if let Ok(file_source) = HtmlFileSource::try_from_extension(extension) {
-                return Ok(file_source.into());
-            }
-            if let Ok(file_source) = JsFileSource::try_from_extension(extension) {
-                return Ok(file_source.into());
-            }
-        } else {
-            if let Ok(file_source) = JsFileSource::try_from_extension(extension) {
-                return Ok(file_source.into());
-            }
-
-            if let Ok(file_source) = HtmlFileSource::try_from_extension(extension) {
-                return Ok(file_source.into());
-            }
-        }
+    pub fn from_well_known(path: &Utf8Path) -> Self {
+        Self::try_from_well_known(path).unwrap_or(Self::Unknown)
+    }
 
+    fn try_from_extension(extension: &str) -> Result<Self, FileSourceError> {
         if let Ok(file_source) = JsonFileSource::try_from_extension(extension) {
             return Ok(file_source.into());
         }
+        if let Ok(file_source) = JsFileSource::try_from_extension(extension) {
+            return Ok(file_source.into());
+        }
         if let Ok(file_source) = CssFileSource::try_from_extension(extension) {
             return Ok(file_source.into());
         }
         if let Ok(file_source) = GraphqlFileSource::try_from_extension(extension) {
             return Ok(file_source.into());
         }
-
+        if let Ok(file_source) = HtmlFileSource::try_from_extension(extension) {
+            return Ok(file_source.into());
+        }
         if let Ok(file_source) = GritFileSource::try_from_extension(extension) {
             return Ok(file_source.into());
         }
@@ -204,8 +175,8 @@ impl DocumentFileSource {
     }
 
     /// Returns the document file source corresponding to this file extension
-    pub fn from_extension(extension: &str, experimental_full_html_support: bool) -> Self {
-        Self::try_from_extension(extension, experimental_full_html_support).unwrap_or(Self::Unknown)
+    pub fn from_extension(extension: &str) -> Self {
+        Self::try_from_extension(extension).unwrap_or(Self::Unknown)
     }
 
     #[instrument(level = "debug", fields(result))]
@@ -241,11 +212,8 @@ impl DocumentFileSource {
         Self::try_from_language_id(language_id).unwrap_or(Self::Unknown)
     }
 
-    pub(crate) fn try_from_path(
-        path: &Utf8Path,
-        experimental_full_html_support: bool,
-    ) -> Result<Self, FileSourceError> {
-        if let Ok(file_source) = Self::try_from_well_known(path, experimental_full_html_support) {
+    pub(crate) fn try_from_path(path: &Utf8Path) -> Result<Self, FileSourceError> {
+        if let Ok(file_source) = Self::try_from_well_known(path) {
             return Ok(file_source);
         }
 
@@ -276,12 +244,12 @@ impl DocumentFileSource {
                 .ok_or(FileSourceError::MissingFileExtension)?,
         };
 
-        Self::try_from_extension(extension.as_ref(), experimental_full_html_support)
+        Self::try_from_extension(extension.as_ref())
     }
 
     /// Returns the document file source corresponding to the file path
-    pub fn from_path(path: &Utf8Path, experimental_full_html_support: bool) -> Self {
-        Self::try_from_path(path, experimental_full_html_support).unwrap_or(Self::Unknown)
+    pub fn from_path(path: &Utf8Path) -> Self {
+        Self::try_from_path(path).unwrap_or(Self::Unknown)
     }
 
     /// Returns the document file source if it's not unknown, otherwise returns `other`.
@@ -366,16 +334,25 @@ impl DocumentFileSource {
         }
     }
 
+    /// Convert the file source from a JS file source into an HTML-like file source, if the file belongs to an HTML-like language.
+    pub fn to_htmlish(&self) -> Self {
+        match self {
+            Self::Js(js) => match js.as_embedding_kind() {
+                EmbeddingKind::Astro => Self::Html(HtmlFileSource::astro()),
+                EmbeddingKind::Vue => Self::Html(HtmlFileSource::vue()),
+                EmbeddingKind::Svelte => Self::Html(HtmlFileSource::svelte()),
+                EmbeddingKind::None => Self::Unknown,
+            },
+            _ => Self::Unknown,
+        }
+    }
+
     /// The file can be parsed
     pub fn can_parse(path: &Utf8Path) -> bool {
         let file_source = Self::from(path);
         match file_source {
-            Self::Js(_)
-            | Self::Css(_)
-            | Self::Graphql(_)
-            | Self::Json(_)
-            | Self::Html(_)
-            | Self::Grit(_) => true,
+            Self::Js(_) => true,
+            Self::Css(_) | Self::Graphql(_) | Self::Json(_) | Self::Html(_) | Self::Grit(_) => true,
             Self::Ignore => false,
             Self::Unknown => false,
         }
@@ -397,8 +374,8 @@ impl DocumentFileSource {
     }
 
     /// Whether this file can contain embedded nodes
-    pub fn can_contain_embeds(path: &Utf8Path, experimental_full_html_support: bool) -> bool {
-        let file_source = Self::from_path(path, experimental_full_html_support);
+    pub fn can_contain_embeds(path: &Utf8Path) -> bool {
+        let file_source = Self::from(path);
         match file_source {
             Self::Html(_) => true,
             Self::Js(_)
@@ -673,7 +650,6 @@ pub(crate) struct CodeActionsParams<'a> {
     pub(crate) enabled_rules: &'a [AnalyzerSelector],
     pub(crate) plugins: AnalyzerPluginVec,
     pub(crate) categories: RuleCategories,
-    pub(crate) action_offset: Option<TextSize>,
 }
 
 pub(crate) struct UpdateSnippetsNodes {
@@ -726,7 +702,6 @@ type FormatEmbedded = fn(
     Vec<FormatEmbedNode>,
 ) -> Result<Printed, WorkspaceError>;
 
-#[derive(Debug)]
 pub(crate) struct FormatEmbedNode {
     pub(crate) range: TextRange,
     pub(crate) node: AnyParse,
@@ -799,8 +774,8 @@ impl Features {
             json: JsonFileHandler {},
             css: CssFileHandler {},
             astro: AstroFileHandler {},
-            svelte: SvelteFileHandler {},
             vue: VueFileHandler {},
+            svelte: SvelteFileHandler {},
             graphql: GraphqlFileHandler {},
             html: HtmlFileHandler {},
             grit: GritFileHandler {},
@@ -812,7 +787,6 @@ impl Features {
     /// Returns the [Capabilities] associated with a [BiomePath]
     pub(crate) fn get_capabilities(&self, language_hint: DocumentFileSource) -> Capabilities {
         match language_hint {
-            // TODO: remove match once we remove vue/astro/svelte handlers
             DocumentFileSource::Js(source) => match source.as_embedding_kind() {
                 EmbeddingKind::Astro => self.astro.capabilities(),
                 EmbeddingKind::Vue => self.vue.capabilities(),
@@ -933,6 +907,36 @@ pub(crate) fn search(
     Ok(matches)
 }
 
+#[test]
+fn test_svelte_script_lang() {
+    const SVELTE_JS_SCRIPT_OPENING_TAG: &str = r#"<script>"#;
+    const SVELTE_TS_SCRIPT_OPENING_TAG: &str = r#"<script lang="ts">"#;
+    const SVELTE_CONTEXT_MODULE_JS_SCRIPT_OPENING_TAG: &str = r#"<script context="module">"#;
+    const SVELTE_CONTEXT_MODULE_TS_SCRIPT_OPENING_TAG: &str =
+        r#"<script context="module" lang="ts">"#;
+
+    assert!(
+        parse_lang_from_script_opening_tag(SVELTE_JS_SCRIPT_OPENING_TAG)
+            .0
+            .is_javascript()
+    );
+    assert!(
+        parse_lang_from_script_opening_tag(SVELTE_TS_SCRIPT_OPENING_TAG)
+            .0
+            .is_typescript()
+    );
+    assert!(
+        parse_lang_from_script_opening_tag(SVELTE_CONTEXT_MODULE_JS_SCRIPT_OPENING_TAG)
+            .0
+            .is_javascript()
+    );
+    assert!(
+        parse_lang_from_script_opening_tag(SVELTE_CONTEXT_MODULE_TS_SCRIPT_OPENING_TAG)
+            .0
+            .is_typescript()
+    );
+}
+
 /// Type meant to register all the syntax rules for each language supported by Biome
 ///
 /// When a new language is introduced, it must be implemented it. Syntax rules aren't negotiable via configuration, so it's safe
@@ -1659,3 +1663,59 @@ impl<'b> AnalyzerVisitorBuilder<'b> {
         (enabled_rules, disabled_rules, analyzer_options)
     }
 }
+
+#[test]
+fn test_vue_script_lang() {
+    const VUE_JS_SCRIPT_OPENING_TAG: &str = r#"<script>"#;
+    const VUE_TS_SCRIPT_OPENING_TAG: &str = r#"<script lang="ts">"#;
+    const VUE_TSX_SCRIPT_OPENING_TAG: &str = r#"<script lang="tsx">"#;
+    const VUE_JSX_SCRIPT_OPENING_TAG: &str = r#"<script lang="jsx">"#;
+    const VUE_SETUP_JS_SCRIPT_OPENING_TAG: &str = r#"<script setup>"#;
+    const VUE_SETUP_TS_SCRIPT_OPENING_TAG: &str = r#"<script setup lang="ts">"#;
+
+    assert!(
+        parse_lang_from_script_opening_tag(VUE_JS_SCRIPT_OPENING_TAG)
+            .0
+            .is_javascript()
+    );
+    assert!(
+        parse_lang_from_script_opening_tag(VUE_JS_SCRIPT_OPENING_TAG)
+            .1
+            .is_standard()
+    );
+    assert!(
+        parse_lang_from_script_opening_tag(VUE_TS_SCRIPT_OPENING_TAG)
+            .0
+            .is_typescript()
+    );
+    assert!(
+        parse_lang_from_script_opening_tag(VUE_TS_SCRIPT_OPENING_TAG)
+            .1
+            .is_standard()
+    );
+    assert!(
+        parse_lang_from_script_opening_tag(VUE_JSX_SCRIPT_OPENING_TAG)
+            .0
+            .is_javascript()
+    );
+    assert!(
+        parse_lang_from_script_opening_tag(VUE_JSX_SCRIPT_OPENING_TAG)
+            .1
+            .is_jsx()
+    );
+    assert!(
+        parse_lang_from_script_opening_tag(VUE_TSX_SCRIPT_OPENING_TAG)
+            .0
+            .is_typescript()
+    );
+    assert!(
+        parse_lang_from_script_opening_tag(VUE_SETUP_JS_SCRIPT_OPENING_TAG)
+            .0
+            .is_javascript()
+    );
+    assert!(
+        parse_lang_from_script_opening_tag(VUE_SETUP_TS_SCRIPT_OPENING_TAG)
+            .0
+            .is_typescript()
+    );
+}
diff --git a/crates/biome_service/src/file_handlers/svelte.rs b/crates/biome_service/src/file_handlers/svelte.rs
index fbe3ead301..ed406ae4ea 100644
--- a/crates/biome_service/src/file_handlers/svelte.rs
+++ b/crates/biome_service/src/file_handlers/svelte.rs
@@ -148,7 +148,8 @@ fn format(
     settings: &Settings,
 ) -> Result<Printed, WorkspaceError> {
     let options = settings.format_options::<JsLanguage>(biome_path, document_file_source);
-    let html_options = settings.format_options::<HtmlLanguage>(biome_path, document_file_source);
+    let html_options =
+        settings.format_options::<HtmlLanguage>(biome_path, &document_file_source.to_htmlish());
     let indent_amount = if *html_options.indent_script_and_style() {
         1
     } else {
diff --git a/crates/biome_service/src/file_handlers/vue.rs b/crates/biome_service/src/file_handlers/vue.rs
index aa0ff53a5e..2540f55ff0 100644
--- a/crates/biome_service/src/file_handlers/vue.rs
+++ b/crates/biome_service/src/file_handlers/vue.rs
@@ -148,7 +148,8 @@ fn format(
     settings: &Settings,
 ) -> Result<Printed, WorkspaceError> {
     let options = settings.format_options::<JsLanguage>(biome_path, document_file_source);
-    let html_options = settings.format_options::<HtmlLanguage>(biome_path, document_file_source);
+    let html_options =
+        settings.format_options::<HtmlLanguage>(biome_path, &document_file_source.to_htmlish());
     let indent_amount = if *html_options.indent_script_and_style() {
         1
     } else {
diff --git a/crates/biome_service/src/settings.rs b/crates/biome_service/src/settings.rs
index 947f0934b4..e3a1fe5fe6 100644
--- a/crates/biome_service/src/settings.rs
+++ b/crates/biome_service/src/settings.rs
@@ -6,7 +6,7 @@ use biome_configuration::analyzer::{LinterEnabled, RuleDomains};
 use biome_configuration::bool::Bool;
 use biome_configuration::diagnostics::InvalidIgnorePattern;
 use biome_configuration::formatter::{FormatWithErrorsEnabled, FormatterEnabled};
-use biome_configuration::html::{ExperimentalFullSupportEnabled, HtmlConfiguration};
+use biome_configuration::html::HtmlConfiguration;
 use biome_configuration::javascript::JsxRuntime;
 use biome_configuration::max_size::MaxSize;
 use biome_configuration::plugins::Plugins;
@@ -73,18 +73,9 @@ pub struct Settings {
     pub override_settings: OverrideSettings,
     /// The VCS settings of the project
     pub vcs_settings: VcsSettings,
-
-    // TODO: remove once HTML full support is stable
-    pub experimental_full_html_support: Option<ExperimentalFullSupportEnabled>,
 }
 
 impl Settings {
-    pub fn experimental_full_html_support_enabled(&self) -> bool {
-        self.experimental_full_html_support
-            .unwrap_or_default()
-            .value()
-    }
-
     pub fn source(&self) -> Option<Configuration> {
         self.source.as_ref().map(|source| {
             let (config, _) = source.deref().clone();
@@ -151,8 +142,7 @@ impl Settings {
         }
         // html settings
         if let Some(html) = configuration.html {
-            self.experimental_full_html_support = html.experimental_full_support_enabled;
-            self.languages.html = html.into();
+            self.languages.html = html.into()
         }
 
         // plugin settings
@@ -314,7 +304,6 @@ impl Settings {
             FeatureKind::Format => &self.formatter.includes,
             FeatureKind::Lint => &self.linter.includes,
             FeatureKind::Assist => &self.assist.includes,
-            FeatureKind::HtmlFullSupport => return false,
             FeatureKind::Search => return false, // There is no search-specific config.
             FeatureKind::Debug => return false,
         };
diff --git a/crates/biome_service/src/workspace.rs b/crates/biome_service/src/workspace.rs
index c3df2fdf47..5727ce8276 100644
--- a/crates/biome_service/src/workspace.rs
+++ b/crates/biome_service/src/workspace.rs
@@ -130,14 +130,13 @@ pub struct SupportsFeatureResult {
 pub struct FeaturesSupported([SupportKind; NUM_FEATURE_KINDS]);
 
 impl FeaturesSupported {
-    /// By default, a file does not support all features.
+    /// By default, all features are not supported by a file.
     const WORKSPACE_FEATURES: [SupportKind; NUM_FEATURE_KINDS] = [
         SupportKind::FileNotSupported,
         SupportKind::FileNotSupported,
         SupportKind::FileNotSupported,
         SupportKind::FileNotSupported,
         SupportKind::FileNotSupported,
-        SupportKind::FileNotSupported,
     ];
 
     #[inline]
@@ -219,12 +218,6 @@ impl FeaturesSupported {
             }
         }
 
-        if let Some(experimental_full_html_support) = settings.experimental_full_html_support
-            && experimental_full_html_support.value()
-        {
-            self.insert(FeatureKind::HtmlFullSupport, SupportKind::Supported);
-        }
-
         debug!("The file has the following feature sets: {:?}", &self);
 
         self
@@ -274,11 +267,6 @@ impl FeaturesSupported {
         self.supports(FeatureKind::Search)
     }
 
-    // TODO: remove once html full support is stable
-    pub fn supports_full_html_support(&self) -> bool {
-        self.supports(FeatureKind::HtmlFullSupport)
-    }
-
     /// Returns the [`SupportKind`] for the given `feature`, but only if it is
     /// not enabled.
     #[inline(always)]
@@ -548,11 +536,9 @@ pub enum FeatureKind {
     Search,
     Assist,
     Debug,
-    // TODO: remove once full HTML support is stable
-    HtmlFullSupport,
 }
 
-pub const NUM_FEATURE_KINDS: usize = 6;
+pub const NUM_FEATURE_KINDS: usize = 5;
 
 impl Display for FeatureKind {
     fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
@@ -562,7 +548,6 @@ impl Display for FeatureKind {
             Self::Search => write!(f, "Search"),
             Self::Assist => write!(f, "Assist"),
             Self::Debug => write!(f, "Debug"),
-            Self::HtmlFullSupport => write!(f, "HtmlFullSupport"),
         }
     }
 }
@@ -580,7 +565,6 @@ impl FeatureKind {
             2 => Self::Search,
             3 => Self::Assist,
             4 => Self::Debug,
-            5 => Self::HtmlFullSupport,
             _ => unreachable!("invalid index for FeatureKind"),
         }
     }
@@ -594,7 +578,6 @@ impl FeatureKind {
             Self::Search => 2,
             Self::Assist => 3,
             Self::Debug => 4,
-            Self::HtmlFullSupport => 5,
         }
     }
 }
@@ -623,7 +606,6 @@ impl Debug for FeatureName {
                 FeatureKind::Search => list.entry(&"Search"),
                 FeatureKind::Assist => list.entry(&"Assist"),
                 FeatureKind::Debug => list.entry(&"Debug"),
-                FeatureKind::HtmlFullSupport => list.entry(&"HtmlFullSupport"),
             };
         }
         list.finish()
@@ -987,7 +969,6 @@ pub struct CodeAction {
     pub category: ActionCategory,
     pub rule_name: Option<(Cow<'static, str>, Cow<'static, str>)>,
     pub suggestion: CodeSuggestion,
-    pub offset: Option<TextSize>,
 }
 
 #[derive(Debug, serde::Serialize, serde::Deserialize)]
diff --git a/crates/biome_service/src/workspace/server.rs b/crates/biome_service/src/workspace/server.rs
index 15413228f9..dd748e48c6 100644
--- a/crates/biome_service/src/workspace/server.rs
+++ b/crates/biome_service/src/workspace/server.rs
@@ -210,30 +210,19 @@ impl WorkspaceServer {
     }
 
     /// Gets the supported capabilities for a given file path.
-    fn get_file_capabilities(
-        &self,
-        path: &BiomePath,
-        experimental_full_html_support: bool,
-    ) -> Capabilities {
-        let language = self.get_file_source(path, experimental_full_html_support);
+    fn get_file_capabilities(&self, path: &BiomePath) -> Capabilities {
+        let language = self.get_file_source(path);
         self.features.get_capabilities(language)
     }
 
     /// Retrieves the supported language of a file.
-    fn get_file_source(
-        &self,
-        path: &Utf8Path,
-        experimental_full_html_support: bool,
-    ) -> DocumentFileSource {
+    fn get_file_source(&self, path: &Utf8Path) -> DocumentFileSource {
         self.documents
             .pin()
             .get(path)
             .map(|doc| doc.file_source_index)
             .and_then(|index| self.get_source(index))
-            .unwrap_or(DocumentFileSource::from_path(
-                path,
-                experimental_full_html_support,
-            ))
+            .unwrap_or(DocumentFileSource::from_path(path))
     }
 
     /// Returns an error factory function for unsupported features at a given
@@ -243,10 +232,9 @@ impl WorkspaceServer {
         path: &'a Utf8Path,
     ) -> impl FnOnce() -> WorkspaceError + 'a {
         move || {
-            // For simplicity and avoid too many changes, we hardcode the support to false
-            let file_source = self.get_file_source(path, false);
+            let file_source = self.get_file_source(path);
 
-            let language = DocumentFileSource::from_path(path, false).or(file_source);
+            let language = DocumentFileSource::from_path(path).or(file_source);
             WorkspaceError::source_file_not_supported(
                 language,
                 path.to_string(),
@@ -300,16 +288,13 @@ impl WorkspaceServer {
             return Ok(Default::default());
         }
 
+        let mut source = document_file_source.unwrap_or(DocumentFileSource::from_path(&path));
+
         let settings = self
             .projects
             .get_settings_based_on_path(project_key, &path)
             .ok_or_else(WorkspaceError::no_project)?;
 
-        let mut source = document_file_source.unwrap_or(DocumentFileSource::from_path(
-            &path,
-            settings.experimental_full_html_support_enabled(),
-        ));
-
         if let DocumentFileSource::Js(js) = &mut source {
             match path.extension() {
                 Some("js") => {
@@ -378,10 +363,8 @@ impl WorkspaceServer {
         };
         // Second-pass parsing for HTML files with embedded JavaScript and CSS
         // content.
-        let embedded_snippets = if DocumentFileSource::can_contain_embeds(
-            path.as_path(),
-            settings.experimental_full_html_support_enabled(),
-        ) && let Some(Ok(any_parse)) = &syntax
+        let embedded_snippets = if DocumentFileSource::can_contain_embeds(path.as_path())
+            && let Some(Ok(any_parse)) = &syntax
         {
             // Second-pass parsing for HTML files with embedded JavaScript and CSS content
 
@@ -540,8 +523,7 @@ impl WorkspaceServer {
         settings: &Settings,
     ) -> Result<Vec<AnyEmbeddedSnippet>, WorkspaceError> {
         let mut embedded_nodes = Vec::new();
-        let capabilities =
-            self.get_file_capabilities(path, settings.experimental_full_html_support_enabled());
+        let capabilities = self.get_file_capabilities(path);
         let Some(parse_embedded) = capabilities.parser.parse_embedded_nodes else {
             return Ok(Default::default());
         };
@@ -1096,14 +1078,7 @@ impl Workspace for WorkspaceServer {
         &self,
         params: SupportsFeatureParams,
     ) -> Result<FileFeaturesResult, WorkspaceError> {
-        let settings = self
-            .projects
-            .get_settings_based_on_path(params.project_key, &params.path)
-            .ok_or_else(WorkspaceError::no_project)?;
-        let language = self.get_file_source(
-            &params.path,
-            settings.experimental_full_html_support_enabled(),
-        );
+        let language = self.get_file_source(&params.path);
         let capabilities = self.features.get_capabilities(language);
 
         self.projects.get_file_features(
@@ -1141,14 +1116,7 @@ impl Workspace for WorkspaceServer {
         &self,
         params: GetSyntaxTreeParams,
     ) -> Result<GetSyntaxTreeResult, WorkspaceError> {
-        let settings = self
-            .projects
-            .get_settings_based_on_path(params.project_key, &params.path)
-            .ok_or_else(WorkspaceError::no_project)?;
-        let capabilities = self.get_file_capabilities(
-            &params.path,
-            settings.experimental_full_html_support_enabled(),
-        );
+        let capabilities = self.get_file_capabilities(&params.path);
         let debug_syntax_tree = capabilities
             .debug
             .debug_syntax_tree
@@ -1165,14 +1133,7 @@ impl Workspace for WorkspaceServer {
         &self,
         params: GetControlFlowGraphParams,
     ) -> Result<String, WorkspaceError> {
-        let settings = self
-            .projects
-            .get_settings_based_on_path(params.project_key, &params.path)
-            .ok_or_else(WorkspaceError::no_project)?;
-        let capabilities = self.get_file_capabilities(
-            &params.path,
-            settings.experimental_full_html_support_enabled(),
-        );
+        let capabilities = self.get_file_capabilities(&params.path);
         let debug_control_flow = capabilities
             .debug
             .debug_control_flow
@@ -1185,41 +1146,28 @@ impl Workspace for WorkspaceServer {
     }
 
     fn get_formatter_ir(&self, params: GetFormatterIRParams) -> Result<String, WorkspaceError> {
-        let settings = self
-            .projects
-            .get_settings_based_on_path(params.project_key, &params.path)
-            .ok_or_else(WorkspaceError::no_project)?;
-        let capabilities = self.get_file_capabilities(
-            &params.path,
-            settings.experimental_full_html_support_enabled(),
-        );
+        let capabilities = self.get_file_capabilities(&params.path);
         let debug_formatter_ir = capabilities
             .debug
             .debug_formatter_ir
             .ok_or_else(self.build_capability_error(&params.path))?;
+        let settings = self
+            .projects
+            .get_settings_based_on_path(params.project_key, &params.path)
+            .ok_or_else(WorkspaceError::no_project)?;
         let parse = self.get_parse(&params.path)?;
         if !settings.format_with_errors_enabled_for_this_file_path(&params.path)
             && parse.has_errors()
         {
             return Err(WorkspaceError::format_with_errors_disabled());
         }
-        let document_file_source = self.get_file_source(
-            &params.path,
-            settings.experimental_full_html_support_enabled(),
-        );
+        let document_file_source = self.get_file_source(&params.path);
 
         debug_formatter_ir(&params.path, &document_file_source, parse, &settings)
     }
 
     fn get_type_info(&self, params: GetTypeInfoParams) -> Result<String, WorkspaceError> {
-        let settings = self
-            .projects
-            .get_settings_based_on_path(params.project_key, &params.path)
-            .ok_or_else(WorkspaceError::no_project)?;
-        let capabilities = self.get_file_capabilities(
-            &params.path,
-            settings.experimental_full_html_support_enabled(),
-        );
+        let capabilities = self.get_file_capabilities(&params.path);
         let debug_type_info = capabilities
             .debug
             .debug_type_info
@@ -1233,14 +1181,7 @@ impl Workspace for WorkspaceServer {
         &self,
         params: GetRegisteredTypesParams,
     ) -> Result<String, WorkspaceError> {
-        let settings = self
-            .projects
-            .get_settings_based_on_path(params.project_key, &params.path)
-            .ok_or_else(WorkspaceError::no_project)?;
-        let capabilities = self.get_file_capabilities(
-            &params.path,
-            settings.experimental_full_html_support_enabled(),
-        );
+        let capabilities = self.get_file_capabilities(&params.path);
         let debug_registered_types = capabilities
             .debug
             .debug_registered_types
@@ -1251,14 +1192,7 @@ impl Workspace for WorkspaceServer {
     }
 
     fn get_semantic_model(&self, params: GetSemanticModelParams) -> Result<String, WorkspaceError> {
-        let settings = self
-            .projects
-            .get_settings_based_on_path(params.project_key, &params.path)
-            .ok_or_else(WorkspaceError::no_project)?;
-        let capabilities = self.get_file_capabilities(
-            &params.path,
-            settings.experimental_full_html_support_enabled(),
-        );
+        let capabilities = self.get_file_capabilities(&params.path);
         let debug_semantic_model = capabilities
             .debug
             .debug_semantic_model
@@ -1338,14 +1272,10 @@ impl Workspace for WorkspaceServer {
 
         let parsed = self.parse(&path, &content, &settings, index, &mut node_cache)?;
         let root = parsed.any_parse.unwrap_as_send_node();
-        let document_source =
-            self.get_file_source(&path, settings.experimental_full_html_support_enabled());
+        let document_source = self.get_file_source(&path);
 
         // Second-pass parsing for HTML files with embedded JavaScript and CSS content
-        let embedded_snippets = if DocumentFileSource::can_contain_embeds(
-            path.as_path(),
-            settings.experimental_full_html_support_enabled(),
-        ) {
+        let embedded_snippets = if DocumentFileSource::can_contain_embeds(path.as_path()) {
             // Second-pass parsing for HTML files with embedded JavaScript and CSS content
             let mut node_cache = NodeCache::default();
             self.parse_embedded_language_snippets(
@@ -1435,18 +1365,18 @@ impl Workspace for WorkspaceServer {
             enabled_rules,
             pull_code_actions,
         } = params;
-        let settings = self
-            .projects
-            .get_settings_based_on_path(project_key, &path)
-            .ok_or_else(WorkspaceError::no_project)?;
         let (parse, embedded_snippets) = self.get_parse_with_snippets(&path)?;
-        let language =
-            self.get_file_source(&path, settings.experimental_full_html_support_enabled());
+        let language = self.get_file_source(&path);
         let capabilities = self.features.get_capabilities(language);
         let (diagnostics, errors, skipped_diagnostics) = if (categories.is_lint()
             || categories.is_assist())
             && let Some(lint) = capabilities.analyzer.lint
         {
+            let settings = self
+                .projects
+                .get_settings_based_on_path(project_key, &path)
+                .ok_or_else(WorkspaceError::no_project)?;
+
             let plugins = if categories.is_lint() {
                 self.get_analyzer_plugins_for_project(
                     settings.source_path().unwrap_or_default().as_path(),
@@ -1570,20 +1500,18 @@ impl Workspace for WorkspaceServer {
             enabled_rules,
             categories,
         } = params;
-        let settings = self
-            .projects
-            .get_settings_based_on_path(project_key, &path)
-            .ok_or_else(WorkspaceError::no_project)?;
-        let capabilities =
-            self.get_file_capabilities(&path, settings.experimental_full_html_support_enabled());
+        let capabilities = self.get_file_capabilities(&path);
         let code_actions = capabilities
             .analyzer
             .code_actions
             .ok_or_else(self.build_capability_error(&path))?;
 
         let (parse, embedded_snippets) = self.get_parse_with_snippets(&path)?;
-        let language =
-            self.get_file_source(&path, settings.experimental_full_html_support_enabled());
+        let language = self.get_file_source(&path);
+        let settings = self
+            .projects
+            .get_settings_based_on_path(project_key, &path)
+            .ok_or_else(WorkspaceError::no_project)?;
         let mut result = code_actions(CodeActionsParams {
             parse,
             range,
@@ -1598,7 +1526,6 @@ impl Workspace for WorkspaceServer {
             enabled_rules: &enabled_rules,
             plugins: Vec::new(),
             categories,
-            action_offset: None,
         });
 
         for embedded_snippet in embedded_snippets {
@@ -1624,7 +1551,6 @@ impl Workspace for WorkspaceServer {
                 enabled_rules: &enabled_rules,
                 plugins: Vec::new(),
                 categories,
-                action_offset: Some(embedded_snippet.content_offset()),
             });
 
             result.actions.extend(embedded_actions_result.actions);
@@ -1643,14 +1569,7 @@ impl Workspace for WorkspaceServer {
         )
     )]
     fn format_file(&self, params: FormatFileParams) -> Result<Printed, WorkspaceError> {
-        let settings = self
-            .projects
-            .get_settings_based_on_path(params.project_key, &params.path)
-            .ok_or_else(WorkspaceError::no_project)?;
-        let capabilities = self.get_file_capabilities(
-            &params.path,
-            settings.experimental_full_html_support_enabled(),
-        );
+        let capabilities = self.get_file_capabilities(&params.path);
 
         let format = capabilities
             .formatter
@@ -1659,6 +1578,11 @@ impl Workspace for WorkspaceServer {
 
         let format_embedded = capabilities.formatter.format_embedded;
 
+        let settings = self
+            .projects
+            .get_settings_based_on_path(params.project_key, &params.path)
+            .ok_or_else(WorkspaceError::no_project)?;
+
         let (parse, embedded_nodes) = self.get_parse_with_embedded_format_nodes(&params.path)?;
 
         if !settings.format_with_errors_enabled_for_this_file_path(&params.path)
@@ -1667,10 +1591,7 @@ impl Workspace for WorkspaceServer {
             return Err(WorkspaceError::format_with_errors_disabled());
         }
 
-        let document_file_source = self.get_file_source(
-            &params.path,
-            settings.experimental_full_html_support_enabled(),
-        );
+        let document_file_source = self.get_file_source(&params.path);
         if !embedded_nodes.is_empty() {
             let format_embedded =
                 format_embedded.ok_or_else(self.build_capability_error(&params.path))?;
@@ -1687,28 +1608,22 @@ impl Workspace for WorkspaceServer {
 
     #[instrument(level = "debug", skip(self, params))]
     fn format_range(&self, params: FormatRangeParams) -> Result<Printed, WorkspaceError> {
-        let settings = self
-            .projects
-            .get_settings_based_on_path(params.project_key, &params.path)
-            .ok_or_else(WorkspaceError::no_project)?;
-        let capabilities = self.get_file_capabilities(
-            &params.path,
-            settings.experimental_full_html_support_enabled(),
-        );
+        let capabilities = self.get_file_capabilities(&params.path);
         let format_range = capabilities
             .formatter
             .format_range
             .ok_or_else(self.build_capability_error(&params.path))?;
+        let settings = self
+            .projects
+            .get_settings_based_on_path(params.project_key, &params.path)
+            .ok_or_else(WorkspaceError::no_project)?;
         let parse = self.get_parse(&params.path)?;
         if !settings.format_with_errors_enabled_for_this_file_path(&params.path)
             && parse.has_errors()
         {
             return Err(WorkspaceError::format_with_errors_disabled());
         }
-        let document_file_source = self.get_file_source(
-            &params.path,
-            settings.experimental_full_html_support_enabled(),
-        );
+        let document_file_source = self.get_file_source(&params.path);
         format_range(
             &params.path,
             &document_file_source,
@@ -1720,29 +1635,23 @@ impl Workspace for WorkspaceServer {
 
     #[instrument(level = "debug", skip(self, params))]
     fn format_on_type(&self, params: FormatOnTypeParams) -> Result<Printed, WorkspaceError> {
-        let settings = self
-            .projects
-            .get_settings_based_on_path(params.project_key, &params.path)
-            .ok_or_else(WorkspaceError::no_project)?;
-        let capabilities = self.get_file_capabilities(
-            &params.path,
-            settings.experimental_full_html_support_enabled(),
-        );
+        let capabilities = self.get_file_capabilities(&params.path);
         let format_on_type = capabilities
             .formatter
             .format_on_type
             .ok_or_else(self.build_capability_error(&params.path))?;
 
+        let settings = self
+            .projects
+            .get_settings_based_on_path(params.project_key, &params.path)
+            .ok_or_else(WorkspaceError::no_project)?;
         let parse = self.get_parse(&params.path)?;
         if !settings.format_with_errors_enabled_for_this_file_path(&params.path)
             && parse.has_errors()
         {
             return Err(WorkspaceError::format_with_errors_disabled());
         }
-        let document_file_source = self.get_file_source(
-            &params.path,
-            settings.experimental_full_html_support_enabled(),
-        );
+        let document_file_source = self.get_file_source(&params.path);
 
         format_on_type(
             &params.path,
@@ -1777,12 +1686,7 @@ impl Workspace for WorkspaceServer {
             suppression_reason,
         } = params;
 
-        let settings = self
-            .projects
-            .get_settings_based_on_path(project_key, &path)
-            .ok_or_else(WorkspaceError::no_project)?;
-        let capabilities =
-            self.get_file_capabilities(&path, settings.experimental_full_html_support_enabled());
+        let capabilities = self.get_file_capabilities(&path);
 
         let fix_all = capabilities
             .analyzer
@@ -1791,14 +1695,17 @@ impl Workspace for WorkspaceServer {
 
         let (mut parse, embedded_snippets) = self.get_parse_with_snippets(&path)?;
 
+        let settings = self
+            .projects
+            .get_settings_based_on_path(project_key, &path)
+            .ok_or_else(WorkspaceError::no_project)?;
         let plugins = self
             .get_analyzer_plugins_for_project(
                 settings.source_path().unwrap_or_default().as_path(),
                 &settings.get_plugins_for_path(&path),
             )
             .map_err(WorkspaceError::plugin_errors)?;
-        let language =
-            self.get_file_source(&path, settings.experimental_full_html_support_enabled());
+        let language = self.get_file_source(&path);
         let plugins = if rule_categories.contains(RuleCategory::Lint) {
             plugins
         } else {
@@ -1882,15 +1789,8 @@ impl Workspace for WorkspaceServer {
         })
     }
 
-    fn rename(&self, params: RenameParams) -> Result<RenameResult, WorkspaceError> {
-        let settings = self
-            .projects
-            .get_settings_based_on_path(params.project_key, &params.path)
-            .ok_or_else(WorkspaceError::no_project)?;
-        let capabilities = self.get_file_capabilities(
-            &params.path,
-            settings.experimental_full_html_support_enabled(),
-        );
+    fn rename(&self, params: super::RenameParams) -> Result<RenameResult, WorkspaceError> {
+        let capabilities = self.get_file_capabilities(&params.path);
         let rename = capabilities
             .analyzer
             .rename
@@ -1964,17 +1864,12 @@ impl Workspace for WorkspaceServer {
             pattern,
         }: SearchPatternParams,
     ) -> Result<SearchResults, WorkspaceError> {
-        let settings = self
-            .projects
-            .get_settings_based_on_path(project_key, &path)
-            .ok_or_else(WorkspaceError::no_project)?;
         let patterns = self.patterns.pin();
         let query = patterns
             .get(&pattern)
             .ok_or_else(WorkspaceError::invalid_pattern)?;
 
-        let capabilities =
-            self.get_file_capabilities(&path, settings.experimental_full_html_support_enabled());
+        let capabilities = self.get_file_capabilities(&path);
         let search = capabilities
             .search
             .search
@@ -1985,14 +1880,13 @@ impl Workspace for WorkspaceServer {
             .ok_or_else(WorkspaceError::no_project)?;
         let parse = self.get_parse(&path)?;
 
-        let document_file_source =
-            self.get_file_source(&path, settings.experimental_full_html_support_enabled());
+        let document_file_source = self.get_file_source(&path);
         let matches = search(&path, &document_file_source, parse, query, &settings)?;
 
         Ok(SearchResults { path, matches })
     }
 
-    fn drop_pattern(&self, params: DropPatternParams) -> Result<(), WorkspaceError> {
+    fn drop_pattern(&self, params: super::DropPatternParams) -> Result<(), WorkspaceError> {
         self.patterns.pin().remove(&params.pattern);
         Ok(())
     }
diff --git a/crates/biome_service/src/workspace/server.tests.rs b/crates/biome_service/src/workspace/server.tests.rs
index 22714f6990..26950bad3c 100644
--- a/crates/biome_service/src/workspace/server.tests.rs
+++ b/crates/biome_service/src/workspace/server.tests.rs
@@ -270,7 +270,7 @@ function Foo({cond}) {
         })
         .unwrap();
 
-    let ts_file_source = workspace.get_file_source("/project/a.ts".into(), false);
+    let ts_file_source = workspace.get_file_source("/project/a.ts".into());
     let ts = ts_file_source.to_js_file_source().expect("JS file source");
     assert!(ts.is_typescript());
     assert!(!ts.is_jsx());
@@ -279,7 +279,7 @@ function Foo({cond}) {
         Err(error) => panic!("File not available: {error}"),
     }
 
-    let js_file_source = workspace.get_file_source("/project/a.js".into(), false);
+    let js_file_source = workspace.get_file_source("/project/a.js".into());
     let js = js_file_source.to_js_file_source().expect("JS file source");
     assert!(!js.is_typescript());
     assert!(js.is_jsx());
@@ -382,7 +382,7 @@ function Foo({cond}) {
         })
         .unwrap();
 
-    let js_file_source = workspace.get_file_source("/project/a.js".into(), false);
+    let js_file_source = workspace.get_file_source("/project/a.js".into());
     let js = js_file_source.to_js_file_source().expect("JS file source");
     assert!(!js.is_typescript());
     assert!(!js.is_jsx());
@@ -391,7 +391,7 @@ function Foo({cond}) {
         Err(error) => panic!("File not available: {error}"),
     }
 
-    let jsx_file_source = workspace.get_file_source("/project/a.jsx".into(), false);
+    let jsx_file_source = workspace.get_file_source("/project/a.jsx".into());
     let jsx = jsx_file_source.to_js_file_source().expect("JS file source");
     assert!(!jsx.is_typescript());
     assert!(jsx.is_jsx());
diff --git a/crates/biome_test_utils/src/lib.rs b/crates/biome_test_utils/src/lib.rs
index cd01c2626a..4984696762 100644
--- a/crates/biome_test_utils/src/lib.rs
+++ b/crates/biome_test_utils/src/lib.rs
@@ -86,10 +86,7 @@ pub fn create_analyzer_options<L: ServiceLanguage>(
             &L::lookup_settings(&settings.languages).linter,
             L::resolve_environment(&settings),
             &BiomePath::new(input_file),
-            &DocumentFileSource::from_path(
-                input_file,
-                settings.experimental_full_html_support_enabled(),
-            ),
+            &DocumentFileSource::from_path(input_file),
             None,
         )
     }
@@ -133,10 +130,7 @@ where
             .merge_with_configuration(configuration, None)
             .unwrap();
 
-        let document_file_source = DocumentFileSource::from_path(
-            input_file,
-            settings.experimental_full_html_support_enabled(),
-        );
+        let document_file_source = DocumentFileSource::from_path(input_file);
         settings.format_options::<L>(&input_file.into(), &document_file_source)
     }
 }
@@ -197,7 +191,7 @@ fn get_js_like_paths_in_dir(dir: &Utf8Path) -> Vec<BiomePath> {
             if path.is_dir() {
                 get_js_like_paths_in_dir(&path)
             } else {
-                DocumentFileSource::from_well_known(&path, false)
+                DocumentFileSource::from_well_known(&path)
                     .is_javascript_like()
                     .then(|| BiomePath::new(path))
                     .into_iter()
diff --git a/packages/@biomejs/backend-jsonrpc/src/workspace.ts b/packages/@biomejs/backend-jsonrpc/src/workspace.ts
index 7be5a6207b..9a270f969f 100644
--- a/packages/@biomejs/backend-jsonrpc/src/workspace.ts
+++ b/packages/@biomejs/backend-jsonrpc/src/workspace.ts
@@ -8,13 +8,7 @@ export interface SupportsFeatureParams {
 export type FeatureName = FeatureKind[];
 export type BiomePath = string;
 export type ProjectKey = number;
-export type FeatureKind =
-	| "format"
-	| "lint"
-	| "search"
-	| "assist"
-	| "debug"
-	| "htmlFullSupport";
+export type FeatureKind = "format" | "lint" | "search" | "assist" | "debug";
 export interface FileFeaturesResult {
 	featuresSupported: FeaturesSupported;
 }
@@ -251,10 +245,6 @@ export interface GritConfiguration {
  */
 export interface HtmlConfiguration {
 	assist?: HtmlAssistConfiguration;
-	/**
-	 * Enables full support for HTML, Vue, Svelte and Astro files.
-	 */
-	experimentalFullSupportEnabled?: Bool;
 	/**
 	 * HTML formatter options
 	 */
@@ -8565,7 +8555,12 @@ export interface NoTemplateCurlyInStringOptions {}
 export interface NoThenPropertyOptions {}
 export interface NoTsIgnoreOptions {}
 export interface NoUnassignedVariablesOptions {}
-export interface NoUnknownAtRulesOptions {}
+export interface NoUnknownAtRulesOptions {
+	/**
+	 * A list of unknown at-rule names to ignore (case-insensitive).
+	 */
+	ignore: string[];
+}
 export interface NoUnsafeDeclarationMergingOptions {}
 export interface NoUnsafeNegationOptions {}
 export interface NoUselessEscapeInStringOptions {}
@@ -9421,7 +9416,7 @@ export type DocumentFileSource =
 	| { Grit: GritFileSource };
 export interface JsFileSource {
 	/**
-	 * Used to mark if the JavaScript is embedded inside some particular files. This affects the parsing. For example, if inside an Astro file, a top-level return statement is allowed.
+	 * Used to mark if the source is being used for an Astro, Svelte or Vue file
 	 */
 	embedding_kind: EmbeddingKind;
 	language: Language;
@@ -9603,18 +9598,17 @@ export interface PullDiagnosticsParams {
 	/**
 	 * Rules to apply on top of the configuration
 	 */
-	enabledRules?: AnalyzerSelector[];
-	only?: AnalyzerSelector[];
+	enabledRules?: Selector[];
+	only?: Selector[];
 	path: BiomePath;
 	projectKey: ProjectKey;
 	/**
 	 * When `false` the diagnostics, don't have code frames of the code actions (fixes, suppressions, etc.)
 	 */
 	pullCodeActions: boolean;
-	skip?: AnalyzerSelector[];
+	skip?: Selector[];
 }
 export type RuleCategories = RuleCategory[];
-export type AnalyzerSelector = string;
 export type RuleCategory = "syntax" | "lint" | "action" | "transformation";
 export interface PullDiagnosticsResult {
 	diagnostics: Diagnostic[];
@@ -9623,12 +9617,12 @@ export interface PullDiagnosticsResult {
 }
 export interface PullActionsParams {
 	categories?: RuleCategories;
-	enabledRules?: AnalyzerSelector[];
-	only?: AnalyzerSelector[];
+	enabledRules?: Selector[];
+	only?: Selector[];
 	path: BiomePath;
 	projectKey: ProjectKey;
 	range?: TextRange;
-	skip?: AnalyzerSelector[];
+	skip?: Selector[];
 	suppressionReason?: string;
 }
 export interface PullActionsResult {
@@ -9636,7 +9630,6 @@ export interface PullActionsResult {
 }
 export interface CodeAction {
 	category: ActionCategory;
-	offset?: TextSize;
 	ruleName?: [string, string];
 	suggestion: CodeSuggestion;
 }
@@ -9724,14 +9717,14 @@ export interface FixFileParams {
 	/**
 	 * Rules to apply to the file
 	 */
-	enabledRules?: AnalyzerSelector[];
+	enabledRules?: Selector[];
 	fixFileMode: FixFileMode;
-	only?: AnalyzerSelector[];
+	only?: Selector[];
 	path: BiomePath;
 	projectKey: ProjectKey;
 	ruleCategories: RuleCategories;
 	shouldFormat: boolean;
-	skip?: AnalyzerSelector[];
+	skip?: Selector[];
 	suppressionReason?: string;
 }
 /**
diff --git a/packages/@biomejs/biome/configuration_schema.json b/packages/@biomejs/biome/configuration_schema.json
index a1821b3d47..ae2bb79438 100644
--- a/packages/@biomejs/biome/configuration_schema.json
+++ b/packages/@biomejs/biome/configuration_schema.json
@@ -1863,10 +1863,6 @@
 						{ "type": "null" }
 					]
 				},
-				"experimentalFullSupportEnabled": {
-					"description": "Enables full support for HTML, Vue, Svelte and Astro files.",
-					"anyOf": [{ "$ref": "#/definitions/Bool" }, { "type": "null" }]
-				},
 				"formatter": {
 					"description": "HTML formatter options",
 					"anyOf": [
@@ -4470,6 +4466,13 @@
 		},
 		"NoUnknownAtRulesOptions": {
 			"type": "object",
+			"properties": {
+				"ignore": {
+					"description": "A list of unknown at-rule names to ignore (case-insensitive).",
+					"type": "array",
+					"items": { "type": "string" }
+				}
+			},
 			"additionalProperties": false
 		},
 		"NoUnknownFunctionConfiguration": {
diff --git a/xtask/codegen/html.ungram b/xtask/codegen/html.ungram
index f8c0045d65..ea7aa639c5 100644
--- a/xtask/codegen/html.ungram
+++ b/xtask/codegen/html.ungram
@@ -144,11 +144,8 @@ AnyAstroFrontmatterElement =
 
 AstroFrontmatterElement =
 	l_fence: '---'
-	content: AstroEmbeddedContent
-	r_fence: '---'
-
-AstroEmbeddedContent =
 	content: 'html_literal'?
+	r_fence: '---'
 
 // ==================================
 // Attributes
diff --git a/xtask/codegen/src/html_kinds_src.rs b/xtask/codegen/src/html_kinds_src.rs
index 22dd5a1c9c..e0b58e6453 100644
--- a/xtask/codegen/src/html_kinds_src.rs
+++ b/xtask/codegen/src/html_kinds_src.rs
@@ -31,7 +31,6 @@ pub const HTML_KINDS_SRC: KindsSrc = KindsSrc {
         "HTML_SELF_CLOSING_TAG",
         "HTML_ELEMENT",
         "ASTRO_FRONTMATTER_ELEMENT",
-        "ASTRO_EMBEDDED_CONTENT",
         "HTML_OPENING_ELEMENT",
         "HTML_CLOSING_ELEMENT",
         "HTML_SELF_CLOSING_ELEMENT",
diff --git a/xtask/rules_check/src/lib.rs b/xtask/rules_check/src/lib.rs
index 03077a85cc..d4a48da6f6 100644
--- a/xtask/rules_check/src/lib.rs
+++ b/xtask/rules_check/src/lib.rs
@@ -405,8 +405,8 @@ fn assert_lint(
                 });
             }
         }
-        DocumentFileSource::Html(source) => {
-            let parse = biome_html_parser::parse_html(code, HtmlParseOptions::from(&source));
+        DocumentFileSource::Html(..) => {
+            let parse = biome_html_parser::parse_html(code, HtmlParseOptions::default());
 
             if parse.has_errors() {
                 for diag in parse.into_diagnostics() {
