diff --git a/test/fixtures/command with space b/fixtures/command with space
similarity index 100%
rename from test/fixtures/command with space
rename to fixtures/command with space
diff --git a/test/fixtures/delay b/fixtures/delay
similarity index 100%
rename from test/fixtures/delay
rename to fixtures/delay
diff --git a/fixtures/detach b/fixtures/detach
new file mode 100755
index 0000000..7da1f8f
--- /dev/null
+++ b/fixtures/detach
@@ -0,0 +1,8 @@
+#!/usr/bin/env node
+'use strict';
+
+const execa = require('..');
+
+const subprocess = execa('node', ['./fixtures/forever'], {detached: true});
+console.log(subprocess.pid);
+process.exit();
diff --git a/fixtures/echo b/fixtures/echo
new file mode 100755
index 0000000..cdfa972
--- /dev/null
+++ b/fixtures/echo
@@ -0,0 +1,3 @@
+#!/usr/bin/env node
+'use strict';
+console.log(process.argv.slice(2).join('\n'))
diff --git a/test/fixtures/environment b/fixtures/environment
similarity index 100%
rename from test/fixtures/environment
rename to fixtures/environment
diff --git a/test/fixtures/exit b/fixtures/exit
similarity index 100%
rename from test/fixtures/exit
rename to fixtures/exit
diff --git a/test/fixtures/fail b/fixtures/fail
similarity index 100%
rename from test/fixtures/fail
rename to fixtures/fail
diff --git a/test/fixtures/fast-exit-darwin b/fixtures/fast-exit-darwin
similarity index 100%
rename from test/fixtures/fast-exit-darwin
rename to fixtures/fast-exit-darwin
diff --git a/test/fixtures/fast-exit-linux b/fixtures/fast-exit-linux
similarity index 100%
rename from test/fixtures/fast-exit-linux
rename to fixtures/fast-exit-linux
diff --git a/test/fixtures/forever b/fixtures/forever
similarity index 100%
rename from test/fixtures/forever
rename to fixtures/forever
diff --git a/test/fixtures/hello.cmd b/fixtures/hello.cmd
old mode 100755
new mode 100644
similarity index 100%
rename from test/fixtures/hello.cmd
rename to fixtures/hello.cmd
diff --git a/test/fixtures/max-buffer b/fixtures/max-buffer
similarity index 100%
rename from test/fixtures/max-buffer
rename to fixtures/max-buffer
diff --git a/test/fixtures/no-killable b/fixtures/no-killable
old mode 100755
new mode 100644
similarity index 100%
rename from test/fixtures/no-killable
rename to fixtures/no-killable
diff --git a/test/fixtures/non-executable b/fixtures/non-executable
similarity index 100%
rename from test/fixtures/non-executable
rename to fixtures/non-executable
diff --git a/test/fixtures/noop b/fixtures/noop
similarity index 100%
rename from test/fixtures/noop
rename to fixtures/noop
diff --git a/test/fixtures/noop-132 b/fixtures/noop-132
similarity index 100%
rename from test/fixtures/noop-132
rename to fixtures/noop-132
diff --git a/test/fixtures/noop-err b/fixtures/noop-err
similarity index 100%
rename from test/fixtures/noop-err
rename to fixtures/noop-err
diff --git a/test/fixtures/noop-throw b/fixtures/noop-throw
similarity index 100%
rename from test/fixtures/noop-throw
rename to fixtures/noop-throw
diff --git a/test/fixtures/stdin b/fixtures/stdin
similarity index 100%
rename from test/fixtures/stdin
rename to fixtures/stdin
diff --git a/test/fixtures/sub-process b/fixtures/sub-process
similarity index 57%
rename from test/fixtures/sub-process
rename to fixtures/sub-process
index 6920e79..727aa00 100755
--- a/test/fixtures/sub-process
+++ b/fixtures/sub-process
@@ -1,8 +1,8 @@
 #!/usr/bin/env node
 'use strict';
-const execa = require('../..');
+const execa = require('..');
 
 const cleanup = process.argv[2] === 'true';
 const detached = process.argv[3] === 'true';
-const subprocess = execa('node', ['./test/fixtures/forever'], {cleanup, detached});
+const subprocess = execa('node', ['./fixtures/forever'], {cleanup, detached});
 process.send(subprocess.pid);
diff --git a/test/fixtures/sub-process-exit b/fixtures/sub-process-exit
similarity index 56%
rename from test/fixtures/sub-process-exit
rename to fixtures/sub-process-exit
index 2b350a2..3ea8173 100755
--- a/test/fixtures/sub-process-exit
+++ b/fixtures/sub-process-exit
@@ -1,7 +1,7 @@
 #!/usr/bin/env node
 'use strict';
-const execa = require('../..');
+const execa = require('..');
 
 const cleanup = process.argv[2] === 'true';
 const detached = process.argv[3] === 'true';
-execa('node', ['./test/fixtures/noop'], {cleanup, detached});
+execa('node', ['./fixtures/noop'], {cleanup, detached});
diff --git a/index.d.ts b/index.d.ts
index 9a21846..cb25030 100644
--- a/index.d.ts
+++ b/index.d.ts
@@ -187,29 +187,14 @@ declare namespace execa {
 		readonly input?: string | Buffer | ReadableStream;
 	}
 
-	interface SyncOptions<EncodingType = string> extends CommonOptions<EncodingType> {
+	interface SyncOptions<EncodingType = string>
+		extends CommonOptions<EncodingType> {
 		/**
 		Write some input to the `stdin` of your binary.
 		*/
 		readonly input?: string | Buffer;
 	}
 
-	interface NodeOptions<EncodingType = string> extends Options<EncodingType> {
-		/**
-		The Node.js executable to use.
-
-		@default process.execPath
-		*/
-		readonly nodePath?: string;
-
-		/**
-		List of string arguments passed to the Node.js executable.
-
-		@default process.execArgv
-		*/
-		readonly nodeArguments?: string[];
-	}
-
 	interface ExecaReturnBase<StdoutStderrType> {
 		/**
 		The file and arguments that were run.
@@ -432,26 +417,6 @@ declare const execa: {
 	*/
 	commandSync(command: string, options?: execa.SyncOptions): execa.ExecaSyncReturnValue;
 	commandSync(command: string, options?: execa.SyncOptions<null>): execa.ExecaSyncReturnValue<Buffer>;
-
-	/**
-	Execute a Node.js script as a child process.
-
-	@param scriptPath - Node.js script to execute.
-	@param arguments - Arguments to pass to `scriptPath` on execution.
-	@returns A [`child_process` instance](https://nodejs.org/api/child_process.html#child_process_class_childprocess), which is enhanced to also be a `Promise` for a result `Object` with `stdout` and `stderr` properties.
-	*/
-	node(
-		scriptPath: string,
-		arguments?: readonly string[],
-		options?: execa.NodeOptions
-	): execa.ExecaChildProcess;
-	node(
-		file: string,
-		arguments?: readonly string[],
-		options?: execa.Options<null>
-	): execa.ExecaChildProcess<Buffer>;
-	node(file: string, options?: execa.Options): execa.ExecaChildProcess;
-	node(file: string, options?: execa.Options<null>): execa.ExecaChildProcess<Buffer>;
 };
 
 export = execa;
diff --git a/index.js b/index.js
index db4b85f..4c28cc0 100644
--- a/index.js
+++ b/index.js
@@ -520,30 +520,3 @@ module.exports.commandSync = (command, options) => {
 	const [file, ...args] = parseCommand(command);
 	return execa.sync(file, args, options);
 };
-
-module.exports.node = (scriptPath, args, options) => {
-	if (args && !Array.isArray(args) && typeof args === 'object') {
-		options = args;
-		args = [];
-	}
-
-	const stdioOption = stdio.node(options);
-	options = options || {};
-
-	return execa(
-		options.nodePath || process.execPath,
-		[
-			...(options.nodeArguments || process.execArgv),
-			scriptPath,
-			...(Array.isArray(args) ? args : [])
-		],
-		{
-			...options,
-			stdin: undefined,
-			stdout: undefined,
-			stderr: undefined,
-			stdio: stdioOption,
-			shell: false
-		}
-	);
-};
diff --git a/index.test-d.ts b/index.test-d.ts
index 591ad5e..a435ef8 100644
--- a/index.test-d.ts
+++ b/index.test-d.ts
@@ -166,16 +166,3 @@ expectType<ExecaSyncReturnValue<string>>(execa.commandSync('unicorns', {encoding
 expectType<ExecaSyncReturnValue<Buffer>>(execa.commandSync('unicorns', {encoding: null}));
 expectType<ExecaSyncReturnValue<string>>(execa.commandSync('unicorns foo', {encoding: 'utf8'}));
 expectType<ExecaSyncReturnValue<Buffer>>(execa.commandSync('unicorns foo', {encoding: null}));
-
-expectType<ExecaChildProcess<string>>(execa.node('unicorns'));
-expectType<ExecaReturnValue<string>>(await execa.node('unicorns'));
-expectType<ExecaReturnValue<string>>(
-	await execa.node('unicorns', {encoding: 'utf8'})
-);
-expectType<ExecaReturnValue<Buffer>>(await execa.node('unicorns', {encoding: null}));
-expectType<ExecaReturnValue<string>>(
-	await execa.node('unicorns', ['foo'], {encoding: 'utf8'})
-);
-expectType<ExecaReturnValue<Buffer>>(
-	await execa.node('unicorns', ['foo'], {encoding: null})
-);
diff --git a/lib/stdio.js b/lib/stdio.js
index d9f5458..5b4cb9e 100644
--- a/lib/stdio.js
+++ b/lib/stdio.js
@@ -3,7 +3,7 @@ const alias = ['stdin', 'stdout', 'stderr'];
 
 const hasAlias = opts => alias.some(x => Boolean(opts[x]));
 
-const stdio = opts => {
+module.exports = opts => {
 	if (!opts) {
 		return;
 	}
@@ -39,23 +39,3 @@ const stdio = opts => {
 
 	return result;
 };
-
-module.exports = stdio;
-
-module.exports.node = opts => {
-	const defaultOption = 'pipe';
-
-	let stdioOption = stdio(opts || {stdio: defaultOption});
-
-	if (typeof stdioOption === 'string') {
-		stdioOption = [...new Array(3)].fill(stdioOption);
-	} else if (Array.isArray(stdioOption)) {
-		stdioOption = stdioOption.map((channel = defaultOption) => channel);
-	}
-
-	if (!stdioOption.includes('ipc')) {
-		stdioOption.push('ipc');
-	}
-
-	return stdioOption;
-};
diff --git a/readme.md b/readme.md
index e0e8571..5a27204 100644
--- a/readme.md
+++ b/readme.md
@@ -184,15 +184,6 @@ Same as [`execa.command()`](#execacommand-command-options) but synchronous.
 
 Returns or throws a [`childProcessResult`](#childProcessResult).
 
-### execa.node(scriptPath, [arguments], [options])
-
-Execute a Node.js script as a child process.
-
-Same as `execa('node', [file, ...arguments], options)` except (like [`child_process#fork()`](https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options)):
-  - the [`nodePath`](#nodepath-for-node-only) and [`nodeArguments`](#nodearguments-for-node-only) options can be used
-  - the [`shell`](#shell) option cannot be used 
-  - an extra channel [`ipc`](https://nodejs.org/api/child_process.html#child_process_options_stdio) is passed to [`stdio`](#stdio)
-
 ### childProcessResult
 
 Type: `object`
@@ -447,19 +438,6 @@ Default: `false`
 
 If `true`, no quoting or escaping of arguments is done on Windows. Ignored on other platforms. This is set to `true` automatically when the `shell` option is `true`.
 
-#### nodePath *(for `.node()` only)*
-
-Type: `string`<br>
-Default: [`process.execPath`](https://nodejs.org/api/process.html#process_process_execpath)
-
-Node.js executable used to create the child process.
-
-#### nodeArguments *(for `.node()` only)*
-
-Type: `string[]`<br>
-Default: [`process.execArgv`](https://nodejs.org/api/process.html#process_process_execargv)
-
-List of string arguments passed to the Node.js executable.
 
 ## Tips
 
diff --git a/test/test.js b/test.js
similarity index 93%
rename from test/test.js
rename to test.js
index 613ddec..18bee8c 100644
--- a/test/test.js
+++ b/test.js
@@ -7,7 +7,7 @@ import getStream from 'get-stream';
 import isRunning from 'is-running';
 import tempfile from 'tempfile';
 import pEvent from 'p-event';
-import execa from '..';
+import execa from '.';
 
 process.env.PATH = path.join(__dirname, 'fixtures') + path.delimiter + process.env.PATH;
 process.env.FOO = 'foo';
@@ -87,13 +87,13 @@ test('stdout/stderr/all on process errors, in sync mode', t => {
 
 test('pass `stdout` to a file descriptor', async t => {
 	const file = tempfile('.txt');
-	await execa('test/fixtures/noop', ['foo bar'], {stdout: fs.openSync(file, 'w')});
+	await execa('fixtures/noop', ['foo bar'], {stdout: fs.openSync(file, 'w')});
 	t.is(fs.readFileSync(file, 'utf8'), 'foo bar\n');
 });
 
 test('pass `stderr` to a file descriptor', async t => {
 	const file = tempfile('.txt');
-	await execa('test/fixtures/noop-err', ['foo bar'], {stderr: fs.openSync(file, 'w')});
+	await execa('fixtures/noop-err', ['foo bar'], {stderr: fs.openSync(file, 'w')});
 	t.is(fs.readFileSync(file, 'utf8'), 'foo bar\n');
 });
 
@@ -119,7 +119,7 @@ test('skip throwing when using reject option in sync mode', t => {
 });
 
 test('kill("SIGKILL") should terminate cleanly', async t => {
-	const subprocess = execa('node', ['./test/fixtures/no-killable'], {stdio: ['ipc']});
+	const subprocess = execa('node', ['fixtures/no-killable'], {stdio: ['ipc']});
 	await pEvent(subprocess, 'message');
 
 	subprocess.kill('SIGKILL');
@@ -132,7 +132,7 @@ test('kill("SIGKILL") should terminate cleanly', async t => {
 // Therefore, this feature and those tests do not make sense on Windows.
 if (process.platform !== 'win32') {
 	test('`forceKillAfterTimeout: false` should not kill after a timeout', async t => {
-		const subprocess = execa('node', ['./test/fixtures/no-killable'], {stdio: ['ipc']});
+		const subprocess = execa('node', ['fixtures/no-killable'], {stdio: ['ipc']});
 		await pEvent(subprocess, 'message');
 
 		subprocess.kill('SIGTERM', {forceKillAfterTimeout: false});
@@ -142,7 +142,7 @@ if (process.platform !== 'win32') {
 	});
 
 	test('`forceKillAfterTimeout: number` should kill after a timeout', async t => {
-		const subprocess = execa('node', ['./test/fixtures/no-killable'], {stdio: ['ipc']});
+		const subprocess = execa('node', ['fixtures/no-killable'], {stdio: ['ipc']});
 		await pEvent(subprocess, 'message');
 
 		subprocess.kill('SIGTERM', {forceKillAfterTimeout: 50});
@@ -152,7 +152,7 @@ if (process.platform !== 'win32') {
 	});
 
 	test('`forceKillAfterTimeout: true` should kill after a timeout', async t => {
-		const subprocess = execa('node', ['./test/fixtures/no-killable'], {stdio: ['ipc']});
+		const subprocess = execa('node', ['fixtures/no-killable'], {stdio: ['ipc']});
 		await pEvent(subprocess, 'message');
 
 		subprocess.kill('SIGTERM', {forceKillAfterTimeout: true});
@@ -162,7 +162,7 @@ if (process.platform !== 'win32') {
 	});
 
 	test('kill() with no arguments should kill after a timeout', async t => {
-		const subprocess = execa('node', ['./test/fixtures/no-killable'], {stdio: ['ipc']});
+		const subprocess = execa('node', ['fixtures/no-killable'], {stdio: ['ipc']});
 		await pEvent(subprocess, 'message');
 
 		subprocess.kill();
@@ -382,7 +382,7 @@ test('execa() returns code and failed properties', async t => {
 });
 
 test('use relative path with \'..\' chars', async t => {
-	const pathViaParentDir = path.join('..', path.basename(path.dirname(__dirname)), 'test', 'fixtures', 'noop');
+	const pathViaParentDir = path.join('..', path.basename(__dirname), 'fixtures', 'noop');
 	const {stdout} = await execa(pathViaParentDir, ['foo']);
 	t.is(stdout, 'foo');
 });
@@ -623,13 +623,13 @@ test('do not extend environment with `extendEnv: false`', async t => {
 });
 
 test('can use `options.shell: true`', async t => {
-	const {stdout} = await execa('node test/fixtures/noop foo', {shell: true});
+	const {stdout} = await execa('node fixtures/noop foo', {shell: true});
 	t.is(stdout, 'foo');
 });
 
 test('can use `options.shell: string`', async t => {
 	const shell = process.platform === 'win32' ? 'cmd.exe' : '/bin/bash';
-	const {stdout} = await execa('node test/fixtures/noop foo', {shell});
+	const {stdout} = await execa('node fixtures/noop foo', {shell});
 	t.is(stdout, 'foo');
 });
 
@@ -777,7 +777,7 @@ test('calling cancel method twice should show the same behaviour as calling it o
 	t.true(subprocess.killed);
 });
 
-test('calling cancel method on a successfully completed process does not make result.isCanceled true', async t => {
+test('calling cancel method on a successfuly completed process does not make result.isCanceled true', async t => {
 	const subprocess = execa('noop');
 	const {isCanceled} = await subprocess;
 	subprocess.cancel();
@@ -792,46 +792,46 @@ test('calling cancel method on a process which has been killed does not make err
 });
 
 test('allow commands with spaces and no array arguments', async t => {
-	const {stdout} = await execa('command with space');
+	const {stdout} = await execa('./fixtures/command with space');
 	t.is(stdout, '');
 });
 
 test('allow commands with spaces and array arguments', async t => {
-	const {stdout} = await execa('command with space', ['foo', 'bar']);
+	const {stdout} = await execa('./fixtures/command with space', ['foo', 'bar']);
 	t.is(stdout, 'foo\nbar');
 });
 
 test('execa.command()', async t => {
-	const {stdout} = await execa.command('node test/fixtures/echo foo bar');
+	const {stdout} = await execa.command('node fixtures/echo foo bar');
 	t.is(stdout, 'foo\nbar');
 });
 
 test('execa.command() ignores consecutive spaces', async t => {
-	const {stdout} = await execa.command('node test/fixtures/echo foo    bar');
+	const {stdout} = await execa.command('node fixtures/echo foo    bar');
 	t.is(stdout, 'foo\nbar');
 });
 
 test('execa.command() allows escaping spaces in commands', async t => {
-	const {stdout} = await execa.command('command\\ with\\ space foo bar');
+	const {stdout} = await execa.command('./fixtures/command\\ with\\ space foo bar');
 	t.is(stdout, 'foo\nbar');
 });
 
 test('execa.command() allows escaping spaces in arguments', async t => {
-	const {stdout} = await execa.command('node test/fixtures/echo foo\\ bar');
+	const {stdout} = await execa.command('node fixtures/echo foo\\ bar');
 	t.is(stdout, 'foo bar');
 });
 
 test('execa.command() escapes other whitespaces', async t => {
-	const {stdout} = await execa.command('node test/fixtures/echo foo\tbar');
+	const {stdout} = await execa.command('node fixtures/echo foo\tbar');
 	t.is(stdout, 'foo\tbar');
 });
 
 test('execa.command() trims', async t => {
-	const {stdout} = await execa.command('  node test/fixtures/echo foo bar  ');
+	const {stdout} = await execa.command('  node fixtures/echo foo bar  ');
 	t.is(stdout, 'foo\nbar');
 });
 
 test('execa.command.sync()', t => {
-	const {stdout} = execa.commandSync('node test/fixtures/echo foo bar');
+	const {stdout} = execa.commandSync('node fixtures/echo foo bar');
 	t.is(stdout, 'foo\nbar');
 });
diff --git a/test/fixtures/detach b/test/fixtures/detach
deleted file mode 100755
index 80f8980..0000000
--- a/test/fixtures/detach
+++ /dev/null
@@ -1,8 +0,0 @@
-#!/usr/bin/env node
-'use strict';
-
-const execa = require('../..');
-
-const subprocess = execa('node', ['./test/fixtures/forever'], {detached: true});
-console.log(subprocess.pid);
-process.exit();
diff --git a/test/fixtures/echo b/test/fixtures/echo
deleted file mode 100755
index e9baf7e..0000000
--- a/test/fixtures/echo
+++ /dev/null
@@ -1,3 +0,0 @@
-#!/usr/bin/env node
-'use strict';
-console.log(process.argv.slice(2).join('\n'));
diff --git a/test/fixtures/hello.sh b/test/fixtures/hello.sh
deleted file mode 100755
index ff0e12e..0000000
--- a/test/fixtures/hello.sh
+++ /dev/null
@@ -1 +0,0 @@
-echo Hello World
diff --git a/test/fixtures/send b/test/fixtures/send
deleted file mode 100755
index c215df6..0000000
--- a/test/fixtures/send
+++ /dev/null
@@ -1,9 +0,0 @@
-#!/usr/bin/env node
-'use strict';
-process.on('message', message => {
-	if (message === 'ping') {
-		process.send('pong');
-	} else {
-		throw new Error('Receive wrong message');
-	}
-});
diff --git a/test/node.js b/test/node.js
deleted file mode 100644
index c6ff30d..0000000
--- a/test/node.js
+++ /dev/null
@@ -1,46 +0,0 @@
-import test from 'ava';
-import pEvent from 'p-event';
-import path from 'path';
-import execa from '..';
-
-process.env.PATH = path.join(__dirname, 'fixtures') + path.delimiter + process.env.PATH;
-
-test('node()', async t => {
-	const {exitCode} = await execa.node('test/fixtures/noop');
-	t.is(exitCode, 0);
-});
-
-test('node pipe stdout', async t => {
-	const {stdout} = await execa.node('test/fixtures/noop', ['foo'], {
-		stdout: 'pipe'
-	});
-
-	t.is(stdout, 'foo');
-});
-
-test('node correctly use nodePath', async t => {
-	const {stdout} = await execa.node(process.platform === 'win32' ? 'hello.cmd' : 'hello.sh', {
-		stdout: 'pipe',
-		nodePath: process.platform === 'win32' ? 'cmd.exe' : 'bash',
-		nodeArguments: process.platform === 'win32' ? ['/c'] : []
-	});
-
-	t.is(stdout, 'Hello World');
-});
-
-test('node pass on nodeArguments', async t => {
-	const {stdout} = await execa.node('console.log("foo")', {
-		stdout: 'pipe',
-		nodeArguments: ['-e']
-	});
-
-	t.is(stdout, 'foo');
-});
-
-test('node\'s forked script has a communication channel', async t => {
-	const subprocess = execa.node('test/fixtures/send');
-	subprocess.send('ping');
-
-	const message = await pEvent(subprocess, 'message');
-	t.is(message, 'pong');
-});
diff --git a/test/stdio.js b/test/stdio.js
index a9ccb03..e02a329 100644
--- a/test/stdio.js
+++ b/test/stdio.js
@@ -4,69 +4,46 @@ import stdio from '../lib/stdio';
 
 util.inspect.styles.name = 'magenta';
 
-function createMacro(func) {
-	const macro = (t, input, expected) => {
-		if (expected instanceof Error) {
-			t.throws(() => {
-				stdio(input);
-			}, expected.message);
-			return;
-		}
-
-		const result = func(input);
-
-		if (typeof expected === 'object' && expected !== null) {
-			t.deepEqual(result, expected);
-		} else {
-			t.is(result, expected);
-		}
-	};
-
-	macro.title = (providedTitle, input) => `${func.name} ${(providedTitle || util.inspect(input, {colors: true}))}`;
-
-	return macro;
+function macro(t, input, expected) {
+	if (expected instanceof Error) {
+		t.throws(() => stdio(input), expected.message);
+		return;
+	}
+
+	const result = stdio(input);
+
+	if (typeof expected === 'object' && expected !== null) {
+		t.deepEqual(result, expected);
+	} else {
+		t.is(result, expected);
+	}
 }
 
-const stdioMacro = createMacro(stdio);
-
-test(stdioMacro, undefined, undefined);
-test(stdioMacro, null, undefined);
-
-test(stdioMacro, {stdio: 'inherit'}, 'inherit');
-test(stdioMacro, {stdio: 'pipe'}, 'pipe');
-test(stdioMacro, {stdio: 'ignore'}, 'ignore');
-test(stdioMacro, {stdio: [0, 1, 2]}, [0, 1, 2]);
-
-test(stdioMacro, {}, [undefined, undefined, undefined]);
-test(stdioMacro, {stdio: []}, [undefined, undefined, undefined]);
-test(stdioMacro, {stdin: 'pipe'}, ['pipe', undefined, undefined]);
-test(stdioMacro, {stdout: 'ignore'}, [undefined, 'ignore', undefined]);
-test(stdioMacro, {stderr: 'inherit'}, [undefined, undefined, 'inherit']);
-test(stdioMacro, {stdin: 'pipe', stdout: 'ignore', stderr: 'inherit'}, ['pipe', 'ignore', 'inherit']);
-test(stdioMacro, {stdin: 'pipe', stdout: 'ignore'}, ['pipe', 'ignore', undefined]);
-test(stdioMacro, {stdin: 'pipe', stderr: 'inherit'}, ['pipe', undefined, 'inherit']);
-test(stdioMacro, {stdout: 'ignore', stderr: 'inherit'}, [undefined, 'ignore', 'inherit']);
-test(stdioMacro, {stdin: 0, stdout: 1, stderr: 2}, [0, 1, 2]);
-test(stdioMacro, {stdin: 0, stdout: 1}, [0, 1, undefined]);
-test(stdioMacro, {stdin: 0, stderr: 2}, [0, undefined, 2]);
-test(stdioMacro, {stdout: 1, stderr: 2}, [undefined, 1, 2]);
-
-test(stdioMacro, {stdio: {foo: 'bar'}}, new TypeError('Expected `stdio` to be of type `string` or `Array`, got `object`'));
-
-test(stdioMacro, {stdin: 'inherit', stdio: 'pipe'}, new Error('It\'s not possible to provide `stdio` in combination with one of `stdin`, `stdout`, `stderr`'));
-test(stdioMacro, {stdin: 'inherit', stdio: ['pipe']}, new Error('It\'s not possible to provide `stdio` in combination with one of `stdin`, `stdout`, `stderr`'));
-test(stdioMacro, {stdin: 'inherit', stdio: [undefined, 'pipe']}, new Error('It\'s not possible to provide `stdio` in combination with one of `stdin`, `stdout`, `stderr`'));
-
-const forkMacro = createMacro(stdio.node);
-
-test(forkMacro, undefined, ['pipe', 'pipe', 'pipe', 'ipc']);
-test(forkMacro, {stdio: 'ignore'}, ['ignore', 'ignore', 'ignore', 'ipc']);
-test(forkMacro, {stdio: [0, 1, 2]}, [0, 1, 2, 'ipc']);
-test(forkMacro, {stdio: [0, 1, 2, 3]}, [0, 1, 2, 3, 'ipc']);
-test(forkMacro, {stdio: [0, 1, 2, 'ipc']}, [0, 1, 2, 'ipc']);
-
-test(forkMacro, {stdout: 'ignore'}, ['pipe', 'ignore', 'pipe', 'ipc']);
-test(forkMacro, {stdout: 'ignore', stderr: 'ignore'}, ['pipe', 'ignore', 'ignore', 'ipc']);
-
-test(forkMacro, {stdio: {foo: 'bar'}}, new TypeError('Expected `stdio` to be of type `string` or `Array`, got `object`'));
-test(forkMacro, {stdin: 'inherit', stdio: 'pipe'}, new Error('It\'s not possible to provide `stdio` in combination with one of `stdin`, `stdout`, `stderr`'));
+macro.title = (providedTitle, input) => providedTitle || util.inspect(input, {colors: true});
+
+test(macro, undefined, undefined);
+
+test(macro, {stdio: 'inherit'}, 'inherit');
+test(macro, {stdio: 'pipe'}, 'pipe');
+test(macro, {stdio: 'ignore'}, 'ignore');
+test(macro, {stdio: [0, 1, 2]}, [0, 1, 2]);
+
+test(macro, {}, [undefined, undefined, undefined]);
+test(macro, {stdio: []}, [undefined, undefined, undefined]);
+test(macro, {stdin: 'pipe'}, ['pipe', undefined, undefined]);
+test(macro, {stdout: 'ignore'}, [undefined, 'ignore', undefined]);
+test(macro, {stderr: 'inherit'}, [undefined, undefined, 'inherit']);
+test(macro, {stdin: 'pipe', stdout: 'ignore', stderr: 'inherit'}, ['pipe', 'ignore', 'inherit']);
+test(macro, {stdin: 'pipe', stdout: 'ignore'}, ['pipe', 'ignore', undefined]);
+test(macro, {stdin: 'pipe', stderr: 'inherit'}, ['pipe', undefined, 'inherit']);
+test(macro, {stdout: 'ignore', stderr: 'inherit'}, [undefined, 'ignore', 'inherit']);
+test(macro, {stdin: 0, stdout: 1, stderr: 2}, [0, 1, 2]);
+test(macro, {stdin: 0, stdout: 1}, [0, 1, undefined]);
+test(macro, {stdin: 0, stderr: 2}, [0, undefined, 2]);
+test(macro, {stdout: 1, stderr: 2}, [undefined, 1, 2]);
+
+test(macro, {stdio: {foo: 'bar'}}, new TypeError('Expected `stdio` to be of type `string` or `Array`, got `object`'));
+
+test(macro, {stdin: 'inherit', stdio: 'pipe'}, new Error('It\'s not possible to provide `stdio` in combination with one of `stdin`, `stdout`, `stderr`'));
+test(macro, {stdin: 'inherit', stdio: ['pipe']}, new Error('It\'s not possible to provide `stdio` in combination with one of `stdin`, `stdout`, `stderr`'));
+test(macro, {stdin: 'inherit', stdio: [undefined, 'pipe']}, new Error('It\'s not possible to provide `stdio` in combination with one of `stdin`, `stdout`, `stderr`'));
