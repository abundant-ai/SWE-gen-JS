diff --git a/changelog_unreleased/javascript/18037.md b/changelog_unreleased/javascript/18037.md
index 51b53126a..4aa44d960 100644
--- a/changelog_unreleased/javascript/18037.md
+++ b/changelog_unreleased/javascript/18037.md
@@ -8,28 +8,13 @@ require(
 "foo"
 );
 
-call(
-// Comment
-"foo"
-);
-
 // Prettier stable
 require(// Comment
 "foo");
 
-call(
-  // Comment
-  "foo",
-);
-
 // Prettier main
 require(
   // Comment
   "foo",
 );
-
-call(
-  // Comment
-  "foo",
-);
 ```
diff --git a/changelog_unreleased/typescript/18035.md b/changelog_unreleased/typescript/18035.md
new file mode 100644
index 000000000..356f84530
--- /dev/null
+++ b/changelog_unreleased/typescript/18035.md
@@ -0,0 +1,20 @@
+#### Improve CommonJS module `require()` with comments (#18035 by @fisker)
+
+<!-- prettier-ignore -->
+```tsx
+// Input
+import foo = require(
+// Comment
+"foo"
+);
+
+// Prettier stable
+import foo = require(// Comment
+"foo");
+
+// Prettier main
+import foo = require(
+  // Comment
+  "foo"
+);
+```
diff --git a/src/language-js/print/call-arguments.js b/src/language-js/print/call-arguments.js
index 55b73043c..a949e08a3 100644
--- a/src/language-js/print/call-arguments.js
+++ b/src/language-js/print/call-arguments.js
@@ -37,6 +37,14 @@ import {
 } from "../utils/index.js";
 import { isConciselyPrintedArray } from "./array.js";
 
+/*
+- `NewExpression`
+- `ImportExpression`
+- `OptionalCallExpression`
+- `CallExpression`
+- `TSImportType` (TypeScript)
+- `TSExternalModuleReference` (TypeScript)
+*/
 function printCallArguments(path, options, print) {
   const { node } = path;
 
@@ -84,6 +92,7 @@ function printCallArguments(path, options, print) {
     // Dynamic imports cannot have trailing commas
     node.type !== "ImportExpression" &&
     node.type !== "TSImportType" &&
+    node.type !== "TSExternalModuleReference" &&
     shouldPrintComma(options, "all")
       ? ","
       : "";
diff --git a/src/language-js/print/call-expression.js b/src/language-js/print/call-expression.js
index 781345762..dcc2ad541 100644
--- a/src/language-js/print/call-expression.js
+++ b/src/language-js/print/call-expression.js
@@ -21,6 +21,7 @@ import { printOptionalToken } from "./misc.js";
 - `OptionalCallExpression`
 - `CallExpression`
 - `TSImportType` (TypeScript)
+- `TSExternalModuleReference` (TypeScript)
 */
 function printCallExpression(path, options, print) {
   const { node } = path;
@@ -67,13 +68,15 @@ function printCallExpression(path, options, print) {
     }
   }
 
-  const isDynamicImport =
-    node.type === "ImportExpression" || node.type === "TSImportType";
+  const isDynamicImportLike =
+    node.type === "ImportExpression" ||
+    node.type === "TSImportType" ||
+    node.type === "TSExternalModuleReference";
 
   // We detect calls on member lookups and possibly print them in a
   // special chain format. See `printMemberChain` for more info.
   if (
-    !isDynamicImport &&
+    !isDynamicImportLike &&
     !isNewExpression &&
     isMemberish(node.callee) &&
     !path.call(
@@ -95,7 +98,7 @@ function printCallExpression(path, options, print) {
 
   // We group here when the callee is itself a call expression.
   // See `isLongCurriedCallExpression` for more info.
-  if (isDynamicImport || isCallExpression(node.callee)) {
+  if (isDynamicImportLike || isCallExpression(node.callee)) {
     return group(contents);
   }
 
@@ -109,6 +112,10 @@ function printCallee(path, print) {
     return `import${node.phase ? `.${node.phase}` : ""}`;
   }
 
+  if (node.type === "TSExternalModuleReference") {
+    return "require";
+  }
+
   return print("callee");
 }
 
@@ -128,6 +135,8 @@ function isSimpleModuleImport(path) {
         node.type === "ImportExpression" ||
         // `type foo = import("foo")`
         node.type === "TSImportType" ||
+        // `import type A = require("foo")`
+        node.type === "TSExternalModuleReference" ||
         // `require("foo")`
         // `require.resolve("foo")`
         // `require.resolve.paths("foo")`
diff --git a/src/language-js/print/typescript.js b/src/language-js/print/typescript.js
index 57d02b9a9..01010ff43 100644
--- a/src/language-js/print/typescript.js
+++ b/src/language-js/print/typescript.js
@@ -278,7 +278,7 @@ function printTypescript(path, options, print) {
         options.semi ? ";" : "",
       ];
     case "TSExternalModuleReference":
-      return ["require(", print("expression"), ")"];
+      return printCallExpression(path, options, print);
     case "TSModuleDeclaration": {
       const parts = [];
       const { parent } = path;
diff --git a/src/language-js/utils/index.js b/src/language-js/utils/index.js
index b3c566822..c6644e2cd 100644
--- a/src/language-js/utils/index.js
+++ b/src/language-js/utils/index.js
@@ -855,7 +855,7 @@ function getFunctionParameters(node) {
 function iterateFunctionParametersPath(path, iteratee) {
   const { node } = path;
   let index = 0;
-  const callback = (childPath) => iteratee(childPath, index++);
+  const callback = () => iteratee(path, index++);
   if (node.this) {
     path.call(callback, "this");
   }
@@ -877,13 +877,17 @@ function getCallArguments(node) {
     return getCallArguments(node.expression);
   }
 
-  let args = node.arguments;
+  let args;
   if (node.type === "ImportExpression" || node.type === "TSImportType") {
     args = [node.type === "ImportExpression" ? node.source : node.argument];
 
     if (node.options) {
       args.push(node.options);
     }
+  } else if (node.type === "TSExternalModuleReference") {
+    args = [node.expression];
+  } else {
+    args = node.arguments;
   }
 
   callArgumentsCache.set(node, args);
@@ -902,13 +906,15 @@ function iterateCallArgumentsPath(path, iteratee) {
 
   if (node.type === "ImportExpression" || node.type === "TSImportType") {
     path.call(
-      (sourcePath) => iteratee(sourcePath, 0),
+      () => iteratee(path, 0),
       node.type === "ImportExpression" ? "source" : "argument",
     );
 
     if (node.options) {
-      path.call((sourcePath) => iteratee(sourcePath, 1), "options");
+      path.call(() => iteratee(path, 1), "options");
     }
+  } else if (node.type === "TSExternalModuleReference") {
+    path.call(() => iteratee(path, 0), "expression");
   } else {
     path.each(iteratee, "arguments");
   }
@@ -932,15 +938,21 @@ function getCallArgumentSelector(node, index) {
       return [...selectors, "options"];
     }
     throw new RangeError("Invalid argument index");
+  } else if (node.type === "TSExternalModuleReference") {
+    if (index === 0 || index === -1) {
+      return [...selectors, "expression"];
+    }
+  } else {
+    if (index < 0) {
+      index = node.arguments.length + index;
+    }
+    if (index >= 0 && index < node.arguments.length) {
+      return [...selectors, "arguments", index];
+    }
   }
-  if (index < 0) {
-    index = node.arguments.length + index;
-  }
-  /* c8 ignore next 3 */
-  if (index < 0 || index >= node.arguments.length) {
-    throw new RangeError("Invalid argument index");
-  }
-  return [...selectors, "arguments", index];
+
+  /* c8 ignore next */
+  throw new RangeError("Invalid argument index");
 }
 
 function isPrettierIgnoreComment(comment) {
