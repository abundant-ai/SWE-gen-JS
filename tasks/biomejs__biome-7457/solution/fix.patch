diff --git a/.changeset/empty-paths-occur.md b/.changeset/empty-paths-occur.md
new file mode 100644
index 0000000000..8b3e3a9378
--- /dev/null
+++ b/.changeset/empty-paths-occur.md
@@ -0,0 +1,71 @@
+---
+"@biomejs/biome": patch
+---
+
+Added `style` and `requireForObjectLiteral` options to the lint rule [`useConsistentArrowReturn`](https://biomejs.dev/linter/rules/use-consistent-arrow-return/).
+
+This rule enforces a consistent return style for arrow functions. It can be configured with the following options:
+
+  - `style`: (default: `asNeeded`)
+    - `always`: enforces that arrow functions always have a block body.
+    - `never`: enforces that arrow functions never have a block body, when possible.
+    - `asNeeded`: enforces that arrow functions have a block body only when necessary (e.g. for object literals).
+
+#### `style: "always"`
+
+Invalid:
+
+```js
+const f = () => 1;
+```
+
+Valid:
+
+```js
+const f = () => {
+  return 1;
+};
+```
+
+#### `style: "never"`
+
+Invalid:
+
+```js
+const f = () => {
+  return 1;
+};
+```
+
+Valid:
+
+```js
+const f = () => 1;
+```
+
+#### `style: "asNeeded"`
+
+Invalid:
+
+```js
+const f = () => {
+  return 1;
+};
+```
+
+Valid:
+
+```js
+const f = () => 1;
+```
+
+#### `style: "asNeeded"` and `requireForObjectLiteral: true`
+
+Valid:
+
+```js
+const f = () => {
+  return { a: 1 }
+};
+```
+
diff --git a/crates/biome_js_analyze/src/lint/nursery/use_consistent_arrow_return.rs b/crates/biome_js_analyze/src/lint/nursery/use_consistent_arrow_return.rs
index c870ee27bd..973aa15849 100644
--- a/crates/biome_js_analyze/src/lint/nursery/use_consistent_arrow_return.rs
+++ b/crates/biome_js_analyze/src/lint/nursery/use_consistent_arrow_return.rs
@@ -6,11 +6,13 @@ use biome_console::markup;
 use biome_diagnostics::Severity;
 use biome_js_factory::make;
 use biome_js_syntax::{
-    AnyJsExpression, AnyJsFunctionBody, JsArrowFunctionExpression, JsFunctionBody,
-    JsReturnStatement,
+    AnyJsExpression, AnyJsFunctionBody, AnyJsStatement, JsArrowFunctionExpression, JsFunctionBody,
+    JsReturnStatement, T,
 };
 use biome_rowan::{AstNode, AstNodeList, BatchMutationExt};
-use biome_rule_options::use_consistent_arrow_return::UseConsistentArrowReturnOptions;
+use biome_rule_options::use_consistent_arrow_return::{
+    UseConsistentArrowReturnOptions, UseConsistentArrowReturnStyle,
+};
 
 declare_lint_rule! {
     /// Enforce consistent arrow function bodies.
@@ -58,67 +60,193 @@ declare_lint_rule! {
     }
 }
 
+pub enum State {
+    AddBraces(AnyJsExpression),
+    RemoveBraces(JsFunctionBody),
+}
+
 impl Rule for UseConsistentArrowReturn {
     type Query = Ast<JsArrowFunctionExpression>;
-    type State = JsFunctionBody;
+    type State = State;
     type Signals = Option<Self::State>;
     type Options = UseConsistentArrowReturnOptions;
 
     fn run(ctx: &RuleContext<Self>) -> Self::Signals {
         let arrow = ctx.query();
-        let body = JsFunctionBody::cast(arrow.body().ok()?.into_syntax())?;
+        let options = ctx.options();
+        let body = arrow.body().ok()?;
 
-        if !body.directives().is_empty() || body.syntax().has_comments_descendants() {
-            return None;
-        }
+        match options.style {
+            UseConsistentArrowReturnStyle::Always => {
+                if let AnyJsFunctionBody::AnyJsExpression(expr) = body {
+                    if expr.syntax().has_comments_descendants() {
+                        return None;
+                    }
+                    return Some(State::AddBraces(expr));
+                }
+            }
+            UseConsistentArrowReturnStyle::Never => {
+                if let AnyJsFunctionBody::JsFunctionBody(body) = body {
+                    if !body.directives().is_empty() || body.syntax().has_comments_descendants() {
+                        return None;
+                    }
 
-        if body.statements().len() == 1 {
-            let first_statement = body.statements().iter().next()?;
-            if let Some(return_statement) = JsReturnStatement::cast(first_statement.into_syntax())
-                && return_statement.argument().is_some()
-            {
-                return Some(body);
+                    if body.statements().len() == 1 {
+                        let first_statement = body.statements().iter().next()?;
+                        if let Some(return_statement) =
+                            JsReturnStatement::cast(first_statement.into_syntax())
+                            && return_statement.argument().is_some()
+                        {
+                            return Some(State::RemoveBraces(body));
+                        }
+                    }
+                }
             }
+            UseConsistentArrowReturnStyle::AsNeeded => match body {
+                AnyJsFunctionBody::AnyJsExpression(expr) => {
+                    if options.require_for_object_literal {
+                        let mut expression = expr.clone();
+                        if let Some(paren_expr) = expression.as_js_parenthesized_expression() {
+                            expression = paren_expr.expression().ok()?;
+                        }
+
+                        if expression.as_js_object_expression().is_some() {
+                            if expr.syntax().has_comments_descendants() {
+                                return None;
+                            }
+                            return Some(State::AddBraces(expr));
+                        }
+                    }
+                }
+                AnyJsFunctionBody::JsFunctionBody(body) => {
+                    if !body.directives().is_empty() || body.syntax().has_comments_descendants() {
+                        return None;
+                    }
+
+                    if body.statements().len() == 1 {
+                        let first_statement = body.statements().iter().next()?;
+                        if let Some(return_statement) =
+                            JsReturnStatement::cast(first_statement.into_syntax())
+                            && let Some(arg) = return_statement.argument()
+                        {
+                            if arg.as_js_object_expression().is_some()
+                                && options.require_for_object_literal
+                            {
+                                return None;
+                            }
+                            return Some(State::RemoveBraces(body));
+                        }
+                    }
+                }
+            },
         }
 
         None
     }
 
-    fn diagnostic(ctx: &RuleContext<Self>, _state: &Self::State) -> Option<RuleDiagnostic> {
+    fn diagnostic(ctx: &RuleContext<Self>, state: &Self::State) -> Option<RuleDiagnostic> {
         let node = ctx.query();
-        Some(RuleDiagnostic::new(
-            rule_category!(),
-            node.range(),
-            markup! {
-                "The body of this arrow function contains a single "<Emphasis>"return"</Emphasis> " statement."
-            },
-        ))
+        let diagnostic = match state {
+            State::AddBraces(_) => RuleDiagnostic::new(
+                rule_category!(),
+                node.range(),
+                markup! {
+                    "This arrow function body should be a block statement."
+                },
+            ),
+            State::RemoveBraces(_) => RuleDiagnostic::new(
+                rule_category!(),
+                node.range(),
+                markup! {
+                    "The body of this arrow function contains a single "<Emphasis>"return"</Emphasis>" statement."
+                },
+            ),
+        };
+        Some(diagnostic)
     }
 
-    fn action(ctx: &RuleContext<Self>, body: &Self::State) -> Option<JsRuleAction> {
+    fn action(ctx: &RuleContext<Self>, state: &Self::State) -> Option<JsRuleAction> {
         let mut mutation = ctx.root().begin();
+        let arrow = ctx.query();
 
-        let return_statement = body.statements().iter().next()?;
-        let return_statement = JsReturnStatement::cast(return_statement.into_syntax())?;
-        let return_argument = return_statement.argument()?;
+        match state {
+            State::AddBraces(expr) => {
+                let old_body = arrow.body().ok()?;
+                let expr_to_return = if let Some(paren_expr) = expr.as_js_parenthesized_expression()
+                {
+                    paren_expr.expression().ok()?
+                } else {
+                    expr.clone()
+                };
 
-        let new_body = if needs_parens_in_concise_body(&return_argument) {
-            AnyJsExpression::from(make::parenthesized(return_argument))
-        } else {
-            return_argument
-        };
+                let return_statement =
+                    make::js_return_statement(make::token(T![return]).with_trailing_trivia([(
+                        biome_js_syntax::TriviaPieceKind::Whitespace,
+                        " ",
+                    )]))
+                    .with_argument(expr_to_return)
+                    .with_semicolon_token(make::token(T![;]))
+                    .build();
+
+                let statement = arrow.syntax().ancestors().find_map(AnyJsStatement::cast)?;
+                let mut base_indent = String::new();
+                if let Some(trivia) = statement.syntax().first_leading_trivia() {
+                    for piece in trivia.pieces().rev() {
+                        if piece.is_newline() {
+                            break;
+                        }
+                        if let Some(ws) = piece.as_whitespace() {
+                            base_indent.insert_str(0, ws.text());
+                        }
+                    }
+                }
+
+                let body_indent =
+                    format!("{base_indent}{}", ctx.preferred_indentation().to_string());
+                let body = make::js_function_body(
+                    make::token(T!['{']).with_trailing_trivia([
+                        (biome_js_syntax::TriviaPieceKind::Newline, "\n"),
+                        (biome_js_syntax::TriviaPieceKind::Whitespace, &body_indent),
+                    ]),
+                    make::js_directive_list([]),
+                    make::js_statement_list([AnyJsStatement::from(return_statement)]),
+                    make::token(T!['}']).with_leading_trivia([
+                        (biome_js_syntax::TriviaPieceKind::Newline, "\n"),
+                        (biome_js_syntax::TriviaPieceKind::Whitespace, &base_indent),
+                    ]),
+                );
+                mutation.replace_node(old_body, AnyJsFunctionBody::from(body));
+                Some(JsRuleAction::new(
+                    ctx.metadata().action_category(ctx.category(), ctx.group()),
+                    ctx.metadata().applicability(),
+                    markup! { "Add braces to the arrow function body." }.to_owned(),
+                    mutation,
+                ))
+            }
+            State::RemoveBraces(body) => {
+                let return_statement = body.statements().iter().next()?;
+                let return_statement = JsReturnStatement::cast(return_statement.into_syntax())?;
+                let return_argument = return_statement.argument()?;
 
-        mutation.replace_node(
-            AnyJsFunctionBody::from(body.clone()),
-            AnyJsFunctionBody::AnyJsExpression(new_body),
-        );
-
-        Some(JsRuleAction::new(
-            ctx.metadata().action_category(ctx.category(), ctx.group()),
-            ctx.metadata().applicability(),
-            markup! { "Remove the return statement." }.to_owned(),
-            mutation,
-        ))
+                let new_body = if needs_parens_in_concise_body(&return_argument) {
+                    AnyJsExpression::from(make::parenthesized(return_argument))
+                } else {
+                    return_argument
+                };
+
+                mutation.replace_node(
+                    AnyJsFunctionBody::from(body.clone()),
+                    AnyJsFunctionBody::AnyJsExpression(new_body),
+                );
+
+                Some(JsRuleAction::new(
+                    ctx.metadata().action_category(ctx.category(), ctx.group()),
+                    ctx.metadata().applicability(),
+                    markup! { "Remove the return statement." }.to_owned(),
+                    mutation,
+                ))
+            }
+        }
     }
 }
 
diff --git a/crates/biome_rule_options/src/use_consistent_arrow_return.rs b/crates/biome_rule_options/src/use_consistent_arrow_return.rs
index 11b9278f28..29b8b25c1b 100644
--- a/crates/biome_rule_options/src/use_consistent_arrow_return.rs
+++ b/crates/biome_rule_options/src/use_consistent_arrow_return.rs
@@ -1,6 +1,53 @@
+use biome_deserialize::{
+    DeserializableValidator, DeserializationContext, DeserializationDiagnostic,
+};
 use biome_deserialize_macros::Deserializable;
 use serde::{Deserialize, Serialize};
+
+#[derive(Clone, Debug, Deserialize, Deserializable, Eq, PartialEq, Serialize, Default)]
+#[cfg_attr(feature = "schema", derive(schemars::JsonSchema))]
+#[serde(rename_all = "camelCase")]
+pub enum UseConsistentArrowReturnStyle {
+    /// Enforces no braces where they can be omitted (default).
+    #[default]
+    AsNeeded,
+    /// Enforces braces around the function body.
+    Always,
+    /// Enforces no braces around the function body (constrains arrow functions to the role of returning an expression).
+    Never,
+}
+
+/// Options for the `useConsistentArrowReturn` rule.
 #[derive(Default, Clone, Debug, Deserialize, Deserializable, Eq, PartialEq, Serialize)]
 #[cfg_attr(feature = "schema", derive(schemars::JsonSchema))]
 #[serde(rename_all = "camelCase", deny_unknown_fields, default)]
-pub struct UseConsistentArrowReturnOptions {}
+#[deserializable(with_validator)]
+pub struct UseConsistentArrowReturnOptions {
+    /// The style to enforce for arrow function return statements.
+    pub style: UseConsistentArrowReturnStyle,
+    /// Determines whether the rule enforces a consistent style when the return value is an object literal.
+    ///
+    /// This option is only applicable when used in conjunction with the `asNeeded` option.
+    pub require_for_object_literal: bool,
+}
+
+impl DeserializableValidator for UseConsistentArrowReturnOptions {
+    fn validate(
+        &mut self,
+        ctx: &mut impl DeserializationContext,
+        _name: &str,
+        range: biome_rowan::TextRange,
+    ) -> bool {
+        if self.require_for_object_literal && self.style != UseConsistentArrowReturnStyle::AsNeeded
+        {
+            ctx.report(
+                DeserializationDiagnostic::new(
+                    "`requireForObjectLiteral` can only be used when `style` is `asNeeded`.",
+                )
+                .with_range(range),
+            );
+            return false;
+        }
+        true
+    }
+}
diff --git a/crates/biome_service/src/file_handlers/javascript.rs b/crates/biome_service/src/file_handlers/javascript.rs
index acfd74795e..ca267ca6db 100644
--- a/crates/biome_service/src/file_handlers/javascript.rs
+++ b/crates/biome_service/src/file_handlers/javascript.rs
@@ -275,9 +275,14 @@ impl ServiceLanguage for JsLanguage {
                 QuoteStyle::Double => PreferredQuote::Double,
             })
             .unwrap_or_default();
-        let preferred_indentation = global.languages.javascript.formatter.indent_style.map_or(
-            PreferredIndentation::default(),
-            |indent_style| match indent_style {
+        let preferred_indentation = {
+            let indent_style = global
+                .languages
+                .javascript
+                .formatter
+                .indent_style
+                .unwrap_or_else(|| global.formatter.indent_style.unwrap_or_default());
+            match indent_style {
                 IndentStyle::Tab => PreferredIndentation::Tab,
                 IndentStyle::Space => PreferredIndentation::Spaces(
                     global
@@ -285,11 +290,11 @@ impl ServiceLanguage for JsLanguage {
                         .javascript
                         .formatter
                         .indent_width
-                        .unwrap_or_default()
+                        .unwrap_or_else(|| global.formatter.indent_width.unwrap_or_default())
                         .value(),
                 ),
-            },
-        );
+            }
+        };
 
         let mut configuration = AnalyzerConfiguration::default();
         let mut globals = Vec::new();
diff --git a/crates/biome_test_utils/src/lib.rs b/crates/biome_test_utils/src/lib.rs
index b922c88341..4be5911994 100644
--- a/crates/biome_test_utils/src/lib.rs
+++ b/crates/biome_test_utils/src/lib.rs
@@ -16,7 +16,6 @@ use biome_module_graph::ModuleGraph;
 use biome_package::PackageJson;
 use biome_project_layout::ProjectLayout;
 use biome_rowan::{Direction, Language, SyntaxKind, SyntaxNode, SyntaxSlot};
-use biome_service::configuration::to_analyzer_rules;
 use biome_service::file_handlers::DocumentFileSource;
 use biome_service::projects::Projects;
 use biome_service::settings::{ServiceLanguage, Settings};
@@ -44,7 +43,7 @@ pub fn scripts_from_json(extension: &str, input_code: &str) -> Option<Vec<String
     }
 }
 
-pub fn create_analyzer_options(
+pub fn create_analyzer_options<L: ServiceLanguage>(
     input_file: &Utf8Path,
     diagnostics: &mut Vec<String>,
 ) -> AnalyzerOptions {
@@ -52,7 +51,7 @@ pub fn create_analyzer_options(
     // We allow a test file to configure its rule using a special
     // file with the same name as the test but with extension ".options.json"
     // that configures that specific rule.
-    let mut analyzer_configuration = AnalyzerConfiguration::default()
+    let analyzer_configuration = AnalyzerConfiguration::default()
         .with_preferred_quote(PreferredQuote::Double)
         .with_jsx_runtime(JsxRuntime::Transparent);
     let options_file = input_file.with_extension("options.json");
@@ -74,58 +73,25 @@ pub fn create_analyzer_options(
                 })
                 .collect::<Vec<_>>(),
         );
+
+        options.with_configuration(analyzer_configuration)
     } else {
         let configuration = deserialized.into_deserialized().unwrap_or_default();
-        let mut settings = Settings::default();
-        analyzer_configuration = analyzer_configuration.with_preferred_quote(
-            configuration
-                .javascript
-                .as_ref()
-                .and_then(|js| js.formatter.as_ref())
-                .and_then(|f| {
-                    f.quote_style.map(|quote_style| {
-                        if quote_style.is_double() {
-                            PreferredQuote::Double
-                        } else {
-                            PreferredQuote::Single
-                        }
-                    })
-                })
-                .unwrap_or_default(),
-        );
-
-        use biome_configuration::javascript::JsxRuntime::*;
-        analyzer_configuration = analyzer_configuration.with_jsx_runtime(
-            match configuration
-                .javascript
-                .as_ref()
-                .and_then(|js| js.jsx_runtime)
-                .unwrap_or_default()
-            {
-                ReactClassic => JsxRuntime::ReactClassic,
-                Transparent => JsxRuntime::Transparent,
-            },
-        );
-        analyzer_configuration = analyzer_configuration.with_globals(
-            configuration
-                .javascript
-                .as_ref()
-                .and_then(|js| {
-                    js.globals
-                        .as_ref()
-                        .map(|globals| globals.iter().cloned().collect())
-                })
-                .unwrap_or_default(),
-        );
 
+        let mut settings = Settings::default();
         settings
             .merge_with_configuration(configuration, None)
             .unwrap();
 
-        analyzer_configuration =
-            analyzer_configuration.with_rules(to_analyzer_rules(&settings, input_file));
+        L::resolve_analyzer_options(
+            &settings,
+            &L::lookup_settings(&settings.languages).linter,
+            L::resolve_environment(&settings),
+            &BiomePath::new(input_file),
+            &DocumentFileSource::from_path(input_file),
+            None,
+        )
     }
-    options.with_configuration(analyzer_configuration)
 }
 
 pub fn create_formatting_options<L>(
diff --git a/packages/@biomejs/backend-jsonrpc/src/workspace.ts b/packages/@biomejs/backend-jsonrpc/src/workspace.ts
index df84f856ec..626926c68b 100644
--- a/packages/@biomejs/backend-jsonrpc/src/workspace.ts
+++ b/packages/@biomejs/backend-jsonrpc/src/workspace.ts
@@ -8138,7 +8138,21 @@ export interface NoVueDataObjectDeclarationOptions {}
 export interface NoVueReservedKeysOptions {}
 export interface NoVueReservedPropsOptions {}
 export type UseAnchorHrefOptions = null;
-export interface UseConsistentArrowReturnOptions {}
+/**
+ * Options for the `useConsistentArrowReturn` rule.
+ */
+export interface UseConsistentArrowReturnOptions {
+	/**
+	* Determines whether the rule enforces a consistent style when the return value is an object literal.
+
+This option is only applicable when used in conjunction with the `asNeeded` option. 
+	 */
+	requireForObjectLiteral?: boolean;
+	/**
+	 * The style to enforce for arrow function return statements.
+	 */
+	style?: UseConsistentArrowReturnStyle;
+}
 export interface UseConsistentTypeDefinitionsOptions {
 	style?: ConsistentTypeDefinition;
 }
@@ -8503,6 +8517,7 @@ For example, for React's `useRef()` hook the value would be `true`, while for `u
 	 */
 	stableResult?: StableHookResult;
 }
+export type UseConsistentArrowReturnStyle = "asNeeded" | "always" | "never";
 export type ConsistentTypeDefinition = "interface" | "type";
 /**
  * Specifies whether property assignments on function parameters are allowed or denied.
diff --git a/packages/@biomejs/biome/README.es.md b/packages/@biomejs/biome/README.es.md
index 04edf5442c..57294a7047 100644
--- a/packages/@biomejs/biome/README.es.md
+++ b/packages/@biomejs/biome/README.es.md
@@ -180,9 +180,6 @@ Biome ofrece [soporte empresarial](https://biomejs.dev/enterprise), donde colabo
       <td align="center" valign="middle">
         <a href="https://www.egstock.co.jp/?utm_source=biome&utm_medium=readme" target="_blank"><img src="https://images.opencollective.com/egstock/b18c836/logo/256.png?height=256" width="80" alt="EGSTOCK, Inc. logo"></a>
       </td>
-      <td align="center" valign="middle">
-        <a href="https://www.convex.dev/?utm_source=biome&utm_medium=readme" target="_blank"><img src="https://avatars.githubusercontent.com/u/81530787?s=200&v=4" width="80" alt="Convex logo"></a>
-      </td>
     </tr>
   </tbody>
 </table>
diff --git a/packages/@biomejs/biome/README.fr.md b/packages/@biomejs/biome/README.fr.md
index 6e3deadd4d..a0ab63136b 100644
--- a/packages/@biomejs/biome/README.fr.md
+++ b/packages/@biomejs/biome/README.fr.md
@@ -184,9 +184,6 @@ Nous utilisons [Polar.sh](https://polar.sh/biomejs) pour voter pour des fonction
       <td align="center" valign="middle">
         <a href="https://www.egstock.co.jp/?utm_source=biome&utm_medium=readme" target="_blank"><img src="https://images.opencollective.com/egstock/b18c836/logo/256.png?height=256" width="80" alt="EGSTOCK, Inc. logo"></a>
       </td>
-      <td align="center" valign="middle">
-        <a href="https://www.convex.dev/?utm_source=biome&utm_medium=readme" target="_blank"><img src="https://avatars.githubusercontent.com/u/81530787?s=200&v=4" width="80" alt="Convex logo"></a>
-      </td>
     </tr>
   </tbody>
 </table>
diff --git a/packages/@biomejs/biome/README.hi.md b/packages/@biomejs/biome/README.hi.md
index 905e3a849a..1ddb3ed1ae 100644
--- a/packages/@biomejs/biome/README.hi.md
+++ b/packages/@biomejs/biome/README.hi.md
@@ -190,9 +190,6 @@ Biome एक सरल प्रायोजन[^37] कार्यक्रम
       <td align="center" valign="middle">
         <a href="https://www.egstock.co.jp/?utm_source=biome&utm_medium=readme" target="_blank"><img src="https://images.opencollective.com/egstock/b18c836/logo/256.png?height=256" width="80" alt="EGSTOCK, Inc. logo"></a>
       </td>
-      <td align="center" valign="middle">
-        <a href="https://www.convex.dev/?utm_source=biome&utm_medium=readme" target="_blank"><img src="https://avatars.githubusercontent.com/u/81530787?s=200&v=4" width="80" alt="Convex logo"></a>
-      </td>
     </tr>
   </tbody>
 </table>
diff --git a/packages/@biomejs/biome/README.ja.md b/packages/@biomejs/biome/README.ja.md
index ee88eba785..286f988c3b 100644
--- a/packages/@biomejs/biome/README.ja.md
+++ b/packages/@biomejs/biome/README.ja.md
@@ -167,9 +167,6 @@ Biome についてもっと知るために[ホームページ][biomejs]をチェ
       <td align="center" valign="middle">
         <a href="https://www.egstock.co.jp/?utm_source=biome&utm_medium=readme" target="_blank"><img src="https://images.opencollective.com/egstock/b18c836/logo/256.png?height=256" width="80" alt="EGSTOCK, Inc. logo"></a>
       </td>
-      <td align="center" valign="middle">
-        <a href="https://www.convex.dev/?utm_source=biome&utm_medium=readme" target="_blank"><img src="https://avatars.githubusercontent.com/u/81530787?s=200&v=4" width="80" alt="Convex logo"></a>
-      </td>
     </tr>
   </tbody>
 </table>
diff --git a/packages/@biomejs/biome/README.kr.md b/packages/@biomejs/biome/README.kr.md
index 4530556c93..32f2643483 100644
--- a/packages/@biomejs/biome/README.kr.md
+++ b/packages/@biomejs/biome/README.kr.md
@@ -179,9 +179,6 @@ Biome은 기업이 다양한 개발자들 사이에서 인지도를 얻을 수 
       <td align="center" valign="middle">
         <a href="https://www.egstock.co.jp/?utm_source=biome&utm_medium=readme" target="_blank"><img src="https://images.opencollective.com/egstock/b18c836/logo/256.png?height=256" width="80" alt="EGSTOCK, Inc. logo"></a>
       </td>
-      <td align="center" valign="middle">
-        <a href="https://www.convex.dev/?utm_source=biome&utm_medium=readme" target="_blank"><img src="https://avatars.githubusercontent.com/u/81530787?s=200&v=4" width="80" alt="Convex logo"></a>
-      </td>
     </tr>
   </tbody>
 </table>
diff --git a/packages/@biomejs/biome/README.md b/packages/@biomejs/biome/README.md
index 30568b56b7..f2d1be18d4 100644
--- a/packages/@biomejs/biome/README.md
+++ b/packages/@biomejs/biome/README.md
@@ -181,9 +181,6 @@ Biome offers [enterprise support](https://biomejs.dev/enterprise), where Core Co
       <td align="center" valign="middle">
         <a href="https://www.egstock.co.jp/?utm_source=biome&utm_medium=readme" target="_blank"><img src="https://images.opencollective.com/egstock/b18c836/logo/256.png?height=256" width="80" alt="EGSTOCK, Inc. logo"></a>
       </td>
-      <td align="center" valign="middle">
-        <a href="https://www.convex.dev/?utm_source=biome&utm_medium=readme" target="_blank"><img src="https://avatars.githubusercontent.com/u/81530787?s=200&v=4" width="80" alt="Convex logo"></a>
-      </td>
     </tr>
   </tbody>
 </table>
diff --git a/packages/@biomejs/biome/README.pt-BR.md b/packages/@biomejs/biome/README.pt-BR.md
index a059015616..106a5dc9db 100644
--- a/packages/@biomejs/biome/README.pt-BR.md
+++ b/packages/@biomejs/biome/README.pt-BR.md
@@ -170,9 +170,6 @@ Leia mais sobre nossa [filosofia de projeto][biome-philosophy].
       <td align="center" valign="middle">
         <a href="https://www.egstock.co.jp/?utm_source=biome&utm_medium=readme" target="_blank"><img src="https://images.opencollective.com/egstock/b18c836/logo/256.png?height=256" width="80" alt="EGSTOCK, Inc. logo"></a>
       </td>
-      <td align="center" valign="middle">
-        <a href="https://www.convex.dev/?utm_source=biome&utm_medium=readme" target="_blank"><img src="https://avatars.githubusercontent.com/u/81530787?s=200&v=4" width="80" alt="Convex logo"></a>
-      </td>
     </tr>
   </tbody>
 </table>
diff --git a/packages/@biomejs/biome/README.ru.md b/packages/@biomejs/biome/README.ru.md
index e839aba582..ec6d4b3835 100644
--- a/packages/@biomejs/biome/README.ru.md
+++ b/packages/@biomejs/biome/README.ru.md
@@ -182,9 +182,6 @@ Biome предлагает простую спонсорскую програм
       <td align="center" valign="middle">
         <a href="https://www.egstock.co.jp/?utm_source=biome&utm_medium=readme" target="_blank"><img src="https://images.opencollective.com/egstock/b18c836/logo/256.png?height=256" width="80" alt="EGSTOCK, Inc. logo"></a>
       </td>
-      <td align="center" valign="middle">
-        <a href="https://www.convex.dev/?utm_source=biome&utm_medium=readme" target="_blank"><img src="https://avatars.githubusercontent.com/u/81530787?s=200&v=4" width="80" alt="Convex logo"></a>
-      </td>
     </tr>
   </tbody>
 </table>
diff --git a/packages/@biomejs/biome/README.uk.md b/packages/@biomejs/biome/README.uk.md
index c8635477fb..fe63b47464 100644
--- a/packages/@biomejs/biome/README.uk.md
+++ b/packages/@biomejs/biome/README.uk.md
@@ -179,9 +179,6 @@ Biome пропонує просту програму спонсорства, я
       <td align="center" valign="middle">
         <a href="https://www.egstock.co.jp/?utm_source=biome&utm_medium=readme" target="_blank"><img src="https://images.opencollective.com/egstock/b18c836/logo/256.png?height=256" width="80" alt="EGSTOCK, Inc. logo"></a>
       </td>
-      <td align="center" valign="middle">
-        <a href="https://www.convex.dev/?utm_source=biome&utm_medium=readme" target="_blank"><img src="https://avatars.githubusercontent.com/u/81530787?s=200&v=4" width="80" alt="Convex logo"></a>
-      </td>
     </tr>
   </tbody>
 </table>
diff --git a/packages/@biomejs/biome/README.zh-CN.md b/packages/@biomejs/biome/README.zh-CN.md
index 204dd9afe9..95cc7862f5 100644
--- a/packages/@biomejs/biome/README.zh-CN.md
+++ b/packages/@biomejs/biome/README.zh-CN.md
@@ -164,9 +164,6 @@ npx @biomejs/biome ci ./src
       <td align="center" valign="middle">
         <a href="https://www.egstock.co.jp/?utm_source=biome&utm_medium=readme" target="_blank"><img src="https://images.opencollective.com/egstock/b18c836/logo/256.png?height=256" width="80" alt="EGSTOCK, Inc. logo"></a>
       </td>
-      <td align="center" valign="middle">
-        <a href="https://www.convex.dev/?utm_source=biome&utm_medium=readme" target="_blank"><img src="https://avatars.githubusercontent.com/u/81530787?s=200&v=4" width="80" alt="Convex logo"></a>
-      </td>
     </tr>
   </tbody>
 </table>
diff --git a/packages/@biomejs/biome/README.zh-TW.md b/packages/@biomejs/biome/README.zh-TW.md
index ba0cace596..91f4f320f9 100644
--- a/packages/@biomejs/biome/README.zh-TW.md
+++ b/packages/@biomejs/biome/README.zh-TW.md
@@ -177,9 +177,6 @@ Biome 提供了一個簡單的贊助計劃，允許公司在各種開發者中
       <td align="center" valign="middle">
         <a href="https://www.egstock.co.jp/?utm_source=biome&utm_medium=readme" target="_blank"><img src="https://images.opencollective.com/egstock/b18c836/logo/256.png?height=256" width="80" alt="EGSTOCK, Inc. logo"></a>
       </td>
-      <td align="center" valign="middle">
-        <a href="https://www.convex.dev/?utm_source=biome&utm_medium=readme" target="_blank"><img src="https://avatars.githubusercontent.com/u/81530787?s=200&v=4" width="80" alt="Convex logo"></a>
-      </td>
     </tr>
   </tbody>
 </table>
diff --git a/packages/@biomejs/biome/configuration_schema.json b/packages/@biomejs/biome/configuration_schema.json
index b311924291..d811642073 100644
--- a/packages/@biomejs/biome/configuration_schema.json
+++ b/packages/@biomejs/biome/configuration_schema.json
@@ -13616,9 +13616,41 @@
 			]
 		},
 		"UseConsistentArrowReturnOptions": {
+			"description": "Options for the `useConsistentArrowReturn` rule.",
 			"type": "object",
+			"properties": {
+				"requireForObjectLiteral": {
+					"description": "Determines whether the rule enforces a consistent style when the return value is an object literal.\n\nThis option is only applicable when used in conjunction with the `asNeeded` option.",
+					"default": false,
+					"type": "boolean"
+				},
+				"style": {
+					"description": "The style to enforce for arrow function return statements.",
+					"default": "asNeeded",
+					"allOf": [{ "$ref": "#/definitions/UseConsistentArrowReturnStyle" }]
+				}
+			},
 			"additionalProperties": false
 		},
+		"UseConsistentArrowReturnStyle": {
+			"oneOf": [
+				{
+					"description": "Enforces no braces where they can be omitted (default).",
+					"type": "string",
+					"enum": ["asNeeded"]
+				},
+				{
+					"description": "Enforces braces around the function body.",
+					"type": "string",
+					"enum": ["always"]
+				},
+				{
+					"description": "Enforces no braces around the function body (constrains arrow functions to the role of returning an expression).",
+					"type": "string",
+					"enum": ["never"]
+				}
+			]
+		},
 		"UseConsistentBuiltinInstantiationConfiguration": {
 			"anyOf": [
 				{ "$ref": "#/definitions/RulePlainConfiguration" },
