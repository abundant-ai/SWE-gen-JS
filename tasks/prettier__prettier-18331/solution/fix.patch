diff --git a/changelog_unreleased/yaml/18331.md b/changelog_unreleased/yaml/18331.md
new file mode 100644
index 000000000..2aa43ccc8
--- /dev/null
+++ b/changelog_unreleased/yaml/18331.md
@@ -0,0 +1,16 @@
+#### Fix block value ends with whitespace (#18331 by @kovsu)
+
+```js
+import { inspect } from "node:util";
+import * as prettier from "prettier";
+
+const input = "foo: |\n  x\n   ";
+const output = await prettier.format(input, { parser: "yaml" });
+console.log(inspect(output));
+
+// Prettier stable
+//-> 'foo: |\n  x\n\n'
+
+// Prettier main
+//-> 'foo: |\n  x\n'
+```
diff --git a/src/language-yaml/clean.js b/src/language-yaml/clean.js
index fc614e113..8505c3414 100644
--- a/src/language-yaml/clean.js
+++ b/src/language-yaml/clean.js
@@ -21,6 +21,18 @@ function clean(original, cloned /* , parent */) {
         delete cloned.documentEndMarker;
       }
       break;
+
+    case "blockLiteral":
+    case "blockFolded":
+      // The doc printer currently have bug when print trailing space/tab, they get wiped.
+      // But at least we can still make sure the new lines doesn't change in `value` property.
+      if (original.chomping === "keep") {
+        cloned.value = original.value
+          .split("\n")
+          .map((line) => line.replace(/[ \t]+$/u, ""))
+          .join("\n");
+      }
+      break;
   }
 }
 clean.ignoredProperties = new Set(["position"]);
diff --git a/src/language-yaml/utilities.js b/src/language-yaml/utilities.js
index 90e5183ee..be2caef3d 100644
--- a/src/language-yaml/utilities.js
+++ b/src/language-yaml/utilities.js
@@ -209,6 +209,10 @@ function getBlockValueLineContents(
           // exclude open line `>` or `|`
           .match(/^[^\n]*\n(.*)$/su)[1];
 
+  if (content === "") {
+    return [];
+  }
+
   /** @type {number} */
   let leadingSpaceCount;
   if (node.indent === null) {
@@ -275,14 +279,16 @@ function getBlockValueLineContents(
   */
   function removeUnnecessaryTrailingNewlines(lineContents) {
     if (node.chomping === "keep") {
-      return lineContents.at(-1).length === 0
+      return content.endsWith("\n") && lineContents.at(-1).length === 0
         ? lineContents.slice(0, -1)
         : lineContents;
     }
 
     let trailingNewlineCount = 0;
     for (let i = lineContents.length - 1; i >= 0; i--) {
-      if (lineContents[i].length === 0) {
+      if (
+        lineContents[i].every((line) => line.replace(/[ \t]+$/u, "") === "")
+      ) {
         trailingNewlineCount++;
       } else {
         break;
