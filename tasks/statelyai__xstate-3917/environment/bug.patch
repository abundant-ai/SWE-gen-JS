diff --git a/.changeset/six-pans-warn.md b/.changeset/six-pans-warn.md
deleted file mode 100644
index 6b67f9c67a..0000000000
--- a/.changeset/six-pans-warn.md
+++ /dev/null
@@ -1,5 +0,0 @@
----
-'@xstate/fsm': major
----
-
-Observing a service via `service.subscribe(...)` no longer immediately receives the current state. Instead, the current state can be read from `service.state`, and observers will receive snapshots only when a transition in the service occurs.
diff --git a/packages/xstate-fsm/src/index.ts b/packages/xstate-fsm/src/index.ts
index 5fe045abee..bc527e6645 100644
--- a/packages/xstate-fsm/src/index.ts
+++ b/packages/xstate-fsm/src/index.ts
@@ -261,6 +261,7 @@ export function interpret<
     },
     subscribe: (listener: StateMachine.StateListener<typeof state>) => {
       listeners.add(listener);
+      listener(state);
 
       return {
         unsubscribe: () => listeners.delete(listener)
diff --git a/packages/xstate-fsm/test/fsm.test.ts b/packages/xstate-fsm/test/fsm.test.ts
index f3d02aa481..781f11643b 100644
--- a/packages/xstate-fsm/test/fsm.test.ts
+++ b/packages/xstate-fsm/test/fsm.test.ts
@@ -235,14 +235,14 @@ describe('interpreter', () => {
     }
   });
 
-  it('listeners should not immediately get the initial state', () => {
-    const spy = jest.fn();
-
-    const toggleService = interpret(toggleMachine);
-    toggleService.subscribe(spy);
-    toggleService.start();
+  it('listeners should immediately get the initial state', (done) => {
+    const toggleService = interpret(toggleMachine).start();
 
-    expect(spy).not.toHaveBeenCalled();
+    toggleService.subscribe((state) => {
+      if (state.matches('active')) {
+        done();
+      }
+    });
   });
 
   it('listeners should subscribe to state changes', (done) => {
diff --git a/packages/xstate-react/src/fsm.ts b/packages/xstate-react/src/fsm.ts
index 05f532e078..b7f0ded657 100644
--- a/packages/xstate-react/src/fsm.ts
+++ b/packages/xstate-react/src/fsm.ts
@@ -1,11 +1,13 @@
 import {
   createMachine,
+  EventObject,
   interpret,
   InterpreterStatus,
   MachineImplementationsFrom,
   ServiceFrom,
   StateFrom,
-  StateMachine
+  StateMachine,
+  Typestate
 } from '@xstate/fsm';
 import { useCallback, useEffect, useRef, useState } from 'react';
 import useIsomorphicLayoutEffect from 'use-isomorphic-layout-effect';
@@ -16,6 +18,22 @@ function identity<T>(a: T): T {
   return a;
 }
 
+const getServiceState = <
+  TContext extends object,
+  TEvent extends EventObject = EventObject,
+  TState extends Typestate<TContext> = { value: any; context: TContext }
+>(
+  service: StateMachine.Service<TContext, TEvent, TState>
+): StateMachine.State<TContext, TEvent, TState> => {
+  let currentValue: StateMachine.State<TContext, TEvent, TState>;
+  service
+    .subscribe((state) => {
+      currentValue = state;
+    })
+    .unsubscribe();
+  return currentValue!;
+};
+
 export function useMachine<TMachine extends StateMachine.AnyMachine>(
   stateMachine: TMachine,
   options?: MachineImplementationsFrom<TMachine>
@@ -84,7 +102,7 @@ const isEqual = (
 export function useService<TService extends StateMachine.AnyService>(
   service: TService
 ): [StateFrom<TService>, TService['send'], TService] {
-  const getSnapshot = useCallback(() => service.state, [service]);
+  const getSnapshot = useCallback(() => getServiceState(service), [service]);
 
   const subscribe = useCallback(
     (handleStoreChange) => {
diff --git a/packages/xstate-solid/src/fsm.ts b/packages/xstate-solid/src/fsm.ts
index d04ca356b1..2513f62b7c 100644
--- a/packages/xstate-solid/src/fsm.ts
+++ b/packages/xstate-solid/src/fsm.ts
@@ -52,21 +52,13 @@ export function useService<TService extends StateMachine.AnyService>(
     deriveFSMState(serviceMemo().state as StateFrom<TService>)
   );
 
-  const setNewState = (currentState: StateFrom<TService>) => {
-    setState(deriveFSMState(currentState, unwrap(state)));
-  };
-
   createEffect(() => {
-    const currentService = serviceMemo();
-    // this eager `setState` here is important because the state could change between render and effect's call
-    // however, it might also create some extra work that might not be necessary
-    // perhaps we should only do this if the state has changed
-    // we'd have to track the "original" state to check if the current one is different from it
-    // (for that purpose we can't use the derived one created by `createImmutable` as that's a copy of the original)
-    setNewState(currentService.state as StateFrom<TService>);
-    const { unsubscribe } = currentService.subscribe(setNewState);
+    const { unsubscribe } = serviceMemo().subscribe((currentState) =>
+      setState(
+        deriveFSMState(currentState as StateFrom<TService>, unwrap(state))
+      )
+    );
     onCleanup(unsubscribe);
-    return false;
   });
 
   const send: TService['send'] = (event) => serviceMemo().send(event);
diff --git a/packages/xstate-svelte/test/UseFsm.svelte b/packages/xstate-svelte/test/UseFsm.svelte
index c826df9709..d736343fa2 100644
--- a/packages/xstate-svelte/test/UseFsm.svelte
+++ b/packages/xstate-svelte/test/UseFsm.svelte
@@ -1,5 +1,5 @@
 <script lang="ts">
-  import { useMachine } from '../src/fsm.ts';
+  import { useMachine } from '../src/fsm';
   import { createMachine, assign } from '@xstate/fsm';
 
   const context = {
diff --git a/packages/xstate-vue/src/fsm.ts b/packages/xstate-vue/src/fsm.ts
index 41d86db60d..53f2352820 100644
--- a/packages/xstate-vue/src/fsm.ts
+++ b/packages/xstate-vue/src/fsm.ts
@@ -7,6 +7,22 @@ import {
   Typestate
 } from '@xstate/fsm';
 
+const getServiceValue = <
+  TContext extends object,
+  TEvent extends EventObject = EventObject,
+  TState extends Typestate<TContext> = { value: any; context: TContext }
+>(
+  service: StateMachine.Service<TContext, TEvent, TState>
+): StateMachine.State<TContext, TEvent, TState> => {
+  let currentValue: StateMachine.State<TContext, TEvent, TState>;
+  service
+    .subscribe((state) => {
+      currentValue = state;
+    })
+    .unsubscribe();
+  return currentValue!;
+};
+
 export function useMachine<
   TContext extends object,
   TEvent extends EventObject = EventObject
@@ -28,7 +44,7 @@ export function useMachine<
   ).start();
 
   const state = shallowRef<StateMachine.State<TContext, TEvent, any>>(
-    service.state
+    getServiceValue(service)
   );
 
   onMounted(() => {
@@ -65,7 +81,7 @@ export function useService<
   watch(
     serviceRef,
     (service, _, onCleanup) => {
-      state.value = service.state;
+      state.value = getServiceValue(service);
 
       const { unsubscribe } = service.subscribe((currentState) => {
         if (currentState.changed) {
