diff --git a/package.json b/package.json
index 71a0262..8f7d3e9 100644
--- a/package.json
+++ b/package.json
@@ -26,11 +26,10 @@
   "types": "./dist/immer.d.ts",
   "sideEffects": false,
   "scripts": {
-    "pretest": "yarn build",
     "test": "vitest run && yarn test:build && yarn test:flow",
     "test:perf": "cd __performance_tests__ && node add-data.mjs && node todo.mjs && node incremental.mjs && node large-obj.mjs",
     "test:flow": "yarn flow check __tests__/flow",
-    "test:build": "vitest run --config vitest.config.build.ts",
+    "test:build": "yarn build && vitest run --config vitest.config.build.ts",
     "test:src": "vitest run",
     "watch": "vitest",
     "coverage": "vitest run --coverage",
diff --git a/src/core/finalize.ts b/src/core/finalize.ts
index 9cb9177..9a76e2b 100644
--- a/src/core/finalize.ts
+++ b/src/core/finalize.ts
@@ -240,23 +240,29 @@ export function handleCrossReference(
 		target.callbacks_.push(function nestedDraftCleanup() {
 			const targetCopy = latest(target)
 
-			if (get(targetCopy, key, target.type_) === value) {
-				// Process the value to replace any nested drafts
-				// finalizeAssigned(target, key, target.scope_)
-
-				if (
-					scope_.drafts_.length > 1 &&
-					((target as Exclude<ImmerState, SetState>).assigned_!.get(key) ??
-						false) === true &&
-					target.copy_
-				) {
-					// This might be a non-draft value that has drafts
-					// inside. We do need to recurse here to handle those.
-					handleValue(
-						get(target.copy_, key, target.type_),
-						scope_.handledSet_,
-						scope_
-					)
+			// For Sets, check if value is still in the set
+			if (target.type_ === ArchType.Set) {
+				if (targetCopy.has(value)) {
+					// Process the value to replace any nested drafts
+					handleValue(value, scope_.handledSet_, scope_)
+				}
+			} else {
+				// Maps/objects
+				if (get(targetCopy, key, target.type_) === value) {
+					if (
+						scope_.drafts_.length > 1 &&
+						((target as Exclude<ImmerState, SetState>).assigned_!.get(key) ??
+							false) === true &&
+						target.copy_
+					) {
+						// This might be a non-draft value that has drafts
+						// inside. We do need to recurse here to handle those.
+						handleValue(
+							get(target.copy_, key, target.type_),
+							scope_.handledSet_,
+							scope_
+						)
+					}
 				}
 			}
 		})
diff --git a/src/core/proxy.ts b/src/core/proxy.ts
index a3bc4d4..bd758cd 100644
--- a/src/core/proxy.ts
+++ b/src/core/proxy.ts
@@ -1,5 +1,4 @@
 import {
-	each,
 	has,
 	is,
 	isDraftable,
@@ -17,7 +16,6 @@ import {
 	die,
 	createProxy,
 	ArchType,
-	ImmerScope,
 	handleCrossReference,
 	WRITABLE,
 	CONFIGURABLE,
@@ -256,14 +254,17 @@ export const objectTraps: ProxyHandler<ProxyState> = {
  */
 
 const arrayTraps: ProxyHandler<[ProxyArrayState]> = {}
-each(objectTraps, (key, fn) => {
+// Use `for..in` instead of `each` to work around a weird
+// prod test suite issue
+for (let key in objectTraps) {
+	let fn = objectTraps[key as keyof typeof objectTraps] as Function
 	// @ts-ignore
 	arrayTraps[key] = function() {
 		const args = arguments
 		args[0] = args[0][0]
 		return fn.apply(this, args)
 	}
-})
+}
 arrayTraps.deleteProperty = function(state, prop) {
 	if (process.env.NODE_ENV !== "production" && isNaN(parseInt(prop as any)))
 		die(13)
diff --git a/src/plugins/mapset.ts b/src/plugins/mapset.ts
index 9afa74e..3c59eab 100644
--- a/src/plugins/mapset.ts
+++ b/src/plugins/mapset.ts
@@ -16,7 +16,8 @@ import {
 	ArchType,
 	each,
 	getValue,
-	PluginMapSet
+	PluginMapSet,
+	handleCrossReference
 } from "../internal"
 
 export function enableMapSet() {
@@ -58,6 +59,7 @@ export function enableMapSet() {
 				state.assigned_!.set(key, true)
 				state.copy_!.set(key, value)
 				state.assigned_!.set(key, true)
+				handleCrossReference(state, key, value)
 			}
 			return this
 		}
@@ -222,6 +224,7 @@ export function enableMapSet() {
 				prepareSetCopy(state)
 				markChanged(state)
 				state.copy_!.add(value)
+				handleCrossReference(state, value, value)
 			}
 			return this
 		}
diff --git a/src/plugins/patches.ts b/src/plugins/patches.ts
index a1b5fa8..0709025 100644
--- a/src/plugins/patches.ts
+++ b/src/plugins/patches.ts
@@ -49,7 +49,7 @@ export function enablePatches() {
 
 	function getPath(state: ImmerState, path: PatchPath = []): PatchPath | null {
 		// Step 1: Check if state has a stored key
-		if ("key_" in state && state.key_ !== undefined) {
+		if (state.key_ !== undefined) {
 			// Step 2: Validate the key is still valid in parent
 
 			const parentCopy = state.parent_!.copy_ ?? state.parent_!.base_
diff --git a/vitest.config.build.ts b/vitest.config.build.ts
index ecbbe88..23872f4 100644
--- a/vitest.config.build.ts
+++ b/vitest.config.build.ts
@@ -1,11 +1,38 @@
 import {defineConfig} from "vitest/config"
 import path from "path"
 
+const prodCJSPath = path.resolve(__dirname, "dist/cjs/immer.cjs.production.js")
+
 export default defineConfig({
 	resolve: {
-		alias: {
-			"^src/(.*)": path.resolve(__dirname, "dist/cjs/immer.cjs.production.js")
-		}
+		// 	// Make all `immer` imports use the production build
+		alias: [
+			{
+				find: /^src\/(.*)/,
+				replacement: prodCJSPath
+			},
+			{
+				find: "../src/immer",
+				replacement: prodCJSPath
+			},
+			{
+				find: "immer",
+				replacement: prodCJSPath
+			}
+		],
+		// Ensure only one copy of immer is used throughout the dependency tree
+		dedupe: ["immer"]
+	},
+	// Force Vite to process immer so our alias applies to dependencies too
+	optimizeDeps: {
+		include: ["immer"],
+		// Force re-bundling to pick up our alias
+		force: true
+	},
+	// SSR settings are needed because Vitest runs in Node environment
+	ssr: {
+		// Don't externalize immer - this makes our alias apply to it
+		noExternal: ["immer"]
 	},
 	define: {
 		"global.USES_BUILD": true,
@@ -18,6 +45,15 @@ export default defineConfig({
 		resolveSnapshotPath: (testPath: string, snapExtension: string) =>
 			testPath.replace("__tests__", "__tests__/__prod_snapshots__") +
 			snapExtension,
-		reporters: ["default", "./vitest-custom-reporter.ts"]
+		reporters: ["default", "./vitest-custom-reporter.ts"],
+		// Ensure deps are processed through Vite's transform pipeline
+		deps: {
+			optimizer: {
+				// For SSR (Node) environment, include immer so it's transformed
+				ssr: {
+					include: ["immer"]
+				}
+			}
+		}
 	}
 })
