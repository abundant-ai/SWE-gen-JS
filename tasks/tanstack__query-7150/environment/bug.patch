diff --git a/packages/angular-query-experimental/src/inject-queries.ts b/packages/angular-query-experimental/src/inject-queries.ts
index c6edc9c01..49ff7a562 100644
--- a/packages/angular-query-experimental/src/inject-queries.ts
+++ b/packages/angular-query-experimental/src/inject-queries.ts
@@ -136,7 +136,7 @@ export type QueriesOptions<
             [...TResult, GetOptions<Head>],
             [...TDepth, 1]
           >
-        : ReadonlyArray<unknown> extends T
+        : Array<unknown> extends T
           ? T
           : // If T is *some* array but we couldn't assign unknown[] to it, then it must hold some known/homogenous type!
             // use this to infer the param types in the case of Array.map() argument
@@ -219,13 +219,7 @@ export function injectQueries<
         // Make sure the results are already in fetching state before subscribing or updating options
         defaultedOptions._optimisticResults = 'optimistic'
 
-        return defaultedOptions as QueryObserverOptions<
-          unknown,
-          Error,
-          unknown,
-          unknown,
-          QueryKey
-        >
+        return defaultedOptions
       })
     })
 
diff --git a/packages/react-query/src/__tests__/useQueries.test-d.tsx b/packages/react-query/src/__tests__/useQueries.test-d.tsx
index f4dc9ee3a..f3cff9632 100644
--- a/packages/react-query/src/__tests__/useQueries.test-d.tsx
+++ b/packages/react-query/src/__tests__/useQueries.test-d.tsx
@@ -1,7 +1,6 @@
 import { describe, expectTypeOf, it } from 'vitest'
-import { skipToken } from '..'
-import { useQueries } from '../useQueries'
 import { queryOptions } from '../queryOptions'
+import { useQueries } from '../useQueries'
 import type { OmitKeyof } from '..'
 import type { UseQueryOptions } from '../types'
 
@@ -125,19 +124,4 @@ describe('UseQueries config object overload', () => {
       expectTypeOf(data).toEqualTypeOf<Data | undefined>()
     })
   })
-
-  it('TData should have correct type when conditional skipToken is passed', () => {
-    const queryResults = useQueries({
-      queries: [
-        {
-          queryKey: ['withSkipToken'],
-          queryFn: Math.random() > 0.5 ? skipToken : () => Promise.resolve(5),
-        },
-      ],
-    })
-
-    const data = queryResults[0].data
-
-    expectTypeOf(data).toEqualTypeOf<number | undefined>()
-  })
 })
diff --git a/packages/react-query/src/useQueries.ts b/packages/react-query/src/useQueries.ts
index dd24ccf72..f33c3513e 100644
--- a/packages/react-query/src/useQueries.ts
+++ b/packages/react-query/src/useQueries.ts
@@ -33,7 +33,6 @@ import type {
   QueryClient,
   QueryFunction,
   QueryKey,
-  QueryObserverOptions,
   SkipToken,
   ThrowOnError,
 } from '@tanstack/query-core'
@@ -179,7 +178,7 @@ export type QueriesOptions<
             [...TResult, GetOptions<Head>],
             [...TDepth, 1]
           >
-        : ReadonlyArray<unknown> extends T
+        : Array<unknown> extends T
           ? T
           : // If T is *some* array but we couldn't assign unknown[] to it, then it must hold some known/homogenous type!
             // use this to infer the param types in the case of Array.map() argument
@@ -259,15 +258,7 @@ export function useQueries<
   const defaultedQueries = React.useMemo(
     () =>
       queries.map((opts) => {
-        const defaultedOptions = client.defaultQueryOptions(
-          opts as QueryObserverOptions<
-            unknown,
-            Error,
-            unknown,
-            unknown,
-            QueryKey
-          >,
-        )
+        const defaultedOptions = client.defaultQueryOptions(opts)
 
         // Make sure the results are already in fetching state before subscribing or updating options
         defaultedOptions._optimisticResults = isRestoring
diff --git a/packages/solid-query/src/createQueries.ts b/packages/solid-query/src/createQueries.ts
index 48859abe7..77de5f8e1 100644
--- a/packages/solid-query/src/createQueries.ts
+++ b/packages/solid-query/src/createQueries.ts
@@ -148,7 +148,7 @@ type QueriesOptions<
             [...TResult, GetOptions<Head>],
             [...TDepth, 1]
           >
-        : ReadonlyArray<unknown> extends T
+        : Array<unknown> extends T
           ? T
           : // If T is *some* array but we couldn't assign unknown[] to it, then it must hold some known/homogenous type!
             // use this to infer the param types in the case of Array.map() argument
@@ -221,7 +221,7 @@ export function createQueries<
   const client = createMemo(() => useQueryClient(queryClient?.()))
   const isRestoring = useIsRestoring()
 
-  const defaultedQueries: QueriesOptions<any> = createMemo(() =>
+  const defaultedQueries = createMemo(() =>
     queriesOptions().queries.map((options) =>
       mergeProps(client().defaultQueryOptions(options), {
         get _optimisticResults() {
diff --git a/packages/svelte-query/src/createQueries.ts b/packages/svelte-query/src/createQueries.ts
index 6c9c3487f..9d6aa1ff4 100644
--- a/packages/svelte-query/src/createQueries.ts
+++ b/packages/svelte-query/src/createQueries.ts
@@ -139,7 +139,7 @@ export type QueriesOptions<
             [...TResult, GetOptions<Head>],
             [...TDepth, 1]
           >
-        : Readonly<unknown> extends T
+        : Array<unknown> extends T
           ? T
           : // If T is *some* array but we couldn't assign unknown[] to it, then it must hold some known/homogenous type!
             // use this to infer the param types in the case of Array.map() argument
@@ -221,15 +221,7 @@ export function createQueries<
     [queriesStore, isRestoring],
     ([$queries, $isRestoring]) => {
       return $queries.map((opts) => {
-        const defaultedOptions = client.defaultQueryOptions(
-          opts as QueryObserverOptions<
-            unknown,
-            Error,
-            unknown,
-            unknown,
-            QueryKey
-          >,
-        )
+        const defaultedOptions = client.defaultQueryOptions(opts)
         // Make sure the results are already in fetching state before subscribing or updating options
         defaultedOptions._optimisticResults = $isRestoring
           ? 'isRestoring'
diff --git a/packages/vue-query/src/__tests__/useQueries.types.test.ts b/packages/vue-query/src/__tests__/useQueries.types.test.ts
index f598e0c7b..50e01064a 100644
--- a/packages/vue-query/src/__tests__/useQueries.types.test.ts
+++ b/packages/vue-query/src/__tests__/useQueries.types.test.ts
@@ -1,6 +1,6 @@
 import { describe, it } from 'vitest'
 import { reactive } from 'vue'
-import { skipToken, useQueries } from '..'
+import { useQueries } from '..'
 import { queryOptions } from '../queryOptions'
 import { doNotExecute } from './test-utils'
 import type { OmitKeyof } from '..'
@@ -124,24 +124,6 @@ describe('UseQueries config object overload', () => {
     })
   })
 
-  it('TData should have correct type when conditional skipToken is passed', () => {
-    doNotExecute(() => {
-      const { value: queriesState } = useQueries({
-        queries: [
-          {
-            queryKey: ['key'],
-            queryFn: Math.random() > 0.5 ? skipToken : () => Promise.resolve(5),
-          },
-        ],
-      })
-
-      const data = queriesState[0].data
-
-      const result: Expect<Equal<number | undefined, typeof data>> = true
-      return result
-    })
-  })
-
   describe('custom hook', () => {
     it('should allow custom hooks using UseQueryOptions', () => {
       doNotExecute(() => {
diff --git a/packages/vue-query/src/useQueries.ts b/packages/vue-query/src/useQueries.ts
index 5ab0e47ac..15c75d773 100644
--- a/packages/vue-query/src/useQueries.ts
+++ b/packages/vue-query/src/useQueries.ts
@@ -182,7 +182,7 @@ export type UseQueriesOptions<
             [...TResult, GetOptions<Head>],
             [...TDepth, 1]
           >
-        : Readonly<unknown> extends T
+        : Array<unknown> extends T
           ? T
           : // If T is *some* array but we couldn't assign unknown[] to it, then it must hold some known/homogenous type!
             // use this to infer the param types in the case of Array.map() argument
@@ -270,20 +270,18 @@ export function useQueries<
   const client = queryClient || useQueryClient()
 
   const defaultedQueries = computed(() =>
-    cloneDeepUnref(queries as MaybeRefDeep<UseQueriesOptionsArg<any>>).map(
-      (queryOptions) => {
-        if (typeof queryOptions.enabled === 'function') {
-          queryOptions.enabled = queryOptions.enabled()
-        }
+    cloneDeepUnref(queries).map((queryOptions) => {
+      if (typeof queryOptions.enabled === 'function') {
+        queryOptions.enabled = queryOptions.enabled()
+      }
 
-        const defaulted = client.defaultQueryOptions(queryOptions)
-        defaulted._optimisticResults = client.isRestoring.value
-          ? 'isRestoring'
-          : 'optimistic'
+      const defaulted = client.defaultQueryOptions(queryOptions)
+      defaulted._optimisticResults = client.isRestoring.value
+        ? 'isRestoring'
+        : 'optimistic'
 
-        return defaulted
-      },
-    ),
+      return defaulted
+    }),
   )
 
   const observer = new QueriesObserver<TCombinedResult>(
