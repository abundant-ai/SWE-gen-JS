diff --git a/.changeset/five-walls-approve.md b/.changeset/five-walls-approve.md
new file mode 100644
index 0000000000..9193469d5c
--- /dev/null
+++ b/.changeset/five-walls-approve.md
@@ -0,0 +1,27 @@
+---
+'@xstate/store': major
+---
+
+The `createStore` function now only accepts a single configuration object argument. This is a breaking change that simplifies the API and aligns with the configuration pattern used throughout XState.
+
+```ts
+// Before
+// createStore(
+//   {
+//     count: 0
+//   },
+//   {
+//     increment: (context) => ({ count: context.count + 1 })
+//   }
+// );
+
+// After
+createStore({
+  context: {
+    count: 0
+  },
+  on: {
+    increment: (context) => ({ count: context.count + 1 })
+  }
+});
+```
diff --git a/.changeset/great-candles-rule.md b/.changeset/great-candles-rule.md
new file mode 100644
index 0000000000..c3233a0b2d
--- /dev/null
+++ b/.changeset/great-candles-rule.md
@@ -0,0 +1,24 @@
+---
+'@xstate/store': major
+---
+
+You can now enqueue effects in state transitions.
+
+```ts
+const store = createStore({
+  context: {
+    count: 0
+  },
+  on: {
+    incrementDelayed: (context, event, enq) => {
+      enq.effect(async () => {
+        await new Promise((resolve) => setTimeout(resolve, 1000));
+        store.send({ type: 'increment' });
+      });
+
+      return context;
+    },
+    increment: (context) => ({ count: context.count + 1 })
+  }
+});
+```
diff --git a/.changeset/mean-taxis-jump.md b/.changeset/mean-taxis-jump.md
new file mode 100644
index 0000000000..54bd1c7420
--- /dev/null
+++ b/.changeset/mean-taxis-jump.md
@@ -0,0 +1,17 @@
+---
+'@xstate/store': major
+---
+
+The `fromStore(config)` function now only supports a single config object argument.
+
+```ts
+const storeLogic = fromStore({
+  context: (input: { initialCount: number }) => ({ count: input.initialCount }),
+  on: {
+    inc: (ctx, ev: { by: number }) => ({
+      ...ctx,
+      count: ctx.count + ev.by
+    })
+  }
+});
+```
diff --git a/.changeset/quick-bears-swim.md b/.changeset/quick-bears-swim.md
new file mode 100644
index 0000000000..830fc10e16
--- /dev/null
+++ b/.changeset/quick-bears-swim.md
@@ -0,0 +1,24 @@
+---
+'@xstate/store': minor
+---
+
+Added `store.trigger` API for sending events with a fluent interface:
+
+```ts
+const store = createStore({
+  context: { count: 0 },
+  on: {
+    increment: (ctx, event: { by: number }) => ({
+      count: ctx.count + event.by
+    })
+  }
+});
+
+// Instead of manually constructing event objects:
+store.send({ type: 'increment', by: 5 });
+
+// You can now use the fluent trigger API:
+store.trigger.increment({ by: 5 });
+```
+
+The `trigger` API provides full type safety for event names and payloads, making it easier and safer to send events to the store.
diff --git a/.changeset/spotty-moose-joke.md b/.changeset/spotty-moose-joke.md
new file mode 100644
index 0000000000..1a6fbf15e5
--- /dev/null
+++ b/.changeset/spotty-moose-joke.md
@@ -0,0 +1,32 @@
+---
+'@xstate/store': major
+---
+
+The `createStoreWithProducer(…)` function now only accepts two arguments: a `producer` and a config (`{ context, on }`) object.
+
+```ts
+// Before
+// createStoreWithProducer(
+//   producer,
+//   {
+//     count: 0
+//   },
+//   {
+//     increment: (context) => {
+//       context.count++;
+//     }
+//   }
+// );
+
+// After
+createStoreWithProducer(producer, {
+  context: {
+    count: 0
+  },
+  on: {
+    increment: (context) => {
+      context.count++;
+    }
+  }
+});
+```
diff --git a/.changeset/thick-paws-invite.md b/.changeset/thick-paws-invite.md
new file mode 100644
index 0000000000..ea9cd7668e
--- /dev/null
+++ b/.changeset/thick-paws-invite.md
@@ -0,0 +1,19 @@
+---
+'@xstate/store': major
+---
+
+Only complete assigner functions that replace the `context` fully are supported. This is a breaking change that simplifies the API and provides more type safety.
+
+```diff
+const store = createStore({
+  context: {
+    items: [],
+    count: 0
+  },
+  on: {
+-   increment: { count: (context) => context.count + 1 }
+-   increment: (context) => ({ count: context.count + 1 })
++   increment: (context) => ({ ...context, count: context.count + 1 })
+  }
+})
+```
diff --git a/.changeset/wise-bikes-leave.md b/.changeset/wise-bikes-leave.md
new file mode 100644
index 0000000000..0f5b7a9e0b
--- /dev/null
+++ b/.changeset/wise-bikes-leave.md
@@ -0,0 +1,24 @@
+---
+'@xstate/store': major
+---
+
+Emitted event types are now specified in functions on the `emits` property of the store definition:
+
+```ts
+const store = createStore({
+  // …
+  emits: {
+    increased: (payload: { upBy: number }) => {
+      // You can execute a side-effect here
+      // or leave it empty
+    }
+  },
+  on: {
+    inc: (ctx, ev: { by: number }, enq) => {
+      enq.emit.increased({ upBy: ev.by });
+
+      // …
+    }
+  }
+});
+```
diff --git a/packages/xstate-store/src/fromStore.ts b/packages/xstate-store/src/fromStore.ts
index 5469e4b9ea..551a48335c 100644
--- a/packages/xstate-store/src/fromStore.ts
+++ b/packages/xstate-store/src/fromStore.ts
@@ -1,4 +1,4 @@
-import { ActorLogic, Cast } from 'xstate';
+import { ActorLogic } from 'xstate';
 import { createStoreTransition, TransitionsFromEventPayloadMap } from './store';
 import {
   EventPayloadMap,
@@ -6,9 +6,8 @@ import {
   Snapshot,
   StoreSnapshot,
   EventObject,
-  ExtractEventsFromPayloadMap,
-  StoreAssigner,
-  StorePropertyAssigner
+  ExtractEvents,
+  StoreAssigner
 } from './types';
 
 type StoreLogic<
@@ -18,34 +17,6 @@ type StoreLogic<
   TEmitted extends EventObject
 > = ActorLogic<StoreSnapshot<TContext>, TEvent, TInput, any, TEmitted>;
 
-/**
- * An actor logic creator which creates store [actor
- * logic](https://stately.ai/docs/actors#actor-logic) for use with XState.
- *
- * @param initialContext The initial context for the store, either a function
- *   that returns context based on input, or the context itself
- * @param transitions The transitions object defining how the context updates
- *   due to events
- * @returns An actor logic creator function that creates store actor logic
- */
-export function fromStore<
-  TContext extends StoreContext,
-  TEventPayloadMap extends EventPayloadMap,
-  TInput
->(
-  initialContext: ((input: TInput) => TContext) | TContext,
-  transitions: TransitionsFromEventPayloadMap<
-    TEventPayloadMap,
-    NoInfer<TContext>,
-    EventObject
-  >
-): StoreLogic<
-  TContext,
-  ExtractEventsFromPayloadMap<TEventPayloadMap>,
-  TInput,
-  EventObject
->;
-
 /**
  * An actor logic creator which creates store [actor
  * logic](https://stately.ai/docs/actors#actor-logic) for use with XState.
@@ -54,97 +25,54 @@ export function fromStore<
  * @param config.context The initial context for the store, either a function
  *   that returns context based on input, or the context itself
  * @param config.on An object defining the transitions for different event types
- * @param config.types Optional object to define custom event types
+ * @param config.emits Optional object to define emitted event handlers
  * @returns An actor logic creator function that creates store actor logic
  */
 export function fromStore<
   TContext extends StoreContext,
   TEventPayloadMap extends EventPayloadMap,
   TInput,
-  TTypes extends { emitted?: EventObject }
->(
-  config: {
-    context: ((input: TInput) => TContext) | TContext;
-    on: {
-      [K in keyof TEventPayloadMap & string]:
-        | StoreAssigner<
-            NoInfer<TContext>,
-            { type: K } & TEventPayloadMap[K],
-            Cast<TTypes['emitted'], EventObject>
-          >
-        | StorePropertyAssigner<
-            NoInfer<TContext>,
-            { type: K } & TEventPayloadMap[K],
-            Cast<TTypes['emitted'], EventObject>
-          >;
-    };
-  } & { types?: TTypes }
-): StoreLogic<
-  TContext,
-  ExtractEventsFromPayloadMap<TEventPayloadMap>,
-  TInput,
-  TTypes['emitted'] extends EventObject ? TTypes['emitted'] : EventObject
->;
-export function fromStore<
-  TContext extends StoreContext,
-  TEventPayloadMap extends EventPayloadMap,
-  TInput,
-  TTypes extends { emitted?: EventObject }
->(
-  initialContextOrObj:
-    | ((input: TInput) => TContext)
-    | TContext
-    | ({
-        context: ((input: TInput) => TContext) | TContext;
-        on: {
-          [K in keyof TEventPayloadMap & string]:
-            | StoreAssigner<
-                NoInfer<TContext>,
-                { type: K } & TEventPayloadMap[K],
-                Cast<TTypes['emitted'], EventObject>
-              >
-            | StorePropertyAssigner<
-                NoInfer<TContext>,
-                { type: K } & TEventPayloadMap[K],
-                Cast<TTypes['emitted'], EventObject>
-              >;
-        };
-      } & { types?: TTypes }),
-  transitions?: TransitionsFromEventPayloadMap<
-    TEventPayloadMap,
-    NoInfer<TContext>,
-    EventObject
-  >
-): StoreLogic<
+  TEmitted extends EventPayloadMap
+>(config: {
+  context: ((input: TInput) => TContext) | TContext;
+  on: {
+    [K in keyof TEventPayloadMap & string]: StoreAssigner<
+      NoInfer<TContext>,
+      { type: K } & TEventPayloadMap[K],
+      ExtractEvents<TEmitted>
+    >;
+  };
+  emits?: {
+    [K in keyof TEmitted & string]: (
+      payload: { type: K } & TEmitted[K]
+    ) => void;
+  };
+}): StoreLogic<
   TContext,
-  ExtractEventsFromPayloadMap<TEventPayloadMap>,
+  ExtractEvents<TEventPayloadMap>,
   TInput,
-  TTypes['emitted'] extends EventObject ? TTypes['emitted'] : EventObject
+  ExtractEvents<TEmitted>
 > {
-  let initialContext: ((input: TInput) => TContext) | TContext;
-  let transitionsObj: TransitionsFromEventPayloadMap<
+  const initialContext: ((input: TInput) => TContext) | TContext =
+    config.context;
+  const transitionsObj: TransitionsFromEventPayloadMap<
     TEventPayloadMap,
     NoInfer<TContext>,
     EventObject
-  >;
-
-  if (
-    typeof initialContextOrObj === 'object' &&
-    'context' in initialContextOrObj
-  ) {
-    initialContext = initialContextOrObj.context;
-    transitionsObj = initialContextOrObj.on;
-  } else {
-    initialContext = initialContextOrObj;
-    transitionsObj = transitions!;
-  }
+  > = config.on;
 
   const transition = createStoreTransition(transitionsObj);
   return {
     transition: (snapshot, event, actorScope) => {
-      const [nextSnapshot, emittedEvents] = transition(snapshot, event);
+      const [nextSnapshot, effects] = transition(snapshot, event);
 
-      emittedEvents.forEach(actorScope.emit);
+      for (const effect of effects) {
+        if (typeof effect === 'function') {
+          effect();
+        } else {
+          actorScope.emit(effect as ExtractEvents<TEmitted>);
+        }
+      }
 
       return nextSnapshot;
     },
diff --git a/packages/xstate-store/src/store.ts b/packages/xstate-store/src/store.ts
index 6a651d58be..57ff25ca1e 100644
--- a/packages/xstate-store/src/store.ts
+++ b/packages/xstate-store/src/store.ts
@@ -1,19 +1,17 @@
 import {
-  Cast,
   EnqueueObject,
   EventObject,
   EventPayloadMap,
-  ExtractEventsFromPayloadMap,
+  ExtractEvents,
   InteropSubscribable,
   Observer,
   Recipe,
   Store,
   StoreAssigner,
-  StoreCompleteAssigner,
   StoreContext,
+  StoreEffect,
   StoreInspectionEvent,
-  StorePartialAssigner,
-  StorePropertyAssigner,
+  StoreProducerAssigner,
   StoreSnapshot
 } from './types';
 
@@ -38,6 +36,13 @@ function toObserver<T>(
   };
 }
 
+/**
+ * Updates a context object using a recipe function.
+ *
+ * @param context - The current context
+ * @param recipe - A function that describes how to update the context
+ * @returns The updated context
+ */
 function setter<TContext extends StoreContext>(
   context: TContext,
   recipe: Recipe<TContext, TContext>
@@ -57,24 +62,18 @@ function createStoreCore<
 >(
   initialContext: TContext,
   transitions: {
-    [K in keyof TEventPayloadMap & string]:
-      | StoreAssigner<
-          NoInfer<TContext>,
-          { type: K } & TEventPayloadMap[K],
-          TEmitted
-        >
-      | StorePropertyAssigner<
-          NoInfer<TContext>,
-          { type: K } & TEventPayloadMap[K],
-          TEmitted
-        >;
+    [K in keyof TEventPayloadMap & string]: StoreAssigner<
+      NoInfer<TContext>,
+      { type: K } & TEventPayloadMap[K],
+      TEmitted
+    >;
   },
-  updater?: (
+  producer?: (
     context: NoInfer<TContext>,
-    recipe: (context: NoInfer<TContext>) => NoInfer<TContext>
+    recipe: (context: NoInfer<TContext>) => void
   ) => NoInfer<TContext>
-): Store<TContext, ExtractEventsFromPayloadMap<TEventPayloadMap>, TEmitted> {
-  type StoreEvent = ExtractEventsFromPayloadMap<TEventPayloadMap>;
+): Store<TContext, ExtractEvents<TEventPayloadMap>, TEmitted> {
+  type StoreEvent = ExtractEvents<TEventPayloadMap>;
   let observers: Set<Observer<StoreSnapshot<TContext>>> | undefined;
   let listeners: Map<TEmitted['type'], Set<any>> | undefined;
   const initialSnapshot: StoreSnapshot<TContext> = {
@@ -96,11 +95,11 @@ function createStoreCore<
     }
   };
 
-  const transition = createStoreTransition(transitions, updater);
+  const transition = createStoreTransition(transitions, producer);
 
   function receive(event: StoreEvent) {
-    let emitted: TEmitted[];
-    [currentSnapshot, emitted] = transition(currentSnapshot, event);
+    let effects: StoreEffect<TEmitted>[];
+    [currentSnapshot, effects] = transition(currentSnapshot, event);
 
     inspectionObservers.get(store)?.forEach((observer) => {
       observer.next?.({
@@ -114,7 +113,13 @@ function createStoreCore<
 
     observers?.forEach((o) => o.next?.(currentSnapshot));
 
-    emitted.forEach(emit);
+    for (const effect of effects) {
+      if (typeof effect === 'function') {
+        effect();
+      } else {
+        emit(effect);
+      }
+    }
   }
 
   const store: Store<TContext, StoreEvent, TEmitted> = {
@@ -196,7 +201,17 @@ function createStoreCore<
           return inspectionObservers.get(store)?.delete(observer);
         }
       };
-    }
+    },
+    trigger: new Proxy({} as Store<TContext, StoreEvent, TEmitted>['trigger'], {
+      get: (_, eventType: string) => {
+        return (payload: any) => {
+          store.send({
+            type: eventType,
+            ...payload
+          });
+        };
+      }
+    })
   };
 
   return store;
@@ -207,23 +222,41 @@ export type TransitionsFromEventPayloadMap<
   TContext extends StoreContext,
   TEmitted extends EventObject
 > = {
-  [K in keyof TEventPayloadMap & string]:
-    | StoreAssigner<
-        TContext,
-        {
-          type: K;
-        } & TEventPayloadMap[K],
-        TEmitted
-      >
-    | StorePropertyAssigner<
-        TContext,
-        {
-          type: K;
-        } & TEventPayloadMap[K],
-        TEmitted
-      >;
+  [K in keyof TEventPayloadMap & string]: StoreAssigner<
+    TContext,
+    {
+      type: K;
+    } & TEventPayloadMap[K],
+    TEmitted
+  >;
 };
 
+type CreateStoreParameterTypes<
+  TContext extends StoreContext,
+  TEventPayloadMap extends EventPayloadMap,
+  TEmitted extends EventPayloadMap
+> = [
+  definition: {
+    context: TContext;
+    emits?: {
+      [K in keyof TEmitted & string]: (payload: TEmitted[K]) => void;
+    };
+    on: {
+      [K in keyof TEventPayloadMap & string]: StoreAssigner<
+        NoInfer<TContext>,
+        { type: K } & TEventPayloadMap[K],
+        ExtractEvents<TEmitted>
+      >;
+    };
+  }
+];
+
+type CreateStoreReturnType<
+  TContext extends StoreContext,
+  TEventPayloadMap extends EventPayloadMap,
+  TEmitted extends EventPayloadMap
+> = Store<TContext, ExtractEvents<TEventPayloadMap>, ExtractEvents<TEmitted>>;
+
 /**
  * Creates a **store** that has its own internal state and can be sent events
  * that update its internal state based on transitions.
@@ -232,16 +265,11 @@ export type TransitionsFromEventPayloadMap<
  *
  * ```ts
  * const store = createStore({
- *   types: {
- *     // ...
- *   },
  *   context: { count: 0 },
  *   on: {
- *     inc: (context, event: { by: number }) => {
- *       return {
- *         count: context.count + event.by
- *       };
- *     }
+ *     inc: (context, event: { by: number }) => ({
+ *       count: context.count + event.by
+ *     })
  *   }
  * });
  *
@@ -252,86 +280,47 @@ export type TransitionsFromEventPayloadMap<
  * store.send({ type: 'inc', by: 5 });
  * // Logs { context: { count: 5 }, status: 'active', ... }
  * ```
- */
-export function createStore<
-  TContext extends StoreContext,
-  TEventPayloadMap extends EventPayloadMap,
-  TTypes extends { emitted?: EventObject }
->({
-  context,
-  on,
-  types
-}: {
-  context: TContext;
-  on: {
-    [K in keyof TEventPayloadMap & string]:
-      | StoreAssigner<
-          NoInfer<TContext>,
-          { type: K } & TEventPayloadMap[K],
-          Cast<TTypes['emitted'], EventObject>
-        >
-      | StorePropertyAssigner<
-          NoInfer<TContext>,
-          { type: K } & TEventPayloadMap[K],
-          Cast<TTypes['emitted'], EventObject>
-        >;
-  };
-} & { types?: TTypes }): Store<
-  TContext,
-  ExtractEventsFromPayloadMap<TEventPayloadMap>,
-  Cast<TTypes['emitted'], EventObject>
->;
-
-/**
- * Creates a **store** that has its own internal state and can be sent events
- * that update its internal state based on transitions.
- *
- * @example
- *
- * ```ts
- * const store = createStore(
- *   // Initial context
- *   { count: 0 },
- *   // Transitions
- *   {
- *     inc: (context, event: { by: number }) => {
- *       return {
- *         count: context.count + event.by
- *       };
- *     }
- *   }
- * );
- *
- * store.subscribe((snapshot) => {
- *   console.log(snapshot);
- * });
  *
- * store.send({ type: 'inc', by: 5 });
- * // Logs { context: { count: 5 }, status: 'active', ... }
- * ```
+ * @param config - The store configuration object
+ * @param config.context - The initial state of the store
+ * @param config.on - An object mapping event types to transition functions
+ * @returns A store instance with methods to send events and subscribe to state
+ *   changes
  */
-export function createStore<
+function _createStore<
   TContext extends StoreContext,
-  TEventPayloadMap extends EventPayloadMap
+  TEventPayloadMap extends EventPayloadMap,
+  TEmitted extends EventPayloadMap
 >(
-  initialContext: TContext,
-  transitions: TransitionsFromEventPayloadMap<
-    TEventPayloadMap,
+  ...[{ context, on }]: CreateStoreParameterTypes<
     TContext,
-    EventObject
+    TEventPayloadMap,
+    TEmitted
   >
-): Store<TContext, ExtractEventsFromPayloadMap<TEventPayloadMap>, EventObject>;
-
-export function createStore(initialContextOrObject: any, transitions?: any) {
-  if (transitions === undefined) {
-    return createStoreCore(
-      initialContextOrObject.context,
-      initialContextOrObject.on
-    );
-  }
-  return createStoreCore(initialContextOrObject, transitions);
+): CreateStoreReturnType<TContext, TEventPayloadMap, TEmitted> {
+  return createStoreCore(context, on);
 }
 
+export const createStore: {
+  // those overloads are exactly the same, we only duplicate them so TypeScript can:
+  // 1. assign contextual parameter types during inference attempt for the first overload when the source object is still context-sensitive and often non-inferrable
+  // 2. infer correctly during inference attempt for the second overload when the parameter types are already "known"
+  <
+    TContext extends StoreContext,
+    TEventPayloadMap extends EventPayloadMap,
+    TEmitted extends EventPayloadMap
+  >(
+    ...args: CreateStoreParameterTypes<TContext, TEventPayloadMap, TEmitted>
+  ): CreateStoreReturnType<TContext, TEventPayloadMap, TEmitted>;
+  <
+    TContext extends StoreContext,
+    TEventPayloadMap extends EventPayloadMap,
+    TEmitted extends EventPayloadMap
+  >(
+    ...args: CreateStoreParameterTypes<TContext, TEventPayloadMap, TEmitted>
+  ): CreateStoreReturnType<TContext, TEventPayloadMap, TEmitted>;
+} = _createStore;
+
 /**
  * Creates a `Store` with a provided producer (such as Immer's `producer(…)` A
  * store has its own internal state and can receive events.
@@ -342,14 +331,10 @@ export function createStore(initialContextOrObject: any, transitions?: any) {
  * import { produce } from 'immer';
  *
  * const store = createStoreWithProducer(produce, {
- *   // Initial context
- *   { count: 0 },
- *   // Transitions
- *   {
- *     on: {
- *       inc: (context, event: { by: number }) => {
- *         context.count += event.by;
- *       }
+ *   context: { count: 0 },
+ *   on: {
+ *     inc: (context, event: { by: number }) => {
+ *       context.count += event.by;
  *     }
  *   }
  * });
@@ -365,7 +350,7 @@ export function createStore(initialContextOrObject: any, transitions?: any) {
 export function createStoreWithProducer<
   TContext extends StoreContext,
   TEventPayloadMap extends EventPayloadMap,
-  TEmitted extends EventObject = EventObject
+  TEmittedPayloadMap extends EventPayloadMap
 >(
   producer: NoInfer<
     (context: TContext, recipe: (context: TContext) => void) => TContext
@@ -376,53 +361,16 @@ export function createStoreWithProducer<
       [K in keyof TEventPayloadMap & string]: (
         context: NoInfer<TContext>,
         event: { type: K } & TEventPayloadMap[K],
-        enqueue: EnqueueObject<TEmitted>
+        enqueue: EnqueueObject<ExtractEvents<TEmittedPayloadMap>>
       ) => void;
     };
   }
-): Store<TContext, ExtractEventsFromPayloadMap<TEventPayloadMap>, TEmitted>;
-export function createStoreWithProducer<
-  TContext extends StoreContext,
-  TEventPayloadMap extends EventPayloadMap,
-  TEmitted extends EventObject = EventObject
->(
-  producer: NoInfer<
-    (context: TContext, recipe: (context: TContext) => void) => TContext
-  >,
-  initialContext: TContext,
-  transitions: {
-    [K in keyof TEventPayloadMap & string]: (
-      context: NoInfer<TContext>,
-      event: { type: K } & TEventPayloadMap[K],
-      enqueue: EnqueueObject<TEmitted>
-    ) => void;
-  }
-): Store<TContext, ExtractEventsFromPayloadMap<TEventPayloadMap>, TEmitted>;
-
-export function createStoreWithProducer<
-  TContext extends StoreContext,
-  TEventPayloadMap extends EventPayloadMap,
-  TEmitted extends EventObject = EventObject
->(
-  producer: (
-    context: TContext,
-    recipe: (context: TContext) => void
-  ) => TContext,
-  initialContextOrConfig: any,
-  transitions?: any
-): Store<TContext, ExtractEventsFromPayloadMap<TEventPayloadMap>, TEmitted> {
-  if (
-    typeof initialContextOrConfig === 'object' &&
-    'context' in initialContextOrConfig &&
-    'on' in initialContextOrConfig
-  ) {
-    return createStoreCore(
-      initialContextOrConfig.context,
-      initialContextOrConfig.on,
-      producer
-    );
-  }
-  return createStoreCore(initialContextOrConfig, transitions, producer);
+): Store<
+  TContext,
+  ExtractEvents<TEventPayloadMap>,
+  ExtractEvents<TEmittedPayloadMap>
+> {
+  return createStoreCore(config.context, config.on, producer);
 }
 
 declare global {
@@ -432,12 +380,14 @@ declare global {
 }
 
 /**
- * Creates a store function, which is a function that accepts the current
- * snapshot and an event and returns a new snapshot.
+ * Creates a store transition function that handles state updates based on
+ * events.
  *
- * @param transitions
- * @param updater
- * @returns
+ * @param transitions - An object mapping event types to transition functions
+ * @param producer - Optional producer function (e.g., Immer's produce) for
+ *   immutable updates
+ * @returns A transition function that takes a snapshot and event and returns a
+ *   new snapshot with effects
  */
 export function createStoreTransition<
   TContext extends StoreContext,
@@ -445,44 +395,54 @@ export function createStoreTransition<
   TEmitted extends EventObject
 >(
   transitions: {
-    [K in keyof TEventPayloadMap & string]:
-      | StoreAssigner<TContext, { type: K } & TEventPayloadMap[K], TEmitted>
-      | StorePropertyAssigner<
-          TContext,
-          { type: K } & TEventPayloadMap[K],
-          TEmitted
-        >;
+    [K in keyof TEventPayloadMap & string]: StoreAssigner<
+      TContext,
+      { type: K } & TEventPayloadMap[K],
+      TEmitted
+    >;
   },
-  updater?: (
+  producer?: (
     context: TContext,
-    recipe: (context: TContext) => TContext
+    recipe: (context: TContext) => void
   ) => TContext
 ) {
   return (
     snapshot: StoreSnapshot<TContext>,
-    event: ExtractEventsFromPayloadMap<TEventPayloadMap>
-  ): [StoreSnapshot<TContext>, TEmitted[]] => {
-    type StoreEvent = ExtractEventsFromPayloadMap<TEventPayloadMap>;
+    event: ExtractEvents<TEventPayloadMap>
+  ): [StoreSnapshot<TContext>, StoreEffect<TEmitted>[]] => {
+    type StoreEvent = ExtractEvents<TEventPayloadMap>;
     let currentContext = snapshot.context;
     const assigner = transitions?.[event.type as StoreEvent['type']];
-    const emitted: TEmitted[] = [];
-
-    const enqueue = {
-      emit: (ev: TEmitted) => {
-        emitted.push(ev);
+    const effects: StoreEffect<TEmitted>[] = [];
+
+    const enqueue: EnqueueObject<TEmitted> = {
+      emit: new Proxy({} as any, {
+        get: (_, eventType: string) => {
+          return (payload: any) => {
+            effects.push({
+              type: eventType,
+              ...payload
+            });
+          };
+        }
+      }),
+      effect: (fn) => {
+        effects.push(fn);
       }
     };
 
     if (!assigner) {
-      return [snapshot, emitted];
+      return [snapshot, effects];
     }
 
     if (typeof assigner === 'function') {
-      currentContext = updater
-        ? updater(currentContext, (draftContext) =>
-            (
-              assigner as StoreCompleteAssigner<TContext, StoreEvent, TEmitted>
-            )?.(draftContext, event, enqueue)
+      currentContext = producer
+        ? producer(currentContext, (draftContext) =>
+            (assigner as StoreProducerAssigner<TContext, StoreEvent, TEmitted>)(
+              draftContext,
+              event,
+              enqueue
+            )
           )
         : setter(currentContext, (draftContext) =>
             Object.assign(
@@ -501,24 +461,25 @@ export function createStoreTransition<
         const propAssignment = assigner[key];
         partialUpdate[key] =
           typeof propAssignment === 'function'
-            ? (
-                propAssignment as StorePartialAssigner<
-                  TContext,
-                  StoreEvent,
-                  typeof key,
-                  TEmitted
-                >
-              )(currentContext, event, enqueue)
+            ? (propAssignment as StoreAssigner<TContext, StoreEvent, TEmitted>)(
+                currentContext,
+                event,
+                enqueue
+              )
             : propAssignment;
       }
       currentContext = Object.assign({}, currentContext, partialUpdate);
     }
 
-    return [{ ...snapshot, context: currentContext }, emitted];
+    return [{ ...snapshot, context: currentContext }, effects];
   };
 }
 
-// create a unique 6-char id
+/**
+ * Generates a unique 6-character identifier.
+ *
+ * @returns A random string identifier
+ */
 function uniqueId() {
   return Math.random().toString(36).slice(6);
 }
diff --git a/packages/xstate-store/src/types.ts b/packages/xstate-store/src/types.ts
index 23b90758b8..edff42361e 100644
--- a/packages/xstate-store/src/types.ts
+++ b/packages/xstate-store/src/types.ts
@@ -1,15 +1,20 @@
 export type EventPayloadMap = Record<string, {} | null | undefined>;
 
-export type ExtractEventsFromPayloadMap<T extends EventPayloadMap> = Values<{
+export type ExtractEvents<T extends EventPayloadMap> = Values<{
   [K in keyof T & string]: T[K] & { type: K };
 }>;
 
 export type Recipe<T, TReturn> = (state: T) => TReturn;
 
-export type EnqueueObject<TEmitted extends EventObject> = {
-  emit: (ev: TEmitted) => void;
+export type EnqueueObject<TEmittedEvent extends EventObject> = {
+  emit: {
+    [E in TEmittedEvent as E['type']]: (payload: Omit<E, 'type'>) => void;
+  };
+  effect: (fn: () => void) => void;
 };
 
+export type StoreEffect<TEmitted extends EventObject> = (() => void) | TEmitted;
+
 export type StoreAssigner<
   TContext extends StoreContext,
   TEvent extends EventObject,
@@ -18,31 +23,13 @@ export type StoreAssigner<
   context: TContext,
   event: TEvent,
   enq: EnqueueObject<TEmitted>
-) => Partial<TContext>;
-export type StoreCompleteAssigner<
-  TContext,
-  TEvent extends EventObject,
-  TEmitted extends EventObject
-> = (ctx: TContext, ev: TEvent, enq: EnqueueObject<TEmitted>) => TContext;
-export type StorePartialAssigner<
-  TContext,
-  TEvent extends EventObject,
-  K extends keyof TContext,
-  TEmitted extends EventObject
-> = (
-  ctx: TContext,
-  ev: TEvent,
-  enq: EnqueueObject<TEmitted>
-) => Partial<TContext>[K];
-export type StorePropertyAssigner<
-  TContext,
+) => TContext | void;
+
+export type StoreProducerAssigner<
+  TContext extends StoreContext,
   TEvent extends EventObject,
   TEmitted extends EventObject
-> = {
-  [K in keyof TContext]?:
-    | TContext[K]
-    | StorePartialAssigner<TContext, TEvent, K, TEmitted>;
-};
+> = (context: TContext, event: TEvent, enq: EnqueueObject<TEmitted>) => void;
 
 export type Snapshot<TOutput> =
   | {
@@ -105,8 +92,29 @@ export interface Store<
       ev: Compute<TEmitted & { type: TEmittedType }>
     ) => void
   ) => Subscription;
+  /**
+   * A proxy object that allows you to send events to the store without manually
+   * constructing event objects.
+   *
+   * @example
+   *
+   * ```ts
+   * // Equivalent to:
+   * // store.send({ type: 'increment', by: 1 });
+   * store.trigger.increment({ by: 1 });
+   * ```
+   */
+  trigger: {
+    [E in TEvent as E['type'] & string]: IsEmptyObject<
+      Omit<E, 'type'>
+    > extends true
+      ? () => Omit<E, 'type'>
+      : (eventPayload: Omit<E, 'type'>) => void;
+  };
 }
 
+export type IsEmptyObject<T> = T extends Record<string, never> ? true : false;
+
 export type AnyStore = Store<any, any, any>;
 
 export type Compute<A> = { [K in keyof A]: A[K] };
@@ -300,3 +308,7 @@ export type ActorRefLike = {
 export type Prop<T, K> = K extends keyof T ? T[K] : never;
 
 export type Cast<A, B> = A extends B ? A : B;
+
+export type EventMap<TEvent extends EventObject> = {
+  [E in TEvent as E['type']]: E;
+};
