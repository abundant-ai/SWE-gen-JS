diff --git a/packages/angular-query-experimental/package.json b/packages/angular-query-experimental/package.json
index 02afc6b66..cd4361d9e 100644
--- a/packages/angular-query-experimental/package.json
+++ b/packages/angular-query-experimental/package.json
@@ -94,7 +94,6 @@
     "@angular/core": "^20.0.0",
     "@angular/platform-browser": "^20.0.0",
     "@tanstack/query-test-utils": "workspace:*",
-    "@testing-library/angular": "^18.0.0",
     "eslint-plugin-jsdoc": "^50.5.0",
     "npm-run-all2": "^5.0.0",
     "vite-plugin-dts": "4.2.3",
diff --git a/packages/angular-query-experimental/src/__tests__/inject-queries.test-d.ts b/packages/angular-query-experimental/src/__tests__/inject-queries.test-d.ts
deleted file mode 100644
index 62547fd9e..000000000
--- a/packages/angular-query-experimental/src/__tests__/inject-queries.test-d.ts
+++ /dev/null
@@ -1,177 +0,0 @@
-import { describe, expectTypeOf, it } from 'vitest'
-import { skipToken } from '..'
-import { injectQueries } from '../inject-queries'
-import { queryOptions } from '../query-options'
-import type { CreateQueryOptions, CreateQueryResult, OmitKeyof } from '..'
-import type { Signal } from '@angular/core'
-
-describe('InjectQueries config object overload', () => {
-  it('TData should always be defined when initialData is provided as an object', () => {
-    const query1 = {
-      queryKey: ['key1'],
-      queryFn: () => {
-        return {
-          wow: true,
-        }
-      },
-      initialData: {
-        wow: false,
-      },
-    }
-
-    const query2 = {
-      queryKey: ['key2'],
-      queryFn: () => 'Query Data',
-      initialData: 'initial data',
-    }
-
-    const query3 = {
-      queryKey: ['key2'],
-      queryFn: () => 'Query Data',
-    }
-
-    const queryResults = injectQueries(() => ({
-      queries: [query1, query2, query3],
-    }))
-
-    const query1Data = queryResults()[0].data()
-    const query2Data = queryResults()[1].data()
-    const query3Data = queryResults()[2].data()
-
-    expectTypeOf(query1Data).toEqualTypeOf<{ wow: boolean }>()
-    expectTypeOf(query2Data).toEqualTypeOf<string>()
-    expectTypeOf(query3Data).toEqualTypeOf<string | undefined>()
-  })
-
-  it('TData should be defined when passed through queryOptions', () => {
-    const options = queryOptions({
-      queryKey: ['key'],
-      queryFn: () => {
-        return {
-          wow: true,
-        }
-      },
-      initialData: {
-        wow: true,
-      },
-    })
-    const queryResults = injectQueries(() => ({ queries: [options] }))
-
-    const data = queryResults()[0].data()
-
-    expectTypeOf(data).toEqualTypeOf<{ wow: boolean }>()
-  })
-
-  it('should be possible to define a different TData than TQueryFnData using select with queryOptions spread into injectQuery', () => {
-    const query1 = queryOptions({
-      queryKey: ['key'],
-      queryFn: () => Promise.resolve(1),
-      select: (data) => data > 1,
-    })
-
-    const query2 = {
-      queryKey: ['key'],
-      queryFn: () => Promise.resolve(1),
-      select: (data: number) => data > 1,
-    }
-
-    const queryResults = injectQueries(() => ({ queries: [query1, query2] }))
-    const query1Data = queryResults()[0].data()
-    const query2Data = queryResults()[1].data()
-
-    expectTypeOf(query1Data).toEqualTypeOf<boolean | undefined>()
-    expectTypeOf(query2Data).toEqualTypeOf<boolean | undefined>()
-  })
-
-  it('TData should have undefined in the union when initialData is provided as a function which can return undefined', () => {
-    const queryResults = injectQueries(() => ({
-      queries: [
-        {
-          queryKey: ['key'],
-          queryFn: () => {
-            return {
-              wow: true,
-            }
-          },
-          initialData: () => undefined as { wow: boolean } | undefined,
-        },
-      ],
-    }))
-
-    const data = queryResults()[0].data()
-
-    expectTypeOf(data).toEqualTypeOf<{ wow: boolean } | undefined>()
-  })
-
-  describe('custom injectable', () => {
-    it('should allow custom hooks using UseQueryOptions', () => {
-      type Data = string
-
-      const injectCustomQueries = (
-        options?: OmitKeyof<CreateQueryOptions<Data>, 'queryKey' | 'queryFn'>,
-      ) => {
-        return injectQueries(() => ({
-          queries: [
-            {
-              ...options,
-              queryKey: ['todos-key'],
-              queryFn: () => Promise.resolve('data'),
-            },
-          ],
-        }))
-      }
-
-      const queryResults = injectCustomQueries()
-      const data = queryResults()[0].data()
-
-      expectTypeOf(data).toEqualTypeOf<Data | undefined>()
-    })
-  })
-
-  it('TData should have correct type when conditional skipToken is passed', () => {
-    const queryResults = injectQueries(() => ({
-      queries: [
-        {
-          queryKey: ['withSkipToken'],
-          queryFn: Math.random() > 0.5 ? skipToken : () => Promise.resolve(5),
-        },
-      ],
-    }))
-
-    const firstResult = queryResults()[0]
-
-    expectTypeOf(firstResult).toEqualTypeOf<CreateQueryResult<number, Error>>()
-    expectTypeOf(firstResult.data()).toEqualTypeOf<number | undefined>()
-  })
-
-  it('should return correct data for dynamic queries with mixed result types', () => {
-    const Queries1 = {
-      get: () =>
-        queryOptions({
-          queryKey: ['key1'],
-          queryFn: () => Promise.resolve(1),
-        }),
-    }
-    const Queries2 = {
-      get: () =>
-        queryOptions({
-          queryKey: ['key2'],
-          queryFn: () => Promise.resolve(true),
-        }),
-    }
-
-    const queries1List = [1, 2, 3].map(() => ({ ...Queries1.get() }))
-    const result = injectQueries(() => ({
-      queries: [...queries1List, { ...Queries2.get() }],
-    }))
-
-    expectTypeOf(result).branded.toEqualTypeOf<
-      Signal<
-        [
-          ...Array<CreateQueryResult<number, Error>>,
-          CreateQueryResult<boolean, Error>,
-        ]
-      >
-    >()
-  })
-})
diff --git a/packages/angular-query-experimental/src/__tests__/inject-queries.test.ts b/packages/angular-query-experimental/src/__tests__/inject-queries.test.ts
deleted file mode 100644
index 3fb3d5a62..000000000
--- a/packages/angular-query-experimental/src/__tests__/inject-queries.test.ts
+++ /dev/null
@@ -1,79 +0,0 @@
-import { beforeEach, describe, expect, it } from 'vitest'
-import { render } from '@testing-library/angular'
-import {
-  Component,
-  effect,
-  provideZonelessChangeDetection,
-} from '@angular/core'
-import { TestBed } from '@angular/core/testing'
-import { queryKey } from '@tanstack/query-test-utils'
-import { QueryClient, provideTanStackQuery } from '..'
-import { injectQueries } from '../inject-queries'
-
-let queryClient: QueryClient
-
-beforeEach(() => {
-  queryClient = new QueryClient()
-  TestBed.configureTestingModule({
-    providers: [
-      provideZonelessChangeDetection(),
-      provideTanStackQuery(queryClient),
-    ],
-  })
-})
-
-describe('injectQueries', () => {
-  it('should return the correct states', async () => {
-    const key1 = queryKey()
-    const key2 = queryKey()
-    const results: Array<Array<Record<string, any>>> = []
-
-    @Component({
-      template: `
-        <div>
-          <div>
-            data1: {{ result()[0].data() ?? 'null' }}, data2:
-            {{ result()[1].data() ?? 'null' }}
-          </div>
-        </div>
-      `,
-    })
-    class Page {
-      toString(val: any) {
-        return String(val)
-      }
-      result = injectQueries(() => ({
-        queries: [
-          {
-            queryKey: key1,
-            queryFn: async () => {
-              await new Promise((r) => setTimeout(r, 10))
-              return 1
-            },
-          },
-          {
-            queryKey: key2,
-            queryFn: async () => {
-              await new Promise((r) => setTimeout(r, 100))
-              return 2
-            },
-          },
-        ],
-      }))
-
-      _pushResults = effect(() => {
-        const snapshot = this.result().map((q) => ({ data: q.data() }))
-        results.push(snapshot)
-      })
-    }
-
-    const rendered = await render(Page)
-
-    await rendered.findByText('data1: 1, data2: 2')
-
-    expect(results.length).toBe(3)
-    expect(results[0]).toMatchObject([{ data: undefined }, { data: undefined }])
-    expect(results[1]).toMatchObject([{ data: 1 }, { data: undefined }])
-    expect(results[2]).toMatchObject([{ data: 1 }, { data: 2 }])
-  })
-})
diff --git a/packages/angular-query-experimental/src/inject-queries.ts b/packages/angular-query-experimental/src/inject-queries.ts
index 2b7707158..0cbcf3fb6 100644
--- a/packages/angular-query-experimental/src/inject-queries.ts
+++ b/packages/angular-query-experimental/src/inject-queries.ts
@@ -13,10 +13,9 @@ import {
   inject,
   runInInjectionContext,
   signal,
-  untracked,
 } from '@angular/core'
-import { signalProxy } from './signal-proxy'
 import { injectIsRestoring } from './inject-is-restoring'
+import type { Signal } from '@angular/core'
 import type {
   DefaultError,
   OmitKeyof,
@@ -25,24 +24,19 @@ import type {
   QueryFunction,
   QueryKey,
   QueryObserverOptions,
+  QueryObserverResult,
   ThrowOnError,
 } from '@tanstack/query-core'
-import type {
-  CreateQueryOptions,
-  CreateQueryResult,
-  DefinedCreateQueryResult,
-} from './types'
-import type { Signal } from '@angular/core'
 
 // This defines the `CreateQueryOptions` that are accepted in `QueriesOptions` & `GetOptions`.
-// `placeholderData` function always gets undefined passed
+// `placeholderData` function does not have a parameter
 type QueryObserverOptionsForCreateQueries<
   TQueryFnData = unknown,
   TError = DefaultError,
   TData = TQueryFnData,
   TQueryKey extends QueryKey = QueryKey,
 > = OmitKeyof<
-  CreateQueryOptions<TQueryFnData, TError, TData, TQueryKey>,
+  QueryObserverOptions<TQueryFnData, TError, TData, TQueryFnData, TQueryKey>,
   'placeholderData'
 > & {
   placeholderData?: TQueryFnData | QueriesPlaceholderDataFunction<TQueryFnData>
@@ -52,9 +46,9 @@ type QueryObserverOptionsForCreateQueries<
 type MAXIMUM_DEPTH = 20
 
 // Widen the type of the symbol to enable type inference even if skipToken is not immutable.
-type SkipTokenForCreateQueries = symbol
+type SkipTokenForUseQueries = symbol
 
-type GetCreateQueryOptionsForCreateQueries<T> =
+type GetOptions<T> =
   // Part 1: responsible for applying explicit type parameter to function arguments, if object { queryFnData: TQueryFnData, error: TError, data: TData }
   T extends {
     queryFnData: infer TQueryFnData
@@ -77,8 +71,8 @@ type GetCreateQueryOptionsForCreateQueries<T> =
                 T extends {
                     queryFn?:
                       | QueryFunction<infer TQueryFnData, infer TQueryKey>
-                      | SkipTokenForCreateQueries
-                    select?: (data: any) => infer TData
+                      | SkipTokenForUseQueries
+                    select: (data: any) => infer TData
                     throwOnError?: ThrowOnError<any, infer TError, any, any>
                   }
                 ? QueryObserverOptionsForCreateQueries<
@@ -90,71 +84,53 @@ type GetCreateQueryOptionsForCreateQueries<T> =
                 : // Fallback
                   QueryObserverOptionsForCreateQueries
 
-// A defined initialData setting should return a DefinedCreateQueryResult rather than CreateQueryResult
-type GetDefinedOrUndefinedQueryResult<T, TData, TError = unknown> = T extends {
-  initialData?: infer TInitialData
-}
-  ? unknown extends TInitialData
-    ? CreateQueryResult<TData, TError>
-    : TInitialData extends TData
-      ? DefinedCreateQueryResult<TData, TError>
-      : TInitialData extends () => infer TInitialDataResult
-        ? unknown extends TInitialDataResult
-          ? CreateQueryResult<TData, TError>
-          : TInitialDataResult extends TData
-            ? DefinedCreateQueryResult<TData, TError>
-            : CreateQueryResult<TData, TError>
-        : CreateQueryResult<TData, TError>
-  : CreateQueryResult<TData, TError>
-
-type GetCreateQueryResult<T> =
+type GetResults<T> =
   // Part 1: responsible for mapping explicit type parameter to function result, if object
   T extends { queryFnData: any; error?: infer TError; data: infer TData }
-    ? GetDefinedOrUndefinedQueryResult<T, TData, TError>
+    ? QueryObserverResult<TData, TError>
     : T extends { queryFnData: infer TQueryFnData; error?: infer TError }
-      ? GetDefinedOrUndefinedQueryResult<T, TQueryFnData, TError>
+      ? QueryObserverResult<TQueryFnData, TError>
       : T extends { data: infer TData; error?: infer TError }
-        ? GetDefinedOrUndefinedQueryResult<T, TData, TError>
+        ? QueryObserverResult<TData, TError>
         : // Part 2: responsible for mapping explicit type parameter to function result, if tuple
           T extends [any, infer TError, infer TData]
-          ? GetDefinedOrUndefinedQueryResult<T, TData, TError>
+          ? QueryObserverResult<TData, TError>
           : T extends [infer TQueryFnData, infer TError]
-            ? GetDefinedOrUndefinedQueryResult<T, TQueryFnData, TError>
+            ? QueryObserverResult<TQueryFnData, TError>
             : T extends [infer TQueryFnData]
-              ? GetDefinedOrUndefinedQueryResult<T, TQueryFnData>
+              ? QueryObserverResult<TQueryFnData>
               : // Part 3: responsible for mapping inferred type to results, if no explicit parameter was provided
                 T extends {
                     queryFn?:
                       | QueryFunction<infer TQueryFnData, any>
-                      | SkipTokenForCreateQueries
-                    select?: (data: any) => infer TData
+                      | SkipTokenForUseQueries
+                    select: (data: any) => infer TData
                     throwOnError?: ThrowOnError<any, infer TError, any, any>
                   }
-                ? GetDefinedOrUndefinedQueryResult<
-                    T,
+                ? QueryObserverResult<
                     unknown extends TData ? TQueryFnData : TData,
                     unknown extends TError ? DefaultError : TError
                   >
                 : // Fallback
-                  CreateQueryResult
+                  QueryObserverResult
 
 /**
  * QueriesOptions reducer recursively unwraps function arguments to infer/enforce type param
  */
 export type QueriesOptions<
   T extends Array<any>,
-  TResults extends Array<any> = [],
+  TResult extends Array<any> = [],
   TDepth extends ReadonlyArray<number> = [],
 > = TDepth['length'] extends MAXIMUM_DEPTH
   ? Array<QueryObserverOptionsForCreateQueries>
   : T extends []
     ? []
     : T extends [infer Head]
-      ? [...TResults, GetCreateQueryOptionsForCreateQueries<Head>]
-      : T extends [infer Head, ...infer Tails]
+      ? [...TResult, GetOptions<Head>]
+      : T extends [infer Head, ...infer Tail]
         ? QueriesOptions<
-            [...Tails],
-            [...TResults, GetCreateQueryOptionsForCreateQueries<Head>],
+            [...Tail],
+            [...TResult, GetOptions<Head>],
             [...TDepth, 1]
           >
         : ReadonlyArray<unknown> extends T
@@ -185,44 +161,55 @@ export type QueriesOptions<
  */
 export type QueriesResults<
   T extends Array<any>,
-  TResults extends Array<any> = [],
+  TResult extends Array<any> = [],
   TDepth extends ReadonlyArray<number> = [],
 > = TDepth['length'] extends MAXIMUM_DEPTH
-  ? Array<CreateQueryResult>
+  ? Array<QueryObserverResult>
   : T extends []
     ? []
     : T extends [infer Head]
-      ? [...TResults, GetCreateQueryResult<Head>]
-      : T extends [infer Head, ...infer Tails]
+      ? [...TResult, GetResults<Head>]
+      : T extends [infer Head, ...infer Tail]
         ? QueriesResults<
-            [...Tails],
-            [...TResults, GetCreateQueryResult<Head>],
+            [...Tail],
+            [...TResult, GetResults<Head>],
             [...TDepth, 1]
           >
-        : { [K in keyof T]: GetCreateQueryResult<T[K]> }
-
-export interface InjectQueriesOptions<
-  T extends Array<any>,
-  TCombinedResult = QueriesResults<T>,
-> {
-  queries:
-    | readonly [...QueriesOptions<T>]
-    | readonly [
-        ...{ [K in keyof T]: GetCreateQueryOptionsForCreateQueries<T[K]> },
-      ]
-  combine?: (result: QueriesResults<T>) => TCombinedResult
-}
+        : T extends Array<
+              QueryObserverOptionsForCreateQueries<
+                infer TQueryFnData,
+                infer TError,
+                infer TData,
+                any
+              >
+            >
+          ? // Dynamic-size (homogenous) CreateQueryOptions array: map directly to array of results
+            Array<
+              QueryObserverResult<
+                unknown extends TData ? TQueryFnData : TData,
+                unknown extends TError ? DefaultError : TError
+              >
+            >
+          : // Fallback
+            Array<QueryObserverResult>
 
 /**
- * @param optionsFn - A function that returns queries' options.
- * @param injector - The Angular injector to use.
- * @public
+ * @param root0
+ * @param root0.queries
+ * @param root0.combine
+ * @param injector
  */
 export function injectQueries<
   T extends Array<any>,
   TCombinedResult = QueriesResults<T>,
 >(
-  optionsFn: () => InjectQueriesOptions<T, TCombinedResult>,
+  {
+    queries,
+    ...options
+  }: {
+    queries: Signal<[...QueriesOptions<T>]>
+    combine?: (result: QueriesResults<T>) => TCombinedResult
+  },
   injector?: Injector,
 ): Signal<TCombinedResult> {
   !injector && assertInInjectionContext(injectQueries)
@@ -232,21 +219,9 @@ export function injectQueries<
     const queryClient = inject(QueryClient)
     const isRestoring = injectIsRestoring()
 
-    /**
-     * Signal that has the default options from query client applied
-     * computed() is used so signals can be inserted into the options
-     * making it reactive. Wrapping options in a function ensures embedded expressions
-     * are preserved and can keep being applied after signal changes
-     */
-    const optionsSignal = computed(() => {
-      return optionsFn()
-    })
-
     const defaultedQueries = computed(() => {
-      return optionsSignal().queries.map((opts) => {
-        const defaultedOptions = queryClient.defaultQueryOptions(
-          opts as QueryObserverOptions,
-        )
+      return queries().map((opts) => {
+        const defaultedOptions = queryClient.defaultQueryOptions(opts)
         // Make sure the results are already in fetching state before subscribing or updating options
         defaultedOptions._optimisticResults = isRestoring()
           ? 'isRestoring'
@@ -256,76 +231,37 @@ export function injectQueries<
       })
     })
 
-    const observerSignal = (() => {
-      let instance: QueriesObserver<TCombinedResult> | null = null
-
-      return computed(() => {
-        return (instance ||= new QueriesObserver<TCombinedResult>(
-          queryClient,
-          defaultedQueries(),
-          optionsSignal() as QueriesObserverOptions<TCombinedResult>,
-        ))
-      })
-    })()
-
-    const optimisticResultSignal = computed(() =>
-      observerSignal().getOptimisticResult(
-        defaultedQueries(),
-        (optionsSignal() as QueriesObserverOptions<TCombinedResult>).combine,
-      ),
+    const observer = new QueriesObserver<TCombinedResult>(
+      queryClient,
+      defaultedQueries(),
+      options as QueriesObserverOptions<TCombinedResult>,
     )
 
     // Do not notify on updates because of changes in the options because
     // these changes should already be reflected in the optimistic result.
     effect(() => {
-      observerSignal().setQueries(
+      observer.setQueries(
         defaultedQueries(),
-        optionsSignal() as QueriesObserverOptions<TCombinedResult>,
+        options as QueriesObserverOptions<TCombinedResult>,
       )
     })
 
-    const optimisticCombinedResultSignal = computed(() => {
-      const [_optimisticResult, getCombinedResult, trackResult] =
-        optimisticResultSignal()
-      return getCombinedResult(trackResult())
-    })
+    const [, getCombinedResult] = observer.getOptimisticResult(
+      defaultedQueries(),
+      (options as QueriesObserverOptions<TCombinedResult>).combine,
+    )
 
-    const resultFromSubscriberSignal = signal<TCombinedResult | null>(null)
+    const result = signal(getCombinedResult() as any)
 
     effect(() => {
-      const observer = observerSignal()
-      const [_optimisticResult, getCombinedResult] = optimisticResultSignal()
-
-      untracked(() => {
-        const unsubscribe = isRestoring()
-          ? () => undefined
-          : ngZone.runOutsideAngular(() =>
-              observer.subscribe(
-                notifyManager.batchCalls((state) => {
-                  resultFromSubscriberSignal.set(getCombinedResult(state))
-                }),
-              ),
-            )
-
-        destroyRef.onDestroy(unsubscribe)
-      })
-    })
-
-    const resultSignal = computed(() => {
-      const subscriberResult = resultFromSubscriberSignal()
-      const optimisticResult = optimisticCombinedResultSignal()
-      return subscriberResult ?? optimisticResult
-    })
-
-    return computed(() => {
-      const result = resultSignal()
-      const { combine } = optionsSignal()
-
-      return combine
-        ? result
-        : (result as QueriesResults<T>).map((query) =>
-            signalProxy(signal(query)),
+      const unsubscribe = isRestoring()
+        ? () => undefined
+        : ngZone.runOutsideAngular(() =>
+            observer.subscribe(notifyManager.batchCalls(result.set)),
           )
+      destroyRef.onDestroy(unsubscribe)
     })
-  }) as unknown as Signal<TCombinedResult>
+
+    return result
+  })
 }
diff --git a/packages/angular-query-persist-client/package.json b/packages/angular-query-persist-client/package.json
index 07e696119..3f455949c 100644
--- a/packages/angular-query-persist-client/package.json
+++ b/packages/angular-query-persist-client/package.json
@@ -64,7 +64,7 @@
     "@angular/platform-browser": "^20.0.0",
     "@tanstack/angular-query-experimental": "workspace:*",
     "@tanstack/query-test-utils": "workspace:*",
-    "@testing-library/angular": "^18.0.0",
+    "@testing-library/angular": "^17.3.7",
     "@testing-library/dom": "^10.4.0",
     "eslint-plugin-jsdoc": "^50.5.0",
     "npm-run-all2": "^5.0.0"
diff --git a/pnpm-lock.yaml b/pnpm-lock.yaml
index 95b617072..17e425726 100644
--- a/pnpm-lock.yaml
+++ b/pnpm-lock.yaml
@@ -2260,9 +2260,6 @@ importers:
       '@tanstack/query-test-utils':
         specifier: workspace:*
         version: link:../query-test-utils
-      '@testing-library/angular':
-        specifier: ^18.0.0
-        version: 18.0.0(b638270d50b9f611fb362719c9f1adf5)
       eslint-plugin-jsdoc:
         specifier: ^50.5.0
         version: 50.5.0(eslint@9.29.0(jiti@2.4.2))
@@ -2312,8 +2309,8 @@ importers:
         specifier: workspace:*
         version: link:../query-test-utils
       '@testing-library/angular':
-        specifier: ^18.0.0
-        version: 18.0.0(b638270d50b9f611fb362719c9f1adf5)
+        specifier: ^17.3.7
+        version: 17.3.7(44e06ac0fb247039d3919c909462d711)
       '@testing-library/dom':
         specifier: ^10.4.0
         version: 10.4.0
@@ -6597,13 +6594,14 @@ packages:
     resolution: {integrity: sha512-WpL1C9iR5/U7g3GpvHIssN5QvKnDnWhW05BQhaD6bAqoPCkQyBepxUF8ZRO4IGZRGVAZeMVqTbUA05BAQH/88g==}
     engines: {node: '>=18'}
 
-  '@testing-library/angular@18.0.0':
-    resolution: {integrity: sha512-0seNMa4ql2I3VD7CtnI9i4sFgxEgRES+EtGid8H4MTuOK/dlj457mVk8tWdFjPQPC/cPromcUNw0is1ogO3DSA==}
+  '@testing-library/angular@17.3.7':
+    resolution: {integrity: sha512-99Wf/06CCyBP3rmIu+WacUTGZMDKTQR12phe1lUMrknwxHLFUf5jn230L/mW4XIZ+ThDJ/4D6OzhVskbOYDqig==}
     peerDependencies:
-      '@angular/common': '>= 20.0.0'
-      '@angular/core': '>= 20.0.0'
-      '@angular/platform-browser': '>= 20.0.0'
-      '@angular/router': '>= 20.0.0'
+      '@angular/animations': '>= 17.0.0'
+      '@angular/common': '>= 17.0.0'
+      '@angular/core': '>= 17.0.0'
+      '@angular/platform-browser': '>= 17.0.0'
+      '@angular/router': '>= 17.0.0'
       '@testing-library/dom': ^10.0.0
 
   '@testing-library/dom@10.4.0':
@@ -19890,8 +19888,9 @@ snapshots:
       - typescript
       - vite
 
-  '@testing-library/angular@18.0.0(b638270d50b9f611fb362719c9f1adf5)':
+  '@testing-library/angular@17.3.7(44e06ac0fb247039d3919c909462d711)':
     dependencies:
+      '@angular/animations': 20.0.0(@angular/common@20.0.0(@angular/core@20.0.0(@angular/compiler@20.0.0)(rxjs@7.8.2)(zone.js@0.15.0))(rxjs@7.8.2))(@angular/core@20.0.0(@angular/compiler@20.0.0)(rxjs@7.8.2)(zone.js@0.15.0))
       '@angular/common': 20.0.0(@angular/core@20.0.0(@angular/compiler@20.0.0)(rxjs@7.8.2)(zone.js@0.15.0))(rxjs@7.8.2)
       '@angular/core': 20.0.0(@angular/compiler@20.0.0)(rxjs@7.8.2)(zone.js@0.15.0)
       '@angular/platform-browser': 20.0.0(@angular/animations@20.0.0(@angular/common@20.0.0(@angular/core@20.0.0(@angular/compiler@20.0.0)(rxjs@7.8.2)(zone.js@0.15.0))(rxjs@7.8.2))(@angular/core@20.0.0(@angular/compiler@20.0.0)(rxjs@7.8.2)(zone.js@0.15.0)))(@angular/common@20.0.0(@angular/core@20.0.0(@angular/compiler@20.0.0)(rxjs@7.8.2)(zone.js@0.15.0))(rxjs@7.8.2))(@angular/core@20.0.0(@angular/compiler@20.0.0)(rxjs@7.8.2)(zone.js@0.15.0))
