diff --git a/package.json b/package.json
index 0b118e3..844a72d 100644
--- a/package.json
+++ b/package.json
@@ -9,6 +9,7 @@
   "react-native": "dist/immer.module.js",
   "types": "./dist/immer.d.ts",
   "scripts": {
+    "watch": "jest --watch",
     "test": "jest",
     "test:perf": "yarn-or-npm build && node --expose-gc node_modules/jest-cli/bin/jest.js --verbose --testRegex '__performance_tests__/.*?js$'",
     "test:flow": "yarn-or-npm flow check",
diff --git a/readme.md b/readme.md
index 701f167..889a614 100644
--- a/readme.md
+++ b/readme.md
@@ -1,11 +1,6 @@
 # Immer
 
-[![npm](https://img.shields.io/npm/v/immer.svg)](https://www.npmjs.com/package/immer)
-[![size](http://img.badgesize.io/https://cdn.jsdelivr.net/npm/immer/dist/immer.umd.js?compression=gzip)](http://img.badgesize.io/https://cdn.jsdelivr.net/npm/immer/dist/immer.umd.js)
-[![Build Status](https://travis-ci.org/mweststrate/immer.svg?branch=master)](https://travis-ci.org/mweststrate/immer)
-[![Coverage Status](https://coveralls.io/repos/github/mweststrate/immer/badge.svg?branch=master)](https://coveralls.io/github/mweststrate/immer?branch=master)
-[![code style: prettier](https://img.shields.io/badge/code_style-prettier-ff69b4.svg)](https://github.com/prettier/prettier)
-[![Donate](https://img.shields.io/badge/Donate-PayPal-green.svg)](https://www.paypal.me/michelweststrate)
+[![npm](https://img.shields.io/npm/v/immer.svg)](https://www.npmjs.com/package/immer) [![size](http://img.badgesize.io/https://cdn.jsdelivr.net/npm/immer/dist/immer.umd.js?compression=gzip)](http://img.badgesize.io/https://cdn.jsdelivr.net/npm/immer/dist/immer.umd.js) [![Build Status](https://travis-ci.org/mweststrate/immer.svg?branch=master)](https://travis-ci.org/mweststrate/immer) [![Coverage Status](https://coveralls.io/repos/github/mweststrate/immer/badge.svg?branch=master)](https://coveralls.io/github/mweststrate/immer?branch=master) [![code style: prettier](https://img.shields.io/badge/code_style-prettier-ff69b4.svg)](https://github.com/prettier/prettier) [![Donate](https://img.shields.io/badge/Donate-PayPal-green.svg)](https://www.paypal.me/michelweststrate)
 
 _Create the next immutable state tree by simply modifying the current tree_
 
@@ -14,20 +9,17 @@ _Create the next immutable state tree by simply modifying the current tree_
 * NPM: `npm install immer`
 * Yarn: `yarn add immer`
 * CDN: Exposed global is `immer`
-    * Unpkg: `<script src="https://unpkg.com/immer/dist/immer.umd.js"></script>`
-    * JSDelivr: `<script src="https://cdn.jsdelivr.net/npm/immer/dist/immer.umd.js"></script>`
+  * Unpkg: `<script src="https://unpkg.com/immer/dist/immer.umd.js"></script>`
+  * JSDelivr: `<script src="https://cdn.jsdelivr.net/npm/immer/dist/immer.umd.js"></script>`
 
 ---
 
 * Egghead lesson covering all of immer (7m): [Simplify creating immutable data trees with Immer](https://egghead.io/lessons/redux-simplify-creating-immutable-data-trees-with-immer)
 * Introduction blogpost: [Immer: Immutability the easy way](https://medium.com/@mweststrate/introducing-immer-immutability-the-easy-way-9d73d8f71cb3)
 
-Immer (German for: always) is a tiny package that allows you to work with immutable state in a more convenient way.
-It is based on the [_copy-on-write_](https://en.wikipedia.org/wiki/Copy-on-write) mechanism.
+Immer (German for: always) is a tiny package that allows you to work with immutable state in a more convenient way. It is based on the [_copy-on-write_](https://en.wikipedia.org/wiki/Copy-on-write) mechanism.
 
-The basic idea is that you will apply all your changes to a temporarily _draftState_, which is a proxy of the _currentState_.
-Once all your mutations are completed, Immer will produce the _nextState_ based on the mutations to the draft state.
-This means that you can interact with your data by simply modifying it, while keeping all the benefits of immutable data.
+The basic idea is that you will apply all your changes to a temporarily _draftState_, which is a proxy of the _currentState_. Once all your mutations are completed, Immer will produce the _nextState_ based on the mutations to the draft state. This means that you can interact with your data by simply modifying it, while keeping all the benefits of immutable data.
 
 ![immer-hd.png](images/hd/immer.png)
 
@@ -60,7 +52,7 @@ const baseState = [
 ]
 
 const nextState = produce(baseState, draftState => {
-    draftState.push({ todo: "Tweet about it" })
+    draftState.push({todo: "Tweet about it"})
     draftState[1].done = true
 })
 ```
@@ -103,56 +95,53 @@ Here is a simple example of the difference that Immer could make in practice.
 // Redux reducer
 // Shortened, based on: https://github.com/reactjs/redux/blob/master/examples/shopping-cart/src/reducers/products.js
 const byId = (state, action) => {
-  switch (action.type) {
-    case RECEIVE_PRODUCTS:
-      return {
-        ...state,
-        ...action.products.reduce((obj, product) => {
-          obj[product.id] = product
-          return obj
-        }, {})
-      }
-    default:
-      return state
-  }
+    switch (action.type) {
+        case RECEIVE_PRODUCTS:
+            return {
+                ...state,
+                ...action.products.reduce((obj, product) => {
+                    obj[product.id] = product
+                    return obj
+                }, {})
+            }
+        default:
+            return state
+    }
 }
 ```
 
 After using Immer, that simply becomes:
 
 ```javascript
-import produce from 'immer'
+import produce from "immer"
 
 const byId = (state, action) =>
-  produce(state, draft => {
-    switch (action.type) {
-      case RECEIVE_PRODUCTS:
-        action.products.forEach(product => {
-          draft[product.id] = product
-        })
-    }
-  })
+    produce(state, draft => {
+        switch (action.type) {
+            case RECEIVE_PRODUCTS:
+                action.products.forEach(product => {
+                    draft[product.id] = product
+                })
+        }
+    })
 ```
 
 Notice that it is not needed to handle the default case, a producer that doesn't do anything will simply return the original state.
 
-Creating Redux reducer is just a sample application of the Immer package.
-Immer is not just designed to simplify Redux reducers.
-It can be used in any context where you have an immutable data tree that you want to clone and modify (with structural sharing).
+Creating Redux reducer is just a sample application of the Immer package. Immer is not just designed to simplify Redux reducers. It can be used in any context where you have an immutable data tree that you want to clone and modify (with structural sharing).
 
 _Note: it might be tempting after using producers for a while, to just place `produce` in your root reducer and then pass the draft to each reducer and work directly over such draft. Don't do that. It kills the point of Redux where each reducer is testable as pure reducer. Immer is best used when applying it to small individual pieces of logic._
 
 ## React.setState example
 
-Deep updates in the state of React components can be greatly simplified as well by using immer.
-Take for example the following onClick handlers (Try in [codesandbox](https://codesandbox.io/s/m4yp57632j)):
+Deep updates in the state of React components can be greatly simplified as well by using immer. Take for example the following onClick handlers (Try in [codesandbox](https://codesandbox.io/s/m4yp57632j)):
 
 ```javascript
 /**
  * Classic React.setState with a deep merge
  */
 onBirthDayClick1 = () => {
-    this.setState((prevState)=>({
+    this.setState(prevState => ({
         user: {
             ...prevState.user,
             age: prevState.user.age + 1
@@ -163,18 +152,19 @@ onBirthDayClick1 = () => {
 /**
  * ...But, since setState accepts functions,
  * we can just create a curried producer and further simplify!
-*/
+ */
 onBirthDayClick2 = () => {
-    this.setState(produce(draft => {
-        draft.user.age += 1
-    }))
+    this.setState(
+        produce(draft => {
+            draft.user.age += 1
+        })
+    )
 }
 ```
 
 ## Currying
 
-Passing a function as the first argument to `produce` is intended to be used for currying. This means that you get a pre-bound producer that only needs a state to produce the value from.
-The producer function gets passed in the draft, and any further arguments that were passed to the curried function.
+Passing a function as the first argument to `produce` is intended to be used for currying. This means that you get a pre-bound producer that only needs a state to produce the value from. The producer function gets passed in the draft, and any further arguments that were passed to the curried function.
 
 For example:
 
@@ -211,73 +201,66 @@ Note that `state` is now factored out (the created reducer will accept a state,
 If you want to initialize an uninitialized state using this construction, you can do so by passing the initial state as second argument to `produce`:
 
 ```javascript
-import produce from 'immer'
+import produce from "immer"
 
 const byId = produce(
-  (draft, action) => {
-    switch (action.type) {
-      case RECEIVE_PRODUCTS:
-        action.products.forEach(product => {
-          draft[product.id] = product
-        })
-        return
+    (draft, action) => {
+        switch (action.type) {
+            case RECEIVE_PRODUCTS:
+                action.products.forEach(product => {
+                    draft[product.id] = product
+                })
+                return
+        }
+    },
+    {
+        1: {id: 1, name: "product-1"}
     }
-  },
-  {
-    1: { id: 1, name: "product-1" }
-  }
 )
 ```
 
 ## Auto freezing
 
- Immer automatically freezes any state trees that are modified using `produce`.
- This protects against accidental modifications of the state tree outside of a producer.
- This comes with a performance impact, so it is recommended to disable this option in production.
- It is by default enabled.
- By default it is turned on during local development, and turned off in production.
- Use `setAutoFreeze(true / false)` to explicitly turn this feature on or off.
+Immer automatically freezes any state trees that are modified using `produce`. This protects against accidental modifications of the state tree outside of a producer. This comes with a performance impact, so it is recommended to disable this option in production. It is by default enabled. By default it is turned on during local development, and turned off in production. Use `setAutoFreeze(true / false)` to explicitly turn this feature on or off.
 
 ## Returning data from producers
 
-It is not needed to return anything from a producer, as Immer will return the (finalized) version of the `draft` anyway.
-However, it is allowed to just `return draft`.
+It is not needed to return anything from a producer, as Immer will return the (finalized) version of the `draft` anyway. However, it is allowed to just `return draft`.
 
-It is also allowed to return arbitrarily other data from the producer function. But _only_ if you didn't modify the draft.
-This can be useful to produce an entirely new state. Some examples:
+It is also allowed to return arbitrarily other data from the producer function. But _only_ if you didn't modify the draft. This can be useful to produce an entirely new state. Some examples:
 
 ```javascript
 const userReducer = produce((draft, action) => {
-  switch (action.type) {
-    case "renameUser":
-      // OK: we modify the current state
-      draft.users[action.payload.id].name = action.payload.name
-      return draft // same as just 'return'
-    case "loadUsers":
-      // OK: we return an entirely new state
-      return action.payload
-    case "adduser-1":
-      // NOT OK: This doesn't do change the draft nor return a new state!
-      // It doesn't modify the draft (it just redeclares it)
-      // In fact, this just doesn't do anything at all
-      draft = { users: [...draft.users, action.payload]}
-      return
-    case "adduser-2":
-      // NOT OK: modifying draft *and* returning a new state
-      draft.userCount += 1
-      return { users: [...draft.users, action.payload] }
-    case "adduser-3":
-      // OK: returning a new state. But, unnecessary complex and expensive
-      return {
-        userCount: draft.userCount + 1,
-        users: [...draft.users, action.payload]
-      }
-    case "adduser-4":
-      // OK: the immer way
-      draft.userCount += 1
-      draft.users.push(action.payload)
-      return
-  }
+    switch (action.type) {
+        case "renameUser":
+            // OK: we modify the current state
+            draft.users[action.payload.id].name = action.payload.name
+            return draft // same as just 'return'
+        case "loadUsers":
+            // OK: we return an entirely new state
+            return action.payload
+        case "adduser-1":
+            // NOT OK: This doesn't do change the draft nor return a new state!
+            // It doesn't modify the draft (it just redeclares it)
+            // In fact, this just doesn't do anything at all
+            draft = {users: [...draft.users, action.payload]}
+            return
+        case "adduser-2":
+            // NOT OK: modifying draft *and* returning a new state
+            draft.userCount += 1
+            return {users: [...draft.users, action.payload]}
+        case "adduser-3":
+            // OK: returning a new state. But, unnecessary complex and expensive
+            return {
+                userCount: draft.userCount + 1,
+                users: [...draft.users, action.payload]
+            }
+        case "adduser-4":
+            // OK: the immer way
+            draft.userCount += 1
+            draft.users.push(action.payload)
+            return
+    }
 })
 ```
 
@@ -288,16 +271,16 @@ The recipe will be always invoked with the `draft` as `this` context.
 This means that the following constructions are also valid:
 
 ```javascript
-const base = { counter: 0 }
+const base = {counter: 0}
 
 const next = produce(base, function() {
-  this.counter++
+    this.counter++
 })
 console.log(next.counter) // 1
 
 // OR
 const increment = produce(function() {
-  this.counter++
+    this.counter++
 })
 console.log(increment(base).counter) // 1
 ```
@@ -308,19 +291,16 @@ The Immer package ships with type definitions inside the package, which should b
 
 ## Immer on older JavaScript environments?
 
-By default `produce` tries to use proxies for optimal performance.
-However, on older JavaScript engines `Proxy` is not available.
-For example, when running Microsoft Internet Explorer or React Native on Android.
-In such cases Immer will fallback to an ES5 compatible implementation which works identical, but is a bit slower.
+By default `produce` tries to use proxies for optimal performance. However, on older JavaScript engines `Proxy` is not available. For example, when running Microsoft Internet Explorer or React Native on Android. In such cases Immer will fallback to an ES5 compatible implementation which works identical, but is a bit slower.
 
 ## Pitfalls
 
 1. Don't redefine draft like, `draft = myCoolNewState`. Instead, either modify the `draft` or return a new state. See [Returning data from producers](#returning-data-from-producers).
 1. Currently, Immer only supports plain objects and arrays. PRs are welcome for more language built-in types like `Map` and `Set`.
-2. Immer only processes native arrays and plain objects (with a prototype of `null` or `Object`). Any other type of value will be treated verbatim! So if you modify a `Map` or `Buffer` (or whatever complex object from the draft state), the changes will be persisted. But, both in your new and old state! So, in such cases, make sure to always produce fresh instances if you want to keep your state truly immutable.
-3. For example, working with `Date` objects is no problem, just make sure you never modify them (by using methods like `setYear` on an existing instance). Instead, always create fresh `Date` instances. Which is probably what you were unconsciously doing already.
-4. Since Immer uses proxies, reading huge amounts of data from state comes with an overhead (especially in the ES5 implementation). If this ever becomes an issue (measure before you optimize!), do the current state analysis before entering the producer function or read from the `currentState` rather than the `draftState`
-5. Some debuggers (at least Node 6 is known) have trouble debugging when Proxies are in play. Node 8 is known to work correctly.
+1. Immer only processes native arrays and plain objects (with a prototype of `null` or `Object`). Any other type of value will be treated verbatim! So if you modify a `Map` or `Buffer` (or whatever complex object from the draft state), the changes will be persisted. But, both in your new and old state! So, in such cases, make sure to always produce fresh instances if you want to keep your state truly immutable.
+1. For example, working with `Date` objects is no problem, just make sure you never modify them (by using methods like `setYear` on an existing instance). Instead, always create fresh `Date` instances. Which is probably what you were unconsciously doing already.
+1. Since Immer uses proxies, reading huge amounts of data from state comes with an overhead (especially in the ES5 implementation). If this ever becomes an issue (measure before you optimize!), do the current state analysis before entering the producer function or read from the `currentState` rather than the `draftState`
+1. Some debuggers (at least Node 6 is known) have trouble debugging when Proxies are in play. Node 8 is known to work correctly.
 
 ## Cool things built with immer
 
@@ -339,65 +319,63 @@ Read the (second part of the) [introduction blog](https://medium.com/@mweststrat
 _For those who have to go back to thinking in object updates :-)_
 
 ```javascript
-import produce from "immer";
+import produce from "immer"
 
 // object mutations
 const todosObj = {
-  id1: { done: false, body: "Take out the trash" },
-  id2: { done: false, body: "Check Email" }
-};
+    id1: {done: false, body: "Take out the trash"},
+    id2: {done: false, body: "Check Email"}
+}
 
 // add
 const addedTodosObj = produce(todosObj, draft => {
-  draft["id3"] = { done: false, body: "Buy bananas" };
-});
+    draft["id3"] = {done: false, body: "Buy bananas"}
+})
 
 // delete
 const deletedTodosObj = produce(todosObj, draft => {
-  delete draft["id1"];
-});
+    delete draft["id1"]
+})
 
 // update
 const updatedTodosObj = produce(todosObj, draft => {
-  draft["id1"].done = true;
-});
+    draft["id1"].done = true
+})
 
 // array mutations
 const todosArray = [
-  { id: "id1", done: false, body: "Take out the trash" },
-  { id: "id2", done: false, body: "Check Email" }
-];
+    {id: "id1", done: false, body: "Take out the trash"},
+    {id: "id2", done: false, body: "Check Email"}
+]
 
 // add
 const addedTodosArray = produce(todosArray, draft => {
-  draft.push({ id: "id3", done: false, body: "Buy bananas" });
-});
+    draft.push({id: "id3", done: false, body: "Buy bananas"})
+})
 
 // delete
 const deletedTodosArray = produce(todosArray, draft => {
-  draft.splice(draft.findIndex(todo => todo.id === "id1"), 1);
-  // or (slower):
-  // return draft.filter(todo => todo.id !== "id1")
-});
+    draft.splice(draft.findIndex(todo => todo.id === "id1"), 1)
+    // or (slower):
+    // return draft.filter(todo => todo.id !== "id1")
+})
 
 // update
 const updatedTodosArray = produce(todosArray, draft => {
-  draft[draft.findIndex(todo => todo.id === "id1")].done = true;
-});
+    draft[draft.findIndex(todo => todo.id === "id1")].done = true
+})
 ```
 
 ## Performance
 
-Here is a [simple benchmark](__performance_tests__/todo.js) on the performance of Immer.
-This test takes 100.000 todo items, and updates 10.000 of them.
-_Freeze_ indicates that the state tree has been frozen after producing it. This is a _development_ best practice, as it prevents developers from accidentally modifying the state tree.
+Here is a [simple benchmark](__performance_tests__/todo.js) on the performance of Immer. This test takes 100.000 todo items, and updates 10.000 of them. _Freeze_ indicates that the state tree has been frozen after producing it. This is a _development_ best practice, as it prevents developers from accidentally modifying the state tree.
 
-These tests were executed on Node 8.4.0.
-Use `yarn test:perf`  to reproduce them locally.
+These tests were executed on Node 8.4.0. Use `yarn test:perf` to reproduce them locally.
 
 ![performance.png](images/performance.png)
 
 Some observations:
+
 * From `immer` perspective, this benchmark is a _worst case_ scenario, because the root collection it has to proxy is really large relatively to the rest of the data set.
 * The _mutate_, and _deepclone, mutate_ benchmarks establish a baseline on how expensive changing the data is, without immutability (or structural sharing in the deep clone case).
 * The _reducer_ and _naive reducer_ are implemented in typical Redux style reducers. The "smart" implementation slices the collection first, and then maps and freezes only the relevant todos. The "naive" implementation just maps over and processes the entire collection.
diff --git a/src/es5.js b/src/es5.js
index 8df50f4..9cf9e0e 100644
--- a/src/es5.js
+++ b/src/es5.js
@@ -99,7 +99,8 @@ function createPropertyProxy(prop) {
 function assertUnfinished(state) {
     if (state.finished === true)
         throw new Error(
-            "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process?"
+            "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " +
+                JSON.stringify(state.copy || state.base)
         )
 }
 
@@ -144,6 +145,11 @@ function hasArrayChanges(state) {
 }
 
 export function produceEs5(baseState, producer) {
+    if (isProxy(baseState)) {
+        // See #100, don't nest producers
+        const returnValue = producer.call(baseState, baseState)
+        return returnValue === undefined ? baseState : returnValue
+    }
     const prevStates = states
     states = []
     try {
diff --git a/src/proxy.js b/src/proxy.js
index f13317b..348587a 100644
--- a/src/proxy.js
+++ b/src/proxy.js
@@ -120,6 +120,7 @@ function markChanged(state) {
 
 // creates a proxy for plain objects / arrays
 function createProxy(parentState, base) {
+    if (isProxy(base)) throw new Error("Immer bug. Plz report.")
     const state = createState(parentState, base)
     const proxy = Array.isArray(base)
         ? Proxy.revocable([state], arrayTraps)
@@ -129,6 +130,11 @@ function createProxy(parentState, base) {
 }
 
 export function produceProxy(baseState, producer) {
+    if (isProxy(baseState)) {
+        // See #100, don't nest producers
+        const returnValue = producer.call(baseState, baseState)
+        return returnValue === undefined ? baseState : returnValue
+    }
     const previousProxies = proxies
     proxies = []
     try {
