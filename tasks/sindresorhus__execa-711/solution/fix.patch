diff --git a/index.d.ts b/index.d.ts
index 9e79c0f..c8f1136 100644
--- a/index.d.ts
+++ b/index.d.ts
@@ -615,9 +615,7 @@ type ExecaCommonReturnValue<IsSync extends boolean = boolean, OptionsType extend
 	cwd: string;
 
 	/**
-	Whether the process was canceled.
-
-	You can cancel the spawned process using the [`signal`](https://github.com/sindresorhus/execa#signal-1) option.
+	Whether the process was canceled using the [`signal`](https://github.com/sindresorhus/execa#signal-1) option.
 	*/
 	isCanceled: boolean;
 
@@ -726,11 +724,6 @@ export type ExecaChildPromise<OptionsType extends Options = Options> = {
 	*/
 	kill(signal?: string, options?: KillOptions): void;
 
-	/**
-	Similar to [`childProcess.kill()`](https://nodejs.org/api/child_process.html#child_process_subprocess_kill_signal). This used to be preferred when cancelling the child process execution as the error is more descriptive and [`childProcessResult.isCanceled`](#iscanceled) is set to `true`. But now this is deprecated and you should either use `.kill()` or the `signal` option when creating the child process.
-	*/
-	cancel(): void;
-
 	/**
 	[Pipe](https://nodejs.org/api/stream.html#readablepipedestination-options) the child process's `stdout` to `target`, which can be:
 	- Another `execa()` return value
diff --git a/index.js b/index.js
index 1ff8d7a..57734c0 100644
--- a/index.js
+++ b/index.js
@@ -10,7 +10,7 @@ import {makeError} from './lib/error.js';
 import {handleInputAsync, pipeOutputAsync} from './lib/stdio/async.js';
 import {handleInputSync, pipeOutputSync} from './lib/stdio/sync.js';
 import {normalizeStdioNode} from './lib/stdio/normalize.js';
-import {spawnedKill, spawnedCancel, validateTimeout} from './lib/kill.js';
+import {spawnedKill, validateTimeout} from './lib/kill.js';
 import {addPipeMethods} from './lib/pipe.js';
 import {getSpawnedResult, makeAllStream} from './lib/stream.js';
 import {mergePromise} from './lib/promise.js';
@@ -119,20 +119,19 @@ export function execa(rawFile, rawArgs, rawOptions) {
 
 	pipeOutputAsync(spawned, stdioStreamsGroups);
 
-	const context = {isCanceled: false, timedOut: false};
-
 	spawned.kill = spawnedKill.bind(null, spawned.kill.bind(spawned));
-	spawned.cancel = spawnedCancel.bind(null, spawned, context);
 	spawned.all = makeAllStream(spawned, options);
 
 	addPipeMethods(spawned);
 
-	const promise = handlePromise({spawned, options, context, stdioStreamsGroups, command, escapedCommand});
+	const promise = handlePromise({spawned, options, stdioStreamsGroups, command, escapedCommand});
 	mergePromise(spawned, promise);
 	return spawned;
 }
 
-const handlePromise = async ({spawned, options, context, stdioStreamsGroups, command, escapedCommand}) => {
+const handlePromise = async ({spawned, options, stdioStreamsGroups, command, escapedCommand}) => {
+	const context = {timedOut: false};
+
 	const [
 		[exitCode, signal, error],
 		stdioResults,
@@ -142,7 +141,7 @@ const handlePromise = async ({spawned, options, context, stdioStreamsGroups, com
 	const all = handleOutput(options, allResult);
 
 	if (error || exitCode !== 0 || signal !== null) {
-		const isCanceled = context.isCanceled || Boolean(options.signal?.aborted);
+		const isCanceled = options.signal?.aborted === true;
 		const returnedError = makeError({
 			error,
 			exitCode,
diff --git a/index.test-d.ts b/index.test-d.ts
index 238070d..a23b1cf 100644
--- a/index.test-d.ts
+++ b/index.test-d.ts
@@ -34,7 +34,6 @@ expectType<[undefined, string | Uint8Array | undefined, string | Uint8Array | un
 
 try {
 	const execaPromise = execa('unicorns', {all: true});
-	execaPromise.cancel();
 
 	const execaBufferPromise = execa('unicorns', {encoding: 'buffer', all: true});
 	const writeStream = createWriteStream('output.txt');
diff --git a/lib/kill.js b/lib/kill.js
index 3cf4c6a..7cc6836 100644
--- a/lib/kill.js
+++ b/lib/kill.js
@@ -42,15 +42,6 @@ const getForceKillAfterTimeout = (signal, forceKillAfterTimeout, killResult) =>
 	return forceKillAfterTimeout;
 };
 
-// `childProcess.cancel()`
-export const spawnedCancel = (spawned, context) => {
-	const killResult = spawned.kill();
-
-	if (killResult) {
-		context.isCanceled = true;
-	}
-};
-
 const killAfterTimeout = async ({spawned, timeout, killSignal, context, controller}) => {
 	await pSetTimeout(timeout, undefined, {ref: false, signal: controller.signal});
 	spawned.kill(killSignal);
diff --git a/readme.md b/readme.md
index 518a79b..d1e379a 100644
--- a/readme.md
+++ b/readme.md
@@ -459,9 +459,7 @@ Whether the process timed out.
 
 Type: `boolean`
 
-Whether the process was canceled.
-
-You can cancel the spawned process using the [`signal`](#signal-1) option.
+Whether the process was canceled using the [`signal`](#signal-1) option.
 
 #### isTerminated
 
