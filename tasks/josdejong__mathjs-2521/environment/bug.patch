diff --git a/src/expression/embeddedDocs/embeddedDocs.js b/src/expression/embeddedDocs/embeddedDocs.js
index 50ee611fd..0085eed8c 100644
--- a/src/expression/embeddedDocs/embeddedDocs.js
+++ b/src/expression/embeddedDocs/embeddedDocs.js
@@ -121,7 +121,6 @@ import { forEachDocs } from './function/matrix/forEach.js'
 import { getMatrixDataTypeDocs } from './function/matrix/getMatrixDataType.js'
 import { identityDocs } from './function/matrix/identity.js'
 import { invDocs } from './function/matrix/inv.js'
-import { pinvDocs } from './function/matrix/pinv.js'
 import { kronDocs } from './function/matrix/kron.js'
 import { mapDocs } from './function/matrix/map.js'
 import { matrixFromColumnsDocs } from './function/matrix/matrixFromColumns.js'
@@ -439,7 +438,6 @@ export const embeddedDocs = {
   flatten: flattenDocs,
   forEach: forEachDocs,
   inv: invDocs,
-  pinv: pinvDocs,
   eigs: eigsDocs,
   kron: kronDocs,
   matrixFromFunction: matrixFromFunctionDocs,
diff --git a/src/expression/embeddedDocs/function/matrix/pinv.js b/src/expression/embeddedDocs/function/matrix/pinv.js
deleted file mode 100644
index 1e1a92070..000000000
--- a/src/expression/embeddedDocs/function/matrix/pinv.js
+++ /dev/null
@@ -1,16 +0,0 @@
-export const pinvDocs = {
-  name: 'pinv',
-  category: 'Matrix',
-  syntax: [
-    'pinv(x)'
-  ],
-  description: 'Calculate the Moore–Penrose inverse of a matrix',
-  examples: [
-    'pinv([1, 2; 3, 4])',
-    'pinv([[1, 0], [0, 1], [0, 1]])',
-    'pinv(4)'
-  ],
-  seealso: [
-    'inv'
-  ]
-}
diff --git a/src/factoriesAny.js b/src/factoriesAny.js
index 9a98646ee..b51c8001a 100644
--- a/src/factoriesAny.js
+++ b/src/factoriesAny.js
@@ -214,7 +214,6 @@ export { createHelp } from './expression/function/help.js'
 export { createChain } from './type/chain/function/chain.js'
 export { createDet } from './function/matrix/det.js'
 export { createInv } from './function/matrix/inv.js'
-export { createPinv } from './function/matrix/pinv.js'
 export { createEigs } from './function/matrix/eigs.js'
 export { createExpm } from './function/matrix/expm.js'
 export { createSqrtm } from './function/matrix/sqrtm.js'
diff --git a/src/function/matrix/pinv.js b/src/function/matrix/pinv.js
deleted file mode 100644
index c98c4e6b4..000000000
--- a/src/function/matrix/pinv.js
+++ /dev/null
@@ -1,199 +0,0 @@
-import { isMatrix } from '../../utils/is.js'
-import { arraySize } from '../../utils/array.js'
-import { factory } from '../../utils/factory.js'
-import { format } from '../../utils/string.js'
-import { clone } from '../../utils/object.js'
-
-const name = 'pinv'
-const dependencies = [
-  'typed',
-  'matrix',
-  'inv',
-  'deepEqual',
-  'equal',
-  'dotDivide',
-  'dot',
-  'ctranspose',
-  'divideScalar',
-  'multiply',
-  'add',
-  'Complex'
-]
-
-export const createPinv = /* #__PURE__ */ factory(name, dependencies, ({
-  typed,
-  matrix,
-  inv,
-  deepEqual,
-  equal,
-  dotDivide,
-  dot,
-  ctranspose,
-  divideScalar,
-  multiply,
-  add,
-  Complex
-}) => {
-  /**
-   * Calculate the Moore–Penrose inverse of a matrix.
-   *
-   * Syntax:
-   *
-   *     math.pinv(x)
-   *
-   * Examples:
-   *
-   *     math.pinv([[1, 2], [3, 4]])          // returns [[-2, 1], [1.5, -0.5]]
-   *     math.pinv([[1, 0], [0, 1], [0, 1]])  // returns [[1, 0, 0], [0, 0.5, 0.5]]
-   *     math.pinv(4)                         // returns 0.25
-   *
-   * See also:
-   *
-   *     inv
-   *
-   * @param {number | Complex | Array | Matrix} x     Matrix to be inversed
-   * @return {number | Complex | Array | Matrix} The inverse of `x`.
-   */
-  return typed(name, {
-    'Array | Matrix': function (x) {
-      const size = isMatrix(x) ? x.size() : arraySize(x)
-      switch (size.length) {
-        case 1:
-          // vector
-          if (_isZeros(x)) return ctranspose(x) // null vector
-          if (size[0] === 1) {
-            return inv(x) // invertible matrix
-          } else {
-            return dotDivide(ctranspose(x), dot(x, x))
-          }
-
-        case 2:
-        // two dimensional array
-        {
-          if (_isZeros(x)) return ctranspose(x) // zero matrixx
-          const rows = size[0]
-          const cols = size[1]
-          if (rows === cols) {
-            try {
-              return inv(x) // invertible matrix
-            } catch (err) {
-              if (err instanceof Error && err.message.match(/Cannot calculate inverse, determinant is zero/)) {
-                // Expected
-              } else {
-                throw err
-              }
-            }
-          }
-          if (isMatrix(x)) {
-            return matrix(
-              _pinv(x.valueOf(), rows, cols),
-              x.storage()
-            )
-          } else {
-            // return an Array
-            return _pinv(x, rows, cols)
-          }
-        }
-
-        default:
-          // multi dimensional array
-          throw new RangeError('Matrix must be two dimensional ' +
-          '(size: ' + format(size) + ')')
-      }
-    },
-
-    any: function (x) {
-      // scalar
-      if (equal(x, 0)) return clone(x) // zero
-      return divideScalar(1, x)
-    }
-  })
-
-  /**
-   * Calculate the Moore–Penrose inverse of a matrix
-   * @param {Array[]} mat     A matrix
-   * @param {number} rows     Number of rows
-   * @param {number} cols     Number of columns
-   * @return {Array[]} pinv    Pseudoinverse matrix
-   * @private
-   */
-  function _pinv (mat, rows, cols) {
-    const { C, F } = _rankFact(mat, rows, cols) // TODO: Use SVD instead (may improve precision)
-    const Cpinv = multiply(inv(multiply(ctranspose(C), C)), ctranspose(C))
-    const Fpinv = multiply(ctranspose(F), inv(multiply(F, ctranspose(F))))
-    return multiply(Fpinv, Cpinv)
-  }
-
-  /**
-   * Calculate the reduced row echelon form of a matrix
-   *
-   * Modified from https://rosettacode.org/wiki/Reduced_row_echelon_form
-   *
-   * @param {Array[]} mat     A matrix
-   * @param {number} rows     Number of rows
-   * @param {number} cols     Number of columns
-   * @return {Array[]}        Reduced row echelon form
-   * @private
-   */
-  function _rref (mat, rows, cols) {
-    const M = clone(mat)
-    let lead = 0
-    for (let r = 0; r < rows; r++) {
-      if (cols <= lead) {
-        return M
-      }
-      let i = r
-      while (_isZero(M[i][lead])) {
-        i++
-        if (rows === i) {
-          i = r
-          lead++
-          if (cols === lead) {
-            return M
-          }
-        }
-      }
-
-      [M[i], M[r]] = [M[r], M[i]]
-
-      let val = M[r][lead]
-      for (let j = 0; j < cols; j++) {
-        M[r][j] = dotDivide(M[r][j], val)
-      }
-
-      for (let i = 0; i < rows; i++) {
-        if (i === r) continue
-        val = M[i][lead]
-        for (let j = 0; j < cols; j++) {
-          M[i][j] = add(M[i][j], multiply(-1, multiply(val, M[r][j])))
-        }
-      }
-      lead++
-    }
-    return M
-  }
-
-  /**
-   * Calculate the rank factorization of a matrix
-   *
-   * @param {Array[]} mat                  A matrix (M)
-   * @param {number} rows                  Number of rows
-   * @param {number} cols                  Number of columns
-   * @return {{C: Array, F: Array}}        rank factorization where M = C F
-   * @private
-   */
-  function _rankFact (mat, rows, cols) {
-    const rref = _rref(mat, rows, cols)
-    const C = mat.map((_, i) => _.filter((_, j) => j < rows && !_isZero(dot(rref[j], rref[j]))))
-    const F = rref.filter((_, i) => !_isZero(dot(rref[i], rref[i])))
-    return { C, F }
-  }
-
-  function _isZero (x) {
-    return equal(add(x, Complex(1, 1)), add(0, Complex(1, 1)))
-  }
-
-  function _isZeros (arr) {
-    return deepEqual(add(arr, Complex(1, 1)), add(multiply(arr, 0), Complex(1, 1)))
-  }
-})
diff --git a/src/utils/latex.js b/src/utils/latex.js
index e2dac2c56..686aa1464 100644
--- a/src/utils/latex.js
+++ b/src/utils/latex.js
@@ -189,7 +189,6 @@ export const latexFunctions = {
   dot: { 2: '\\left(${args[0]}\\cdot${args[1]}\\right)' },
   expm: { 1: '\\exp\\left(${args[0]}\\right)' },
   inv: { 1: '\\left(${args[0]}\\right)^{-1}' },
-  pinv: { 1: '\\left(${args[0]}\\right)^{+}' },
   sqrtm: { 1: `{\${args[0]}}${latexOperators.pow}{\\frac{1}{2}}` },
   trace: { 1: '\\mathrm{tr}\\left(${args[0]}\\right)' },
   transpose: { 1: `\\left(\${args[0]}\\right)${latexOperators.transpose}` },
diff --git a/test/unit-tests/function/matrix/pinv.test.js b/test/unit-tests/function/matrix/pinv.test.js
deleted file mode 100644
index e9ad9aa31..000000000
--- a/test/unit-tests/function/matrix/pinv.test.js
+++ /dev/null
@@ -1,176 +0,0 @@
-// test pinv
-import assert from 'assert'
-import approx from '../../../../tools/approx.js'
-import math from '../../../../src/defaultInstance.js'
-const pinv = math.pinv
-
-/**
- * Tests whether `A_` is Moore–Penrose inverse of `A`.
- *
- * @param {Matrix | Array} A     A two dimensional matrix or array.
- * @param {Matrix | Array} A_    A two dimensional matrix or array.
- *
- * @return {Boolean} Returns true if `A_` is a valid Moore–Penrose inverse of `A`
- */
-function assertValidPinv (A, A_) {
-  const Asize = math.size(A).valueOf()
-
-  const rows = Asize[0]
-  const cols = Asize[1]
-
-  // sizes match
-  assert.deepStrictEqual(math.size(A_).valueOf(), [cols, rows])
-
-  // A A_ A = A
-  approx.deepEqual(math.add(math.multiply(A, math.multiply(A_, A)), math.Complex(1, 1)).valueOf(), math.add(A, math.Complex(1, 1)).valueOf())
-  // A_ A A_ = A_
-  approx.deepEqual(math.add(math.multiply(A_, math.multiply(A, A_)), math.Complex(1, 1)).valueOf(), math.add(A_, math.Complex(1, 1)).valueOf())
-  // (A A_)* = A A_
-  approx.deepEqual(math.add(math.ctranspose(math.multiply(A, A_)), math.Complex(1, 1)).valueOf(), math.add(math.multiply(A, A_), math.Complex(1, 1)).valueOf())
-  // (A_ A)* = A_ A
-  approx.deepEqual(math.add(math.ctranspose(math.multiply(A_, A)), math.Complex(1, 1)).valueOf(), math.add(math.multiply(A_, A), math.Complex(1, 1)).valueOf())
-}
-
-describe('pinv', function () {
-  function test (A, A_, strict = false) {
-    const pinvA = pinv(A)
-    if (A_) {
-      if (strict) assert.deepStrictEqual(pinvA, A_)
-      else approx.deepEqual(pinvA, A_)
-    }
-    switch (math.size(A).valueOf().length) {
-      case 0:
-        assertValidPinv([[A]], [[pinvA]])
-        break
-      case 1:
-        assertValidPinv(math.reshape(A, [1, -1]), math.reshape(pinvA, [-1, 1]))
-        break
-      case 2:
-        assertValidPinv(A, pinvA)
-        break
-      default:
-        assert.ok(math.size(A).valueOf().length < 3)
-        break
-    }
-  }
-  it('should return the inverse of a number', function () {
-    test(4, 1 / 4, true)
-    test(math.bignumber(4), math.bignumber(1 / 4), true)
-  })
-
-  it('should return the inverse of a matrix with just one value', function () {
-    test([4], [1 / 4], true)
-    test([[4]], [[1 / 4]], true)
-  })
-
-  it('should return the inverse for each element in an array', function () {
-    test([4], [1 / 4], true)
-    test([[4]], [[1 / 4]], true)
-
-    test([
-      [1, 4, 7],
-      [3, 0, 5],
-      [-1, 9, 11]
-    ], [
-      [5.625, -2.375, -2.5],
-      [4.75, -2.25, -2],
-      [-3.375, 1.625, 1.5]
-    ])
-
-    test([
-      [2, -1, 0],
-      [-1, 2, -1],
-      [0, -1, 2]
-    ], [
-      [3 / 4, 1 / 2, 1 / 4],
-      [1 / 2, 1, 1 / 2],
-      [1 / 4, 1 / 2, 3 / 4]
-    ])
-
-    test([
-      [1, 0, 0],
-      [0, 0, 1],
-      [0, 1, 0]
-    ], [
-      [1, 0, 0],
-      [0, 0, 1],
-      [0, 1, 0]
-    ])
-
-    test([
-      [1, 0, 0],
-      [0, -1, 1],
-      [0, 0, 1]
-    ], [
-      [1, 0, 0],
-      [0, -1, 1],
-      [0, 0, 1]
-    ])
-  })
-
-  it('should return the inverse for each element in a matrix', function () {
-    test(math.matrix([4]), math.matrix([1 / 4]), true)
-    test(math.matrix([[4]]), math.matrix([[1 / 4]]), true)
-    test(math.matrix([[4]], 'sparse'), math.matrix([[1 / 4]], 'sparse'), true)
-    test(math.matrix([[1, 2], [3, 4]], 'sparse'), math.matrix([[-2, 1], [1.5, -0.5]], 'sparse'), true)
-  })
-
-  it('should return the Moore–Penrose inverse of complex matrices', function () {
-    test(
-      math.evaluate(`[
-          [0.4032 + 0.0876i,   0.1678 + 0.0390i,   0.5425 + 0.5118i],
-          [0.3174 + 0.3352i,   0.9784 + 0.4514i,  -0.4416 - 1.3188i],
-          [0.4008 - 0.0504i,   0.0979 - 0.2558i,   0.2983 + 0.7800i]
-      ]`)
-      // , math.evaluate(`[
-      //     [0.4318 - 0.1398i,   0.2869 - 0.1360i,   0.3897 - 0.0370i],
-      //     [0.3507 - 0.0725i,   0.4354 - 0.1329i,   0.2877 + 0.0565i],
-      //     [0.3116 - 0.2626i,   0.0042 + 0.2584i,   0.2388 - 0.2806i]
-      // ]`)
-    )
-  })
-
-  it('should return the Moore–Penrose inverse of non-square matrices', function () {
-    test([[0, 0]], [[0], [0]], true)
-
-    test([1, 2, 3], [1 / 14, 2 / 14, 3 / 14])
-
-    test([[1, 2, 3], [4, 5, 6]], [[-17 / 18, 8 / 18], [-2 / 18, 2 / 18], [13 / 18, -4 / 18]])
-    test([[1, 4], [2, 5], [3, 6]], [[-17 / 18, -2 / 18, 13 / 18], [8 / 18, 2 / 18, -4 / 18]])
-
-    test([
-      [64, 2, 3, 61, 60, 6],
-      [9, 55, 54, 12, 13, 51],
-      [17, 47, 46, 20, 21, 43],
-      [40, 26, 27, 37, 36, 30],
-      [32, 34, 35, 29, 28, 38],
-      [41, 23, 22, 44, 45, 19],
-      [49, 15, 14, 52, 53, 11],
-      [8, 58, 59, 5, 4, 62]
-    ])
-  })
-
-  it('should throw an error in case of multi dimensional matrices', function () {
-    assert.throws(function () { pinv([[[1, 2, 3], [4, 5, 6]]]) }, /Matrix must be two dimensional/)
-  })
-
-  it('should return the Moore–Penrose inverse of non-invertable matrices', function () {
-    test([[0]], [[0]], true)
-    test([[1, 0], [0, 0]], [[1, 0], [0, 0]])
-    test([[1, 1, 1], [1, 0, 0], [0, 0, 0]], [[0, 1, 0], [0.5, -0.5, 0], [0.5, -0.5, 0]])
-  })
-
-  it('should throw an error in case of wrong number of arguments', function () {
-    assert.throws(function () { pinv() }, /TypeError: Too few arguments/)
-    assert.throws(function () { pinv([], []) }, /TypeError: Too many arguments/)
-  })
-
-  it('should throw an error in case of invalid type of arguments', function () {
-    assert.throws(function () { math.concat(pinv(new Date())) }, /TypeError: Unexpected type of argument/)
-  })
-
-  it('should  LaTeX pinv', function () {
-    const expression = math.parse('pinv([[1,2],[3,4]])')
-    assert.strictEqual(expression.toTex(), '\\left(\\begin{bmatrix}1&2\\\\3&4\\end{bmatrix}\\right)^{+}')
-  })
-})
