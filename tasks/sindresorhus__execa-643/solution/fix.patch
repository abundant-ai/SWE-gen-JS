diff --git a/index.d.ts b/index.d.ts
index 6f1b4be..c4eefdc 100644
--- a/index.d.ts
+++ b/index.d.ts
@@ -25,9 +25,15 @@ type OutputStdioOption =
 	| Writable
 	| WritableStream;
 
-export type StdinOption = CommonStdioOption | InputStdioOption;
-export type StdoutStderrOption = CommonStdioOption | OutputStdioOption;
-export type StdioOption = CommonStdioOption | InputStdioOption | OutputStdioOption;
+export type StdinOption =
+	CommonStdioOption | InputStdioOption
+	| Array<CommonStdioOption | InputStdioOption>;
+export type StdoutStderrOption =
+	CommonStdioOption | OutputStdioOption
+	| Array<CommonStdioOption | OutputStdioOption>;
+export type StdioOption =
+	CommonStdioOption | InputStdioOption | OutputStdioOption
+	| Array<CommonStdioOption | InputStdioOption | OutputStdioOption>;
 
 type StdioOptions =
 	| BaseStdioOption
@@ -119,6 +125,8 @@ export type CommonOptions<EncodingType extends EncodingOption = DefaultEncodingO
 	- web [`ReadableStream`](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream).
 	- [`Iterable`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#the_iterable_protocol) or [`AsyncIterable`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#the_async_iterator_and_async_iterable_protocols)
 
+	This can be an [array of values](https://github.com/sindresorhus/execa#redirect-stdinstdoutstderr-to-multiple-destinations) such as `['inherit', 'pipe']` or `[filePath, 'pipe']`.
+
 	@default `inherit` with `$`, `pipe` otherwise
 	*/
 	readonly stdin?: StdinOption;
@@ -138,6 +146,8 @@ export type CommonOptions<EncodingType extends EncodingOption = DefaultEncodingO
 	- file URL.
 	- web [`WritableStream`](https://developer.mozilla.org/en-US/docs/Web/API/WritableStream).
 
+	This can be an [array of values](https://github.com/sindresorhus/execa#redirect-stdinstdoutstderr-to-multiple-destinations) such as `['inherit', 'pipe']` or `[filePath, 'pipe']`.
+
 	@default 'pipe'
 	*/
 	readonly stdout?: StdoutStderrOption;
@@ -157,10 +167,23 @@ export type CommonOptions<EncodingType extends EncodingOption = DefaultEncodingO
 	- file URL.
 	- web [`WritableStream`](https://developer.mozilla.org/en-US/docs/Web/API/WritableStream).
 
+	This can be an [array of values](https://github.com/sindresorhus/execa#redirect-stdinstdoutstderr-to-multiple-destinations) such as `['inherit', 'pipe']` or `[filePath, 'pipe']`.
+
 	@default 'pipe'
 	*/
 	readonly stderr?: StdoutStderrOption;
 
+	/**
+	Like the `stdin`, `stdout` and `stderr` options but for all file descriptors at once. For example, `{stdio: ['ignore', 'pipe', 'pipe']}` is the same as `{stdin: 'ignore', stdout: 'pipe', stderr: 'pipe'}`.
+
+	A single string can be used as a shortcut. For example, `{stdio: 'pipe'}` is the same as `{stdin: 'pipe', stdout: 'pipe', stderr: 'pipe'}`.
+
+	The array can have more than 3 items, to create additional file descriptors beyond `stdin`/`stdout`/`stderr`. For example, `{stdio: ['pipe', 'pipe', 'pipe', 'ipc']}` sets a fourth file descriptor `'ipc'`.
+
+	@default 'pipe'
+	*/
+	readonly stdio?: StdioOptions;
+
 	/**
 	Setting this to `false` resolves the promise with the error instead of rejecting it.
 
@@ -208,16 +231,6 @@ export type CommonOptions<EncodingType extends EncodingOption = DefaultEncodingO
 	*/
 	readonly argv0?: string;
 
-	/**
-	Like the `stdin`, `stdout` and `stderr` options but for all file descriptors at once.
-	The possible values are the same except it can also be:
-	- a single string, to set the same value to each standard stream.
-	- an array with more than 3 values, to create more than 3 file descriptors.
-
-	@default 'pipe'
-	*/
-	readonly stdio?: StdioOptions;
-
 	/**
 	Specify the kind of serialization used for sending messages between processes when using the `stdio: 'ipc'` option or `execaNode()`:
 	- `json`: Uses `JSON.stringify()` and `JSON.parse()`.
diff --git a/index.test-d.ts b/index.test-d.ts
index 59b6555..15363b7 100644
--- a/index.test-d.ts
+++ b/index.test-d.ts
@@ -160,54 +160,100 @@ execa('unicorns', {input: process.stdin});
 execa('unicorns', {inputFile: ''});
 execa('unicorns', {inputFile: fileUrl});
 execa('unicorns', {stdin: 'pipe'});
+execa('unicorns', {stdin: ['pipe']});
 execa('unicorns', {stdin: 'overlapped'});
+execa('unicorns', {stdin: ['overlapped']});
 execa('unicorns', {stdin: 'ipc'});
+execa('unicorns', {stdin: ['ipc']});
 execa('unicorns', {stdin: 'ignore'});
+execa('unicorns', {stdin: ['ignore']});
 execa('unicorns', {stdin: 'inherit'});
+execa('unicorns', {stdin: ['inherit']});
 execa('unicorns', {stdin: process.stdin});
+execa('unicorns', {stdin: [process.stdin]});
 execa('unicorns', {stdin: new Readable()});
+execa('unicorns', {stdin: [new Readable()]});
 expectError(execa('unicorns', {stdin: new Writable()}));
+expectError(execa('unicorns', {stdin: [new Writable()]}));
 execa('unicorns', {stdin: new ReadableStream()});
+execa('unicorns', {stdin: [new ReadableStream()]});
 expectError(execa('unicorns', {stdin: new WritableStream()}));
-execa('unicorns', {stdin: ['']});
-execa('unicorns', {stdin: [new Uint8Array(0)]});
+expectError(execa('unicorns', {stdin: [new WritableStream()]}));
 execa('unicorns', {stdin: stringGenerator()});
+execa('unicorns', {stdin: [stringGenerator()]});
 execa('unicorns', {stdin: binaryGenerator()});
+execa('unicorns', {stdin: [binaryGenerator()]});
 execa('unicorns', {stdin: asyncStringGenerator()});
-expectError(execa('unicorns', {stdin: [0]}));
+execa('unicorns', {stdin: [asyncStringGenerator()]});
 expectError(execa('unicorns', {stdin: numberGenerator()}));
+expectError(execa('unicorns', {stdin: [numberGenerator()]}));
 execa('unicorns', {stdin: fileUrl});
+execa('unicorns', {stdin: [fileUrl]});
 execa('unicorns', {stdin: './test'});
+execa('unicorns', {stdin: ['./test']});
 execa('unicorns', {stdin: 1});
+execa('unicorns', {stdin: [1]});
 execa('unicorns', {stdin: undefined});
+execa('unicorns', {stdin: [undefined]});
+execa('unicorns', {stdin: ['pipe', 'inherit']});
 execa('unicorns', {stdout: 'pipe'});
+execa('unicorns', {stdout: ['pipe']});
 execa('unicorns', {stdout: 'overlapped'});
+execa('unicorns', {stdout: ['overlapped']});
 execa('unicorns', {stdout: 'ipc'});
+execa('unicorns', {stdout: ['ipc']});
 execa('unicorns', {stdout: 'ignore'});
+execa('unicorns', {stdout: ['ignore']});
 execa('unicorns', {stdout: 'inherit'});
+execa('unicorns', {stdout: ['inherit']});
 execa('unicorns', {stdout: process.stdout});
+execa('unicorns', {stdout: [process.stdout]});
 execa('unicorns', {stdout: new Writable()});
+execa('unicorns', {stdout: [new Writable()]});
 expectError(execa('unicorns', {stdout: new Readable()}));
+expectError(execa('unicorn', {stdout: [new Readable()]}));
 execa('unicorns', {stdout: new WritableStream()});
+execa('unicorns', {stdout: [new WritableStream()]});
 expectError(execa('unicorns', {stdout: new ReadableStream()}));
+expectError(execa('unicorn', {stdout: [new ReadableStream()]}));
 execa('unicorns', {stdout: fileUrl});
+execa('unicorns', {stdout: [fileUrl]});
 execa('unicorns', {stdout: './test'});
+execa('unicorns', {stdout: ['./test']});
 execa('unicorns', {stdout: 1});
+execa('unicorns', {stdout: [1]});
 execa('unicorns', {stdout: undefined});
+execa('unicorns', {stdout: [undefined]});
+execa('unicorns', {stdout: ['pipe', 'inherit']});
 execa('unicorns', {stderr: 'pipe'});
+execa('unicorns', {stderr: ['pipe']});
 execa('unicorns', {stderr: 'overlapped'});
+execa('unicorns', {stderr: ['overlapped']});
 execa('unicorns', {stderr: 'ipc'});
+execa('unicorns', {stderr: ['ipc']});
 execa('unicorns', {stderr: 'ignore'});
+execa('unicorns', {stderr: ['ignore']});
 execa('unicorns', {stderr: 'inherit'});
+execa('unicorns', {stderr: ['inherit']});
 execa('unicorns', {stderr: process.stderr});
+execa('unicorns', {stderr: [process.stderr]});
 execa('unicorns', {stderr: new Writable()});
+execa('unicorns', {stderr: [new Writable()]});
 expectError(execa('unicorns', {stderr: new Readable()}));
+expectError(execa('unicorns', {stderr: [new Readable()]}));
 execa('unicorns', {stderr: new WritableStream()});
+execa('unicorns', {stderr: [new WritableStream()]});
 expectError(execa('unicorns', {stderr: new ReadableStream()}));
+expectError(execa('unicorns', {stderr: [new ReadableStream()]}));
 execa('unicorns', {stderr: fileUrl});
+execa('unicorns', {stderr: [fileUrl]});
 execa('unicorns', {stderr: './test'});
+execa('unicorns', {stderr: ['./test']});
 execa('unicorns', {stderr: 1});
+execa('unicorns', {stderr: [1]});
 execa('unicorns', {stderr: undefined});
+execa('unicorns', {stderr: [undefined]});
+execa('unicorns', {stderr: ['pipe', 'inherit']});
 execa('unicorns', {all: true});
 execa('unicorns', {reject: false});
 execa('unicorns', {stripFinalNewline: false});
@@ -233,11 +279,17 @@ expectError(execa('unicorns', {stdio: stringGenerator()}));
 expectError(execa('unicorns', {stdio: asyncStringGenerator()}));
 expectError(execa('unicorns', {stdio: ['pipe', 'pipe']}));
 execa('unicorns', {stdio: [new Readable(), 'pipe', 'pipe']});
+execa('unicorns', {stdio: [[new Readable()], ['pipe'], ['pipe']]});
 execa('unicorns', {stdio: ['pipe', new Writable(), 'pipe']});
+execa('unicorns', {stdio: [['pipe'], [new Writable()], ['pipe']]});
 execa('unicorns', {stdio: ['pipe', 'pipe', new Writable()]});
+execa('unicorns', {stdio: [['pipe'], ['pipe'], [new Writable()]]});
 expectError(execa('unicorns', {stdio: [new Writable(), 'pipe', 'pipe']}));
+expectError(execa('unicorns', {stdio: [[new Writable()], ['pipe'], ['pipe']]}));
 expectError(execa('unicorns', {stdio: ['pipe', new Readable(), 'pipe']}));
+expectError(execa('unicorns', {stdio: [['pipe'], [new Readable()], ['pipe']]}));
 expectError(execa('unicorns', {stdio: ['pipe', 'pipe', new Readable()]}));
+expectError(execa('unicorns', {stdio: [['pipe'], ['pipe'], [new Readable()]]}));
 execa('unicorns', {
 	stdio: [
 		'pipe',
@@ -258,6 +310,27 @@ execa('unicorns', {
 		asyncStringGenerator(),
 	],
 });
+execa('unicorns', {
+	stdio: [
+		['pipe'],
+		['pipe', 'inherit'],
+		['overlapped'],
+		['ipc'],
+		['ignore'],
+		['inherit'],
+		[process.stdin],
+		[1],
+		[undefined],
+		[fileUrl],
+		['./test'],
+		[new Writable()],
+		[new Readable()],
+		[new WritableStream()],
+		[new ReadableStream()],
+		[stringGenerator()],
+		[asyncStringGenerator()],
+	],
+});
 execa('unicorns', {serialization: 'advanced'});
 execa('unicorns', {detached: true});
 execa('unicorns', {uid: 0});
diff --git a/lib/stdio/async.js b/lib/stdio/async.js
index 1a22686..0cfc5d6 100644
--- a/lib/stdio/async.js
+++ b/lib/stdio/async.js
@@ -7,13 +7,13 @@ export const handleInputAsync = options => handleInput(addPropertiesAsync, optio
 
 const addPropertiesAsync = {
 	input: {
-		filePath: ({value}) => ({value: createReadStream(value)}),
-		webStream: ({value}) => ({value: Readable.fromWeb(value)}),
-		iterable: ({value}) => ({value: Readable.from(value)}),
+		filePath: ({value}) => ({value: createReadStream(value), autoDestroy: true}),
+		webStream: ({value}) => ({value: Readable.fromWeb(value), autoDestroy: true}),
+		iterable: ({value}) => ({value: Readable.from(value), autoDestroy: true}),
 	},
 	output: {
-		filePath: ({value}) => ({value: createWriteStream(value)}),
-		webStream: ({value}) => ({value: Writable.fromWeb(value)}),
+		filePath: ({value}) => ({value: createWriteStream(value), autoDestroy: true}),
+		webStream: ({value}) => ({value: Writable.fromWeb(value), autoDestroy: true}),
 		iterable({optionName}) {
 			throw new TypeError(`The \`${optionName}\` option cannot be an iterable.`);
 		},
diff --git a/lib/stdio/direction.js b/lib/stdio/direction.js
index f24237a..b51c6a6 100644
--- a/lib/stdio/direction.js
+++ b/lib/stdio/direction.js
@@ -1,3 +1,4 @@
+import process from 'node:process';
 import {
 	isStream as isNodeStream,
 	isReadableStream as isNodeReadableStream,
@@ -7,11 +8,28 @@ import {isWritableStream} from './type.js';
 
 // For `stdio[index]` beyond stdin/stdout/stderr, we need to guess whether the value passed is intended for inputs or outputs.
 // This allows us to know whether to pipe _into_ or _from_ the stream.
-export const addStreamDirection = stdioStream => {
+// When `stdio[index]` is a single value, this guess is fairly straightforward.
+// However, when it is an array instead, we also need to make sure the different values are not incompatible with each other.
+export const addStreamDirection = stdioStream => Array.isArray(stdioStream)
+	? addStreamArrayDirection(stdioStream)
+	: addStreamSingleDirection(stdioStream);
+
+const addStreamSingleDirection = stdioStream => {
 	const direction = getStreamDirection(stdioStream);
 	return addDirection(stdioStream, direction);
 };
 
+const addStreamArrayDirection = stdioStream => {
+	const directions = stdioStream.map(stdioStreamItem => getStreamDirection(stdioStreamItem));
+
+	if (directions.includes('input') && directions.includes('output')) {
+		throw new TypeError(`The \`${stdioStream[0].optionName}\` option must not be an array of both readable and writable values.`);
+	}
+
+	const direction = directions.find(Boolean);
+	return stdioStream.map(stdioStreamItem => addDirection(stdioStreamItem, direction));
+};
+
 const getStreamDirection = stdioStream => KNOWN_DIRECTIONS[stdioStream.index] ?? guessStreamDirection[stdioStream.type](stdioStream.value);
 
 // `stdin`/`stdout`/`stderr` have a known direction
@@ -30,6 +48,14 @@ const guessStreamDirection = {
 		return 'output';
 	},
 	native(stdioOption) {
+		if ([0, process.stdin].includes(stdioOption)) {
+			return 'input';
+		}
+
+		if ([1, 2, process.stdout, process.stderr].includes(stdioOption)) {
+			return 'output';
+		}
+
 		if (isNodeStream(stdioOption)) {
 			return guessStreamDirection.nodeStream(stdioOption);
 		}
@@ -38,5 +64,8 @@ const guessStreamDirection = {
 
 const addDirection = (stdioStream, direction = DEFAULT_DIRECTION) => ({...stdioStream, direction});
 
+// When ambiguous, we initially keep the direction as `undefined`.
+// This allows arrays of `stdio` values to resolve the ambiguity.
+// For example, `stdio[3]: DuplexStream` is ambiguous, but `stdio[3]: [DuplexStream, WritableStream]` is not.
 // When the ambiguity remains, we default to `output` since it is the most common use case for additional file descriptors.
 const DEFAULT_DIRECTION = 'output';
diff --git a/lib/stdio/handle.js b/lib/stdio/handle.js
index a8a6b6f..c548932 100644
--- a/lib/stdio/handle.js
+++ b/lib/stdio/handle.js
@@ -2,34 +2,72 @@ import {getStdioOptionType, isRegularUrl, isUnknownStdioString} from './type.js'
 import {addStreamDirection} from './direction.js';
 import {normalizeStdio} from './normalize.js';
 import {handleInputOption, handleInputFileOption} from './input.js';
+import {handleNativeStream} from './native.js';
 
 // Handle `input`, `inputFile`, `stdin`, `stdout` and `stderr` options, before spawning, in async/sync mode
 export const handleInput = (addProperties, options) => {
 	const stdio = normalizeStdio(options);
 	const stdioStreams = stdio
-		.map((stdioOption, index) => getStdioStream(stdioOption, index, options))
+		.map((stdioOption, index) => getStdioStreams(stdioOption, index, options))
 		.map(stdioStream => addStreamDirection(stdioStream))
-		.map(stdioStream => addStreamProperties(stdioStream, addProperties));
+		.map(stdioStream => addStreamsProperties(stdioStream, addProperties));
 	options.stdio = transformStdio(stdioStreams);
-	return stdioStreams;
+	return stdioStreams.flat();
 };
 
-const getStdioStream = (stdioOption, index, {input, inputFile}) => {
+// We make sure passing an array with a single item behaves the same as passing that item without an array.
+// This is what users would expect.
+// For example, `stdout: ['ignore']` behaves the same as `stdout: 'ignore'`.
+const getStdioStreams = (stdioOption, index, options) => {
 	const optionName = getOptionName(index);
+	const stdioParameters = {...options, optionName, index};
+
+	if (!Array.isArray(stdioOption)) {
+		return getStdioStream(stdioOption, false, stdioParameters);
+	}
+
+	if (stdioOption.length === 0) {
+		throw new TypeError(`The \`${optionName}\` option must not be an empty array.`);
+	}
+
+	const stdioOptionArray = [...new Set(stdioOption)];
+	if (stdioOptionArray.length === 1) {
+		return getStdioStream(stdioOptionArray[0], false, stdioParameters);
+	}
+
+	validateStdioArray(stdioOptionArray, optionName);
+
+	return stdioOptionArray.map(stdioOptionItem => getStdioStream(stdioOptionItem, true, stdioParameters));
+};
+
+const getOptionName = index => KNOWN_OPTION_NAMES[index] ?? `stdio[${index}]`;
+const KNOWN_OPTION_NAMES = ['stdin', 'stdout', 'stderr'];
+
+const validateStdioArray = (stdioOptionArray, optionName) => {
+	for (const invalidStdioOption of INVALID_STDIO_ARRAY_OPTIONS) {
+		if (stdioOptionArray.includes(invalidStdioOption)) {
+			throw new Error(`The \`${optionName}\` option must not include \`${invalidStdioOption}\`.`);
+		}
+	}
+};
+
+// Using those `stdio` values together with others for the same stream does not make sense, so we make it fail.
+// However, we do allow it if the array has a single item.
+const INVALID_STDIO_ARRAY_OPTIONS = ['ignore', 'ipc'];
+
+const getStdioStream = (stdioOption, isStdioArray, {optionName, index, input, inputFile}) => {
 	const type = getStdioOptionType(stdioOption);
 	let stdioStream = {type, value: stdioOption, optionName, index};
 
 	stdioStream = handleInputOption(stdioStream, input);
 	stdioStream = handleInputFileOption(stdioStream, inputFile, input);
+	stdioStream = handleNativeStream(stdioStream, isStdioArray);
 
 	validateFileStdio(stdioStream);
 
 	return stdioStream;
 };
 
-const getOptionName = index => KNOWN_OPTION_NAMES[index] ?? `stdio[${index}]`;
-const KNOWN_OPTION_NAMES = ['stdin', 'stdout', 'stderr'];
-
 const validateFileStdio = ({type, value, optionName}) => {
 	if (isRegularUrl(value)) {
 		throw new TypeError(`The \`${optionName}: URL\` option must use the \`file:\` scheme.
@@ -44,13 +82,24 @@ For example, you can use the \`pathToFileURL()\` method of the \`url\` core modu
 // Some `stdio` values require Execa to create streams.
 // For example, file paths create file read/write streams.
 // Those transformations are specified in `addProperties`, which is both direction-specific and type-specific.
+const addStreamsProperties = (stdioStream, addProperties) => Array.isArray(stdioStream)
+	? stdioStream.map(stdioStreamItem => addStreamProperties(stdioStreamItem, addProperties))
+	: addStreamProperties(stdioStream, addProperties);
+
 const addStreamProperties = (stdioStream, addProperties) => ({
 	...stdioStream,
 	...addProperties[stdioStream.direction][stdioStream.type]?.(stdioStream),
 });
 
 // When the `std*: Iterable | WebStream | URL | filePath`, `input` or `inputFile` option is used, we pipe to `spawned.std*`.
+// When the `std*: Array` option is used, we emulate some of the native values ('inherit', Node.js stream and file descriptor integer). To do so, we also need to pipe to `spawned.std*`.
 // Therefore the `std*` options must be either `pipe` or `overlapped`. Other values do not set `spawned.std*`.
 const transformStdio = stdioStreams => stdioStreams.map(stdioStream => transformStdioItem(stdioStream));
 
-const transformStdioItem = stdioStream => stdioStream.type !== 'native' && stdioStream.value !== 'overlapped' ? 'pipe' : stdioStream.value;
+const transformStdioItem = stdioStream => {
+	if (Array.isArray(stdioStream)) {
+		return stdioStream.some(({value}) => value === 'overlapped') ? 'overlapped' : 'pipe';
+	}
+
+	return stdioStream.type !== 'native' && stdioStream.value !== 'overlapped' ? 'pipe' : stdioStream.value;
+};
diff --git a/lib/stdio/native.js b/lib/stdio/native.js
new file mode 100644
index 0000000..c70f772
--- /dev/null
+++ b/lib/stdio/native.js
@@ -0,0 +1,48 @@
+import process from 'node:process';
+import {isStream as isNodeStream} from 'is-stream';
+
+// When we use multiple `stdio` values for the same streams, we pass 'pipe' to `child_process.spawn()`.
+// We then emulate the piping done by core Node.js.
+// To do so, we transform the following values:
+//  - Node.js streams are marked as `type: nodeStream`
+//  - 'inherit' becomes `process.stdin|stdout|stderr`
+//  - any file descriptor integer becomes `process.stdio[index]`
+// All of the above transformations tell Execa to perform manual piping.
+export const handleNativeStream = (stdioStream, isStdioArray) => {
+	const {type, value, index, optionName} = stdioStream;
+
+	if (!isStdioArray || type !== 'native') {
+		return stdioStream;
+	}
+
+	if (value === 'inherit') {
+		return {...stdioStream, type: 'nodeStream', value: getStandardStream(index, value, optionName)};
+	}
+
+	if (typeof value === 'number') {
+		return {...stdioStream, type: 'nodeStream', value: getStandardStream(value, value, optionName)};
+	}
+
+	if (isNodeStream(value)) {
+		return {...stdioStream, type: 'nodeStream'};
+	}
+
+	return stdioStream;
+};
+
+// Node.js does not allow to easily retrieve file descriptors beyond stdin/stdout/stderr as streams.
+//  - `fs.createReadStream()`/`fs.createWriteStream()` with the `fd` option do not work with character devices that use blocking reads/writes (such as interactive TTYs).
+//  - Using a TCP `Socket` would work but be rather complex to implement.
+// Since this is an edge case, we simply throw an error message.
+// See https://github.com/sindresorhus/execa/pull/643#discussion_r1435905707
+const getStandardStream = (index, value, optionName) => {
+	const standardStream = STANDARD_STREAMS[index];
+
+	if (standardStream === undefined) {
+		throw new TypeError(`The \`${optionName}: ${value}\` option is invalid: no such standard stream.`);
+	}
+
+	return standardStream;
+};
+
+const STANDARD_STREAMS = [process.stdin, process.stdout, process.stderr];
diff --git a/lib/stdio/type.js b/lib/stdio/type.js
index cf40dcb..47838a0 100644
--- a/lib/stdio/type.js
+++ b/lib/stdio/type.js
@@ -37,9 +37,10 @@ const isReadableStream = stdioOption => Object.prototype.toString.call(stdioOpti
 export const isWritableStream = stdioOption => Object.prototype.toString.call(stdioOption) === '[object WritableStream]';
 const isWebStream = stdioOption => isReadableStream(stdioOption) || isWritableStream(stdioOption);
 
-const isIterableObject = stdinOption => typeof stdinOption === 'object'
-	&& stdinOption !== null
-	&& (typeof stdinOption[Symbol.asyncIterator] === 'function' || typeof stdinOption[Symbol.iterator] === 'function');
+const isIterableObject = stdioOption => typeof stdioOption === 'object'
+	&& stdioOption !== null
+	&& !Array.isArray(stdioOption)
+	&& (typeof stdioOption[Symbol.asyncIterator] === 'function' || typeof stdioOption[Symbol.iterator] === 'function');
 
 // Convert types to human-friendly strings for error messages
 export const TYPE_TO_MESSAGE = {
diff --git a/lib/stream.js b/lib/stream.js
index 86126e7..d4c5ce7 100644
--- a/lib/stream.js
+++ b/lib/stream.js
@@ -73,6 +73,14 @@ const throwOnStreamError = async stream => {
 	throw error;
 };
 
+const cleanupStdioStreams = stdioStreams => {
+	for (const stdioStream of stdioStreams) {
+		if (stdioStream.autoDestroy) {
+			stdioStream.value.destroy();
+		}
+	}
+};
+
 // Retrieve result of child process: exit code, signal, error, streams (stdout/stderr/all)
 export const getSpawnedResult = async (
 	spawned,
@@ -93,12 +101,14 @@ export const getSpawnedResult = async (
 			...stdioStreams.map(stdioStream => waitForStreamEnd(stdioStream, processDone)),
 		]);
 	} catch (error) {
-		spawned.kill();
 		return Promise.all([
 			{error, signal: error.signal, timedOut: error.timedOut},
 			getBufferedData(spawned.stdout, stdoutPromise),
 			getBufferedData(spawned.stderr, stderrPromise),
 			getBufferedData(spawned.all, allPromise),
 		]);
+	} finally {
+		cleanupStdioStreams(stdioStreams);
+		spawned.kill();
 	}
 };
diff --git a/readme.md b/readme.md
index e10b8c8..e8aab75 100644
--- a/readme.md
+++ b/readme.md
@@ -569,7 +569,7 @@ See also the [`input`](#input) and [`stdin`](#stdin) options.
 
 #### stdin
 
-Type: `string | number | stream.Readable | ReadableStream | URL | Iterable<string | Uint8Array> | AsyncIterable<string | Uint8Array>`\
+Type: `string | number | stream.Readable | ReadableStream | URL | Iterable<string | Uint8Array> | AsyncIterable<string | Uint8Array>` (or a tuple of those types)\
 Default: `inherit` with [`$`](#command), `pipe` otherwise
 
 [How to setup](https://nodejs.org/api/child_process.html#child_process_options_stdio) the child process' standard input. This can be:
@@ -587,9 +587,11 @@ Unless either the [synchronous methods](#execasyncfile-arguments-options), the [
 - web [`ReadableStream`](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream).
 - [`Iterable`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#the_iterable_protocol) or [`AsyncIterable`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#the_async_iterator_and_async_iterable_protocols)
 
+This can be an [array of values](#redirect-stdinstdoutstderr-to-multiple-destinations) such as `['inherit', 'pipe']` or `[filePath, 'pipe']`.
+
 #### stdout
 
-Type: `string | number | stream.Writable | WritableStream | URL`\
+Type: `string | number | stream.Writable | WritableStream | URL` (or a tuple of those types)\
 Default: `pipe`
 
 [How to setup](https://nodejs.org/api/child_process.html#child_process_options_stdio) the child process' standard output. This can be:
@@ -606,9 +608,11 @@ Unless either [synchronous methods](#execasyncfile-arguments-options), the value
 - file URL.
 - web [`WritableStream`](https://developer.mozilla.org/en-US/docs/Web/API/WritableStream).
 
+This can be an [array of values](#redirect-stdinstdoutstderr-to-multiple-destinations) such as `['inherit', 'pipe']` or `[filePath, 'pipe']`.
+
 #### stderr
 
-Type: `string | number | stream.Writable | WritableStream | URL`\
+Type: `string | number | stream.Writable | WritableStream | URL` (or a tuple of those types)`\
 Default: `pipe`
 
 [How to setup](https://nodejs.org/api/child_process.html#child_process_options_stdio) the child process' standard error. This can be:
@@ -625,15 +629,18 @@ Unless either [synchronous methods](#execasyncfile-arguments-options), the value
 - file URL.
 - web [`WritableStream`](https://developer.mozilla.org/en-US/docs/Web/API/WritableStream).
 
+This can be an [array of values](#redirect-stdinstdoutstderr-to-multiple-destinations) such as `['inherit', 'pipe']` or `[filePath, 'pipe']`.
+
 #### stdio
 
-Type: `string | [StdinOption, StdoutOption, StderrOption] | StdioOption[]`\
+Type: `string | Array<string | number | stream.Readable | stream.Writable | ReadableStream | WritableStream | URL | Iterable<string | Uint8Array> | AsyncIterable<string | Uint8Array>>` (or a tuple of those types)\
 Default: `pipe`
 
-Like the [`stdin`](#stdin), [`stdout`](#stdout-1) and [`stderr`](#stderr-1) options but for all file descriptors at once.\
-The possible values are the same except it can also be:
-- a single string, to set the same value to each standard stream.
-- an array with more than 3 values, to create more than 3 file descriptors.
+Like the [`stdin`](#stdin), [`stdout`](#stdout-1) and [`stderr`](#stderr-1) options but for all file descriptors at once. For example, `{stdio: ['ignore', 'pipe', 'pipe']}` is the same as `{stdin: 'ignore', stdout: 'pipe', stderr: 'pipe'}`.
+
+A single string can be used as a shortcut. For example, `{stdio: 'pipe'}` is the same as `{stdin: 'pipe', stdout: 'pipe', stderr: 'pipe'}`.
+
+The array can have more than 3 items, to create additional file descriptors beyond `stdin`/`stdout`/`stderr`. For example, `{stdio: ['pipe', 'pipe', 'pipe', 'ipc']}` sets a fourth file descriptor `'ipc'`.
 
 #### all
 
@@ -803,6 +810,18 @@ List of [CLI options](https://nodejs.org/api/cli.html#cli_options) passed to the
 
 ## Tips
 
+### Redirect stdin/stdout/stderr to multiple destinations
+
+The [`stdin`](#stdin), [`stdout`](#stdout-1) and [`stderr`](#stderr-1) options can be an array of values.
+The following example redirects `stdout` to both the terminal and an `output.txt` file, while also retrieving its value programmatically.
+
+```js
+const {stdout} = await execa('npm', ['install'], {stdout: ['inherit', './output.txt', 'pipe']})
+console.log(stdout);
+```
+
+When combining `inherit` with other values, please note that the child process will not be an interactive TTY, even if the parent process is one.
+
 ### Retry on error
 
 Gracefully handle failures by using automatic retries and exponential backoff with the [`p-retry`](https://github.com/sindresorhus/p-retry) package:
