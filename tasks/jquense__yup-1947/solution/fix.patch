diff --git a/src/array.ts b/src/array.ts
index c19f8ab..b03b74f 100644
--- a/src/array.ts
+++ b/src/array.ts
@@ -38,17 +38,23 @@ export function create<C extends Maybe<AnyObject> = AnyObject, T = any>(
   return new ArraySchema<T[] | undefined, C>(type as any);
 }
 
+interface ArraySchemaSpec<TIn, TContext> extends SchemaSpec<any> {
+  types?: ISchema<InnerType<TIn>, TContext>
+}
+
 export default class ArraySchema<
   TIn extends any[] | null | undefined,
   TContext,
   TDefault = undefined,
   TFlags extends Flags = '',
 > extends Schema<TIn, TContext, TDefault, TFlags> {
+  declare spec: ArraySchemaSpec<TIn, TContext>;
   readonly innerType?: ISchema<InnerType<TIn>, TContext>;
 
   constructor(type?: ISchema<InnerType<TIn>, TContext>) {
     super({
       type: 'array',
+      spec: { types: type } as ArraySchemaSpec<TIn, TContext>,
       check(v: any): v is NonNullable<TIn> {
         return Array.isArray(v);
       },
@@ -183,6 +189,11 @@ export default class ArraySchema<
     // @ts-expect-error readonly
     next.innerType = schema;
 
+    next.spec = {
+      ...next.spec,
+      types: schema as ISchema<InnerType<TIn>, TContext>
+    }
+
     return next as any;
   }
 
@@ -263,7 +274,7 @@ export default class ArraySchema<
           value: innerOptions.value[0],
         };
       }
-      base.innerType = this.innerType.describe(options);
+      base.innerType = this.innerType.describe(innerOptions);
     }
     return base;
   }
diff --git a/src/schema.ts b/src/schema.ts
index a1f46dc..363bec3 100644
--- a/src/schema.ts
+++ b/src/schema.ts
@@ -100,7 +100,7 @@ export interface SchemaRefDescription {
 }
 
 export interface SchemaInnerTypeDescription extends SchemaDescription {
-  innerType?: SchemaFieldDescription;
+  innerType?: SchemaFieldDescription | SchemaFieldDescription[];
 }
 
 export interface SchemaObjectDescription extends SchemaDescription {
diff --git a/src/tuple.ts b/src/tuple.ts
index 7cc796c..40fbf0c 100644
--- a/src/tuple.ts
+++ b/src/tuple.ts
@@ -11,7 +11,12 @@ import type {
   UnsetFlag,
   Maybe,
 } from './util/types';
-import Schema, { RunTest, SchemaSpec } from './schema';
+import type { ResolveOptions } from './Condition';
+import Schema, {
+  RunTest,
+  SchemaInnerTypeDescription,
+  SchemaSpec,
+} from './schema';
 import ValidationError from './ValidationError';
 import { tuple as tupleLocale } from './locale';
 
@@ -148,6 +153,22 @@ export default class TupleSchema<
       );
     });
   }
+
+  describe(options?: ResolveOptions<TContext>) {
+    let base = super.describe(options) as SchemaInnerTypeDescription;
+    base.innerType = this.spec.types.map((schema, index) => {
+      let innerOptions = options;
+      if (innerOptions?.value) {
+        innerOptions = {
+          ...innerOptions,
+          parent: innerOptions.value,
+          value: innerOptions.value[index],
+        };
+      }
+      return schema.describe(innerOptions);
+    });
+    return base;
+  }
 }
 
 create.prototype = TupleSchema.prototype;
