diff --git a/cypress/integration/rendering/classDiagram.spec.js b/cypress/integration/rendering/classDiagram.spec.js
index 427b4cf0b..cda455f0e 100644
--- a/cypress/integration/rendering/classDiagram.spec.js
+++ b/cypress/integration/rendering/classDiagram.spec.js
@@ -286,7 +286,7 @@ describe('Class diagram', () => {
     cy.get('svg');
   });
 
-  it('15: should render a simple class diagram with css classes applied to multiple classes', () => {
+  it('15: should render a simple class diagram with css classes applied two multiple classes', () => {
     imgSnapshotTest(
       `
     classDiagram
diff --git a/docs/syntax/classDiagram.md b/docs/syntax/classDiagram.md
index 1287908c9..15ae26444 100644
--- a/docs/syntax/classDiagram.md
+++ b/docs/syntax/classDiagram.md
@@ -128,7 +128,7 @@ classDiagram
     Vehicle <|-- Car
 ```
 
-Naming convention: a class name should be composed only of alphanumeric characters (including unicode), underscores, and dashes (-).
+Naming convention: a class name should be composed only of alphanumeric characters (including unicode), and underscores.
 
 ### Class labels
 
@@ -283,12 +283,12 @@ To describe the visibility (or encapsulation) of an attribute or method/function
 - `#` Protected
 - `~` Package/Internal
 
-> _note_ you can also include additional _classifiers_ to a method definition by adding the following notation to the _end_ of the method, i.e.: after the `()` or after the return type:
+> _note_ you can also include additional _classifiers_ to a method definition by adding the following notation to the _end_ of the method, i.e.: after the `()`:
 >
-> - `*` Abstract e.g.: `someAbstractMethod()*` or `someAbstractMethod() int*`
-> - `$` Static e.g.: `someStaticMethod()$` or `someStaticMethod() String$`
+> - `*` Abstract e.g.: `someAbstractMethod()*`
+> - `$` Static e.g.: `someStaticMethod()$`
 
-> _note_ you can also include additional _classifiers_ to a field definition by adding the following notation to the very end:
+> _note_ you can also include additional _classifiers_ to a field definition by adding the following notation to the end of its name:
 >
 > - `$` Static e.g.: `String someField$`
 
diff --git a/packages/mermaid/src/diagrams/class/classDb.ts b/packages/mermaid/src/diagrams/class/classDb.ts
index a2121f69e..8fa1eeb26 100644
--- a/packages/mermaid/src/diagrams/class/classDb.ts
+++ b/packages/mermaid/src/diagrams/class/classDb.ts
@@ -106,7 +106,6 @@ export const clear = function () {
 export const getClass = function (id: string) {
   return classes[id];
 };
-
 export const getClasses = function () {
   return classes;
 };
@@ -171,10 +170,9 @@ export const addMember = function (className: string, member: string) {
     const memberString = member.trim();
 
     if (memberString.startsWith('<<') && memberString.endsWith('>>')) {
-      // its an annotation
+      // Remove leading and trailing brackets
       theClass.annotations.push(sanitizeText(memberString.substring(2, memberString.length - 2)));
     } else if (memberString.indexOf(')') > 0) {
-      //its a method
       theClass.methods.push(sanitizeText(memberString));
     } else if (memberString) {
       theClass.members.push(sanitizeText(memberString));
@@ -236,7 +234,6 @@ const setTooltip = function (ids: string, tooltip?: string) {
     }
   });
 };
-
 export const getTooltip = function (id: string) {
   return classes[id].tooltip;
 };
diff --git a/packages/mermaid/src/diagrams/class/classDiagram.spec.ts b/packages/mermaid/src/diagrams/class/classDiagram.spec.ts
index f2492e5cc..6dbf9c081 100644
--- a/packages/mermaid/src/diagrams/class/classDiagram.spec.ts
+++ b/packages/mermaid/src/diagrams/class/classDiagram.spec.ts
@@ -4,36 +4,18 @@ import classDb from './classDb.js';
 import { vi, describe, it, expect } from 'vitest';
 const spyOn = vi.spyOn;
 
-describe('given a basic class diagram, ', function () {
-  describe('when parsing class definition', function () {
+describe('class diagram, ', function () {
+  describe('when parsing a class diagram', function () {
     beforeEach(function () {
-      classDb.clear();
       parser.yy = classDb;
     });
-    it('should handle accTitle and accDescr', function () {
-      const str = `classDiagram
-            accTitle: My Title
-            accDescr: My Description`;
-
-      parser.parse(str);
-      expect(parser.yy.getAccTitle()).toBe('My Title');
-      expect(parser.yy.getAccDescription()).toBe('My Description');
-    });
 
-    it('should handle accTitle and multiline accDescr', function () {
-      const str = `classDiagram
-            accTitle: My Title
-            accDescr {
-              This is my multi
-              line description
-            }`;
+    it('should handle backquoted class names', function () {
+      const str = 'classDiagram\n' + 'class `Car`';
 
       parser.parse(str);
-      expect(parser.yy.getAccTitle()).toBe('My Title');
-      expect(parser.yy.getAccDescription()).toBe('This is my multi\nline description');
     });
-
-    it.skip('should handle a leading newline', function () {
+    it.skip('should handle a leading newline axa', function () {
       const str = '\nclassDiagram\n' + 'class Car';
 
       try {
@@ -43,325 +25,304 @@ describe('given a basic class diagram, ', function () {
         expect(true).toBe(false);
       }
     });
-
-    it('should handle backquoted class names', function () {
-      const str = 'classDiagram\n' + 'class `Car`';
+    it('should handle relation definitions', function () {
+      const str =
+        'classDiagram\n' +
+        'Class01 <|-- Class02\n' +
+        'Class03 *-- Class04\n' +
+        'Class05 o-- Class06\n' +
+        'Class07 .. Class08\n' +
+        'Class09 -- Class1';
 
       parser.parse(str);
     });
 
-    it('should handle class names with dash', function () {
-      const str = 'classDiagram\n' + 'class Ca-r';
+    it('should handle backquoted relation definitions', function () {
+      const str =
+        'classDiagram\n' +
+        '`Class01` <|-- Class02\n' +
+        'Class03 *-- Class04\n' +
+        'Class05 o-- Class06\n' +
+        'Class07 .. Class08\n' +
+        'Class09 -- Class1';
 
       parser.parse(str);
-      const actual = classDb.getClass('Ca-r');
-      expect(actual.label).toBe('Ca-r');
     });
 
-    it('should handle class names with underscore', function () {
-      const str = 'classDiagram\n' + 'class `A_Car`';
+    it('should handle relation definition of different types and directions', function () {
+      const str =
+        'classDiagram\n' +
+        'Class11 <|.. Class12\n' +
+        'Class13 --> Class14\n' +
+        'Class15 ..> Class16\n' +
+        'Class17 ..|> Class18\n' +
+        'Class19 <--* Class20';
 
       parser.parse(str);
     });
 
-    it('should handle parsing of separators', function () {
+    it('should handle cardinality and labels', function () {
       const str =
         'classDiagram\n' +
-        'class Foo1 {\n' +
-        '  You can use\n' +
-        '  several lines\n' +
-        '..\n' +
-        'as you want\n' +
-        'and group\n' +
-        '==\n' +
-        'things together.\n' +
-        '__\n' +
-        'You can have as many groups\n' +
-        'as you want\n' +
-        '--\n' +
-        'End of class\n' +
-        '}\n' +
-        '\n' +
-        'class User {\n' +
-        '.. Simple Getter ..\n' +
-        '+ getName()\n' +
-        '+ getAddress()\n' +
-        '.. Some setter ..\n' +
-        '+ setName()\n' +
-        '__ private data __\n' +
-        'int age\n' +
-        '-- encrypted --\n' +
-        'String password\n' +
-        '}';
+        'Class01 "1" *-- "many" Class02 : contains\n' +
+        'Class03 o-- Class04 : aggregation\n' +
+        'Class05 --> "1" Class06';
 
       parser.parse(str);
     });
 
-    it('should parse a class with a text label', () => {
-      const str = 'classDiagram\n' + 'class C1["Class 1 with text label"]';
+    it('should handle visibility for methods and members', function () {
+      const str =
+        'classDiagram\n' +
+        'class TestClass\n' +
+        'TestClass : -int privateMember\n' +
+        'TestClass : +int publicMember\n' +
+        'TestClass : #int protectedMember\n' +
+        'TestClass : -privateMethod()\n' +
+        'TestClass : +publicMethod()\n' +
+        'TestClass : #protectedMethod()\n';
 
       parser.parse(str);
-
-      const c1 = classDb.getClass('C1');
-      expect(c1.label).toBe('Class 1 with text label');
     });
 
-    it('should parse two classes with text labels', function () {
+    it('should handle generic class', function () {
       const str =
         'classDiagram\n' +
-        'class C1["Class 1 with text label"]\n' +
-        'class C2["Class 2 with chars @?"]\n';
+        'class Car~T~\n' +
+        'Driver -- Car : drives >\n' +
+        'Car *-- Wheel : have 4 >\n' +
+        'Car -- Person : < owns';
 
       parser.parse(str);
-
-      const c1 = classDb.getClass('C1');
-      expect(c1.label).toBe('Class 1 with text label');
-      const c2 = classDb.getClass('C2');
-      expect(c2.label).toBe('Class 2 with chars @?');
     });
 
-    it('should parse a class with a text label and member', () => {
-      const str = 'classDiagram\n' + 'class C1["Class 1 with text label"]\n' + 'C1: member1';
+    it('should handle generic class with a literal name', function () {
+      const str =
+        'classDiagram\n' +
+        'class `Car`~T~\n' +
+        'Driver -- `Car` : drives >\n' +
+        '`Car` *-- Wheel : have 4 >\n' +
+        '`Car` -- Person : < owns';
 
       parser.parse(str);
-      const c1 = classDb.getClass('C1');
-      expect(c1.label).toBe('Class 1 with text label');
-      expect(c1.members.length).toBe(1);
-      expect(c1.members[0]).toBe('member1');
     });
 
-    it('should parse a class with a text label, member and annotation', () => {
+    it('should break when another `{`is encountered before closing the first one while defining generic class with brackets', function () {
       const str =
         'classDiagram\n' +
-        'class C1["Class 1 with text label"]\n' +
-        '<<interface>> C1\n' +
-        'C1 : int member1';
-
-      parser.parse(str);
+        'class Dummy_Class~T~ {\n' +
+        'String data\n' +
+        '  void methods()\n' +
+        '}\n' +
+        '\n' +
+        'class Dummy_Class {\n' +
+        'class Flight {\n' +
+        '   flightNumber : Integer\n' +
+        '   departureTime : Date\n' +
+        '}';
+      let testPassed = false;
+      try {
+        parser.parse(str);
+      } catch (error) {
+        testPassed = true;
+      }
+      expect(testPassed).toBe(true);
+    });
 
-      const c1 = classDb.getClass('C1');
-      expect(c1.label).toBe('Class 1 with text label');
-      expect(c1.members.length).toBe(1);
-      expect(c1.members[0]).toBe('int member1');
-      expect(c1.annotations.length).toBe(1);
-      expect(c1.annotations[0]).toBe('interface');
+    it('should break when EOF is encountered before closing the first `{` while defining generic class with brackets', function () {
+      const str =
+        'classDiagram\n' +
+        'class Dummy_Class~T~ {\n' +
+        'String data\n' +
+        '  void methods()\n' +
+        '}\n' +
+        '\n' +
+        'class Dummy_Class {\n';
+      let testPassed = false;
+      try {
+        parser.parse(str);
+      } catch (error) {
+        testPassed = true;
+      }
+      expect(testPassed).toBe(true);
     });
 
-    it('should parse a class with text label and css class shorthand', () => {
-      const str = 'classDiagram\n' + 'class C1["Class 1 with text label"]:::styleClass';
+    it('should handle generic class with brackets', function () {
+      const str =
+        'classDiagram\n' +
+        'class Dummy_Class~T~ {\n' +
+        'String data\n' +
+        '  void methods()\n' +
+        '}\n' +
+        '\n' +
+        'class Flight {\n' +
+        '   flightNumber : Integer\n' +
+        '   departureTime : Date\n' +
+        '}';
 
       parser.parse(str);
-
-      const c1 = classDb.getClass('C1');
-      expect(c1.label).toBe('Class 1 with text label');
-      expect(c1.cssClasses[0]).toBe('styleClass');
     });
 
-    it('should parse a class with text label and css class', () => {
+    it('should handle generic class with brackets and a literal name', function () {
       const str =
         'classDiagram\n' +
-        'class C1["Class 1 with text label"]\n' +
-        'C1 : int member1\n' +
-        'cssClass "C1" styleClass';
+        'class `Dummy_Class`~T~ {\n' +
+        'String data\n' +
+        '  void methods()\n' +
+        '}\n' +
+        '\n' +
+        'class Flight {\n' +
+        '   flightNumber : Integer\n' +
+        '   departureTime : Date\n' +
+        '}';
 
       parser.parse(str);
-
-      const c1 = classDb.getClass('C1');
-      expect(c1.label).toBe('Class 1 with text label');
-      expect(c1.members[0]).toBe('int member1');
-      expect(c1.cssClasses[0]).toBe('styleClass');
     });
 
-    it('should parse two classes with text labels and css classes', () => {
+    it('should handle class definitions', function () {
       const str =
         'classDiagram\n' +
-        'class C1["Class 1 with text label"]\n' +
-        'C1 : int member1\n' +
-        'class C2["Long long long long long long long long long long label"]\n' +
-        'cssClass "C1,C2" styleClass';
+        'class Car\n' +
+        'Driver -- Car : drives >\n' +
+        'Car *-- Wheel : have 4 >\n' +
+        'Car -- Person : < owns';
 
       parser.parse(str);
+    });
 
-      const c1 = classDb.getClass('C1');
-      expect(c1.label).toBe('Class 1 with text label');
-      expect(c1.cssClasses[0]).toBe('styleClass');
+    it('should handle cssClass shorthand with members', () => {
+      parser.parse(`classDiagram-v2
+      class Class10:::exClass2 {
+        int[] id
+        List~int~ ids
+        test(List~int~ ids) List~bool~
+        testArray() bool[]
+      }`);
+
+      expect(classDb.getClass('Class10')).toMatchInlineSnapshot(`
+        {
+          "annotations": [],
+          "cssClasses": [
+            "exClass2",
+          ],
+          "domId": "classId-Class10-27",
+          "id": "Class10",
+          "label": "Class10",
+          "members": [
+            "int[] id",
+            "List~int~ ids",
+          ],
+          "methods": [
+            "test(List~int~ ids) List~bool~",
+            "testArray() bool[]",
+          ],
+          "type": "",
+        }
+      `);
+    });
+
+    it('should handle method statements', function () {
+      const str =
+        'classDiagram\n' +
+        'Object <|-- ArrayList\n' +
+        'Object : equals()\n' +
+        'ArrayList : Object[] elementData\n' +
+        'ArrayList : size()';
 
-      const c2 = classDb.getClass('C2');
-      expect(c2.label).toBe('Long long long long long long long long long long label');
-      expect(c2.cssClasses[0]).toBe('styleClass');
+      parser.parse(str);
     });
 
-    it('should parse two classes with text labels and css class shorthands', () => {
+    it('should handle parsing of method statements grouped by brackets', function () {
       const str =
         'classDiagram\n' +
-        'class C1["Class 1 with text label"]:::styleClass1\n' +
-        'class C2["Class 2 !@#$%^&*() label"]:::styleClass2';
+        'class Dummy_Class {\n' +
+        'String data\n' +
+        '  void methods()\n' +
+        '}\n' +
+        '\n' +
+        'class Flight {\n' +
+        '   flightNumber : Integer\n' +
+        '   departureTime : Date\n' +
+        '}';
 
       parser.parse(str);
+    });
 
-      const c1 = classDb.getClass('C1');
-      expect(c1.label).toBe('Class 1 with text label');
-      expect(c1.cssClasses[0]).toBe('styleClass1');
+    it('should handle return types on methods', function () {
+      const str =
+        'classDiagram\n' +
+        'Object <|-- ArrayList\n' +
+        'Object : equals()\n' +
+        'Object : -Object[] objects\n' +
+        'Object : +getObjects() Object[]\n' +
+        'ArrayList : Dummy elementData\n' +
+        'ArrayList : getDummy() Dummy';
 
-      const c2 = classDb.getClass('C2');
-      expect(c2.label).toBe('Class 2 !@#$%^&*() label');
-      expect(c2.cssClasses[0]).toBe('styleClass2');
+      parser.parse(str);
     });
 
-    it('should parse multiple classes with same text labels', () => {
-      parser.parse(`classDiagram
-class C1["Class with text label"]
-class C2["Class with text label"]
-class C3["Class with text label"]`);
+    it('should handle return types on methods grouped by brackets', function () {
+      const str =
+        'classDiagram\n' +
+        'class Dummy_Class {\n' +
+        'string data\n' +
+        'getDummy() Dummy\n' +
+        '}\n' +
+        '\n' +
+        'class Flight {\n' +
+        '   int flightNumber\n' +
+        '   datetime departureTime\n' +
+        '   getDepartureTime() datetime\n' +
+        '}';
 
-      const c1 = classDb.getClass('C1');
-      expect(c1.label).toBe('Class with text label');
+      parser.parse(str);
+    });
 
-      const c2 = classDb.getClass('C2');
-      expect(c2.label).toBe('Class with text label');
+    it('should handle parsing of separators', function () {
+      const str =
+        'classDiagram\n' +
+        'class Foo1 {\n' +
+        '  You can use\n' +
+        '  several lines\n' +
+        '..\n' +
+        'as you want\n' +
+        'and group\n' +
+        '==\n' +
+        'things together.\n' +
+        '__\n' +
+        'You can have as many groups\n' +
+        'as you want\n' +
+        '--\n' +
+        'End of class\n' +
+        '}\n' +
+        '\n' +
+        'class User {\n' +
+        '.. Simple Getter ..\n' +
+        '+ getName()\n' +
+        '+ getAddress()\n' +
+        '.. Some setter ..\n' +
+        '+ setName()\n' +
+        '__ private data __\n' +
+        'int age\n' +
+        '-- encrypted --\n' +
+        'String password\n' +
+        '}';
 
-      const c3 = classDb.getClass('C3');
-      expect(c3.label).toBe('Class with text label');
+      parser.parse(str);
     });
 
-    it('should parse classes with different text labels', () => {
-      parser.parse(`classDiagram
-class C1["OneWord"]
-class C2["With, Comma"]
-class C3["With (Brackets)"]
-class C4["With [Brackets]"]
-class C5["With {Brackets}"]
-class C6[" "]
-class C7["With 1 number"]
-class C8["With . period..."]
-class C9["With - dash"]
-class C10["With _ underscore"]
-class C11["With ' single quote"]
-class C12["With ~!@#$%^&*()_+=-/?"]
-class C13["With Città foreign language"]
-`);
-      expect(classDb.getClass('C1').label).toBe('OneWord');
-      expect(classDb.getClass('C2').label).toBe('With, Comma');
-      expect(classDb.getClass('C3').label).toBe('With (Brackets)');
-      expect(classDb.getClass('C4').label).toBe('With [Brackets]');
-      expect(classDb.getClass('C5').label).toBe('With {Brackets}');
-      expect(classDb.getClass('C6').label).toBe(' ');
-      expect(classDb.getClass('C7').label).toBe('With 1 number');
-      expect(classDb.getClass('C8').label).toBe('With . period...');
-      expect(classDb.getClass('C9').label).toBe('With - dash');
-      expect(classDb.getClass('C10').label).toBe('With _ underscore');
-      expect(classDb.getClass('C11').label).toBe("With ' single quote");
-      expect(classDb.getClass('C12').label).toBe('With ~!@#$%^&*()_+=-/?');
-      expect(classDb.getClass('C13').label).toBe('With Città foreign language');
-    });
-
-    it('should handle "note for"', function () {
-      const str = 'classDiagram\n' + 'Class11 <|.. Class12\n' + 'note for Class11 "test"\n';
-      parser.parse(str);
-    });
-
-    it('should handle "note"', function () {
-      const str = 'classDiagram\n' + 'note "test"\n';
-      parser.parse(str);
-    });
-  });
-
-  describe('when parsing class defined in brackets', function () {
-    beforeEach(function () {
-      classDb.clear();
-      parser.yy = classDb;
-    });
-
-    it('should handle member definitions', function () {
-      const str = 'classDiagram\n' + 'class Car{\n' + '+int wheels\n' + '}';
-
-      parser.parse(str);
-    });
-
-    it('should handle method definitions', function () {
-      const str = 'classDiagram\n' + 'class Car{\n' + '+size()\n' + '}';
-
-      parser.parse(str);
-    });
-
-    it('should handle a mix of members defined in and outside of brackets', function () {
-      const str =
-        'classDiagram\n' + 'class Car{\n' + '+int wheels\n' + '}\n' + 'Car : +ArrayList size()\n';
-
-      parser.parse(str);
-    });
-
-    it('should handle member and method definitions', () => {
-      const str =
-        'classDiagram\n' + 'class Dummy_Class {\n' + 'String data\n' + 'void methods()\n' + '}';
-
-      parser.parse(str);
-    });
-
-    it('should handle return types on methods', () => {
-      const str =
-        'classDiagram\n' +
-        'class Flight {\n' +
-        'int flightNumber\n' +
-        'datetime departureTime\n' +
-        'getDepartureTime() datetime\n' +
-        '}';
-
-      parser.parse(str);
-    });
-
-    it('should add bracket members in right order', () => {
+    it('should handle a comment', function () {
       const str =
         'classDiagram\n' +
         'class Class1 {\n' +
-        'int testMember\n' +
-        'string fooMember\n' +
+        '%% Comment\n' +
+        'int : test\n' +
+        'string : foo\n' +
         'test()\n' +
         'foo()\n' +
         '}';
-      parser.parse(str);
-
-      const actual = parser.yy.getClass('Class1');
-      expect(actual.members.length).toBe(2);
-      expect(actual.methods.length).toBe(2);
-      expect(actual.members[0]).toBe('int testMember');
-      expect(actual.members[1]).toBe('string fooMember');
-      expect(actual.methods[0]).toBe('test()');
-      expect(actual.methods[1]).toBe('foo()');
-    });
-
-    it('should parse a class with a text label and members', () => {
-      const str = 'classDiagram\n' + 'class C1["Class 1 with text label"] {\n' + '+member1\n' + '}';
-
-      parser.parse(str);
-      const c1 = classDb.getClass('C1');
-      expect(c1.label).toBe('Class 1 with text label');
-      expect(c1.members.length).toBe(1);
-      expect(c1.members[0]).toBe('+member1');
-    });
-
-    it('should parse a class with a text label, members and annotation', () => {
-      const str =
-        'classDiagram\n' +
-        'class C1["Class 1 with text label"] {\n' +
-        '<<interface>>\n' +
-        '+member1\n' +
-        '}';
 
       parser.parse(str);
-      const c1 = classDb.getClass('C1');
-      expect(c1.label).toBe('Class 1 with text label');
-      expect(c1.members.length).toBe(1);
-      expect(c1.members[0]).toBe('+member1');
-      expect(c1.annotations.length).toBe(1);
-      expect(c1.annotations[0]).toBe('interface');
-    });
-  });
-
-  describe('when parsing comments', function () {
-    beforeEach(function () {
-      classDb.clear();
-      parser.yy = classDb;
     });
 
     it('should handle comments at the start', function () {
@@ -422,7 +383,7 @@ foo()
 
     it('should handle a comment with mermaid class diagram code in them', function () {
       const str = `classDiagram
-%% Comment Class1 <|-- Class02
+%% Comment Class01 <|-- Class02
 class Class1 {
 int : test
 string : foo
@@ -437,7 +398,7 @@ foo()
       const str =
         'classDiagram\n' +
         'class Class1 {\n' +
-        '%% Comment Class1 <|-- Class02\n' +
+        '%% Comment Class01 <|-- Class02\n' +
         'int : test\n' +
         'string : foo\n' +
         'test()\n' +
@@ -446,610 +407,762 @@ foo()
 
       parser.parse(str);
     });
-  });
 
-  describe('when parsing click statements', function () {
-    beforeEach(function () {
-      classDb.clear();
-      parser.yy = classDb;
-    });
-    it('should handle href link', function () {
-      spyOn(classDb, 'setLink');
-      const str = 'classDiagram\n' + 'class Class1 \n' + 'click Class1 href "google.com" ';
+    it('should handle click statement with link', function () {
+      const str =
+        'classDiagram\n' +
+        'class Class1 {\n' +
+        '%% Comment Class01 <|-- Class02\n' +
+        'int : test\n' +
+        'string : foo\n' +
+        'test()\n' +
+        'foo()\n' +
+        '}\n' +
+        'link Class01 "google.com" ';
 
       parser.parse(str);
-
-      expect(classDb.setLink).toHaveBeenCalledWith('Class1', 'google.com');
-
-      const actual = parser.yy.getClass('Class1');
-      expect(actual.link).toBe('google.com');
-      expect(actual.cssClasses[0]).toBe('clickable');
     });
 
-    it('should handle href link with tooltip', function () {
-      spyOn(classDb, 'setLink');
-      spyOn(classDb, 'setTooltip');
+    it('should handle click statement with click and href link', function () {
       const str =
-        'classDiagram\n' + 'class Class1 \n' + 'click Class1 href "google.com" "A Tooltip" ';
+        'classDiagram\n' +
+        'class Class1 {\n' +
+        '%% Comment Class01 <|-- Class02\n' +
+        'int : test\n' +
+        'string : foo\n' +
+        'test()\n' +
+        'foo()\n' +
+        '}\n' +
+        'click Class01 href "google.com" ';
 
       parser.parse(str);
-
-      expect(classDb.setLink).toHaveBeenCalledWith('Class1', 'google.com');
-
-      const actual = parser.yy.getClass('Class1');
-      expect(actual.link).toBe('google.com');
-      expect(actual.tooltip).toBe('A Tooltip');
-      expect(actual.cssClasses[0]).toBe('clickable');
     });
 
-    it('should handle href link with tooltip and target', function () {
-      spyOn(classDb, 'setLink');
-      spyOn(classDb, 'setTooltip');
+    it('should handle click statement with link and tooltip', function () {
       const str =
         'classDiagram\n' +
-        'class Class1\n' +
-        'Class1 : someMethod()\n' +
-        'click Class1 href "google.com" "A tooltip" _self';
-      parser.parse(str);
-
-      expect(classDb.setLink).toHaveBeenCalledWith('Class1', 'google.com', '_self');
-      expect(classDb.setTooltip).toHaveBeenCalledWith('Class1', 'A tooltip');
-
-      const actual = parser.yy.getClass('Class1');
-      expect(actual.link).toBe('google.com');
-      expect(actual.tooltip).toBe('A tooltip');
-      expect(actual.cssClasses[0]).toBe('clickable');
-    });
-
-    it('should handle function call', function () {
-      spyOn(classDb, 'setClickEvent');
-
-      const str = 'classDiagram\n' + 'class Class1 \n' + 'click Class1 call functionCall() ';
+        'class Class1 {\n' +
+        '%% Comment Class01 <|-- Class02\n' +
+        'int : test\n' +
+        'string : foo\n' +
+        'test()\n' +
+        'foo()\n' +
+        '}\n' +
+        'link Class01 "google.com" "A Tooltip" ';
 
       parser.parse(str);
-
-      expect(classDb.setClickEvent).toHaveBeenCalledWith('Class1', 'functionCall');
     });
 
-    it('should handle function call with tooltip', function () {
-      spyOn(classDb, 'setClickEvent');
-      spyOn(classDb, 'setTooltip');
-
+    it('should handle click statement with click and href link and tooltip', function () {
       const str =
-        'classDiagram\n' + 'class Class1 \n' + 'click Class1 call functionCall() "A Tooltip" ';
+        'classDiagram\n' +
+        'class Class1 {\n' +
+        '%% Comment Class01 <|-- Class02\n' +
+        'int : test\n' +
+        'string : foo\n' +
+        'test()\n' +
+        'foo()\n' +
+        '}\n' +
+        'click Class01 href "google.com" "A Tooltip" ';
 
       parser.parse(str);
-
-      expect(classDb.setClickEvent).toHaveBeenCalledWith('Class1', 'functionCall');
-      expect(classDb.setTooltip).toHaveBeenCalledWith('Class1', 'A Tooltip');
     });
 
-    it('should handle function call with an arbitrary number of args', function () {
-      spyOn(classDb, 'setClickEvent');
+    it('should handle click statement with callback', function () {
       const str =
         'classDiagram\n' +
-        'class Class1\n' +
-        'Class1 : someMethod()\n' +
-        'click Class1 call functionCall(test, test1, test2)';
-      parser.parse(str);
+        'class Class1 {\n' +
+        '%% Comment Class01 <|-- Class02\n' +
+        'int : test\n' +
+        'string : foo\n' +
+        'test()\n' +
+        'foo()\n' +
+        '}\n' +
+        'callback Class01 "functionCall" ';
 
-      expect(classDb.setClickEvent).toHaveBeenCalledWith(
-        'Class1',
-        'functionCall',
-        'test, test1, test2'
-      );
+      parser.parse(str);
     });
 
-    it('should handle function call with an arbitrary number of args and tooltip', function () {
-      spyOn(classDb, 'setClickEvent');
-      spyOn(classDb, 'setTooltip');
+    it('should handle click statement with click and call callback', function () {
       const str =
         'classDiagram\n' +
-        'class Class1\n' +
-        'Class1 : someMethod()\n' +
-        'click Class1 call functionCall("test0", test1, test2) "A Tooltip"';
-      parser.parse(str);
-
-      expect(classDb.setClickEvent).toHaveBeenCalledWith(
-        'Class1',
-        'functionCall',
-        '"test0", test1, test2'
-      );
-      expect(classDb.setTooltip).toHaveBeenCalledWith('Class1', 'A Tooltip');
-    });
-  });
-
-  describe('when parsing annotations', function () {
-    beforeEach(function () {
-      classDb.clear();
-      parser.yy = classDb;
-    });
+        'class Class1 {\n' +
+        '%% Comment Class01 <|-- Class02\n' +
+        'int : test\n' +
+        'string : foo\n' +
+        'test()\n' +
+        'foo()\n' +
+        '}\n' +
+        'click Class01 call functionCall() ';
 
-    it('should handle class annotations', function () {
-      const str = 'classDiagram\n' + 'class Class1\n' + '<<interface>> Class1';
       parser.parse(str);
-
-      const actual = parser.yy.getClass('Class1');
-      expect(actual.annotations.length).toBe(1);
-      expect(actual.members.length).toBe(0);
-      expect(actual.methods.length).toBe(0);
-      expect(actual.annotations[0]).toBe('interface');
     });
 
-    it('should handle class annotations with members and methods', function () {
+    it('should handle click statement with callback and tooltip', function () {
       const str =
         'classDiagram\n' +
-        'class Class1\n' +
-        'Class1 : int test\n' +
-        'Class1 : test()\n' +
-        '<<interface>> Class1';
-      parser.parse(str);
-
-      const actual = parser.yy.getClass('Class1');
-      expect(actual.annotations.length).toBe(1);
-      expect(actual.members.length).toBe(1);
-      expect(actual.methods.length).toBe(1);
-      expect(actual.annotations[0]).toBe('interface');
-    });
+        'class Class1 {\n' +
+        '%% Comment Class01 <|-- Class02\n' +
+        'int : test\n' +
+        'string : foo\n' +
+        'test()\n' +
+        'foo()\n' +
+        '}\n' +
+        'callback Class01 "functionCall" "A Tooltip" ';
 
-    it('should handle class annotations in brackets', function () {
-      const str = 'classDiagram\n' + 'class Class1 {\n' + '<<interface>>\n' + '}';
       parser.parse(str);
-
-      const actual = parser.yy.getClass('Class1');
-      expect(actual.annotations.length).toBe(1);
-      expect(actual.members.length).toBe(0);
-      expect(actual.methods.length).toBe(0);
-      expect(actual.annotations[0]).toBe('interface');
     });
 
-    it('should handle class annotations in brackets with members and methods', function () {
+    it('should handle click statement with click and call callback and tooltip', function () {
       const str =
         'classDiagram\n' +
         'class Class1 {\n' +
-        '<<interface>>\n' +
+        '%% Comment Class01 <|-- Class02\n' +
         'int : test\n' +
+        'string : foo\n' +
         'test()\n' +
-        '}';
-      parser.parse(str);
-
-      const actual = parser.yy.getClass('Class1');
-      expect(actual.annotations.length).toBe(1);
-      expect(actual.members.length).toBe(1);
-      expect(actual.methods.length).toBe(1);
-      expect(actual.annotations[0]).toBe('interface');
-    });
-  });
-});
-
-describe('given a class diagram with members and methods ', function () {
-  describe('when parsing members', function () {
-    beforeEach(function () {
-      classDb.clear();
-      parser.yy = classDb;
-    });
-
-    it('should handle simple member declaration', function () {
-      const str = 'classDiagram\n' + 'class Car\n' + 'Car : wheels';
+        'foo()\n' +
+        '}\n' +
+        'click Class01 call functionCall() "A Tooltip" ';
 
       parser.parse(str);
     });
 
-    it('should handle simple member declaration with type', function () {
-      const str = 'classDiagram\n' + 'class Car\n' + 'Car : int wheels';
-
+    it('should handle dashed relation definition of different types and directions', function () {
+      const str =
+        'classDiagram\n' +
+        'Class11 <|.. Class12\n' +
+        'Class13 <.. Class14\n' +
+        'Class15 ..|> Class16\n' +
+        'Class17 ..> Class18\n' +
+        'Class19 .. Class20';
       parser.parse(str);
     });
 
-    it('should handle visibility', function () {
+    it('should handle generic types in members', function () {
       const str =
         'classDiagram\n' +
-        'class actual\n' +
-        'actual : -int privateMember\n' +
-        'actual : +int publicMember\n' +
-        'actual : #int protectedMember\n' +
-        'actual : ~int privatePackage';
+        'class Car~T~\n' +
+        'Car : -List~Wheel~ wheels\n' +
+        'Car : +setWheels(List~Wheel~ wheels)\n' +
+        'Car : +getWheels() List~Wheel~';
 
       parser.parse(str);
-
-      const actual = parser.yy.getClass('actual');
-      expect(actual.members.length).toBe(4);
-      expect(actual.methods.length).toBe(0);
-      expect(actual.members[0]).toBe('-int privateMember');
-      expect(actual.members[1]).toBe('+int publicMember');
-      expect(actual.members[2]).toBe('#int protectedMember');
-      expect(actual.members[3]).toBe('~int privatePackage');
     });
 
-    it('should handle generic types', function () {
-      const str = 'classDiagram\n' + 'class Car\n' + 'Car : -List~Wheel~ wheels';
+    it('should handle generic types in members in class with brackets', function () {
+      const str =
+        'classDiagram\n' +
+        'class Car {\n' +
+        'List~Wheel~ wheels\n' +
+        'setWheels(List~Wheel~ wheels)\n' +
+        '+getWheels() List~Wheel~\n' +
+        '}';
 
       parser.parse(str);
     });
+
+    it('should handle "note for"', function () {
+      const str = 'classDiagram\n' + 'Class11 <|.. Class12\n' + 'note for Class11 "test"\n';
+      parser.parse(str);
+    });
+
+    it('should handle "note"', function () {
+      const str = 'classDiagram\n' + 'note "test"\n';
+      parser.parse(str);
+    });
   });
 
-  describe('when parsing method definition', function () {
+  describe('when fetching data from a classDiagram it', function () {
     beforeEach(function () {
-      classDb.clear();
       parser.yy = classDb;
+      parser.yy.clear();
     });
-
-    it('should handle method definition', function () {
-      const str = 'classDiagram\n' + 'class Car\n' + 'Car : GetSize()';
+    it('should handle relation definitions EXTENSION', function () {
+      const str = 'classDiagram\n' + 'Class01 <|-- Class02';
 
       parser.parse(str);
-    });
 
-    it('should handle simple return types', function () {
-      const str = 'classDiagram\n' + 'class Object\n' + 'Object : getObject() Object';
+      const relations = parser.yy.getRelations();
 
-      parser.parse(str);
+      expect(parser.yy.getClass('Class01').id).toBe('Class01');
+      expect(parser.yy.getClass('Class02').id).toBe('Class02');
+      expect(relations[0].relation.type1).toBe(classDb.relationType.EXTENSION);
+      expect(relations[0].relation.type2).toBe('none');
+      expect(relations[0].relation.lineType).toBe(classDb.lineType.LINE);
     });
 
-    it('should handle return types as array', function () {
-      const str = 'classDiagram\n' + 'class Object\n' + 'Object : getObjects() Object[]';
+    it('should handle accTitle and accDescr', function () {
+      const str = `classDiagram
+            accTitle: My Title
+            accDescr: My Description
+
+            Class01 <|-- Class02
+            `;
 
       parser.parse(str);
+      expect(parser.yy.getAccTitle()).toBe('My Title');
+      expect(parser.yy.getAccDescription()).toBe('My Description');
     });
+    it('should handle accTitle and multiline accDescr', function () {
+      const str = `classDiagram
+            accTitle: My Title
+            accDescr {
+              This is mu multi
+              line description
+            }
 
-    it('should handle visibility', function () {
-      const str =
-        'classDiagram\n' +
-        'class actual\n' +
-        'actual : -privateMethod()\n' +
-        'actual : +publicMethod()\n' +
-        'actual : #protectedMethod()\n';
+            Class01 <|-- Class02
+            `;
 
       parser.parse(str);
+      expect(parser.yy.getAccTitle()).toBe('My Title');
+      expect(parser.yy.getAccDescription()).toBe('This is mu multi\nline description');
     });
 
-    it('should handle abstract methods', function () {
-      const str = 'classDiagram\n' + 'class Class1\n' + 'Class1 : someMethod()*';
+    it('should handle relation definitions AGGREGATION and dotted line', function () {
+      const str = 'classDiagram\n' + 'Class01 o.. Class02';
+
       parser.parse(str);
 
-      const actual = parser.yy.getClass('Class1');
-      expect(actual.annotations.length).toBe(0);
-      expect(actual.members.length).toBe(0);
-      expect(actual.methods.length).toBe(1);
-      expect(actual.methods[0]).toBe('someMethod()*');
+      const relations = parser.yy.getRelations();
+
+      expect(parser.yy.getClass('Class01').id).toBe('Class01');
+      expect(parser.yy.getClass('Class02').id).toBe('Class02');
+      expect(relations[0].relation.type1).toBe(classDb.relationType.AGGREGATION);
+      expect(relations[0].relation.type2).toBe('none');
+      expect(relations[0].relation.lineType).toBe(classDb.lineType.DOTTED_LINE);
     });
 
-    it('should handle static methods', function () {
-      const str = 'classDiagram\n' + 'class Class1\n' + 'Class1 : someMethod()$';
+    it('should handle relation definitions COMPOSITION on both sides', function () {
+      const str = 'classDiagram\n' + 'Class01 *--* Class02';
+
       parser.parse(str);
 
-      const actual = parser.yy.getClass('Class1');
-      expect(actual.annotations.length).toBe(0);
-      expect(actual.members.length).toBe(0);
-      expect(actual.methods.length).toBe(1);
-      expect(actual.methods[0]).toBe('someMethod()$');
+      const relations = parser.yy.getRelations();
+
+      expect(parser.yy.getClass('Class01').id).toBe('Class01');
+      expect(parser.yy.getClass('Class02').id).toBe('Class02');
+      expect(relations[0].relation.type1).toBe(classDb.relationType.COMPOSITION);
+      expect(relations[0].relation.type2).toBe(classDb.relationType.COMPOSITION);
+      expect(relations[0].relation.lineType).toBe(classDb.lineType.LINE);
     });
 
-    it('should handle generic types in arguments', function () {
-      const str = 'classDiagram\n' + 'class Car\n' + 'Car : +setWheels(List~Wheel~ wheels)';
+    it('should handle relation definitions no types', function () {
+      const str = 'classDiagram\n' + 'Class01 -- Class02';
+
       parser.parse(str);
+
+      const relations = parser.yy.getRelations();
+
+      expect(parser.yy.getClass('Class01').id).toBe('Class01');
+      expect(parser.yy.getClass('Class02').id).toBe('Class02');
+      expect(relations[0].relation.type1).toBe('none');
+      expect(relations[0].relation.type2).toBe('none');
+      expect(relations[0].relation.lineType).toBe(classDb.lineType.LINE);
     });
 
-    it('should handle generic return types', function () {
-      const str = 'classDiagram\n' + 'class Car\n' + 'Car : +getWheels() List~Wheel~';
+    it('should handle relation definitions with type only on right side', function () {
+      const str = 'classDiagram\n' + 'Class01 --|> Class02';
 
       parser.parse(str);
+
+      const relations = parser.yy.getRelations();
+
+      expect(parser.yy.getClass('Class01').id).toBe('Class01');
+      expect(parser.yy.getClass('Class02').id).toBe('Class02');
+      expect(relations[0].relation.type1).toBe('none');
+      expect(relations[0].relation.type2).toBe(classDb.relationType.EXTENSION);
+      expect(relations[0].relation.lineType).toBe(classDb.lineType.LINE);
     });
 
-    it('should handle generic types in members in class with brackets', function () {
+    it('should handle multiple classes and relation definitions', function () {
       const str =
         'classDiagram\n' +
-        'class Car {\n' +
-        'List~Wheel~ wheels\n' +
-        'setWheels(List~Wheel~ wheels)\n' +
-        '+getWheels() List~Wheel~\n' +
-        '}';
+        'Class01 <|-- Class02\n' +
+        'Class03 *-- Class04\n' +
+        'Class05 o-- Class06\n' +
+        'Class07 .. Class08\n' +
+        'Class09 -- Class10';
 
       parser.parse(str);
-    });
-  });
-});
 
-describe('given a class diagram with generics, ', function () {
-  describe('when parsing valid generic classes', function () {
-    beforeEach(function () {
-      classDb.clear();
-      parser.yy = classDb;
+      const relations = parser.yy.getRelations();
+
+      expect(parser.yy.getClass('Class01').id).toBe('Class01');
+      expect(parser.yy.getClass('Class10').id).toBe('Class10');
+
+      expect(relations.length).toBe(5);
+
+      expect(relations[0].relation.type1).toBe(classDb.relationType.EXTENSION);
+      expect(relations[0].relation.type2).toBe('none');
+      expect(relations[0].relation.lineType).toBe(classDb.lineType.LINE);
+      expect(relations[3].relation.type1).toBe('none');
+      expect(relations[3].relation.type2).toBe('none');
+      expect(relations[3].relation.lineType).toBe(classDb.lineType.DOTTED_LINE);
     });
 
-    it('should handle generic class', function () {
-      const str = 'classDiagram\n' + 'class Car~T~';
+    it('should handle generic class with relation definitions', function () {
+      const str = 'classDiagram\n' + 'Class01~T~ <|-- Class02';
 
       parser.parse(str);
-    });
 
-    it('should handle generic class with relationships', function () {
-      const str =
-        'classDiagram\n' +
-        'class Car~T~\n' +
-        'Driver -- Car : drives >\n' +
-        'Car *-- Wheel : have 4 >\n' +
-        'Car -- Person : < owns';
+      const relations = parser.yy.getRelations();
+
+      expect(parser.yy.getClass('Class01').id).toBe('Class01');
+      expect(parser.yy.getClass('Class01').type).toBe('T');
+      expect(parser.yy.getClass('Class02').id).toBe('Class02');
+      expect(relations[0].relation.type1).toBe(classDb.relationType.EXTENSION);
+      expect(relations[0].relation.type2).toBe('none');
+      expect(relations[0].relation.lineType).toBe(classDb.lineType.LINE);
+    });
 
+    it('should handle class annotations', function () {
+      const str = 'classDiagram\n' + 'class Class1\n' + '<<interface>> Class1';
       parser.parse(str);
+
+      const testClass = parser.yy.getClass('Class1');
+      expect(testClass.annotations.length).toBe(1);
+      expect(testClass.members.length).toBe(0);
+      expect(testClass.methods.length).toBe(0);
+      expect(testClass.annotations[0]).toBe('interface');
     });
 
-    it('should handle generic class with a literal name', function () {
+    it('should handle class annotations with members and methods', function () {
       const str =
         'classDiagram\n' +
-        'class `Car`~T~\n' +
-        'Driver -- `Car` : drives >\n' +
-        '`Car` *-- Wheel : have 4 >\n' +
-        '`Car` -- Person : < owns';
+        'class Class1\n' +
+        'Class1 : int test\n' +
+        'Class1 : test()\n' +
+        '<<interface>> Class1';
+      parser.parse(str);
+
+      const testClass = parser.yy.getClass('Class1');
+      expect(testClass.annotations.length).toBe(1);
+      expect(testClass.members.length).toBe(1);
+      expect(testClass.methods.length).toBe(1);
+      expect(testClass.annotations[0]).toBe('interface');
+    });
 
+    it('should handle class annotations in brackets', function () {
+      const str = 'classDiagram\n' + 'class Class1 {\n' + '<<interface>>\n' + '}';
       parser.parse(str);
+
+      const testClass = parser.yy.getClass('Class1');
+      expect(testClass.annotations.length).toBe(1);
+      expect(testClass.members.length).toBe(0);
+      expect(testClass.methods.length).toBe(0);
+      expect(testClass.annotations[0]).toBe('interface');
     });
 
-    it('should handle generic class with brackets', function () {
+    it('should handle class annotations in brackets with members and methods', function () {
       const str =
         'classDiagram\n' +
-        'class Dummy_Class~T~ {\n' +
-        'String data\n' +
-        'void methods()\n' +
-        '}\n' +
-        '\n' +
-        'class Flight {\n' +
-        'Integer flightNumber\n' +
-        'Date departureTime\n' +
+        'class Class1 {\n' +
+        '<<interface>>\n' +
+        'int : test\n' +
+        'test()\n' +
         '}';
-
       parser.parse(str);
+
+      const testClass = parser.yy.getClass('Class1');
+      expect(testClass.annotations.length).toBe(1);
+      expect(testClass.members.length).toBe(1);
+      expect(testClass.methods.length).toBe(1);
+      expect(testClass.annotations[0]).toBe('interface');
     });
 
-    it('should handle generic class with brackets and a literal name', function () {
+    it('should add bracket members in right order', function () {
       const str =
         'classDiagram\n' +
-        'class `Dummy_Class`~T~ {\n' +
-        'String data\n' +
-        '  void methods()\n' +
-        '}\n' +
-        '\n' +
-        'class Flight {\n' +
-        '   flightNumber : Integer\n' +
-        '   departureTime : Date\n' +
+        'class Class1 {\n' +
+        'int : test\n' +
+        'string : foo\n' +
+        'test()\n' +
+        'foo()\n' +
         '}';
+      parser.parse(str);
+
+      const testClass = parser.yy.getClass('Class1');
+      expect(testClass.members.length).toBe(2);
+      expect(testClass.methods.length).toBe(2);
+      expect(testClass.members[0]).toBe('int : test');
+      expect(testClass.members[1]).toBe('string : foo');
+      expect(testClass.methods[0]).toBe('test()');
+      expect(testClass.methods[1]).toBe('foo()');
+    });
 
+    it('should handle abstract methods', function () {
+      const str = 'classDiagram\n' + 'class Class1\n' + 'Class1 : someMethod()*';
       parser.parse(str);
+
+      const testClass = parser.yy.getClass('Class1');
+      expect(testClass.annotations.length).toBe(0);
+      expect(testClass.members.length).toBe(0);
+      expect(testClass.methods.length).toBe(1);
+      expect(testClass.methods[0]).toBe('someMethod()*');
     });
-  });
 
-  describe('when parsing invalid generic classes', function () {
-    beforeEach(function () {
-      classDb.clear();
-      parser.yy = classDb;
+    it('should handle static methods', function () {
+      const str = 'classDiagram\n' + 'class Class1\n' + 'Class1 : someMethod()$';
+      parser.parse(str);
+
+      const testClass = parser.yy.getClass('Class1');
+      expect(testClass.annotations.length).toBe(0);
+      expect(testClass.members.length).toBe(0);
+      expect(testClass.methods.length).toBe(1);
+      expect(testClass.methods[0]).toBe('someMethod()$');
     });
 
-    it('should break when another `{`is encountered before closing the first one while defining generic class with brackets', function () {
+    it('should associate link and css appropriately', function () {
       const str =
         'classDiagram\n' +
-        'class Dummy_Class~T~ {\n' +
-        'String data\n' +
-        '  void methods()\n' +
-        '}\n' +
-        '\n' +
-        'class Dummy_Class {\n' +
-        'class Flight {\n' +
-        '   flightNumber : Integer\n' +
-        '   departureTime : Date\n' +
-        '}';
-      let testPassed = false;
-      try {
-        parser.parse(str);
-      } catch (error) {
-        testPassed = true;
-      }
-      expect(testPassed).toBe(true);
+        'class Class1\n' +
+        'Class1 : someMethod()\n' +
+        'link Class1 "google.com"';
+      parser.parse(str);
+
+      const testClass = parser.yy.getClass('Class1');
+      expect(testClass.link).toBe('google.com');
+      expect(testClass.cssClasses.length).toBe(1);
+      expect(testClass.cssClasses[0]).toBe('clickable');
     });
 
-    it('should break when EOF is encountered before closing the first `{` while defining generic class with brackets', function () {
+    it('should associate click and href link and css appropriately', function () {
       const str =
         'classDiagram\n' +
-        'class Dummy_Class~T~ {\n' +
-        'String data\n' +
-        '  void methods()\n' +
-        '}\n' +
-        '\n' +
-        'class Dummy_Class {\n';
-      let testPassed = false;
-      try {
-        parser.parse(str);
-      } catch (error) {
-        testPassed = true;
-      }
-      expect(testPassed).toBe(true);
-    });
-  });
-});
+        'class Class1\n' +
+        'Class1 : someMethod()\n' +
+        'click Class1 href "google.com"';
+      parser.parse(str);
 
-describe('given a class diagram with relationships, ', function () {
-  describe('when parsing basic relationships', function () {
-    beforeEach(function () {
-      classDb.clear();
-      parser.yy = classDb;
+      const testClass = parser.yy.getClass('Class1');
+      expect(testClass.link).toBe('google.com');
+      expect(testClass.cssClasses.length).toBe(1);
+      expect(testClass.cssClasses[0]).toBe('clickable');
     });
 
-    it('should handle all basic relationships', function () {
+    it('should associate link with tooltip', function () {
       const str =
         'classDiagram\n' +
-        'Class1 <|-- Class02\n' +
-        'Class03 *-- Class04\n' +
-        'Class05 o-- Class06\n' +
-        'Class07 .. Class08\n' +
-        'Class09 -- Class1';
-
+        'class Class1\n' +
+        'Class1 : someMethod()\n' +
+        'link Class1 "google.com" "A tooltip"';
       parser.parse(str);
+
+      const testClass = parser.yy.getClass('Class1');
+      expect(testClass.link).toBe('google.com');
+      expect(testClass.tooltip).toBe('A tooltip');
+      expect(testClass.cssClasses.length).toBe(1);
+      expect(testClass.cssClasses[0]).toBe('clickable');
     });
 
-    it('should handle backquoted class name', function () {
+    it('should associate click and href link with tooltip', function () {
       const str =
         'classDiagram\n' +
-        '`Class1` <|-- Class02\n' +
-        'Class03 *-- Class04\n' +
-        'Class05 o-- Class06\n' +
-        'Class07 .. Class08\n' +
-        'Class09 -- Class1';
-
+        'class Class1\n' +
+        'Class1 : someMethod()\n' +
+        'click Class1 href "google.com" "A tooltip"';
       parser.parse(str);
-    });
 
-    it('should handle generics', function () {
-      const str = 'classDiagram\n' + 'Class1~T~ <|-- Class02';
+      const testClass = parser.yy.getClass('Class1');
+      expect(testClass.link).toBe('google.com');
+      expect(testClass.tooltip).toBe('A tooltip');
+      expect(testClass.cssClasses.length).toBe(1);
+      expect(testClass.cssClasses[0]).toBe('clickable');
+    });
 
+    it('should associate click and href link with tooltip and target appropriately', function () {
+      spyOn(classDb, 'setLink');
+      spyOn(classDb, 'setTooltip');
+      const str =
+        'classDiagram\n' +
+        'class Class1\n' +
+        'Class1 : someMethod()\n' +
+        'click Class1 href "google.com" "A tooltip" _self';
       parser.parse(str);
 
-      const relations = parser.yy.getRelations();
-
-      expect(parser.yy.getClass('Class1').id).toBe('Class1');
-      expect(parser.yy.getClass('Class1').type).toBe('T');
-      expect(parser.yy.getClass('Class02').id).toBe('Class02');
-      expect(relations[0].relation.type1).toBe(classDb.relationType.EXTENSION);
-      expect(relations[0].relation.type2).toBe('none');
-      expect(relations[0].relation.lineType).toBe(classDb.lineType.LINE);
+      expect(classDb.setLink).toHaveBeenCalledWith('Class1', 'google.com', '_self');
+      expect(classDb.setTooltip).toHaveBeenCalledWith('Class1', 'A tooltip');
     });
 
-    it('should handle relationships with labels', function () {
+    it('should associate click and href link appropriately', function () {
+      spyOn(classDb, 'setLink');
       const str =
         'classDiagram\n' +
-        'class Car\n' +
-        'Driver -- Car : drives >\n' +
-        'Car *-- Wheel : have 4 >\n' +
-        'Car -- Person : < owns';
-
+        'class Class1\n' +
+        'Class1 : someMethod()\n' +
+        'click Class1 href "google.com"';
       parser.parse(str);
-    });
 
-    it('should handle relation definitions EXTENSION', function () {
-      const str = 'classDiagram\n' + 'Class1 <|-- Class02';
+      expect(classDb.setLink).toHaveBeenCalledWith('Class1', 'google.com');
+    });
 
+    it('should associate click and href link with target appropriately', function () {
+      spyOn(classDb, 'setLink');
+      const str =
+        'classDiagram\n' +
+        'class Class1\n' +
+        'Class1 : someMethod()\n' +
+        'click Class1 href "google.com" _self';
       parser.parse(str);
 
-      const relations = parser.yy.getRelations();
-
-      expect(parser.yy.getClass('Class1').id).toBe('Class1');
-      expect(parser.yy.getClass('Class02').id).toBe('Class02');
-      expect(relations[0].relation.type1).toBe(classDb.relationType.EXTENSION);
-      expect(relations[0].relation.type2).toBe('none');
-      expect(relations[0].relation.lineType).toBe(classDb.lineType.LINE);
+      expect(classDb.setLink).toHaveBeenCalledWith('Class1', 'google.com', '_self');
     });
 
-    it('should handle relation definition of different types and directions', function () {
+    it('should associate link appropriately', function () {
+      spyOn(classDb, 'setLink');
+      spyOn(classDb, 'setTooltip');
       const str =
         'classDiagram\n' +
-        'Class11 <|.. Class12\n' +
-        'Class13 --> Class14\n' +
-        'Class15 ..> Class16\n' +
-        'Class17 ..|> Class18\n' +
-        'Class19 <--* Class20';
-
+        'class Class1\n' +
+        'Class1 : someMethod()\n' +
+        'link Class1 "google.com" "A tooltip" _self';
       parser.parse(str);
+
+      expect(classDb.setLink).toHaveBeenCalledWith('Class1', 'google.com', '_self');
+      expect(classDb.setTooltip).toHaveBeenCalledWith('Class1', 'A tooltip');
     });
 
-    it('should handle cardinality and labels', function () {
+    it('should associate callback appropriately', function () {
+      spyOn(classDb, 'setClickEvent');
       const str =
         'classDiagram\n' +
-        'Class1 "1" *-- "many" Class02 : contains\n' +
-        'Class03 o-- Class04 : aggregation\n' +
-        'Class05 --> "1" Class06';
-
+        'class Class1\n' +
+        'Class1 : someMethod()\n' +
+        'callback Class1 "functionCall"';
       parser.parse(str);
+
+      expect(classDb.setClickEvent).toHaveBeenCalledWith('Class1', 'functionCall');
     });
 
-    it('should handle dashed relation definition of different types and directions', function () {
+    it('should associate click and call callback appropriately', function () {
+      spyOn(classDb, 'setClickEvent');
       const str =
         'classDiagram\n' +
-        'Class11 <|.. Class12\n' +
-        'Class13 <.. Class14\n' +
-        'Class15 ..|> Class16\n' +
-        'Class17 ..> Class18\n' +
-        'Class19 .. Class20';
+        'class Class1\n' +
+        'Class1 : someMethod()\n' +
+        'click Class1 call functionCall()';
       parser.parse(str);
+
+      expect(classDb.setClickEvent).toHaveBeenCalledWith('Class1', 'functionCall');
     });
 
-    it('should handle relation definitions AGGREGATION and dotted line', function () {
-      const str = 'classDiagram\n' + 'Class1 o.. Class02';
+    it('should associate callback appropriately with an arbitrary number of args', function () {
+      spyOn(classDb, 'setClickEvent');
+      const str =
+        'classDiagram\n' +
+        'class Class1\n' +
+        'Class1 : someMethod()\n' +
+        'click Class1 call functionCall("test0", test1, test2)';
+      parser.parse(str);
+
+      expect(classDb.setClickEvent).toHaveBeenCalledWith(
+        'Class1',
+        'functionCall',
+        '"test0", test1, test2'
+      );
+    });
 
+    it('should associate callback with tooltip', function () {
+      spyOn(classDb, 'setClickEvent');
+      spyOn(classDb, 'setTooltip');
+      const str =
+        'classDiagram\n' +
+        'class Class1\n' +
+        'Class1 : someMethod()\n' +
+        'click Class1 call functionCall() "A tooltip"';
       parser.parse(str);
 
-      const relations = parser.yy.getRelations();
+      expect(classDb.setClickEvent).toHaveBeenCalledWith('Class1', 'functionCall');
+      expect(classDb.setTooltip).toHaveBeenCalledWith('Class1', 'A tooltip');
+    });
+  });
 
-      expect(parser.yy.getClass('Class1').id).toBe('Class1');
-      expect(parser.yy.getClass('Class02').id).toBe('Class02');
-      expect(relations[0].relation.type1).toBe(classDb.relationType.AGGREGATION);
-      expect(relations[0].relation.type2).toBe('none');
-      expect(relations[0].relation.lineType).toBe(classDb.lineType.DOTTED_LINE);
+  describe('when parsing classDiagram with text labels', () => {
+    beforeEach(function () {
+      parser.yy = classDb;
+      parser.yy.clear();
     });
 
-    it('should handle relation definitions COMPOSITION on both sides', function () {
-      const str = 'classDiagram\n' + 'Class1 *--* Class02';
+    it('should parse a class with a text label', () => {
+      parser.parse(`classDiagram
+  class C1["Class 1 with text label"]
+  C1 -->  C2
+      `);
+      const c1 = classDb.getClass('C1');
+      expect(c1.label).toBe('Class 1 with text label');
+      const c2 = classDb.getClass('C2');
+      expect(c2.label).toBe('C2');
+    });
 
-      parser.parse(str);
+    it('should parse two classes with text labels', () => {
+      parser.parse(`classDiagram
+  class C1["Class 1 with text label"]
+  class C2["Class 2 with chars @?"]
+  C1 -->  C2
+      `);
+      const c1 = classDb.getClass('C1');
+      expect(c1.label).toBe('Class 1 with text label');
+      const c2 = classDb.getClass('C2');
+      expect(c2.label).toBe('Class 2 with chars @?');
+    });
 
-      const relations = parser.yy.getRelations();
+    it('should parse a class with a text label and members', () => {
+      parser.parse(`classDiagram
+  class C1["Class 1 with text label"] {
+    +member1
+  }
+  C1 -->  C2
+      `);
+      const c1 = classDb.getClass('C1');
+      expect(c1.label).toBe('Class 1 with text label');
+      expect(c1.members.length).toBe(1);
+      expect(c1.members[0]).toBe('+member1');
 
-      expect(parser.yy.getClass('Class1').id).toBe('Class1');
-      expect(parser.yy.getClass('Class02').id).toBe('Class02');
-      expect(relations[0].relation.type1).toBe(classDb.relationType.COMPOSITION);
-      expect(relations[0].relation.type2).toBe(classDb.relationType.COMPOSITION);
-      expect(relations[0].relation.lineType).toBe(classDb.lineType.LINE);
+      const c2 = classDb.getClass('C2');
+      expect(c2.label).toBe('C2');
     });
 
-    it('should handle relation definitions with no types', function () {
-      const str = 'classDiagram\n' + 'Class1 -- Class02';
+    it('should parse a class with a text label, members and annotation', () => {
+      parser.parse(`classDiagram
+  class C1["Class 1 with text label"] {
+    <<interface>>
+    +member1
+  }
+  C1 -->  C2
+      `);
+      const c1 = classDb.getClass('C1');
+      expect(c1.label).toBe('Class 1 with text label');
+      expect(c1.members.length).toBe(1);
+      expect(c1.members[0]).toBe('+member1');
+      expect(c1.annotations.length).toBe(1);
+      expect(c1.annotations[0]).toBe('interface');
 
-      parser.parse(str);
+      const c2 = classDb.getClass('C2');
+      expect(c2.label).toBe('C2');
+    });
 
-      const relations = parser.yy.getRelations();
+    it('should parse a class with text label and css class shorthand', () => {
+      parser.parse(`classDiagram
+class C1["Class 1 with text label"]:::styleClass {
+  +member1
+}
+C1 -->  C2
+  `);
 
-      expect(parser.yy.getClass('Class1').id).toBe('Class1');
-      expect(parser.yy.getClass('Class02').id).toBe('Class02');
-      expect(relations[0].relation.type1).toBe('none');
-      expect(relations[0].relation.type2).toBe('none');
-      expect(relations[0].relation.lineType).toBe(classDb.lineType.LINE);
+      const c1 = classDb.getClass('C1');
+      expect(c1.label).toBe('Class 1 with text label');
+      expect(c1.cssClasses.length).toBe(1);
+      expect(c1.members[0]).toBe('+member1');
+      expect(c1.cssClasses[0]).toBe('styleClass');
     });
 
-    it('should handle relation definitions with type only on right side', function () {
-      const str = 'classDiagram\n' + 'Class1 --|> Class02';
+    it('should parse a class with text label and css class', () => {
+      parser.parse(`classDiagram
+class C1["Class 1 with text label"] {
+  +member1
+}
+C1 --> C2
+cssClass "C1" styleClass
+  `);
 
-      parser.parse(str);
+      const c1 = classDb.getClass('C1');
+      expect(c1.label).toBe('Class 1 with text label');
+      expect(c1.cssClasses.length).toBe(1);
+      expect(c1.members[0]).toBe('+member1');
+      expect(c1.cssClasses[0]).toBe('styleClass');
+    });
 
-      const relations = parser.yy.getRelations();
+    it('should parse two classes with text labels and css classes', () => {
+      parser.parse(`classDiagram
+class C1["Class 1 with text label"] {
+  +member1
+}
+class C2["Long long long long long long long long long long label"]
+C1 --> C2
+cssClass "C1,C2" styleClass
+  `);
 
-      expect(parser.yy.getClass('Class1').id).toBe('Class1');
-      expect(parser.yy.getClass('Class02').id).toBe('Class02');
-      expect(relations[0].relation.type1).toBe('none');
-      expect(relations[0].relation.type2).toBe(classDb.relationType.EXTENSION);
-      expect(relations[0].relation.lineType).toBe(classDb.lineType.LINE);
+      const c1 = classDb.getClass('C1');
+      expect(c1.label).toBe('Class 1 with text label');
+      expect(c1.cssClasses.length).toBe(1);
+      expect(c1.cssClasses[0]).toBe('styleClass');
+
+      const c2 = classDb.getClass('C2');
+      expect(c2.label).toBe('Long long long long long long long long long long label');
+      expect(c2.cssClasses.length).toBe(1);
+      expect(c2.cssClasses[0]).toBe('styleClass');
     });
 
-    it('should handle multiple classes and relation definitions', function () {
-      const str =
-        'classDiagram\n' +
-        'Class1 <|-- Class02\n' +
-        'Class03 *-- Class04\n' +
-        'Class05 o-- Class06\n' +
-        'Class07 .. Class08\n' +
-        'Class09 -- Class10';
+    it('should parse two classes with text labels and css class shorthands', () => {
+      parser.parse(`classDiagram
+class C1["Class 1 with text label"]:::styleClass1 {
+  +member1
+}
+class C2["Class 2 !@#$%^&*() label"]:::styleClass2
+C1 --> C2
+  `);
 
-      parser.parse(str);
+      const c1 = classDb.getClass('C1');
+      expect(c1.label).toBe('Class 1 with text label');
+      expect(c1.cssClasses.length).toBe(1);
+      expect(c1.cssClasses[0]).toBe('styleClass1');
 
-      const relations = parser.yy.getRelations();
+      const c2 = classDb.getClass('C2');
+      expect(c2.label).toBe('Class 2 !@#$%^&*() label');
+      expect(c2.cssClasses.length).toBe(1);
+      expect(c2.cssClasses[0]).toBe('styleClass2');
+    });
 
-      expect(parser.yy.getClass('Class1').id).toBe('Class1');
-      expect(parser.yy.getClass('Class10').id).toBe('Class10');
+    it('should parse multiple classes with same text labels', () => {
+      parser.parse(`classDiagram
+class C1["Class with text label"]
+class C2["Class with text label"]
+class C3["Class with text label"]
+C1 --> C2
+C3 ..> C2
+  `);
 
-      expect(relations.length).toBe(5);
+      const c1 = classDb.getClass('C1');
+      expect(c1.label).toBe('Class with text label');
 
-      expect(relations[0].relation.type1).toBe(classDb.relationType.EXTENSION);
-      expect(relations[0].relation.type2).toBe('none');
-      expect(relations[0].relation.lineType).toBe(classDb.lineType.LINE);
-      expect(relations[3].relation.type1).toBe('none');
-      expect(relations[3].relation.type2).toBe('none');
-      expect(relations[3].relation.lineType).toBe(classDb.lineType.DOTTED_LINE);
+      const c2 = classDb.getClass('C2');
+      expect(c2.label).toBe('Class with text label');
+
+      const c3 = classDb.getClass('C3');
+      expect(c3.label).toBe('Class with text label');
+    });
+
+    it('should parse classes with different text labels', () => {
+      parser.parse(`classDiagram
+class C1["OneWord"]
+class C2["With, Comma"]
+class C3["With (Brackets)"]
+class C4["With [Brackets]"]
+class C5["With {Brackets}"]
+class C6[" "]
+class C7["With 1 number"]
+class C8["With . period..."]
+class C9["With - dash"]
+class C10["With _ underscore"]
+class C11["With ' single quote"]
+class C12["With ~!@#$%^&*()_+=-/?"]
+class C13["With Città foreign language"]
+`);
+      expect(classDb.getClass('C1').label).toBe('OneWord');
+      expect(classDb.getClass('C2').label).toBe('With, Comma');
+      expect(classDb.getClass('C3').label).toBe('With (Brackets)');
+      expect(classDb.getClass('C4').label).toBe('With [Brackets]');
+      expect(classDb.getClass('C5').label).toBe('With {Brackets}');
+      expect(classDb.getClass('C6').label).toBe(' ');
+      expect(classDb.getClass('C7').label).toBe('With 1 number');
+      expect(classDb.getClass('C8').label).toBe('With . period...');
+      expect(classDb.getClass('C9').label).toBe('With - dash');
+      expect(classDb.getClass('C10').label).toBe('With _ underscore');
+      expect(classDb.getClass('C11').label).toBe("With ' single quote");
+      expect(classDb.getClass('C12').label).toBe('With ~!@#$%^&*()_+=-/?');
+      expect(classDb.getClass('C13').label).toBe('With Città foreign language');
     });
   });
 });
diff --git a/packages/mermaid/src/diagrams/class/parser/classDiagram.jison b/packages/mermaid/src/diagrams/class/parser/classDiagram.jison
index 6a7834eca..0c9ad2f2a 100644
--- a/packages/mermaid/src/diagrams/class/parser/classDiagram.jison
+++ b/packages/mermaid/src/diagrams/class/parser/classDiagram.jison
@@ -200,7 +200,7 @@ Function arguments are optional: 'call <callback_name>()' simply executes 'callb
 
 start
     : mermaidDoc
-    | statements
+    | statments
     | direction
     | directive start
     ;
@@ -259,8 +259,8 @@ className
     : alphaNumToken { $$=$1; }
     | classLiteralName { $$=$1; }
     | alphaNumToken className { $$=$1+$2; }
-    | alphaNumToken GENERICTYPE { $$=$1+'~'+$2+'~'; }
-    | classLiteralName GENERICTYPE { $$=$1+'~'+$2+'~'; }
+    | alphaNumToken GENERICTYPE { $$=$1+'~'+$2; }
+    | classLiteralName GENERICTYPE { $$=$1+'~'+$2; }
     ;
 
 statement
@@ -366,7 +366,7 @@ textToken      : textNoTagsToken | TAGSTART | TAGEND | '=='  | '--' | PCT | DEFA
 
 textNoTagsToken: alphaNumToken | SPACE | MINUS | keywords ;
 
-alphaNumToken  : UNICODE_TEXT | NUM | ALPHA | MINUS;
+alphaNumToken  : UNICODE_TEXT | NUM | ALPHA;
 
 classLiteralName : BQUOTE_STR;
 
diff --git a/packages/mermaid/src/diagrams/class/svgDraw.js b/packages/mermaid/src/diagrams/class/svgDraw.js
index 7206506a2..3ce8e980b 100644
--- a/packages/mermaid/src/diagrams/class/svgDraw.js
+++ b/packages/mermaid/src/diagrams/class/svgDraw.js
@@ -199,7 +199,11 @@ export const drawClass = function (elem, classDef, conf, diagObj) {
     isFirst = false;
   });
 
-  let classTitleString = getClassTitleString(classDef);
+  let classTitleString = classDef.id;
+
+  if (classDef.type !== undefined && classDef.type !== '') {
+    classTitleString += '<' + classDef.type + '>';
+  }
 
   const classTitle = title.append('tspan').text(classTitleString).attr('class', 'title');
 
@@ -287,16 +291,6 @@ export const drawClass = function (elem, classDef, conf, diagObj) {
   return classInfo;
 };
 
-export const getClassTitleString = function (classDef) {
-  let classTitleString = classDef.id;
-
-  if (classDef.type) {
-    classTitleString += '<' + classDef.type + '>';
-  }
-
-  return classTitleString;
-};
-
 /**
  * Renders a note diagram
  *
@@ -361,9 +355,6 @@ export const drawNote = function (elem, note, conf, diagObj) {
 };
 
 export const parseMember = function (text) {
-  // Note: these two regular expressions don't parse the official UML syntax for attributes
-  // and methods. They parse a Java-style syntax of the form
-  // "String name" (for attributes) and "String name(int x)" for methods
   const fieldRegEx = /^([#+~-])?(\w+)(~\w+~|\[])?\s+(\w+) *([$*])?$/;
   const methodRegEx = /^([#+|~-])?(\w+) *\( *(.*)\) *([$*])? *(\w*[[\]|~]*\s*\w*~?)$/;
 
@@ -430,48 +421,33 @@ const buildLegacyDisplay = function (text) {
   let displayText = '';
   let cssStyle = '';
   let returnType = '';
-
-  let visibility = '';
-  let firstChar = text.substring(0, 1);
-  let lastChar = text.substring(text.length - 1, text.length);
-
-  if (firstChar.match(/[#+~-]/)) {
-    visibility = firstChar;
-  }
-
-  let noClassifierRe = /[\s\w)~]/;
-  if (!lastChar.match(noClassifierRe)) {
-    cssStyle = parseClassifier(lastChar);
-  }
-
-  let startIndex = visibility === '' ? 0 : 1;
-  let endIndex = cssStyle === '' ? text.length : text.length - 1;
-  text = text.substring(startIndex, endIndex);
-
   let methodStart = text.indexOf('(');
   let methodEnd = text.indexOf(')');
 
   if (methodStart > 1 && methodEnd > methodStart && methodEnd <= text.length) {
-    let methodName = text.substring(0, methodStart).trim();
+    let visibility = '';
+    let methodName = '';
+
+    let firstChar = text.substring(0, 1);
+    if (firstChar.match(/\w/)) {
+      methodName = text.substring(0, methodStart).trim();
+    } else {
+      if (firstChar.match(/[#+~-]/)) {
+        visibility = firstChar;
+      }
+
+      methodName = text.substring(1, methodStart).trim();
+    }
 
     const parameters = text.substring(methodStart + 1, methodEnd);
+    const classifier = text.substring(methodEnd + 1, 1);
+    cssStyle = parseClassifier(text.substring(methodEnd + 1, methodEnd + 2));
 
     displayText = visibility + methodName + '(' + parseGenericTypes(parameters.trim()) + ')';
 
     if (methodEnd < text.length) {
-      // special case: classifier after the closing parenthesis
-      let potentialClassifier = text.substring(methodEnd + 1, methodEnd + 2);
-      if (cssStyle === '' && !potentialClassifier.match(noClassifierRe)) {
-        cssStyle = parseClassifier(potentialClassifier);
-        returnType = text.substring(methodEnd + 2).trim();
-      } else {
-        returnType = text.substring(methodEnd + 1).trim();
-      }
-
+      returnType = text.substring(methodEnd + 2).trim();
       if (returnType !== '') {
-        if (returnType.charAt(0) === ':') {
-          returnType = returnType.substring(1).trim();
-        }
         returnType = ' : ' + parseGenericTypes(returnType);
         displayText += returnType;
       }
@@ -526,7 +502,6 @@ const parseClassifier = function (classifier) {
 };
 
 export default {
-  getClassTitleString,
   drawClass,
   drawEdge,
   drawNote,
diff --git a/packages/mermaid/src/diagrams/class/svgDraw.spec.js b/packages/mermaid/src/diagrams/class/svgDraw.spec.js
index e8ba9f7e1..2e7c64fa0 100644
--- a/packages/mermaid/src/diagrams/class/svgDraw.spec.js
+++ b/packages/mermaid/src/diagrams/class/svgDraw.spec.js
@@ -1,19 +1,8 @@
 import svgDraw from './svgDraw.js';
 
-describe('given a string representing class method, ', function () {
-  it('should handle class names with generics', function () {
-    const classDef = {
-      id: 'Car',
-      type: 'T',
-      label: 'Car',
-    };
-
-    let actual = svgDraw.getClassTitleString(classDef);
-    expect(actual).toBe('Car<T>');
-  });
-
-  describe('when parsing base method declaration', function () {
-    it('should handle simple declaration', function () {
+describe('class member Renderer, ', function () {
+  describe('when parsing text to build method display string', function () {
+    it('should handle simple method declaration', function () {
       const str = 'foo()';
       let actual = svgDraw.parseMember(str);
 
@@ -21,105 +10,7 @@ describe('given a string representing class method, ', function () {
       expect(actual.cssStyle).toBe('');
     });
 
-    it('should handle declaration with parameters', function () {
-      const str = 'foo(int id)';
-      let actual = svgDraw.parseMember(str);
-
-      expect(actual.displayText).toBe('foo(int id)');
-      expect(actual.cssStyle).toBe('');
-    });
-
-    it('should handle declaration with multiple parameters', function () {
-      const str = 'foo(int id, object thing)';
-      let actual = svgDraw.parseMember(str);
-
-      expect(actual.displayText).toBe('foo(int id, object thing)');
-      expect(actual.cssStyle).toBe('');
-    });
-
-    it('should handle declaration with single item in parameters', function () {
-      const str = 'foo(id)';
-      let actual = svgDraw.parseMember(str);
-
-      expect(actual.displayText).toBe('foo(id)');
-      expect(actual.cssStyle).toBe('');
-    });
-
-    it('should handle declaration with single item in parameters with extra spaces', function () {
-      const str = ' foo ( id) ';
-      let actual = svgDraw.parseMember(str);
-
-      expect(actual.displayText).toBe('foo(id)');
-      expect(actual.cssStyle).toBe('');
-    });
-
-    it('should handle method declaration with generic parameter', function () {
-      const str = 'foo(List~int~)';
-      let actual = svgDraw.parseMember(str);
-
-      expect(actual.displayText).toBe('foo(List<int>)');
-      expect(actual.cssStyle).toBe('');
-    });
-
-    it('should handle method declaration with normal and generic parameter', function () {
-      const str = 'foo(int, List~int~)';
-      let actual = svgDraw.parseMember(str);
-
-      expect(actual.displayText).toBe('foo(int, List<int>)');
-      expect(actual.cssStyle).toBe('');
-    });
-
-    it('should handle declaration with return value', function () {
-      const str = 'foo(id) int';
-      let actual = svgDraw.parseMember(str);
-
-      expect(actual.displayText).toBe('foo(id) : int');
-      expect(actual.cssStyle).toBe('');
-    });
-
-    it('should handle declaration with colon return value', function () {
-      const str = 'foo(id) : int';
-      let actual = svgDraw.parseMember(str);
-
-      expect(actual.displayText).toBe('foo(id) : int');
-      expect(actual.cssStyle).toBe('');
-    });
-
-    it('should handle declaration with generic return value', function () {
-      const str = 'foo(id) List~int~';
-      let actual = svgDraw.parseMember(str);
-
-      expect(actual.displayText).toBe('foo(id) : List<int>');
-      expect(actual.cssStyle).toBe('');
-    });
-
-    it('should handle declaration with colon generic return value', function () {
-      const str = 'foo(id) : List~int~';
-      let actual = svgDraw.parseMember(str);
-
-      expect(actual.displayText).toBe('foo(id) : List<int>');
-      expect(actual.cssStyle).toBe('');
-    });
-
-    it('should handle method declaration with all possible markup', function () {
-      const str = '+foo (  List~int~ ids  )* List~Item~';
-      let actual = svgDraw.parseMember(str);
-
-      expect(actual.displayText).toBe('+foo(List<int> ids) : List<Item>');
-      expect(actual.cssStyle).toBe('font-style:italic;');
-    });
-
-    it('should handle method declaration with nested generics', function () {
-      const str = '+foo (  List~List~int~~ ids  )* List~List~Item~~';
-      let actual = svgDraw.parseMember(str);
-
-      expect(actual.displayText).toBe('+foo(List<List<int>> ids) : List<List<Item>>');
-      expect(actual.cssStyle).toBe('font-style:italic;');
-    });
-  });
-
-  describe('when parsing method visibility', function () {
-    it('should correctly handle public', function () {
+    it('should handle public visibility', function () {
       const str = '+foo()';
       let actual = svgDraw.parseMember(str);
 
@@ -127,7 +18,7 @@ describe('given a string representing class method, ', function () {
       expect(actual.cssStyle).toBe('');
     });
 
-    it('should correctly handle private', function () {
+    it('should handle private visibility', function () {
       const str = '-foo()';
       let actual = svgDraw.parseMember(str);
 
@@ -135,7 +26,7 @@ describe('given a string representing class method, ', function () {
       expect(actual.cssStyle).toBe('');
     });
 
-    it('should correctly handle protected', function () {
+    it('should handle protected visibility', function () {
       const str = '#foo()';
       let actual = svgDraw.parseMember(str);
 
@@ -143,37 +34,27 @@ describe('given a string representing class method, ', function () {
       expect(actual.cssStyle).toBe('');
     });
 
-    it('should correctly handle package/internal', function () {
+    it('should handle package/internal visibility', function () {
       const str = '~foo()';
       let actual = svgDraw.parseMember(str);
 
       expect(actual.displayText).toBe('~foo()');
       expect(actual.cssStyle).toBe('');
     });
-  });
 
-  describe('when parsing method classifier', function () {
-    it('should handle abstract method', function () {
-      const str = 'foo()*';
+    it('should ignore unknown character for visibility', function () {
+      const str = '!foo()';
       let actual = svgDraw.parseMember(str);
 
       expect(actual.displayText).toBe('foo()');
-      expect(actual.cssStyle).toBe('font-style:italic;');
-    });
-
-    it('should handle abstract method with return type', function () {
-      const str = 'foo(name: String) int*';
-      let actual = svgDraw.parseMember(str);
-
-      expect(actual.displayText).toBe('foo(name: String) : int');
-      expect(actual.cssStyle).toBe('font-style:italic;');
+      expect(actual.cssStyle).toBe('');
     });
 
-    it('should handle abstract method classifier after parenthesis with return type', function () {
-      const str = 'foo(name: String)* int';
+    it('should handle abstract method classifier', function () {
+      const str = 'foo()*';
       let actual = svgDraw.parseMember(str);
 
-      expect(actual.displayText).toBe('foo(name: String) : int');
+      expect(actual.displayText).toBe('foo()');
       expect(actual.cssStyle).toBe('font-style:italic;');
     });
 
@@ -185,30 +66,6 @@ describe('given a string representing class method, ', function () {
       expect(actual.cssStyle).toBe('text-decoration:underline;');
     });
 
-    it('should handle static method classifier with return type', function () {
-      const str = 'foo(name: String) int$';
-      let actual = svgDraw.parseMember(str);
-
-      expect(actual.displayText).toBe('foo(name: String) : int');
-      expect(actual.cssStyle).toBe('text-decoration:underline;');
-    });
-
-    it('should handle static method classifier with colon and return type', function () {
-      const str = 'foo(name: String): int$';
-      let actual = svgDraw.parseMember(str);
-
-      expect(actual.displayText).toBe('foo(name: String) : int');
-      expect(actual.cssStyle).toBe('text-decoration:underline;');
-    });
-
-    it('should handle static method classifier after parenthesis with return type', function () {
-      const str = 'foo(name: String)$ int';
-      let actual = svgDraw.parseMember(str);
-
-      expect(actual.displayText).toBe('foo(name: String) : int');
-      expect(actual.cssStyle).toBe('text-decoration:underline;');
-    });
-
     it('should ignore unknown character for classifier', function () {
       const str = 'foo()!';
       let actual = svgDraw.parseMember(str);
@@ -216,115 +73,103 @@ describe('given a string representing class method, ', function () {
       expect(actual.displayText).toBe('foo()');
       expect(actual.cssStyle).toBe('');
     });
-  });
-});
 
-describe('given a string representing class member, ', function () {
-  describe('when parsing member declaration', function () {
-    it('should handle simple field', function () {
-      const str = 'id';
+    it('should handle simple method declaration with parameters', function () {
+      const str = 'foo(int id)';
       let actual = svgDraw.parseMember(str);
 
-      expect(actual.displayText).toBe('id');
+      expect(actual.displayText).toBe('foo(int id)');
       expect(actual.cssStyle).toBe('');
     });
 
-    it('should handle field with type', function () {
-      const str = 'int id';
+    it('should handle simple method declaration with multiple parameters', function () {
+      const str = 'foo(int id, object thing)';
       let actual = svgDraw.parseMember(str);
 
-      expect(actual.displayText).toBe('int id');
+      expect(actual.displayText).toBe('foo(int id, object thing)');
       expect(actual.cssStyle).toBe('');
     });
 
-    it('should handle field with type (name first)', function () {
-      const str = 'id: int';
+    it('should handle simple method declaration with single item in parameters', function () {
+      const str = 'foo(id)';
       let actual = svgDraw.parseMember(str);
 
-      expect(actual.displayText).toBe('id: int');
+      expect(actual.displayText).toBe('foo(id)');
       expect(actual.cssStyle).toBe('');
     });
 
-    it('should handle array field', function () {
-      const str = 'int[] ids';
+    it('should handle simple method declaration with single item in parameters with extra spaces', function () {
+      const str = ' foo ( id) ';
       let actual = svgDraw.parseMember(str);
 
-      expect(actual.displayText).toBe('int[] ids');
+      expect(actual.displayText).toBe('foo(id)');
       expect(actual.cssStyle).toBe('');
     });
 
-    it('should handle array field (name first)', function () {
-      const str = 'ids: int[]';
+    it('should handle method declaration with return value', function () {
+      const str = 'foo(id) int';
       let actual = svgDraw.parseMember(str);
 
-      expect(actual.displayText).toBe('ids: int[]');
+      expect(actual.displayText).toBe('foo(id) : int');
       expect(actual.cssStyle).toBe('');
     });
 
-    it('should handle field with generic type', function () {
-      const str = 'List~int~ ids';
+    it('should handle method declaration with generic return value', function () {
+      const str = 'foo(id) List~int~';
       let actual = svgDraw.parseMember(str);
 
-      expect(actual.displayText).toBe('List<int> ids');
+      expect(actual.displayText).toBe('foo(id) : List<int>');
       expect(actual.cssStyle).toBe('');
     });
 
-    it('should handle field with generic type (name first)', function () {
-      const str = 'ids: List~int~';
+    it('should handle method declaration with generic parameter', function () {
+      const str = 'foo(List~int~)';
       let actual = svgDraw.parseMember(str);
 
-      expect(actual.displayText).toBe('ids: List<int>');
+      expect(actual.displayText).toBe('foo(List<int>)');
       expect(actual.cssStyle).toBe('');
     });
-  });
-
-  describe('when parsing classifiers', function () {
-    it('should handle static field', function () {
-      const str = 'String foo$';
-      let actual = svgDraw.parseMember(str);
-
-      expect(actual.displayText).toBe('String foo');
-      expect(actual.cssStyle).toBe('text-decoration:underline;');
-    });
 
-    it('should handle static field (name first)', function () {
-      const str = 'foo: String$';
+    it('should handle method declaration with all possible markup', function () {
+      const str = '+foo (  List~int~ ids  )* List~Item~';
       let actual = svgDraw.parseMember(str);
 
-      expect(actual.displayText).toBe('foo: String');
-      expect(actual.cssStyle).toBe('text-decoration:underline;');
+      expect(actual.displayText).toBe('+foo(List<int> ids) : List<Item>');
+      expect(actual.cssStyle).toBe('font-style:italic;');
     });
 
-    it('should handle static field with generic type', function () {
-      const str = 'List~String~ foo$';
+    it('should handle method declaration with nested markup', function () {
+      const str = '+foo (  List~List~int~~ ids  )* List~List~Item~~';
       let actual = svgDraw.parseMember(str);
 
-      expect(actual.displayText).toBe('List<String> foo');
-      expect(actual.cssStyle).toBe('text-decoration:underline;');
+      expect(actual.displayText).toBe('+foo(List<List<int>> ids) : List<List<Item>>');
+      expect(actual.cssStyle).toBe('font-style:italic;');
     });
+  });
 
-    it('should handle static field with generic type (name first)', function () {
-      const str = 'foo: List~String~$';
+  describe('when parsing text to build field display string', function () {
+    it('should handle simple field declaration', function () {
+      const str = 'int[] ids';
       let actual = svgDraw.parseMember(str);
 
-      expect(actual.displayText).toBe('foo: List<String>');
-      expect(actual.cssStyle).toBe('text-decoration:underline;');
+      expect(actual.displayText).toBe('int[] ids');
+      expect(actual.cssStyle).toBe('');
     });
 
-    it('should handle field with nested generic type', function () {
-      const str = 'List~List~int~~ idLists';
+    it('should handle field declaration with generic type', function () {
+      const str = 'List~int~ ids';
       let actual = svgDraw.parseMember(str);
 
-      expect(actual.displayText).toBe('List<List<int>> idLists');
+      expect(actual.displayText).toBe('List<int> ids');
       expect(actual.cssStyle).toBe('');
     });
 
-    it('should handle field with nested generic type (name first)', function () {
-      const str = 'idLists: List~List~int~~';
+    it('should handle static field classifier', function () {
+      const str = 'String foo$';
       let actual = svgDraw.parseMember(str);
 
-      expect(actual.displayText).toBe('idLists: List<List<int>>');
-      expect(actual.cssStyle).toBe('');
+      expect(actual.displayText).toBe('String foo');
+      expect(actual.cssStyle).toBe('text-decoration:underline;');
     });
   });
 });
diff --git a/packages/mermaid/src/diagrams/common/common.ts b/packages/mermaid/src/diagrams/common/common.ts
index 369d84f21..3b72e8718 100644
--- a/packages/mermaid/src/diagrams/common/common.ts
+++ b/packages/mermaid/src/diagrams/common/common.ts
@@ -1,8 +1,6 @@
 import DOMPurify from 'dompurify';
 import { MermaidConfig } from '../../config.type.js';
 
-export const lineBreakRegex = /<br\s*\/?>/gi;
-
 /**
  * Gets the rows of lines in a string
  *
@@ -67,6 +65,8 @@ export const sanitizeTextOrArray = (
   return a.flat().map((x: string) => sanitizeText(x, config));
 };
 
+export const lineBreakRegex = /<br\s*\/?>/gi;
+
 /**
  * Whether or not a text has any line breaks
  *
diff --git a/packages/mermaid/src/docs/syntax/classDiagram.md b/packages/mermaid/src/docs/syntax/classDiagram.md
index 871ade057..d019774b2 100644
--- a/packages/mermaid/src/docs/syntax/classDiagram.md
+++ b/packages/mermaid/src/docs/syntax/classDiagram.md
@@ -74,7 +74,7 @@ classDiagram
     Vehicle <|-- Car
 ```
 
-Naming convention: a class name should be composed only of alphanumeric characters (including unicode), underscores, and dashes (-).
+Naming convention: a class name should be composed only of alphanumeric characters (including unicode), and underscores.
 
 ### Class labels
 
@@ -171,12 +171,12 @@ To describe the visibility (or encapsulation) of an attribute or method/function
 - `#` Protected
 - `~` Package/Internal
 
-> _note_ you can also include additional _classifiers_ to a method definition by adding the following notation to the _end_ of the method, i.e.: after the `()` or after the return type:
+> _note_ you can also include additional _classifiers_ to a method definition by adding the following notation to the _end_ of the method, i.e.: after the `()`:
 >
-> - `*` Abstract e.g.: `someAbstractMethod()*` or `someAbstractMethod() int*`
-> - `$` Static e.g.: `someStaticMethod()$` or `someStaticMethod() String$`
+> - `*` Abstract e.g.: `someAbstractMethod()*`
+> - `$` Static e.g.: `someStaticMethod()$`
 
-> _note_ you can also include additional _classifiers_ to a field definition by adding the following notation to the very end:
+> _note_ you can also include additional _classifiers_ to a field definition by adding the following notation to the end of its name:
 >
 > - `$` Static e.g.: `String someField$`
 
