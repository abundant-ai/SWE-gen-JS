diff --git a/lib/rules/indent.js b/lib/rules/indent.js
index 7ea4b3f86..9068006d4 100644
--- a/lib/rules/indent.js
+++ b/lib/rules/indent.js
@@ -1250,7 +1250,7 @@ module.exports = {
 
             IfStatement(node) {
                 addBlocklessNodeIndent(node.consequent);
-                if (node.alternate) {
+                if (node.alternate && node.alternate.type !== "IfStatement") {
                     addBlocklessNodeIndent(node.alternate);
                 }
             },
diff --git a/lib/rules/no-useless-escape.js b/lib/rules/no-useless-escape.js
index 8304d915f..71d006b23 100644
--- a/lib/rules/no-useless-escape.js
+++ b/lib/rules/no-useless-escape.js
@@ -94,6 +94,7 @@ module.exports = {
         messages: {
             unnecessaryEscape: "Unnecessary escape character: \\{{character}}.",
             removeEscape: "Remove the `\\`. This maintains the current functionality.",
+            removeEscapeDoNotKeepSemantics: "Remove the `\\` if it was inserted by mistake.",
             escapeBackslash: "Replace the `\\` with `\\\\` to include the actual backslash character."
         },
 
@@ -125,7 +126,10 @@ module.exports = {
                 data: { character },
                 suggest: [
                     {
-                        messageId: "removeEscape",
+
+                        // Removing unnecessary `\` characters in a directive is not guaranteed to maintain functionality.
+                        messageId: astUtils.isDirective(node.parent)
+                            ? "removeEscapeDoNotKeepSemantics" : "removeEscape",
                         fix(fixer) {
                             return fixer.removeRange(range);
                         }
diff --git a/lib/rules/padding-line-between-statements.js b/lib/rules/padding-line-between-statements.js
index 6b165c07f..95e08736a 100644
--- a/lib/rules/padding-line-between-statements.js
+++ b/lib/rules/padding-line-between-statements.js
@@ -130,42 +130,6 @@ function isBlockLikeStatement(sourceCode, node) {
     );
 }
 
-/**
- * Check whether the given node is a directive or not.
- * @param {ASTNode} node The node to check.
- * @param {SourceCode} sourceCode The source code object to get tokens.
- * @returns {boolean} `true` if the node is a directive.
- */
-function isDirective(node, sourceCode) {
-    return (
-        astUtils.isTopLevelExpressionStatement(node) &&
-        node.expression.type === "Literal" &&
-        typeof node.expression.value === "string" &&
-        !astUtils.isParenthesised(sourceCode, node.expression)
-    );
-}
-
-/**
- * Check whether the given node is a part of directive prologue or not.
- * @param {ASTNode} node The node to check.
- * @param {SourceCode} sourceCode The source code object to get tokens.
- * @returns {boolean} `true` if the node is a part of directive prologue.
- */
-function isDirectivePrologue(node, sourceCode) {
-    if (isDirective(node, sourceCode)) {
-        for (const sibling of node.parent.body) {
-            if (sibling === node) {
-                break;
-            }
-            if (!isDirective(sibling, sourceCode)) {
-                return false;
-            }
-        }
-        return true;
-    }
-    return false;
-}
-
 /**
  * Gets the actual last token.
  *
@@ -359,12 +323,10 @@ const StatementTypes = {
             CJS_IMPORT.test(sourceCode.getText(node.declarations[0].init))
     },
     directive: {
-        test: isDirectivePrologue
+        test: astUtils.isDirective
     },
     expression: {
-        test: (node, sourceCode) =>
-            node.type === "ExpressionStatement" &&
-            !isDirectivePrologue(node, sourceCode)
+        test: node => node.type === "ExpressionStatement" && !astUtils.isDirective(node)
     },
     iife: {
         test: isIIFEStatement
@@ -375,10 +337,10 @@ const StatementTypes = {
             isBlockLikeStatement(sourceCode, node)
     },
     "multiline-expression": {
-        test: (node, sourceCode) =>
+        test: node =>
             node.loc.start.line !== node.loc.end.line &&
             node.type === "ExpressionStatement" &&
-            !isDirectivePrologue(node, sourceCode)
+            !astUtils.isDirective(node)
     },
 
     "multiline-const": newMultilineKeywordTester("const"),
diff --git a/lib/rules/utils/ast-utils.js b/lib/rules/utils/ast-utils.js
index e8ed3edd8..08a23c888 100644
--- a/lib/rules/utils/ast-utils.js
+++ b/lib/rules/utils/ast-utils.js
@@ -1006,6 +1006,15 @@ function isTopLevelExpressionStatement(node) {
 
 }
 
+/**
+ * Check whether the given node is a part of a directive prologue or not.
+ * @param {ASTNode} node The node to check.
+ * @returns {boolean} `true` if the node is a part of directive prologue.
+ */
+function isDirective(node) {
+    return node.type === "ExpressionStatement" && typeof node.directive === "string";
+}
+
 //------------------------------------------------------------------------------
 // Public Interface
 //------------------------------------------------------------------------------
@@ -2158,5 +2167,6 @@ module.exports = {
     getSwitchCaseColonToken,
     getModuleExportName,
     isConstant,
-    isTopLevelExpressionStatement
+    isTopLevelExpressionStatement,
+    isDirective
 };
