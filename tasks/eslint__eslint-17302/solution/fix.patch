diff --git a/lib/rules/logical-assignment-operators.js b/lib/rules/logical-assignment-operators.js
index cb1cbe5a1..27ca585e9 100644
--- a/lib/rules/logical-assignment-operators.js
+++ b/lib/rules/logical-assignment-operators.js
@@ -370,8 +370,11 @@ module.exports = {
                                 return;
                             }
 
-                            const requiresOuterParenthesis = logical.parent.type !== "ExpressionStatement" &&
-                                                             (astUtils.getPrecedence({ type: "AssignmentExpression" }) < astUtils.getPrecedence(logical.parent));
+                            const parentPrecedence = astUtils.getPrecedence(logical.parent);
+                            const requiresOuterParenthesis = logical.parent.type !== "ExpressionStatement" && (
+                                parentPrecedence === -1 ||
+                                astUtils.getPrecedence({ type: "AssignmentExpression" }) < parentPrecedence
+                            );
 
                             if (!astUtils.isParenthesised(sourceCode, logical) && requiresOuterParenthesis) {
                                 yield ruleFixer.insertTextBefore(logical, "(");
diff --git a/lib/rules/prefer-exponentiation-operator.js b/lib/rules/prefer-exponentiation-operator.js
index dd4ba2c8e..6d807f9cf 100644
--- a/lib/rules/prefer-exponentiation-operator.js
+++ b/lib/rules/prefer-exponentiation-operator.js
@@ -55,11 +55,12 @@ function doesExponentNeedParens(exponent) {
 function doesExponentiationExpressionNeedParens(node, sourceCode) {
     const parent = node.parent.type === "ChainExpression" ? node.parent.parent : node.parent;
 
+    const parentPrecedence = astUtils.getPrecedence(parent);
     const needsParens = (
         parent.type === "ClassDeclaration" ||
         (
             parent.type.endsWith("Expression") &&
-            astUtils.getPrecedence(parent) >= PRECEDENCE_OF_EXPONENTIATION_EXPR &&
+            (parentPrecedence === -1 || parentPrecedence >= PRECEDENCE_OF_EXPONENTIATION_EXPR) &&
             !(parent.type === "BinaryExpression" && parent.operator === "**" && parent.right === node) &&
             !((parent.type === "CallExpression" || parent.type === "NewExpression") && parent.arguments.includes(node)) &&
             !(parent.type === "MemberExpression" && parent.computed && parent.property === node) &&
diff --git a/lib/rules/utils/ast-utils.js b/lib/rules/utils/ast-utils.js
index aed2c42f9..39e53b105 100644
--- a/lib/rules/utils/ast-utils.js
+++ b/lib/rules/utils/ast-utils.js
@@ -9,6 +9,7 @@
 // Requirements
 //------------------------------------------------------------------------------
 
+const { KEYS: eslintVisitorKeys } = require("eslint-visitor-keys");
 const esutils = require("esutils");
 const espree = require("espree");
 const escapeRegExp = require("escape-string-regexp");
@@ -1461,7 +1462,16 @@ module.exports = {
                 return 19;
 
             default:
-                return 20;
+                if (node.type in eslintVisitorKeys) {
+                    return 20;
+                }
+
+                /*
+                 * if the node is not a standard node that we know about, then assume it has the lowest precedence
+                 * this will mean that rules will wrap unknown nodes in parentheses where applicable instead of
+                 * unwrapping them and potentially changing the meaning of the code or introducing a syntax error.
+                 */
+                return -1;
         }
     },
 
