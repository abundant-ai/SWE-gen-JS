diff --git a/AUTHORS b/AUTHORS
index 1048518d9..04a7525c5 100644
--- a/AUTHORS
+++ b/AUTHORS
@@ -267,7 +267,6 @@ Delaney Sylvans <delaneysylvans@gmail.com>
 Rani D. <73716554+ranidam@users.noreply.github.com>
 Don McCurdy <dm@donmccurdy.com>
 Jay Chang <96050090+JayChang4w@users.noreply.github.com>
-Ikem Peter <ikempeter2020@gmail.com>
 mrft <977655+mrft@users.noreply.github.com>
 Jacopo Mercolini <79222209+Mundi93@users.noreply.github.com>
 Luca Quercetti <l.quercetti@wecodeyou.it>
diff --git a/docs/expressions/syntax.md b/docs/expressions/syntax.md
index ad8bd3c92..08d35f288 100644
--- a/docs/expressions/syntax.md
+++ b/docs/expressions/syntax.md
@@ -24,7 +24,6 @@ the lower level syntax of math.js. Differences are:
   not bitwise xor.
 - Implicit multiplication, like `2 pi`, is supported and has special rules.
 - Relational operators (`<`, `>`, `<=`, `>=`, `==`, and `!=`) are chained, so the expression `5 < x < 10` is equivalent to `5 < x and x < 10`.
-- The precedence of some operators is different; see a complete list at the precedence table below.
 - Multi-expression constructs like `a = 1; b = 2; a + b` or
   `"a = 1;\n cos(a)\n sin(a)"` (where `\n` denotes newline)
   produce a collection ("ResultSet") of values. Those expressions
@@ -54,7 +53,6 @@ interchangeably. For example, `x+y` will always evaluate identically to
 `add(x,y)`. For a full list of the equivalences, see the section on
 Functions below.
 
-
 Operator    | Name                       | Syntax      | Associativity | Example               | Result
 ----------- | -------------------------- | ----------  | ------------- | --------------------- | ---------------
 `(`, `)`    | Grouping                   | `(x)`       | None          | `2 * (3 + 4)`         | `14`
@@ -94,7 +92,6 @@ Operator    | Name                       | Syntax      | Associativity | Example
 `xor`       | Logical xor                | `x xor y`   | Left to right | `true xor true`       | `false`
 `=`         | Assignment                 | `x = y`     | Right to left | `a = 5`               | `5`
 `?` `:`     | Conditional expression     | `x ? y : z` | Right to left | `15 > 100 ? 1 : -1`   | `-1`
-`??`        | Nullish coalescing         | `x ?? y`    | Left to right | `null ?? 2`           | `2`
 `:`         | Range                      | `x : y`     | Right to left | `1:4`                 | `[1,2,3,4]`
 `to`, `in`  | Unit conversion            | `x to y`    | Left to right | `2 inch to cm`        | `5.08 cm`
 `==`        | Equal                      | `x == y`    | Left to right | `2 == 4 - 2`          | `true`
@@ -115,7 +112,6 @@ Operators                         | Description
 `x(...)`<br>`x[...]`<br>`obj.prop`<br>`:`| Function call<br>Matrix index<br>Property accessor<br>Key/value separator
 `'`                               | Matrix transpose
 `!`                               | Factorial
-`??`                              | Nullish coalescing
 `^`, `.^`                         | Exponentiation
 `+`, `-`, `~`, `not`              | Unary plus, unary minus, bitwise not, logical not
 See section below                 | Implicit multiplication
@@ -225,7 +221,6 @@ Operator Expression  | Equivalent Function Expression
 `a \| b`             |`bitOr(a,b)`
 `a ^\| b`            |`bitXor(a,b)`
 `a & b`              |`bitAnd(a,b)`
-`a ?? b`             |`nullish(a,b)`
 `a == b`             |`equal(a,b)`
 `a != b`             |`unequal(a,b)`
 `a < b`              |`smaller(a,b)`
diff --git a/src/expression/embeddedDocs/embeddedDocs.js b/src/expression/embeddedDocs/embeddedDocs.js
index 0696f3c67..bce6cde74 100644
--- a/src/expression/embeddedDocs/embeddedDocs.js
+++ b/src/expression/embeddedDocs/embeddedDocs.js
@@ -112,7 +112,6 @@ import { distanceDocs } from './function/geometry/distance.js'
 import { intersectDocs } from './function/geometry/intersect.js'
 import { andDocs } from './function/logical/and.js'
 import { notDocs } from './function/logical/not.js'
-import { nullishDocs } from './function/logical/nullish.js'
 import { orDocs } from './function/logical/or.js'
 import { xorDocs } from './function/logical/xor.js'
 import { mapSlicesDocs } from './function/matrix/mapSlices.js'
@@ -446,7 +445,6 @@ export const embeddedDocs = {
   // functions - logical
   and: andDocs,
   not: notDocs,
-  nullish: nullishDocs,
   or: orDocs,
   xor: xorDocs,
 
diff --git a/src/expression/embeddedDocs/function/logical/nullish.js b/src/expression/embeddedDocs/function/logical/nullish.js
deleted file mode 100644
index 73ccf3378..000000000
--- a/src/expression/embeddedDocs/function/logical/nullish.js
+++ /dev/null
@@ -1,19 +0,0 @@
-export const nullishDocs = {
-  name: 'nullish',
-  category: 'Logical',
-  syntax: [
-    'x ?? y',
-    'nullish(x, y)'
-  ],
-  description: 'Nullish coalescing operator. Returns the right-hand operand when the left-hand operand is null or undefined, and otherwise returns the left-hand operand.',
-  examples: [
-    'null ?? 42',
-    'undefined ?? 42',
-    '0 ?? 42',
-    'false ?? 42',
-    'null ?? undefined ?? 42'
-  ],
-  seealso: [
-    'and', 'or', 'not'
-  ]
-}
diff --git a/src/expression/operators.js b/src/expression/operators.js
index 8076f70ae..ab73b3de3 100644
--- a/src/expression/operators.js
+++ b/src/expression/operators.js
@@ -39,6 +39,7 @@ export const properties = [
       associativity: 'left',
       associativeWith: []
     }
+
   },
   { // logical xor
     'OperatorNode:xor': {
@@ -238,13 +239,6 @@ export const properties = [
       associativeWith: []
     }
   },
-  { // nullish coalescing
-    'OperatorNode:nullish': {
-      op: '??',
-      associativity: 'left',
-      associativeWith: []
-    }
-  },
   { // factorial
     'OperatorNode:factorial': {
       op: '!',
diff --git a/src/expression/parse.js b/src/expression/parse.js
index 1b1ce4892..3ac4c09c3 100644
--- a/src/expression/parse.js
+++ b/src/expression/parse.js
@@ -151,7 +151,6 @@ export const createParse = /* #__PURE__ */ factory(name, dependencies, ({
     '=': true,
     ':': true,
     '?': true,
-    '??': true,
 
     '==': true,
     '!=': true,
@@ -1202,7 +1201,7 @@ export const createParse = /* #__PURE__ */ factory(name, dependencies, ({
   function parsePow (state) {
     let node, name, fn, params
 
-    node = parseNullishCoalescing(state)
+    node = parseLeftHandOperators(state)
 
     if (state.token === '^' || state.token === '.^') {
       name = state.token
@@ -1216,22 +1215,6 @@ export const createParse = /* #__PURE__ */ factory(name, dependencies, ({
     return node
   }
 
-  /**
-   * nullish coalescing operator
-   * @return {Node} node
-   * @private
-   */
-  function parseNullishCoalescing (state) {
-    let node = parseLeftHandOperators(state)
-
-    while (state.token === '??') { // eslint-disable-line no-unmodified-loop-condition
-      getTokenSkipNewline(state)
-      node = new OperatorNode('??', 'nullish', [node, parseLeftHandOperators(state)])
-    }
-
-    return node
-  }
-
   /**
    * Left hand operators: factorial x!, ctranspose x'
    * @return {Node} node
diff --git a/src/expression/transform/nullish.transform.js b/src/expression/transform/nullish.transform.js
deleted file mode 100644
index 7c6e733be..000000000
--- a/src/expression/transform/nullish.transform.js
+++ /dev/null
@@ -1,27 +0,0 @@
-import { createNullish } from '../../function/logical/nullish.js'
-import { factory } from '../../utils/factory.js'
-import { isCollection } from '../../utils/is.js'
-
-const name = 'nullish'
-const dependencies = ['typed', 'matrix', 'size', 'flatten', 'deepEqual']
-
-export const createNullishTransform = /* #__PURE__ */ factory(name, dependencies, ({ typed, matrix, size, flatten, deepEqual }) => {
-  const nullish = createNullish({ typed, matrix, size, flatten, deepEqual })
-
-  function nullishTransform (args, math, scope) {
-    const left = args[0].compile().evaluate(scope)
-
-    // If left is not a collection and not nullish, short-circuit and return it
-    if (!isCollection(left) && left != null && left !== undefined) {
-      return left
-    }
-
-    // Otherwise evaluate right and apply full nullish semantics (incl. element-wise)
-    const right = args[1].compile().evaluate(scope)
-    return nullish(left, right)
-  }
-
-  nullishTransform.rawArgs = true
-
-  return nullishTransform
-}, { isTransformFunction: true })
diff --git a/src/factoriesAny.js b/src/factoriesAny.js
index 4b7d70bf4..5de88aebd 100644
--- a/src/factoriesAny.js
+++ b/src/factoriesAny.js
@@ -66,7 +66,6 @@ export { createConj } from './function/complex/conj.js'
 export { createIm } from './function/complex/im.js'
 export { createRe } from './function/complex/re.js'
 export { createNot } from './function/logical/not.js'
-export { createNullish } from './function/logical/nullish.js'
 export { createOr } from './function/logical/or.js'
 export { createXor } from './function/logical/xor.js'
 export { createConcat } from './function/matrix/concat.js'
@@ -365,6 +364,5 @@ export { createVarianceTransform } from './expression/transform/variance.transfo
 export { createPrintTransform } from './expression/transform/print.transform.js'
 export { createAndTransform } from './expression/transform/and.transform.js'
 export { createOrTransform } from './expression/transform/or.transform.js'
-export { createNullishTransform } from './expression/transform/nullish.transform.js'
 export { createBitAndTransform } from './expression/transform/bitAnd.transform.js'
 export { createBitOrTransform } from './expression/transform/bitOr.transform.js'
diff --git a/src/function/logical/nullish.js b/src/function/logical/nullish.js
deleted file mode 100644
index 30eabda02..000000000
--- a/src/function/logical/nullish.js
+++ /dev/null
@@ -1,80 +0,0 @@
-import { factory } from '../../utils/factory.js'
-import { createMatAlgo03xDSf } from '../../type/matrix/utils/matAlgo03xDSf.js'
-import { createMatAlgo14xDs } from '../../type/matrix/utils/matAlgo14xDs.js'
-import { createMatAlgo13xDD } from '../../type/matrix/utils/matAlgo13xDD.js'
-import { DimensionError } from '../../error/DimensionError.js'
-
-const name = 'nullish'
-const dependencies = ['typed', 'matrix', 'size', 'flatten', 'deepEqual']
-
-export const createNullish = /* #__PURE__ */ factory(
-  name,
-  dependencies,
-  ({ typed, matrix, size, flatten, deepEqual }) => {
-    const matAlgo03xDSf = createMatAlgo03xDSf({ typed })
-    const matAlgo14xDs = createMatAlgo14xDs({ typed })
-    const matAlgo13xDD = createMatAlgo13xDD({ typed })
-
-    /**
-     * Nullish coalescing operator (??). Returns the right-hand side operand
-     * when the left-hand side operand is null or undefined, and otherwise
-     * returns the left-hand side operand.
-     *
-     * For matrices, the function is evaluated element wise.
-     *
-     * Syntax:
-     *
-     *    math.nullish(x, y)
-     *
-     * Examples:
-     *
-     *    math.nullish(null, 42)        // returns 42
-     *    math.nullish(undefined, 42)   // returns 42
-     *    math.nullish(0, 42)           // returns 0
-     *    math.nullish(false, 42)       // returns false
-     *    math.nullish('', 42)          // returns ''
-     *
-     *    // Object property access with fallback
-     *    const obj = {foo: 7, bar: 3}
-     *    math.nullish(obj.baz, 0)      // returns 0
-     *
-     * See also:
-     *
-     *    and, or, not
-     *
-     * @param  {*} x First value to check
-     * @param  {*} y Fallback value
-     * @return {*} Returns y when x is null or undefined, otherwise returns x
-     */
-
-    return typed(
-      name,
-      {
-        // Scalar and SparseMatrix-first short-circuit handlers
-        'number|bigint|Complex|BigNumber|Fraction|Unit|string|boolean|SparseMatrix, any': (x, _y) => x,
-        'null, any': (_x, y) => y,
-        'undefined, any': (_x, y) => y,
-
-        // SparseMatrix-first with collection RHS: enforce exact shape match
-        'SparseMatrix, Array | Matrix': (x, y) => {
-          const sx = flatten(size(x).valueOf()) // work around #3529/#3530
-          const sy = flatten(size(y).valueOf())
-          if (deepEqual(sx, sy)) return x
-          throw new DimensionError(sx, sy)
-        },
-
-        // DenseMatrix-first handlers (no broadcasting between collections)
-        'DenseMatrix, DenseMatrix': typed.referToSelf(self => (x, y) => matAlgo13xDD(x, y, self)),
-        'DenseMatrix, SparseMatrix': typed.referToSelf(self => (x, y) => matAlgo03xDSf(x, y, self, false)),
-        'DenseMatrix, Array': typed.referToSelf(self => (x, y) => matAlgo13xDD(x, matrix(y), self)),
-        'DenseMatrix, any': typed.referToSelf(self => (x, y) => matAlgo14xDs(x, y, self, false)),
-
-        // Array-first handlers (bridge via matrix() where needed)
-        'Array, Array': typed.referToSelf(self => (x, y) => matAlgo13xDD(matrix(x), matrix(y), self).valueOf()),
-        'Array, DenseMatrix': typed.referToSelf(self => (x, y) => matAlgo13xDD(matrix(x), y, self)),
-        'Array, SparseMatrix': typed.referToSelf(self => (x, y) => matAlgo03xDSf(matrix(x), y, self, false)),
-        'Array, any': typed.referToSelf(self => (x, y) => matAlgo14xDs(matrix(x), y, self, false).valueOf())
-      }
-    )
-  }
-)
diff --git a/test/unit-tests/expression/function/evaluate.test.js b/test/unit-tests/expression/function/evaluate.test.js
index 72e9af11f..7851573e1 100644
--- a/test/unit-tests/expression/function/evaluate.test.js
+++ b/test/unit-tests/expression/function/evaluate.test.js
@@ -84,199 +84,4 @@ describe('evaluate', function () {
     assert.strictEqual(expr1.toTex(), '\\mathrm{evaluate}\\left( expr\\right)')
     assert.strictEqual(expr2.toTex(), '\\mathrm{evaluate}\\left( expr, scope\\right)')
   })
-
-  describe('nullish coalescing operator', function () {
-    it('should handle basic nullish coalescing', function () {
-      assert.strictEqual(math.evaluate('null ?? 42'), 42)
-      assert.strictEqual(math.evaluate('undefined ?? 42'), 42)
-      assert.strictEqual(math.evaluate('0 ?? 42'), 0)
-      assert.strictEqual(math.evaluate('nullish(null, 42)'), 42)
-      assert.strictEqual(math.evaluate('false ?? 42'), false)
-      assert.strictEqual(math.evaluate('"" ?? 42'), '')
-      assert(isNaN(math.evaluate('NaN ?? 42'))) // Should return NaN, not 42
-    })
-
-    it('should handle nullish coalescing with variables', function () {
-      const scope1 = {}
-      assert.throws(() => math.evaluate('x ?? 42', scope1), /Undefined symbol x/)
-      assert.throws(() => math.evaluate('nullish(x, 42)', scope1), /Undefined symbol x/)
-
-      const scope2 = { x: null }
-      assert.strictEqual(math.evaluate('x ?? 42', scope2), 42)
-      assert.strictEqual(math.evaluate('nullish(x, 42)', scope2), 42)
-
-      const scope3 = { x: 0 }
-      assert.strictEqual(math.evaluate('x ?? 42', scope3), 0)
-      assert.strictEqual(math.evaluate('nullish(x, 42)', scope3), 0)
-
-      const scope4 = { x: undefined }
-      assert.strictEqual(math.evaluate('x ?? 42', scope4), 42)
-      assert.strictEqual(math.evaluate('nullish(x, 42)', scope4), 42)
-
-      const scope5 = { x: 5 }
-      assert.strictEqual(math.evaluate('x ?? 42', scope5), 5)
-      assert.strictEqual(math.evaluate('nullish(x, 42)', scope5), 5)
-    })
-
-    it('should handle chained nullish coalescing', function () {
-      assert.strictEqual(math.evaluate('null ?? undefined ?? 42'), 42)
-      assert.strictEqual(math.evaluate('nullish(null, undefined ?? 42)'), 42)
-      assert.strictEqual(math.evaluate('null ?? 10 ?? 42'), 10)
-      assert.strictEqual(math.evaluate('5 ?? null ?? 42'), 5)
-      assert.strictEqual(math.evaluate('nullish(5, null ?? 42)'), 5)
-      assert.strictEqual(math.evaluate('null ?? null ?? null ?? 99'), 99)
-      assert.strictEqual(math.evaluate('nullish(null ?? null, null ?? 99)'), 99)
-    })
-
-    it('should handle nullish coalescing with correct precedence', function () {
-      // ?? has higher precedence than arithmetic and logical operators
-      assert.strictEqual(math.evaluate('1 + null ?? 2'), 3) // 1 + (null ?? 2)
-      assert.strictEqual(math.evaluate('2 * null ?? 3'), 6) // 2 * (null ?? 3)
-
-      // ?? has higher precedence than exponentiation
-      assert.strictEqual(math.evaluate('2 ^ null ?? 3'), 8) // 2 ^ (null ?? 3)
-
-      assert.strictEqual(math.evaluate('null ?? false or true'), true) // (null ?? false) or true
-      assert.strictEqual(math.evaluate('true or null ?? 42'), true) // true or (null ?? 42)
-      assert.strictEqual(math.evaluate('false and null ?? 42'), false) // false and (null ?? 42)
-      assert.strictEqual(math.evaluate('true xor null ?? 42'), false) // true xor (null ?? 42)
-
-      // Parentheses can override precedence
-      assert.throws(() => math.evaluate('(1 + null) ?? 2'), /TypeError: Unexpected type of argument/)
-      assert.throws(() => math.evaluate('(2 * null) ?? 3'), /TypeError: Unexpected type of argument/)
-      assert.throws(() => math.evaluate('(2 ^ null) ?? 3'), /TypeError: Unexpected type of argument/)
-      assert.strictEqual(math.evaluate('2 * (null ?? 3)'), 6)
-    })
-
-    it('should handle nullish coalescing with higher precedence than exponentiation', function () {
-      // These tests specifically verify that ?? has higher precedence than ^
-      assert.strictEqual(math.evaluate('5 ?? 2 ^ 3'), 125) // (5 ?? 2) ^ 3 = 5 ^ 3 = 125
-      assert.strictEqual(math.evaluate('5 ?? (2 ^ 3)'), 5)
-      assert.strictEqual(math.evaluate('3 ^ null ?? 2 ^ 2'), 81) // 3 ^ (null ?? 2) ^ 2 = 3 ^ 2 ^ 2 = 3 ^ 4 = 81
-      assert.strictEqual(math.evaluate('false ?? 3 ^ 2'), 0) // false is not nullish, so (false ?? 3) ^ 2 = false ^ 2 = 0 ^ 2 = 0
-    })
-
-    it('should handle nullish coalescing precedence with dot power and left-hand operators', function () {
-      // dot power .^ should behave like ^ for scalars and bind lower than ??
-      assert.strictEqual(math.evaluate('2 .^ null ?? 3'), 8) // 2 .^ (null ?? 3)
-      assert.strictEqual(math.evaluate('5 ?? 2 .^ 3'), 125) // (5 ?? 2) .^ 3
-
-      // left-hand operators like factorial bind tighter than ??
-      assert.strictEqual(math.evaluate('5! ?? 2'), 120) // (5!) ?? 2
-      assert.strictEqual(math.evaluate('null ?? 3!'), 6) // null ?? (3!)
-      assert.strictEqual(math.evaluate('(null ?? 3)!'), 6) // parentheses with left-hand op
-    })
-
-    it('should handle nullish coalescing with scope lookup', function () {
-      const scope = { a: null, b: 5, c: 0 }
-      assert.strictEqual(math.evaluate('a ?? b * 2', scope), 10) // null ?? (5 * 2)
-      assert.strictEqual(math.evaluate('c ?? b * 2', scope), 0) // 0 ?? (5 * 2) = 0
-      assert.strictEqual(math.evaluate('(a ?? b) * 2', scope), 10) // (null ?? 5) * 2 = 10
-      // d is undefined, would throw error without fallback
-      assert.throws(() => math.evaluate('d ?? 0', scope), /Undefined symbol d/)
-    })
-
-    it('should handle nullish coalescing with strings', function () {
-      assert.strictEqual(math.evaluate('null ?? "hello"'), 'hello')
-      assert.strictEqual(math.evaluate('"world" ?? "hello"'), 'world')
-      assert.strictEqual(math.evaluate('"" ?? "hello"'), '') // empty string is not nullish
-    })
-
-    it('should handle nullish coalescing with matrices and arrays as operands', function () {
-      // Test arrays as operands
-      assert.deepStrictEqual(math.evaluate('null ?? [1, 2, 3]'), math.matrix([1, 2, 3]))
-      assert.deepStrictEqual(math.evaluate('[1, 2] ?? [3, 4]'), math.matrix([1, 2])) // Neither 1 nor 2 is nullish
-      assert.deepStrictEqual(math.evaluate('undefined ?? [5, 6]'), math.matrix([5, 6]))
-      assert.deepStrictEqual(math.evaluate('[null, null] ?? [7, 8]'), math.matrix([7, 8])) // Both null elements are nullish, so use [7, 8]
-
-      // Test matrices as operands
-      const matrix1 = math.matrix([1, 2])
-      assert.deepStrictEqual(math.evaluate('null ?? matrix([1, 2])'), matrix1)
-      assert.deepStrictEqual(math.evaluate('matrix([1, 2]) ?? matrix([3, 4])'), matrix1) // Neither 1 nor 2 is nullish
-      assert.deepStrictEqual(math.evaluate('undefined ?? matrix([5, 6])'), math.matrix([5, 6]))
-
-      // Test mixed arrays and matrices
-      assert.deepStrictEqual(math.evaluate('null ?? matrix([1, 2])'), matrix1)
-      assert.deepStrictEqual(math.evaluate('[1, 2] ?? matrix([3, 4])'), math.matrix([1, 2]))
-      assert.deepStrictEqual(math.evaluate('[null, 5] ?? 42'), math.matrix([42, 5]))
-      assert.deepStrictEqual(math.evaluate('[null, 5] ?? [1, 2]'), math.matrix([1, 5]))
-
-      // Test arrays/matrices containing expressions
-      assert.deepStrictEqual(math.evaluate(['null ?? 1', '2 ?? null', 'null ?? null ?? 3']), [1, 2, 3])
-      assert.deepStrictEqual(math.evaluate(math.matrix(['null ?? 1', '2 ?? null'])), math.matrix([1, 2]))
-
-      // Test shape mismatch with empty array
-      assert.throws(() => math.evaluate('[] ?? [7, 8]'), /RangeError/)
-      assert.throws(() => math.evaluate('[1] ?? [7, 8]'), /RangeError/)
-    })
-
-    it('should handle nullish coalescing with function calls', function () {
-      const scope = {
-        getValue: function () { return null },
-        getDefault: function () { return 42 }
-      }
-      assert.strictEqual(math.evaluate('getValue() ?? getDefault()', scope), 42)
-
-      const scope2 = {
-        getValue: function () { return 10 },
-        getDefault: function () { return 42 }
-      }
-      assert.strictEqual(math.evaluate('getValue() ?? getDefault()', scope2), 10)
-    })
-
-    it('should handle nullish function with arrays', function () {
-      assert.deepStrictEqual(math.evaluate('nullish(null, [1, 2, 3])'), math.matrix([1, 2, 3]))
-      assert.deepStrictEqual(math.evaluate('nullish([1, 2], [3, 4])'), math.matrix([1, 2]))
-      assert.deepStrictEqual(math.evaluate('nullish([null, 5], 42)'), math.matrix([42, 5]))
-      assert.deepStrictEqual(math.evaluate('nullish([null, 5], [1, 2])'), math.matrix([1, 5]))
-    })
-
-    it('should handle nullish coalescing with conditional expressions and correct precedence', function () {
-      // ?? has higher precedence than conditional (?:), so these test cases show the difference
-      assert.strictEqual(math.evaluate('5 ?? null ? 1 : 2'), 1) // (5 ?? null) ? 1 : 2 = 5 ? 1 : 2 = 1
-      assert.strictEqual(math.evaluate('null ?? 0 ? 1 : 2'), 2) // (null ?? 0) ? 1 : 2 = 0 ? 1 : 2 = 2
-      assert.strictEqual(math.evaluate('undefined ?? true ? 1 : 2'), 1) // (undefined ?? true) ? 1 : 2 = true ? 1 : 2 = 1
-
-      assert.strictEqual(math.evaluate('(5 ?? null) ? 1 : 2'), 1) // Explicit precedence
-      assert.strictEqual(math.evaluate('5 ?? (null ? 1 : 2)'), 5) // Different precedence
-    })
-
-    it('should short-circuit evaluation of the right-hand side when left is not nullish', function () {
-      // RHS throws if evaluated; must not be called
-      const scope = {
-        boom: function () { throw new Error('RHS evaluated unexpectedly') }
-      }
-      assert.strictEqual(math.evaluate('5 ?? boom()', scope), 5)
-      assert.strictEqual(math.evaluate('0 ?? boom()', scope), 0)
-      assert.strictEqual(math.evaluate('false ?? boom()', scope), false)
-      assert.strictEqual(math.evaluate('"" ?? boom()', scope), '')
-      assert.throws(() => math.evaluate('null ?? boom()', scope))
-      assert.throws(() => math.evaluate('undefined ?? boom()', scope))
-    })
-
-    it('should evaluate the right-hand side when left is nullish', function () {
-      let count = 0
-      const scope = {
-        inc: function () { count++; return 7 }
-      }
-      assert.strictEqual(math.evaluate('null ?? inc()', scope), 7)
-      assert.strictEqual(count, 1)
-      assert.strictEqual(math.evaluate('undefined ?? inc()', scope), 7)
-      assert.strictEqual(count, 2)
-    })
-
-    it('should not short-circuit for collections (element-wise evaluation requires RHS)', function () {
-      // When left is a collection, element-wise nullish requires evaluating RHS
-      let called = 0
-      const scope = {
-        getDefault: function () {
-          called++
-          return math.matrix([1, 2])
-        }
-      }
-      const res = math.evaluate('matrix([null, 5]) ?? getDefault()', scope)
-      assert.deepStrictEqual(res, math.matrix([1, 5]))
-      assert.strictEqual(called, 1)
-    })
-  })
 })
diff --git a/test/unit-tests/expression/operators.test.js b/test/unit-tests/expression/operators.test.js
index 7abc1e2fe..48c51d42f 100644
--- a/test/unit-tests/expression/operators.test.js
+++ b/test/unit-tests/expression/operators.test.js
@@ -14,14 +14,12 @@ describe('operators', function () {
     const b = new ConstantNode(2)
 
     const n1 = new AssignmentNode(new SymbolNode('a'), a)
-    const n2 = new OperatorNode('??', 'nullish', [a, b])
-    const n3 = new OperatorNode('or', 'or', [a, b])
-    const n4 = math.parse("M'")
+    const n2 = new OperatorNode('or', 'or', [a, b])
+    const n3 = math.parse("M'")
 
     assert.strictEqual(getPrecedence(n1, 'keep'), 0)
-    assert.strictEqual(getPrecedence(n2, 'keep'), 17) // nullish coalescing
-    assert.strictEqual(getPrecedence(n3, 'keep'), 2) // logical or
-    assert.strictEqual(getPrecedence(n4, 'keep'), 19)
+    assert.strictEqual(getPrecedence(n2, 'keep'), 2)
+    assert.strictEqual(getPrecedence(n3, 'keep'), 18)
   })
 
   it('should return null if precedence is not defined for a node', function () {
@@ -49,14 +47,12 @@ describe('operators', function () {
     const n2 = new OperatorNode('^', 'pow', [a, a])
     const n3 = new OperatorNode('-', 'unaryMinus', [a])
     const n4 = new OperatorNode('!', 'factorial', [a])
-    const n6 = new OperatorNode('??', 'nullish', [a, a])
     const n5 = math.parse("M'")
 
     assert.strictEqual(getAssociativity(n1, 'keep'), 'left')
     assert.strictEqual(getAssociativity(n2, 'keep'), 'right')
     assert.strictEqual(getAssociativity(n3, 'keep'), 'right')
     assert.strictEqual(getAssociativity(n4, 'keep'), 'left')
-    assert.strictEqual(getAssociativity(n6, 'keep'), 'left')
     assert.strictEqual(getAssociativity(n5, 'keep'), 'left')
   })
 
@@ -123,7 +119,6 @@ describe('operators', function () {
     assert.strictEqual(getOperator('multiply'), '*')
     assert.strictEqual(getOperator('ctranspose'), "'")
     assert.strictEqual(getOperator('mod'), 'mod')
-    assert.strictEqual(getOperator('nullish'), '??')
     assert.strictEqual(getOperator('square'), null)
   })
 })
diff --git a/test/unit-tests/function/logical/nullish.test.js b/test/unit-tests/function/logical/nullish.test.js
deleted file mode 100644
index 407809e7d..000000000
--- a/test/unit-tests/function/logical/nullish.test.js
+++ /dev/null
@@ -1,213 +0,0 @@
-import assert from 'assert'
-import math from '../../../../src/defaultInstance.js'
-const { sparse, matrix, nullish } = math
-
-describe('nullish', function () {
-  it('should return right if left nullish', function () {
-    assert.strictEqual(nullish(null, 42), 42)
-    assert.strictEqual(nullish(undefined, 'foo'), 'foo')
-    assert.strictEqual(nullish(0, 42), 0)
-  })
-
-  it('should short-circuit scalar ?? sparse', function () {
-    const s = sparse([[1, 0]])
-    assert.strictEqual(nullish(5, s), 5)
-    assert.strictEqual(nullish(undefined, s), s)
-  })
-
-  it('should short-circuit scalar ?? dense', function () {
-    const d = matrix([
-      [1, null],
-      [undefined, 4]
-    ])
-    assert.strictEqual(nullish(5, d), 5)
-    assert.strictEqual(nullish(undefined, d), d)
-  })
-
-  it('should handle sparse ?? dense efficiently', function () {
-    const s = sparse([[1, 0]])
-    const d = matrix([[10, 20]])
-    const res = nullish(s, d)
-    assert(res.isSparseMatrix) // but since 0 not nullish, res should have 1 and 0 (but sparse might skip 0)
-    assert.deepStrictEqual(res.toArray(), [[1, 0]])
-  })
-
-  it('should handle dense ?? scalar element-wise', function () {
-    const d = matrix([
-      [null, 0],
-      [undefined, 1]
-    ])
-    const res = nullish(d, 42)
-    assert.deepStrictEqual(res.toArray(), [
-      [42, 0],
-      [42, 1]
-    ])
-  })
-
-  it('should allow scalar broadcasting', function () {
-    assert.strictEqual(nullish(5, [7, 8]), 5)
-    assert.deepStrictEqual(nullish(null, [7, 8]), [7, 8])
-    assert.deepStrictEqual(nullish([null, undefined], 42), [42, 42])
-  })
-
-  describe('nullish with advanced types', function () {
-    it('should handle Complex numbers', function () {
-      const zeroComplex = math.complex(0, 0)
-      const nonZeroComplex = math.complex(1, 1)
-      assert.strictEqual(nullish(null, nonZeroComplex), nonZeroComplex)
-      assert.strictEqual(nullish(zeroComplex, nonZeroComplex), zeroComplex) // zero complex is not nullish
-      assert.strictEqual(nullish(nonZeroComplex, zeroComplex), nonZeroComplex)
-    })
-
-    it('should handle BigNumbers', function () {
-      const zeroBig = math.bignumber(0)
-      const nonZeroBig = math.bignumber(42)
-      assert.strictEqual(nullish(null, nonZeroBig), nonZeroBig)
-      assert.strictEqual(nullish(zeroBig, nonZeroBig), zeroBig) // zero BigNumber is not nullish
-      assert.strictEqual(nullish(nonZeroBig, zeroBig), nonZeroBig)
-    })
-
-    it('should handle Fractions', function () {
-      const zeroFrac = math.fraction(0)
-      const nonZeroFrac = math.fraction(3, 4)
-      assert.strictEqual(nullish(null, nonZeroFrac), nonZeroFrac)
-      assert.strictEqual(nullish(zeroFrac, nonZeroFrac), zeroFrac) // zero Fraction is not nullish
-      assert.strictEqual(nullish(nonZeroFrac, zeroFrac), nonZeroFrac)
-    })
-
-    it('should handle Units', function () {
-      const zeroUnit = math.unit(0, 'cm')
-      const nonZeroUnit = math.unit(5, 'cm')
-      assert.strictEqual(nullish(null, nonZeroUnit), nonZeroUnit)
-      assert.strictEqual(nullish(zeroUnit, nonZeroUnit), zeroUnit) // zero Unit is not nullish
-      assert.strictEqual(nullish(nonZeroUnit, zeroUnit), nonZeroUnit)
-    })
-  })
-
-  describe('nullish with n-dimensional matrices', function () {
-    it('should handle 3D matrices element-wise', function () {
-      const left = math.matrix([
-        [
-          [null, 1],
-          [undefined, 2]
-        ],
-        [
-          [3, null],
-          [4, 5]
-        ]
-      ])
-      const right = math.matrix([
-        [
-          [10, 20],
-          [30, 40]
-        ],
-        [
-          [50, 60],
-          [70, 80]
-        ]
-      ])
-      const res = nullish(left, right)
-      assert.deepStrictEqual(res.toArray(), [
-        [
-          [10, 1],
-          [30, 2]
-        ],
-        [
-          [3, 60],
-          [4, 5]
-        ]
-      ])
-    })
-  })
-
-  describe('shape handling and sparse matrices', function () {
-    it('should throw on mismatched shapes', function () {
-      assert.throws(() => nullish([1], [7, 8]), /Dimension mismatch/)
-      assert.throws(() => nullish(matrix([1]), matrix([7, 8])), /RangeError/)
-      assert.throws(() => nullish(sparse([[1]]), matrix([7, 8])), /DimensionError/)
-    })
-
-    it('should throw on mismatched shapes for sparse ?? dense', function () {
-      const left = sparse([[1, 0]])
-      const right = matrix([7, 8])
-      assert.throws(() => nullish(left, right), /Dimension mismatch/)
-    })
-
-    it('should throw on mismatched shapes for sparse ?? dense with zeros', function () {
-      const left = sparse([[0, 1]])
-      const right = matrix([7, 8])
-      assert.throws(() => nullish(left, right), /Dimension mismatch/)
-    })
-
-    it('should handle sparse with explicit null', function () {
-      const d = math.matrix([[null, 1]])
-      const s = math.sparse([[10, 20]])
-      const res = nullish(d, s)
-      assert.deepStrictEqual(res.toArray(), [[10, 1]])
-    })
-
-    it('should handle explicit null in dense ?? sparse', function () {
-      const d = math.matrix([[null, 1]])
-      const s = math.sparse([[10, 20]])
-      const res = nullish(d, s)
-      assert.deepStrictEqual(res.toArray(), [[10, 1]])
-    })
-
-    it('should throw on broadcastable but mismatched sizes', function () {
-      assert.throws(() => nullish([1], [7, 8]), /Dimension mismatch/)
-      assert.throws(() => nullish(math.matrix([1]), math.matrix([7, 8])), /Dimension mismatch/)
-    })
-
-    it('should throw on mismatched shapes for sparse ?? array (no temp conversion)', function () {
-      const left = sparse([[1, 0]])
-      const right = [7, 8, 9]
-      assert.throws(() => nullish(left, right), /Dimension mismatch/)
-    })
-
-    it('should throw on mismatched shapes for sparse ?? sparse', function () {
-      const left = sparse([[1, 0]]) // 1x2
-      const right = sparse([[7], [8]]) // 2x1
-      assert.throws(() => nullish(left, right), /Dimension mismatch/)
-    })
-
-    it('should return left on matching shapes for sparse ?? sparse', function () {
-      const left = sparse([[1, 0]]) // 1x2
-      const right = sparse([[7, 8]]) // 1x2
-      const res = nullish(left, right)
-      assert(res && res.isSparseMatrix)
-      assert.deepStrictEqual(res.toArray(), [[1, 0]])
-    })
-  })
-
-  describe('result type conventions (function form)', function () {
-    it('Array, Array -> Array', function () {
-      const r = nullish([null, 2], [7, 8])
-      assert(Array.isArray(r))
-      assert.deepStrictEqual(r, [7, 2])
-    })
-
-    it('Array, DenseMatrix -> Matrix', function () {
-      const r = nullish([null, 2], math.matrix([7, 8]))
-      assert.strictEqual(!!(r && (r.isMatrix || r.isDenseMatrix || r.isSparseMatrix)), true)
-      assert.deepStrictEqual(r.toArray(), [7, 2])
-    })
-
-    it('DenseMatrix, Array -> Matrix', function () {
-      const r = nullish(math.matrix([null, 2]), [7, 8])
-      assert.strictEqual(!!(r && (r.isMatrix || r.isDenseMatrix || r.isSparseMatrix)), true)
-      assert.deepStrictEqual(r.toArray(), [7, 2])
-    })
-
-    it('SparseMatrix, Array -> Matrix (left returned on match)', function () {
-      const r = nullish(math.sparse([[1, 0]]), [[7, 8]])
-      assert.strictEqual(!!(r && (r.isMatrix || r.isDenseMatrix || r.isSparseMatrix)), true)
-      assert.deepStrictEqual(r.toArray(), [[1, 0]])
-    })
-
-    it('Array, any (scalar) -> Array', function () {
-      const r = nullish([null, 5], 42)
-      assert(Array.isArray(r))
-      assert.deepStrictEqual(r, [42, 5])
-    })
-  })
-})
