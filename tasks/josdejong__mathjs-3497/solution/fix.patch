diff --git a/AUTHORS b/AUTHORS
index 04a7525c5..1048518d9 100644
--- a/AUTHORS
+++ b/AUTHORS
@@ -267,6 +267,7 @@ Delaney Sylvans <delaneysylvans@gmail.com>
 Rani D. <73716554+ranidam@users.noreply.github.com>
 Don McCurdy <dm@donmccurdy.com>
 Jay Chang <96050090+JayChang4w@users.noreply.github.com>
+Ikem Peter <ikempeter2020@gmail.com>
 mrft <977655+mrft@users.noreply.github.com>
 Jacopo Mercolini <79222209+Mundi93@users.noreply.github.com>
 Luca Quercetti <l.quercetti@wecodeyou.it>
diff --git a/docs/expressions/syntax.md b/docs/expressions/syntax.md
index 08d35f288..ad8bd3c92 100644
--- a/docs/expressions/syntax.md
+++ b/docs/expressions/syntax.md
@@ -24,6 +24,7 @@ the lower level syntax of math.js. Differences are:
   not bitwise xor.
 - Implicit multiplication, like `2 pi`, is supported and has special rules.
 - Relational operators (`<`, `>`, `<=`, `>=`, `==`, and `!=`) are chained, so the expression `5 < x < 10` is equivalent to `5 < x and x < 10`.
+- The precedence of some operators is different; see a complete list at the precedence table below.
 - Multi-expression constructs like `a = 1; b = 2; a + b` or
   `"a = 1;\n cos(a)\n sin(a)"` (where `\n` denotes newline)
   produce a collection ("ResultSet") of values. Those expressions
@@ -53,6 +54,7 @@ interchangeably. For example, `x+y` will always evaluate identically to
 `add(x,y)`. For a full list of the equivalences, see the section on
 Functions below.
 
+
 Operator    | Name                       | Syntax      | Associativity | Example               | Result
 ----------- | -------------------------- | ----------  | ------------- | --------------------- | ---------------
 `(`, `)`    | Grouping                   | `(x)`       | None          | `2 * (3 + 4)`         | `14`
@@ -92,6 +94,7 @@ Operator    | Name                       | Syntax      | Associativity | Example
 `xor`       | Logical xor                | `x xor y`   | Left to right | `true xor true`       | `false`
 `=`         | Assignment                 | `x = y`     | Right to left | `a = 5`               | `5`
 `?` `:`     | Conditional expression     | `x ? y : z` | Right to left | `15 > 100 ? 1 : -1`   | `-1`
+`??`        | Nullish coalescing         | `x ?? y`    | Left to right | `null ?? 2`           | `2`
 `:`         | Range                      | `x : y`     | Right to left | `1:4`                 | `[1,2,3,4]`
 `to`, `in`  | Unit conversion            | `x to y`    | Left to right | `2 inch to cm`        | `5.08 cm`
 `==`        | Equal                      | `x == y`    | Left to right | `2 == 4 - 2`          | `true`
@@ -112,6 +115,7 @@ Operators                         | Description
 `x(...)`<br>`x[...]`<br>`obj.prop`<br>`:`| Function call<br>Matrix index<br>Property accessor<br>Key/value separator
 `'`                               | Matrix transpose
 `!`                               | Factorial
+`??`                              | Nullish coalescing
 `^`, `.^`                         | Exponentiation
 `+`, `-`, `~`, `not`              | Unary plus, unary minus, bitwise not, logical not
 See section below                 | Implicit multiplication
@@ -221,6 +225,7 @@ Operator Expression  | Equivalent Function Expression
 `a \| b`             |`bitOr(a,b)`
 `a ^\| b`            |`bitXor(a,b)`
 `a & b`              |`bitAnd(a,b)`
+`a ?? b`             |`nullish(a,b)`
 `a == b`             |`equal(a,b)`
 `a != b`             |`unequal(a,b)`
 `a < b`              |`smaller(a,b)`
diff --git a/src/expression/embeddedDocs/embeddedDocs.js b/src/expression/embeddedDocs/embeddedDocs.js
index bce6cde74..0696f3c67 100644
--- a/src/expression/embeddedDocs/embeddedDocs.js
+++ b/src/expression/embeddedDocs/embeddedDocs.js
@@ -112,6 +112,7 @@ import { distanceDocs } from './function/geometry/distance.js'
 import { intersectDocs } from './function/geometry/intersect.js'
 import { andDocs } from './function/logical/and.js'
 import { notDocs } from './function/logical/not.js'
+import { nullishDocs } from './function/logical/nullish.js'
 import { orDocs } from './function/logical/or.js'
 import { xorDocs } from './function/logical/xor.js'
 import { mapSlicesDocs } from './function/matrix/mapSlices.js'
@@ -445,6 +446,7 @@ export const embeddedDocs = {
   // functions - logical
   and: andDocs,
   not: notDocs,
+  nullish: nullishDocs,
   or: orDocs,
   xor: xorDocs,
 
diff --git a/src/expression/embeddedDocs/function/logical/nullish.js b/src/expression/embeddedDocs/function/logical/nullish.js
new file mode 100644
index 000000000..73ccf3378
--- /dev/null
+++ b/src/expression/embeddedDocs/function/logical/nullish.js
@@ -0,0 +1,19 @@
+export const nullishDocs = {
+  name: 'nullish',
+  category: 'Logical',
+  syntax: [
+    'x ?? y',
+    'nullish(x, y)'
+  ],
+  description: 'Nullish coalescing operator. Returns the right-hand operand when the left-hand operand is null or undefined, and otherwise returns the left-hand operand.',
+  examples: [
+    'null ?? 42',
+    'undefined ?? 42',
+    '0 ?? 42',
+    'false ?? 42',
+    'null ?? undefined ?? 42'
+  ],
+  seealso: [
+    'and', 'or', 'not'
+  ]
+}
diff --git a/src/expression/operators.js b/src/expression/operators.js
index ab73b3de3..8076f70ae 100644
--- a/src/expression/operators.js
+++ b/src/expression/operators.js
@@ -39,7 +39,6 @@ export const properties = [
       associativity: 'left',
       associativeWith: []
     }
-
   },
   { // logical xor
     'OperatorNode:xor': {
@@ -239,6 +238,13 @@ export const properties = [
       associativeWith: []
     }
   },
+  { // nullish coalescing
+    'OperatorNode:nullish': {
+      op: '??',
+      associativity: 'left',
+      associativeWith: []
+    }
+  },
   { // factorial
     'OperatorNode:factorial': {
       op: '!',
diff --git a/src/expression/parse.js b/src/expression/parse.js
index 3ac4c09c3..1b1ce4892 100644
--- a/src/expression/parse.js
+++ b/src/expression/parse.js
@@ -151,6 +151,7 @@ export const createParse = /* #__PURE__ */ factory(name, dependencies, ({
     '=': true,
     ':': true,
     '?': true,
+    '??': true,
 
     '==': true,
     '!=': true,
@@ -1201,7 +1202,7 @@ export const createParse = /* #__PURE__ */ factory(name, dependencies, ({
   function parsePow (state) {
     let node, name, fn, params
 
-    node = parseLeftHandOperators(state)
+    node = parseNullishCoalescing(state)
 
     if (state.token === '^' || state.token === '.^') {
       name = state.token
@@ -1215,6 +1216,22 @@ export const createParse = /* #__PURE__ */ factory(name, dependencies, ({
     return node
   }
 
+  /**
+   * nullish coalescing operator
+   * @return {Node} node
+   * @private
+   */
+  function parseNullishCoalescing (state) {
+    let node = parseLeftHandOperators(state)
+
+    while (state.token === '??') { // eslint-disable-line no-unmodified-loop-condition
+      getTokenSkipNewline(state)
+      node = new OperatorNode('??', 'nullish', [node, parseLeftHandOperators(state)])
+    }
+
+    return node
+  }
+
   /**
    * Left hand operators: factorial x!, ctranspose x'
    * @return {Node} node
diff --git a/src/expression/transform/nullish.transform.js b/src/expression/transform/nullish.transform.js
new file mode 100644
index 000000000..7c6e733be
--- /dev/null
+++ b/src/expression/transform/nullish.transform.js
@@ -0,0 +1,27 @@
+import { createNullish } from '../../function/logical/nullish.js'
+import { factory } from '../../utils/factory.js'
+import { isCollection } from '../../utils/is.js'
+
+const name = 'nullish'
+const dependencies = ['typed', 'matrix', 'size', 'flatten', 'deepEqual']
+
+export const createNullishTransform = /* #__PURE__ */ factory(name, dependencies, ({ typed, matrix, size, flatten, deepEqual }) => {
+  const nullish = createNullish({ typed, matrix, size, flatten, deepEqual })
+
+  function nullishTransform (args, math, scope) {
+    const left = args[0].compile().evaluate(scope)
+
+    // If left is not a collection and not nullish, short-circuit and return it
+    if (!isCollection(left) && left != null && left !== undefined) {
+      return left
+    }
+
+    // Otherwise evaluate right and apply full nullish semantics (incl. element-wise)
+    const right = args[1].compile().evaluate(scope)
+    return nullish(left, right)
+  }
+
+  nullishTransform.rawArgs = true
+
+  return nullishTransform
+}, { isTransformFunction: true })
diff --git a/src/factoriesAny.js b/src/factoriesAny.js
index 5de88aebd..4b7d70bf4 100644
--- a/src/factoriesAny.js
+++ b/src/factoriesAny.js
@@ -66,6 +66,7 @@ export { createConj } from './function/complex/conj.js'
 export { createIm } from './function/complex/im.js'
 export { createRe } from './function/complex/re.js'
 export { createNot } from './function/logical/not.js'
+export { createNullish } from './function/logical/nullish.js'
 export { createOr } from './function/logical/or.js'
 export { createXor } from './function/logical/xor.js'
 export { createConcat } from './function/matrix/concat.js'
@@ -364,5 +365,6 @@ export { createVarianceTransform } from './expression/transform/variance.transfo
 export { createPrintTransform } from './expression/transform/print.transform.js'
 export { createAndTransform } from './expression/transform/and.transform.js'
 export { createOrTransform } from './expression/transform/or.transform.js'
+export { createNullishTransform } from './expression/transform/nullish.transform.js'
 export { createBitAndTransform } from './expression/transform/bitAnd.transform.js'
 export { createBitOrTransform } from './expression/transform/bitOr.transform.js'
diff --git a/src/function/logical/nullish.js b/src/function/logical/nullish.js
new file mode 100644
index 000000000..30eabda02
--- /dev/null
+++ b/src/function/logical/nullish.js
@@ -0,0 +1,80 @@
+import { factory } from '../../utils/factory.js'
+import { createMatAlgo03xDSf } from '../../type/matrix/utils/matAlgo03xDSf.js'
+import { createMatAlgo14xDs } from '../../type/matrix/utils/matAlgo14xDs.js'
+import { createMatAlgo13xDD } from '../../type/matrix/utils/matAlgo13xDD.js'
+import { DimensionError } from '../../error/DimensionError.js'
+
+const name = 'nullish'
+const dependencies = ['typed', 'matrix', 'size', 'flatten', 'deepEqual']
+
+export const createNullish = /* #__PURE__ */ factory(
+  name,
+  dependencies,
+  ({ typed, matrix, size, flatten, deepEqual }) => {
+    const matAlgo03xDSf = createMatAlgo03xDSf({ typed })
+    const matAlgo14xDs = createMatAlgo14xDs({ typed })
+    const matAlgo13xDD = createMatAlgo13xDD({ typed })
+
+    /**
+     * Nullish coalescing operator (??). Returns the right-hand side operand
+     * when the left-hand side operand is null or undefined, and otherwise
+     * returns the left-hand side operand.
+     *
+     * For matrices, the function is evaluated element wise.
+     *
+     * Syntax:
+     *
+     *    math.nullish(x, y)
+     *
+     * Examples:
+     *
+     *    math.nullish(null, 42)        // returns 42
+     *    math.nullish(undefined, 42)   // returns 42
+     *    math.nullish(0, 42)           // returns 0
+     *    math.nullish(false, 42)       // returns false
+     *    math.nullish('', 42)          // returns ''
+     *
+     *    // Object property access with fallback
+     *    const obj = {foo: 7, bar: 3}
+     *    math.nullish(obj.baz, 0)      // returns 0
+     *
+     * See also:
+     *
+     *    and, or, not
+     *
+     * @param  {*} x First value to check
+     * @param  {*} y Fallback value
+     * @return {*} Returns y when x is null or undefined, otherwise returns x
+     */
+
+    return typed(
+      name,
+      {
+        // Scalar and SparseMatrix-first short-circuit handlers
+        'number|bigint|Complex|BigNumber|Fraction|Unit|string|boolean|SparseMatrix, any': (x, _y) => x,
+        'null, any': (_x, y) => y,
+        'undefined, any': (_x, y) => y,
+
+        // SparseMatrix-first with collection RHS: enforce exact shape match
+        'SparseMatrix, Array | Matrix': (x, y) => {
+          const sx = flatten(size(x).valueOf()) // work around #3529/#3530
+          const sy = flatten(size(y).valueOf())
+          if (deepEqual(sx, sy)) return x
+          throw new DimensionError(sx, sy)
+        },
+
+        // DenseMatrix-first handlers (no broadcasting between collections)
+        'DenseMatrix, DenseMatrix': typed.referToSelf(self => (x, y) => matAlgo13xDD(x, y, self)),
+        'DenseMatrix, SparseMatrix': typed.referToSelf(self => (x, y) => matAlgo03xDSf(x, y, self, false)),
+        'DenseMatrix, Array': typed.referToSelf(self => (x, y) => matAlgo13xDD(x, matrix(y), self)),
+        'DenseMatrix, any': typed.referToSelf(self => (x, y) => matAlgo14xDs(x, y, self, false)),
+
+        // Array-first handlers (bridge via matrix() where needed)
+        'Array, Array': typed.referToSelf(self => (x, y) => matAlgo13xDD(matrix(x), matrix(y), self).valueOf()),
+        'Array, DenseMatrix': typed.referToSelf(self => (x, y) => matAlgo13xDD(matrix(x), y, self)),
+        'Array, SparseMatrix': typed.referToSelf(self => (x, y) => matAlgo03xDSf(matrix(x), y, self, false)),
+        'Array, any': typed.referToSelf(self => (x, y) => matAlgo14xDs(matrix(x), y, self, false).valueOf())
+      }
+    )
+  }
+)
