diff --git a/.changeset/chubby-buttons-lie.md b/.changeset/chubby-buttons-lie.md
new file mode 100644
index 0000000000..2e35902a2b
--- /dev/null
+++ b/.changeset/chubby-buttons-lie.md
@@ -0,0 +1,9 @@
+---
+"@biomejs/biome": minor
+---
+
+It's now possible to provide the stacktrace for a fatal error. The stacktrace is only available when the environment variable `RUST_BACKTRACE=1` is set, either via the CLI or exported `$PATH`. This is useful when providing detailed information for debugging purposes:
+
+```shell
+RUST_BACKTRACE=1 biome lint
+```
diff --git a/.changeset/dirty-beans-flash.md b/.changeset/dirty-beans-flash.md
new file mode 100644
index 0000000000..64b632b1a9
--- /dev/null
+++ b/.changeset/dirty-beans-flash.md
@@ -0,0 +1,5 @@
+---
+"@biomejs/biome": minor
+---
+
+Fixed [#8024](https://github.com/biomejs/biome/issues/8024). The rule [`useIterableCallbackReturn`](https://biomejs.dev/linter/rules/use-iterable-callback-return/) now supports a `checkForEach` option. When set to `false`, the rule will skip checking for `forEach()` callbacks for returning values.
diff --git a/.changeset/fix-component-export-tanstack-router.md b/.changeset/fix-component-export-tanstack-router.md
new file mode 100644
index 0000000000..e9ae0c5807
--- /dev/null
+++ b/.changeset/fix-component-export-tanstack-router.md
@@ -0,0 +1,13 @@
+---
+"@biomejs/biome": patch
+---
+
+Fixed [#8628](https://github.com/biomejs/biome/issues/8628): [`useComponentExportOnlyModules`](https://biomejs.dev/linter/rules/use-component-export-only-modules/) now allows components referenced as object property values in exported expressions. This fixes false positives for TanStack Router patterns.
+
+```jsx
+export const Route = createFileRoute('/')({
+  component: HomeComponent,
+})
+
+function HomeComponent() { ... } // no longer reported as "should be exported"
+```
diff --git a/.changeset/html-no-autofocus.md b/.changeset/html-no-autofocus.md
new file mode 100644
index 0000000000..e2bacce5a6
--- /dev/null
+++ b/.changeset/html-no-autofocus.md
@@ -0,0 +1,5 @@
+---
+"@biomejs/biome": minor
+---
+
+Added the [`noAutofocus`](https://biomejs.dev/linter/rules/no-autofocus/) lint rule for HTML. This rule enforces that the `autofocus` attribute is not used on elements, as it can cause usability issues for sighted and non-sighted users. The rule allows `autofocus` inside `dialog` elements or elements with the `popover` attribute, as these are modal contexts where autofocus is expected.
diff --git a/.changeset/html-use-alt-text.md b/.changeset/html-use-alt-text.md
new file mode 100644
index 0000000000..768eb5d844
--- /dev/null
+++ b/.changeset/html-use-alt-text.md
@@ -0,0 +1,5 @@
+---
+"@biomejs/biome": minor
+---
+
+Added the [`useAltText`](https://biomejs.dev/linter/rules/use-alt-text/) lint rule for HTML. This rule enforces that elements requiring alternative text (`<img>`, `<area>`, `<input type="image">`, `<object>`) provide meaningful information for screen reader users via `alt`, `title` (for objects), `aria-label`, or `aria-labelledby` attributes. Elements with `aria-hidden="true"` are exempt.
diff --git a/.changeset/skip-only-check-ci.md b/.changeset/skip-only-check-ci.md
deleted file mode 100644
index bd431414f9..0000000000
--- a/.changeset/skip-only-check-ci.md
+++ /dev/null
@@ -1,12 +0,0 @@
----
-"@biomejs/biome": minor
----
-
-Added `--only` and `--skip` options to `biome check` and `biome ci`, covering both lint diagnostics and assist actions. Biome now lets you run or exclude specific lint rules, assist actions, group or rules and actions, or domains when running these commands.
-
-Examples:
-
-```shell
-biome check --only=suspicious/noDebugger src/**/*.js
-biome ci --skip=project src/**
-```
diff --git a/.changeset/small-seas-laugh.md b/.changeset/small-seas-laugh.md
new file mode 100644
index 0000000000..2846ef08a7
--- /dev/null
+++ b/.changeset/small-seas-laugh.md
@@ -0,0 +1,5 @@
+---
+"@biomejs/biome": minor
+---
+
+Added the rule [`noRedundantAlt`](https://biomejs.dev/linter/rules/no-redundant-alt/) to HTML. The rule enforces that the `img` element `alt` attribute does not contain the words “image”, “picture”, or “photo”.
diff --git a/.changeset/smooth-dots-swim.md b/.changeset/smooth-dots-swim.md
new file mode 100644
index 0000000000..5bfaa1b604
--- /dev/null
+++ b/.changeset/smooth-dots-swim.md
@@ -0,0 +1,16 @@
+---
+"@biomejs/biome": minor
+---
+
+Added the new linter domain `types`. This is a domain that enables all rules that require the type inference engine.
+
+As opposed to the `project` domain, which only enables rules that require the module graph to function.
+
+The following **nursery** rules have been moved to the `types` domain:
+- `useArraySortCompare`
+- `useAwaitThenable`
+- `useFind`
+- `useRegexpExec`
+- `noUnnecessaryConditions`
+- `noMisusedPromises`
+- `noFloatingPromises`
diff --git a/crates/biome_analyze/src/rule.rs b/crates/biome_analyze/src/rule.rs
index 429f26d9b2..e28942c74e 100644
--- a/crates/biome_analyze/src/rule.rs
+++ b/crates/biome_analyze/src/rule.rs
@@ -475,6 +475,8 @@ pub enum RuleDomain {
     Tailwind,
     /// Turborepo build system rules
     Turborepo,
+    /// Rules that require type inference
+    Types,
 }
 
 impl Display for RuleDomain {
@@ -490,6 +492,7 @@ impl Display for RuleDomain {
             Self::Project => fmt.write_str("project"),
             Self::Tailwind => fmt.write_str("tailwind"),
             Self::Turborepo => fmt.write_str("turborepo"),
+            Self::Types => fmt.write_str("types"),
         }
     }
 }
@@ -530,6 +533,7 @@ impl RuleDomain {
             Self::Project => &[],
             Self::Tailwind => &[&("tailwindcss", ">=3.0.0")],
             Self::Turborepo => &[&("turbo", ">=1.0.0")],
+            Self::Types => &[],
         }
     }
 
@@ -556,6 +560,7 @@ impl RuleDomain {
             Self::Project => &[],
             Self::Tailwind => &[],
             Self::Turborepo => &[],
+            Self::Types => &[],
         }
     }
 
@@ -570,6 +575,7 @@ impl RuleDomain {
             Self::Project => "project",
             Self::Tailwind => "tailwind",
             Self::Turborepo => "turborepo",
+            Self::Types => "types",
         }
     }
 }
@@ -588,6 +594,7 @@ impl FromStr for RuleDomain {
             "project" => Ok(Self::Project),
             "tailwind" => Ok(Self::Tailwind),
             "turborepo" => Ok(Self::Turborepo),
+            "types" => Ok(Self::Types),
 
             _ => Err("Invalid rule domain"),
         }
diff --git a/crates/biome_cli/src/commands/check.rs b/crates/biome_cli/src/commands/check.rs
index 730f5b26fa..f02d716466 100644
--- a/crates/biome_cli/src/commands/check.rs
+++ b/crates/biome_cli/src/commands/check.rs
@@ -5,7 +5,6 @@ use crate::runner::execution::{AnalyzerSelectors, Execution, VcsTargeted};
 use crate::runner::impls::commands::traversal::{LoadEditorConfig, TraversalCommand};
 use crate::runner::impls::executions::summary_verb::SummaryVerbExecution;
 use crate::runner::impls::process_file::check::CheckProcessFile;
-use biome_configuration::analyzer::AnalyzerSelector;
 use biome_configuration::analyzer::LinterEnabled;
 use biome_configuration::analyzer::assist::{AssistConfiguration, AssistEnabled};
 use biome_configuration::css::CssParserConfiguration;
@@ -42,8 +41,6 @@ pub(crate) struct CheckCommandPayload {
     pub(crate) format_with_errors: Option<FormatWithErrorsEnabled>,
     pub(crate) json_parser: Option<JsonParserConfiguration>,
     pub(crate) css_parser: Option<CssParserConfiguration>,
-    pub(crate) only: Vec<AnalyzerSelector>,
-    pub(crate) skip: Vec<AnalyzerSelector>,
 }
 
 struct CheckExecution {
@@ -64,11 +61,6 @@ struct CheckExecution {
 
     /// It skips parse errors
     skip_parse_errors: bool,
-
-    /// Run only the given lint rule, assist action, group of rules and actions, or domain
-    only: Vec<AnalyzerSelector>,
-    /// Skip the given lint rule, assist action, group of rules and actions, or domain
-    skip: Vec<AnalyzerSelector>,
 }
 
 impl Execution for CheckExecution {
@@ -130,10 +122,7 @@ impl Execution for CheckExecution {
     }
 
     fn analyzer_selectors(&self) -> AnalyzerSelectors {
-        AnalyzerSelectors {
-            only: self.only.clone(),
-            skip: self.skip.clone(),
-        }
+        AnalyzerSelectors::default()
     }
 
     fn should_enforce_assist(&self) -> bool {
@@ -185,8 +174,6 @@ impl TraversalCommand for CheckCommandPayload {
             vcs_targeted: (self.staged, self.changed).into(),
             enforce_assist: self.enforce_assist,
             skip_parse_errors: cli_options.skip_parse_errors,
-            only: self.only.clone(),
-            skip: self.skip.clone(),
         }))
     }
 
diff --git a/crates/biome_cli/src/commands/ci.rs b/crates/biome_cli/src/commands/ci.rs
index da9eadb97a..2705735811 100644
--- a/crates/biome_cli/src/commands/ci.rs
+++ b/crates/biome_cli/src/commands/ci.rs
@@ -5,7 +5,6 @@ use crate::runner::execution::{AnalyzerSelectors, Execution, ExecutionEnvironmen
 use crate::runner::impls::commands::traversal::{LoadEditorConfig, TraversalCommand};
 use crate::runner::impls::executions::summary_verb::SummaryVerbExecution;
 use crate::runner::impls::process_file::check::CheckProcessFile;
-use biome_configuration::analyzer::AnalyzerSelector;
 use biome_configuration::analyzer::LinterEnabled;
 use biome_configuration::analyzer::assist::{AssistConfiguration, AssistEnabled};
 use biome_configuration::css::CssParserConfiguration;
@@ -38,8 +37,6 @@ pub(crate) struct CiCommandPayload {
     pub(crate) format_with_errors: Option<FormatWithErrorsEnabled>,
     pub(crate) json_parser: Option<JsonParserConfiguration>,
     pub(crate) css_parser: Option<CssParserConfiguration>,
-    pub(crate) only: Vec<AnalyzerSelector>,
-    pub(crate) skip: Vec<AnalyzerSelector>,
 }
 
 struct CiExecution {
@@ -51,10 +48,6 @@ struct CiExecution {
     enforce_assist: bool,
     /// It skips parse errors
     skip_parse_errors: bool,
-    /// Run only the given rule or group of rules.
-    only: Vec<AnalyzerSelector>,
-    /// Skip the given rule or group of rules.
-    skip: Vec<AnalyzerSelector>,
 }
 
 impl Execution for CiExecution {
@@ -102,10 +95,7 @@ impl Execution for CiExecution {
     }
 
     fn analyzer_selectors(&self) -> AnalyzerSelectors {
-        AnalyzerSelectors {
-            only: self.only.clone(),
-            skip: self.skip.clone(),
-        }
+        AnalyzerSelectors::default()
     }
 
     fn should_enforce_assist(&self) -> bool {
@@ -157,8 +147,6 @@ impl TraversalCommand for CiCommandPayload {
             vcs_targeted: (false, self.changed).into(),
             enforce_assist: self.enforce_assist,
             skip_parse_errors: cli_options.skip_parse_errors,
-            only: self.only.clone(),
-            skip: self.skip.clone(),
         }))
     }
 
diff --git a/crates/biome_cli/src/commands/mod.rs b/crates/biome_cli/src/commands/mod.rs
index ffeedb74e5..6a7970727a 100644
--- a/crates/biome_cli/src/commands/mod.rs
+++ b/crates/biome_cli/src/commands/mod.rs
@@ -181,29 +181,6 @@ pub enum BiomeCommand {
         #[bpaf(long("since"), argument("REF"))]
         since: Option<String>,
 
-        /// Run only the given lint rule, assist action, group of rules and actions, or domain.
-        /// If the severity level of a rule is `off`,
-        /// then the severity level of the rule is set to `error` if it is a recommended rule or `warn` otherwise.
-        ///
-        /// Example:
-        ///
-        /// ```shell
-        /// biome check --only=correctness/noUnusedVariables --only=suspicious --only=test
-        /// ```
-        #[bpaf(long("only"), argument("GROUP|RULE|DOMAIN|ACTION"))]
-        only: Vec<AnalyzerSelector>,
-
-        /// Skip the given lint rule, assist action, group of rules and actions, or domain by setting the severity level of the rules to `off`.
-        /// This option takes precedence over `--only`.
-        ///
-        /// Example:
-        ///
-        /// ```shell
-        /// biome check --skip=correctness/noUnusedVariables --skip=suspicious --skip=project
-        /// ```
-        #[bpaf(long("skip"), argument("GROUP|RULE|DOMAIN|ACTION"))]
-        skip: Vec<AnalyzerSelector>,
-
         /// Single file, single path or list of paths
         #[bpaf(positional("PATH"), many)]
         paths: Vec<OsString>,
@@ -264,7 +241,7 @@ pub enum BiomeCommand {
         #[bpaf(external, hide_usage)]
         log_options: LogOptions,
 
-        /// Run only the given lint rule, assist action, group of rules and actions, or domain.
+        /// Run only the given rule, group of rules or domain.
         /// If the severity level of a rule is `off`,
         /// then the severity level of the rule is set to `error` if it is a recommended rule or `warn` otherwise.
         ///
@@ -273,10 +250,10 @@ pub enum BiomeCommand {
         /// ```shell
         /// biome lint --only=correctness/noUnusedVariables --only=suspicious --only=test
         /// ```
-        #[bpaf(long("only"), argument("GROUP|RULE|DOMAIN|ACTION"))]
+        #[bpaf(long("only"), argument("GROUP|RULE|DOMAIN"))]
         only: Vec<AnalyzerSelector>,
 
-        /// Skip the given lint rule, assist action, group of rules and actions, or domain by setting the severity level of the rules to `off`.
+        /// Skip the given rule, group of rules or domain by setting the severity level of the rules to `off`.
         /// This option takes precedence over `--only`.
         ///
         /// Example:
@@ -284,7 +261,7 @@ pub enum BiomeCommand {
         /// ```shell
         /// biome lint --skip=correctness/noUnusedVariables --skip=suspicious --skip=project
         /// ```
-        #[bpaf(long("skip"), argument("GROUP|RULE|DOMAIN|ACTION"))]
+        #[bpaf(long("skip"), argument("GROUP|RULE|DOMAIN"))]
         skip: Vec<AnalyzerSelector>,
 
         /// Use this option when you want to format code piped from `stdin`, and print the output to `stdout`.
@@ -459,29 +436,6 @@ pub enum BiomeCommand {
         )]
         threads: Option<usize>,
 
-        /// Run only the given lint rule, assist action, group of rules and actions, or domain.
-        /// If the severity level of a rule is `off`,
-        /// then the severity level of the rule is set to `error` if it is a recommended rule or `warn` otherwise.
-        ///
-        /// Example:
-        ///
-        /// ```shell
-        /// biome ci --only=correctness/noUnusedVariables --only=suspicious --only=test
-        /// ```
-        #[bpaf(long("only"), argument("GROUP|RULE|DOMAIN|ACTION"))]
-        only: Vec<AnalyzerSelector>,
-
-        /// Skip the given lint rule, assist action, group of rules and actions, or domain by setting the severity level of the rules to `off`.
-        /// This option takes precedence over `--only`.
-        ///
-        /// Example:
-        ///
-        /// ```shell
-        /// biome ci --skip=correctness/noUnusedVariables --skip=suspicious --skip=project
-        /// ```
-        #[bpaf(long("skip"), argument("GROUP|RULE|DOMAIN|ACTION"))]
-        skip: Vec<AnalyzerSelector>,
-
         /// Single file, single path or list of paths
         #[bpaf(positional("PATH"), many)]
         paths: Vec<OsString>,
diff --git a/crates/biome_cli/src/lib.rs b/crates/biome_cli/src/lib.rs
index 5925738e85..2442c80744 100644
--- a/crates/biome_cli/src/lib.rs
+++ b/crates/biome_cli/src/lib.rs
@@ -97,8 +97,6 @@ impl<'app> CliSession<'app> {
                 json_parser,
                 css_parser,
                 log_options,
-                only,
-                skip,
             } => run_command(
                 self,
                 &log_options,
@@ -120,8 +118,6 @@ impl<'app> CliSession<'app> {
                     format_with_errors,
                     json_parser,
                     css_parser,
-                    only,
-                    skip,
                 }),
             ),
             BiomeCommand::Lint {
@@ -190,8 +186,6 @@ impl<'app> CliSession<'app> {
                 css_parser,
                 json_parser,
                 log_options,
-                only,
-                skip,
                 ..
             } => run_command(
                 self,
@@ -209,8 +203,6 @@ impl<'app> CliSession<'app> {
                     format_with_errors,
                     css_parser,
                     json_parser,
-                    only,
-                    skip,
                 }),
             ),
             BiomeCommand::Format {
diff --git a/crates/biome_cli/src/panic.rs b/crates/biome_cli/src/panic.rs
index 1e1f5976e1..1e72cda86f 100644
--- a/crates/biome_cli/src/panic.rs
+++ b/crates/biome_cli/src/panic.rs
@@ -1,4 +1,5 @@
 use std::{
+    backtrace::{Backtrace, BacktraceStatus},
     fmt::Write,
     panic::{PanicHookInfo, set_hook},
     thread,
@@ -11,39 +12,68 @@ pub fn setup_panic_handler() {
 }
 
 fn panic_handler(info: &PanicHookInfo) {
+    let error = write_error(info).expect("To write into buffer");
+
+    // Write the panic to stderr
+    eprintln!("{error}");
+
+    // Write the panic to the log file, this is done last since the `tracing`
+    // infrastructure could panic a second time and abort the process, so we
+    // want to ensure the error has at least been logged to stderr beforehand
+    tracing::error!("{error}");
+}
+
+fn write_error(info: &PanicHookInfo) -> Result<String, std::fmt::Error> {
     // Buffer the error message to a string before printing it at once
     // to prevent it from getting mixed with other errors if multiple threads
     // panic at the same time
     let mut error = String::new();
 
-    writeln!(error, "Biome encountered an unexpected error").unwrap();
-    writeln!(error).unwrap();
+    writeln!(error, "Biome encountered an unexpected error")?;
+    writeln!(error)?;
 
-    writeln!(error, "This is a bug in Biome, not an error in your code, and we would appreciate it if you could report it to https://github.com/biomejs/biome/issues/ along with the following information to help us fixing the issue.").unwrap();
-    writeln!(error).unwrap();
-    writeln!(error, "When opening the issue, please provide a minimal reproduction, or identify and share the file/code that triggers it. Without a way to reproduce the error, the error can't be fixed:").unwrap();
-    writeln!(error).unwrap();
+    writeln!(
+        error,
+        "This is a bug in Biome, not an error in your code, and we would appreciate it if you could report it to https://github.com/biomejs/biome/issues/ along with the following information to help us fixing the issue."
+    )?;
+    writeln!(error)?;
+    writeln!(
+        error,
+        "When opening the issue, please provide a minimal reproduction, or identify and share the file/code that triggers it. Without a way to reproduce the error, the error can't be fixed:"
+    )?;
+    writeln!(error)?;
 
     if let Some(location) = info.location() {
-        writeln!(error, "Source Location: {location}").unwrap();
+        writeln!(error, "Source Location: {location}")?;
     }
 
     if let Some(thread) = thread::current().name() {
-        writeln!(error, "Thread Name: {thread}").unwrap();
+        writeln!(error, "Thread Name: {thread}")?;
     }
 
     let payload = info.payload();
     if let Some(msg) = payload.downcast_ref::<&'static str>() {
-        writeln!(error, "Message: {msg}").unwrap();
+        writeln!(error, "Message: {msg}")?;
     } else if let Some(msg) = payload.downcast_ref::<String>() {
-        writeln!(error, "Message: {msg}").unwrap();
+        writeln!(error, "Message: {msg}")?;
     }
 
-    // Write the panic to stderr
-    eprintln!("{error}");
+    let backtrace = Backtrace::capture();
+    match backtrace.status() {
+        BacktraceStatus::Captured => {
+            writeln!(error, "Stack Trace:")?;
+            writeln!(error, "{}", backtrace)?;
+        }
+        BacktraceStatus::Disabled => {
+            writeln!(
+                error,
+                "Stack Trace: Re-run with `RUST_BACKTRACE=1` to capture the stack trace"
+            )?;
+        }
+        _ => {
+            writeln!(error, "Stack Trace: Not Supported")?;
+        }
+    }
 
-    // Write the panic to the log file, this is done last since the `tracing`
-    // infrastructure could panic a second time and abort the process, so we
-    // want to ensure the error has at least been logged to stderr beforehand
-    tracing::error!("{error}");
+    Ok(error)
 }
diff --git a/crates/biome_cli/src/runner/mod.rs b/crates/biome_cli/src/runner/mod.rs
index 8adc177cc5..0b8012b0f0 100644
--- a/crates/biome_cli/src/runner/mod.rs
+++ b/crates/biome_cli/src/runner/mod.rs
@@ -152,6 +152,7 @@ use biome_fs::{BiomePath, FileSystem};
 use biome_resolver::FsWithResolverProxy;
 use biome_service::configuration::{LoadedConfiguration, ProjectScanComputer, load_configuration};
 use biome_service::projects::ProjectKey;
+use biome_service::settings::ModuleGraphResolutionKind;
 use biome_service::workspace::{
     OpenProjectParams, ScanKind, ScanProjectParams, UpdateSettingsParams,
 };
@@ -405,6 +406,10 @@ pub(crate) trait CommandRunner {
             self.minimal_scan_kind(),
         );
 
+        // Scan the project
+        let scan_kind =
+            execution.compute_scan_kind(paths.as_slice(), working_dir.as_path(), scan_kind);
+
         // Update the settings of the project
         let result = workspace.update_settings(UpdateSettingsParams {
             project_key: open_project_result.project_key,
@@ -414,6 +419,7 @@ pub(crate) trait CommandRunner {
                 .into_iter()
                 .map(|(path, config)| (BiomePath::from(path), config))
                 .collect(),
+            module_graph_resolution_kind: ModuleGraphResolutionKind::from(&scan_kind),
         })?;
         if self.should_validate_configuration_diagnostics() {
             print_diagnostics_from_workspace_result(
@@ -423,10 +429,6 @@ pub(crate) trait CommandRunner {
             )?;
         }
 
-        // Scan the project
-        let scan_kind =
-            execution.compute_scan_kind(paths.as_slice(), working_dir.as_path(), scan_kind);
-
         let result = workspace.scan_project(ScanProjectParams {
             project_key: open_project_result.project_key,
             watch: cli_options.use_server,
diff --git a/crates/biome_cli/tests/commands/check.rs b/crates/biome_cli/tests/commands/check.rs
index b773288549..7fedfad288 100644
--- a/crates/biome_cli/tests/commands/check.rs
+++ b/crates/biome_cli/tests/commands/check.rs
@@ -645,198 +645,6 @@ fn upgrade_severity() {
     ));
 }
 
-#[test]
-fn check_only_applies_selected_rule() {
-    let fs = MemoryFileSystem::default();
-    let mut console = BufferConsole::default();
-
-    let file_path = Utf8Path::new("file.js");
-    fs.insert(file_path.into(), "debugger;\n".as_bytes());
-
-    let (_fs, result) = run_cli(
-        fs,
-        &mut console,
-        Args::from(["check", "--only=suspicious/noDebugger", file_path.as_str()].as_slice()),
-    );
-
-    assert!(result.is_err(), "run_cli returned {result:?}");
-
-    let messages = &console.out_buffer;
-
-    let error_count = messages
-        .iter()
-        .filter(|m| m.level == LogLevel::Error)
-        .filter(|m| {
-            let content = format!("{:#?}", m.content);
-            content.contains("suspicious/noDebugger")
-        })
-        .count();
-
-    assert_eq!(
-        error_count, 1,
-        "expected 1 error-level message for suspicious/noDebugger, found {error_count:?}: {messages:?}"
-    );
-}
-
-#[test]
-fn check_skip_suppresses_rule() {
-    let fs = MemoryFileSystem::default();
-    let mut console = BufferConsole::default();
-
-    let file_path = Utf8Path::new("file.js");
-    fs.insert(file_path.into(), "debugger;\n".as_bytes());
-
-    let (_fs, result) = run_cli(
-        fs,
-        &mut console,
-        Args::from(["check", "--skip=suspicious/noDebugger", file_path.as_str()].as_slice()),
-    );
-
-    assert!(result.is_ok(), "run_cli returned {result:?}");
-
-    let messages = &console.out_buffer;
-    let error_count = messages
-        .iter()
-        .filter(|m| m.level == LogLevel::Error)
-        .filter(|m| {
-            let content = format!("{:#?}", m.content);
-            content.contains("suspicious/noDebugger")
-        })
-        .count();
-
-    assert_eq!(
-        error_count, 0,
-        "expected no suspicious/noDebugger errors when skipped, found {error_count:?}: {messages:?}"
-    );
-}
-
-#[test]
-fn check_skip_takes_precedence_over_only() {
-    let fs = MemoryFileSystem::default();
-    let mut console = BufferConsole::default();
-
-    let file_path = Utf8Path::new("file.js");
-    fs.insert(file_path.into(), "debugger;\n".as_bytes());
-
-    let (_fs, result) = run_cli(
-        fs,
-        &mut console,
-        Args::from(
-            [
-                "check",
-                "--only=suspicious/noDebugger",
-                "--skip=suspicious/noDebugger",
-                file_path.as_str(),
-            ]
-            .as_slice(),
-        ),
-    );
-
-    assert!(result.is_ok(), "run_cli returned {result:?}");
-
-    let messages = &console.out_buffer;
-    let error_count = messages
-        .iter()
-        .filter(|m| m.level == LogLevel::Error)
-        .filter(|m| {
-            let content = format!("{:#?}", m.content);
-            content.contains("suspicious/noDebugger")
-        })
-        .count();
-
-    assert_eq!(
-        error_count, 0,
-        "expected skip to win over only, but found {error_count:?} error messages: {messages:?}"
-    );
-}
-
-#[test]
-fn check_only_assist_action() {
-    let fs = MemoryFileSystem::default();
-    let mut console = BufferConsole::default();
-
-    let file_path = Utf8Path::new("file.js");
-    fs.insert(
-        file_path.into(),
-        "import b from \"b\";\nimport a from \"a\";\n".as_bytes(),
-    );
-
-    let (_fs, result) = run_cli(
-        fs,
-        &mut console,
-        Args::from(
-            [
-                "check",
-                "--assist-enabled=true",
-                "--only=assist/source/organizeImports",
-                file_path.as_str(),
-            ]
-            .as_slice(),
-        ),
-    );
-
-    assert!(result.is_err(), "run_cli returned {result:?}");
-
-    let messages = &console.out_buffer;
-    let error_count = messages
-        .iter()
-        .filter(|m| m.level == LogLevel::Error)
-        .filter(|m| {
-            let content = format!("{:#?}", m.content);
-            content.contains("assist/source/organizeImports")
-        })
-        .count();
-
-    assert_eq!(
-        error_count, 1,
-        "expected assist action to be enforced when selected with --only, found {error_count:?}: {messages:?}"
-    );
-}
-
-#[test]
-fn check_skip_assist_action_and_group() {
-    let fs = MemoryFileSystem::default();
-    let mut console = BufferConsole::default();
-
-    let file_path = Utf8Path::new("file.js");
-    fs.insert(
-        file_path.into(),
-        "import b from \"b\";\nimport a from \"a\";\n".as_bytes(),
-    );
-
-    let (_fs, result) = run_cli(
-        fs,
-        &mut console,
-        Args::from(
-            [
-                "check",
-                "--assist-enabled=true",
-                "--only=assist/source",
-                "--skip=assist/source/organizeImports",
-                file_path.as_str(),
-            ]
-            .as_slice(),
-        ),
-    );
-
-    assert!(result.is_ok(), "run_cli returned {result:?}");
-
-    let messages = &console.out_buffer;
-    let error_count = messages
-        .iter()
-        .filter(|m| m.level == LogLevel::Error)
-        .filter(|m| {
-            let content = format!("{:#?}", m.content);
-            content.contains("assist/source/organizeImports")
-        })
-        .count();
-
-    assert_eq!(
-        error_count, 0,
-        "expected assist action to be skipped when group and action are both provided, found {error_count:?}: {messages:?}"
-    );
-}
-
 #[test]
 fn no_lint_when_file_is_ignored() {
     let fs = MemoryFileSystem::default();
diff --git a/crates/biome_cli/tests/commands/ci.rs b/crates/biome_cli/tests/commands/ci.rs
index 60cda82dec..0e0803b7e1 100644
--- a/crates/biome_cli/tests/commands/ci.rs
+++ b/crates/biome_cli/tests/commands/ci.rs
@@ -7,7 +7,7 @@ use crate::{
     CUSTOM_FORMAT_BEFORE, FORMATTED, LINT_ERROR, PARSE_ERROR, UNFORMATTED, assert_cli_snapshot,
     run_cli,
 };
-use biome_console::{BufferConsole, LogLevel, MarkupBuf};
+use biome_console::{BufferConsole, MarkupBuf};
 use biome_fs::MemoryFileSystem;
 use bpaf::Args;
 use camino::{Utf8Path, Utf8PathBuf};
@@ -966,194 +966,3 @@ fn ci_does_not_enable_assist() {
         result,
     ));
 }
-
-#[test]
-fn ci_only_applies_selected_rule() {
-    let fs = MemoryFileSystem::default();
-    let mut console = BufferConsole::default();
-
-    let file = Utf8Path::new("file.js");
-    fs.insert(file.into(), "debugger;\n".as_bytes());
-
-    let (_fs, result) = run_cli(
-        fs,
-        &mut console,
-        Args::from(["ci", "--only=suspicious/noDebugger", file.as_str()].as_slice()),
-    );
-
-    assert!(result.is_err(), "run_cli returned {result:?}");
-
-    let messages = &console.out_buffer;
-    let error_count = messages
-        .iter()
-        .filter(|m| m.level == LogLevel::Error)
-        .filter(|m| {
-            let content = format!("{:#?}", m.content);
-            content.contains("suspicious/noDebugger")
-        })
-        .count();
-
-    assert_eq!(
-        error_count, 1,
-        "expected 1 suspicious/noDebugger error, found {error_count:?}: {messages:?}"
-    );
-}
-
-#[test]
-fn ci_skip_suppresses_rule() {
-    let fs = MemoryFileSystem::default();
-    let mut console = BufferConsole::default();
-
-    let file = Utf8Path::new("file.js");
-    fs.insert(file.into(), "debugger;\n".as_bytes());
-
-    let (_fs, result) = run_cli(
-        fs,
-        &mut console,
-        Args::from(["ci", "--skip=suspicious/noDebugger", file.as_str()].as_slice()),
-    );
-
-    assert!(result.is_ok(), "run_cli returned {result:?}");
-
-    let messages = &console.out_buffer;
-    let error_count = messages
-        .iter()
-        .filter(|m| m.level == LogLevel::Error)
-        .filter(|m| {
-            let content = format!("{:#?}", m.content);
-            content.contains("suspicious/noDebugger")
-        })
-        .count();
-
-    assert_eq!(
-        error_count, 0,
-        "expected suspicious/noDebugger to be skipped, found {error_count:?}: {messages:?}"
-    );
-}
-
-#[test]
-fn ci_skip_takes_precedence_over_only() {
-    let fs = MemoryFileSystem::default();
-    let mut console = BufferConsole::default();
-
-    let file = Utf8Path::new("file.js");
-    fs.insert(file.into(), "debugger;\n".as_bytes());
-
-    let (_fs, result) = run_cli(
-        fs,
-        &mut console,
-        Args::from(
-            [
-                "ci",
-                "--only=suspicious/noDebugger",
-                "--skip=suspicious/noDebugger",
-                file.as_str(),
-            ]
-            .as_slice(),
-        ),
-    );
-
-    assert!(result.is_ok(), "run_cli returned {result:?}");
-
-    let messages = &console.out_buffer;
-    let error_count = messages
-        .iter()
-        .filter(|m| m.level == LogLevel::Error)
-        .filter(|m| {
-            let content = format!("{:#?}", m.content);
-            content.contains("suspicious/noDebugger")
-        })
-        .count();
-
-    assert_eq!(
-        error_count, 0,
-        "expected skip to override only, found {error_count:?}: {messages:?}"
-    );
-}
-
-#[test]
-fn ci_only_assist_action() {
-    let fs = MemoryFileSystem::default();
-    let mut console = BufferConsole::default();
-
-    let file = Utf8Path::new("file.js");
-    fs.insert(
-        file.into(),
-        "import b from \"b\";\nimport a from \"a\";\n".as_bytes(),
-    );
-
-    let (_fs, result) = run_cli(
-        fs,
-        &mut console,
-        Args::from(
-            [
-                "ci",
-                "--assist-enabled=true",
-                "--only=assist/source/organizeImports",
-                file.as_str(),
-            ]
-            .as_slice(),
-        ),
-    );
-
-    assert!(result.is_err(), "run_cli returned {result:?}");
-
-    let messages = &console.out_buffer;
-    let error_count = messages
-        .iter()
-        .filter(|m| m.level == LogLevel::Error)
-        .filter(|m| {
-            let content = format!("{:#?}", m.content);
-            content.contains("assist/source/organizeImports")
-        })
-        .count();
-
-    assert_eq!(
-        error_count, 1,
-        "expected assist action to be enforced when selected with --only, found {error_count:?}: {messages:?}"
-    );
-}
-
-#[test]
-fn ci_skip_assist_action_and_group() {
-    let fs = MemoryFileSystem::default();
-    let mut console = BufferConsole::default();
-
-    let file = Utf8Path::new("file.js");
-    fs.insert(
-        file.into(),
-        "import b from \"b\";\nimport a from \"a\";\n".as_bytes(),
-    );
-
-    let (_fs, result) = run_cli(
-        fs,
-        &mut console,
-        Args::from(
-            [
-                "ci",
-                "--assist-enabled=true",
-                "--only=assist/source",
-                "--skip=assist/source/organizeImports",
-                file.as_str(),
-            ]
-            .as_slice(),
-        ),
-    );
-
-    assert!(result.is_ok(), "run_cli returned {result:?}");
-
-    let messages = &console.out_buffer;
-    let error_count = messages
-        .iter()
-        .filter(|m| m.level == LogLevel::Error)
-        .filter(|m| {
-            let content = format!("{:#?}", m.content);
-            content.contains("assist/source/organizeImports")
-        })
-        .count();
-
-    assert_eq!(
-        error_count, 0,
-        "expected assist action to be skipped when group and action are both provided, found {error_count:?}: {messages:?}"
-    );
-}
diff --git a/crates/biome_cli/tests/snapshots/main_commands_check/check_help.snap b/crates/biome_cli/tests/snapshots/main_commands_check/check_help.snap
index a6dbc1d929..2ae8686348 100644
--- a/crates/biome_cli/tests/snapshots/main_commands_check/check_help.snap
+++ b/crates/biome_cli/tests/snapshots/main_commands_check/check_help.snap
@@ -8,8 +8,7 @@ expression: redactor(content)
 Runs formatter, linter and import sorting to the requested files.
 
 Usage: check [--write] [--unsafe] [--assist-enabled=<true|false>] [--enforce-assist=<true|false>] [
---format-with-errors=<true|false>] [--staged] [--changed] [--since=REF] [--only=
-<GROUP|RULE|DOMAIN|ACTION>]... [--skip=<GROUP|RULE|DOMAIN|ACTION>]... [PATH]...
+--format-with-errors=<true|false>] [--staged] [--changed] [--since=REF] [PATH]...
 
 Options that changes how the JSON parser behaves
         --json-parse-allow-comments=<true|false>  Allow parsing comments in `.json` files
@@ -291,19 +290,6 @@ Available options:
         --since=REF           Use this to specify the base branch to compare against when you're
                               using the --changed flag and the `defaultBranch` is not set in your
                               `biome.json`
-        --only=<GROUP|RULE|DOMAIN|ACTION>  Run only the given lint rule, assist action, group of
-                              rules and actions, or domain. If the severity level of a rule is
-                              `off`, then the severity level of the rule is set to `error` if it is
-                              a recommended rule or `warn` otherwise.
-                              Example:
-                              ```shell biome check --only=correctness/noUnusedVariables
-                              --only=suspicious --only=test ```
-        --skip=<GROUP|RULE|DOMAIN|ACTION>  Skip the given lint rule, assist action, group of rules
-                              and actions, or domain by setting the severity level of the rules to
-                              `off`. This option takes precedence over `--only`.
-                              Example:
-                              ```shell biome check --skip=correctness/noUnusedVariables
-                              --skip=suspicious --skip=project ```
     -h, --help                Prints help information
 
 ```
diff --git a/crates/biome_cli/tests/snapshots/main_commands_ci/ci_help.snap b/crates/biome_cli/tests/snapshots/main_commands_ci/ci_help.snap
index 1e77fa90be..a3f029cf28 100644
--- a/crates/biome_cli/tests/snapshots/main_commands_ci/ci_help.snap
+++ b/crates/biome_cli/tests/snapshots/main_commands_ci/ci_help.snap
@@ -10,7 +10,7 @@ Files won't be modified, the command is a read-only operation.
 
 Usage: ci [--formatter-enabled=<true|false>] [--linter-enabled=<true|false>] [--assist-enabled=
 <true|false>] [--format-with-errors=<true|false>] [--enforce-assist=<true|false>] [--changed] [
---since=REF] [--only=<GROUP|RULE|DOMAIN|ACTION>]... [--skip=<GROUP|RULE|DOMAIN|ACTION>]... [PATH]...
+--since=REF] [PATH]...
 
 Options that changes how the JSON parser behaves
         --json-parse-allow-comments=<true|false>  Allow parsing comments in `.json` files
@@ -275,19 +275,6 @@ Available options:
         --threads=NUMBER      The number of threads to use. This is useful when running the CLI in
                               environments with limited resource, for example CI.
                               [env:BIOME_THREADS: N/A]
-        --only=<GROUP|RULE|DOMAIN|ACTION>  Run only the given lint rule, assist action, group of
-                              rules and actions, or domain. If the severity level of a rule is
-                              `off`, then the severity level of the rule is set to `error` if it is
-                              a recommended rule or `warn` otherwise.
-                              Example:
-                              ```shell biome ci --only=correctness/noUnusedVariables
-                              --only=suspicious --only=test ```
-        --skip=<GROUP|RULE|DOMAIN|ACTION>  Skip the given lint rule, assist action, group of rules
-                              and actions, or domain by setting the severity level of the rules to
-                              `off`. This option takes precedence over `--only`.
-                              Example:
-                              ```shell biome ci --skip=correctness/noUnusedVariables
-                              --skip=suspicious --skip=project ```
     -h, --help                Prints help information
 
 ```
diff --git a/crates/biome_cli/tests/snapshots/main_commands_lint/lint_help.snap b/crates/biome_cli/tests/snapshots/main_commands_lint/lint_help.snap
index f7e597ff47..69fc98f475 100644
--- a/crates/biome_cli/tests/snapshots/main_commands_lint/lint_help.snap
+++ b/crates/biome_cli/tests/snapshots/main_commands_lint/lint_help.snap
@@ -7,8 +7,8 @@ expression: redactor(content)
 ```block
 Run various checks on a set of files.
 
-Usage: lint [--write] [--unsafe] [--suppress] [--reason=STRING] [--only=<GROUP|RULE|DOMAIN|ACTION>
-]... [--skip=<GROUP|RULE|DOMAIN|ACTION>]... [--staged] [--changed] [--since=REF] [PATH]...
+Usage: lint [--write] [--unsafe] [--suppress] [--reason=STRING] [--only=<GROUP|RULE|DOMAIN>]... [
+--skip=<GROUP|RULE|DOMAIN>]... [--staged] [--changed] [--since=REF] [PATH]...
 
 Options that changes how the JSON parser behaves
         --json-parse-allow-comments=<true|false>  Allow parsing comments in `.json` files
@@ -102,16 +102,15 @@ Available options:
         --suppress            Fixes lint rule violations with comment suppressions instead of using
                               a rule code action (fix)
         --reason=STRING       Explanation for suppressing diagnostics with `--suppress`
-        --only=<GROUP|RULE|DOMAIN|ACTION>  Run only the given lint rule, assist action, group of
-                              rules and actions, or domain. If the severity level of a rule is
-                              `off`, then the severity level of the rule is set to `error` if it is
-                              a recommended rule or `warn` otherwise.
+        --only=<GROUP|RULE|DOMAIN>  Run only the given rule, group of rules or domain. If the
+                              severity level of a rule is `off`, then the severity level of the rule
+                              is set to `error` if it is a recommended rule or `warn` otherwise.
                               Example:
                               ```shell biome lint --only=correctness/noUnusedVariables
                               --only=suspicious --only=test ```
-        --skip=<GROUP|RULE|DOMAIN|ACTION>  Skip the given lint rule, assist action, group of rules
-                              and actions, or domain by setting the severity level of the rules to
-                              `off`. This option takes precedence over `--only`.
+        --skip=<GROUP|RULE|DOMAIN>  Skip the given rule, group of rules or domain by setting the
+                              severity level of the rules to `off`. This option takes precedence
+                              over `--only`.
                               Example:
                               ```shell biome lint --skip=correctness/noUnusedVariables
                               --skip=suspicious --skip=project ```
diff --git a/crates/biome_configuration/src/analyzer/linter/rules.rs b/crates/biome_configuration/src/analyzer/linter/rules.rs
index 45e4084245..083a833f8f 100644
--- a/crates/biome_configuration/src/analyzer/linter/rules.rs
+++ b/crates/biome_configuration/src/analyzer/linter/rules.rs
@@ -2072,7 +2072,7 @@ impl Rules {
 #[cfg_attr(feature = "schema", derive(JsonSchema))]
 #[serde(rename_all = "camelCase", default, deny_unknown_fields)]
 #[doc = r" A list of rules that belong to this group"]
-pub struct A11y { # [doc = r" Enables the recommended rules for this group"] # [serde (skip_serializing_if = "Option::is_none")] pub recommended : Option < bool > , # [doc = "Enforce that the accesskey attribute is not used on any HTML element.\nSee <https://biomejs.dev/linter/rules/no-access-key>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_access_key : Option < RuleFixConfiguration < biome_rule_options :: no_access_key :: NoAccessKeyOptions >> , # [doc = "Enforce that aria-hidden=\"true\" is not set on focusable elements.\nSee <https://biomejs.dev/linter/rules/no-aria-hidden-on-focusable>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_aria_hidden_on_focusable : Option < RuleFixConfiguration < biome_rule_options :: no_aria_hidden_on_focusable :: NoAriaHiddenOnFocusableOptions >> , # [doc = "Enforce that elements that do not support ARIA roles, states, and properties do not have those attributes.\nSee <https://biomejs.dev/linter/rules/no-aria-unsupported-elements>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_aria_unsupported_elements : Option < RuleFixConfiguration < biome_rule_options :: no_aria_unsupported_elements :: NoAriaUnsupportedElementsOptions >> , # [doc = "Enforce that autoFocus prop is not used on elements.\nSee <https://biomejs.dev/linter/rules/no-autofocus>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_autofocus : Option < RuleFixConfiguration < biome_rule_options :: no_autofocus :: NoAutofocusOptions >> , # [doc = "Enforces that no distracting elements are used.\nSee <https://biomejs.dev/linter/rules/no-distracting-elements>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_distracting_elements : Option < RuleFixConfiguration < biome_rule_options :: no_distracting_elements :: NoDistractingElementsOptions >> , # [doc = "The scope prop should be used only on \\<th> elements.\nSee <https://biomejs.dev/linter/rules/no-header-scope>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_header_scope : Option < RuleFixConfiguration < biome_rule_options :: no_header_scope :: NoHeaderScopeOptions >> , # [doc = "Enforce that non-interactive ARIA roles are not assigned to interactive HTML elements.\nSee <https://biomejs.dev/linter/rules/no-interactive-element-to-noninteractive-role>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_interactive_element_to_noninteractive_role : Option < RuleFixConfiguration < biome_rule_options :: no_interactive_element_to_noninteractive_role :: NoInteractiveElementToNoninteractiveRoleOptions >> , # [doc = "Enforce that a label element or component has a text label and an associated input.\nSee <https://biomejs.dev/linter/rules/no-label-without-control>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_label_without_control : Option < RuleConfiguration < biome_rule_options :: no_label_without_control :: NoLabelWithoutControlOptions >> , # [doc = "Disallow use event handlers on non-interactive elements.\nSee <https://biomejs.dev/linter/rules/no-noninteractive-element-interactions>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_noninteractive_element_interactions : Option < RuleConfiguration < biome_rule_options :: no_noninteractive_element_interactions :: NoNoninteractiveElementInteractionsOptions >> , # [doc = "Enforce that interactive ARIA roles are not assigned to non-interactive HTML elements.\nSee <https://biomejs.dev/linter/rules/no-noninteractive-element-to-interactive-role>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_noninteractive_element_to_interactive_role : Option < RuleFixConfiguration < biome_rule_options :: no_noninteractive_element_to_interactive_role :: NoNoninteractiveElementToInteractiveRoleOptions >> , # [doc = "Enforce that tabIndex is not assigned to non-interactive HTML elements.\nSee <https://biomejs.dev/linter/rules/no-noninteractive-tabindex>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_noninteractive_tabindex : Option < RuleFixConfiguration < biome_rule_options :: no_noninteractive_tabindex :: NoNoninteractiveTabindexOptions >> , # [doc = "Prevent the usage of positive integers on tabindex attribute.\nSee <https://biomejs.dev/linter/rules/no-positive-tabindex>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_positive_tabindex : Option < RuleFixConfiguration < biome_rule_options :: no_positive_tabindex :: NoPositiveTabindexOptions >> , # [doc = "Enforce img alt prop does not contain the word \"image\", \"picture\", or \"photo\".\nSee <https://biomejs.dev/linter/rules/no-redundant-alt>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_redundant_alt : Option < RuleConfiguration < biome_rule_options :: no_redundant_alt :: NoRedundantAltOptions >> , # [doc = "Enforce explicit role property is not the same as implicit/default role property on an element.\nSee <https://biomejs.dev/linter/rules/no-redundant-roles>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_redundant_roles : Option < RuleFixConfiguration < biome_rule_options :: no_redundant_roles :: NoRedundantRolesOptions >> , # [doc = "Enforce that static, visible elements (such as \\<div>) that have click handlers use the valid role attribute.\nSee <https://biomejs.dev/linter/rules/no-static-element-interactions>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_static_element_interactions : Option < RuleConfiguration < biome_rule_options :: no_static_element_interactions :: NoStaticElementInteractionsOptions >> , # [doc = "Enforces the usage of the title element for the svg element.\nSee <https://biomejs.dev/linter/rules/no-svg-without-title>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_svg_without_title : Option < RuleConfiguration < biome_rule_options :: no_svg_without_title :: NoSvgWithoutTitleOptions >> , # [doc = "Enforce that all elements that require alternative text have meaningful information to relay back to the end user.\nSee <https://biomejs.dev/linter/rules/use-alt-text>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_alt_text : Option < RuleConfiguration < biome_rule_options :: use_alt_text :: UseAltTextOptions >> , # [doc = "Enforce that anchors have content and that the content is accessible to screen readers.\nSee <https://biomejs.dev/linter/rules/use-anchor-content>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_anchor_content : Option < RuleFixConfiguration < biome_rule_options :: use_anchor_content :: UseAnchorContentOptions >> , # [doc = "Enforce that tabIndex is assigned to non-interactive HTML elements with aria-activedescendant.\nSee <https://biomejs.dev/linter/rules/use-aria-activedescendant-with-tabindex>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_aria_activedescendant_with_tabindex : Option < RuleFixConfiguration < biome_rule_options :: use_aria_activedescendant_with_tabindex :: UseAriaActivedescendantWithTabindexOptions >> , # [doc = "Enforce that elements with ARIA roles must have all required ARIA attributes for that role.\nSee <https://biomejs.dev/linter/rules/use-aria-props-for-role>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_aria_props_for_role : Option < RuleConfiguration < biome_rule_options :: use_aria_props_for_role :: UseAriaPropsForRoleOptions >> , # [doc = "Enforce that ARIA properties are valid for the roles that are supported by the element.\nSee <https://biomejs.dev/linter/rules/use-aria-props-supported-by-role>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_aria_props_supported_by_role : Option < RuleConfiguration < biome_rule_options :: use_aria_props_supported_by_role :: UseAriaPropsSupportedByRoleOptions >> , # [doc = "Enforces the usage and validity of the attribute type for the element button.\nSee <https://biomejs.dev/linter/rules/use-button-type>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_button_type : Option < RuleConfiguration < biome_rule_options :: use_button_type :: UseButtonTypeOptions >> , # [doc = "Elements with an interactive role and interaction handlers must be focusable.\nSee <https://biomejs.dev/linter/rules/use-focusable-interactive>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_focusable_interactive : Option < RuleConfiguration < biome_rule_options :: use_focusable_interactive :: UseFocusableInteractiveOptions >> , # [doc = "Disallow a missing generic family keyword within font families.\nSee <https://biomejs.dev/linter/rules/use-generic-font-names>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_generic_font_names : Option < RuleConfiguration < biome_rule_options :: use_generic_font_names :: UseGenericFontNamesOptions >> , # [doc = "Enforce that heading elements (h1, h2, etc.) have content and that the content is accessible to screen readers. Accessible means that it is not hidden using the aria-hidden prop.\nSee <https://biomejs.dev/linter/rules/use-heading-content>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_heading_content : Option < RuleConfiguration < biome_rule_options :: use_heading_content :: UseHeadingContentOptions >> , # [doc = "Enforce that html element has lang attribute.\nSee <https://biomejs.dev/linter/rules/use-html-lang>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_html_lang : Option < RuleConfiguration < biome_rule_options :: use_html_lang :: UseHtmlLangOptions >> , # [doc = "Enforces the usage of the attribute title for the element iframe.\nSee <https://biomejs.dev/linter/rules/use-iframe-title>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_iframe_title : Option < RuleConfiguration < biome_rule_options :: use_iframe_title :: UseIframeTitleOptions >> , # [doc = "Enforce onClick is accompanied by at least one of the following: onKeyUp, onKeyDown, onKeyPress.\nSee <https://biomejs.dev/linter/rules/use-key-with-click-events>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_key_with_click_events : Option < RuleConfiguration < biome_rule_options :: use_key_with_click_events :: UseKeyWithClickEventsOptions >> , # [doc = "Enforce onMouseOver / onMouseOut are accompanied by onFocus / onBlur.\nSee <https://biomejs.dev/linter/rules/use-key-with-mouse-events>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_key_with_mouse_events : Option < RuleConfiguration < biome_rule_options :: use_key_with_mouse_events :: UseKeyWithMouseEventsOptions >> , # [doc = "Enforces that audio and video elements must have a track for captions.\nSee <https://biomejs.dev/linter/rules/use-media-caption>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_media_caption : Option < RuleConfiguration < biome_rule_options :: use_media_caption :: UseMediaCaptionOptions >> , # [doc = "It detects the use of role attributes in JSX elements and suggests using semantic elements instead.\nSee <https://biomejs.dev/linter/rules/use-semantic-elements>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_semantic_elements : Option < RuleConfiguration < biome_rule_options :: use_semantic_elements :: UseSemanticElementsOptions >> , # [doc = "Enforce that all anchors are valid, and they are navigable elements.\nSee <https://biomejs.dev/linter/rules/use-valid-anchor>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_valid_anchor : Option < RuleConfiguration < biome_rule_options :: use_valid_anchor :: UseValidAnchorOptions >> , # [doc = "Ensures that ARIA properties aria-* are all valid.\nSee <https://biomejs.dev/linter/rules/use-valid-aria-props>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_valid_aria_props : Option < RuleFixConfiguration < biome_rule_options :: use_valid_aria_props :: UseValidAriaPropsOptions >> , # [doc = "Elements with ARIA roles must use a valid, non-abstract ARIA role.\nSee <https://biomejs.dev/linter/rules/use-valid-aria-role>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_valid_aria_role : Option < RuleFixConfiguration < biome_rule_options :: use_valid_aria_role :: UseValidAriaRoleOptions >> , # [doc = "Enforce that ARIA state and property values are valid.\nSee <https://biomejs.dev/linter/rules/use-valid-aria-values>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_valid_aria_values : Option < RuleConfiguration < biome_rule_options :: use_valid_aria_values :: UseValidAriaValuesOptions >> , # [doc = "Use valid values for the autocomplete attribute on input elements.\nSee <https://biomejs.dev/linter/rules/use-valid-autocomplete>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_valid_autocomplete : Option < RuleConfiguration < biome_rule_options :: use_valid_autocomplete :: UseValidAutocompleteOptions >> , # [doc = "Ensure that the attribute passed to the lang attribute is a correct ISO language and/or country.\nSee <https://biomejs.dev/linter/rules/use-valid-lang>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_valid_lang : Option < RuleConfiguration < biome_rule_options :: use_valid_lang :: UseValidLangOptions >> }
+pub struct A11y { # [doc = r" Enables the recommended rules for this group"] # [serde (skip_serializing_if = "Option::is_none")] pub recommended : Option < bool > , # [doc = "Enforce that the accesskey attribute is not used on any HTML element.\nSee <https://biomejs.dev/linter/rules/no-access-key>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_access_key : Option < RuleFixConfiguration < biome_rule_options :: no_access_key :: NoAccessKeyOptions >> , # [doc = "Enforce that aria-hidden=\"true\" is not set on focusable elements.\nSee <https://biomejs.dev/linter/rules/no-aria-hidden-on-focusable>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_aria_hidden_on_focusable : Option < RuleFixConfiguration < biome_rule_options :: no_aria_hidden_on_focusable :: NoAriaHiddenOnFocusableOptions >> , # [doc = "Enforce that elements that do not support ARIA roles, states, and properties do not have those attributes.\nSee <https://biomejs.dev/linter/rules/no-aria-unsupported-elements>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_aria_unsupported_elements : Option < RuleFixConfiguration < biome_rule_options :: no_aria_unsupported_elements :: NoAriaUnsupportedElementsOptions >> , # [doc = "Enforce that the autofocus attribute is not used on elements.\nSee <https://biomejs.dev/linter/rules/no-autofocus>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_autofocus : Option < RuleFixConfiguration < biome_rule_options :: no_autofocus :: NoAutofocusOptions >> , # [doc = "Enforces that no distracting elements are used.\nSee <https://biomejs.dev/linter/rules/no-distracting-elements>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_distracting_elements : Option < RuleFixConfiguration < biome_rule_options :: no_distracting_elements :: NoDistractingElementsOptions >> , # [doc = "The scope prop should be used only on \\<th> elements.\nSee <https://biomejs.dev/linter/rules/no-header-scope>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_header_scope : Option < RuleFixConfiguration < biome_rule_options :: no_header_scope :: NoHeaderScopeOptions >> , # [doc = "Enforce that non-interactive ARIA roles are not assigned to interactive HTML elements.\nSee <https://biomejs.dev/linter/rules/no-interactive-element-to-noninteractive-role>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_interactive_element_to_noninteractive_role : Option < RuleFixConfiguration < biome_rule_options :: no_interactive_element_to_noninteractive_role :: NoInteractiveElementToNoninteractiveRoleOptions >> , # [doc = "Enforce that a label element or component has a text label and an associated input.\nSee <https://biomejs.dev/linter/rules/no-label-without-control>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_label_without_control : Option < RuleConfiguration < biome_rule_options :: no_label_without_control :: NoLabelWithoutControlOptions >> , # [doc = "Disallow use event handlers on non-interactive elements.\nSee <https://biomejs.dev/linter/rules/no-noninteractive-element-interactions>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_noninteractive_element_interactions : Option < RuleConfiguration < biome_rule_options :: no_noninteractive_element_interactions :: NoNoninteractiveElementInteractionsOptions >> , # [doc = "Enforce that interactive ARIA roles are not assigned to non-interactive HTML elements.\nSee <https://biomejs.dev/linter/rules/no-noninteractive-element-to-interactive-role>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_noninteractive_element_to_interactive_role : Option < RuleFixConfiguration < biome_rule_options :: no_noninteractive_element_to_interactive_role :: NoNoninteractiveElementToInteractiveRoleOptions >> , # [doc = "Enforce that tabIndex is not assigned to non-interactive HTML elements.\nSee <https://biomejs.dev/linter/rules/no-noninteractive-tabindex>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_noninteractive_tabindex : Option < RuleFixConfiguration < biome_rule_options :: no_noninteractive_tabindex :: NoNoninteractiveTabindexOptions >> , # [doc = "Prevent the usage of positive integers on tabindex attribute.\nSee <https://biomejs.dev/linter/rules/no-positive-tabindex>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_positive_tabindex : Option < RuleFixConfiguration < biome_rule_options :: no_positive_tabindex :: NoPositiveTabindexOptions >> , # [doc = "Enforce img alt prop does not contain the word \"image\", \"picture\", or \"photo\".\nSee <https://biomejs.dev/linter/rules/no-redundant-alt>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_redundant_alt : Option < RuleConfiguration < biome_rule_options :: no_redundant_alt :: NoRedundantAltOptions >> , # [doc = "Enforce explicit role property is not the same as implicit/default role property on an element.\nSee <https://biomejs.dev/linter/rules/no-redundant-roles>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_redundant_roles : Option < RuleFixConfiguration < biome_rule_options :: no_redundant_roles :: NoRedundantRolesOptions >> , # [doc = "Enforce that static, visible elements (such as \\<div>) that have click handlers use the valid role attribute.\nSee <https://biomejs.dev/linter/rules/no-static-element-interactions>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_static_element_interactions : Option < RuleConfiguration < biome_rule_options :: no_static_element_interactions :: NoStaticElementInteractionsOptions >> , # [doc = "Enforces the usage of the title element for the svg element.\nSee <https://biomejs.dev/linter/rules/no-svg-without-title>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_svg_without_title : Option < RuleConfiguration < biome_rule_options :: no_svg_without_title :: NoSvgWithoutTitleOptions >> , # [doc = "Enforce that all elements that require alternative text have meaningful information to relay back to the end user.\nSee <https://biomejs.dev/linter/rules/use-alt-text>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_alt_text : Option < RuleConfiguration < biome_rule_options :: use_alt_text :: UseAltTextOptions >> , # [doc = "Enforce that anchors have content and that the content is accessible to screen readers.\nSee <https://biomejs.dev/linter/rules/use-anchor-content>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_anchor_content : Option < RuleFixConfiguration < biome_rule_options :: use_anchor_content :: UseAnchorContentOptions >> , # [doc = "Enforce that tabIndex is assigned to non-interactive HTML elements with aria-activedescendant.\nSee <https://biomejs.dev/linter/rules/use-aria-activedescendant-with-tabindex>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_aria_activedescendant_with_tabindex : Option < RuleFixConfiguration < biome_rule_options :: use_aria_activedescendant_with_tabindex :: UseAriaActivedescendantWithTabindexOptions >> , # [doc = "Enforce that elements with ARIA roles must have all required ARIA attributes for that role.\nSee <https://biomejs.dev/linter/rules/use-aria-props-for-role>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_aria_props_for_role : Option < RuleConfiguration < biome_rule_options :: use_aria_props_for_role :: UseAriaPropsForRoleOptions >> , # [doc = "Enforce that ARIA properties are valid for the roles that are supported by the element.\nSee <https://biomejs.dev/linter/rules/use-aria-props-supported-by-role>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_aria_props_supported_by_role : Option < RuleConfiguration < biome_rule_options :: use_aria_props_supported_by_role :: UseAriaPropsSupportedByRoleOptions >> , # [doc = "Enforces the usage and validity of the attribute type for the element button.\nSee <https://biomejs.dev/linter/rules/use-button-type>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_button_type : Option < RuleConfiguration < biome_rule_options :: use_button_type :: UseButtonTypeOptions >> , # [doc = "Elements with an interactive role and interaction handlers must be focusable.\nSee <https://biomejs.dev/linter/rules/use-focusable-interactive>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_focusable_interactive : Option < RuleConfiguration < biome_rule_options :: use_focusable_interactive :: UseFocusableInteractiveOptions >> , # [doc = "Disallow a missing generic family keyword within font families.\nSee <https://biomejs.dev/linter/rules/use-generic-font-names>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_generic_font_names : Option < RuleConfiguration < biome_rule_options :: use_generic_font_names :: UseGenericFontNamesOptions >> , # [doc = "Enforce that heading elements (h1, h2, etc.) have content and that the content is accessible to screen readers. Accessible means that it is not hidden using the aria-hidden prop.\nSee <https://biomejs.dev/linter/rules/use-heading-content>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_heading_content : Option < RuleConfiguration < biome_rule_options :: use_heading_content :: UseHeadingContentOptions >> , # [doc = "Enforce that html element has lang attribute.\nSee <https://biomejs.dev/linter/rules/use-html-lang>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_html_lang : Option < RuleConfiguration < biome_rule_options :: use_html_lang :: UseHtmlLangOptions >> , # [doc = "Enforces the usage of the attribute title for the element iframe.\nSee <https://biomejs.dev/linter/rules/use-iframe-title>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_iframe_title : Option < RuleConfiguration < biome_rule_options :: use_iframe_title :: UseIframeTitleOptions >> , # [doc = "Enforce onClick is accompanied by at least one of the following: onKeyUp, onKeyDown, onKeyPress.\nSee <https://biomejs.dev/linter/rules/use-key-with-click-events>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_key_with_click_events : Option < RuleConfiguration < biome_rule_options :: use_key_with_click_events :: UseKeyWithClickEventsOptions >> , # [doc = "Enforce onMouseOver / onMouseOut are accompanied by onFocus / onBlur.\nSee <https://biomejs.dev/linter/rules/use-key-with-mouse-events>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_key_with_mouse_events : Option < RuleConfiguration < biome_rule_options :: use_key_with_mouse_events :: UseKeyWithMouseEventsOptions >> , # [doc = "Enforces that audio and video elements must have a track for captions.\nSee <https://biomejs.dev/linter/rules/use-media-caption>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_media_caption : Option < RuleConfiguration < biome_rule_options :: use_media_caption :: UseMediaCaptionOptions >> , # [doc = "It detects the use of role attributes in JSX elements and suggests using semantic elements instead.\nSee <https://biomejs.dev/linter/rules/use-semantic-elements>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_semantic_elements : Option < RuleConfiguration < biome_rule_options :: use_semantic_elements :: UseSemanticElementsOptions >> , # [doc = "Enforce that all anchors are valid, and they are navigable elements.\nSee <https://biomejs.dev/linter/rules/use-valid-anchor>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_valid_anchor : Option < RuleConfiguration < biome_rule_options :: use_valid_anchor :: UseValidAnchorOptions >> , # [doc = "Ensures that ARIA properties aria-* are all valid.\nSee <https://biomejs.dev/linter/rules/use-valid-aria-props>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_valid_aria_props : Option < RuleFixConfiguration < biome_rule_options :: use_valid_aria_props :: UseValidAriaPropsOptions >> , # [doc = "Elements with ARIA roles must use a valid, non-abstract ARIA role.\nSee <https://biomejs.dev/linter/rules/use-valid-aria-role>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_valid_aria_role : Option < RuleFixConfiguration < biome_rule_options :: use_valid_aria_role :: UseValidAriaRoleOptions >> , # [doc = "Enforce that ARIA state and property values are valid.\nSee <https://biomejs.dev/linter/rules/use-valid-aria-values>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_valid_aria_values : Option < RuleConfiguration < biome_rule_options :: use_valid_aria_values :: UseValidAriaValuesOptions >> , # [doc = "Use valid values for the autocomplete attribute on input elements.\nSee <https://biomejs.dev/linter/rules/use-valid-autocomplete>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_valid_autocomplete : Option < RuleConfiguration < biome_rule_options :: use_valid_autocomplete :: UseValidAutocompleteOptions >> , # [doc = "Ensure that the attribute passed to the lang attribute is a correct ISO language and/or country.\nSee <https://biomejs.dev/linter/rules/use-valid-lang>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_valid_lang : Option < RuleConfiguration < biome_rule_options :: use_valid_lang :: UseValidLangOptions >> }
 impl A11y {
     const GROUP_NAME: &'static str = "a11y";
     pub(crate) const GROUP_RULES: &'static [&'static str] = &[
diff --git a/crates/biome_configuration/src/generated/domain_selector.rs b/crates/biome_configuration/src/generated/domain_selector.rs
index 03fd957d57..62ab7397c5 100644
--- a/crates/biome_configuration/src/generated/domain_selector.rs
+++ b/crates/biome_configuration/src/generated/domain_selector.rs
@@ -25,16 +25,8 @@ static PROJECT_FILTERS: LazyLock<Vec<RuleFilter<'static>>> = LazyLock::new(|| {
         RuleFilter::Rule("correctness", "useImportExtensions"),
         RuleFilter::Rule("correctness", "useJsonImportAttributes"),
         RuleFilter::Rule("nursery", "noDeprecatedImports"),
-        RuleFilter::Rule("nursery", "noFloatingPromises"),
         RuleFilter::Rule("nursery", "noImportCycles"),
-        RuleFilter::Rule("nursery", "noMisusedPromises"),
-        RuleFilter::Rule("nursery", "noUnnecessaryConditions"),
         RuleFilter::Rule("nursery", "noUnresolvedImports"),
-        RuleFilter::Rule("nursery", "useArraySortCompare"),
-        RuleFilter::Rule("nursery", "useAwaitThenable"),
-        RuleFilter::Rule("nursery", "useExhaustiveSwitchCases"),
-        RuleFilter::Rule("nursery", "useFind"),
-        RuleFilter::Rule("nursery", "useRegexpExec"),
     ]
 });
 static QWIK_FILTERS: LazyLock<Vec<RuleFilter<'static>>> = LazyLock::new(|| {
@@ -89,6 +81,18 @@ static TEST_FILTERS: LazyLock<Vec<RuleFilter<'static>>> = LazyLock::new(|| {
 });
 static TURBOREPO_FILTERS: LazyLock<Vec<RuleFilter<'static>>> =
     LazyLock::new(|| vec![RuleFilter::Rule("nursery", "noUndeclaredEnvVars")]);
+static TYPES_FILTERS: LazyLock<Vec<RuleFilter<'static>>> = LazyLock::new(|| {
+    vec![
+        RuleFilter::Rule("nursery", "noFloatingPromises"),
+        RuleFilter::Rule("nursery", "noMisusedPromises"),
+        RuleFilter::Rule("nursery", "noUnnecessaryConditions"),
+        RuleFilter::Rule("nursery", "useArraySortCompare"),
+        RuleFilter::Rule("nursery", "useAwaitThenable"),
+        RuleFilter::Rule("nursery", "useExhaustiveSwitchCases"),
+        RuleFilter::Rule("nursery", "useFind"),
+        RuleFilter::Rule("nursery", "useRegexpExec"),
+    ]
+});
 static VUE_FILTERS: LazyLock<Vec<RuleFilter<'static>>> = LazyLock::new(|| {
     vec![
         RuleFilter::Rule("nursery", "noVueDataObjectDeclaration"),
@@ -111,6 +115,7 @@ impl DomainSelector {
             "solid" => SOLID_FILTERS.clone(),
             "test" => TEST_FILTERS.clone(),
             "turborepo" => TURBOREPO_FILTERS.clone(),
+            "types" => TYPES_FILTERS.clone(),
             "vue" => VUE_FILTERS.clone(),
             _ => unreachable!("DomainFilter::as_rule_filters: domain {} not found", self.0),
         }
@@ -131,6 +136,7 @@ impl DomainSelector {
             "turborepo" => TURBOREPO_FILTERS
                 .iter()
                 .any(|filter| filter.match_rule::<R>()),
+            "types" => TYPES_FILTERS.iter().any(|filter| filter.match_rule::<R>()),
             "vue" => VUE_FILTERS.iter().any(|filter| filter.match_rule::<R>()),
             _ => false,
         }
diff --git a/crates/biome_configuration/tests/invalid/domains.json.snap b/crates/biome_configuration/tests/invalid/domains.json.snap
index fcdb07c210..74d6a4e61e 100644
--- a/crates/biome_configuration/tests/invalid/domains.json.snap
+++ b/crates/biome_configuration/tests/invalid/domains.json.snap
@@ -24,6 +24,7 @@ domains.json:4:7 deserialize ━━━━━━━━━━━━━━━━━
   - project
   - tailwind
   - turborepo
+  - types
   
 
 
diff --git a/crates/biome_css_formatter/tests/spec_test.rs b/crates/biome_css_formatter/tests/spec_test.rs
index 55f64250c3..1c094617b1 100644
--- a/crates/biome_css_formatter/tests/spec_test.rs
+++ b/crates/biome_css_formatter/tests/spec_test.rs
@@ -43,6 +43,7 @@ pub fn run(spec_input_file: &str, _expected_file: &str, test_directory: &str, _f
             },
             workspace_directory: None,
             extended_configurations: vec![],
+            module_graph_resolution_kind: Default::default(),
         })
     };
 
diff --git a/crates/biome_graphql_formatter/tests/spec_test.rs b/crates/biome_graphql_formatter/tests/spec_test.rs
index d42215c2d2..45d136674e 100644
--- a/crates/biome_graphql_formatter/tests/spec_test.rs
+++ b/crates/biome_graphql_formatter/tests/spec_test.rs
@@ -43,6 +43,7 @@ pub fn run(spec_input_file: &str, _expected_file: &str, test_directory: &str, _f
             },
             workspace_directory: None,
             extended_configurations: vec![],
+            module_graph_resolution_kind: Default::default(),
         })
     };
 
diff --git a/crates/biome_html_analyze/src/lib.rs b/crates/biome_html_analyze/src/lib.rs
index 30850f0f47..6c2fbb2fe6 100644
--- a/crates/biome_html_analyze/src/lib.rs
+++ b/crates/biome_html_analyze/src/lib.rs
@@ -15,7 +15,7 @@ use biome_analyze::{
 };
 use biome_deserialize::TextRange;
 use biome_diagnostics::Error;
-use biome_html_syntax::HtmlLanguage;
+use biome_html_syntax::{HtmlFileSource, HtmlLanguage};
 use biome_suppression::{SuppressionDiagnostic, parse_suppression_comment};
 use std::ops::Deref;
 use std::sync::LazyLock;
@@ -35,13 +35,14 @@ pub fn analyze<'a, F, B>(
     root: &LanguageRoot<HtmlLanguage>,
     filter: AnalysisFilter,
     options: &'a AnalyzerOptions,
+    source_type: HtmlFileSource,
     emit_signal: F,
 ) -> (Option<B>, Vec<Error>)
 where
     F: FnMut(&dyn AnalyzerSignal<HtmlLanguage>) -> ControlFlow<B> + 'a,
     B: 'a,
 {
-    analyze_with_inspect_matcher(root, filter, |_| {}, options, emit_signal)
+    analyze_with_inspect_matcher(root, filter, |_| {}, options, source_type, emit_signal)
 }
 
 /// Run the analyzer on the provided `root`: this process will use the given `filter`
@@ -55,6 +56,7 @@ pub fn analyze_with_inspect_matcher<'a, V, F, B>(
     filter: AnalysisFilter,
     inspect_matcher: V,
     options: &'a AnalyzerOptions,
+    source_type: HtmlFileSource,
     mut emit_signal: F,
 ) -> (Option<B>, Vec<Error>)
 where
@@ -91,13 +93,15 @@ where
     let mut registry = RuleRegistry::builder(&filter, root);
     visit_registry(&mut registry);
 
-    let (registry, services, diagnostics, visitors) = registry.build();
+    let (registry, mut services, diagnostics, visitors) = registry.build();
 
     // Bail if we can't parse a rule option
     if !diagnostics.is_empty() {
         return (None, diagnostics);
     }
 
+    services.insert_service(source_type);
+
     let mut analyzer = biome_analyze::Analyzer::new(
         METADATA.deref(),
         biome_analyze::InspectMatcher::new(registry, inspect_matcher),
@@ -130,6 +134,7 @@ mod tests {
     use biome_diagnostics::termcolor::NoColor;
     use biome_diagnostics::{Diagnostic, DiagnosticExt, PrintDiagnostic, Severity};
     use biome_html_parser::parse_html;
+    use biome_html_syntax::HtmlFileSource;
     use biome_rowan::TextRange;
     use std::slice;
 
@@ -159,6 +164,7 @@ mod tests {
                 ..AnalysisFilter::default()
             },
             &options,
+            HtmlFileSource::html(),
             |signal| {
                 if let Some(diag) = signal.diagnostic() {
                     error_ranges.push(diag.location().span.unwrap());
diff --git a/crates/biome_html_analyze/src/lint/a11y.rs b/crates/biome_html_analyze/src/lint/a11y.rs
index e509af00bd..73946eb0f7 100644
--- a/crates/biome_html_analyze/src/lint/a11y.rs
+++ b/crates/biome_html_analyze/src/lint/a11y.rs
@@ -4,13 +4,16 @@
 
 use biome_analyze::declare_lint_group;
 pub mod no_access_key;
+pub mod no_autofocus;
 pub mod no_distracting_elements;
 pub mod no_header_scope;
 pub mod no_positive_tabindex;
+pub mod no_redundant_alt;
 pub mod no_svg_without_title;
+pub mod use_alt_text;
 pub mod use_aria_props_for_role;
 pub mod use_button_type;
 pub mod use_html_lang;
 pub mod use_iframe_title;
 pub mod use_valid_aria_role;
-declare_lint_group! { pub A11y { name : "a11y" , rules : [self :: no_access_key :: NoAccessKey , self :: no_distracting_elements :: NoDistractingElements , self :: no_header_scope :: NoHeaderScope , self :: no_positive_tabindex :: NoPositiveTabindex , self :: no_svg_without_title :: NoSvgWithoutTitle , self :: use_aria_props_for_role :: UseAriaPropsForRole , self :: use_button_type :: UseButtonType , self :: use_html_lang :: UseHtmlLang , self :: use_iframe_title :: UseIframeTitle , self :: use_valid_aria_role :: UseValidAriaRole ,] } }
+declare_lint_group! { pub A11y { name : "a11y" , rules : [self :: no_access_key :: NoAccessKey , self :: no_autofocus :: NoAutofocus , self :: no_distracting_elements :: NoDistractingElements , self :: no_header_scope :: NoHeaderScope , self :: no_positive_tabindex :: NoPositiveTabindex , self :: no_redundant_alt :: NoRedundantAlt , self :: no_svg_without_title :: NoSvgWithoutTitle , self :: use_alt_text :: UseAltText , self :: use_aria_props_for_role :: UseAriaPropsForRole , self :: use_button_type :: UseButtonType , self :: use_html_lang :: UseHtmlLang , self :: use_iframe_title :: UseIframeTitle , self :: use_valid_aria_role :: UseValidAriaRole ,] } }
diff --git a/crates/biome_html_analyze/src/lint/a11y/no_autofocus.rs b/crates/biome_html_analyze/src/lint/a11y/no_autofocus.rs
new file mode 100644
index 0000000000..116af8e8c3
--- /dev/null
+++ b/crates/biome_html_analyze/src/lint/a11y/no_autofocus.rs
@@ -0,0 +1,167 @@
+use biome_analyze::{
+    Ast, FixKind, Rule, RuleDiagnostic, RuleSource, context::RuleContext, declare_lint_rule,
+};
+use biome_console::markup;
+use biome_diagnostics::Severity;
+use biome_html_syntax::element_ext::AnyHtmlTagElement;
+use biome_html_syntax::{HtmlAttribute, HtmlElement, HtmlSelfClosingElement};
+use biome_rowan::{AstNode, BatchMutationExt};
+use biome_rule_options::no_autofocus::NoAutofocusOptions;
+
+use crate::HtmlRuleAction;
+
+declare_lint_rule! {
+    /// Enforce that the `autofocus` attribute is not used on elements.
+    ///
+    /// Autofocusing elements can cause usability issues for sighted and non-sighted users, alike.
+    /// However, the `autofocus` attribute is allowed on elements inside a `dialog` element or
+    /// elements with a `popover` attribute, as these are modal contexts where autofocus is expected.
+    ///
+    /// ## Examples
+    ///
+    /// ### Invalid
+    ///
+    /// ```html,expect_diagnostic
+    /// <input autofocus />
+    /// ```
+    ///
+    /// ```html,expect_diagnostic
+    /// <input autofocus="true" />
+    /// ```
+    ///
+    /// ```html,expect_diagnostic
+    /// <textarea autofocus>content</textarea>
+    /// ```
+    ///
+    /// ### Valid
+    ///
+    /// ```html
+    /// <input />
+    /// ```
+    ///
+    /// ```html
+    /// <div popover><input autofocus /></div>
+    /// ```
+    ///
+    /// ```html
+    /// <dialog><input autofocus /></dialog>
+    /// ```
+    ///
+    /// ## Resources
+    ///
+    /// - [WHATWG HTML Standard, The autofocus attribute](https://html.spec.whatwg.org/multipage/interaction.html#attr-fe-autofocus)
+    /// - [The accessibility of HTML 5 autofocus](https://brucelawson.co.uk/2009/the-accessibility-of-html-5-autofocus/)
+    /// - [MDN Web Docs, HTMLElement: autofocus property](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/autofocus)
+    ///
+    pub NoAutofocus {
+        version: "next",
+        name: "noAutofocus",
+        language: "html",
+        sources: &[RuleSource::EslintJsxA11y("no-autofocus").same()],
+        recommended: true,
+        severity: Severity::Error,
+        fix_kind: FixKind::Unsafe,
+    }
+}
+
+impl Rule for NoAutofocus {
+    type Query = Ast<HtmlAttribute>;
+    type State = ();
+    type Signals = Option<Self::State>;
+    type Options = NoAutofocusOptions;
+
+    fn run(ctx: &RuleContext<Self>) -> Option<Self::State> {
+        let node = ctx.query();
+
+        // Check if this is an autofocus attribute
+        if !is_autofocus_attribute(node) {
+            return None;
+        }
+
+        // Check if element is inside a dialog or has popover attribute in ancestors
+        if is_inside_allowed_context(node).unwrap_or(false) {
+            return None;
+        }
+
+        Some(())
+    }
+
+    fn diagnostic(ctx: &RuleContext<Self>, _state: &Self::State) -> Option<RuleDiagnostic> {
+        let node = ctx.query();
+        Some(RuleDiagnostic::new(
+            rule_category!(),
+            node.syntax().text_trimmed_range(),
+            markup! {
+                "Avoid the "<Emphasis>"autofocus"</Emphasis>" attribute."
+            },
+        ))
+    }
+
+    fn action(ctx: &RuleContext<Self>, _state: &Self::State) -> Option<HtmlRuleAction> {
+        let node = ctx.query();
+        let mut mutation = ctx.root().begin();
+        mutation.remove_node(node.clone());
+        Some(HtmlRuleAction::new(
+            ctx.metadata().action_category(ctx.category(), ctx.group()),
+            ctx.metadata().applicability(),
+            markup! { "Remove the "<Emphasis>"autofocus"</Emphasis>" attribute." }.to_owned(),
+            mutation,
+        ))
+    }
+}
+
+/// Check if the attribute is an autofocus attribute
+fn is_autofocus_attribute(node: &HtmlAttribute) -> bool {
+    node.name().is_ok_and(|name| {
+        name.value_token()
+            .is_ok_and(|value_token| value_token.text_trimmed().eq_ignore_ascii_case("autofocus"))
+    })
+}
+
+/// Check if the element is inside an allowed context (dialog or popover)
+///
+/// Note: We skip the first [HtmlElement] (the one containing the autofocus attribute)
+/// because we only want to check if it's *inside* a dialog/popover, not if
+/// it *is* the dialog/popover itself.
+fn is_inside_allowed_context(attr: &HtmlAttribute) -> Option<bool> {
+    let mut skip_first_element = true;
+
+    // Walk up the ancestors to find if we're inside a dialog or popover
+    for ancestor in attr.syntax().ancestors() {
+        let Some(tag_element) = get_tag_element(&ancestor) else {
+            continue;
+        };
+
+        if skip_first_element {
+            skip_first_element = false;
+            continue;
+        }
+
+        if is_dialog_or_popover(&tag_element) {
+            return Some(true);
+        }
+    }
+
+    Some(false)
+}
+
+/// Extract an [AnyHtmlTagElement] from an ancestor node
+fn get_tag_element(node: &biome_html_syntax::HtmlSyntaxNode) -> Option<AnyHtmlTagElement> {
+    HtmlElement::cast_ref(node)
+        .and_then(|e| e.opening_element().ok())
+        .map(AnyHtmlTagElement::from)
+        .or_else(|| {
+            HtmlSelfClosingElement::cast_ref(node).map(|e| AnyHtmlTagElement::from(e.clone()))
+        })
+}
+
+/// Check if the tag element is a dialog or has popover attribute
+fn is_dialog_or_popover(tag_element: &AnyHtmlTagElement) -> bool {
+    let is_dialog = tag_element
+        .name()
+        .ok()
+        .and_then(|n| n.value_token().ok())
+        .is_some_and(|token| token.text_trimmed().eq_ignore_ascii_case("dialog"));
+
+    is_dialog || tag_element.find_attribute_by_name("popover").is_some()
+}
diff --git a/crates/biome_html_analyze/src/lint/a11y/no_redundant_alt.rs b/crates/biome_html_analyze/src/lint/a11y/no_redundant_alt.rs
new file mode 100644
index 0000000000..3815042f47
--- /dev/null
+++ b/crates/biome_html_analyze/src/lint/a11y/no_redundant_alt.rs
@@ -0,0 +1,121 @@
+use biome_analyze::{
+    Ast, Rule, RuleDiagnostic, RuleSource, context::RuleContext, declare_lint_rule,
+};
+use biome_console::markup;
+use biome_diagnostics::Severity;
+use biome_html_syntax::element_ext::AnyHtmlTagElement;
+use biome_html_syntax::{AnyHtmlAttributeInitializer, HtmlFileSource};
+use biome_rowan::AstNode;
+use biome_rule_options::is_redundant_alt;
+use biome_rule_options::no_redundant_alt::NoRedundantAltOptions;
+
+declare_lint_rule! {
+    /// Enforce `img` alt prop does not contain the word "image", "picture", or "photo".
+    ///
+    /// The rule will first check if `aria-hidden` is truthy to determine whether to enforce the rule. If the image is
+    /// hidden, then the rule will always succeed.
+    ///
+    /// ## Examples
+    ///
+    /// ### Invalid
+    ///
+    /// ```html,expect_diagnostic
+    /// <img src="src" alt="photo content" />;
+    /// ```
+    ///
+    /// ```html,expect_diagnostic
+    /// <img alt="picture of cool person" aria-hidden="false" />;
+    /// ```
+    ///
+    /// ### Valid
+    ///
+    /// ```html
+    /// <>
+    /// 	<img src="src" alt="alt" />
+    /// 	<img src="bar" aria-hidden alt="Picture of me taking a photo of an image" />
+    /// </>
+    /// ```
+    ///
+    pub NoRedundantAlt {
+        version: "next",
+        name: "noRedundantAlt",
+        language: "html",
+        sources: &[RuleSource::EslintJsxA11y("img-redundant-alt").same()],
+        recommended: true,
+        severity: Severity::Error,
+    }
+}
+
+impl Rule for NoRedundantAlt {
+    type Query = Ast<AnyHtmlTagElement>;
+    type State = AnyHtmlAttributeInitializer;
+    type Signals = Option<Self::State>;
+    type Options = NoRedundantAltOptions;
+
+    fn run(ctx: &RuleContext<Self>) -> Self::Signals {
+        let node = ctx.query();
+        let file_source = ctx.source_type::<HtmlFileSource>();
+
+        let name = node.name().ok()?.value_token().ok()?;
+        if (file_source.is_html() && !name.text_trimmed().eq_ignore_ascii_case("img"))
+            || (!file_source.is_html() && name.text_trimmed() != "img")
+        {
+            return None;
+        }
+
+        let aria_hidden_attribute = node.find_attribute_by_name("aria-hidden");
+        if let Some(aria_hidden) = aria_hidden_attribute {
+            let is_false = match aria_hidden.initializer()?.value().ok()? {
+                AnyHtmlAttributeInitializer::HtmlSingleTextExpression(aria_hidden) => {
+                    aria_hidden
+                        .expression()
+                        .ok()?
+                        .html_literal_token()
+                        .ok()?
+                        .text_trimmed()
+                        == "false"
+                }
+                AnyHtmlAttributeInitializer::HtmlString(aria_hidden) => {
+                    aria_hidden.inner_string_text().ok()?.text() == "false"
+                }
+            };
+
+            if !is_false {
+                return None;
+            }
+        }
+
+        let alt = node
+            .find_attribute_by_name("alt")?
+            .initializer()?
+            .value()
+            .ok()?;
+
+        match alt {
+            AnyHtmlAttributeInitializer::HtmlSingleTextExpression(ref expression) => {
+                let value = expression.expression().ok()?.html_literal_token().ok()?;
+
+                is_redundant_alt(value.text_trimmed()).then_some(alt)
+            }
+            AnyHtmlAttributeInitializer::HtmlString(ref value) => {
+                let inner_string_text = value.inner_string_text().ok()?;
+                is_redundant_alt(inner_string_text.text()).then_some(alt)
+            }
+        }
+    }
+
+    fn diagnostic(_ctx: &RuleContext<Self>, state: &Self::State) -> Option<RuleDiagnostic> {
+        Some(
+            RuleDiagnostic::new(
+                rule_category!(),
+                state.range(),
+                markup! {
+                    "Avoid the words \"image\", \"picture\", or \"photo\" in " <Emphasis>"img"</Emphasis>" element alt text."
+                },
+            )
+            .note(markup! {
+                "Screen readers announce img elements as \"images\", so it is not necessary to redeclare this in alternative text."
+            }),
+        )
+    }
+}
diff --git a/crates/biome_html_analyze/src/lint/a11y/use_alt_text.rs b/crates/biome_html_analyze/src/lint/a11y/use_alt_text.rs
new file mode 100644
index 0000000000..e0544bb6eb
--- /dev/null
+++ b/crates/biome_html_analyze/src/lint/a11y/use_alt_text.rs
@@ -0,0 +1,242 @@
+use biome_analyze::{
+    Ast, Rule, RuleDiagnostic, RuleSource, context::RuleContext, declare_lint_rule,
+};
+use biome_console::{fmt::Display, fmt::Formatter, markup};
+use biome_diagnostics::Severity;
+use biome_html_syntax::{AnyHtmlElement, HtmlFileSource};
+use biome_rowan::{AstNode, TextRange};
+use biome_rule_options::use_alt_text::UseAltTextOptions;
+
+declare_lint_rule! {
+    /// Enforce that all elements that require alternative text have meaningful information to relay back to the end user.
+    ///
+    /// This is a critical component of accessibility for screen reader users in order for them
+    /// to understand the content's purpose on the page.
+    /// By default, this rule checks for alternative text on the following elements:
+    /// `<img>`, `<area>`, `<input type="image">`, and `<object>`.
+    ///
+    /// :::note
+    /// In `.html` files, this rule matches element names case-insensitively (e.g., `<IMG>`, `<Img>`).
+    ///
+    /// In component-based frameworks (Vue, Svelte, Astro), only lowercase element names are checked.
+    /// PascalCase variants like `<Img>` are assumed to be custom components and are ignored.
+    /// :::
+    ///
+    /// ## Examples
+    ///
+    /// ### Invalid
+    ///
+    /// ```html,expect_diagnostic
+    /// <img src="image.png" />
+    /// ```
+    ///
+    /// ```html,expect_diagnostic
+    /// <input type="image" src="image.png" />
+    /// ```
+    ///
+    /// ```html,expect_diagnostic
+    /// <area href="foo" />
+    /// ```
+    ///
+    /// ```html,expect_diagnostic
+    /// <object data="foo"></object>
+    /// ```
+    ///
+    /// ### Valid
+    ///
+    /// ```html
+    /// <img src="image.png" alt="A beautiful landscape" />
+    /// ```
+    ///
+    /// ```html
+    /// <input type="image" src="image.png" alt="Submit" />
+    /// ```
+    ///
+    /// ```html
+    /// <img src="image.png" aria-label="A beautiful landscape" />
+    /// ```
+    ///
+    /// ```html
+    /// <img src="image.png" aria-labelledby="image-description" />
+    /// ```
+    ///
+    /// ```html
+    /// <object data="foo" title="Embedded content"></object>
+    /// ```
+    ///
+    /// ```html
+    /// <!-- Decorative images can be hidden from assistive technologies -->
+    /// <img src="decorative.png" alt="" />
+    /// ```
+    ///
+    /// ```html
+    /// <img src="decorative.png" aria-hidden="true" />
+    /// ```
+    ///
+    /// ## Accessibility guidelines
+    ///
+    /// - [WCAG 1.1.1](https://www.w3.org/WAI/WCAG21/Understanding/non-text-content.html)
+    ///
+    pub UseAltText {
+        version: "next",
+        name: "useAltText",
+        language: "html",
+        sources: &[RuleSource::EslintJsxA11y("alt-text").same()],
+        recommended: true,
+        severity: Severity::Error,
+    }
+}
+
+/// The type of element being validated
+pub enum ValidatedElement {
+    Object,
+    Img,
+    Area,
+    Input,
+}
+
+impl Display for ValidatedElement {
+    fn fmt(&self, fmt: &mut Formatter) -> std::io::Result<()> {
+        match self {
+            Self::Object => fmt.write_markup(markup!(<Emphasis>"title"</Emphasis>)),
+            _ => fmt.write_markup(markup!(<Emphasis>"alt"</Emphasis>)),
+        }
+    }
+}
+
+impl Rule for UseAltText {
+    type Query = Ast<AnyHtmlElement>;
+    type State = (ValidatedElement, TextRange);
+    type Signals = Option<Self::State>;
+    type Options = UseAltTextOptions;
+
+    fn run(ctx: &RuleContext<Self>) -> Self::Signals {
+        let element = ctx.query();
+        let file_source = ctx.source_type::<HtmlFileSource>();
+
+        let element_name = element.name()?;
+        let is_html_file = file_source.is_html();
+
+        let has_alt = has_valid_alt_text(element);
+        let has_aria_label = has_valid_label(element, "aria-label");
+        let has_aria_labelledby = has_valid_label(element, "aria-labelledby");
+        let aria_hidden = is_aria_hidden(element);
+
+        let name_matches = |name: &str| -> bool {
+            if is_html_file {
+                element_name.eq_ignore_ascii_case(name)
+            } else {
+                element_name.text() == name
+            }
+        };
+
+        if name_matches("object") {
+            let has_title = has_valid_label(element, "title");
+
+            if !has_title && !has_aria_label && !has_aria_labelledby && !aria_hidden {
+                // For object elements, check if it has accessible child content
+                // In HTML, we can't easily check for accessible children, so we flag all
+                // object elements without title/aria-label/aria-labelledby
+                return Some((
+                    ValidatedElement::Object,
+                    element.syntax().text_trimmed_range(),
+                ));
+            }
+        } else if name_matches("img") {
+            if !has_alt && !has_aria_label && !has_aria_labelledby && !aria_hidden {
+                return Some((ValidatedElement::Img, element.syntax().text_trimmed_range()));
+            }
+        } else if name_matches("area") {
+            if !has_alt && !has_aria_label && !has_aria_labelledby && !aria_hidden {
+                return Some((
+                    ValidatedElement::Area,
+                    element.syntax().text_trimmed_range(),
+                ));
+            }
+        } else if name_matches("input")
+            && has_type_image_attribute(element)
+            && !has_alt
+            && !has_aria_label
+            && !has_aria_labelledby
+            && !aria_hidden
+        {
+            return Some((
+                ValidatedElement::Input,
+                element.syntax().text_trimmed_range(),
+            ));
+        }
+
+        None
+    }
+
+    fn diagnostic(_ctx: &RuleContext<Self>, state: &Self::State) -> Option<RuleDiagnostic> {
+        let (validated_element, range) = state;
+        let message = markup!(
+            "Provide a text alternative through the "{validated_element}", "<Emphasis>"aria-label"</Emphasis>", or "<Emphasis>"aria-labelledby"</Emphasis>" attribute."
+        )
+        .to_owned();
+        Some(
+            RuleDiagnostic::new(rule_category!(), range, message)
+                .note(markup! {
+                    "Meaningful alternative text on elements helps users relying on screen readers to understand content's purpose within a page."
+                })
+                .note(markup! {
+                    "If the content is decorative, redundant, or obscured, consider hiding it from assistive technologies with the "<Emphasis>"aria-hidden"</Emphasis>" attribute."
+                }),
+        )
+    }
+}
+
+/// Check if the element has a type="image" attribute
+fn has_type_image_attribute(element: &AnyHtmlElement) -> bool {
+    element
+        .find_attribute_by_name("type")
+        .is_some_and(|attribute| {
+            attribute
+                .initializer()
+                .and_then(|init| init.value().ok())
+                .and_then(|value| value.string_value())
+                .is_some_and(|value| value.eq_ignore_ascii_case("image"))
+        })
+}
+
+/// Check if the element has a valid alt attribute
+fn has_valid_alt_text(element: &AnyHtmlElement) -> bool {
+    // The alt attribute exists - even an empty alt="" is valid for decorative images
+    // If there's no initializer, it's treated as an empty string (valid)
+    // If there's an initializer with a value, any value is valid
+    element.find_attribute_by_name("alt").is_some()
+}
+
+/// Check if the element has a valid label attribute (aria-label, aria-labelledby, or title)
+fn has_valid_label(element: &AnyHtmlElement, name_to_lookup: &str) -> bool {
+    element
+        .find_attribute_by_name(name_to_lookup)
+        .is_some_and(|attribute| {
+            // If no initializer, the attribute is present but empty - not valid for labels
+            let Some(initializer) = attribute.initializer() else {
+                return false;
+            };
+
+            // Check if the value is not empty
+            initializer
+                .value()
+                .ok()
+                .and_then(|value| value.string_value())
+                .is_some_and(|value| !value.trim().is_empty())
+        })
+}
+
+/// Check if the element has aria-hidden="true"
+fn is_aria_hidden(element: &AnyHtmlElement) -> bool {
+    element
+        .find_attribute_by_name("aria-hidden")
+        .is_some_and(|attribute| {
+            // Only aria-hidden="true" means hidden (must have initializer with value "true")
+            attribute
+                .initializer()
+                .and_then(|init| init.value().ok())
+                .and_then(|value| value.string_value())
+                .is_some_and(|value| value == "true")
+        })
+}
diff --git a/crates/biome_html_analyze/tests/spec_tests.rs b/crates/biome_html_analyze/tests/spec_tests.rs
index 48b6a87d30..8c3ce3baac 100644
--- a/crates/biome_html_analyze/tests/spec_tests.rs
+++ b/crates/biome_html_analyze/tests/spec_tests.rs
@@ -100,7 +100,7 @@ pub(crate) fn analyze_and_snap(
     let mut code_fixes = Vec::new();
     let options = create_analyzer_options::<HtmlLanguage>(input_file, &mut diagnostics);
 
-    let (_, errors) = biome_html_analyze::analyze(&root, filter, &options, |event| {
+    let (_, errors) = biome_html_analyze::analyze(&root, filter, &options, source_type, |event| {
         if let Some(mut diag) = event.diagnostic() {
             for action in event.actions() {
                 if check_action_type.is_suppression() {
diff --git a/crates/biome_html_analyze/tests/specs/a11y/noAutofocus/invalid.html b/crates/biome_html_analyze/tests/specs/a11y/noAutofocus/invalid.html
new file mode 100644
index 0000000000..26f2d2fe8e
--- /dev/null
+++ b/crates/biome_html_analyze/tests/specs/a11y/noAutofocus/invalid.html
@@ -0,0 +1,10 @@
+<!-- should generate diagnostics -->
+<input autofocus />
+<input autofocus="true" />
+<textarea autofocus>content</textarea>
+<button autofocus>Submit</button>
+<select autofocus><option>a</option></select>
+
+<!-- autofocus on dialog/popover container itself is invalid -->
+<dialog autofocus>content</dialog>
+<div popover autofocus>content</div>
diff --git a/crates/biome_html_analyze/tests/specs/a11y/noAutofocus/invalid.html.snap b/crates/biome_html_analyze/tests/specs/a11y/noAutofocus/invalid.html.snap
new file mode 100644
index 0000000000..6bcead3d22
--- /dev/null
+++ b/crates/biome_html_analyze/tests/specs/a11y/noAutofocus/invalid.html.snap
@@ -0,0 +1,149 @@
+---
+source: crates/biome_html_analyze/tests/spec_tests.rs
+expression: invalid.html
+---
+# Input
+```html
+<!-- should generate diagnostics -->
+<input autofocus />
+<input autofocus="true" />
+<textarea autofocus>content</textarea>
+<button autofocus>Submit</button>
+<select autofocus><option>a</option></select>
+
+<!-- autofocus on dialog/popover container itself is invalid -->
+<dialog autofocus>content</dialog>
+<div popover autofocus>content</div>
+
+```
+
+# Diagnostics
+```
+invalid.html:2:8 lint/a11y/noAutofocus  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
+
+  × Avoid the autofocus attribute.
+  
+    1 │ <!-- should generate diagnostics -->
+  > 2 │ <input autofocus />
+      │        ^^^^^^^^^
+    3 │ <input autofocus="true" />
+    4 │ <textarea autofocus>content</textarea>
+  
+  i Unsafe fix: Remove the autofocus attribute.
+  
+    2 │ <input·autofocus·/>
+      │        ----------  
+
+```
+
+```
+invalid.html:3:8 lint/a11y/noAutofocus  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
+
+  × Avoid the autofocus attribute.
+  
+    1 │ <!-- should generate diagnostics -->
+    2 │ <input autofocus />
+  > 3 │ <input autofocus="true" />
+      │        ^^^^^^^^^^^^^^^^
+    4 │ <textarea autofocus>content</textarea>
+    5 │ <button autofocus>Submit</button>
+  
+  i Unsafe fix: Remove the autofocus attribute.
+  
+    3 │ <input·autofocus="true"·/>
+      │        -----------------  
+
+```
+
+```
+invalid.html:4:11 lint/a11y/noAutofocus  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
+
+  × Avoid the autofocus attribute.
+  
+    2 │ <input autofocus />
+    3 │ <input autofocus="true" />
+  > 4 │ <textarea autofocus>content</textarea>
+      │           ^^^^^^^^^
+    5 │ <button autofocus>Submit</button>
+    6 │ <select autofocus><option>a</option></select>
+  
+  i Unsafe fix: Remove the autofocus attribute.
+  
+    4 │ <textarea·autofocus>content</textarea>
+      │           ---------                   
+
+```
+
+```
+invalid.html:5:9 lint/a11y/noAutofocus  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
+
+  × Avoid the autofocus attribute.
+  
+    3 │ <input autofocus="true" />
+    4 │ <textarea autofocus>content</textarea>
+  > 5 │ <button autofocus>Submit</button>
+      │         ^^^^^^^^^
+    6 │ <select autofocus><option>a</option></select>
+    7 │ 
+  
+  i Unsafe fix: Remove the autofocus attribute.
+  
+    5 │ <button·autofocus>Submit</button>
+      │         ---------                
+
+```
+
+```
+invalid.html:6:9 lint/a11y/noAutofocus  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
+
+  × Avoid the autofocus attribute.
+  
+    4 │ <textarea autofocus>content</textarea>
+    5 │ <button autofocus>Submit</button>
+  > 6 │ <select autofocus><option>a</option></select>
+      │         ^^^^^^^^^
+    7 │ 
+    8 │ <!-- autofocus on dialog/popover container itself is invalid -->
+  
+  i Unsafe fix: Remove the autofocus attribute.
+  
+    6 │ <select·autofocus><option>a</option></select>
+      │         ---------                            
+
+```
+
+```
+invalid.html:9:9 lint/a11y/noAutofocus  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
+
+  × Avoid the autofocus attribute.
+  
+     8 │ <!-- autofocus on dialog/popover container itself is invalid -->
+   > 9 │ <dialog autofocus>content</dialog>
+       │         ^^^^^^^^^
+    10 │ <div popover autofocus>content</div>
+    11 │ 
+  
+  i Unsafe fix: Remove the autofocus attribute.
+  
+    9 │ <dialog·autofocus>content</dialog>
+      │         ---------                 
+
+```
+
+```
+invalid.html:10:14 lint/a11y/noAutofocus  FIXABLE  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
+
+  × Avoid the autofocus attribute.
+  
+     8 │ <!-- autofocus on dialog/popover container itself is invalid -->
+     9 │ <dialog autofocus>content</dialog>
+  > 10 │ <div popover autofocus>content</div>
+       │              ^^^^^^^^^
+    11 │ 
+  
+  i Unsafe fix: Remove the autofocus attribute.
+  
+    10 │ <div·popover·autofocus>content</div>
+       │              ---------              
+
+```
diff --git a/crates/biome_html_analyze/tests/specs/a11y/noAutofocus/valid.html b/crates/biome_html_analyze/tests/specs/a11y/noAutofocus/valid.html
new file mode 100644
index 0000000000..2a7b42f582
--- /dev/null
+++ b/crates/biome_html_analyze/tests/specs/a11y/noAutofocus/valid.html
@@ -0,0 +1,24 @@
+<!-- should not generate diagnostics -->
+<input />
+<textarea>content</textarea>
+<button>Submit</button>
+
+<!-- autofocus inside dialog is valid -->
+<dialog><input autofocus /></dialog>
+<dialog><textarea autofocus>content</textarea></dialog>
+
+<!-- autofocus inside element with popover is valid -->
+<div popover><input autofocus /></div>
+<div popover="auto"><button autofocus>Submit</button></div>
+
+<!-- nested cases -->
+<dialog>
+    <div>
+        <input autofocus />
+    </div>
+</dialog>
+<div popover>
+    <div>
+        <input autofocus />
+    </div>
+</div>
diff --git a/crates/biome_html_analyze/tests/specs/a11y/noAutofocus/valid.html.snap b/crates/biome_html_analyze/tests/specs/a11y/noAutofocus/valid.html.snap
new file mode 100644
index 0000000000..41038042a6
--- /dev/null
+++ b/crates/biome_html_analyze/tests/specs/a11y/noAutofocus/valid.html.snap
@@ -0,0 +1,32 @@
+---
+source: crates/biome_html_analyze/tests/spec_tests.rs
+expression: valid.html
+---
+# Input
+```html
+<!-- should not generate diagnostics -->
+<input />
+<textarea>content</textarea>
+<button>Submit</button>
+
+<!-- autofocus inside dialog is valid -->
+<dialog><input autofocus /></dialog>
+<dialog><textarea autofocus>content</textarea></dialog>
+
+<!-- autofocus inside element with popover is valid -->
+<div popover><input autofocus /></div>
+<div popover="auto"><button autofocus>Submit</button></div>
+
+<!-- nested cases -->
+<dialog>
+    <div>
+        <input autofocus />
+    </div>
+</dialog>
+<div popover>
+    <div>
+        <input autofocus />
+    </div>
+</div>
+
+```
diff --git a/crates/biome_html_analyze/tests/specs/a11y/noRedundantAlt/invalid.html b/crates/biome_html_analyze/tests/specs/a11y/noRedundantAlt/invalid.html
new file mode 100644
index 0000000000..f176c0356c
--- /dev/null
+++ b/crates/biome_html_analyze/tests/specs/a11y/noRedundantAlt/invalid.html
@@ -0,0 +1,10 @@
+<!-- should generate diagnostics -->
+<img alt="Photo of friend." />
+<img alt="Picture of friend." />
+<img alt="Image of friend." />
+<img alt="PhOtO of friend." />
+<img alt={"photo"} />
+<img alt="piCTUre of friend." />
+<img alt="imAGE of friend." />
+<img alt="image of cool person" aria-hidden="false" />
+<IMG alt="imAGE of friend." />
diff --git a/crates/biome_html_analyze/tests/specs/a11y/noRedundantAlt/invalid.html.snap b/crates/biome_html_analyze/tests/specs/a11y/noRedundantAlt/invalid.html.snap
new file mode 100644
index 0000000000..be84855aff
--- /dev/null
+++ b/crates/biome_html_analyze/tests/specs/a11y/noRedundantAlt/invalid.html.snap
@@ -0,0 +1,155 @@
+---
+source: crates/biome_html_analyze/tests/spec_tests.rs
+expression: invalid.html
+---
+# Input
+```html
+<!-- should generate diagnostics -->
+<img alt="Photo of friend." />
+<img alt="Picture of friend." />
+<img alt="Image of friend." />
+<img alt="PhOtO of friend." />
+<img alt={"photo"} />
+<img alt="piCTUre of friend." />
+<img alt="imAGE of friend." />
+<img alt="image of cool person" aria-hidden="false" />
+<IMG alt="imAGE of friend." />
+
+```
+
+_Note: The parser emitted 2 diagnostics which are not shown here._
+
+# Diagnostics
+```
+invalid.html:2:10 lint/a11y/noRedundantAlt ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
+
+  × Avoid the words "image", "picture", or "photo" in img element alt text.
+  
+    1 │ <!-- should generate diagnostics -->
+  > 2 │ <img alt="Photo of friend." />
+      │          ^^^^^^^^^^^^^^^^^^
+    3 │ <img alt="Picture of friend." />
+    4 │ <img alt="Image of friend." />
+  
+  i Screen readers announce img elements as "images", so it is not necessary to redeclare this in alternative text.
+  
+
+```
+
+```
+invalid.html:3:10 lint/a11y/noRedundantAlt ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
+
+  × Avoid the words "image", "picture", or "photo" in img element alt text.
+  
+    1 │ <!-- should generate diagnostics -->
+    2 │ <img alt="Photo of friend." />
+  > 3 │ <img alt="Picture of friend." />
+      │          ^^^^^^^^^^^^^^^^^^^^
+    4 │ <img alt="Image of friend." />
+    5 │ <img alt="PhOtO of friend." />
+  
+  i Screen readers announce img elements as "images", so it is not necessary to redeclare this in alternative text.
+  
+
+```
+
+```
+invalid.html:4:10 lint/a11y/noRedundantAlt ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
+
+  × Avoid the words "image", "picture", or "photo" in img element alt text.
+  
+    2 │ <img alt="Photo of friend." />
+    3 │ <img alt="Picture of friend." />
+  > 4 │ <img alt="Image of friend." />
+      │          ^^^^^^^^^^^^^^^^^^
+    5 │ <img alt="PhOtO of friend." />
+    6 │ <img alt={"photo"} />
+  
+  i Screen readers announce img elements as "images", so it is not necessary to redeclare this in alternative text.
+  
+
+```
+
+```
+invalid.html:5:10 lint/a11y/noRedundantAlt ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
+
+  × Avoid the words "image", "picture", or "photo" in img element alt text.
+  
+    3 │ <img alt="Picture of friend." />
+    4 │ <img alt="Image of friend." />
+  > 5 │ <img alt="PhOtO of friend." />
+      │          ^^^^^^^^^^^^^^^^^^
+    6 │ <img alt={"photo"} />
+    7 │ <img alt="piCTUre of friend." />
+  
+  i Screen readers announce img elements as "images", so it is not necessary to redeclare this in alternative text.
+  
+
+```
+
+```
+invalid.html:7:10 lint/a11y/noRedundantAlt ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
+
+  × Avoid the words "image", "picture", or "photo" in img element alt text.
+  
+    5 │ <img alt="PhOtO of friend." />
+    6 │ <img alt={"photo"} />
+  > 7 │ <img alt="piCTUre of friend." />
+      │          ^^^^^^^^^^^^^^^^^^^^
+    8 │ <img alt="imAGE of friend." />
+    9 │ <img alt="image of cool person" aria-hidden="false" />
+  
+  i Screen readers announce img elements as "images", so it is not necessary to redeclare this in alternative text.
+  
+
+```
+
+```
+invalid.html:8:10 lint/a11y/noRedundantAlt ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
+
+  × Avoid the words "image", "picture", or "photo" in img element alt text.
+  
+     6 │ <img alt={"photo"} />
+     7 │ <img alt="piCTUre of friend." />
+   > 8 │ <img alt="imAGE of friend." />
+       │          ^^^^^^^^^^^^^^^^^^
+     9 │ <img alt="image of cool person" aria-hidden="false" />
+    10 │ <IMG alt="imAGE of friend." />
+  
+  i Screen readers announce img elements as "images", so it is not necessary to redeclare this in alternative text.
+  
+
+```
+
+```
+invalid.html:9:10 lint/a11y/noRedundantAlt ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
+
+  × Avoid the words "image", "picture", or "photo" in img element alt text.
+  
+     7 │ <img alt="piCTUre of friend." />
+     8 │ <img alt="imAGE of friend." />
+   > 9 │ <img alt="image of cool person" aria-hidden="false" />
+       │          ^^^^^^^^^^^^^^^^^^^^^^
+    10 │ <IMG alt="imAGE of friend." />
+    11 │ 
+  
+  i Screen readers announce img elements as "images", so it is not necessary to redeclare this in alternative text.
+  
+
+```
+
+```
+invalid.html:10:10 lint/a11y/noRedundantAlt ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
+
+  × Avoid the words "image", "picture", or "photo" in img element alt text.
+  
+     8 │ <img alt="imAGE of friend." />
+     9 │ <img alt="image of cool person" aria-hidden="false" />
+  > 10 │ <IMG alt="imAGE of friend." />
+       │          ^^^^^^^^^^^^^^^^^^
+    11 │ 
+  
+  i Screen readers announce img elements as "images", so it is not necessary to redeclare this in alternative text.
+  
+
+```
diff --git a/crates/biome_html_analyze/tests/specs/a11y/noRedundantAlt/invalid.vue b/crates/biome_html_analyze/tests/specs/a11y/noRedundantAlt/invalid.vue
new file mode 100644
index 0000000000..d6c6d26f3a
--- /dev/null
+++ b/crates/biome_html_analyze/tests/specs/a11y/noRedundantAlt/invalid.vue
@@ -0,0 +1,9 @@
+<!-- should generate diagnostics -->
+<img alt="Photo of friend." />
+<img alt="Picture of friend." />
+<img alt="Image of friend." />
+<img alt="PhOtO of friend." />
+<img alt={"photo"} />
+<img alt="piCTUre of friend." />
+<img alt="imAGE of friend." />
+<img alt="image of cool person" aria-hidden="false" />
diff --git a/crates/biome_html_analyze/tests/specs/a11y/noRedundantAlt/invalid.vue.snap b/crates/biome_html_analyze/tests/specs/a11y/noRedundantAlt/invalid.vue.snap
new file mode 100644
index 0000000000..928d0ff71a
--- /dev/null
+++ b/crates/biome_html_analyze/tests/specs/a11y/noRedundantAlt/invalid.vue.snap
@@ -0,0 +1,137 @@
+---
+source: crates/biome_html_analyze/tests/spec_tests.rs
+expression: invalid.vue
+---
+# Input
+```html
+<!-- should generate diagnostics -->
+<img alt="Photo of friend." />
+<img alt="Picture of friend." />
+<img alt="Image of friend." />
+<img alt="PhOtO of friend." />
+<img alt={"photo"} />
+<img alt="piCTUre of friend." />
+<img alt="imAGE of friend." />
+<img alt="image of cool person" aria-hidden="false" />
+
+```
+
+_Note: The parser emitted 2 diagnostics which are not shown here._
+
+# Diagnostics
+```
+invalid.vue:2:10 lint/a11y/noRedundantAlt ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
+
+  × Avoid the words "image", "picture", or "photo" in img element alt text.
+  
+    1 │ <!-- should generate diagnostics -->
+  > 2 │ <img alt="Photo of friend." />
+      │          ^^^^^^^^^^^^^^^^^^
+    3 │ <img alt="Picture of friend." />
+    4 │ <img alt="Image of friend." />
+  
+  i Screen readers announce img elements as "images", so it is not necessary to redeclare this in alternative text.
+  
+
+```
+
+```
+invalid.vue:3:10 lint/a11y/noRedundantAlt ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
+
+  × Avoid the words "image", "picture", or "photo" in img element alt text.
+  
+    1 │ <!-- should generate diagnostics -->
+    2 │ <img alt="Photo of friend." />
+  > 3 │ <img alt="Picture of friend." />
+      │          ^^^^^^^^^^^^^^^^^^^^
+    4 │ <img alt="Image of friend." />
+    5 │ <img alt="PhOtO of friend." />
+  
+  i Screen readers announce img elements as "images", so it is not necessary to redeclare this in alternative text.
+  
+
+```
+
+```
+invalid.vue:4:10 lint/a11y/noRedundantAlt ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
+
+  × Avoid the words "image", "picture", or "photo" in img element alt text.
+  
+    2 │ <img alt="Photo of friend." />
+    3 │ <img alt="Picture of friend." />
+  > 4 │ <img alt="Image of friend." />
+      │          ^^^^^^^^^^^^^^^^^^
+    5 │ <img alt="PhOtO of friend." />
+    6 │ <img alt={"photo"} />
+  
+  i Screen readers announce img elements as "images", so it is not necessary to redeclare this in alternative text.
+  
+
+```
+
+```
+invalid.vue:5:10 lint/a11y/noRedundantAlt ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
+
+  × Avoid the words "image", "picture", or "photo" in img element alt text.
+  
+    3 │ <img alt="Picture of friend." />
+    4 │ <img alt="Image of friend." />
+  > 5 │ <img alt="PhOtO of friend." />
+      │          ^^^^^^^^^^^^^^^^^^
+    6 │ <img alt={"photo"} />
+    7 │ <img alt="piCTUre of friend." />
+  
+  i Screen readers announce img elements as "images", so it is not necessary to redeclare this in alternative text.
+  
+
+```
+
+```
+invalid.vue:7:10 lint/a11y/noRedundantAlt ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
+
+  × Avoid the words "image", "picture", or "photo" in img element alt text.
+  
+    5 │ <img alt="PhOtO of friend." />
+    6 │ <img alt={"photo"} />
+  > 7 │ <img alt="piCTUre of friend." />
+      │          ^^^^^^^^^^^^^^^^^^^^
+    8 │ <img alt="imAGE of friend." />
+    9 │ <img alt="image of cool person" aria-hidden="false" />
+  
+  i Screen readers announce img elements as "images", so it is not necessary to redeclare this in alternative text.
+  
+
+```
+
+```
+invalid.vue:8:10 lint/a11y/noRedundantAlt ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
+
+  × Avoid the words "image", "picture", or "photo" in img element alt text.
+  
+     6 │ <img alt={"photo"} />
+     7 │ <img alt="piCTUre of friend." />
+   > 8 │ <img alt="imAGE of friend." />
+       │          ^^^^^^^^^^^^^^^^^^
+     9 │ <img alt="image of cool person" aria-hidden="false" />
+    10 │ 
+  
+  i Screen readers announce img elements as "images", so it is not necessary to redeclare this in alternative text.
+  
+
+```
+
+```
+invalid.vue:9:10 lint/a11y/noRedundantAlt ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
+
+  × Avoid the words "image", "picture", or "photo" in img element alt text.
+  
+     7 │ <img alt="piCTUre of friend." />
+     8 │ <img alt="imAGE of friend." />
+   > 9 │ <img alt="image of cool person" aria-hidden="false" />
+       │          ^^^^^^^^^^^^^^^^^^^^^^
+    10 │ 
+  
+  i Screen readers announce img elements as "images", so it is not necessary to redeclare this in alternative text.
+  
+
+```
diff --git a/crates/biome_html_analyze/tests/specs/a11y/noRedundantAlt/valid.html b/crates/biome_html_analyze/tests/specs/a11y/noRedundantAlt/valid.html
new file mode 100644
index 0000000000..c071e2b2d7
--- /dev/null
+++ b/crates/biome_html_analyze/tests/specs/a11y/noRedundantAlt/valid.html
@@ -0,0 +1,12 @@
+<!-- should not generate diagnostics -->
+<img alt="foo" />
+<img alt="picture of me taking a photo of an image" aria-hidden />
+<img aria-hidden alt="photo of image" />
+<img aria-hidden="true" alt="photo of image" />
+<img ALt="foo" />
+<a />
+<img />
+<IMG />
+<img aria-hidden="false" alt="Doing cool things." />
+<ux-Layout>test</ux-Layout>
+<img alt />
diff --git a/crates/biome_html_analyze/tests/specs/a11y/noRedundantAlt/valid.html.snap b/crates/biome_html_analyze/tests/specs/a11y/noRedundantAlt/valid.html.snap
new file mode 100644
index 0000000000..19fba44a76
--- /dev/null
+++ b/crates/biome_html_analyze/tests/specs/a11y/noRedundantAlt/valid.html.snap
@@ -0,0 +1,20 @@
+---
+source: crates/biome_html_analyze/tests/spec_tests.rs
+expression: valid.html
+---
+# Input
+```html
+<!-- should not generate diagnostics -->
+<img alt="foo" />
+<img alt="picture of me taking a photo of an image" aria-hidden />
+<img aria-hidden alt="photo of image" />
+<img aria-hidden="true" alt="photo of image" />
+<img ALt="foo" />
+<a />
+<img />
+<IMG />
+<img aria-hidden="false" alt="Doing cool things." />
+<ux-Layout>test</ux-Layout>
+<img alt />
+
+```
diff --git a/crates/biome_html_analyze/tests/specs/a11y/noRedundantAlt/valid.vue b/crates/biome_html_analyze/tests/specs/a11y/noRedundantAlt/valid.vue
new file mode 100644
index 0000000000..df4fb70a31
--- /dev/null
+++ b/crates/biome_html_analyze/tests/specs/a11y/noRedundantAlt/valid.vue
@@ -0,0 +1,15 @@
+<script setup>
+</script><!-- should not generate diagnostics -->
+<img alt="foo" />
+<img alt="picture of me taking a photo of an image" aria-hidden />
+<img aria-hidden alt="photo of image" />
+<img aria-hidden="true" alt="photo of image" />
+<img ALt="foo" />
+<a />
+<img />
+<IMG />
+<img aria-hidden="false" alt="Doing cool things." />
+<ux-Layout>test</ux-Layout>
+<img alt />
+<Img alt="image of cool person" aria-hidden="false" />
+
diff --git a/crates/biome_html_analyze/tests/specs/a11y/noRedundantAlt/valid.vue.snap b/crates/biome_html_analyze/tests/specs/a11y/noRedundantAlt/valid.vue.snap
new file mode 100644
index 0000000000..bfc23be26a
--- /dev/null
+++ b/crates/biome_html_analyze/tests/specs/a11y/noRedundantAlt/valid.vue.snap
@@ -0,0 +1,23 @@
+---
+source: crates/biome_html_analyze/tests/spec_tests.rs
+expression: valid.vue
+---
+# Input
+```html
+<script setup>
+</script><!-- should not generate diagnostics -->
+<img alt="foo" />
+<img alt="picture of me taking a photo of an image" aria-hidden />
+<img aria-hidden alt="photo of image" />
+<img aria-hidden="true" alt="photo of image" />
+<img ALt="foo" />
+<a />
+<img />
+<IMG />
+<img aria-hidden="false" alt="Doing cool things." />
+<ux-Layout>test</ux-Layout>
+<img alt />
+<Img alt="image of cool person" aria-hidden="false" />
+
+
+```
diff --git a/crates/biome_html_analyze/tests/specs/a11y/useAltText/invalid.html b/crates/biome_html_analyze/tests/specs/a11y/useAltText/invalid.html
new file mode 100644
index 0000000000..7a916dd399
--- /dev/null
+++ b/crates/biome_html_analyze/tests/specs/a11y/useAltText/invalid.html
@@ -0,0 +1,17 @@
+<!-- should generate diagnostics -->
+
+<!-- img without alt -->
+<img src="image.png" />
+<img src="image.png" class="photo" />
+
+<!-- area without alt -->
+<area href="foo" />
+<map name="map"><area shape="rect" coords="0,0,100,100" href="link" /></map>
+
+<!-- input type="image" without alt -->
+<input type="image" src="submit.png" />
+<input type="image" src="button.png" name="submit" />
+
+<!-- object without title -->
+<object data="movie.swf"></object>
+<object data="document.pdf" type="application/pdf"></object>
diff --git a/crates/biome_html_analyze/tests/specs/a11y/useAltText/invalid.html.snap b/crates/biome_html_analyze/tests/specs/a11y/useAltText/invalid.html.snap
new file mode 100644
index 0000000000..3845d82ed8
--- /dev/null
+++ b/crates/biome_html_analyze/tests/specs/a11y/useAltText/invalid.html.snap
@@ -0,0 +1,173 @@
+---
+source: crates/biome_html_analyze/tests/spec_tests.rs
+expression: invalid.html
+---
+# Input
+```html
+<!-- should generate diagnostics -->
+
+<!-- img without alt -->
+<img src="image.png" />
+<img src="image.png" class="photo" />
+
+<!-- area without alt -->
+<area href="foo" />
+<map name="map"><area shape="rect" coords="0,0,100,100" href="link" /></map>
+
+<!-- input type="image" without alt -->
+<input type="image" src="submit.png" />
+<input type="image" src="button.png" name="submit" />
+
+<!-- object without title -->
+<object data="movie.swf"></object>
+<object data="document.pdf" type="application/pdf"></object>
+
+```
+
+# Diagnostics
+```
+invalid.html:4:1 lint/a11y/useAltText ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
+
+  × Provide a text alternative through the alt, aria-label, or aria-labelledby attribute.
+  
+    3 │ <!-- img without alt -->
+  > 4 │ <img src="image.png" />
+      │ ^^^^^^^^^^^^^^^^^^^^^^^
+    5 │ <img src="image.png" class="photo" />
+    6 │ 
+  
+  i Meaningful alternative text on elements helps users relying on screen readers to understand content's purpose within a page.
+  
+  i If the content is decorative, redundant, or obscured, consider hiding it from assistive technologies with the aria-hidden attribute.
+  
+
+```
+
+```
+invalid.html:5:1 lint/a11y/useAltText ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
+
+  × Provide a text alternative through the alt, aria-label, or aria-labelledby attribute.
+  
+    3 │ <!-- img without alt -->
+    4 │ <img src="image.png" />
+  > 5 │ <img src="image.png" class="photo" />
+      │ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+    6 │ 
+    7 │ <!-- area without alt -->
+  
+  i Meaningful alternative text on elements helps users relying on screen readers to understand content's purpose within a page.
+  
+  i If the content is decorative, redundant, or obscured, consider hiding it from assistive technologies with the aria-hidden attribute.
+  
+
+```
+
+```
+invalid.html:8:1 lint/a11y/useAltText ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
+
+  × Provide a text alternative through the alt, aria-label, or aria-labelledby attribute.
+  
+     7 │ <!-- area without alt -->
+   > 8 │ <area href="foo" />
+       │ ^^^^^^^^^^^^^^^^^^^
+     9 │ <map name="map"><area shape="rect" coords="0,0,100,100" href="link" /></map>
+    10 │ 
+  
+  i Meaningful alternative text on elements helps users relying on screen readers to understand content's purpose within a page.
+  
+  i If the content is decorative, redundant, or obscured, consider hiding it from assistive technologies with the aria-hidden attribute.
+  
+
+```
+
+```
+invalid.html:9:17 lint/a11y/useAltText ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
+
+  × Provide a text alternative through the alt, aria-label, or aria-labelledby attribute.
+  
+     7 │ <!-- area without alt -->
+     8 │ <area href="foo" />
+   > 9 │ <map name="map"><area shape="rect" coords="0,0,100,100" href="link" /></map>
+       │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+    10 │ 
+    11 │ <!-- input type="image" without alt -->
+  
+  i Meaningful alternative text on elements helps users relying on screen readers to understand content's purpose within a page.
+  
+  i If the content is decorative, redundant, or obscured, consider hiding it from assistive technologies with the aria-hidden attribute.
+  
+
+```
+
+```
+invalid.html:12:1 lint/a11y/useAltText ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
+
+  × Provide a text alternative through the alt, aria-label, or aria-labelledby attribute.
+  
+    11 │ <!-- input type="image" without alt -->
+  > 12 │ <input type="image" src="submit.png" />
+       │ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+    13 │ <input type="image" src="button.png" name="submit" />
+    14 │ 
+  
+  i Meaningful alternative text on elements helps users relying on screen readers to understand content's purpose within a page.
+  
+  i If the content is decorative, redundant, or obscured, consider hiding it from assistive technologies with the aria-hidden attribute.
+  
+
+```
+
+```
+invalid.html:13:1 lint/a11y/useAltText ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
+
+  × Provide a text alternative through the alt, aria-label, or aria-labelledby attribute.
+  
+    11 │ <!-- input type="image" without alt -->
+    12 │ <input type="image" src="submit.png" />
+  > 13 │ <input type="image" src="button.png" name="submit" />
+       │ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+    14 │ 
+    15 │ <!-- object without title -->
+  
+  i Meaningful alternative text on elements helps users relying on screen readers to understand content's purpose within a page.
+  
+  i If the content is decorative, redundant, or obscured, consider hiding it from assistive technologies with the aria-hidden attribute.
+  
+
+```
+
+```
+invalid.html:16:1 lint/a11y/useAltText ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
+
+  × Provide a text alternative through the title, aria-label, or aria-labelledby attribute.
+  
+    15 │ <!-- object without title -->
+  > 16 │ <object data="movie.swf"></object>
+       │ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+    17 │ <object data="document.pdf" type="application/pdf"></object>
+    18 │ 
+  
+  i Meaningful alternative text on elements helps users relying on screen readers to understand content's purpose within a page.
+  
+  i If the content is decorative, redundant, or obscured, consider hiding it from assistive technologies with the aria-hidden attribute.
+  
+
+```
+
+```
+invalid.html:17:1 lint/a11y/useAltText ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
+
+  × Provide a text alternative through the title, aria-label, or aria-labelledby attribute.
+  
+    15 │ <!-- object without title -->
+    16 │ <object data="movie.swf"></object>
+  > 17 │ <object data="document.pdf" type="application/pdf"></object>
+       │ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+    18 │ 
+  
+  i Meaningful alternative text on elements helps users relying on screen readers to understand content's purpose within a page.
+  
+  i If the content is decorative, redundant, or obscured, consider hiding it from assistive technologies with the aria-hidden attribute.
+  
+
+```
diff --git a/crates/biome_html_analyze/tests/specs/a11y/useAltText/valid.html b/crates/biome_html_analyze/tests/specs/a11y/useAltText/valid.html
new file mode 100644
index 0000000000..03610bd1d9
--- /dev/null
+++ b/crates/biome_html_analyze/tests/specs/a11y/useAltText/valid.html
@@ -0,0 +1,56 @@
+<!-- should not generate diagnostics -->
+
+<!-- img with alt -->
+<img src="image.png" alt="A beautiful landscape" />
+<img src="photo.jpg" alt="Profile picture" />
+
+<!-- img with empty alt (decorative) -->
+<img src="decorative.png" alt="" />
+
+<!-- img with aria-label -->
+<img src="image.png" aria-label="Description" />
+
+<!-- img with aria-labelledby -->
+<img src="image.png" aria-labelledby="desc-id" />
+
+<!-- img with aria-hidden="true" -->
+<img src="decorative.png" aria-hidden="true" />
+
+<!-- area with alt -->
+<map name="map">
+    <area shape="rect" coords="0,0,100,100" href="link" alt="Link area" />
+</map>
+
+<!-- area with aria-label -->
+<area href="foo" aria-label="Link description" />
+
+<!-- input type="image" with alt -->
+<input type="image" src="submit.png" alt="Submit form" />
+
+<!-- input type="image" with aria-label -->
+<input type="image" src="button.png" aria-label="Click me" />
+
+<!-- input type="image" with aria-labelledby -->
+<input type="image" src="button.png" aria-labelledby="button-desc" />
+
+<!-- input type="text" doesn't need alt -->
+<input type="text" />
+<input type="submit" value="Submit" />
+
+<!-- object with title -->
+<object data="movie.swf" title="Video player"></object>
+
+<!-- object with aria-label -->
+<object data="document.pdf" aria-label="PDF document"></object>
+
+<!-- object with aria-labelledby -->
+<object data="app.swf" aria-labelledby="app-title"></object>
+
+<!-- object with aria-hidden -->
+<object data="decorative.swf" aria-hidden="true"></object>
+
+<!-- Case insensitivity in HTML -->
+<IMG src="image.png" alt="Image" />
+<AREA href="link" alt="Link" />
+<INPUT type="image" alt="Submit" />
+<OBJECT data="file.pdf" title="PDF"></OBJECT>
diff --git a/crates/biome_html_analyze/tests/specs/a11y/useAltText/valid.html.snap b/crates/biome_html_analyze/tests/specs/a11y/useAltText/valid.html.snap
new file mode 100644
index 0000000000..5865495078
--- /dev/null
+++ b/crates/biome_html_analyze/tests/specs/a11y/useAltText/valid.html.snap
@@ -0,0 +1,64 @@
+---
+source: crates/biome_html_analyze/tests/spec_tests.rs
+expression: valid.html
+---
+# Input
+```html
+<!-- should not generate diagnostics -->
+
+<!-- img with alt -->
+<img src="image.png" alt="A beautiful landscape" />
+<img src="photo.jpg" alt="Profile picture" />
+
+<!-- img with empty alt (decorative) -->
+<img src="decorative.png" alt="" />
+
+<!-- img with aria-label -->
+<img src="image.png" aria-label="Description" />
+
+<!-- img with aria-labelledby -->
+<img src="image.png" aria-labelledby="desc-id" />
+
+<!-- img with aria-hidden="true" -->
+<img src="decorative.png" aria-hidden="true" />
+
+<!-- area with alt -->
+<map name="map">
+    <area shape="rect" coords="0,0,100,100" href="link" alt="Link area" />
+</map>
+
+<!-- area with aria-label -->
+<area href="foo" aria-label="Link description" />
+
+<!-- input type="image" with alt -->
+<input type="image" src="submit.png" alt="Submit form" />
+
+<!-- input type="image" with aria-label -->
+<input type="image" src="button.png" aria-label="Click me" />
+
+<!-- input type="image" with aria-labelledby -->
+<input type="image" src="button.png" aria-labelledby="button-desc" />
+
+<!-- input type="text" doesn't need alt -->
+<input type="text" />
+<input type="submit" value="Submit" />
+
+<!-- object with title -->
+<object data="movie.swf" title="Video player"></object>
+
+<!-- object with aria-label -->
+<object data="document.pdf" aria-label="PDF document"></object>
+
+<!-- object with aria-labelledby -->
+<object data="app.swf" aria-labelledby="app-title"></object>
+
+<!-- object with aria-hidden -->
+<object data="decorative.swf" aria-hidden="true"></object>
+
+<!-- Case insensitivity in HTML -->
+<IMG src="image.png" alt="Image" />
+<AREA href="link" alt="Link" />
+<INPUT type="image" alt="Submit" />
+<OBJECT data="file.pdf" title="PDF"></OBJECT>
+
+```
diff --git a/crates/biome_html_formatter/tests/spec_test.rs b/crates/biome_html_formatter/tests/spec_test.rs
index 22a80d9365..09a6c3deac 100644
--- a/crates/biome_html_formatter/tests/spec_test.rs
+++ b/crates/biome_html_formatter/tests/spec_test.rs
@@ -45,6 +45,7 @@ pub fn run(spec_input_file: &str, _expected_file: &str, test_directory: &str, _f
             project_key,
             workspace_directory: Some(BiomePath::new(test_directory)),
             extended_configurations: vec![],
+            module_graph_resolution_kind: Default::default(),
         })
     }) else {
         panic!("Failed to set up snapshot test");
diff --git a/crates/biome_html_syntax/src/element_ext.rs b/crates/biome_html_syntax/src/element_ext.rs
index 7edc02fd23..444d0c9bac 100644
--- a/crates/biome_html_syntax/src/element_ext.rs
+++ b/crates/biome_html_syntax/src/element_ext.rs
@@ -219,6 +219,10 @@ impl HtmlElement {
     pub fn is_sass_lang(&self) -> bool {
         self.is_style_tag() && self.has_attribute("lang", "scss")
     }
+
+    pub fn name(&self) -> SyntaxResult<HtmlTagName> {
+        self.opening_element()?.name()
+    }
 }
 
 impl HtmlTagName {
diff --git a/crates/biome_js_analyze/src/lint/a11y/no_redundant_alt.rs b/crates/biome_js_analyze/src/lint/a11y/no_redundant_alt.rs
index 2b6dfcfb49..b8f3d9d222 100644
--- a/crates/biome_js_analyze/src/lint/a11y/no_redundant_alt.rs
+++ b/crates/biome_js_analyze/src/lint/a11y/no_redundant_alt.rs
@@ -7,8 +7,8 @@ use biome_js_syntax::{
     AnyJsExpression, AnyJsLiteralExpression, AnyJsTemplateElement, AnyJsxAttributeValue,
 };
 use biome_rowan::AstNode;
+use biome_rule_options::is_redundant_alt;
 use biome_rule_options::no_redundant_alt::NoRedundantAltOptions;
-use biome_string_case::StrLikeExtension;
 
 declare_lint_rule! {
     /// Enforce `img` alt prop does not contain the word "image", "picture", or "photo".
@@ -142,12 +142,3 @@ impl Rule for NoRedundantAlt {
         )
     }
 }
-
-const REDUNDANT_WORDS: [&str; 3] = ["image", "photo", "picture"];
-
-fn is_redundant_alt(alt: &str) -> bool {
-    REDUNDANT_WORDS.into_iter().any(|word| {
-        alt.split_whitespace()
-            .any(|x| x.to_ascii_lowercase_cow() == word)
-    })
-}
diff --git a/crates/biome_js_analyze/src/lint/nursery/no_floating_promises.rs b/crates/biome_js_analyze/src/lint/nursery/no_floating_promises.rs
index 47762a04f5..f04ef9b5ad 100644
--- a/crates/biome_js_analyze/src/lint/nursery/no_floating_promises.rs
+++ b/crates/biome_js_analyze/src/lint/nursery/no_floating_promises.rs
@@ -158,7 +158,7 @@ declare_lint_rule! {
         recommended: true,
         sources: &[RuleSource::EslintTypeScript("no-floating-promises").same()],
         fix_kind: FixKind::Unsafe,
-        domains: &[RuleDomain::Project],
+        domains: &[RuleDomain::Types],
     }
 }
 
diff --git a/crates/biome_js_analyze/src/lint/nursery/no_misused_promises.rs b/crates/biome_js_analyze/src/lint/nursery/no_misused_promises.rs
index 532e83374f..70bccf3a36 100644
--- a/crates/biome_js_analyze/src/lint/nursery/no_misused_promises.rs
+++ b/crates/biome_js_analyze/src/lint/nursery/no_misused_promises.rs
@@ -88,7 +88,7 @@ declare_lint_rule! {
         recommended: true,
         sources: &[RuleSource::EslintTypeScript("no-misused-promises").same()],
         fix_kind: FixKind::Unsafe,
-        domains: &[RuleDomain::Project],
+        domains: &[RuleDomain::Types],
     }
 }
 
diff --git a/crates/biome_js_analyze/src/lint/nursery/no_unnecessary_conditions.rs b/crates/biome_js_analyze/src/lint/nursery/no_unnecessary_conditions.rs
index eed6b69a00..1ab220eadf 100644
--- a/crates/biome_js_analyze/src/lint/nursery/no_unnecessary_conditions.rs
+++ b/crates/biome_js_analyze/src/lint/nursery/no_unnecessary_conditions.rs
@@ -90,7 +90,7 @@ declare_lint_rule! {
         sources: &[RuleSource::EslintTypeScript("no-unnecessary-condition").inspired()],
         recommended: false,
         severity: Severity::Warning,
-        domains: &[RuleDomain::Project],
+        domains: &[RuleDomain::Types],
         issue_number: Some("6611"),
     }
 }
diff --git a/crates/biome_js_analyze/src/lint/nursery/use_array_sort_compare.rs b/crates/biome_js_analyze/src/lint/nursery/use_array_sort_compare.rs
index 8896b5ed8e..2ffcd73e20 100644
--- a/crates/biome_js_analyze/src/lint/nursery/use_array_sort_compare.rs
+++ b/crates/biome_js_analyze/src/lint/nursery/use_array_sort_compare.rs
@@ -43,7 +43,7 @@ declare_lint_rule! {
         language: "js",
         recommended: false,
         sources: &[RuleSource::EslintTypeScript("require-array-sort-compare").same()],
-        domains: &[RuleDomain::Project],
+        domains: &[RuleDomain::Types],
     }
 }
 
diff --git a/crates/biome_js_analyze/src/lint/nursery/use_await_thenable.rs b/crates/biome_js_analyze/src/lint/nursery/use_await_thenable.rs
index 57ede9ffae..400101bd9a 100644
--- a/crates/biome_js_analyze/src/lint/nursery/use_await_thenable.rs
+++ b/crates/biome_js_analyze/src/lint/nursery/use_await_thenable.rs
@@ -46,7 +46,7 @@ declare_lint_rule! {
         language: "js",
         recommended: false,
         sources: &[RuleSource::EslintTypeScript("use-await-thenable").inspired()],
-        domains: &[RuleDomain::Project],
+        domains: &[RuleDomain::Types],
     }
 }
 
diff --git a/crates/biome_js_analyze/src/lint/nursery/use_exhaustive_switch_cases.rs b/crates/biome_js_analyze/src/lint/nursery/use_exhaustive_switch_cases.rs
index 5f262c5407..d4d2d2c6a6 100644
--- a/crates/biome_js_analyze/src/lint/nursery/use_exhaustive_switch_cases.rs
+++ b/crates/biome_js_analyze/src/lint/nursery/use_exhaustive_switch_cases.rs
@@ -97,7 +97,7 @@ declare_lint_rule! {
         recommended: true,
         sources: &[RuleSource::EslintTypeScript("switch-exhaustiveness-check").same()],
         fix_kind: FixKind::Unsafe,
-        domains: &[RuleDomain::Project],
+        domains: &[RuleDomain::Types],
     }
 }
 
diff --git a/crates/biome_js_analyze/src/lint/nursery/use_find.rs b/crates/biome_js_analyze/src/lint/nursery/use_find.rs
index c7477886ac..06d9a99c44 100644
--- a/crates/biome_js_analyze/src/lint/nursery/use_find.rs
+++ b/crates/biome_js_analyze/src/lint/nursery/use_find.rs
@@ -41,7 +41,7 @@ declare_lint_rule! {
         language: "js",
         recommended: false,
         sources: &[RuleSource::EslintTypeScript("prefer-find").same()],
-        domains: &[RuleDomain::Project],
+        domains: &[RuleDomain::Types],
     }
 }
 
diff --git a/crates/biome_js_analyze/src/lint/nursery/use_regexp_exec.rs b/crates/biome_js_analyze/src/lint/nursery/use_regexp_exec.rs
index 66a32d0374..94580fc687 100644
--- a/crates/biome_js_analyze/src/lint/nursery/use_regexp_exec.rs
+++ b/crates/biome_js_analyze/src/lint/nursery/use_regexp_exec.rs
@@ -36,7 +36,7 @@ declare_lint_rule! {
         language: "js",
         recommended: false,
         sources: &[RuleSource::EslintTypeScript("prefer-regexp-exec").same(), RuleSource::EslintRegexp("prefer-regexp-exec").same()],
-        domains: &[RuleDomain::Project],
+        domains: &[RuleDomain::Types],
     }
 }
 
diff --git a/crates/biome_js_analyze/src/lint/style/use_component_export_only_modules.rs b/crates/biome_js_analyze/src/lint/style/use_component_export_only_modules.rs
index 0093ce1dec..cff55e5a8a 100644
--- a/crates/biome_js_analyze/src/lint/style/use_component_export_only_modules.rs
+++ b/crates/biome_js_analyze/src/lint/style/use_component_export_only_modules.rs
@@ -4,10 +4,13 @@ use biome_analyze::{
 };
 use biome_console::markup;
 use biome_diagnostics::Severity;
-use biome_js_syntax::{AnyJsModuleItem, AnyJsStatement, JsModule, export_ext::AnyJsExported};
-use biome_rowan::{AstNode, TextRange};
+use biome_js_syntax::{
+    AnyJsModuleItem, AnyJsStatement, JsIdentifierExpression, JsModule, JsPropertyObjectMember,
+    JsShorthandPropertyObjectMember, export_ext::AnyJsExported,
+};
+use biome_rowan::{AstNode, SyntaxNodeCast, TextRange};
 use biome_rule_options::use_component_export_only_modules::UseComponentExportOnlyModulesOptions;
-use rustc_hash::FxHashMap;
+use rustc_hash::{FxHashMap, FxHashSet};
 
 declare_lint_rule! {
     /// Enforce declaring components only within modules that export React Components exclusively.
@@ -215,6 +218,55 @@ impl Rule for UseComponentExportOnlyModules {
             }
         }
 
+        // Collect identifiers referenced as object property values in exported expressions.
+        // If a local component is referenced as an object property value,
+        // it should not be reported as unexported.
+        // This handles patterns like TanStack Router:
+        //   export const Route = createFileRoute('/')({ component: HomeComponent })
+        //   function HomeComponent() { ... }
+        //
+        // We only exempt components referenced in object literals (like { component: X })
+        // and not direct function call arguments (like hoge(X)), because the latter
+        // might be non-standard HOCs that could break Fast Refresh.
+        let referenced_ids: FxHashSet<Box<str>> = exported_non_component_ids
+            .iter()
+            .filter_map(|item| item.exported.as_ref())
+            .flat_map(|exported| {
+                exported
+                    .syntax()
+                    .descendants()
+                    .filter_map(JsIdentifierExpression::cast)
+                    .filter(|id| {
+                        // Only include identifiers that are object property values
+                        id.syntax()
+                            .parent()
+                            .is_some_and(|parent| parent.cast::<JsPropertyObjectMember>().is_some())
+                    })
+                    .filter_map(|id| id.name().ok())
+                    .filter_map(|name| name.value_token().ok())
+                    .map(|token| token.text_trimmed().into())
+            })
+            .collect();
+
+        // Also collect shorthand property references like { HomeComponent }
+        let shorthand_ids: FxHashSet<Box<str>> = exported_non_component_ids
+            .iter()
+            .filter_map(|item| item.exported.as_ref())
+            .flat_map(|exported| {
+                exported
+                    .syntax()
+                    .descendants()
+                    .filter_map(JsShorthandPropertyObjectMember::cast)
+                    .filter_map(|prop| prop.name().ok())
+                    .filter_map(|name| name.value_token().ok())
+                    .map(|token| token.text_trimmed().into())
+            })
+            .collect();
+
+        // Remove components that are referenced as object property values
+        local_components
+            .retain(|name, _| !referenced_ids.contains(name) && !shorthand_ids.contains(name));
+
         if !exported_component_ids.is_empty() {
             return exported_non_component_ids
                 .iter()
diff --git a/crates/biome_js_analyze/src/lint/suspicious/use_iterable_callback_return.rs b/crates/biome_js_analyze/src/lint/suspicious/use_iterable_callback_return.rs
index 6ce5644d2b..43cd0995c1 100644
--- a/crates/biome_js_analyze/src/lint/suspicious/use_iterable_callback_return.rs
+++ b/crates/biome_js_analyze/src/lint/suspicious/use_iterable_callback_return.rs
@@ -57,9 +57,15 @@ declare_lint_rule! {
     /// });
     /// ```
     ///
-    /// ```js,expect_diagnostic
+    /// ```js
     /// [].forEach(() => {
-    ///     return 1; // Should not return a value
+    ///     // No return value, which is correct
+    /// });
+    /// ```
+    ///
+    /// ```js,expect_diagnostic
+    /// [].filter(() => {
+    ///     // Missing required return value
     /// });
     /// ```
     ///
@@ -72,14 +78,37 @@ declare_lint_rule! {
     /// ```
     ///
     /// ```js
-    /// [].forEach(() => {
-    ///     // No return value, which is correct
-    /// });
+    /// [].forEach(() => void null); // Void return value, which doesn't trigger the rule
     /// ```
     ///
-    /// ```js
-    /// [].forEach(() => void null); // Void return value, which doesn't trigger the rule
+    /// ## Options
+    ///
+    /// ### `checkForEach`
+    ///
+    /// **Since `v2.4.0**
+    ///
+    /// Default: `true`
+    ///
+    /// When set to `false`, the rule will skip `forEach` callbacks that return a value.
+    ///
+    /// ### Examples
+    ///
+    /// ```json,options
+    /// {
+    ///     "options": {
+    ///         "checkForEach": false
+    ///     }
+    /// }
     /// ```
+    ///
+    /// ```js,use_options
+    /// [1, 2, 3].forEach((el) => {
+    ///     return el * 2;
+    /// });
+    /// ```
+    ///
+    /// When `checkForEach` is `false` (default), the above code will not trigger any diagnostic.
+    ///
     pub UseIterableCallbackReturn {
         version: "2.0.0",
         name: "useIterableCallbackReturn",
@@ -128,6 +157,10 @@ impl Rule for UseIterableCallbackReturn {
             .and_then(|member| member.as_js_name().cloned())
             .and_then(|name| name.value_token().ok())?;
 
+        if !ctx.options().check_for_each() && member_name.text_trimmed() == "forEach" {
+            return None;
+        }
+
         let method_config = ITERABLE_METHOD_INFOS.get(member_name.text_trimmed())?;
 
         let arg_position = argument_list
diff --git a/crates/biome_js_analyze/src/services/module_graph.rs b/crates/biome_js_analyze/src/services/module_graph.rs
index a44c7d10aa..90c4852f05 100644
--- a/crates/biome_js_analyze/src/services/module_graph.rs
+++ b/crates/biome_js_analyze/src/services/module_graph.rs
@@ -38,7 +38,7 @@ impl FromServices for ModuleGraphService {
                 .any(|d| d == &RuleDomain::Project);
             if !has_project_domain {
                 panic!(
-                    "The rule {rule_key} uses ModuleGraphService, but it is not in the project domain."
+                    "The rule {rule_key} uses ModuleGraphService, but it is not in the Project domain."
                 );
             }
         }
diff --git a/crates/biome_js_analyze/src/services/typed.rs b/crates/biome_js_analyze/src/services/typed.rs
index b141532715..92d81ca3dd 100644
--- a/crates/biome_js_analyze/src/services/typed.rs
+++ b/crates/biome_js_analyze/src/services/typed.rs
@@ -68,10 +68,10 @@ impl FromServices for TypedService {
             let has_project_domain = rule_metadata
                 .domains
                 .iter()
-                .any(|d| d == &RuleDomain::Project);
+                .any(|d| d == &RuleDomain::Types);
             if !has_project_domain {
                 panic!(
-                    "The rule {rule_key} uses TypedService, but it is not in the project domain."
+                    "The rule {rule_key} uses TypedService, but it is not in the TypeAware domain."
                 );
             }
         }
diff --git a/crates/biome_js_analyze/tests/spec_tests.rs b/crates/biome_js_analyze/tests/spec_tests.rs
index 89f1516bc4..ef64da5208 100644
--- a/crates/biome_js_analyze/tests/spec_tests.rs
+++ b/crates/biome_js_analyze/tests/spec_tests.rs
@@ -58,7 +58,8 @@ impl RegistryVisitor<JsLanguage> for NeedsModuleGraph<'_> {
         if self
             .enabled_rules
             .is_some_and(|enabled_rules| enabled_rules.contains(&filter))
-            && R::METADATA.domains.contains(&RuleDomain::Project)
+            && (R::METADATA.domains.contains(&RuleDomain::Project)
+                || R::METADATA.domains.contains(&RuleDomain::Types))
         {
             self.needs_module_graph = true;
         }
diff --git a/crates/biome_js_analyze/tests/specs/style/useComponentExportOnlyModules/valid_component_referenced_in_export.jsx b/crates/biome_js_analyze/tests/specs/style/useComponentExportOnlyModules/valid_component_referenced_in_export.jsx
new file mode 100644
index 0000000000..5054717686
--- /dev/null
+++ b/crates/biome_js_analyze/tests/specs/style/useComponentExportOnlyModules/valid_component_referenced_in_export.jsx
@@ -0,0 +1,12 @@
+/* should not generate diagnostics */
+
+// TanStack Router pattern - component referenced in exported object
+import { createFileRoute } from '@tanstack/react-router'
+
+export const Route = createFileRoute('/')({
+  component: HomeComponent,
+})
+
+function HomeComponent() {
+  return <div>Home</div>
+}
diff --git a/crates/biome_js_analyze/tests/specs/style/useComponentExportOnlyModules/valid_component_referenced_in_export.jsx.snap b/crates/biome_js_analyze/tests/specs/style/useComponentExportOnlyModules/valid_component_referenced_in_export.jsx.snap
new file mode 100644
index 0000000000..384cf6d49e
--- /dev/null
+++ b/crates/biome_js_analyze/tests/specs/style/useComponentExportOnlyModules/valid_component_referenced_in_export.jsx.snap
@@ -0,0 +1,20 @@
+---
+source: crates/biome_js_analyze/tests/spec_tests.rs
+expression: valid_component_referenced_in_export.jsx
+---
+# Input
+```jsx
+/* should not generate diagnostics */
+
+// TanStack Router pattern - component referenced in exported object
+import { createFileRoute } from '@tanstack/react-router'
+
+export const Route = createFileRoute('/')({
+  component: HomeComponent,
+})
+
+function HomeComponent() {
+  return <div>Home</div>
+}
+
+```
diff --git a/crates/biome_js_analyze/tests/specs/style/useComponentExportOnlyModules/valid_component_shorthand_in_export.jsx b/crates/biome_js_analyze/tests/specs/style/useComponentExportOnlyModules/valid_component_shorthand_in_export.jsx
new file mode 100644
index 0000000000..e9ee6824eb
--- /dev/null
+++ b/crates/biome_js_analyze/tests/specs/style/useComponentExportOnlyModules/valid_component_shorthand_in_export.jsx
@@ -0,0 +1,10 @@
+/* should not generate diagnostics */
+
+// Shorthand property pattern - component referenced via shorthand syntax
+export const config = {
+  HomeComponent,
+}
+
+function HomeComponent() {
+  return <div>Home</div>
+}
diff --git a/crates/biome_js_analyze/tests/specs/style/useComponentExportOnlyModules/valid_component_shorthand_in_export.jsx.snap b/crates/biome_js_analyze/tests/specs/style/useComponentExportOnlyModules/valid_component_shorthand_in_export.jsx.snap
new file mode 100644
index 0000000000..31951b6ec3
--- /dev/null
+++ b/crates/biome_js_analyze/tests/specs/style/useComponentExportOnlyModules/valid_component_shorthand_in_export.jsx.snap
@@ -0,0 +1,18 @@
+---
+source: crates/biome_js_analyze/tests/spec_tests.rs
+expression: valid_component_shorthand_in_export.jsx
+---
+# Input
+```jsx
+/* should not generate diagnostics */
+
+// Shorthand property pattern - component referenced via shorthand syntax
+export const config = {
+  HomeComponent,
+}
+
+function HomeComponent() {
+  return <div>Home</div>
+}
+
+```
diff --git a/crates/biome_js_analyze/tests/specs/suspicious/useIterableCallbackReturn/checkForEachFalse.js b/crates/biome_js_analyze/tests/specs/suspicious/useIterableCallbackReturn/checkForEachFalse.js
new file mode 100644
index 0000000000..a5f9845b6a
--- /dev/null
+++ b/crates/biome_js_analyze/tests/specs/suspicious/useIterableCallbackReturn/checkForEachFalse.js
@@ -0,0 +1,5 @@
+// should not generate diagnostics
+
+[1, 2, 3].forEach(function(el) {
+    return el * 2;
+});
diff --git a/crates/biome_js_analyze/tests/specs/suspicious/useIterableCallbackReturn/checkForEachFalse.js.snap b/crates/biome_js_analyze/tests/specs/suspicious/useIterableCallbackReturn/checkForEachFalse.js.snap
new file mode 100644
index 0000000000..f9791673aa
--- /dev/null
+++ b/crates/biome_js_analyze/tests/specs/suspicious/useIterableCallbackReturn/checkForEachFalse.js.snap
@@ -0,0 +1,13 @@
+---
+source: crates/biome_js_analyze/tests/spec_tests.rs
+expression: checkForEachFalse.js
+---
+# Input
+```js
+// should not generate diagnostics
+
+[1, 2, 3].forEach(function(el) {
+    return el * 2;
+});
+
+```
diff --git a/crates/biome_js_analyze/tests/specs/suspicious/useIterableCallbackReturn/checkForEachFalse.options.json b/crates/biome_js_analyze/tests/specs/suspicious/useIterableCallbackReturn/checkForEachFalse.options.json
new file mode 100644
index 0000000000..f0baae1a87
--- /dev/null
+++ b/crates/biome_js_analyze/tests/specs/suspicious/useIterableCallbackReturn/checkForEachFalse.options.json
@@ -0,0 +1,15 @@
+{
+	"$schema": "../../../../../../../packages/@biomejs/biome/configuration_schema.json",
+	"linter": {
+		"rules": {
+			"suspicious": {
+				"useIterableCallbackReturn": {
+					"level": "error",
+					"options": {
+						"checkForEach": false
+					}
+				}
+			}
+		}
+	}
+}
\ No newline at end of file
diff --git a/crates/biome_js_analyze/tests/specs/suspicious/useIterableCallbackReturn/checkForEachTrue.js b/crates/biome_js_analyze/tests/specs/suspicious/useIterableCallbackReturn/checkForEachTrue.js
new file mode 100644
index 0000000000..180b517d7e
--- /dev/null
+++ b/crates/biome_js_analyze/tests/specs/suspicious/useIterableCallbackReturn/checkForEachTrue.js
@@ -0,0 +1,28 @@
+// should generate diagnostics
+
+[1, 2, 3].forEach(function(el) {
+    return el * 2;
+});
+
+// Invalid: forEach with arrow function implicit return
+[1, 2, 3].forEach((el) => el * 2);
+
+// Invalid: forEach with conditional return
+[1, 2, 3].forEach(function(el) {
+    if (el > 1) {
+        return el;
+    }
+});
+
+// Valid: forEach with no return value
+[1, 2, 3].forEach(function(el) {
+    console.log(el);
+});
+
+// Valid: forEach with empty return
+[1, 2, 3].forEach(function(el) {
+    if (el > 10) {
+        return;
+    }
+    console.log(el);
+});
diff --git a/crates/biome_js_analyze/tests/specs/suspicious/useIterableCallbackReturn/checkForEachTrue.js.snap b/crates/biome_js_analyze/tests/specs/suspicious/useIterableCallbackReturn/checkForEachTrue.js.snap
new file mode 100644
index 0000000000..7dcf84bbf3
--- /dev/null
+++ b/crates/biome_js_analyze/tests/specs/suspicious/useIterableCallbackReturn/checkForEachTrue.js.snap
@@ -0,0 +1,110 @@
+---
+source: crates/biome_js_analyze/tests/spec_tests.rs
+expression: checkForEachTrue.js
+---
+# Input
+```js
+// should generate diagnostics
+
+[1, 2, 3].forEach(function(el) {
+    return el * 2;
+});
+
+// Invalid: forEach with arrow function implicit return
+[1, 2, 3].forEach((el) => el * 2);
+
+// Invalid: forEach with conditional return
+[1, 2, 3].forEach(function(el) {
+    if (el > 1) {
+        return el;
+    }
+});
+
+// Valid: forEach with no return value
+[1, 2, 3].forEach(function(el) {
+    console.log(el);
+});
+
+// Valid: forEach with empty return
+[1, 2, 3].forEach(function(el) {
+    if (el > 10) {
+        return;
+    }
+    console.log(el);
+});
+
+```
+
+# Diagnostics
+```
+checkForEachTrue.js:3:11 lint/suspicious/useIterableCallbackReturn ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
+
+  × This callback passed to forEach() iterable method should not return a value.
+  
+    1 │ // should generate diagnostics
+    2 │ 
+  > 3 │ [1, 2, 3].forEach(function(el) {
+      │           ^^^^^^^
+    4 │     return el * 2;
+    5 │ });
+  
+  i Either remove this return or remove the returned value.
+  
+    1 │ // should generate diagnostics
+    2 │ 
+  > 3 │ [1, 2, 3].forEach(function(el) {
+      │                                 
+  > 4 │     return el * 2;
+      │     ^^^^^^^
+    5 │ });
+    6 │ 
+  
+
+```
+
+```
+checkForEachTrue.js:8:11 lint/suspicious/useIterableCallbackReturn ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
+
+  × This callback passed to forEach() iterable method should not return a value.
+  
+     7 │ // Invalid: forEach with arrow function implicit return
+   > 8 │ [1, 2, 3].forEach((el) => el * 2);
+       │           ^^^^^^^
+     9 │ 
+    10 │ // Invalid: forEach with conditional return
+  
+  i Either remove this return or remove the returned value.
+  
+     7 │ // Invalid: forEach with arrow function implicit return
+   > 8 │ [1, 2, 3].forEach((el) => el * 2);
+       │                           ^^^^^^
+     9 │ 
+    10 │ // Invalid: forEach with conditional return
+  
+
+```
+
+```
+checkForEachTrue.js:11:11 lint/suspicious/useIterableCallbackReturn ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
+
+  × This callback passed to forEach() iterable method should not return a value.
+  
+    10 │ // Invalid: forEach with conditional return
+  > 11 │ [1, 2, 3].forEach(function(el) {
+       │           ^^^^^^^
+    12 │     if (el > 1) {
+    13 │         return el;
+  
+  i Either remove this return or remove the returned value.
+  
+    10 │ // Invalid: forEach with conditional return
+    11 │ [1, 2, 3].forEach(function(el) {
+  > 12 │     if (el > 1) {
+       │                  
+  > 13 │         return el;
+       │         ^^^^^^^
+    14 │     }
+    15 │ });
+  
+
+```
diff --git a/crates/biome_js_analyze/tests/specs/suspicious/useIterableCallbackReturn/checkForEachTrue.options.json b/crates/biome_js_analyze/tests/specs/suspicious/useIterableCallbackReturn/checkForEachTrue.options.json
new file mode 100644
index 0000000000..fa05c560f8
--- /dev/null
+++ b/crates/biome_js_analyze/tests/specs/suspicious/useIterableCallbackReturn/checkForEachTrue.options.json
@@ -0,0 +1,15 @@
+{
+	"$schema": "../../../../../../../packages/@biomejs/biome/configuration_schema.json",
+	"linter": {
+		"rules": {
+			"suspicious": {
+				"useIterableCallbackReturn": {
+					"level": "error",
+					"options": {
+						"checkForEach": true
+					}
+				}
+			}
+		}
+	}
+}
\ No newline at end of file
diff --git a/crates/biome_lsp/src/session.rs b/crates/biome_lsp/src/session.rs
index 89fe57cef6..3a9c90a2b8 100644
--- a/crates/biome_lsp/src/session.rs
+++ b/crates/biome_lsp/src/session.rs
@@ -17,6 +17,7 @@ use biome_service::configuration::{
     LoadedConfiguration, ProjectScanComputer, load_configuration, load_editorconfig,
 };
 use biome_service::projects::ProjectKey;
+use biome_service::settings::ModuleGraphResolutionKind;
 use biome_service::workspace::{
     FeaturesBuilder, OpenProjectParams, OpenProjectResult, PullDiagnosticsParams,
     SupportsFeatureParams,
@@ -741,7 +742,7 @@ impl Session {
         spawn_blocking(move || {
             let result = session.workspace.scan_project(ScanProjectParams {
                 project_key,
-                watch: scan_kind.is_project(),
+                watch: scan_kind.is_project() || scan_kind.is_type_aware(),
                 force,
                 scan_kind,
                 verbose: false,
@@ -960,6 +961,7 @@ impl Session {
                 .map(BiomePath::from),
             configuration,
             extended_configurations: Default::default(),
+            module_graph_resolution_kind: ModuleGraphResolutionKind::from(&scan_kind),
         });
 
         self.insert_and_scan_project(project_key, path.into(), scan_kind, force)
diff --git a/crates/biome_module_graph/benches/module_graph.rs b/crates/biome_module_graph/benches/module_graph.rs
index 9da270cb04..20e59ec9b1 100644
--- a/crates/biome_module_graph/benches/module_graph.rs
+++ b/crates/biome_module_graph/benches/module_graph.rs
@@ -73,6 +73,7 @@ fn bench_index_d_ts(bencher: Bencher, name: &str) {
                 &fs,
                 &ProjectLayout::default(),
                 &[(&path, root)],
+                true,
             );
             divan::black_box(&module_graph);
         });
diff --git a/crates/biome_module_graph/src/js_module_info.rs b/crates/biome_module_graph/src/js_module_info.rs
index 100f6f048f..84f9a407d8 100644
--- a/crates/biome_module_graph/src/js_module_info.rs
+++ b/crates/biome_module_graph/src/js_module_info.rs
@@ -207,6 +207,9 @@ pub struct JsModuleInfoInner {
 
     /// Diagnostics emitted during the resolution of the module
     pub(crate) diagnostics: Vec<ModuleDiagnostic>,
+
+    /// Whether type inference was enabled when this module info was created
+    pub(crate) infer_types: bool,
 }
 
 #[derive(Debug, Default)]
diff --git a/crates/biome_module_graph/src/js_module_info/collector.rs b/crates/biome_module_graph/src/js_module_info/collector.rs
index d86fde17d8..f099ad1147 100644
--- a/crates/biome_module_graph/src/js_module_info/collector.rs
+++ b/crates/biome_module_graph/src/js_module_info/collector.rs
@@ -100,6 +100,9 @@ pub(super) struct JsModuleInfoCollector {
 
     /// Diagnostics emitted during the collection of module graph information
     diagnostics: Vec<JsModuleInfoDiagnostic>,
+
+    /// Whether to enable type inference when finalizing the module info
+    infer_types: bool,
 }
 
 /// Intermediary representation for an exported symbol.
@@ -556,14 +559,16 @@ impl JsModuleInfoCollector {
                 .collect(),
         );
 
-        self.infer_all_types(&scope_by_range);
-        self.resolve_all_and_downgrade_project_references();
+        if self.infer_types {
+            self.infer_all_types(&scope_by_range);
+            self.resolve_all_and_downgrade_project_references();
 
-        // Purging before flattening will save us from duplicate work during
-        // flattening. We'll purge again after for a final cleanup.
-        self.purge_redundant_types();
-        self.flatten_all();
-        self.purge_redundant_types();
+            // Purging before flattening will save us from duplicate work during
+            // flattening. We'll purge again after for a final cleanup.
+            self.purge_redundant_types();
+            self.flatten_all();
+            self.purge_redundant_types();
+        }
 
         let exports = self.collect_exports();
 
@@ -1114,7 +1119,8 @@ impl TypeResolver for JsModuleInfoCollector {
 }
 
 impl JsModuleInfo {
-    pub(super) fn new(mut collector: JsModuleInfoCollector) -> Self {
+    pub(super) fn new(mut collector: JsModuleInfoCollector, infer_types: bool) -> Self {
+        collector.infer_types = infer_types;
         let (exports, scope_by_range) = collector.finalise();
 
         Self(Arc::new(JsModuleInfoInner {
@@ -1129,6 +1135,7 @@ impl JsModuleInfo {
             scope_by_range,
             types: collector.types.into(),
             diagnostics: collector.diagnostics.into_iter().map(Into::into).collect(),
+            infer_types: collector.infer_types,
         }))
     }
 }
diff --git a/crates/biome_module_graph/src/js_module_info/module_resolver.rs b/crates/biome_module_graph/src/js_module_info/module_resolver.rs
index df52749be1..f0de32b388 100644
--- a/crates/biome_module_graph/src/js_module_info/module_resolver.rs
+++ b/crates/biome_module_graph/src/js_module_info/module_resolver.rs
@@ -74,19 +74,26 @@ pub struct ModuleResolver {
 
 impl ModuleResolver {
     pub fn for_module(module_info: JsModuleInfo, module_graph: Arc<ModuleGraph>) -> Self {
-        let num_initial_types = module_info.types.len();
+        let infer_types = module_info.infer_types;
 
+        let types = if infer_types {
+            TypeStore::with_capacity(module_info.types.len())
+        } else {
+            TypeStore::default()
+        };
         let mut resolver = Self {
             module_graph,
             modules: vec![module_info],
             modules_by_path: Default::default(),
             expressions: Default::default(),
-            types: TypeStore::with_capacity(num_initial_types),
+            types,
             type_id_map: Default::default(),
             diagnostics: Default::default(),
         };
 
-        resolver.run_inference();
+        if infer_types {
+            resolver.run_inference();
+        }
         resolver
     }
 
diff --git a/crates/biome_module_graph/src/js_module_info/visitor.rs b/crates/biome_module_graph/src/js_module_info/visitor.rs
index 625523a523..1ebea29642 100644
--- a/crates/biome_module_graph/src/js_module_info/visitor.rs
+++ b/crates/biome_module_graph/src/js_module_info/visitor.rs
@@ -30,14 +30,21 @@ pub(crate) struct JsModuleVisitor<'a> {
     root: AnyJsRoot,
     directory: &'a Utf8Path,
     fs_proxy: &'a ModuleGraphFsProxy<'a>,
+    infer_types: bool,
 }
 
 impl<'a> JsModuleVisitor<'a> {
-    pub fn new(root: AnyJsRoot, directory: &'a Utf8Path, fs_proxy: &'a ModuleGraphFsProxy) -> Self {
+    pub fn new(
+        root: AnyJsRoot,
+        directory: &'a Utf8Path,
+        fs_proxy: &'a ModuleGraphFsProxy,
+        infer_types: bool,
+    ) -> Self {
         Self {
             root,
             directory,
             fs_proxy,
+            infer_types,
         }
     }
 
@@ -62,7 +69,7 @@ impl<'a> JsModuleVisitor<'a> {
             }
         }
 
-        JsModuleInfo::new(collector)
+        JsModuleInfo::new(collector, self.infer_types)
     }
 
     fn visit_import(&self, node: AnyJsImportLike, collector: &mut JsModuleInfoCollector) {
diff --git a/crates/biome_module_graph/src/module_graph.rs b/crates/biome_module_graph/src/module_graph.rs
index 4a17a1d2ac..b994e6976e 100644
--- a/crates/biome_module_graph/src/module_graph.rs
+++ b/crates/biome_module_graph/src/module_graph.rs
@@ -82,6 +82,7 @@ impl ModuleGraph {
         fs: &dyn FsWithResolverProxy,
         project_layout: &ProjectLayout,
         added_or_updated_paths: &[(&BiomePath, AnyJsRoot)],
+        enable_type_inference: bool,
     ) -> (ModuleDependencies, Vec<ModuleDiagnostic>) {
         // Make sure all directories are registered for the added/updated paths.
         let path_info = self.path_info.pin();
@@ -109,7 +110,8 @@ impl ModuleGraph {
         let modules = self.data.pin();
         for (path, root) in added_or_updated_paths {
             let directory = path.parent().unwrap_or(path);
-            let visitor = JsModuleVisitor::new(root.clone(), directory, &fs_proxy);
+            let visitor =
+                JsModuleVisitor::new(root.clone(), directory, &fs_proxy, enable_type_inference);
 
             let module_info = visitor.collect_info();
             for import_path in module_info.all_import_paths() {
diff --git a/crates/biome_module_graph/tests/spec_tests.rs b/crates/biome_module_graph/tests/spec_tests.rs
index 477bb55c42..59f24fcac6 100644
--- a/crates/biome_module_graph/tests/spec_tests.rs
+++ b/crates/biome_module_graph/tests/spec_tests.rs
@@ -14,14 +14,13 @@ use biome_jsdoc_comment::JsdocComment;
 use biome_json_parser::{JsonParserOptions, parse_json};
 use biome_json_value::{JsonObject, JsonString};
 use biome_module_graph::{
-    CssImport, ImportSymbol, JsExport, JsImport, JsImportPath, JsImportPhase,
-    JsModuleInfoDiagnostic, JsReexport, ModuleDiagnostic, ModuleGraph, ModuleResolver,
-    ResolvedPath,
+    ImportSymbol, JsExport, JsImport, JsImportPath, JsImportPhase, JsModuleInfoDiagnostic,
+    JsReexport, ModuleDiagnostic, ModuleGraph, ModuleResolver, ResolvedPath,
 };
 use biome_package::{Dependencies, PackageJson};
 use biome_project_layout::ProjectLayout;
 use biome_rowan::Text;
-use biome_test_utils::{get_added_js_paths, get_css_added_paths};
+use biome_test_utils::get_added_js_paths;
 use camino::{Utf8Path, Utf8PathBuf};
 use walkdir::WalkDir;
 
@@ -140,7 +139,7 @@ fn test_type_flattening_does_not_explode_on_recursive_parent_element_pattern() {
     let added_paths = get_added_js_paths(&fs, &added_paths);
 
     let module_graph = ModuleGraph::default();
-    module_graph.update_graph_for_js_paths(&fs, &project_layout, &added_paths);
+    module_graph.update_graph_for_js_paths(&fs, &project_layout, &added_paths, true);
 
     let data = module_graph.data();
     let module = data.get(Utf8Path::new("/src/repro.ts")).unwrap();
@@ -165,7 +164,7 @@ fn test_resolve_relative_import() {
     let added_paths = get_added_js_paths(&fs, &added_paths);
 
     let module_graph = ModuleGraph::default();
-    module_graph.update_graph_for_js_paths(&fs, &project_layout, &added_paths);
+    module_graph.update_graph_for_js_paths(&fs, &project_layout, &added_paths, true);
 
     let imports = module_graph.data();
     let file_imports = imports.get(Utf8Path::new("/src/index.ts")).unwrap();
@@ -192,7 +191,7 @@ fn test_resolve_package_import() {
     let added_paths = get_added_js_paths(&fs, &added_paths);
 
     let module_graph = ModuleGraph::default();
-    module_graph.update_graph_for_js_paths(&fs, &project_layout, &added_paths);
+    module_graph.update_graph_for_js_paths(&fs, &project_layout, &added_paths, true);
 
     let imports = module_graph.data();
     let file_imports = imports.get(Utf8Path::new("/src/index.ts")).unwrap();
@@ -219,7 +218,7 @@ fn test_import_through_path_alias() {
     let added_paths = get_added_js_paths(&fs, &added_paths);
 
     let module_graph = ModuleGraph::default();
-    module_graph.update_graph_for_js_paths(&fs, &project_layout, &added_paths);
+    module_graph.update_graph_for_js_paths(&fs, &project_layout, &added_paths, true);
 
     let imports = module_graph.data();
     let file_imports = imports.get(Utf8Path::new("/src/index.ts")).unwrap();
@@ -295,7 +294,7 @@ fn test_resolve_package_import_in_monorepo_fixtures() {
     let added_paths = get_added_js_paths(&fs, &added_paths);
 
     let module_graph = ModuleGraph::default();
-    module_graph.update_graph_for_js_paths(&fs, &project_layout, &added_paths);
+    module_graph.update_graph_for_js_paths(&fs, &project_layout, &added_paths, true);
 
     let imports = module_graph.data();
     let file_imports = imports
@@ -343,7 +342,7 @@ fn test_export_referenced_function() {
     let added_paths = get_added_js_paths(&fs, &added_paths);
 
     let module_graph = ModuleGraph::default();
-    module_graph.update_graph_for_js_paths(&fs, &ProjectLayout::default(), &added_paths);
+    module_graph.update_graph_for_js_paths(&fs, &ProjectLayout::default(), &added_paths, true);
 
     let snapshot = ModuleGraphSnapshot::new(&module_graph, &fs);
 
@@ -368,7 +367,7 @@ fn test_export_default_function_declaration() {
     let added_paths = get_added_js_paths(&fs, &added_paths);
 
     let module_graph = ModuleGraph::default();
-    module_graph.update_graph_for_js_paths(&fs, &ProjectLayout::default(), &added_paths);
+    module_graph.update_graph_for_js_paths(&fs, &ProjectLayout::default(), &added_paths, true);
 
     let snapshot = ModuleGraphSnapshot::new(&module_graph, &fs);
     snapshot.assert_snapshot("test_export_default_function_declaration");
@@ -396,7 +395,7 @@ fn test_export_const_type_declaration_with_namespace() {
     let added_paths = get_added_js_paths(&fs, &added_paths);
 
     let module_graph = ModuleGraph::default();
-    module_graph.update_graph_for_js_paths(&fs, &ProjectLayout::default(), &added_paths);
+    module_graph.update_graph_for_js_paths(&fs, &ProjectLayout::default(), &added_paths, true);
 
     let snapshot = ModuleGraphSnapshot::new(&module_graph, &fs);
     snapshot.assert_snapshot("test_export_const_type_declaration_with_namespace");
@@ -483,7 +482,7 @@ fn test_resolve_exports() {
     let added_paths = get_added_js_paths(&fs, &added_paths);
 
     let module_graph = ModuleGraph::default();
-    module_graph.update_graph_for_js_paths(&fs, &project_layout, &added_paths);
+    module_graph.update_graph_for_js_paths(&fs, &project_layout, &added_paths, true);
 
     let dependency_data = module_graph.data();
     let data = dependency_data.get(Utf8Path::new("/src/index.ts")).unwrap();
@@ -593,7 +592,7 @@ fn test_resolve_export_types() {
     let added_paths = get_added_js_paths(&fs, &added_paths);
 
     let module_graph = ModuleGraph::default();
-    module_graph.update_graph_for_js_paths(&fs, &ProjectLayout::default(), &added_paths);
+    module_graph.update_graph_for_js_paths(&fs, &ProjectLayout::default(), &added_paths, true);
 
     let snapshot = ModuleGraphSnapshot::new(&module_graph, &fs);
     snapshot.assert_snapshot("test_resolve_export_types");
@@ -621,7 +620,7 @@ export const promise = makePromiseCb();
     let added_paths = get_added_js_paths(&fs, &added_paths);
 
     let module_graph = Arc::new(ModuleGraph::default());
-    module_graph.update_graph_for_js_paths(&fs, &ProjectLayout::default(), &added_paths);
+    module_graph.update_graph_for_js_paths(&fs, &ProjectLayout::default(), &added_paths, true);
 
     let index_module = module_graph
         .js_module_info_for_path(Utf8Path::new("/src/index.ts"))
@@ -654,7 +653,7 @@ fn test_resolve_generic_mapped_value() {
     let added_paths = get_added_js_paths(&fs, &added_paths);
 
     let module_graph = Arc::new(ModuleGraph::default());
-    module_graph.update_graph_for_js_paths(&fs, &ProjectLayout::default(), &added_paths);
+    module_graph.update_graph_for_js_paths(&fs, &ProjectLayout::default(), &added_paths, true);
 
     let index_module = module_graph
         .js_module_info_for_path(Utf8Path::new("/src/index.ts"))
@@ -716,7 +715,7 @@ fn test_resolve_generic_return_value_with_multiple_modules() {
     let added_paths = get_added_js_paths(&fs, &added_paths);
 
     let module_graph = Arc::new(ModuleGraph::default());
-    module_graph.update_graph_for_js_paths(&fs, &ProjectLayout::default(), &added_paths);
+    module_graph.update_graph_for_js_paths(&fs, &ProjectLayout::default(), &added_paths, true);
 
     let index_module = module_graph
         .js_module_info_for_path(Utf8Path::new("/src/index.ts"))
@@ -763,7 +762,7 @@ fn test_resolve_import_as_namespace() {
     let added_paths = get_added_js_paths(&fs, &added_paths);
 
     let module_graph = Arc::new(ModuleGraph::default());
-    module_graph.update_graph_for_js_paths(&fs, &ProjectLayout::default(), &added_paths);
+    module_graph.update_graph_for_js_paths(&fs, &ProjectLayout::default(), &added_paths, true);
 
     let index_module = module_graph
         .js_module_info_for_path(Utf8Path::new("/src/index.ts"))
@@ -807,7 +806,7 @@ fn test_resolve_nested_function_call_with_namespace_in_return_type() {
     let added_paths = get_added_js_paths(&fs, &added_paths);
 
     let module_graph = Arc::new(ModuleGraph::default());
-    module_graph.update_graph_for_js_paths(&fs, &ProjectLayout::default(), &added_paths);
+    module_graph.update_graph_for_js_paths(&fs, &ProjectLayout::default(), &added_paths, true);
 
     let index_module = module_graph
         .js_module_info_for_path(Utf8Path::new("/src/index.ts"))
@@ -840,7 +839,7 @@ fn test_resolve_return_value_of_function() {
     let added_paths = get_added_js_paths(&fs, &added_paths);
 
     let module_graph = Arc::new(ModuleGraph::default());
-    module_graph.update_graph_for_js_paths(&fs, &ProjectLayout::default(), &added_paths);
+    module_graph.update_graph_for_js_paths(&fs, &ProjectLayout::default(), &added_paths, true);
 
     let index_module = module_graph
         .js_module_info_for_path(Utf8Path::new("/src/index.ts"))
@@ -898,7 +897,7 @@ fn test_resolve_type_of_property_with_getter() {
     let added_paths = get_added_js_paths(&fs, &added_paths);
 
     let module_graph = Arc::new(ModuleGraph::default());
-    module_graph.update_graph_for_js_paths(&fs, &ProjectLayout::default(), &added_paths);
+    module_graph.update_graph_for_js_paths(&fs, &ProjectLayout::default(), &added_paths, true);
 
     let index_module = module_graph
         .js_module_info_for_path(Utf8Path::new("/src/index.ts"))
@@ -991,7 +990,7 @@ fn class_this_test_helper(case_name: &str, prefix: &str) {
     let added_paths = get_added_js_paths(&fs, &added_paths);
 
     let module_graph = Arc::new(ModuleGraph::default());
-    module_graph.update_graph_for_js_paths(&fs, &ProjectLayout::default(), &added_paths);
+    module_graph.update_graph_for_js_paths(&fs, &ProjectLayout::default(), &added_paths, true);
 
     let index_module = module_graph
         .js_module_info_for_path(Utf8Path::new("/src/index.ts"))
@@ -1066,7 +1065,7 @@ fn test_resolve_type_of_this_in_object() {
     let added_paths = get_added_js_paths(&fs, &added_paths);
 
     let module_graph = Arc::new(ModuleGraph::default());
-    module_graph.update_graph_for_js_paths(&fs, &ProjectLayout::default(), &added_paths);
+    module_graph.update_graph_for_js_paths(&fs, &ProjectLayout::default(), &added_paths, true);
 
     let index_module = module_graph
         .js_module_info_for_path(Utf8Path::new("/src/index.ts"))
@@ -1158,7 +1157,7 @@ fn test_resolve_type_of_this_in_class_wrong_scope() {
     let added_paths = get_added_js_paths(&fs, &added_paths);
 
     let module_graph = Arc::new(ModuleGraph::default());
-    module_graph.update_graph_for_js_paths(&fs, &ProjectLayout::default(), &added_paths);
+    module_graph.update_graph_for_js_paths(&fs, &ProjectLayout::default(), &added_paths, true);
 
     let index_module = module_graph
         .js_module_info_for_path(Utf8Path::new("/src/index.ts"))
@@ -1199,7 +1198,7 @@ fn test_resolve_promise_export() {
     let added_paths = get_added_js_paths(&fs, &added_paths);
 
     let module_graph = ModuleGraph::default();
-    module_graph.update_graph_for_js_paths(&fs, &ProjectLayout::default(), &added_paths);
+    module_graph.update_graph_for_js_paths(&fs, &ProjectLayout::default(), &added_paths, true);
 
     let snapshot = ModuleGraphSnapshot::new(&module_graph, &fs);
     snapshot.assert_snapshot("test_resolve_promise_export");
@@ -1229,7 +1228,7 @@ export { A, B };
     let added_paths = get_added_js_paths(&fs, &added_paths);
 
     let module_graph = ModuleGraph::default();
-    module_graph.update_graph_for_js_paths(&fs, &ProjectLayout::default(), &added_paths);
+    module_graph.update_graph_for_js_paths(&fs, &ProjectLayout::default(), &added_paths, true);
 
     let snapshot = ModuleGraphSnapshot::new(&module_graph, &fs);
     snapshot.assert_snapshot("test_resolve_merged_types");
@@ -1252,7 +1251,7 @@ export type Foo = Foo.Bar;
     let added_paths = get_added_js_paths(&fs, &added_paths);
 
     let module_graph = ModuleGraph::default();
-    module_graph.update_graph_for_js_paths(&fs, &ProjectLayout::default(), &added_paths);
+    module_graph.update_graph_for_js_paths(&fs, &ProjectLayout::default(), &added_paths, true);
 
     let snapshot = ModuleGraphSnapshot::new(&module_graph, &fs);
 
@@ -1321,7 +1320,7 @@ export const codes: {
     let added_paths = get_added_js_paths(&fs, &added_paths);
 
     let module_graph = ModuleGraph::default();
-    module_graph.update_graph_for_js_paths(&fs, &ProjectLayout::default(), &added_paths);
+    module_graph.update_graph_for_js_paths(&fs, &ProjectLayout::default(), &added_paths, true);
 
     let snapshot = ModuleGraphSnapshot::new(&module_graph, &fs);
     snapshot.assert_snapshot("test_resolve_recursive_looking_country_info");
@@ -1500,7 +1499,7 @@ export = vfile
     let added_paths = get_added_js_paths(&fs, &added_paths);
 
     let module_graph = ModuleGraph::default();
-    module_graph.update_graph_for_js_paths(&fs, &ProjectLayout::default(), &added_paths);
+    module_graph.update_graph_for_js_paths(&fs, &ProjectLayout::default(), &added_paths, true);
 
     let snapshot = ModuleGraphSnapshot::new(&module_graph, &fs);
     snapshot.assert_snapshot("test_resolve_recursive_looking_vfile");
@@ -1541,7 +1540,7 @@ fn test_resolve_react_types() {
         .insert_serialized_tsconfig("/".into(), &tsconfig_json.syntax().as_send().unwrap());
 
     let module_graph = Arc::new(ModuleGraph::default());
-    module_graph.update_graph_for_js_paths(&fs, &project_layout, &added_paths);
+    module_graph.update_graph_for_js_paths(&fs, &project_layout, &added_paths, true);
 
     let index_module = module_graph
         .js_module_info_for_path(Utf8Path::new("/src/index.ts"))
@@ -1584,7 +1583,7 @@ fn test_resolve_redis_commander_types() {
     let added_paths = get_added_js_paths(&fs, &added_paths);
 
     let module_graph = Arc::new(ModuleGraph::default());
-    module_graph.update_graph_for_js_paths(&fs, &ProjectLayout::default(), &added_paths);
+    module_graph.update_graph_for_js_paths(&fs, &ProjectLayout::default(), &added_paths, true);
 
     // We previously had an issue with `RedisCommander.d.ts` that caused types
     // to be duplicated. We should look out in this snapshot that method
@@ -1642,7 +1641,7 @@ fn test_resolve_single_reexport() {
     let added_paths = get_added_js_paths(&fs, &added_paths);
 
     let module_graph = Arc::new(ModuleGraph::default());
-    module_graph.update_graph_for_js_paths(&fs, &ProjectLayout::default(), &added_paths);
+    module_graph.update_graph_for_js_paths(&fs, &ProjectLayout::default(), &added_paths, true);
 
     let index_module = module_graph
         .js_module_info_for_path(Utf8Path::new("/src/index.ts"))
@@ -1706,7 +1705,7 @@ fn test_resolve_type_of_union_from_imported_module() {
     let added_paths = get_added_js_paths(&fs, &added_paths);
 
     let module_graph = Arc::new(ModuleGraph::default());
-    module_graph.update_graph_for_js_paths(&fs, &ProjectLayout::default(), &added_paths);
+    module_graph.update_graph_for_js_paths(&fs, &ProjectLayout::default(), &added_paths, true);
 
     let index_module = module_graph
         .js_module_info_for_path(Utf8Path::new("/src/index.ts"))
@@ -1772,7 +1771,7 @@ fn test_resolve_multiple_reexports() {
     let added_paths = get_added_js_paths(&fs, &added_paths);
 
     let module_graph = Arc::new(ModuleGraph::default());
-    module_graph.update_graph_for_js_paths(&fs, &ProjectLayout::default(), &added_paths);
+    module_graph.update_graph_for_js_paths(&fs, &ProjectLayout::default(), &added_paths, true);
 
     let index_module = module_graph
         .js_module_info_for_path(Utf8Path::new("/src/index.ts"))
@@ -1824,7 +1823,7 @@ fn test_resolve_export_type_referencing_imported_type() {
     let added_paths = get_added_js_paths(&fs, &added_paths);
 
     let module_graph = ModuleGraph::default();
-    module_graph.update_graph_for_js_paths(&fs, &ProjectLayout::default(), &added_paths);
+    module_graph.update_graph_for_js_paths(&fs, &ProjectLayout::default(), &added_paths, true);
 
     let snapshot = ModuleGraphSnapshot::new(&module_graph, &fs);
     snapshot.assert_snapshot("test_resolve_export_type_referencing_imported_type");
@@ -1864,7 +1863,7 @@ fn test_resolve_promise_from_imported_function_returning_imported_promise_type()
     let added_paths = get_added_js_paths(&fs, &added_paths);
 
     let module_graph = Arc::new(ModuleGraph::default());
-    module_graph.update_graph_for_js_paths(&fs, &ProjectLayout::default(), &added_paths);
+    module_graph.update_graph_for_js_paths(&fs, &ProjectLayout::default(), &added_paths, true);
 
     let index_module = module_graph
         .js_module_info_for_path(Utf8Path::new("/src/index.ts"))
@@ -1928,7 +1927,7 @@ fn test_resolve_promise_from_imported_function_returning_reexported_promise_type
     let added_paths = get_added_js_paths(&fs, &added_paths);
 
     let module_graph = Arc::new(ModuleGraph::default());
-    module_graph.update_graph_for_js_paths(&fs, &ProjectLayout::default(), &added_paths);
+    module_graph.update_graph_for_js_paths(&fs, &ProjectLayout::default(), &added_paths, true);
 
     let index_module = module_graph
         .js_module_info_for_path(Utf8Path::new("/src/index.ts"))
@@ -1983,7 +1982,7 @@ const { mutate } = useSWRConfig();
     let added_paths = get_added_js_paths(&fs, &added_paths);
 
     let module_graph = Arc::new(ModuleGraph::default());
-    module_graph.update_graph_for_js_paths(&fs, &ProjectLayout::default(), &added_paths);
+    module_graph.update_graph_for_js_paths(&fs, &ProjectLayout::default(), &added_paths, true);
 
     let index_module = module_graph
         .js_module_info_for_path(Utf8Path::new("/src/index.ts"))
@@ -2044,7 +2043,7 @@ type Intersection = Foo & Bar;"#,
     let added_paths = get_added_js_paths(&fs, &added_paths);
 
     let module_graph = Arc::new(ModuleGraph::default());
-    module_graph.update_graph_for_js_paths(&fs, &ProjectLayout::default(), &added_paths);
+    module_graph.update_graph_for_js_paths(&fs, &ProjectLayout::default(), &added_paths, true);
 
     let index_module = module_graph
         .js_module_info_for_path(Utf8Path::new("/src/index.ts"))
@@ -2115,7 +2114,7 @@ fn test_resolve_swr_types() {
     let added_paths = get_added_js_paths(&fs, &added_paths);
 
     let module_graph = Arc::new(ModuleGraph::default());
-    module_graph.update_graph_for_js_paths(&fs, &project_layout, &added_paths);
+    module_graph.update_graph_for_js_paths(&fs, &project_layout, &added_paths, true);
 
     let index_module = module_graph
         .js_module_info_for_path(Utf8Path::new(&format!(
@@ -2185,7 +2184,7 @@ function f() {
 
     let module_graph = Arc::new(ModuleGraph::default());
 
-    module_graph.update_graph_for_js_paths(&fs, &ProjectLayout::default(), &added_paths);
+    module_graph.update_graph_for_js_paths(&fs, &ProjectLayout::default(), &added_paths, true);
 
     let index_module = module_graph
         .js_module_info_for_path(Utf8Path::new("index.ts"))
@@ -2222,7 +2221,7 @@ function g() {
 
     let module_graph = Arc::new(ModuleGraph::default());
 
-    module_graph.update_graph_for_js_paths(&fs, &ProjectLayout::default(), &added_paths);
+    module_graph.update_graph_for_js_paths(&fs, &ProjectLayout::default(), &added_paths, true);
 
     let index_module = module_graph
         .js_module_info_for_path(Utf8Path::new("index.ts"))
@@ -2237,58 +2236,6 @@ function g() {
     snapshot.assert_snapshot("test_widening_via_assignment_multiple_values");
 }
 
-#[test]
-fn resolves_css_imports_correctly() {
-    let fixtures_path = get_fixtures_path();
-
-    let fs = OsFileSystem::new(fixtures_path.clone());
-
-    let project_layout = ProjectLayout::default();
-    project_layout.insert_node_manifest(format!("{fixtures_path}/css").into(), {
-        let path = Utf8PathBuf::from(format!("{fixtures_path}/css/package.json"));
-        deserialize_from_json_str::<PackageJson>(
-            &fs.read_file_from_path(&path)
-                .expect("package.json must be readable"),
-            JsonParserOptions::default(),
-            "package.json",
-        )
-        .into_deserialized()
-        .expect("package.json must parse")
-    });
-
-    let added_paths = [
-        BiomePath::new(format!("{fixtures_path}/css/index.css")),
-        BiomePath::new(format!("{fixtures_path}/css/foo.css")),
-        BiomePath::new(format!("{fixtures_path}/css/bar.css")),
-    ];
-    let added_paths = get_css_added_paths(&fs, &added_paths);
-
-    let module_graph = ModuleGraph::default();
-    module_graph.update_graph_for_css_paths(&fs, &project_layout, &added_paths, None);
-
-    let imports = module_graph.data();
-    let file_imports = imports
-        .get(Utf8Path::new(&format!("{fixtures_path}/css/index.css")))
-        .unwrap();
-    let file_imports = file_imports.as_css_module_info().unwrap();
-
-    assert_eq!(file_imports.imports.len(), 2);
-    assert_eq!(
-        file_imports.imports.get("foo.css"),
-        Some(&CssImport {
-            specifier: "foo.css".into(),
-            resolved_path: ResolvedPath::from_path(format!("{fixtures_path}/css/foo.css")),
-        })
-    );
-    assert_eq!(
-        file_imports.imports.get("./bar.css"),
-        Some(&CssImport {
-            specifier: "./bar.css".into(),
-            resolved_path: ResolvedPath::from_path(format!("{fixtures_path}/css/bar.css")),
-        })
-    );
-}
-
 fn find_files_recursively_in_directory(
     directory: &Utf8Path,
     predicate: impl Fn(&Utf8Path) -> bool,
diff --git a/crates/biome_rule_options/src/no_redundant_alt.rs b/crates/biome_rule_options/src/no_redundant_alt.rs
index ddd508af5c..1f0c7de5dd 100644
--- a/crates/biome_rule_options/src/no_redundant_alt.rs
+++ b/crates/biome_rule_options/src/no_redundant_alt.rs
@@ -1,5 +1,6 @@
 use biome_deserialize_macros::{Deserializable, Merge};
 use serde::{Deserialize, Serialize};
+
 #[derive(Default, Clone, Debug, Deserialize, Deserializable, Merge, Eq, PartialEq, Serialize)]
 #[cfg_attr(feature = "schema", derive(schemars::JsonSchema))]
 #[serde(rename_all = "camelCase", deny_unknown_fields, default)]
diff --git a/crates/biome_rule_options/src/shared/mod.rs b/crates/biome_rule_options/src/shared/mod.rs
index a9965fbb48..9817d15c60 100644
--- a/crates/biome_rule_options/src/shared/mod.rs
+++ b/crates/biome_rule_options/src/shared/mod.rs
@@ -1,2 +1,13 @@
+use biome_string_case::StrLikeExtension;
+
 pub mod restricted_regex;
 pub mod sort_order;
+
+const REDUNDANT_WORDS: [&str; 3] = ["image", "photo", "picture"];
+
+pub fn is_redundant_alt(alt: &str) -> bool {
+    REDUNDANT_WORDS.into_iter().any(|word| {
+        alt.split_whitespace()
+            .any(|x| x.to_ascii_lowercase_cow() == word)
+    })
+}
diff --git a/crates/biome_rule_options/src/use_iterable_callback_return.rs b/crates/biome_rule_options/src/use_iterable_callback_return.rs
index 866a2b0db3..604fc9dab2 100644
--- a/crates/biome_rule_options/src/use_iterable_callback_return.rs
+++ b/crates/biome_rule_options/src/use_iterable_callback_return.rs
@@ -3,4 +3,19 @@ use serde::{Deserialize, Serialize};
 #[derive(Default, Clone, Debug, Deserialize, Deserializable, Merge, Eq, PartialEq, Serialize)]
 #[cfg_attr(feature = "schema", derive(schemars::JsonSchema))]
 #[serde(rename_all = "camelCase", deny_unknown_fields, default)]
-pub struct UseIterableCallbackReturnOptions {}
+pub struct UseIterableCallbackReturnOptions {
+    /// When `true`, the rule reports `forEach` callbacks that return a value (default behaviour).
+    /// When `false` or unset, such callbacks are ignored.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub check_for_each: Option<bool>,
+}
+
+impl UseIterableCallbackReturnOptions {
+    pub const DEFAULT_CHECK_FOR_EACH: bool = true;
+
+    /// Returns [`Self::check_for_each`] if it is set.
+    /// Otherwise, returns [`Self::DEFAULT_CHECK_FOR_EACH`].
+    pub fn check_for_each(&self) -> bool {
+        self.check_for_each.unwrap_or(Self::DEFAULT_CHECK_FOR_EACH)
+    }
+}
diff --git a/crates/biome_ruledoc_utils/src/lib.rs b/crates/biome_ruledoc_utils/src/lib.rs
index 69c1921e4d..a251fc774f 100644
--- a/crates/biome_ruledoc_utils/src/lib.rs
+++ b/crates/biome_ruledoc_utils/src/lib.rs
@@ -81,7 +81,7 @@ impl AnalyzerServicesBuilder {
 
         let module_graph = ModuleGraph::default();
         let added_paths = get_added_js_paths(&fs, &added_paths);
-        module_graph.update_graph_for_js_paths(&fs, &layout, &added_paths);
+        module_graph.update_graph_for_js_paths(&fs, &layout, &added_paths, true);
 
         Self {
             module_graph: Arc::new(module_graph),
diff --git a/crates/biome_service/src/configuration.rs b/crates/biome_service/src/configuration.rs
index 44e934e961..8e584b005b 100644
--- a/crates/biome_service/src/configuration.rs
+++ b/crates/biome_service/src/configuration.rs
@@ -23,6 +23,7 @@ use biome_fs::{AutoSearchResult, ConfigName, FileSystem, OpenOptions};
 use biome_graphql_analyze::METADATA as graphql_lint_metadata;
 use biome_graphql_syntax::GraphqlLanguage;
 use biome_html_analyze::METADATA as html_lint_metadata;
+use biome_html_syntax::HtmlLanguage;
 use biome_js_analyze::METADATA as js_lint_metadata;
 use biome_js_syntax::JsLanguage;
 use biome_json_analyze::METADATA as json_lint_metadata;
@@ -729,6 +730,7 @@ mod test {
 /// on the current configuration
 pub struct ProjectScanComputer<'a> {
     requires_project_scan: bool,
+    requires_types: bool,
     enabled_rules: FxHashSet<RuleFilter<'a>>,
     configuration: &'a Configuration,
     skip: &'a [AnalyzerSelector],
@@ -741,6 +743,7 @@ impl<'a> ProjectScanComputer<'a> {
         Self {
             enabled_rules,
             requires_project_scan: false,
+            requires_types: false,
             configuration,
             skip: &[],
             only: &[],
@@ -765,6 +768,11 @@ impl<'a> ProjectScanComputer<'a> {
             for (domain, value) in domains.iter() {
                 if domain == &RuleDomain::Project && value != &RuleDomainValue::None {
                     self.requires_project_scan = true;
+                }
+                if domain == &RuleDomain::Types && value != &RuleDomainValue::None {
+                    self.requires_types = true;
+                    self.requires_project_scan = true;
+                    // requiring types is of higher order of project, so we can bail
                     break;
                 }
             }
@@ -774,8 +782,11 @@ impl<'a> ProjectScanComputer<'a> {
         biome_css_analyze::visit_registry(&mut self);
         biome_json_analyze::visit_registry(&mut self);
         biome_js_analyze::visit_registry(&mut self);
+        biome_html_analyze::visit_registry(&mut self);
 
-        if self.requires_project_scan {
+        if self.requires_types {
+            ScanKind::TypeAware
+        } else if self.requires_project_scan {
             ScanKind::Project
         } else {
             // There's no need to scan further known files if the VCS isn't enabled
@@ -799,6 +810,7 @@ impl<'a> ProjectScanComputer<'a> {
                 if selector.match_rule::<R>() {
                     let domains = R::METADATA.domains;
                     self.requires_project_scan |= domains.contains(&RuleDomain::Project);
+                    self.requires_types |= domains.contains(&RuleDomain::Types);
                     break;
                 }
             }
@@ -807,6 +819,7 @@ impl<'a> ProjectScanComputer<'a> {
         {
             let domains = R::METADATA.domains;
             self.requires_project_scan |= domains.contains(&RuleDomain::Project);
+            self.requires_types |= domains.contains(&RuleDomain::Types);
         }
     }
 }
@@ -850,6 +863,15 @@ impl RegistryVisitor<GraphqlLanguage> for ProjectScanComputer<'_> {
     }
 }
 
+impl RegistryVisitor<HtmlLanguage> for ProjectScanComputer<'_> {
+    fn record_rule<R>(&mut self)
+    where
+        R: Rule<Options: Default, Query: Queryable<Language = HtmlLanguage, Output: Clone>>
+            + 'static,
+    {
+        self.check_rule::<R, HtmlLanguage>();
+    }
+}
 #[cfg(test)]
 mod tests {
     use super::*;
@@ -1001,4 +1023,67 @@ mod tests {
             ScanKind::NoScanner
         );
     }
+
+    #[test]
+    fn should_return_type_aware_if_type_aware_domain_is_enabled() {
+        let mut domains = FxHashMap::default();
+        domains.insert(RuleDomain::Types, RuleDomainValue::Recommended);
+
+        let configuration = Configuration {
+            linter: Some(LinterConfiguration {
+                domains: Some(RuleDomains(domains)),
+                ..Default::default()
+            }),
+            ..Default::default()
+        };
+
+        assert_eq!(
+            ProjectScanComputer::new(&configuration).compute(),
+            ScanKind::TypeAware
+        );
+    }
+
+    #[test]
+    fn should_return_type_aware_if_type_aware_domain_selector() {
+        let configuration = Configuration::default();
+
+        assert_eq!(
+            ProjectScanComputer::new(&configuration)
+                .with_rule_selectors(&[], &[DomainSelector("types").into()])
+                .compute(),
+            ScanKind::TypeAware
+        );
+    }
+
+    #[test]
+    fn should_return_type_aware_when_both_type_aware_and_project_enabled() {
+        let mut domains = FxHashMap::default();
+        domains.insert(RuleDomain::Project, RuleDomainValue::Recommended);
+        domains.insert(RuleDomain::Types, RuleDomainValue::Recommended);
+
+        let configuration = Configuration {
+            linter: Some(LinterConfiguration {
+                domains: Some(RuleDomains(domains)),
+                ..Default::default()
+            }),
+            ..Default::default()
+        };
+
+        assert_eq!(
+            ProjectScanComputer::new(&configuration).compute(),
+            ScanKind::TypeAware
+        );
+    }
+
+    #[test]
+    fn should_not_return_type_aware_if_non_type_aware_domain() {
+        let configuration = Configuration::default();
+
+        assert_eq!(
+            ProjectScanComputer::new(&configuration)
+                .with_rule_selectors(&[], &[DomainSelector("react").into()])
+                .compute(),
+            ScanKind::NoScanner
+        );
+    }
 }
diff --git a/crates/biome_service/src/file_handlers/html.rs b/crates/biome_service/src/file_handlers/html.rs
index 4c888d54d2..4daad8e970 100644
--- a/crates/biome_service/src/file_handlers/html.rs
+++ b/crates/biome_service/src/file_handlers/html.rs
@@ -793,9 +793,11 @@ fn lint(params: LintParams) -> LintResults {
 
     let mut process_lint = ProcessLint::new(&params);
 
-    let (_, analyze_diagnostics) = analyze(&tree, filter, &analyzer_options, |signal| {
-        process_lint.process_signal(signal)
-    });
+    let source_type = params.language.to_html_file_source().unwrap_or_default();
+    let (_, analyze_diagnostics) =
+        analyze(&tree, filter, &analyzer_options, source_type, |signal| {
+            process_lint.process_signal(signal)
+        });
 
     process_lint.into_result(
         params
@@ -826,7 +828,7 @@ pub(crate) fn code_actions(params: CodeActionsParams) -> PullActionsResult {
     let _ = debug_span!("Code actions HTML", range =? range, path =? path).entered();
     let tree = parse.tree();
     let _ = trace_span!("Parsed file", tree =? tree).entered();
-    let Some(_) = language.to_html_file_source() else {
+    let Some(source_type) = language.to_html_file_source() else {
         error!("Could not determine the HTML file source of the file");
         return PullActionsResult {
             actions: Vec::new(),
@@ -851,7 +853,7 @@ pub(crate) fn code_actions(params: CodeActionsParams) -> PullActionsResult {
         range,
     };
 
-    analyze(&tree, filter, &analyzer_options, |signal| {
+    analyze(&tree, filter, &analyzer_options, source_type, |signal| {
         actions.extend(signal.actions().into_code_action_iter().map(|item| {
             CodeAction {
                 category: item.category.clone(),
@@ -905,8 +907,12 @@ pub(crate) fn fix_all(params: FixAllParams) -> Result<FixFileResult, WorkspaceEr
         tree.syntax().text_range_with_trivia().len().into(),
     );
 
+    let source_type = params
+        .document_file_source
+        .to_html_file_source()
+        .unwrap_or_default();
     loop {
-        let (action, _) = analyze(&tree, filter, &analyzer_options, |signal| {
+        let (action, _) = analyze(&tree, filter, &analyzer_options, source_type, |signal| {
             process_fix_all.process_signal(signal)
         });
 
diff --git a/crates/biome_service/src/scanner.rs b/crates/biome_service/src/scanner.rs
index 205c1d259b..5742841ff6 100644
--- a/crates/biome_service/src/scanner.rs
+++ b/crates/biome_service/src/scanner.rs
@@ -710,6 +710,9 @@ pub enum ScanKind {
     },
     /// Scans the entire repository, indexing all files to enable project rules.
     Project,
+
+    /// Scans the entire repository, indexing all files to enable type inference rules
+    TypeAware,
 }
 
 impl ScanKind {
@@ -723,6 +726,7 @@ impl ScanKind {
             Self::KnownFiles => Self::KnownFiles,
             Self::Project => Self::Project,
             Self::TargetedKnownFiles { .. } => Self::KnownFiles,
+            Self::TypeAware => Self::TypeAware,
         }
     }
 
@@ -730,6 +734,10 @@ impl ScanKind {
         matches!(self, Self::Project)
     }
 
+    pub const fn is_type_aware(&self) -> bool {
+        matches!(self, Self::TypeAware)
+    }
+
     pub const fn is_known_files(&self) -> bool {
         matches!(self, Self::KnownFiles)
     }
diff --git a/crates/biome_service/src/scanner.tests.rs b/crates/biome_service/src/scanner.tests.rs
index 9f11bb53d5..febe774455 100644
--- a/crates/biome_service/src/scanner.tests.rs
+++ b/crates/biome_service/src/scanner.tests.rs
@@ -6,6 +6,7 @@ use camino::Utf8PathBuf;
 
 use crate::Workspace;
 use crate::scanner::WorkspaceScannerBridge;
+use crate::settings::ModuleGraphResolutionKind;
 use crate::test_utils::setup_workspace_and_open_project;
 use crate::workspace::{GetFileContentParams, ScanKind, ScanProjectParams, UpdateSettingsParams};
 
@@ -63,6 +64,7 @@ fn scanner_only_loads_used_type_definitions_from_node_modules() {
             configuration: Default::default(),
             workspace_directory: Some(fixtures_path.clone().into()),
             extended_configurations: Default::default(),
+            module_graph_resolution_kind: ModuleGraphResolutionKind::ModulesAndTypes,
         })
         .unwrap();
 
@@ -143,6 +145,7 @@ fn scanner_ignored_files_are_not_loaded() {
             configuration,
             workspace_directory: Some(fixtures_path.clone().into()),
             extended_configurations: Default::default(),
+            module_graph_resolution_kind: ModuleGraphResolutionKind::ModulesAndTypes,
         })
         .unwrap();
 
@@ -196,6 +199,7 @@ fn scanner_required_files_are_only_ignored_in_ignored_directories() {
             configuration,
             workspace_directory: Some(fixtures_path.clone().into()),
             extended_configurations: Default::default(),
+            module_graph_resolution_kind: ModuleGraphResolutionKind::ModulesAndTypes,
         })
         .unwrap();
 
diff --git a/crates/biome_service/src/scanner/test_utils.rs b/crates/biome_service/src/scanner/test_utils.rs
index 7ed0db4c78..063aa9645d 100644
--- a/crates/biome_service/src/scanner/test_utils.rs
+++ b/crates/biome_service/src/scanner/test_utils.rs
@@ -128,14 +128,22 @@ impl WorkspaceWatcherBridge for MockWorkspaceWatcherBridge<'_> {
         self.tx.send(()).expect("can send notification");
     }
 
-    fn unload_file(&self, path: &Utf8Path) -> Result<Vec<Diagnostic>, WorkspaceError> {
+    fn unload_file(
+        &self,
+        path: &Utf8Path,
+        _project_key: ProjectKey,
+    ) -> Result<Vec<Diagnostic>, WorkspaceError> {
         self.indexed_files.pin().remove(path);
         self.tx.send(()).expect("can send notification");
 
         Ok(vec![])
     }
 
-    fn unload_path(&self, path: &Utf8Path) -> Result<Vec<Diagnostic>, WorkspaceError> {
+    fn unload_path(
+        &self,
+        path: &Utf8Path,
+        _project_key: ProjectKey,
+    ) -> Result<Vec<Diagnostic>, WorkspaceError> {
         self.indexed_files.pin().remove(path);
         self.indexed_folders.pin().remove(path);
         self.tx.send(()).expect("can send notification");
diff --git a/crates/biome_service/src/scanner/watcher.rs b/crates/biome_service/src/scanner/watcher.rs
index 01831a199d..c46af54a13 100644
--- a/crates/biome_service/src/scanner/watcher.rs
+++ b/crates/biome_service/src/scanner/watcher.rs
@@ -390,7 +390,10 @@ impl Watcher {
     ) -> Result<Vec<Diagnostic>, WorkspaceError> {
         let mut diagnostics = vec![];
         for path in paths {
-            diagnostics.extend(workspace.unload_file(&path)?);
+            let Some(project_key) = workspace.find_project_for_path(&path) else {
+                return Ok(vec![]);
+            };
+            diagnostics.extend(workspace.unload_file(&path, project_key)?);
         }
 
         Ok(diagnostics)
@@ -406,7 +409,10 @@ impl Watcher {
     ) -> Result<Vec<Diagnostic>, WorkspaceError> {
         let mut diagnostics = vec![];
         for path in &paths {
-            let result = workspace.unload_path(path)?;
+            let Some(project_key) = workspace.find_project_for_path(path) else {
+                return Ok(vec![]);
+            };
+            let result = workspace.unload_path(path, project_key)?;
             diagnostics.extend(result);
         }
 
@@ -419,10 +425,13 @@ impl Watcher {
         to: &Utf8Path,
     ) -> Result<Vec<Diagnostic>, WorkspaceError> {
         let mut diagnostics = vec![];
+        let Some(project_key) = workspace.find_project_for_path(from) else {
+            return Ok(vec![]);
+        };
         if workspace.fs().path_is_file(from) {
-            diagnostics.extend(workspace.unload_file(from)?);
+            diagnostics.extend(workspace.unload_file(from, project_key)?);
         } else {
-            diagnostics.extend(workspace.unload_path(from)?);
+            diagnostics.extend(workspace.unload_path(from, project_key)?);
         }
         diagnostics.extend(Self::index_path(workspace, to)?);
         Ok(diagnostics)
diff --git a/crates/biome_service/src/scanner/workspace_bridges.rs b/crates/biome_service/src/scanner/workspace_bridges.rs
index e85cd175e4..884b26927d 100644
--- a/crates/biome_service/src/scanner/workspace_bridges.rs
+++ b/crates/biome_service/src/scanner/workspace_bridges.rs
@@ -86,7 +86,11 @@ pub(crate) trait WorkspaceScannerBridge: Send + Sync + RefUnwindSafe {
 
     /// Unloads the index of the file with the given `path` within the
     /// workspace.
-    fn unload_file(&self, path: &Utf8Path) -> Result<Vec<Diagnostic>, WorkspaceError>;
+    fn unload_file(
+        &self,
+        path: &Utf8Path,
+        project_key: ProjectKey,
+    ) -> Result<Vec<Diagnostic>, WorkspaceError>;
 
     /// Unloads the given `path` from the workspace index.
     ///
@@ -97,7 +101,11 @@ pub(crate) trait WorkspaceScannerBridge: Send + Sync + RefUnwindSafe {
     ///
     /// If you already know the path is a file, you should use
     /// [`WorkspaceWatcherBridge::unload_file()`] directly instead.
-    fn unload_path(&self, path: &Utf8Path) -> Result<Vec<Diagnostic>, WorkspaceError>;
+    fn unload_path(
+        &self,
+        path: &Utf8Path,
+        project_key: ProjectKey,
+    ) -> Result<Vec<Diagnostic>, WorkspaceError>;
 }
 
 /// Trait used to give access to workspace functionality required by the
@@ -157,7 +165,11 @@ pub trait WorkspaceWatcherBridge {
 
     /// Unloads the index of the file with the given `path` within the
     /// workspace.
-    fn unload_file(&self, path: &Utf8Path) -> Result<Vec<Diagnostic>, WorkspaceError>;
+    fn unload_file(
+        &self,
+        path: &Utf8Path,
+        project_key: ProjectKey,
+    ) -> Result<Vec<Diagnostic>, WorkspaceError>;
 
     /// Unloads the given `path` from the workspace index.
     ///
@@ -168,7 +180,11 @@ pub trait WorkspaceWatcherBridge {
     ///
     /// If you already know the path is a file, you should use
     /// [`WorkspaceWatcherBridge::unload_file()`] directly instead.
-    fn unload_path(&self, path: &Utf8Path) -> Result<Vec<Diagnostic>, WorkspaceError>;
+    fn unload_path(
+        &self,
+        path: &Utf8Path,
+        project_key: ProjectKey,
+    ) -> Result<Vec<Diagnostic>, WorkspaceError>;
 
     /// Notifies service notification listeners that the watcher has stopped.
     fn notify_stopped(&self);
@@ -270,13 +286,21 @@ where
     }
 
     #[inline]
-    fn unload_file(&self, path: &Utf8Path) -> Result<Vec<Diagnostic>, WorkspaceError> {
-        self.workspace.unload_file(path)
+    fn unload_file(
+        &self,
+        path: &Utf8Path,
+        project_key: ProjectKey,
+    ) -> Result<Vec<Diagnostic>, WorkspaceError> {
+        self.workspace.unload_file(path, project_key)
     }
 
     #[inline]
-    fn unload_path(&self, path: &Utf8Path) -> Result<Vec<Diagnostic>, WorkspaceError> {
-        self.workspace.unload_path(path)
+    fn unload_path(
+        &self,
+        path: &Utf8Path,
+        project_key: ProjectKey,
+    ) -> Result<Vec<Diagnostic>, WorkspaceError> {
+        self.workspace.unload_path(path, project_key)
     }
 
     #[inline]
diff --git a/crates/biome_service/src/scanner/workspace_scanner_bridge.tests.rs b/crates/biome_service/src/scanner/workspace_scanner_bridge.tests.rs
index 51627948ec..86ee9eeca3 100644
--- a/crates/biome_service/src/scanner/workspace_scanner_bridge.tests.rs
+++ b/crates/biome_service/src/scanner/workspace_scanner_bridge.tests.rs
@@ -15,7 +15,9 @@ use biome_fs::{BiomePath, MemoryFileSystem, TemporaryFs};
 use biome_glob::NormalizedGlob;
 use camino::{Utf8Path, Utf8PathBuf};
 
+use super::{ScanKind, WorkspaceScannerBridge};
 use crate::scanner::IndexTrigger;
+use crate::settings::ModuleGraphResolutionKind;
 use crate::test_utils::setup_workspace_and_open_project;
 use crate::workspace::{
     CloseFileParams, FileContent, GetFileContentParams, OpenFileParams, ScanProjectParams,
@@ -23,8 +25,6 @@ use crate::workspace::{
 };
 use crate::{Workspace, WorkspaceError};
 
-use super::{ScanKind, WorkspaceScannerBridge};
-
 #[test]
 fn close_file_through_watcher_before_client() {
     const FILE_CONTENT: &str = "import 'foo';";
@@ -62,7 +62,7 @@ fn close_file_through_watcher_before_client() {
     );
 
     workspace
-        .unload_file(&file_path)
+        .unload_file(&file_path, project_key)
         .expect("can unload indexed file");
 
     assert!(
@@ -147,7 +147,7 @@ fn close_file_from_client_before_watcher() {
     );
 
     workspace
-        .unload_file(&file_path)
+        .unload_file(&file_path, project_key)
         .expect("can unload file from index");
 
     assert!(
@@ -202,6 +202,7 @@ fn should_not_index_an_ignored_file_inside_vcs_ignore_file() {
                 ..Default::default()
             },
             extended_configurations: Default::default(),
+            module_graph_resolution_kind: ModuleGraphResolutionKind::ModulesAndTypes,
         })
         .expect("can update settings");
 
@@ -242,6 +243,7 @@ fn should_not_index_an_ignored_file_inside_file_includes() {
                 ..Default::default()
             },
             extended_configurations: Default::default(),
+            module_graph_resolution_kind: ModuleGraphResolutionKind::ModulesAndTypes,
         })
         .expect("can update settings");
 
@@ -283,6 +285,7 @@ fn should_index_an_ignored_file_if_it_is_a_dependency_of_a_non_ignored_file() {
                 ..Default::default()
             },
             extended_configurations: Default::default(),
+            module_graph_resolution_kind: ModuleGraphResolutionKind::ModulesAndTypes,
         })
         .expect("can update settings");
 
@@ -331,6 +334,7 @@ fn should_not_index_a_force_ignored_file_even_if_it_is_a_dependency() {
                 ..Default::default()
             },
             extended_configurations: Default::default(),
+            module_graph_resolution_kind: ModuleGraphResolutionKind::ModulesAndTypes,
         })
         .expect("can update settings");
 
@@ -374,6 +378,7 @@ fn should_not_index_dependency_with_scan_kind_known_files() {
                 ..Default::default()
             },
             extended_configurations: Default::default(),
+            module_graph_resolution_kind: ModuleGraphResolutionKind::ModulesAndTypes,
         })
         .expect("can update settings");
 
@@ -415,6 +420,7 @@ fn should_not_index_inside_an_ignored_folder_inside_file_includes() {
                 ..Default::default()
             },
             extended_configurations: Default::default(),
+            module_graph_resolution_kind: ModuleGraphResolutionKind::ModulesAndTypes,
         })
         .expect("can update settings");
 
@@ -457,6 +463,7 @@ fn should_not_index_inside_an_ignored_folder_inside_vcs_ignore_file() {
                 ..Default::default()
             },
             extended_configurations: Default::default(),
+            module_graph_resolution_kind: ModuleGraphResolutionKind::ModulesAndTypes,
         })
         .expect("can update settings");
 
diff --git a/crates/biome_service/src/settings.rs b/crates/biome_service/src/settings.rs
index 73c47e6ed5..7f418f56c3 100644
--- a/crates/biome_service/src/settings.rs
+++ b/crates/biome_service/src/settings.rs
@@ -1,4 +1,4 @@
-use crate::workspace::{DocumentFileSource, FeatureKind};
+use crate::workspace::{DocumentFileSource, FeatureKind, ScanKind};
 use crate::{WorkspaceError, is_dir};
 use biome_analyze::{AnalyzerOptions, AnalyzerRules};
 use biome_configuration::analyzer::assist::{Actions, AssistConfiguration, AssistEnabled};
@@ -55,6 +55,8 @@ pub struct Settings {
     /// The configuration that originated this setting, if applicable.
     source: Option<Arc<ConfigurationSource>>,
 
+    pub(crate) module_graph_resolution_kind: ModuleGraphResolutionKind,
+
     /// Formatter settings applied to all files in the project.
     pub formatter: FormatSettings,
     /// Linter settings applied to all files in the project.
@@ -364,6 +366,34 @@ impl Settings {
     }
 }
 
+#[derive(Clone, Debug, Default, PartialEq, serde::Serialize, serde::Deserialize)]
+#[cfg_attr(feature = "schema", derive(schemars::JsonSchema))]
+#[serde(rename_all = "camelCase")]
+pub enum ModuleGraphResolutionKind {
+    #[default]
+    None,
+    Modules,
+    ModulesAndTypes,
+}
+
+impl ModuleGraphResolutionKind {
+    pub const fn is_modules_and_types(&self) -> bool {
+        matches!(self, Self::ModulesAndTypes)
+    }
+}
+
+impl From<&ScanKind> for ModuleGraphResolutionKind {
+    fn from(value: &ScanKind) -> Self {
+        match value {
+            ScanKind::NoScanner | ScanKind::KnownFiles | ScanKind::TargetedKnownFiles { .. } => {
+                Self::None
+            }
+            ScanKind::Project => Self::Modules,
+            ScanKind::TypeAware => Self::ModulesAndTypes,
+        }
+    }
+}
+
 pub type SettingsWithEditor<'a> = SettingsHandle<'a, Option<Configuration>>;
 
 /// Handle object holding a temporary lock on the workspace settings until
diff --git a/crates/biome_service/src/settings.tests.rs b/crates/biome_service/src/settings.tests.rs
index 0b9da0103e..519c209ea1 100644
--- a/crates/biome_service/src/settings.tests.rs
+++ b/crates/biome_service/src/settings.tests.rs
@@ -1,4 +1,8 @@
-use crate::settings::{LanguageSettings, ServiceLanguage, Settings, to_json_language_settings};
+use crate::scanner::ScanKind;
+use crate::settings::{
+    LanguageSettings, ModuleGraphResolutionKind, ServiceLanguage, Settings,
+    to_json_language_settings,
+};
 use crate::workspace::DocumentFileSource;
 use biome_analyze::RuleFilter;
 use biome_configuration::analyzer::{GroupPlainConfiguration, Nursery, SeverityOrGroup};
@@ -231,3 +235,63 @@ fn override_inherits_global_formatter_when_not_specified() {
         "Formatter should be enabled for .js files"
     );
 }
+
+#[test]
+fn test_module_graph_resolution_kind_from_scan_kind() {
+    // Test all ScanKind variants map to correct ModuleGraphResolutionKind
+    assert_eq!(
+        ModuleGraphResolutionKind::from(&ScanKind::NoScanner),
+        ModuleGraphResolutionKind::None
+    );
+
+    assert_eq!(
+        ModuleGraphResolutionKind::from(&ScanKind::KnownFiles),
+        ModuleGraphResolutionKind::None
+    );
+
+    assert_eq!(
+        ModuleGraphResolutionKind::from(&ScanKind::TargetedKnownFiles {
+            target_paths: vec![],
+            descend_from_targets: false,
+        }),
+        ModuleGraphResolutionKind::None
+    );
+
+    assert_eq!(
+        ModuleGraphResolutionKind::from(&ScanKind::Project),
+        ModuleGraphResolutionKind::Modules
+    );
+
+    assert_eq!(
+        ModuleGraphResolutionKind::from(&ScanKind::TypeAware),
+        ModuleGraphResolutionKind::ModulesAndTypes
+    );
+}
+
+#[test]
+fn test_module_graph_resolution_kind_is_modules_and_types() {
+    // Test is_modules_and_types predicate
+    assert!(!ModuleGraphResolutionKind::None.is_modules_and_types());
+    assert!(!ModuleGraphResolutionKind::Modules.is_modules_and_types());
+    assert!(ModuleGraphResolutionKind::ModulesAndTypes.is_modules_and_types());
+}
+
+#[test]
+fn test_type_aware_scan_enables_module_graph_type_inference() {
+    // This test verifies that TypeAware scan kind results in type inference being enabled
+    let type_aware_kind = ModuleGraphResolutionKind::from(&ScanKind::TypeAware);
+    assert!(
+        type_aware_kind.is_modules_and_types(),
+        "TypeAware scan should enable type inference"
+    );
+}
+
+#[test]
+fn test_project_scan_disables_module_graph_type_inference() {
+    // This test verifies that Project scan kind does NOT enable type inference
+    let project_kind = ModuleGraphResolutionKind::from(&ScanKind::Project);
+    assert!(
+        !project_kind.is_modules_and_types(),
+        "Project scan should NOT enable type inference"
+    );
+}
diff --git a/crates/biome_service/src/workspace.rs b/crates/biome_service/src/workspace.rs
index 7396551b82..a22ad50b56 100644
--- a/crates/biome_service/src/workspace.rs
+++ b/crates/biome_service/src/workspace.rs
@@ -95,7 +95,7 @@ pub use crate::{
 #[cfg(feature = "schema")]
 use schemars::{Schema, SchemaGenerator};
 
-use crate::settings::SettingsWithEditor;
+use crate::settings::{ModuleGraphResolutionKind, SettingsWithEditor};
 pub use client::{TransportRequest, WorkspaceClient, WorkspaceTransport};
 pub use server::OpenFileReason;
 
@@ -750,6 +750,8 @@ pub struct UpdateSettingsParams {
     pub workspace_directory: Option<BiomePath>,
     #[serde(skip_serializing_if = "Vec::is_empty", default)]
     pub extended_configurations: Vec<(BiomePath, Configuration)>,
+    #[serde(default)]
+    pub module_graph_resolution_kind: ModuleGraphResolutionKind,
 }
 
 #[derive(Debug, serde::Serialize, serde::Deserialize)]
@@ -949,6 +951,7 @@ pub struct CloseFileParams {
 #[cfg_attr(feature = "schema", derive(schemars::JsonSchema))]
 #[serde(rename_all = "camelCase")]
 pub struct UpdateModuleGraphParams {
+    pub project_key: ProjectKey,
     pub path: BiomePath,
     /// The kind of update to apply to the module graph
     pub update_kind: UpdateKind,
diff --git a/crates/biome_service/src/workspace.tests.rs b/crates/biome_service/src/workspace.tests.rs
index 67e831138d..c4bbccc1a4 100644
--- a/crates/biome_service/src/workspace.tests.rs
+++ b/crates/biome_service/src/workspace.tests.rs
@@ -15,16 +15,16 @@ use biome_plugin_loader::{PluginConfiguration, Plugins};
 use camino::Utf8PathBuf;
 use insta::{assert_debug_snapshot, assert_snapshot};
 
-use crate::file_handlers::DocumentFileSource;
-use crate::projects::ProjectKey;
-use crate::{Workspace, WorkspaceError};
-
 use super::{
     CloseFileParams, CloseProjectParams, FileContent, FileFeaturesResult, FileGuard,
     GetModuleGraphParams, GetSyntaxTreeParams, OpenFileParams, OpenProjectParams,
     OpenProjectResult, PullDiagnosticsParams, ScanKind, ScanProjectParams, UpdateKind,
     UpdateModuleGraphParams, UpdateSettingsParams, server,
 };
+use crate::file_handlers::DocumentFileSource;
+use crate::projects::ProjectKey;
+use crate::settings::ModuleGraphResolutionKind;
+use crate::{Workspace, WorkspaceError};
 
 fn create_server() -> (Box<dyn Workspace>, ProjectKey) {
     let workspace = server(Arc::new(MemoryFileSystem::default()), None);
@@ -471,6 +471,7 @@ fn too_large_files_are_tracked_but_not_parsed() {
             },
             workspace_directory: None,
             extended_configurations: Default::default(),
+            module_graph_resolution_kind: ModuleGraphResolutionKind::None,
         })
         .unwrap();
 
@@ -531,6 +532,7 @@ fn plugins_are_loaded_and_used_during_analysis() {
             },
             workspace_directory: Some(BiomePath::new("/project")),
             extended_configurations: Default::default(),
+            module_graph_resolution_kind: ModuleGraphResolutionKind::None,
         })
         .unwrap();
 
@@ -601,6 +603,7 @@ language css;
             },
             workspace_directory: Some(BiomePath::new("/project")),
             extended_configurations: Default::default(),
+            module_graph_resolution_kind: ModuleGraphResolutionKind::None,
         })
         .unwrap();
 
@@ -667,6 +670,7 @@ fn plugins_may_use_invalid_span() {
             },
             workspace_directory: Some(BiomePath::new("/project")),
             extended_configurations: Default::default(),
+            module_graph_resolution_kind: ModuleGraphResolutionKind::None,
         })
         .unwrap();
 
@@ -787,6 +791,7 @@ const hasOwn = Object.hasOwn({ foo: 'bar' }, 'foo');"#,
             },
             workspace_directory: Some(BiomePath::new("/project")),
             extended_configurations: Default::default(),
+            module_graph_resolution_kind: ModuleGraphResolutionKind::None,
         })
         .unwrap();
 
@@ -1017,12 +1022,14 @@ export const squash = function squash() {};
         .update_module_graph(UpdateModuleGraphParams {
             path: BiomePath::new("/project/file.js"),
             update_kind: UpdateKind::AddOrUpdate,
+            project_key,
         })
         .unwrap();
     workspace
         .update_module_graph(UpdateModuleGraphParams {
             path: BiomePath::new("/project/utils.js"),
             update_kind: UpdateKind::AddOrUpdate,
+            project_key,
         })
         .unwrap();
 
@@ -1030,6 +1037,7 @@ export const squash = function squash() {};
         .update_module_graph(UpdateModuleGraphParams {
             path: BiomePath::new("/project/dynamic.js"),
             update_kind: UpdateKind::AddOrUpdate,
+            project_key,
         })
         .unwrap();
 
diff --git a/crates/biome_service/src/workspace/server.rs b/crates/biome_service/src/workspace/server.rs
index 662ef4d8b7..4c8488ecc2 100644
--- a/crates/biome_service/src/workspace/server.rs
+++ b/crates/biome_service/src/workspace/server.rs
@@ -4,7 +4,7 @@ use std::sync::{Arc, Mutex};
 
 use super::{document::Document, *};
 use crate::Watcher;
-use crate::configuration::{LoadedConfiguration, read_config};
+use crate::configuration::{LoadedConfiguration, ProjectScanComputer, read_config};
 use crate::diagnostics::{FileTooLarge, NoIgnoreFileFound, VcsDiagnostic};
 use crate::file_handlers::{
     Capabilities, CodeActionsParams, DiagnosticsAndActionsParams, DocumentFileSource, Features,
@@ -530,8 +530,11 @@ impl WorkspaceServer {
                 .and_then(Result::ok)
                 .map(|node| node.unwrap_as_send_node())
         {
-            let (dependencies, diagnostics) = self
-                .update_service_data(&path, UpdateKind::AddedOrChanged(reason, root, services))?;
+            let (dependencies, diagnostics) = self.update_service_data(
+                &path,
+                UpdateKind::AddedOrChanged(reason, root, services),
+                project_key,
+            )?;
 
             Ok(InternalOpenFileResult {
                 dependencies,
@@ -780,7 +783,7 @@ impl WorkspaceServer {
             PathKind::Directory { .. } => {
                 if path.is_dependency() {
                     // Every mode ignores dependencies, except project mode.
-                    return Ok(!scan_kind.is_project());
+                    return Ok(!scan_kind.is_project() && !scan_kind.is_type_aware());
                 }
 
                 if self.projects.is_ignored_by_top_level_config(
@@ -824,7 +827,7 @@ impl WorkspaceServer {
                             )
                         }),
                     },
-                    ScanKind::Project => {
+                    ScanKind::Project | ScanKind::TypeAware => {
                         if path.is_dependency() {
                             // During the initial scan, we only care about
                             // `package.json` files inside `node_modules`, so that
@@ -940,6 +943,7 @@ impl WorkspaceServer {
         &self,
         path: &BiomePath,
         update_kind: &UpdateKind,
+        infer_types: bool,
     ) -> (ModuleDependencies, Vec<ModuleDiagnostic>) {
         match update_kind {
             UpdateKind::AddedOrChanged(_, root, services) => {
@@ -949,6 +953,7 @@ impl WorkspaceServer {
                         self.fs.as_ref(),
                         &self.project_layout,
                         &[(path, js_root)],
+                        infer_types,
                     )
                 } else if let (Some(css_root), Some(services)) = (
                     SendNode::into_language_root::<AnyCssRoot>(root.clone()),
@@ -980,13 +985,22 @@ impl WorkspaceServer {
         &self,
         path: &Utf8Path,
         update_kind: UpdateKind,
+        project_key: ProjectKey,
     ) -> Result<(ModuleDependencies, Vec<ModuleDiagnostic>), WorkspaceError> {
         let path = BiomePath::from(path);
         if path.is_manifest() {
             self.update_project_layout(&path, &update_kind)?;
         }
+        let settings = self
+            .projects
+            .get_settings_based_on_path(project_key, &path)
+            .ok_or_else(WorkspaceError::no_project)?;
 
-        let result = self.update_module_graph_internal(&path, &update_kind);
+        let result = self.update_module_graph_internal(
+            &path,
+            &update_kind,
+            settings.module_graph_resolution_kind.is_modules_and_types(),
+        );
 
         match update_kind {
             UpdateKind::AddedOrChanged(OpenFileReason::Index(IndexTrigger::InitialScan), _, _) => {
@@ -1081,6 +1095,7 @@ impl Workspace for WorkspaceServer {
             configuration,
             project_key,
             extended_configurations,
+            module_graph_resolution_kind,
         } = params;
         let mut diagnostics: Vec<biome_diagnostics::serde::Diagnostic> = vec![];
         let workspace_directory = workspace_directory.map(|p| p.to_path_buf());
@@ -1102,6 +1117,7 @@ impl Workspace for WorkspaceServer {
                 .get_root_settings(project_key)
                 .ok_or_else(WorkspaceError::no_project)?
         };
+        settings.module_graph_resolution_kind = module_graph_resolution_kind;
 
         settings.merge_with_configuration(
             configuration,
@@ -1535,6 +1551,7 @@ impl Workspace for WorkspaceServer {
             let (dependencies, diagnostics) = self.update_service_data(
                 &path,
                 UpdateKind::AddedOrChanged(OpenFileReason::ClientRequest, root, services),
+                project_key,
             )?;
             final_diagnostics.extend(
                 diagnostics
@@ -2194,6 +2211,10 @@ impl Workspace for WorkspaceServer {
 
     fn update_module_graph(&self, params: UpdateModuleGraphParams) -> Result<(), WorkspaceError> {
         let (parsed, services) = self.get_parse_and_services(params.path.as_path())?;
+        let settings = self
+            .projects
+            .get_settings_based_on_path(params.project_key, &params.path)
+            .ok_or_else(WorkspaceError::no_project)?;
         let update_kind = match params.update_kind {
             super::UpdateKind::AddOrUpdate => UpdateKind::AddedOrChanged(
                 OpenFileReason::ClientRequest,
@@ -2203,7 +2224,11 @@ impl Workspace for WorkspaceServer {
             super::UpdateKind::Remove => UpdateKind::Removed,
         };
 
-        self.update_module_graph_internal(&params.path, &update_kind);
+        self.update_module_graph_internal(
+            &params.path,
+            &update_kind,
+            settings.module_graph_resolution_kind.is_modules_and_types(),
+        );
         Ok(())
     }
 
@@ -2425,6 +2450,8 @@ impl WorkspaceScannerBridge for WorkspaceServer {
                 nested_configuration
             };
 
+            let scan_kind = ProjectScanComputer::new(&nested_configuration).compute();
+
             let result = self.update_settings(UpdateSettingsParams {
                 project_key,
                 workspace_directory: nested_directory_path.map(BiomePath::from),
@@ -2433,6 +2460,7 @@ impl WorkspaceScannerBridge for WorkspaceServer {
                     .into_iter()
                     .map(|(path, config)| (BiomePath::from(path), config))
                     .collect(),
+                module_graph_resolution_kind: ModuleGraphResolutionKind::from(&scan_kind),
             })?;
 
             returned_diagnostics.extend(result.diagnostics)
@@ -2491,8 +2519,9 @@ impl WorkspaceScannerBridge for WorkspaceServer {
     fn unload_file(
         &self,
         path: &Utf8Path,
+        project_key: ProjectKey,
     ) -> Result<Vec<biome_diagnostics::serde::Diagnostic>, WorkspaceError> {
-        self.update_service_data(path, UpdateKind::Removed)
+        self.update_service_data(path, UpdateKind::Removed, project_key)
             .map(|(_, diagnostics)| {
                 diagnostics
                     .into_iter()
@@ -2504,6 +2533,7 @@ impl WorkspaceScannerBridge for WorkspaceServer {
     fn unload_path(
         &self,
         path: &Utf8Path,
+        project_key: ProjectKey,
     ) -> Result<Vec<biome_diagnostics::serde::Diagnostic>, WorkspaceError> {
         // Note that we cannot check the kind of the path, because the watcher
         // would only attempt to unload a file or folder after it has been
@@ -2517,7 +2547,7 @@ impl WorkspaceScannerBridge for WorkspaceServer {
         self.project_layout.unload_folder(path);
 
         // Finally unloads the path itself.
-        self.unload_file(path)
+        self.unload_file(path, project_key)
     }
 }
 
diff --git a/crates/biome_service/src/workspace/server.tests.rs b/crates/biome_service/src/workspace/server.tests.rs
index b8b536a19f..b1b0e1d7e5 100644
--- a/crates/biome_service/src/workspace/server.tests.rs
+++ b/crates/biome_service/src/workspace/server.tests.rs
@@ -243,6 +243,7 @@ function Foo({cond}) {
             configuration,
             workspace_directory: Some(BiomePath::new("/project")),
             extended_configurations: Default::default(),
+            module_graph_resolution_kind: ModuleGraphResolutionKind::None,
         })
         .unwrap();
 
@@ -359,6 +360,7 @@ function Foo({cond}) {
             configuration,
             workspace_directory: Some(BiomePath::new("/project")),
             extended_configurations: Default::default(),
+            module_graph_resolution_kind: ModuleGraphResolutionKind::None,
         })
         .unwrap();
 
@@ -516,6 +518,7 @@ const Bar = styled(Component)`
                 ..Default::default()
             },
             extended_configurations: vec![],
+            module_graph_resolution_kind: ModuleGraphResolutionKind::None,
         })
         .unwrap();
 
@@ -587,6 +590,7 @@ const Bar = graphql(`
                 ..Default::default()
             },
             extended_configurations: vec![],
+            module_graph_resolution_kind: ModuleGraphResolutionKind::None,
         })
         .unwrap();
 
diff --git a/crates/biome_test_utils/src/lib.rs b/crates/biome_test_utils/src/lib.rs
index 15e7fe250b..0b535e8d2d 100644
--- a/crates/biome_test_utils/src/lib.rs
+++ b/crates/biome_test_utils/src/lib.rs
@@ -251,7 +251,7 @@ pub fn module_graph_for_test_file(
     let fs = OsFileSystem::new(dir);
     let paths = get_added_js_paths(&fs, &paths);
 
-    module_graph.update_graph_for_js_paths(&fs, project_layout, &paths);
+    module_graph.update_graph_for_js_paths(&fs, project_layout, &paths, true);
 
     Arc::new(module_graph)
 }
diff --git a/packages/@biomejs/backend-jsonrpc/src/workspace.ts b/packages/@biomejs/backend-jsonrpc/src/workspace.ts
index df26ece24a..4a329ed019 100644
--- a/packages/@biomejs/backend-jsonrpc/src/workspace.ts
+++ b/packages/@biomejs/backend-jsonrpc/src/workspace.ts
@@ -979,7 +979,8 @@ export type RuleDomain =
 	| "vue"
 	| "project"
 	| "tailwind"
-	| "turborepo";
+	| "turborepo"
+	| "types";
 export type RuleDomainValue = "all" | "none" | "recommended";
 export type SeverityOrA11y = GroupPlainConfiguration | A11y;
 export type SeverityOrComplexity = GroupPlainConfiguration | Complexity;
@@ -1105,7 +1106,7 @@ See <https://biomejs.dev/linter/rules/no-aria-unsupported-elements>
 	 */
 	noAriaUnsupportedElements?: NoAriaUnsupportedElementsConfiguration;
 	/**
-	* Enforce that autoFocus prop is not used on elements.
+	* Enforce that the autofocus attribute is not used on elements.
 See <https://biomejs.dev/linter/rules/no-autofocus> 
 	 */
 	noAutofocus?: NoAutofocusConfiguration;
@@ -7139,7 +7140,13 @@ export type UseGetterReturnOptions = {};
 export type UseGoogleFontDisplayOptions = {};
 export type UseGuardForInOptions = {};
 export type UseIsArrayOptions = {};
-export type UseIterableCallbackReturnOptions = {};
+export interface UseIterableCallbackReturnOptions {
+	/**
+	* When `true`, the rule reports `forEach` callbacks that return a value (default behaviour).
+When `false` or unset, such callbacks are ignored. 
+	 */
+	checkForEach?: boolean;
+}
 export type UseNamespaceKeywordOptions = {};
 export type UseNumberToFixedDigitsArgumentOptions = {};
 export type UseStaticResponseMethodsOptions = {};
@@ -7374,9 +7381,11 @@ export type SupportKind =
 export interface UpdateSettingsParams {
 	configuration: Configuration;
 	extendedConfigurations?: [BiomePath, Configuration][];
+	moduleGraphResolutionKind?: ModuleGraphResolutionKind;
 	projectKey: ProjectKey;
 	workspaceDirectory?: BiomePath;
 }
+export type ModuleGraphResolutionKind = "none" | "modules" | "modulesAndTypes";
 export interface UpdateSettingsResult {
 	diagnostics: Diagnostic[];
 }
@@ -8026,7 +8035,8 @@ Target paths must be absolute.
 				targetPaths: BiomePath[];
 			};
 	  }
-	| "project";
+	| "project"
+	| "typeAware";
 export interface ScanProjectResult {
 	/**
 	 * A list of child configuration files found inside the project
@@ -8205,6 +8215,7 @@ When this field is empty, Biome checks only `files.includes`.
 export type IgnoreKind = "path" | "ancestors";
 export interface UpdateModuleGraphParams {
 	path: BiomePath;
+	projectKey: ProjectKey;
 	/**
 	 * The kind of update to apply to the module graph
 	 */
diff --git a/packages/@biomejs/biome/configuration_schema.json b/packages/@biomejs/biome/configuration_schema.json
index 5c60a07904..1a70d7eab8 100644
--- a/packages/@biomejs/biome/configuration_schema.json
+++ b/packages/@biomejs/biome/configuration_schema.json
@@ -100,7 +100,7 @@
 					]
 				},
 				"noAutofocus": {
-					"description": "Enforce that autoFocus prop is not used on elements.\nSee <https://biomejs.dev/linter/rules/no-autofocus>",
+					"description": "Enforce that the autofocus attribute is not used on elements.\nSee <https://biomejs.dev/linter/rules/no-autofocus>",
 					"anyOf": [
 						{ "$ref": "#/$defs/NoAutofocusConfiguration" },
 						{ "type": "null" }
@@ -6238,6 +6238,11 @@
 					"description": "Turborepo build system rules",
 					"type": "string",
 					"const": "turborepo"
+				},
+				{
+					"description": "Rules that require type inference",
+					"type": "string",
+					"const": "types"
 				}
 			]
 		},
@@ -12452,6 +12457,12 @@
 		},
 		"UseIterableCallbackReturnOptions": {
 			"type": "object",
+			"properties": {
+				"checkForEach": {
+					"description": "When `true`, the rule reports `forEach` callbacks that return a value (default behaviour).\nWhen `false` or unset, such callbacks are ignored.",
+					"type": ["boolean", "null"]
+				}
+			},
 			"additionalProperties": false
 		},
 		"UseJsonImportAttributesConfiguration": {
diff --git a/xtask/rules_check/src/lib.rs b/xtask/rules_check/src/lib.rs
index 177b272f5b..d476cb2b3a 100644
--- a/xtask/rules_check/src/lib.rs
+++ b/xtask/rules_check/src/lib.rs
@@ -508,7 +508,7 @@ fn assert_lint(
 
                 let options = test.create_analyzer_options::<HtmlLanguage>(config)?;
 
-                biome_html_analyze::analyze(&root, filter, &options, |signal| {
+                biome_html_analyze::analyze(&root, filter, &options, source, |signal| {
                     if let Some(mut diag) = signal.diagnostic() {
                         for action in signal.actions() {
                             if !action.is_suppression() {
