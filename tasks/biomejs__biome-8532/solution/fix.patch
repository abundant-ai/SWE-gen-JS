diff --git a/.changeset/chubby-buttons-lie.md b/.changeset/chubby-buttons-lie.md
deleted file mode 100644
index 2e35902a2b..0000000000
--- a/.changeset/chubby-buttons-lie.md
+++ /dev/null
@@ -1,9 +0,0 @@
----
-"@biomejs/biome": minor
----
-
-It's now possible to provide the stacktrace for a fatal error. The stacktrace is only available when the environment variable `RUST_BACKTRACE=1` is set, either via the CLI or exported `$PATH`. This is useful when providing detailed information for debugging purposes:
-
-```shell
-RUST_BACKTRACE=1 biome lint
-```
diff --git a/.changeset/dirty-beans-flash.md b/.changeset/dirty-beans-flash.md
deleted file mode 100644
index 64b632b1a9..0000000000
--- a/.changeset/dirty-beans-flash.md
+++ /dev/null
@@ -1,5 +0,0 @@
----
-"@biomejs/biome": minor
----
-
-Fixed [#8024](https://github.com/biomejs/biome/issues/8024). The rule [`useIterableCallbackReturn`](https://biomejs.dev/linter/rules/use-iterable-callback-return/) now supports a `checkForEach` option. When set to `false`, the rule will skip checking for `forEach()` callbacks for returning values.
diff --git a/.changeset/fix-component-export-tanstack-router.md b/.changeset/fix-component-export-tanstack-router.md
deleted file mode 100644
index e9ae0c5807..0000000000
--- a/.changeset/fix-component-export-tanstack-router.md
+++ /dev/null
@@ -1,13 +0,0 @@
----
-"@biomejs/biome": patch
----
-
-Fixed [#8628](https://github.com/biomejs/biome/issues/8628): [`useComponentExportOnlyModules`](https://biomejs.dev/linter/rules/use-component-export-only-modules/) now allows components referenced as object property values in exported expressions. This fixes false positives for TanStack Router patterns.
-
-```jsx
-export const Route = createFileRoute('/')({
-  component: HomeComponent,
-})
-
-function HomeComponent() { ... } // no longer reported as "should be exported"
-```
diff --git a/.changeset/html-no-autofocus.md b/.changeset/html-no-autofocus.md
deleted file mode 100644
index e2bacce5a6..0000000000
--- a/.changeset/html-no-autofocus.md
+++ /dev/null
@@ -1,5 +0,0 @@
----
-"@biomejs/biome": minor
----
-
-Added the [`noAutofocus`](https://biomejs.dev/linter/rules/no-autofocus/) lint rule for HTML. This rule enforces that the `autofocus` attribute is not used on elements, as it can cause usability issues for sighted and non-sighted users. The rule allows `autofocus` inside `dialog` elements or elements with the `popover` attribute, as these are modal contexts where autofocus is expected.
diff --git a/.changeset/html-use-alt-text.md b/.changeset/html-use-alt-text.md
deleted file mode 100644
index 768eb5d844..0000000000
--- a/.changeset/html-use-alt-text.md
+++ /dev/null
@@ -1,5 +0,0 @@
----
-"@biomejs/biome": minor
----
-
-Added the [`useAltText`](https://biomejs.dev/linter/rules/use-alt-text/) lint rule for HTML. This rule enforces that elements requiring alternative text (`<img>`, `<area>`, `<input type="image">`, `<object>`) provide meaningful information for screen reader users via `alt`, `title` (for objects), `aria-label`, or `aria-labelledby` attributes. Elements with `aria-hidden="true"` are exempt.
diff --git a/.changeset/skip-only-check-ci.md b/.changeset/skip-only-check-ci.md
new file mode 100644
index 0000000000..bd431414f9
--- /dev/null
+++ b/.changeset/skip-only-check-ci.md
@@ -0,0 +1,12 @@
+---
+"@biomejs/biome": minor
+---
+
+Added `--only` and `--skip` options to `biome check` and `biome ci`, covering both lint diagnostics and assist actions. Biome now lets you run or exclude specific lint rules, assist actions, group or rules and actions, or domains when running these commands.
+
+Examples:
+
+```shell
+biome check --only=suspicious/noDebugger src/**/*.js
+biome ci --skip=project src/**
+```
diff --git a/.changeset/small-seas-laugh.md b/.changeset/small-seas-laugh.md
deleted file mode 100644
index 2846ef08a7..0000000000
--- a/.changeset/small-seas-laugh.md
+++ /dev/null
@@ -1,5 +0,0 @@
----
-"@biomejs/biome": minor
----
-
-Added the rule [`noRedundantAlt`](https://biomejs.dev/linter/rules/no-redundant-alt/) to HTML. The rule enforces that the `img` element `alt` attribute does not contain the words “image”, “picture”, or “photo”.
diff --git a/.changeset/smooth-dots-swim.md b/.changeset/smooth-dots-swim.md
deleted file mode 100644
index 5bfaa1b604..0000000000
--- a/.changeset/smooth-dots-swim.md
+++ /dev/null
@@ -1,16 +0,0 @@
----
-"@biomejs/biome": minor
----
-
-Added the new linter domain `types`. This is a domain that enables all rules that require the type inference engine.
-
-As opposed to the `project` domain, which only enables rules that require the module graph to function.
-
-The following **nursery** rules have been moved to the `types` domain:
-- `useArraySortCompare`
-- `useAwaitThenable`
-- `useFind`
-- `useRegexpExec`
-- `noUnnecessaryConditions`
-- `noMisusedPromises`
-- `noFloatingPromises`
diff --git a/crates/biome_analyze/src/rule.rs b/crates/biome_analyze/src/rule.rs
index e28942c74e..429f26d9b2 100644
--- a/crates/biome_analyze/src/rule.rs
+++ b/crates/biome_analyze/src/rule.rs
@@ -475,8 +475,6 @@ pub enum RuleDomain {
     Tailwind,
     /// Turborepo build system rules
     Turborepo,
-    /// Rules that require type inference
-    Types,
 }
 
 impl Display for RuleDomain {
@@ -492,7 +490,6 @@ impl Display for RuleDomain {
             Self::Project => fmt.write_str("project"),
             Self::Tailwind => fmt.write_str("tailwind"),
             Self::Turborepo => fmt.write_str("turborepo"),
-            Self::Types => fmt.write_str("types"),
         }
     }
 }
@@ -533,7 +530,6 @@ impl RuleDomain {
             Self::Project => &[],
             Self::Tailwind => &[&("tailwindcss", ">=3.0.0")],
             Self::Turborepo => &[&("turbo", ">=1.0.0")],
-            Self::Types => &[],
         }
     }
 
@@ -560,7 +556,6 @@ impl RuleDomain {
             Self::Project => &[],
             Self::Tailwind => &[],
             Self::Turborepo => &[],
-            Self::Types => &[],
         }
     }
 
@@ -575,7 +570,6 @@ impl RuleDomain {
             Self::Project => "project",
             Self::Tailwind => "tailwind",
             Self::Turborepo => "turborepo",
-            Self::Types => "types",
         }
     }
 }
@@ -594,7 +588,6 @@ impl FromStr for RuleDomain {
             "project" => Ok(Self::Project),
             "tailwind" => Ok(Self::Tailwind),
             "turborepo" => Ok(Self::Turborepo),
-            "types" => Ok(Self::Types),
 
             _ => Err("Invalid rule domain"),
         }
diff --git a/crates/biome_cli/src/commands/check.rs b/crates/biome_cli/src/commands/check.rs
index f02d716466..730f5b26fa 100644
--- a/crates/biome_cli/src/commands/check.rs
+++ b/crates/biome_cli/src/commands/check.rs
@@ -5,6 +5,7 @@ use crate::runner::execution::{AnalyzerSelectors, Execution, VcsTargeted};
 use crate::runner::impls::commands::traversal::{LoadEditorConfig, TraversalCommand};
 use crate::runner::impls::executions::summary_verb::SummaryVerbExecution;
 use crate::runner::impls::process_file::check::CheckProcessFile;
+use biome_configuration::analyzer::AnalyzerSelector;
 use biome_configuration::analyzer::LinterEnabled;
 use biome_configuration::analyzer::assist::{AssistConfiguration, AssistEnabled};
 use biome_configuration::css::CssParserConfiguration;
@@ -41,6 +42,8 @@ pub(crate) struct CheckCommandPayload {
     pub(crate) format_with_errors: Option<FormatWithErrorsEnabled>,
     pub(crate) json_parser: Option<JsonParserConfiguration>,
     pub(crate) css_parser: Option<CssParserConfiguration>,
+    pub(crate) only: Vec<AnalyzerSelector>,
+    pub(crate) skip: Vec<AnalyzerSelector>,
 }
 
 struct CheckExecution {
@@ -61,6 +64,11 @@ struct CheckExecution {
 
     /// It skips parse errors
     skip_parse_errors: bool,
+
+    /// Run only the given lint rule, assist action, group of rules and actions, or domain
+    only: Vec<AnalyzerSelector>,
+    /// Skip the given lint rule, assist action, group of rules and actions, or domain
+    skip: Vec<AnalyzerSelector>,
 }
 
 impl Execution for CheckExecution {
@@ -122,7 +130,10 @@ impl Execution for CheckExecution {
     }
 
     fn analyzer_selectors(&self) -> AnalyzerSelectors {
-        AnalyzerSelectors::default()
+        AnalyzerSelectors {
+            only: self.only.clone(),
+            skip: self.skip.clone(),
+        }
     }
 
     fn should_enforce_assist(&self) -> bool {
@@ -174,6 +185,8 @@ impl TraversalCommand for CheckCommandPayload {
             vcs_targeted: (self.staged, self.changed).into(),
             enforce_assist: self.enforce_assist,
             skip_parse_errors: cli_options.skip_parse_errors,
+            only: self.only.clone(),
+            skip: self.skip.clone(),
         }))
     }
 
diff --git a/crates/biome_cli/src/commands/ci.rs b/crates/biome_cli/src/commands/ci.rs
index 2705735811..da9eadb97a 100644
--- a/crates/biome_cli/src/commands/ci.rs
+++ b/crates/biome_cli/src/commands/ci.rs
@@ -5,6 +5,7 @@ use crate::runner::execution::{AnalyzerSelectors, Execution, ExecutionEnvironmen
 use crate::runner::impls::commands::traversal::{LoadEditorConfig, TraversalCommand};
 use crate::runner::impls::executions::summary_verb::SummaryVerbExecution;
 use crate::runner::impls::process_file::check::CheckProcessFile;
+use biome_configuration::analyzer::AnalyzerSelector;
 use biome_configuration::analyzer::LinterEnabled;
 use biome_configuration::analyzer::assist::{AssistConfiguration, AssistEnabled};
 use biome_configuration::css::CssParserConfiguration;
@@ -37,6 +38,8 @@ pub(crate) struct CiCommandPayload {
     pub(crate) format_with_errors: Option<FormatWithErrorsEnabled>,
     pub(crate) json_parser: Option<JsonParserConfiguration>,
     pub(crate) css_parser: Option<CssParserConfiguration>,
+    pub(crate) only: Vec<AnalyzerSelector>,
+    pub(crate) skip: Vec<AnalyzerSelector>,
 }
 
 struct CiExecution {
@@ -48,6 +51,10 @@ struct CiExecution {
     enforce_assist: bool,
     /// It skips parse errors
     skip_parse_errors: bool,
+    /// Run only the given rule or group of rules.
+    only: Vec<AnalyzerSelector>,
+    /// Skip the given rule or group of rules.
+    skip: Vec<AnalyzerSelector>,
 }
 
 impl Execution for CiExecution {
@@ -95,7 +102,10 @@ impl Execution for CiExecution {
     }
 
     fn analyzer_selectors(&self) -> AnalyzerSelectors {
-        AnalyzerSelectors::default()
+        AnalyzerSelectors {
+            only: self.only.clone(),
+            skip: self.skip.clone(),
+        }
     }
 
     fn should_enforce_assist(&self) -> bool {
@@ -147,6 +157,8 @@ impl TraversalCommand for CiCommandPayload {
             vcs_targeted: (false, self.changed).into(),
             enforce_assist: self.enforce_assist,
             skip_parse_errors: cli_options.skip_parse_errors,
+            only: self.only.clone(),
+            skip: self.skip.clone(),
         }))
     }
 
diff --git a/crates/biome_cli/src/commands/mod.rs b/crates/biome_cli/src/commands/mod.rs
index 6a7970727a..ffeedb74e5 100644
--- a/crates/biome_cli/src/commands/mod.rs
+++ b/crates/biome_cli/src/commands/mod.rs
@@ -181,6 +181,29 @@ pub enum BiomeCommand {
         #[bpaf(long("since"), argument("REF"))]
         since: Option<String>,
 
+        /// Run only the given lint rule, assist action, group of rules and actions, or domain.
+        /// If the severity level of a rule is `off`,
+        /// then the severity level of the rule is set to `error` if it is a recommended rule or `warn` otherwise.
+        ///
+        /// Example:
+        ///
+        /// ```shell
+        /// biome check --only=correctness/noUnusedVariables --only=suspicious --only=test
+        /// ```
+        #[bpaf(long("only"), argument("GROUP|RULE|DOMAIN|ACTION"))]
+        only: Vec<AnalyzerSelector>,
+
+        /// Skip the given lint rule, assist action, group of rules and actions, or domain by setting the severity level of the rules to `off`.
+        /// This option takes precedence over `--only`.
+        ///
+        /// Example:
+        ///
+        /// ```shell
+        /// biome check --skip=correctness/noUnusedVariables --skip=suspicious --skip=project
+        /// ```
+        #[bpaf(long("skip"), argument("GROUP|RULE|DOMAIN|ACTION"))]
+        skip: Vec<AnalyzerSelector>,
+
         /// Single file, single path or list of paths
         #[bpaf(positional("PATH"), many)]
         paths: Vec<OsString>,
@@ -241,7 +264,7 @@ pub enum BiomeCommand {
         #[bpaf(external, hide_usage)]
         log_options: LogOptions,
 
-        /// Run only the given rule, group of rules or domain.
+        /// Run only the given lint rule, assist action, group of rules and actions, or domain.
         /// If the severity level of a rule is `off`,
         /// then the severity level of the rule is set to `error` if it is a recommended rule or `warn` otherwise.
         ///
@@ -250,10 +273,10 @@ pub enum BiomeCommand {
         /// ```shell
         /// biome lint --only=correctness/noUnusedVariables --only=suspicious --only=test
         /// ```
-        #[bpaf(long("only"), argument("GROUP|RULE|DOMAIN"))]
+        #[bpaf(long("only"), argument("GROUP|RULE|DOMAIN|ACTION"))]
         only: Vec<AnalyzerSelector>,
 
-        /// Skip the given rule, group of rules or domain by setting the severity level of the rules to `off`.
+        /// Skip the given lint rule, assist action, group of rules and actions, or domain by setting the severity level of the rules to `off`.
         /// This option takes precedence over `--only`.
         ///
         /// Example:
@@ -261,7 +284,7 @@ pub enum BiomeCommand {
         /// ```shell
         /// biome lint --skip=correctness/noUnusedVariables --skip=suspicious --skip=project
         /// ```
-        #[bpaf(long("skip"), argument("GROUP|RULE|DOMAIN"))]
+        #[bpaf(long("skip"), argument("GROUP|RULE|DOMAIN|ACTION"))]
         skip: Vec<AnalyzerSelector>,
 
         /// Use this option when you want to format code piped from `stdin`, and print the output to `stdout`.
@@ -436,6 +459,29 @@ pub enum BiomeCommand {
         )]
         threads: Option<usize>,
 
+        /// Run only the given lint rule, assist action, group of rules and actions, or domain.
+        /// If the severity level of a rule is `off`,
+        /// then the severity level of the rule is set to `error` if it is a recommended rule or `warn` otherwise.
+        ///
+        /// Example:
+        ///
+        /// ```shell
+        /// biome ci --only=correctness/noUnusedVariables --only=suspicious --only=test
+        /// ```
+        #[bpaf(long("only"), argument("GROUP|RULE|DOMAIN|ACTION"))]
+        only: Vec<AnalyzerSelector>,
+
+        /// Skip the given lint rule, assist action, group of rules and actions, or domain by setting the severity level of the rules to `off`.
+        /// This option takes precedence over `--only`.
+        ///
+        /// Example:
+        ///
+        /// ```shell
+        /// biome ci --skip=correctness/noUnusedVariables --skip=suspicious --skip=project
+        /// ```
+        #[bpaf(long("skip"), argument("GROUP|RULE|DOMAIN|ACTION"))]
+        skip: Vec<AnalyzerSelector>,
+
         /// Single file, single path or list of paths
         #[bpaf(positional("PATH"), many)]
         paths: Vec<OsString>,
diff --git a/crates/biome_cli/src/lib.rs b/crates/biome_cli/src/lib.rs
index 2442c80744..5925738e85 100644
--- a/crates/biome_cli/src/lib.rs
+++ b/crates/biome_cli/src/lib.rs
@@ -97,6 +97,8 @@ impl<'app> CliSession<'app> {
                 json_parser,
                 css_parser,
                 log_options,
+                only,
+                skip,
             } => run_command(
                 self,
                 &log_options,
@@ -118,6 +120,8 @@ impl<'app> CliSession<'app> {
                     format_with_errors,
                     json_parser,
                     css_parser,
+                    only,
+                    skip,
                 }),
             ),
             BiomeCommand::Lint {
@@ -186,6 +190,8 @@ impl<'app> CliSession<'app> {
                 css_parser,
                 json_parser,
                 log_options,
+                only,
+                skip,
                 ..
             } => run_command(
                 self,
@@ -203,6 +209,8 @@ impl<'app> CliSession<'app> {
                     format_with_errors,
                     css_parser,
                     json_parser,
+                    only,
+                    skip,
                 }),
             ),
             BiomeCommand::Format {
diff --git a/crates/biome_cli/src/panic.rs b/crates/biome_cli/src/panic.rs
index 1e72cda86f..1e1f5976e1 100644
--- a/crates/biome_cli/src/panic.rs
+++ b/crates/biome_cli/src/panic.rs
@@ -1,5 +1,4 @@
 use std::{
-    backtrace::{Backtrace, BacktraceStatus},
     fmt::Write,
     panic::{PanicHookInfo, set_hook},
     thread,
@@ -12,68 +11,39 @@ pub fn setup_panic_handler() {
 }
 
 fn panic_handler(info: &PanicHookInfo) {
-    let error = write_error(info).expect("To write into buffer");
-
-    // Write the panic to stderr
-    eprintln!("{error}");
-
-    // Write the panic to the log file, this is done last since the `tracing`
-    // infrastructure could panic a second time and abort the process, so we
-    // want to ensure the error has at least been logged to stderr beforehand
-    tracing::error!("{error}");
-}
-
-fn write_error(info: &PanicHookInfo) -> Result<String, std::fmt::Error> {
     // Buffer the error message to a string before printing it at once
     // to prevent it from getting mixed with other errors if multiple threads
     // panic at the same time
     let mut error = String::new();
 
-    writeln!(error, "Biome encountered an unexpected error")?;
-    writeln!(error)?;
+    writeln!(error, "Biome encountered an unexpected error").unwrap();
+    writeln!(error).unwrap();
 
-    writeln!(
-        error,
-        "This is a bug in Biome, not an error in your code, and we would appreciate it if you could report it to https://github.com/biomejs/biome/issues/ along with the following information to help us fixing the issue."
-    )?;
-    writeln!(error)?;
-    writeln!(
-        error,
-        "When opening the issue, please provide a minimal reproduction, or identify and share the file/code that triggers it. Without a way to reproduce the error, the error can't be fixed:"
-    )?;
-    writeln!(error)?;
+    writeln!(error, "This is a bug in Biome, not an error in your code, and we would appreciate it if you could report it to https://github.com/biomejs/biome/issues/ along with the following information to help us fixing the issue.").unwrap();
+    writeln!(error).unwrap();
+    writeln!(error, "When opening the issue, please provide a minimal reproduction, or identify and share the file/code that triggers it. Without a way to reproduce the error, the error can't be fixed:").unwrap();
+    writeln!(error).unwrap();
 
     if let Some(location) = info.location() {
-        writeln!(error, "Source Location: {location}")?;
+        writeln!(error, "Source Location: {location}").unwrap();
     }
 
     if let Some(thread) = thread::current().name() {
-        writeln!(error, "Thread Name: {thread}")?;
+        writeln!(error, "Thread Name: {thread}").unwrap();
     }
 
     let payload = info.payload();
     if let Some(msg) = payload.downcast_ref::<&'static str>() {
-        writeln!(error, "Message: {msg}")?;
+        writeln!(error, "Message: {msg}").unwrap();
     } else if let Some(msg) = payload.downcast_ref::<String>() {
-        writeln!(error, "Message: {msg}")?;
+        writeln!(error, "Message: {msg}").unwrap();
     }
 
-    let backtrace = Backtrace::capture();
-    match backtrace.status() {
-        BacktraceStatus::Captured => {
-            writeln!(error, "Stack Trace:")?;
-            writeln!(error, "{}", backtrace)?;
-        }
-        BacktraceStatus::Disabled => {
-            writeln!(
-                error,
-                "Stack Trace: Re-run with `RUST_BACKTRACE=1` to capture the stack trace"
-            )?;
-        }
-        _ => {
-            writeln!(error, "Stack Trace: Not Supported")?;
-        }
-    }
+    // Write the panic to stderr
+    eprintln!("{error}");
 
-    Ok(error)
+    // Write the panic to the log file, this is done last since the `tracing`
+    // infrastructure could panic a second time and abort the process, so we
+    // want to ensure the error has at least been logged to stderr beforehand
+    tracing::error!("{error}");
 }
diff --git a/crates/biome_cli/src/runner/mod.rs b/crates/biome_cli/src/runner/mod.rs
index 0b8012b0f0..8adc177cc5 100644
--- a/crates/biome_cli/src/runner/mod.rs
+++ b/crates/biome_cli/src/runner/mod.rs
@@ -152,7 +152,6 @@ use biome_fs::{BiomePath, FileSystem};
 use biome_resolver::FsWithResolverProxy;
 use biome_service::configuration::{LoadedConfiguration, ProjectScanComputer, load_configuration};
 use biome_service::projects::ProjectKey;
-use biome_service::settings::ModuleGraphResolutionKind;
 use biome_service::workspace::{
     OpenProjectParams, ScanKind, ScanProjectParams, UpdateSettingsParams,
 };
@@ -406,10 +405,6 @@ pub(crate) trait CommandRunner {
             self.minimal_scan_kind(),
         );
 
-        // Scan the project
-        let scan_kind =
-            execution.compute_scan_kind(paths.as_slice(), working_dir.as_path(), scan_kind);
-
         // Update the settings of the project
         let result = workspace.update_settings(UpdateSettingsParams {
             project_key: open_project_result.project_key,
@@ -419,7 +414,6 @@ pub(crate) trait CommandRunner {
                 .into_iter()
                 .map(|(path, config)| (BiomePath::from(path), config))
                 .collect(),
-            module_graph_resolution_kind: ModuleGraphResolutionKind::from(&scan_kind),
         })?;
         if self.should_validate_configuration_diagnostics() {
             print_diagnostics_from_workspace_result(
@@ -429,6 +423,10 @@ pub(crate) trait CommandRunner {
             )?;
         }
 
+        // Scan the project
+        let scan_kind =
+            execution.compute_scan_kind(paths.as_slice(), working_dir.as_path(), scan_kind);
+
         let result = workspace.scan_project(ScanProjectParams {
             project_key: open_project_result.project_key,
             watch: cli_options.use_server,
diff --git a/crates/biome_configuration/src/analyzer/linter/rules.rs b/crates/biome_configuration/src/analyzer/linter/rules.rs
index 083a833f8f..45e4084245 100644
--- a/crates/biome_configuration/src/analyzer/linter/rules.rs
+++ b/crates/biome_configuration/src/analyzer/linter/rules.rs
@@ -2072,7 +2072,7 @@ impl Rules {
 #[cfg_attr(feature = "schema", derive(JsonSchema))]
 #[serde(rename_all = "camelCase", default, deny_unknown_fields)]
 #[doc = r" A list of rules that belong to this group"]
-pub struct A11y { # [doc = r" Enables the recommended rules for this group"] # [serde (skip_serializing_if = "Option::is_none")] pub recommended : Option < bool > , # [doc = "Enforce that the accesskey attribute is not used on any HTML element.\nSee <https://biomejs.dev/linter/rules/no-access-key>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_access_key : Option < RuleFixConfiguration < biome_rule_options :: no_access_key :: NoAccessKeyOptions >> , # [doc = "Enforce that aria-hidden=\"true\" is not set on focusable elements.\nSee <https://biomejs.dev/linter/rules/no-aria-hidden-on-focusable>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_aria_hidden_on_focusable : Option < RuleFixConfiguration < biome_rule_options :: no_aria_hidden_on_focusable :: NoAriaHiddenOnFocusableOptions >> , # [doc = "Enforce that elements that do not support ARIA roles, states, and properties do not have those attributes.\nSee <https://biomejs.dev/linter/rules/no-aria-unsupported-elements>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_aria_unsupported_elements : Option < RuleFixConfiguration < biome_rule_options :: no_aria_unsupported_elements :: NoAriaUnsupportedElementsOptions >> , # [doc = "Enforce that the autofocus attribute is not used on elements.\nSee <https://biomejs.dev/linter/rules/no-autofocus>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_autofocus : Option < RuleFixConfiguration < biome_rule_options :: no_autofocus :: NoAutofocusOptions >> , # [doc = "Enforces that no distracting elements are used.\nSee <https://biomejs.dev/linter/rules/no-distracting-elements>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_distracting_elements : Option < RuleFixConfiguration < biome_rule_options :: no_distracting_elements :: NoDistractingElementsOptions >> , # [doc = "The scope prop should be used only on \\<th> elements.\nSee <https://biomejs.dev/linter/rules/no-header-scope>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_header_scope : Option < RuleFixConfiguration < biome_rule_options :: no_header_scope :: NoHeaderScopeOptions >> , # [doc = "Enforce that non-interactive ARIA roles are not assigned to interactive HTML elements.\nSee <https://biomejs.dev/linter/rules/no-interactive-element-to-noninteractive-role>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_interactive_element_to_noninteractive_role : Option < RuleFixConfiguration < biome_rule_options :: no_interactive_element_to_noninteractive_role :: NoInteractiveElementToNoninteractiveRoleOptions >> , # [doc = "Enforce that a label element or component has a text label and an associated input.\nSee <https://biomejs.dev/linter/rules/no-label-without-control>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_label_without_control : Option < RuleConfiguration < biome_rule_options :: no_label_without_control :: NoLabelWithoutControlOptions >> , # [doc = "Disallow use event handlers on non-interactive elements.\nSee <https://biomejs.dev/linter/rules/no-noninteractive-element-interactions>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_noninteractive_element_interactions : Option < RuleConfiguration < biome_rule_options :: no_noninteractive_element_interactions :: NoNoninteractiveElementInteractionsOptions >> , # [doc = "Enforce that interactive ARIA roles are not assigned to non-interactive HTML elements.\nSee <https://biomejs.dev/linter/rules/no-noninteractive-element-to-interactive-role>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_noninteractive_element_to_interactive_role : Option < RuleFixConfiguration < biome_rule_options :: no_noninteractive_element_to_interactive_role :: NoNoninteractiveElementToInteractiveRoleOptions >> , # [doc = "Enforce that tabIndex is not assigned to non-interactive HTML elements.\nSee <https://biomejs.dev/linter/rules/no-noninteractive-tabindex>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_noninteractive_tabindex : Option < RuleFixConfiguration < biome_rule_options :: no_noninteractive_tabindex :: NoNoninteractiveTabindexOptions >> , # [doc = "Prevent the usage of positive integers on tabindex attribute.\nSee <https://biomejs.dev/linter/rules/no-positive-tabindex>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_positive_tabindex : Option < RuleFixConfiguration < biome_rule_options :: no_positive_tabindex :: NoPositiveTabindexOptions >> , # [doc = "Enforce img alt prop does not contain the word \"image\", \"picture\", or \"photo\".\nSee <https://biomejs.dev/linter/rules/no-redundant-alt>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_redundant_alt : Option < RuleConfiguration < biome_rule_options :: no_redundant_alt :: NoRedundantAltOptions >> , # [doc = "Enforce explicit role property is not the same as implicit/default role property on an element.\nSee <https://biomejs.dev/linter/rules/no-redundant-roles>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_redundant_roles : Option < RuleFixConfiguration < biome_rule_options :: no_redundant_roles :: NoRedundantRolesOptions >> , # [doc = "Enforce that static, visible elements (such as \\<div>) that have click handlers use the valid role attribute.\nSee <https://biomejs.dev/linter/rules/no-static-element-interactions>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_static_element_interactions : Option < RuleConfiguration < biome_rule_options :: no_static_element_interactions :: NoStaticElementInteractionsOptions >> , # [doc = "Enforces the usage of the title element for the svg element.\nSee <https://biomejs.dev/linter/rules/no-svg-without-title>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_svg_without_title : Option < RuleConfiguration < biome_rule_options :: no_svg_without_title :: NoSvgWithoutTitleOptions >> , # [doc = "Enforce that all elements that require alternative text have meaningful information to relay back to the end user.\nSee <https://biomejs.dev/linter/rules/use-alt-text>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_alt_text : Option < RuleConfiguration < biome_rule_options :: use_alt_text :: UseAltTextOptions >> , # [doc = "Enforce that anchors have content and that the content is accessible to screen readers.\nSee <https://biomejs.dev/linter/rules/use-anchor-content>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_anchor_content : Option < RuleFixConfiguration < biome_rule_options :: use_anchor_content :: UseAnchorContentOptions >> , # [doc = "Enforce that tabIndex is assigned to non-interactive HTML elements with aria-activedescendant.\nSee <https://biomejs.dev/linter/rules/use-aria-activedescendant-with-tabindex>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_aria_activedescendant_with_tabindex : Option < RuleFixConfiguration < biome_rule_options :: use_aria_activedescendant_with_tabindex :: UseAriaActivedescendantWithTabindexOptions >> , # [doc = "Enforce that elements with ARIA roles must have all required ARIA attributes for that role.\nSee <https://biomejs.dev/linter/rules/use-aria-props-for-role>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_aria_props_for_role : Option < RuleConfiguration < biome_rule_options :: use_aria_props_for_role :: UseAriaPropsForRoleOptions >> , # [doc = "Enforce that ARIA properties are valid for the roles that are supported by the element.\nSee <https://biomejs.dev/linter/rules/use-aria-props-supported-by-role>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_aria_props_supported_by_role : Option < RuleConfiguration < biome_rule_options :: use_aria_props_supported_by_role :: UseAriaPropsSupportedByRoleOptions >> , # [doc = "Enforces the usage and validity of the attribute type for the element button.\nSee <https://biomejs.dev/linter/rules/use-button-type>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_button_type : Option < RuleConfiguration < biome_rule_options :: use_button_type :: UseButtonTypeOptions >> , # [doc = "Elements with an interactive role and interaction handlers must be focusable.\nSee <https://biomejs.dev/linter/rules/use-focusable-interactive>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_focusable_interactive : Option < RuleConfiguration < biome_rule_options :: use_focusable_interactive :: UseFocusableInteractiveOptions >> , # [doc = "Disallow a missing generic family keyword within font families.\nSee <https://biomejs.dev/linter/rules/use-generic-font-names>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_generic_font_names : Option < RuleConfiguration < biome_rule_options :: use_generic_font_names :: UseGenericFontNamesOptions >> , # [doc = "Enforce that heading elements (h1, h2, etc.) have content and that the content is accessible to screen readers. Accessible means that it is not hidden using the aria-hidden prop.\nSee <https://biomejs.dev/linter/rules/use-heading-content>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_heading_content : Option < RuleConfiguration < biome_rule_options :: use_heading_content :: UseHeadingContentOptions >> , # [doc = "Enforce that html element has lang attribute.\nSee <https://biomejs.dev/linter/rules/use-html-lang>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_html_lang : Option < RuleConfiguration < biome_rule_options :: use_html_lang :: UseHtmlLangOptions >> , # [doc = "Enforces the usage of the attribute title for the element iframe.\nSee <https://biomejs.dev/linter/rules/use-iframe-title>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_iframe_title : Option < RuleConfiguration < biome_rule_options :: use_iframe_title :: UseIframeTitleOptions >> , # [doc = "Enforce onClick is accompanied by at least one of the following: onKeyUp, onKeyDown, onKeyPress.\nSee <https://biomejs.dev/linter/rules/use-key-with-click-events>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_key_with_click_events : Option < RuleConfiguration < biome_rule_options :: use_key_with_click_events :: UseKeyWithClickEventsOptions >> , # [doc = "Enforce onMouseOver / onMouseOut are accompanied by onFocus / onBlur.\nSee <https://biomejs.dev/linter/rules/use-key-with-mouse-events>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_key_with_mouse_events : Option < RuleConfiguration < biome_rule_options :: use_key_with_mouse_events :: UseKeyWithMouseEventsOptions >> , # [doc = "Enforces that audio and video elements must have a track for captions.\nSee <https://biomejs.dev/linter/rules/use-media-caption>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_media_caption : Option < RuleConfiguration < biome_rule_options :: use_media_caption :: UseMediaCaptionOptions >> , # [doc = "It detects the use of role attributes in JSX elements and suggests using semantic elements instead.\nSee <https://biomejs.dev/linter/rules/use-semantic-elements>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_semantic_elements : Option < RuleConfiguration < biome_rule_options :: use_semantic_elements :: UseSemanticElementsOptions >> , # [doc = "Enforce that all anchors are valid, and they are navigable elements.\nSee <https://biomejs.dev/linter/rules/use-valid-anchor>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_valid_anchor : Option < RuleConfiguration < biome_rule_options :: use_valid_anchor :: UseValidAnchorOptions >> , # [doc = "Ensures that ARIA properties aria-* are all valid.\nSee <https://biomejs.dev/linter/rules/use-valid-aria-props>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_valid_aria_props : Option < RuleFixConfiguration < biome_rule_options :: use_valid_aria_props :: UseValidAriaPropsOptions >> , # [doc = "Elements with ARIA roles must use a valid, non-abstract ARIA role.\nSee <https://biomejs.dev/linter/rules/use-valid-aria-role>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_valid_aria_role : Option < RuleFixConfiguration < biome_rule_options :: use_valid_aria_role :: UseValidAriaRoleOptions >> , # [doc = "Enforce that ARIA state and property values are valid.\nSee <https://biomejs.dev/linter/rules/use-valid-aria-values>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_valid_aria_values : Option < RuleConfiguration < biome_rule_options :: use_valid_aria_values :: UseValidAriaValuesOptions >> , # [doc = "Use valid values for the autocomplete attribute on input elements.\nSee <https://biomejs.dev/linter/rules/use-valid-autocomplete>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_valid_autocomplete : Option < RuleConfiguration < biome_rule_options :: use_valid_autocomplete :: UseValidAutocompleteOptions >> , # [doc = "Ensure that the attribute passed to the lang attribute is a correct ISO language and/or country.\nSee <https://biomejs.dev/linter/rules/use-valid-lang>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_valid_lang : Option < RuleConfiguration < biome_rule_options :: use_valid_lang :: UseValidLangOptions >> }
+pub struct A11y { # [doc = r" Enables the recommended rules for this group"] # [serde (skip_serializing_if = "Option::is_none")] pub recommended : Option < bool > , # [doc = "Enforce that the accesskey attribute is not used on any HTML element.\nSee <https://biomejs.dev/linter/rules/no-access-key>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_access_key : Option < RuleFixConfiguration < biome_rule_options :: no_access_key :: NoAccessKeyOptions >> , # [doc = "Enforce that aria-hidden=\"true\" is not set on focusable elements.\nSee <https://biomejs.dev/linter/rules/no-aria-hidden-on-focusable>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_aria_hidden_on_focusable : Option < RuleFixConfiguration < biome_rule_options :: no_aria_hidden_on_focusable :: NoAriaHiddenOnFocusableOptions >> , # [doc = "Enforce that elements that do not support ARIA roles, states, and properties do not have those attributes.\nSee <https://biomejs.dev/linter/rules/no-aria-unsupported-elements>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_aria_unsupported_elements : Option < RuleFixConfiguration < biome_rule_options :: no_aria_unsupported_elements :: NoAriaUnsupportedElementsOptions >> , # [doc = "Enforce that autoFocus prop is not used on elements.\nSee <https://biomejs.dev/linter/rules/no-autofocus>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_autofocus : Option < RuleFixConfiguration < biome_rule_options :: no_autofocus :: NoAutofocusOptions >> , # [doc = "Enforces that no distracting elements are used.\nSee <https://biomejs.dev/linter/rules/no-distracting-elements>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_distracting_elements : Option < RuleFixConfiguration < biome_rule_options :: no_distracting_elements :: NoDistractingElementsOptions >> , # [doc = "The scope prop should be used only on \\<th> elements.\nSee <https://biomejs.dev/linter/rules/no-header-scope>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_header_scope : Option < RuleFixConfiguration < biome_rule_options :: no_header_scope :: NoHeaderScopeOptions >> , # [doc = "Enforce that non-interactive ARIA roles are not assigned to interactive HTML elements.\nSee <https://biomejs.dev/linter/rules/no-interactive-element-to-noninteractive-role>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_interactive_element_to_noninteractive_role : Option < RuleFixConfiguration < biome_rule_options :: no_interactive_element_to_noninteractive_role :: NoInteractiveElementToNoninteractiveRoleOptions >> , # [doc = "Enforce that a label element or component has a text label and an associated input.\nSee <https://biomejs.dev/linter/rules/no-label-without-control>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_label_without_control : Option < RuleConfiguration < biome_rule_options :: no_label_without_control :: NoLabelWithoutControlOptions >> , # [doc = "Disallow use event handlers on non-interactive elements.\nSee <https://biomejs.dev/linter/rules/no-noninteractive-element-interactions>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_noninteractive_element_interactions : Option < RuleConfiguration < biome_rule_options :: no_noninteractive_element_interactions :: NoNoninteractiveElementInteractionsOptions >> , # [doc = "Enforce that interactive ARIA roles are not assigned to non-interactive HTML elements.\nSee <https://biomejs.dev/linter/rules/no-noninteractive-element-to-interactive-role>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_noninteractive_element_to_interactive_role : Option < RuleFixConfiguration < biome_rule_options :: no_noninteractive_element_to_interactive_role :: NoNoninteractiveElementToInteractiveRoleOptions >> , # [doc = "Enforce that tabIndex is not assigned to non-interactive HTML elements.\nSee <https://biomejs.dev/linter/rules/no-noninteractive-tabindex>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_noninteractive_tabindex : Option < RuleFixConfiguration < biome_rule_options :: no_noninteractive_tabindex :: NoNoninteractiveTabindexOptions >> , # [doc = "Prevent the usage of positive integers on tabindex attribute.\nSee <https://biomejs.dev/linter/rules/no-positive-tabindex>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_positive_tabindex : Option < RuleFixConfiguration < biome_rule_options :: no_positive_tabindex :: NoPositiveTabindexOptions >> , # [doc = "Enforce img alt prop does not contain the word \"image\", \"picture\", or \"photo\".\nSee <https://biomejs.dev/linter/rules/no-redundant-alt>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_redundant_alt : Option < RuleConfiguration < biome_rule_options :: no_redundant_alt :: NoRedundantAltOptions >> , # [doc = "Enforce explicit role property is not the same as implicit/default role property on an element.\nSee <https://biomejs.dev/linter/rules/no-redundant-roles>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_redundant_roles : Option < RuleFixConfiguration < biome_rule_options :: no_redundant_roles :: NoRedundantRolesOptions >> , # [doc = "Enforce that static, visible elements (such as \\<div>) that have click handlers use the valid role attribute.\nSee <https://biomejs.dev/linter/rules/no-static-element-interactions>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_static_element_interactions : Option < RuleConfiguration < biome_rule_options :: no_static_element_interactions :: NoStaticElementInteractionsOptions >> , # [doc = "Enforces the usage of the title element for the svg element.\nSee <https://biomejs.dev/linter/rules/no-svg-without-title>"] # [serde (skip_serializing_if = "Option::is_none")] pub no_svg_without_title : Option < RuleConfiguration < biome_rule_options :: no_svg_without_title :: NoSvgWithoutTitleOptions >> , # [doc = "Enforce that all elements that require alternative text have meaningful information to relay back to the end user.\nSee <https://biomejs.dev/linter/rules/use-alt-text>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_alt_text : Option < RuleConfiguration < biome_rule_options :: use_alt_text :: UseAltTextOptions >> , # [doc = "Enforce that anchors have content and that the content is accessible to screen readers.\nSee <https://biomejs.dev/linter/rules/use-anchor-content>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_anchor_content : Option < RuleFixConfiguration < biome_rule_options :: use_anchor_content :: UseAnchorContentOptions >> , # [doc = "Enforce that tabIndex is assigned to non-interactive HTML elements with aria-activedescendant.\nSee <https://biomejs.dev/linter/rules/use-aria-activedescendant-with-tabindex>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_aria_activedescendant_with_tabindex : Option < RuleFixConfiguration < biome_rule_options :: use_aria_activedescendant_with_tabindex :: UseAriaActivedescendantWithTabindexOptions >> , # [doc = "Enforce that elements with ARIA roles must have all required ARIA attributes for that role.\nSee <https://biomejs.dev/linter/rules/use-aria-props-for-role>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_aria_props_for_role : Option < RuleConfiguration < biome_rule_options :: use_aria_props_for_role :: UseAriaPropsForRoleOptions >> , # [doc = "Enforce that ARIA properties are valid for the roles that are supported by the element.\nSee <https://biomejs.dev/linter/rules/use-aria-props-supported-by-role>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_aria_props_supported_by_role : Option < RuleConfiguration < biome_rule_options :: use_aria_props_supported_by_role :: UseAriaPropsSupportedByRoleOptions >> , # [doc = "Enforces the usage and validity of the attribute type for the element button.\nSee <https://biomejs.dev/linter/rules/use-button-type>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_button_type : Option < RuleConfiguration < biome_rule_options :: use_button_type :: UseButtonTypeOptions >> , # [doc = "Elements with an interactive role and interaction handlers must be focusable.\nSee <https://biomejs.dev/linter/rules/use-focusable-interactive>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_focusable_interactive : Option < RuleConfiguration < biome_rule_options :: use_focusable_interactive :: UseFocusableInteractiveOptions >> , # [doc = "Disallow a missing generic family keyword within font families.\nSee <https://biomejs.dev/linter/rules/use-generic-font-names>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_generic_font_names : Option < RuleConfiguration < biome_rule_options :: use_generic_font_names :: UseGenericFontNamesOptions >> , # [doc = "Enforce that heading elements (h1, h2, etc.) have content and that the content is accessible to screen readers. Accessible means that it is not hidden using the aria-hidden prop.\nSee <https://biomejs.dev/linter/rules/use-heading-content>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_heading_content : Option < RuleConfiguration < biome_rule_options :: use_heading_content :: UseHeadingContentOptions >> , # [doc = "Enforce that html element has lang attribute.\nSee <https://biomejs.dev/linter/rules/use-html-lang>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_html_lang : Option < RuleConfiguration < biome_rule_options :: use_html_lang :: UseHtmlLangOptions >> , # [doc = "Enforces the usage of the attribute title for the element iframe.\nSee <https://biomejs.dev/linter/rules/use-iframe-title>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_iframe_title : Option < RuleConfiguration < biome_rule_options :: use_iframe_title :: UseIframeTitleOptions >> , # [doc = "Enforce onClick is accompanied by at least one of the following: onKeyUp, onKeyDown, onKeyPress.\nSee <https://biomejs.dev/linter/rules/use-key-with-click-events>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_key_with_click_events : Option < RuleConfiguration < biome_rule_options :: use_key_with_click_events :: UseKeyWithClickEventsOptions >> , # [doc = "Enforce onMouseOver / onMouseOut are accompanied by onFocus / onBlur.\nSee <https://biomejs.dev/linter/rules/use-key-with-mouse-events>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_key_with_mouse_events : Option < RuleConfiguration < biome_rule_options :: use_key_with_mouse_events :: UseKeyWithMouseEventsOptions >> , # [doc = "Enforces that audio and video elements must have a track for captions.\nSee <https://biomejs.dev/linter/rules/use-media-caption>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_media_caption : Option < RuleConfiguration < biome_rule_options :: use_media_caption :: UseMediaCaptionOptions >> , # [doc = "It detects the use of role attributes in JSX elements and suggests using semantic elements instead.\nSee <https://biomejs.dev/linter/rules/use-semantic-elements>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_semantic_elements : Option < RuleConfiguration < biome_rule_options :: use_semantic_elements :: UseSemanticElementsOptions >> , # [doc = "Enforce that all anchors are valid, and they are navigable elements.\nSee <https://biomejs.dev/linter/rules/use-valid-anchor>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_valid_anchor : Option < RuleConfiguration < biome_rule_options :: use_valid_anchor :: UseValidAnchorOptions >> , # [doc = "Ensures that ARIA properties aria-* are all valid.\nSee <https://biomejs.dev/linter/rules/use-valid-aria-props>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_valid_aria_props : Option < RuleFixConfiguration < biome_rule_options :: use_valid_aria_props :: UseValidAriaPropsOptions >> , # [doc = "Elements with ARIA roles must use a valid, non-abstract ARIA role.\nSee <https://biomejs.dev/linter/rules/use-valid-aria-role>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_valid_aria_role : Option < RuleFixConfiguration < biome_rule_options :: use_valid_aria_role :: UseValidAriaRoleOptions >> , # [doc = "Enforce that ARIA state and property values are valid.\nSee <https://biomejs.dev/linter/rules/use-valid-aria-values>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_valid_aria_values : Option < RuleConfiguration < biome_rule_options :: use_valid_aria_values :: UseValidAriaValuesOptions >> , # [doc = "Use valid values for the autocomplete attribute on input elements.\nSee <https://biomejs.dev/linter/rules/use-valid-autocomplete>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_valid_autocomplete : Option < RuleConfiguration < biome_rule_options :: use_valid_autocomplete :: UseValidAutocompleteOptions >> , # [doc = "Ensure that the attribute passed to the lang attribute is a correct ISO language and/or country.\nSee <https://biomejs.dev/linter/rules/use-valid-lang>"] # [serde (skip_serializing_if = "Option::is_none")] pub use_valid_lang : Option < RuleConfiguration < biome_rule_options :: use_valid_lang :: UseValidLangOptions >> }
 impl A11y {
     const GROUP_NAME: &'static str = "a11y";
     pub(crate) const GROUP_RULES: &'static [&'static str] = &[
diff --git a/crates/biome_configuration/src/generated/domain_selector.rs b/crates/biome_configuration/src/generated/domain_selector.rs
index 62ab7397c5..03fd957d57 100644
--- a/crates/biome_configuration/src/generated/domain_selector.rs
+++ b/crates/biome_configuration/src/generated/domain_selector.rs
@@ -25,8 +25,16 @@ static PROJECT_FILTERS: LazyLock<Vec<RuleFilter<'static>>> = LazyLock::new(|| {
         RuleFilter::Rule("correctness", "useImportExtensions"),
         RuleFilter::Rule("correctness", "useJsonImportAttributes"),
         RuleFilter::Rule("nursery", "noDeprecatedImports"),
+        RuleFilter::Rule("nursery", "noFloatingPromises"),
         RuleFilter::Rule("nursery", "noImportCycles"),
+        RuleFilter::Rule("nursery", "noMisusedPromises"),
+        RuleFilter::Rule("nursery", "noUnnecessaryConditions"),
         RuleFilter::Rule("nursery", "noUnresolvedImports"),
+        RuleFilter::Rule("nursery", "useArraySortCompare"),
+        RuleFilter::Rule("nursery", "useAwaitThenable"),
+        RuleFilter::Rule("nursery", "useExhaustiveSwitchCases"),
+        RuleFilter::Rule("nursery", "useFind"),
+        RuleFilter::Rule("nursery", "useRegexpExec"),
     ]
 });
 static QWIK_FILTERS: LazyLock<Vec<RuleFilter<'static>>> = LazyLock::new(|| {
@@ -81,18 +89,6 @@ static TEST_FILTERS: LazyLock<Vec<RuleFilter<'static>>> = LazyLock::new(|| {
 });
 static TURBOREPO_FILTERS: LazyLock<Vec<RuleFilter<'static>>> =
     LazyLock::new(|| vec![RuleFilter::Rule("nursery", "noUndeclaredEnvVars")]);
-static TYPES_FILTERS: LazyLock<Vec<RuleFilter<'static>>> = LazyLock::new(|| {
-    vec![
-        RuleFilter::Rule("nursery", "noFloatingPromises"),
-        RuleFilter::Rule("nursery", "noMisusedPromises"),
-        RuleFilter::Rule("nursery", "noUnnecessaryConditions"),
-        RuleFilter::Rule("nursery", "useArraySortCompare"),
-        RuleFilter::Rule("nursery", "useAwaitThenable"),
-        RuleFilter::Rule("nursery", "useExhaustiveSwitchCases"),
-        RuleFilter::Rule("nursery", "useFind"),
-        RuleFilter::Rule("nursery", "useRegexpExec"),
-    ]
-});
 static VUE_FILTERS: LazyLock<Vec<RuleFilter<'static>>> = LazyLock::new(|| {
     vec![
         RuleFilter::Rule("nursery", "noVueDataObjectDeclaration"),
@@ -115,7 +111,6 @@ impl DomainSelector {
             "solid" => SOLID_FILTERS.clone(),
             "test" => TEST_FILTERS.clone(),
             "turborepo" => TURBOREPO_FILTERS.clone(),
-            "types" => TYPES_FILTERS.clone(),
             "vue" => VUE_FILTERS.clone(),
             _ => unreachable!("DomainFilter::as_rule_filters: domain {} not found", self.0),
         }
@@ -136,7 +131,6 @@ impl DomainSelector {
             "turborepo" => TURBOREPO_FILTERS
                 .iter()
                 .any(|filter| filter.match_rule::<R>()),
-            "types" => TYPES_FILTERS.iter().any(|filter| filter.match_rule::<R>()),
             "vue" => VUE_FILTERS.iter().any(|filter| filter.match_rule::<R>()),
             _ => false,
         }
diff --git a/crates/biome_html_analyze/src/lib.rs b/crates/biome_html_analyze/src/lib.rs
index 6c2fbb2fe6..30850f0f47 100644
--- a/crates/biome_html_analyze/src/lib.rs
+++ b/crates/biome_html_analyze/src/lib.rs
@@ -15,7 +15,7 @@ use biome_analyze::{
 };
 use biome_deserialize::TextRange;
 use biome_diagnostics::Error;
-use biome_html_syntax::{HtmlFileSource, HtmlLanguage};
+use biome_html_syntax::HtmlLanguage;
 use biome_suppression::{SuppressionDiagnostic, parse_suppression_comment};
 use std::ops::Deref;
 use std::sync::LazyLock;
@@ -35,14 +35,13 @@ pub fn analyze<'a, F, B>(
     root: &LanguageRoot<HtmlLanguage>,
     filter: AnalysisFilter,
     options: &'a AnalyzerOptions,
-    source_type: HtmlFileSource,
     emit_signal: F,
 ) -> (Option<B>, Vec<Error>)
 where
     F: FnMut(&dyn AnalyzerSignal<HtmlLanguage>) -> ControlFlow<B> + 'a,
     B: 'a,
 {
-    analyze_with_inspect_matcher(root, filter, |_| {}, options, source_type, emit_signal)
+    analyze_with_inspect_matcher(root, filter, |_| {}, options, emit_signal)
 }
 
 /// Run the analyzer on the provided `root`: this process will use the given `filter`
@@ -56,7 +55,6 @@ pub fn analyze_with_inspect_matcher<'a, V, F, B>(
     filter: AnalysisFilter,
     inspect_matcher: V,
     options: &'a AnalyzerOptions,
-    source_type: HtmlFileSource,
     mut emit_signal: F,
 ) -> (Option<B>, Vec<Error>)
 where
@@ -93,15 +91,13 @@ where
     let mut registry = RuleRegistry::builder(&filter, root);
     visit_registry(&mut registry);
 
-    let (registry, mut services, diagnostics, visitors) = registry.build();
+    let (registry, services, diagnostics, visitors) = registry.build();
 
     // Bail if we can't parse a rule option
     if !diagnostics.is_empty() {
         return (None, diagnostics);
     }
 
-    services.insert_service(source_type);
-
     let mut analyzer = biome_analyze::Analyzer::new(
         METADATA.deref(),
         biome_analyze::InspectMatcher::new(registry, inspect_matcher),
@@ -134,7 +130,6 @@ mod tests {
     use biome_diagnostics::termcolor::NoColor;
     use biome_diagnostics::{Diagnostic, DiagnosticExt, PrintDiagnostic, Severity};
     use biome_html_parser::parse_html;
-    use biome_html_syntax::HtmlFileSource;
     use biome_rowan::TextRange;
     use std::slice;
 
@@ -164,7 +159,6 @@ mod tests {
                 ..AnalysisFilter::default()
             },
             &options,
-            HtmlFileSource::html(),
             |signal| {
                 if let Some(diag) = signal.diagnostic() {
                     error_ranges.push(diag.location().span.unwrap());
diff --git a/crates/biome_html_analyze/src/lint/a11y.rs b/crates/biome_html_analyze/src/lint/a11y.rs
index 73946eb0f7..e509af00bd 100644
--- a/crates/biome_html_analyze/src/lint/a11y.rs
+++ b/crates/biome_html_analyze/src/lint/a11y.rs
@@ -4,16 +4,13 @@
 
 use biome_analyze::declare_lint_group;
 pub mod no_access_key;
-pub mod no_autofocus;
 pub mod no_distracting_elements;
 pub mod no_header_scope;
 pub mod no_positive_tabindex;
-pub mod no_redundant_alt;
 pub mod no_svg_without_title;
-pub mod use_alt_text;
 pub mod use_aria_props_for_role;
 pub mod use_button_type;
 pub mod use_html_lang;
 pub mod use_iframe_title;
 pub mod use_valid_aria_role;
-declare_lint_group! { pub A11y { name : "a11y" , rules : [self :: no_access_key :: NoAccessKey , self :: no_autofocus :: NoAutofocus , self :: no_distracting_elements :: NoDistractingElements , self :: no_header_scope :: NoHeaderScope , self :: no_positive_tabindex :: NoPositiveTabindex , self :: no_redundant_alt :: NoRedundantAlt , self :: no_svg_without_title :: NoSvgWithoutTitle , self :: use_alt_text :: UseAltText , self :: use_aria_props_for_role :: UseAriaPropsForRole , self :: use_button_type :: UseButtonType , self :: use_html_lang :: UseHtmlLang , self :: use_iframe_title :: UseIframeTitle , self :: use_valid_aria_role :: UseValidAriaRole ,] } }
+declare_lint_group! { pub A11y { name : "a11y" , rules : [self :: no_access_key :: NoAccessKey , self :: no_distracting_elements :: NoDistractingElements , self :: no_header_scope :: NoHeaderScope , self :: no_positive_tabindex :: NoPositiveTabindex , self :: no_svg_without_title :: NoSvgWithoutTitle , self :: use_aria_props_for_role :: UseAriaPropsForRole , self :: use_button_type :: UseButtonType , self :: use_html_lang :: UseHtmlLang , self :: use_iframe_title :: UseIframeTitle , self :: use_valid_aria_role :: UseValidAriaRole ,] } }
diff --git a/crates/biome_html_analyze/src/lint/a11y/no_autofocus.rs b/crates/biome_html_analyze/src/lint/a11y/no_autofocus.rs
deleted file mode 100644
index 116af8e8c3..0000000000
--- a/crates/biome_html_analyze/src/lint/a11y/no_autofocus.rs
+++ /dev/null
@@ -1,167 +0,0 @@
-use biome_analyze::{
-    Ast, FixKind, Rule, RuleDiagnostic, RuleSource, context::RuleContext, declare_lint_rule,
-};
-use biome_console::markup;
-use biome_diagnostics::Severity;
-use biome_html_syntax::element_ext::AnyHtmlTagElement;
-use biome_html_syntax::{HtmlAttribute, HtmlElement, HtmlSelfClosingElement};
-use biome_rowan::{AstNode, BatchMutationExt};
-use biome_rule_options::no_autofocus::NoAutofocusOptions;
-
-use crate::HtmlRuleAction;
-
-declare_lint_rule! {
-    /// Enforce that the `autofocus` attribute is not used on elements.
-    ///
-    /// Autofocusing elements can cause usability issues for sighted and non-sighted users, alike.
-    /// However, the `autofocus` attribute is allowed on elements inside a `dialog` element or
-    /// elements with a `popover` attribute, as these are modal contexts where autofocus is expected.
-    ///
-    /// ## Examples
-    ///
-    /// ### Invalid
-    ///
-    /// ```html,expect_diagnostic
-    /// <input autofocus />
-    /// ```
-    ///
-    /// ```html,expect_diagnostic
-    /// <input autofocus="true" />
-    /// ```
-    ///
-    /// ```html,expect_diagnostic
-    /// <textarea autofocus>content</textarea>
-    /// ```
-    ///
-    /// ### Valid
-    ///
-    /// ```html
-    /// <input />
-    /// ```
-    ///
-    /// ```html
-    /// <div popover><input autofocus /></div>
-    /// ```
-    ///
-    /// ```html
-    /// <dialog><input autofocus /></dialog>
-    /// ```
-    ///
-    /// ## Resources
-    ///
-    /// - [WHATWG HTML Standard, The autofocus attribute](https://html.spec.whatwg.org/multipage/interaction.html#attr-fe-autofocus)
-    /// - [The accessibility of HTML 5 autofocus](https://brucelawson.co.uk/2009/the-accessibility-of-html-5-autofocus/)
-    /// - [MDN Web Docs, HTMLElement: autofocus property](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/autofocus)
-    ///
-    pub NoAutofocus {
-        version: "next",
-        name: "noAutofocus",
-        language: "html",
-        sources: &[RuleSource::EslintJsxA11y("no-autofocus").same()],
-        recommended: true,
-        severity: Severity::Error,
-        fix_kind: FixKind::Unsafe,
-    }
-}
-
-impl Rule for NoAutofocus {
-    type Query = Ast<HtmlAttribute>;
-    type State = ();
-    type Signals = Option<Self::State>;
-    type Options = NoAutofocusOptions;
-
-    fn run(ctx: &RuleContext<Self>) -> Option<Self::State> {
-        let node = ctx.query();
-
-        // Check if this is an autofocus attribute
-        if !is_autofocus_attribute(node) {
-            return None;
-        }
-
-        // Check if element is inside a dialog or has popover attribute in ancestors
-        if is_inside_allowed_context(node).unwrap_or(false) {
-            return None;
-        }
-
-        Some(())
-    }
-
-    fn diagnostic(ctx: &RuleContext<Self>, _state: &Self::State) -> Option<RuleDiagnostic> {
-        let node = ctx.query();
-        Some(RuleDiagnostic::new(
-            rule_category!(),
-            node.syntax().text_trimmed_range(),
-            markup! {
-                "Avoid the "<Emphasis>"autofocus"</Emphasis>" attribute."
-            },
-        ))
-    }
-
-    fn action(ctx: &RuleContext<Self>, _state: &Self::State) -> Option<HtmlRuleAction> {
-        let node = ctx.query();
-        let mut mutation = ctx.root().begin();
-        mutation.remove_node(node.clone());
-        Some(HtmlRuleAction::new(
-            ctx.metadata().action_category(ctx.category(), ctx.group()),
-            ctx.metadata().applicability(),
-            markup! { "Remove the "<Emphasis>"autofocus"</Emphasis>" attribute." }.to_owned(),
-            mutation,
-        ))
-    }
-}
-
-/// Check if the attribute is an autofocus attribute
-fn is_autofocus_attribute(node: &HtmlAttribute) -> bool {
-    node.name().is_ok_and(|name| {
-        name.value_token()
-            .is_ok_and(|value_token| value_token.text_trimmed().eq_ignore_ascii_case("autofocus"))
-    })
-}
-
-/// Check if the element is inside an allowed context (dialog or popover)
-///
-/// Note: We skip the first [HtmlElement] (the one containing the autofocus attribute)
-/// because we only want to check if it's *inside* a dialog/popover, not if
-/// it *is* the dialog/popover itself.
-fn is_inside_allowed_context(attr: &HtmlAttribute) -> Option<bool> {
-    let mut skip_first_element = true;
-
-    // Walk up the ancestors to find if we're inside a dialog or popover
-    for ancestor in attr.syntax().ancestors() {
-        let Some(tag_element) = get_tag_element(&ancestor) else {
-            continue;
-        };
-
-        if skip_first_element {
-            skip_first_element = false;
-            continue;
-        }
-
-        if is_dialog_or_popover(&tag_element) {
-            return Some(true);
-        }
-    }
-
-    Some(false)
-}
-
-/// Extract an [AnyHtmlTagElement] from an ancestor node
-fn get_tag_element(node: &biome_html_syntax::HtmlSyntaxNode) -> Option<AnyHtmlTagElement> {
-    HtmlElement::cast_ref(node)
-        .and_then(|e| e.opening_element().ok())
-        .map(AnyHtmlTagElement::from)
-        .or_else(|| {
-            HtmlSelfClosingElement::cast_ref(node).map(|e| AnyHtmlTagElement::from(e.clone()))
-        })
-}
-
-/// Check if the tag element is a dialog or has popover attribute
-fn is_dialog_or_popover(tag_element: &AnyHtmlTagElement) -> bool {
-    let is_dialog = tag_element
-        .name()
-        .ok()
-        .and_then(|n| n.value_token().ok())
-        .is_some_and(|token| token.text_trimmed().eq_ignore_ascii_case("dialog"));
-
-    is_dialog || tag_element.find_attribute_by_name("popover").is_some()
-}
diff --git a/crates/biome_html_analyze/src/lint/a11y/no_redundant_alt.rs b/crates/biome_html_analyze/src/lint/a11y/no_redundant_alt.rs
deleted file mode 100644
index 3815042f47..0000000000
--- a/crates/biome_html_analyze/src/lint/a11y/no_redundant_alt.rs
+++ /dev/null
@@ -1,121 +0,0 @@
-use biome_analyze::{
-    Ast, Rule, RuleDiagnostic, RuleSource, context::RuleContext, declare_lint_rule,
-};
-use biome_console::markup;
-use biome_diagnostics::Severity;
-use biome_html_syntax::element_ext::AnyHtmlTagElement;
-use biome_html_syntax::{AnyHtmlAttributeInitializer, HtmlFileSource};
-use biome_rowan::AstNode;
-use biome_rule_options::is_redundant_alt;
-use biome_rule_options::no_redundant_alt::NoRedundantAltOptions;
-
-declare_lint_rule! {
-    /// Enforce `img` alt prop does not contain the word "image", "picture", or "photo".
-    ///
-    /// The rule will first check if `aria-hidden` is truthy to determine whether to enforce the rule. If the image is
-    /// hidden, then the rule will always succeed.
-    ///
-    /// ## Examples
-    ///
-    /// ### Invalid
-    ///
-    /// ```html,expect_diagnostic
-    /// <img src="src" alt="photo content" />;
-    /// ```
-    ///
-    /// ```html,expect_diagnostic
-    /// <img alt="picture of cool person" aria-hidden="false" />;
-    /// ```
-    ///
-    /// ### Valid
-    ///
-    /// ```html
-    /// <>
-    /// 	<img src="src" alt="alt" />
-    /// 	<img src="bar" aria-hidden alt="Picture of me taking a photo of an image" />
-    /// </>
-    /// ```
-    ///
-    pub NoRedundantAlt {
-        version: "next",
-        name: "noRedundantAlt",
-        language: "html",
-        sources: &[RuleSource::EslintJsxA11y("img-redundant-alt").same()],
-        recommended: true,
-        severity: Severity::Error,
-    }
-}
-
-impl Rule for NoRedundantAlt {
-    type Query = Ast<AnyHtmlTagElement>;
-    type State = AnyHtmlAttributeInitializer;
-    type Signals = Option<Self::State>;
-    type Options = NoRedundantAltOptions;
-
-    fn run(ctx: &RuleContext<Self>) -> Self::Signals {
-        let node = ctx.query();
-        let file_source = ctx.source_type::<HtmlFileSource>();
-
-        let name = node.name().ok()?.value_token().ok()?;
-        if (file_source.is_html() && !name.text_trimmed().eq_ignore_ascii_case("img"))
-            || (!file_source.is_html() && name.text_trimmed() != "img")
-        {
-            return None;
-        }
-
-        let aria_hidden_attribute = node.find_attribute_by_name("aria-hidden");
-        if let Some(aria_hidden) = aria_hidden_attribute {
-            let is_false = match aria_hidden.initializer()?.value().ok()? {
-                AnyHtmlAttributeInitializer::HtmlSingleTextExpression(aria_hidden) => {
-                    aria_hidden
-                        .expression()
-                        .ok()?
-                        .html_literal_token()
-                        .ok()?
-                        .text_trimmed()
-                        == "false"
-                }
-                AnyHtmlAttributeInitializer::HtmlString(aria_hidden) => {
-                    aria_hidden.inner_string_text().ok()?.text() == "false"
-                }
-            };
-
-            if !is_false {
-                return None;
-            }
-        }
-
-        let alt = node
-            .find_attribute_by_name("alt")?
-            .initializer()?
-            .value()
-            .ok()?;
-
-        match alt {
-            AnyHtmlAttributeInitializer::HtmlSingleTextExpression(ref expression) => {
-                let value = expression.expression().ok()?.html_literal_token().ok()?;
-
-                is_redundant_alt(value.text_trimmed()).then_some(alt)
-            }
-            AnyHtmlAttributeInitializer::HtmlString(ref value) => {
-                let inner_string_text = value.inner_string_text().ok()?;
-                is_redundant_alt(inner_string_text.text()).then_some(alt)
-            }
-        }
-    }
-
-    fn diagnostic(_ctx: &RuleContext<Self>, state: &Self::State) -> Option<RuleDiagnostic> {
-        Some(
-            RuleDiagnostic::new(
-                rule_category!(),
-                state.range(),
-                markup! {
-                    "Avoid the words \"image\", \"picture\", or \"photo\" in " <Emphasis>"img"</Emphasis>" element alt text."
-                },
-            )
-            .note(markup! {
-                "Screen readers announce img elements as \"images\", so it is not necessary to redeclare this in alternative text."
-            }),
-        )
-    }
-}
diff --git a/crates/biome_html_analyze/src/lint/a11y/use_alt_text.rs b/crates/biome_html_analyze/src/lint/a11y/use_alt_text.rs
deleted file mode 100644
index e0544bb6eb..0000000000
--- a/crates/biome_html_analyze/src/lint/a11y/use_alt_text.rs
+++ /dev/null
@@ -1,242 +0,0 @@
-use biome_analyze::{
-    Ast, Rule, RuleDiagnostic, RuleSource, context::RuleContext, declare_lint_rule,
-};
-use biome_console::{fmt::Display, fmt::Formatter, markup};
-use biome_diagnostics::Severity;
-use biome_html_syntax::{AnyHtmlElement, HtmlFileSource};
-use biome_rowan::{AstNode, TextRange};
-use biome_rule_options::use_alt_text::UseAltTextOptions;
-
-declare_lint_rule! {
-    /// Enforce that all elements that require alternative text have meaningful information to relay back to the end user.
-    ///
-    /// This is a critical component of accessibility for screen reader users in order for them
-    /// to understand the content's purpose on the page.
-    /// By default, this rule checks for alternative text on the following elements:
-    /// `<img>`, `<area>`, `<input type="image">`, and `<object>`.
-    ///
-    /// :::note
-    /// In `.html` files, this rule matches element names case-insensitively (e.g., `<IMG>`, `<Img>`).
-    ///
-    /// In component-based frameworks (Vue, Svelte, Astro), only lowercase element names are checked.
-    /// PascalCase variants like `<Img>` are assumed to be custom components and are ignored.
-    /// :::
-    ///
-    /// ## Examples
-    ///
-    /// ### Invalid
-    ///
-    /// ```html,expect_diagnostic
-    /// <img src="image.png" />
-    /// ```
-    ///
-    /// ```html,expect_diagnostic
-    /// <input type="image" src="image.png" />
-    /// ```
-    ///
-    /// ```html,expect_diagnostic
-    /// <area href="foo" />
-    /// ```
-    ///
-    /// ```html,expect_diagnostic
-    /// <object data="foo"></object>
-    /// ```
-    ///
-    /// ### Valid
-    ///
-    /// ```html
-    /// <img src="image.png" alt="A beautiful landscape" />
-    /// ```
-    ///
-    /// ```html
-    /// <input type="image" src="image.png" alt="Submit" />
-    /// ```
-    ///
-    /// ```html
-    /// <img src="image.png" aria-label="A beautiful landscape" />
-    /// ```
-    ///
-    /// ```html
-    /// <img src="image.png" aria-labelledby="image-description" />
-    /// ```
-    ///
-    /// ```html
-    /// <object data="foo" title="Embedded content"></object>
-    /// ```
-    ///
-    /// ```html
-    /// <!-- Decorative images can be hidden from assistive technologies -->
-    /// <img src="decorative.png" alt="" />
-    /// ```
-    ///
-    /// ```html
-    /// <img src="decorative.png" aria-hidden="true" />
-    /// ```
-    ///
-    /// ## Accessibility guidelines
-    ///
-    /// - [WCAG 1.1.1](https://www.w3.org/WAI/WCAG21/Understanding/non-text-content.html)
-    ///
-    pub UseAltText {
-        version: "next",
-        name: "useAltText",
-        language: "html",
-        sources: &[RuleSource::EslintJsxA11y("alt-text").same()],
-        recommended: true,
-        severity: Severity::Error,
-    }
-}
-
-/// The type of element being validated
-pub enum ValidatedElement {
-    Object,
-    Img,
-    Area,
-    Input,
-}
-
-impl Display for ValidatedElement {
-    fn fmt(&self, fmt: &mut Formatter) -> std::io::Result<()> {
-        match self {
-            Self::Object => fmt.write_markup(markup!(<Emphasis>"title"</Emphasis>)),
-            _ => fmt.write_markup(markup!(<Emphasis>"alt"</Emphasis>)),
-        }
-    }
-}
-
-impl Rule for UseAltText {
-    type Query = Ast<AnyHtmlElement>;
-    type State = (ValidatedElement, TextRange);
-    type Signals = Option<Self::State>;
-    type Options = UseAltTextOptions;
-
-    fn run(ctx: &RuleContext<Self>) -> Self::Signals {
-        let element = ctx.query();
-        let file_source = ctx.source_type::<HtmlFileSource>();
-
-        let element_name = element.name()?;
-        let is_html_file = file_source.is_html();
-
-        let has_alt = has_valid_alt_text(element);
-        let has_aria_label = has_valid_label(element, "aria-label");
-        let has_aria_labelledby = has_valid_label(element, "aria-labelledby");
-        let aria_hidden = is_aria_hidden(element);
-
-        let name_matches = |name: &str| -> bool {
-            if is_html_file {
-                element_name.eq_ignore_ascii_case(name)
-            } else {
-                element_name.text() == name
-            }
-        };
-
-        if name_matches("object") {
-            let has_title = has_valid_label(element, "title");
-
-            if !has_title && !has_aria_label && !has_aria_labelledby && !aria_hidden {
-                // For object elements, check if it has accessible child content
-                // In HTML, we can't easily check for accessible children, so we flag all
-                // object elements without title/aria-label/aria-labelledby
-                return Some((
-                    ValidatedElement::Object,
-                    element.syntax().text_trimmed_range(),
-                ));
-            }
-        } else if name_matches("img") {
-            if !has_alt && !has_aria_label && !has_aria_labelledby && !aria_hidden {
-                return Some((ValidatedElement::Img, element.syntax().text_trimmed_range()));
-            }
-        } else if name_matches("area") {
-            if !has_alt && !has_aria_label && !has_aria_labelledby && !aria_hidden {
-                return Some((
-                    ValidatedElement::Area,
-                    element.syntax().text_trimmed_range(),
-                ));
-            }
-        } else if name_matches("input")
-            && has_type_image_attribute(element)
-            && !has_alt
-            && !has_aria_label
-            && !has_aria_labelledby
-            && !aria_hidden
-        {
-            return Some((
-                ValidatedElement::Input,
-                element.syntax().text_trimmed_range(),
-            ));
-        }
-
-        None
-    }
-
-    fn diagnostic(_ctx: &RuleContext<Self>, state: &Self::State) -> Option<RuleDiagnostic> {
-        let (validated_element, range) = state;
-        let message = markup!(
-            "Provide a text alternative through the "{validated_element}", "<Emphasis>"aria-label"</Emphasis>", or "<Emphasis>"aria-labelledby"</Emphasis>" attribute."
-        )
-        .to_owned();
-        Some(
-            RuleDiagnostic::new(rule_category!(), range, message)
-                .note(markup! {
-                    "Meaningful alternative text on elements helps users relying on screen readers to understand content's purpose within a page."
-                })
-                .note(markup! {
-                    "If the content is decorative, redundant, or obscured, consider hiding it from assistive technologies with the "<Emphasis>"aria-hidden"</Emphasis>" attribute."
-                }),
-        )
-    }
-}
-
-/// Check if the element has a type="image" attribute
-fn has_type_image_attribute(element: &AnyHtmlElement) -> bool {
-    element
-        .find_attribute_by_name("type")
-        .is_some_and(|attribute| {
-            attribute
-                .initializer()
-                .and_then(|init| init.value().ok())
-                .and_then(|value| value.string_value())
-                .is_some_and(|value| value.eq_ignore_ascii_case("image"))
-        })
-}
-
-/// Check if the element has a valid alt attribute
-fn has_valid_alt_text(element: &AnyHtmlElement) -> bool {
-    // The alt attribute exists - even an empty alt="" is valid for decorative images
-    // If there's no initializer, it's treated as an empty string (valid)
-    // If there's an initializer with a value, any value is valid
-    element.find_attribute_by_name("alt").is_some()
-}
-
-/// Check if the element has a valid label attribute (aria-label, aria-labelledby, or title)
-fn has_valid_label(element: &AnyHtmlElement, name_to_lookup: &str) -> bool {
-    element
-        .find_attribute_by_name(name_to_lookup)
-        .is_some_and(|attribute| {
-            // If no initializer, the attribute is present but empty - not valid for labels
-            let Some(initializer) = attribute.initializer() else {
-                return false;
-            };
-
-            // Check if the value is not empty
-            initializer
-                .value()
-                .ok()
-                .and_then(|value| value.string_value())
-                .is_some_and(|value| !value.trim().is_empty())
-        })
-}
-
-/// Check if the element has aria-hidden="true"
-fn is_aria_hidden(element: &AnyHtmlElement) -> bool {
-    element
-        .find_attribute_by_name("aria-hidden")
-        .is_some_and(|attribute| {
-            // Only aria-hidden="true" means hidden (must have initializer with value "true")
-            attribute
-                .initializer()
-                .and_then(|init| init.value().ok())
-                .and_then(|value| value.string_value())
-                .is_some_and(|value| value == "true")
-        })
-}
diff --git a/crates/biome_html_syntax/src/element_ext.rs b/crates/biome_html_syntax/src/element_ext.rs
index 444d0c9bac..7edc02fd23 100644
--- a/crates/biome_html_syntax/src/element_ext.rs
+++ b/crates/biome_html_syntax/src/element_ext.rs
@@ -219,10 +219,6 @@ impl HtmlElement {
     pub fn is_sass_lang(&self) -> bool {
         self.is_style_tag() && self.has_attribute("lang", "scss")
     }
-
-    pub fn name(&self) -> SyntaxResult<HtmlTagName> {
-        self.opening_element()?.name()
-    }
 }
 
 impl HtmlTagName {
diff --git a/crates/biome_js_analyze/src/lint/a11y/no_redundant_alt.rs b/crates/biome_js_analyze/src/lint/a11y/no_redundant_alt.rs
index b8f3d9d222..2b6dfcfb49 100644
--- a/crates/biome_js_analyze/src/lint/a11y/no_redundant_alt.rs
+++ b/crates/biome_js_analyze/src/lint/a11y/no_redundant_alt.rs
@@ -7,8 +7,8 @@ use biome_js_syntax::{
     AnyJsExpression, AnyJsLiteralExpression, AnyJsTemplateElement, AnyJsxAttributeValue,
 };
 use biome_rowan::AstNode;
-use biome_rule_options::is_redundant_alt;
 use biome_rule_options::no_redundant_alt::NoRedundantAltOptions;
+use biome_string_case::StrLikeExtension;
 
 declare_lint_rule! {
     /// Enforce `img` alt prop does not contain the word "image", "picture", or "photo".
@@ -142,3 +142,12 @@ impl Rule for NoRedundantAlt {
         )
     }
 }
+
+const REDUNDANT_WORDS: [&str; 3] = ["image", "photo", "picture"];
+
+fn is_redundant_alt(alt: &str) -> bool {
+    REDUNDANT_WORDS.into_iter().any(|word| {
+        alt.split_whitespace()
+            .any(|x| x.to_ascii_lowercase_cow() == word)
+    })
+}
diff --git a/crates/biome_js_analyze/src/lint/nursery/no_floating_promises.rs b/crates/biome_js_analyze/src/lint/nursery/no_floating_promises.rs
index f04ef9b5ad..47762a04f5 100644
--- a/crates/biome_js_analyze/src/lint/nursery/no_floating_promises.rs
+++ b/crates/biome_js_analyze/src/lint/nursery/no_floating_promises.rs
@@ -158,7 +158,7 @@ declare_lint_rule! {
         recommended: true,
         sources: &[RuleSource::EslintTypeScript("no-floating-promises").same()],
         fix_kind: FixKind::Unsafe,
-        domains: &[RuleDomain::Types],
+        domains: &[RuleDomain::Project],
     }
 }
 
diff --git a/crates/biome_js_analyze/src/lint/nursery/no_misused_promises.rs b/crates/biome_js_analyze/src/lint/nursery/no_misused_promises.rs
index 70bccf3a36..532e83374f 100644
--- a/crates/biome_js_analyze/src/lint/nursery/no_misused_promises.rs
+++ b/crates/biome_js_analyze/src/lint/nursery/no_misused_promises.rs
@@ -88,7 +88,7 @@ declare_lint_rule! {
         recommended: true,
         sources: &[RuleSource::EslintTypeScript("no-misused-promises").same()],
         fix_kind: FixKind::Unsafe,
-        domains: &[RuleDomain::Types],
+        domains: &[RuleDomain::Project],
     }
 }
 
diff --git a/crates/biome_js_analyze/src/lint/nursery/no_unnecessary_conditions.rs b/crates/biome_js_analyze/src/lint/nursery/no_unnecessary_conditions.rs
index 1ab220eadf..eed6b69a00 100644
--- a/crates/biome_js_analyze/src/lint/nursery/no_unnecessary_conditions.rs
+++ b/crates/biome_js_analyze/src/lint/nursery/no_unnecessary_conditions.rs
@@ -90,7 +90,7 @@ declare_lint_rule! {
         sources: &[RuleSource::EslintTypeScript("no-unnecessary-condition").inspired()],
         recommended: false,
         severity: Severity::Warning,
-        domains: &[RuleDomain::Types],
+        domains: &[RuleDomain::Project],
         issue_number: Some("6611"),
     }
 }
diff --git a/crates/biome_js_analyze/src/lint/nursery/use_array_sort_compare.rs b/crates/biome_js_analyze/src/lint/nursery/use_array_sort_compare.rs
index 2ffcd73e20..8896b5ed8e 100644
--- a/crates/biome_js_analyze/src/lint/nursery/use_array_sort_compare.rs
+++ b/crates/biome_js_analyze/src/lint/nursery/use_array_sort_compare.rs
@@ -43,7 +43,7 @@ declare_lint_rule! {
         language: "js",
         recommended: false,
         sources: &[RuleSource::EslintTypeScript("require-array-sort-compare").same()],
-        domains: &[RuleDomain::Types],
+        domains: &[RuleDomain::Project],
     }
 }
 
diff --git a/crates/biome_js_analyze/src/lint/nursery/use_await_thenable.rs b/crates/biome_js_analyze/src/lint/nursery/use_await_thenable.rs
index 400101bd9a..57ede9ffae 100644
--- a/crates/biome_js_analyze/src/lint/nursery/use_await_thenable.rs
+++ b/crates/biome_js_analyze/src/lint/nursery/use_await_thenable.rs
@@ -46,7 +46,7 @@ declare_lint_rule! {
         language: "js",
         recommended: false,
         sources: &[RuleSource::EslintTypeScript("use-await-thenable").inspired()],
-        domains: &[RuleDomain::Types],
+        domains: &[RuleDomain::Project],
     }
 }
 
diff --git a/crates/biome_js_analyze/src/lint/nursery/use_exhaustive_switch_cases.rs b/crates/biome_js_analyze/src/lint/nursery/use_exhaustive_switch_cases.rs
index d4d2d2c6a6..5f262c5407 100644
--- a/crates/biome_js_analyze/src/lint/nursery/use_exhaustive_switch_cases.rs
+++ b/crates/biome_js_analyze/src/lint/nursery/use_exhaustive_switch_cases.rs
@@ -97,7 +97,7 @@ declare_lint_rule! {
         recommended: true,
         sources: &[RuleSource::EslintTypeScript("switch-exhaustiveness-check").same()],
         fix_kind: FixKind::Unsafe,
-        domains: &[RuleDomain::Types],
+        domains: &[RuleDomain::Project],
     }
 }
 
diff --git a/crates/biome_js_analyze/src/lint/nursery/use_find.rs b/crates/biome_js_analyze/src/lint/nursery/use_find.rs
index 06d9a99c44..c7477886ac 100644
--- a/crates/biome_js_analyze/src/lint/nursery/use_find.rs
+++ b/crates/biome_js_analyze/src/lint/nursery/use_find.rs
@@ -41,7 +41,7 @@ declare_lint_rule! {
         language: "js",
         recommended: false,
         sources: &[RuleSource::EslintTypeScript("prefer-find").same()],
-        domains: &[RuleDomain::Types],
+        domains: &[RuleDomain::Project],
     }
 }
 
diff --git a/crates/biome_js_analyze/src/lint/nursery/use_regexp_exec.rs b/crates/biome_js_analyze/src/lint/nursery/use_regexp_exec.rs
index 94580fc687..66a32d0374 100644
--- a/crates/biome_js_analyze/src/lint/nursery/use_regexp_exec.rs
+++ b/crates/biome_js_analyze/src/lint/nursery/use_regexp_exec.rs
@@ -36,7 +36,7 @@ declare_lint_rule! {
         language: "js",
         recommended: false,
         sources: &[RuleSource::EslintTypeScript("prefer-regexp-exec").same(), RuleSource::EslintRegexp("prefer-regexp-exec").same()],
-        domains: &[RuleDomain::Types],
+        domains: &[RuleDomain::Project],
     }
 }
 
diff --git a/crates/biome_js_analyze/src/lint/style/use_component_export_only_modules.rs b/crates/biome_js_analyze/src/lint/style/use_component_export_only_modules.rs
index cff55e5a8a..0093ce1dec 100644
--- a/crates/biome_js_analyze/src/lint/style/use_component_export_only_modules.rs
+++ b/crates/biome_js_analyze/src/lint/style/use_component_export_only_modules.rs
@@ -4,13 +4,10 @@ use biome_analyze::{
 };
 use biome_console::markup;
 use biome_diagnostics::Severity;
-use biome_js_syntax::{
-    AnyJsModuleItem, AnyJsStatement, JsIdentifierExpression, JsModule, JsPropertyObjectMember,
-    JsShorthandPropertyObjectMember, export_ext::AnyJsExported,
-};
-use biome_rowan::{AstNode, SyntaxNodeCast, TextRange};
+use biome_js_syntax::{AnyJsModuleItem, AnyJsStatement, JsModule, export_ext::AnyJsExported};
+use biome_rowan::{AstNode, TextRange};
 use biome_rule_options::use_component_export_only_modules::UseComponentExportOnlyModulesOptions;
-use rustc_hash::{FxHashMap, FxHashSet};
+use rustc_hash::FxHashMap;
 
 declare_lint_rule! {
     /// Enforce declaring components only within modules that export React Components exclusively.
@@ -218,55 +215,6 @@ impl Rule for UseComponentExportOnlyModules {
             }
         }
 
-        // Collect identifiers referenced as object property values in exported expressions.
-        // If a local component is referenced as an object property value,
-        // it should not be reported as unexported.
-        // This handles patterns like TanStack Router:
-        //   export const Route = createFileRoute('/')({ component: HomeComponent })
-        //   function HomeComponent() { ... }
-        //
-        // We only exempt components referenced in object literals (like { component: X })
-        // and not direct function call arguments (like hoge(X)), because the latter
-        // might be non-standard HOCs that could break Fast Refresh.
-        let referenced_ids: FxHashSet<Box<str>> = exported_non_component_ids
-            .iter()
-            .filter_map(|item| item.exported.as_ref())
-            .flat_map(|exported| {
-                exported
-                    .syntax()
-                    .descendants()
-                    .filter_map(JsIdentifierExpression::cast)
-                    .filter(|id| {
-                        // Only include identifiers that are object property values
-                        id.syntax()
-                            .parent()
-                            .is_some_and(|parent| parent.cast::<JsPropertyObjectMember>().is_some())
-                    })
-                    .filter_map(|id| id.name().ok())
-                    .filter_map(|name| name.value_token().ok())
-                    .map(|token| token.text_trimmed().into())
-            })
-            .collect();
-
-        // Also collect shorthand property references like { HomeComponent }
-        let shorthand_ids: FxHashSet<Box<str>> = exported_non_component_ids
-            .iter()
-            .filter_map(|item| item.exported.as_ref())
-            .flat_map(|exported| {
-                exported
-                    .syntax()
-                    .descendants()
-                    .filter_map(JsShorthandPropertyObjectMember::cast)
-                    .filter_map(|prop| prop.name().ok())
-                    .filter_map(|name| name.value_token().ok())
-                    .map(|token| token.text_trimmed().into())
-            })
-            .collect();
-
-        // Remove components that are referenced as object property values
-        local_components
-            .retain(|name, _| !referenced_ids.contains(name) && !shorthand_ids.contains(name));
-
         if !exported_component_ids.is_empty() {
             return exported_non_component_ids
                 .iter()
diff --git a/crates/biome_js_analyze/src/lint/suspicious/use_iterable_callback_return.rs b/crates/biome_js_analyze/src/lint/suspicious/use_iterable_callback_return.rs
index 43cd0995c1..6ce5644d2b 100644
--- a/crates/biome_js_analyze/src/lint/suspicious/use_iterable_callback_return.rs
+++ b/crates/biome_js_analyze/src/lint/suspicious/use_iterable_callback_return.rs
@@ -57,15 +57,9 @@ declare_lint_rule! {
     /// });
     /// ```
     ///
-    /// ```js
-    /// [].forEach(() => {
-    ///     // No return value, which is correct
-    /// });
-    /// ```
-    ///
     /// ```js,expect_diagnostic
-    /// [].filter(() => {
-    ///     // Missing required return value
+    /// [].forEach(() => {
+    ///     return 1; // Should not return a value
     /// });
     /// ```
     ///
@@ -78,37 +72,14 @@ declare_lint_rule! {
     /// ```
     ///
     /// ```js
-    /// [].forEach(() => void null); // Void return value, which doesn't trigger the rule
-    /// ```
-    ///
-    /// ## Options
-    ///
-    /// ### `checkForEach`
-    ///
-    /// **Since `v2.4.0**
-    ///
-    /// Default: `true`
-    ///
-    /// When set to `false`, the rule will skip `forEach` callbacks that return a value.
-    ///
-    /// ### Examples
-    ///
-    /// ```json,options
-    /// {
-    ///     "options": {
-    ///         "checkForEach": false
-    ///     }
-    /// }
-    /// ```
-    ///
-    /// ```js,use_options
-    /// [1, 2, 3].forEach((el) => {
-    ///     return el * 2;
+    /// [].forEach(() => {
+    ///     // No return value, which is correct
     /// });
     /// ```
     ///
-    /// When `checkForEach` is `false` (default), the above code will not trigger any diagnostic.
-    ///
+    /// ```js
+    /// [].forEach(() => void null); // Void return value, which doesn't trigger the rule
+    /// ```
     pub UseIterableCallbackReturn {
         version: "2.0.0",
         name: "useIterableCallbackReturn",
@@ -157,10 +128,6 @@ impl Rule for UseIterableCallbackReturn {
             .and_then(|member| member.as_js_name().cloned())
             .and_then(|name| name.value_token().ok())?;
 
-        if !ctx.options().check_for_each() && member_name.text_trimmed() == "forEach" {
-            return None;
-        }
-
         let method_config = ITERABLE_METHOD_INFOS.get(member_name.text_trimmed())?;
 
         let arg_position = argument_list
diff --git a/crates/biome_js_analyze/src/services/module_graph.rs b/crates/biome_js_analyze/src/services/module_graph.rs
index 90c4852f05..a44c7d10aa 100644
--- a/crates/biome_js_analyze/src/services/module_graph.rs
+++ b/crates/biome_js_analyze/src/services/module_graph.rs
@@ -38,7 +38,7 @@ impl FromServices for ModuleGraphService {
                 .any(|d| d == &RuleDomain::Project);
             if !has_project_domain {
                 panic!(
-                    "The rule {rule_key} uses ModuleGraphService, but it is not in the Project domain."
+                    "The rule {rule_key} uses ModuleGraphService, but it is not in the project domain."
                 );
             }
         }
diff --git a/crates/biome_js_analyze/src/services/typed.rs b/crates/biome_js_analyze/src/services/typed.rs
index 92d81ca3dd..b141532715 100644
--- a/crates/biome_js_analyze/src/services/typed.rs
+++ b/crates/biome_js_analyze/src/services/typed.rs
@@ -68,10 +68,10 @@ impl FromServices for TypedService {
             let has_project_domain = rule_metadata
                 .domains
                 .iter()
-                .any(|d| d == &RuleDomain::Types);
+                .any(|d| d == &RuleDomain::Project);
             if !has_project_domain {
                 panic!(
-                    "The rule {rule_key} uses TypedService, but it is not in the TypeAware domain."
+                    "The rule {rule_key} uses TypedService, but it is not in the project domain."
                 );
             }
         }
diff --git a/crates/biome_lsp/src/session.rs b/crates/biome_lsp/src/session.rs
index 3a9c90a2b8..89fe57cef6 100644
--- a/crates/biome_lsp/src/session.rs
+++ b/crates/biome_lsp/src/session.rs
@@ -17,7 +17,6 @@ use biome_service::configuration::{
     LoadedConfiguration, ProjectScanComputer, load_configuration, load_editorconfig,
 };
 use biome_service::projects::ProjectKey;
-use biome_service::settings::ModuleGraphResolutionKind;
 use biome_service::workspace::{
     FeaturesBuilder, OpenProjectParams, OpenProjectResult, PullDiagnosticsParams,
     SupportsFeatureParams,
@@ -742,7 +741,7 @@ impl Session {
         spawn_blocking(move || {
             let result = session.workspace.scan_project(ScanProjectParams {
                 project_key,
-                watch: scan_kind.is_project() || scan_kind.is_type_aware(),
+                watch: scan_kind.is_project(),
                 force,
                 scan_kind,
                 verbose: false,
@@ -961,7 +960,6 @@ impl Session {
                 .map(BiomePath::from),
             configuration,
             extended_configurations: Default::default(),
-            module_graph_resolution_kind: ModuleGraphResolutionKind::from(&scan_kind),
         });
 
         self.insert_and_scan_project(project_key, path.into(), scan_kind, force)
diff --git a/crates/biome_module_graph/benches/module_graph.rs b/crates/biome_module_graph/benches/module_graph.rs
index 20e59ec9b1..9da270cb04 100644
--- a/crates/biome_module_graph/benches/module_graph.rs
+++ b/crates/biome_module_graph/benches/module_graph.rs
@@ -73,7 +73,6 @@ fn bench_index_d_ts(bencher: Bencher, name: &str) {
                 &fs,
                 &ProjectLayout::default(),
                 &[(&path, root)],
-                true,
             );
             divan::black_box(&module_graph);
         });
diff --git a/crates/biome_module_graph/src/js_module_info.rs b/crates/biome_module_graph/src/js_module_info.rs
index 84f9a407d8..100f6f048f 100644
--- a/crates/biome_module_graph/src/js_module_info.rs
+++ b/crates/biome_module_graph/src/js_module_info.rs
@@ -207,9 +207,6 @@ pub struct JsModuleInfoInner {
 
     /// Diagnostics emitted during the resolution of the module
     pub(crate) diagnostics: Vec<ModuleDiagnostic>,
-
-    /// Whether type inference was enabled when this module info was created
-    pub(crate) infer_types: bool,
 }
 
 #[derive(Debug, Default)]
diff --git a/crates/biome_module_graph/src/js_module_info/collector.rs b/crates/biome_module_graph/src/js_module_info/collector.rs
index f099ad1147..d86fde17d8 100644
--- a/crates/biome_module_graph/src/js_module_info/collector.rs
+++ b/crates/biome_module_graph/src/js_module_info/collector.rs
@@ -100,9 +100,6 @@ pub(super) struct JsModuleInfoCollector {
 
     /// Diagnostics emitted during the collection of module graph information
     diagnostics: Vec<JsModuleInfoDiagnostic>,
-
-    /// Whether to enable type inference when finalizing the module info
-    infer_types: bool,
 }
 
 /// Intermediary representation for an exported symbol.
@@ -559,16 +556,14 @@ impl JsModuleInfoCollector {
                 .collect(),
         );
 
-        if self.infer_types {
-            self.infer_all_types(&scope_by_range);
-            self.resolve_all_and_downgrade_project_references();
+        self.infer_all_types(&scope_by_range);
+        self.resolve_all_and_downgrade_project_references();
 
-            // Purging before flattening will save us from duplicate work during
-            // flattening. We'll purge again after for a final cleanup.
-            self.purge_redundant_types();
-            self.flatten_all();
-            self.purge_redundant_types();
-        }
+        // Purging before flattening will save us from duplicate work during
+        // flattening. We'll purge again after for a final cleanup.
+        self.purge_redundant_types();
+        self.flatten_all();
+        self.purge_redundant_types();
 
         let exports = self.collect_exports();
 
@@ -1119,8 +1114,7 @@ impl TypeResolver for JsModuleInfoCollector {
 }
 
 impl JsModuleInfo {
-    pub(super) fn new(mut collector: JsModuleInfoCollector, infer_types: bool) -> Self {
-        collector.infer_types = infer_types;
+    pub(super) fn new(mut collector: JsModuleInfoCollector) -> Self {
         let (exports, scope_by_range) = collector.finalise();
 
         Self(Arc::new(JsModuleInfoInner {
@@ -1135,7 +1129,6 @@ impl JsModuleInfo {
             scope_by_range,
             types: collector.types.into(),
             diagnostics: collector.diagnostics.into_iter().map(Into::into).collect(),
-            infer_types: collector.infer_types,
         }))
     }
 }
diff --git a/crates/biome_module_graph/src/js_module_info/module_resolver.rs b/crates/biome_module_graph/src/js_module_info/module_resolver.rs
index f0de32b388..df52749be1 100644
--- a/crates/biome_module_graph/src/js_module_info/module_resolver.rs
+++ b/crates/biome_module_graph/src/js_module_info/module_resolver.rs
@@ -74,26 +74,19 @@ pub struct ModuleResolver {
 
 impl ModuleResolver {
     pub fn for_module(module_info: JsModuleInfo, module_graph: Arc<ModuleGraph>) -> Self {
-        let infer_types = module_info.infer_types;
+        let num_initial_types = module_info.types.len();
 
-        let types = if infer_types {
-            TypeStore::with_capacity(module_info.types.len())
-        } else {
-            TypeStore::default()
-        };
         let mut resolver = Self {
             module_graph,
             modules: vec![module_info],
             modules_by_path: Default::default(),
             expressions: Default::default(),
-            types,
+            types: TypeStore::with_capacity(num_initial_types),
             type_id_map: Default::default(),
             diagnostics: Default::default(),
         };
 
-        if infer_types {
-            resolver.run_inference();
-        }
+        resolver.run_inference();
         resolver
     }
 
diff --git a/crates/biome_module_graph/src/js_module_info/visitor.rs b/crates/biome_module_graph/src/js_module_info/visitor.rs
index 1ebea29642..625523a523 100644
--- a/crates/biome_module_graph/src/js_module_info/visitor.rs
+++ b/crates/biome_module_graph/src/js_module_info/visitor.rs
@@ -30,21 +30,14 @@ pub(crate) struct JsModuleVisitor<'a> {
     root: AnyJsRoot,
     directory: &'a Utf8Path,
     fs_proxy: &'a ModuleGraphFsProxy<'a>,
-    infer_types: bool,
 }
 
 impl<'a> JsModuleVisitor<'a> {
-    pub fn new(
-        root: AnyJsRoot,
-        directory: &'a Utf8Path,
-        fs_proxy: &'a ModuleGraphFsProxy,
-        infer_types: bool,
-    ) -> Self {
+    pub fn new(root: AnyJsRoot, directory: &'a Utf8Path, fs_proxy: &'a ModuleGraphFsProxy) -> Self {
         Self {
             root,
             directory,
             fs_proxy,
-            infer_types,
         }
     }
 
@@ -69,7 +62,7 @@ impl<'a> JsModuleVisitor<'a> {
             }
         }
 
-        JsModuleInfo::new(collector, self.infer_types)
+        JsModuleInfo::new(collector)
     }
 
     fn visit_import(&self, node: AnyJsImportLike, collector: &mut JsModuleInfoCollector) {
diff --git a/crates/biome_module_graph/src/module_graph.rs b/crates/biome_module_graph/src/module_graph.rs
index b994e6976e..4a17a1d2ac 100644
--- a/crates/biome_module_graph/src/module_graph.rs
+++ b/crates/biome_module_graph/src/module_graph.rs
@@ -82,7 +82,6 @@ impl ModuleGraph {
         fs: &dyn FsWithResolverProxy,
         project_layout: &ProjectLayout,
         added_or_updated_paths: &[(&BiomePath, AnyJsRoot)],
-        enable_type_inference: bool,
     ) -> (ModuleDependencies, Vec<ModuleDiagnostic>) {
         // Make sure all directories are registered for the added/updated paths.
         let path_info = self.path_info.pin();
@@ -110,8 +109,7 @@ impl ModuleGraph {
         let modules = self.data.pin();
         for (path, root) in added_or_updated_paths {
             let directory = path.parent().unwrap_or(path);
-            let visitor =
-                JsModuleVisitor::new(root.clone(), directory, &fs_proxy, enable_type_inference);
+            let visitor = JsModuleVisitor::new(root.clone(), directory, &fs_proxy);
 
             let module_info = visitor.collect_info();
             for import_path in module_info.all_import_paths() {
diff --git a/crates/biome_rule_options/src/no_redundant_alt.rs b/crates/biome_rule_options/src/no_redundant_alt.rs
index 1f0c7de5dd..ddd508af5c 100644
--- a/crates/biome_rule_options/src/no_redundant_alt.rs
+++ b/crates/biome_rule_options/src/no_redundant_alt.rs
@@ -1,6 +1,5 @@
 use biome_deserialize_macros::{Deserializable, Merge};
 use serde::{Deserialize, Serialize};
-
 #[derive(Default, Clone, Debug, Deserialize, Deserializable, Merge, Eq, PartialEq, Serialize)]
 #[cfg_attr(feature = "schema", derive(schemars::JsonSchema))]
 #[serde(rename_all = "camelCase", deny_unknown_fields, default)]
diff --git a/crates/biome_rule_options/src/shared/mod.rs b/crates/biome_rule_options/src/shared/mod.rs
index 9817d15c60..a9965fbb48 100644
--- a/crates/biome_rule_options/src/shared/mod.rs
+++ b/crates/biome_rule_options/src/shared/mod.rs
@@ -1,13 +1,2 @@
-use biome_string_case::StrLikeExtension;
-
 pub mod restricted_regex;
 pub mod sort_order;
-
-const REDUNDANT_WORDS: [&str; 3] = ["image", "photo", "picture"];
-
-pub fn is_redundant_alt(alt: &str) -> bool {
-    REDUNDANT_WORDS.into_iter().any(|word| {
-        alt.split_whitespace()
-            .any(|x| x.to_ascii_lowercase_cow() == word)
-    })
-}
diff --git a/crates/biome_rule_options/src/use_iterable_callback_return.rs b/crates/biome_rule_options/src/use_iterable_callback_return.rs
index 604fc9dab2..866a2b0db3 100644
--- a/crates/biome_rule_options/src/use_iterable_callback_return.rs
+++ b/crates/biome_rule_options/src/use_iterable_callback_return.rs
@@ -3,19 +3,4 @@ use serde::{Deserialize, Serialize};
 #[derive(Default, Clone, Debug, Deserialize, Deserializable, Merge, Eq, PartialEq, Serialize)]
 #[cfg_attr(feature = "schema", derive(schemars::JsonSchema))]
 #[serde(rename_all = "camelCase", deny_unknown_fields, default)]
-pub struct UseIterableCallbackReturnOptions {
-    /// When `true`, the rule reports `forEach` callbacks that return a value (default behaviour).
-    /// When `false` or unset, such callbacks are ignored.
-    #[serde(skip_serializing_if = "Option::is_none")]
-    pub check_for_each: Option<bool>,
-}
-
-impl UseIterableCallbackReturnOptions {
-    pub const DEFAULT_CHECK_FOR_EACH: bool = true;
-
-    /// Returns [`Self::check_for_each`] if it is set.
-    /// Otherwise, returns [`Self::DEFAULT_CHECK_FOR_EACH`].
-    pub fn check_for_each(&self) -> bool {
-        self.check_for_each.unwrap_or(Self::DEFAULT_CHECK_FOR_EACH)
-    }
-}
+pub struct UseIterableCallbackReturnOptions {}
diff --git a/crates/biome_ruledoc_utils/src/lib.rs b/crates/biome_ruledoc_utils/src/lib.rs
index a251fc774f..69c1921e4d 100644
--- a/crates/biome_ruledoc_utils/src/lib.rs
+++ b/crates/biome_ruledoc_utils/src/lib.rs
@@ -81,7 +81,7 @@ impl AnalyzerServicesBuilder {
 
         let module_graph = ModuleGraph::default();
         let added_paths = get_added_js_paths(&fs, &added_paths);
-        module_graph.update_graph_for_js_paths(&fs, &layout, &added_paths, true);
+        module_graph.update_graph_for_js_paths(&fs, &layout, &added_paths);
 
         Self {
             module_graph: Arc::new(module_graph),
diff --git a/crates/biome_service/src/configuration.rs b/crates/biome_service/src/configuration.rs
index 8e584b005b..44e934e961 100644
--- a/crates/biome_service/src/configuration.rs
+++ b/crates/biome_service/src/configuration.rs
@@ -23,7 +23,6 @@ use biome_fs::{AutoSearchResult, ConfigName, FileSystem, OpenOptions};
 use biome_graphql_analyze::METADATA as graphql_lint_metadata;
 use biome_graphql_syntax::GraphqlLanguage;
 use biome_html_analyze::METADATA as html_lint_metadata;
-use biome_html_syntax::HtmlLanguage;
 use biome_js_analyze::METADATA as js_lint_metadata;
 use biome_js_syntax::JsLanguage;
 use biome_json_analyze::METADATA as json_lint_metadata;
@@ -730,7 +729,6 @@ mod test {
 /// on the current configuration
 pub struct ProjectScanComputer<'a> {
     requires_project_scan: bool,
-    requires_types: bool,
     enabled_rules: FxHashSet<RuleFilter<'a>>,
     configuration: &'a Configuration,
     skip: &'a [AnalyzerSelector],
@@ -743,7 +741,6 @@ impl<'a> ProjectScanComputer<'a> {
         Self {
             enabled_rules,
             requires_project_scan: false,
-            requires_types: false,
             configuration,
             skip: &[],
             only: &[],
@@ -768,11 +765,6 @@ impl<'a> ProjectScanComputer<'a> {
             for (domain, value) in domains.iter() {
                 if domain == &RuleDomain::Project && value != &RuleDomainValue::None {
                     self.requires_project_scan = true;
-                }
-                if domain == &RuleDomain::Types && value != &RuleDomainValue::None {
-                    self.requires_types = true;
-                    self.requires_project_scan = true;
-                    // requiring types is of higher order of project, so we can bail
                     break;
                 }
             }
@@ -782,11 +774,8 @@ impl<'a> ProjectScanComputer<'a> {
         biome_css_analyze::visit_registry(&mut self);
         biome_json_analyze::visit_registry(&mut self);
         biome_js_analyze::visit_registry(&mut self);
-        biome_html_analyze::visit_registry(&mut self);
 
-        if self.requires_types {
-            ScanKind::TypeAware
-        } else if self.requires_project_scan {
+        if self.requires_project_scan {
             ScanKind::Project
         } else {
             // There's no need to scan further known files if the VCS isn't enabled
@@ -810,7 +799,6 @@ impl<'a> ProjectScanComputer<'a> {
                 if selector.match_rule::<R>() {
                     let domains = R::METADATA.domains;
                     self.requires_project_scan |= domains.contains(&RuleDomain::Project);
-                    self.requires_types |= domains.contains(&RuleDomain::Types);
                     break;
                 }
             }
@@ -819,7 +807,6 @@ impl<'a> ProjectScanComputer<'a> {
         {
             let domains = R::METADATA.domains;
             self.requires_project_scan |= domains.contains(&RuleDomain::Project);
-            self.requires_types |= domains.contains(&RuleDomain::Types);
         }
     }
 }
@@ -863,15 +850,6 @@ impl RegistryVisitor<GraphqlLanguage> for ProjectScanComputer<'_> {
     }
 }
 
-impl RegistryVisitor<HtmlLanguage> for ProjectScanComputer<'_> {
-    fn record_rule<R>(&mut self)
-    where
-        R: Rule<Options: Default, Query: Queryable<Language = HtmlLanguage, Output: Clone>>
-            + 'static,
-    {
-        self.check_rule::<R, HtmlLanguage>();
-    }
-}
 #[cfg(test)]
 mod tests {
     use super::*;
@@ -1023,67 +1001,4 @@ mod tests {
             ScanKind::NoScanner
         );
     }
-
-    #[test]
-    fn should_return_type_aware_if_type_aware_domain_is_enabled() {
-        let mut domains = FxHashMap::default();
-        domains.insert(RuleDomain::Types, RuleDomainValue::Recommended);
-
-        let configuration = Configuration {
-            linter: Some(LinterConfiguration {
-                domains: Some(RuleDomains(domains)),
-                ..Default::default()
-            }),
-            ..Default::default()
-        };
-
-        assert_eq!(
-            ProjectScanComputer::new(&configuration).compute(),
-            ScanKind::TypeAware
-        );
-    }
-
-    #[test]
-    fn should_return_type_aware_if_type_aware_domain_selector() {
-        let configuration = Configuration::default();
-
-        assert_eq!(
-            ProjectScanComputer::new(&configuration)
-                .with_rule_selectors(&[], &[DomainSelector("types").into()])
-                .compute(),
-            ScanKind::TypeAware
-        );
-    }
-
-    #[test]
-    fn should_return_type_aware_when_both_type_aware_and_project_enabled() {
-        let mut domains = FxHashMap::default();
-        domains.insert(RuleDomain::Project, RuleDomainValue::Recommended);
-        domains.insert(RuleDomain::Types, RuleDomainValue::Recommended);
-
-        let configuration = Configuration {
-            linter: Some(LinterConfiguration {
-                domains: Some(RuleDomains(domains)),
-                ..Default::default()
-            }),
-            ..Default::default()
-        };
-
-        assert_eq!(
-            ProjectScanComputer::new(&configuration).compute(),
-            ScanKind::TypeAware
-        );
-    }
-
-    #[test]
-    fn should_not_return_type_aware_if_non_type_aware_domain() {
-        let configuration = Configuration::default();
-
-        assert_eq!(
-            ProjectScanComputer::new(&configuration)
-                .with_rule_selectors(&[], &[DomainSelector("react").into()])
-                .compute(),
-            ScanKind::NoScanner
-        );
-    }
 }
diff --git a/crates/biome_service/src/file_handlers/html.rs b/crates/biome_service/src/file_handlers/html.rs
index 4daad8e970..4c888d54d2 100644
--- a/crates/biome_service/src/file_handlers/html.rs
+++ b/crates/biome_service/src/file_handlers/html.rs
@@ -793,11 +793,9 @@ fn lint(params: LintParams) -> LintResults {
 
     let mut process_lint = ProcessLint::new(&params);
 
-    let source_type = params.language.to_html_file_source().unwrap_or_default();
-    let (_, analyze_diagnostics) =
-        analyze(&tree, filter, &analyzer_options, source_type, |signal| {
-            process_lint.process_signal(signal)
-        });
+    let (_, analyze_diagnostics) = analyze(&tree, filter, &analyzer_options, |signal| {
+        process_lint.process_signal(signal)
+    });
 
     process_lint.into_result(
         params
@@ -828,7 +826,7 @@ pub(crate) fn code_actions(params: CodeActionsParams) -> PullActionsResult {
     let _ = debug_span!("Code actions HTML", range =? range, path =? path).entered();
     let tree = parse.tree();
     let _ = trace_span!("Parsed file", tree =? tree).entered();
-    let Some(source_type) = language.to_html_file_source() else {
+    let Some(_) = language.to_html_file_source() else {
         error!("Could not determine the HTML file source of the file");
         return PullActionsResult {
             actions: Vec::new(),
@@ -853,7 +851,7 @@ pub(crate) fn code_actions(params: CodeActionsParams) -> PullActionsResult {
         range,
     };
 
-    analyze(&tree, filter, &analyzer_options, source_type, |signal| {
+    analyze(&tree, filter, &analyzer_options, |signal| {
         actions.extend(signal.actions().into_code_action_iter().map(|item| {
             CodeAction {
                 category: item.category.clone(),
@@ -907,12 +905,8 @@ pub(crate) fn fix_all(params: FixAllParams) -> Result<FixFileResult, WorkspaceEr
         tree.syntax().text_range_with_trivia().len().into(),
     );
 
-    let source_type = params
-        .document_file_source
-        .to_html_file_source()
-        .unwrap_or_default();
     loop {
-        let (action, _) = analyze(&tree, filter, &analyzer_options, source_type, |signal| {
+        let (action, _) = analyze(&tree, filter, &analyzer_options, |signal| {
             process_fix_all.process_signal(signal)
         });
 
diff --git a/crates/biome_service/src/scanner.rs b/crates/biome_service/src/scanner.rs
index 5742841ff6..205c1d259b 100644
--- a/crates/biome_service/src/scanner.rs
+++ b/crates/biome_service/src/scanner.rs
@@ -710,9 +710,6 @@ pub enum ScanKind {
     },
     /// Scans the entire repository, indexing all files to enable project rules.
     Project,
-
-    /// Scans the entire repository, indexing all files to enable type inference rules
-    TypeAware,
 }
 
 impl ScanKind {
@@ -726,7 +723,6 @@ impl ScanKind {
             Self::KnownFiles => Self::KnownFiles,
             Self::Project => Self::Project,
             Self::TargetedKnownFiles { .. } => Self::KnownFiles,
-            Self::TypeAware => Self::TypeAware,
         }
     }
 
@@ -734,10 +730,6 @@ impl ScanKind {
         matches!(self, Self::Project)
     }
 
-    pub const fn is_type_aware(&self) -> bool {
-        matches!(self, Self::TypeAware)
-    }
-
     pub const fn is_known_files(&self) -> bool {
         matches!(self, Self::KnownFiles)
     }
diff --git a/crates/biome_service/src/scanner.tests.rs b/crates/biome_service/src/scanner.tests.rs
index febe774455..9f11bb53d5 100644
--- a/crates/biome_service/src/scanner.tests.rs
+++ b/crates/biome_service/src/scanner.tests.rs
@@ -6,7 +6,6 @@ use camino::Utf8PathBuf;
 
 use crate::Workspace;
 use crate::scanner::WorkspaceScannerBridge;
-use crate::settings::ModuleGraphResolutionKind;
 use crate::test_utils::setup_workspace_and_open_project;
 use crate::workspace::{GetFileContentParams, ScanKind, ScanProjectParams, UpdateSettingsParams};
 
@@ -64,7 +63,6 @@ fn scanner_only_loads_used_type_definitions_from_node_modules() {
             configuration: Default::default(),
             workspace_directory: Some(fixtures_path.clone().into()),
             extended_configurations: Default::default(),
-            module_graph_resolution_kind: ModuleGraphResolutionKind::ModulesAndTypes,
         })
         .unwrap();
 
@@ -145,7 +143,6 @@ fn scanner_ignored_files_are_not_loaded() {
             configuration,
             workspace_directory: Some(fixtures_path.clone().into()),
             extended_configurations: Default::default(),
-            module_graph_resolution_kind: ModuleGraphResolutionKind::ModulesAndTypes,
         })
         .unwrap();
 
@@ -199,7 +196,6 @@ fn scanner_required_files_are_only_ignored_in_ignored_directories() {
             configuration,
             workspace_directory: Some(fixtures_path.clone().into()),
             extended_configurations: Default::default(),
-            module_graph_resolution_kind: ModuleGraphResolutionKind::ModulesAndTypes,
         })
         .unwrap();
 
diff --git a/crates/biome_service/src/scanner/test_utils.rs b/crates/biome_service/src/scanner/test_utils.rs
index 063aa9645d..7ed0db4c78 100644
--- a/crates/biome_service/src/scanner/test_utils.rs
+++ b/crates/biome_service/src/scanner/test_utils.rs
@@ -128,22 +128,14 @@ impl WorkspaceWatcherBridge for MockWorkspaceWatcherBridge<'_> {
         self.tx.send(()).expect("can send notification");
     }
 
-    fn unload_file(
-        &self,
-        path: &Utf8Path,
-        _project_key: ProjectKey,
-    ) -> Result<Vec<Diagnostic>, WorkspaceError> {
+    fn unload_file(&self, path: &Utf8Path) -> Result<Vec<Diagnostic>, WorkspaceError> {
         self.indexed_files.pin().remove(path);
         self.tx.send(()).expect("can send notification");
 
         Ok(vec![])
     }
 
-    fn unload_path(
-        &self,
-        path: &Utf8Path,
-        _project_key: ProjectKey,
-    ) -> Result<Vec<Diagnostic>, WorkspaceError> {
+    fn unload_path(&self, path: &Utf8Path) -> Result<Vec<Diagnostic>, WorkspaceError> {
         self.indexed_files.pin().remove(path);
         self.indexed_folders.pin().remove(path);
         self.tx.send(()).expect("can send notification");
diff --git a/crates/biome_service/src/scanner/watcher.rs b/crates/biome_service/src/scanner/watcher.rs
index c46af54a13..01831a199d 100644
--- a/crates/biome_service/src/scanner/watcher.rs
+++ b/crates/biome_service/src/scanner/watcher.rs
@@ -390,10 +390,7 @@ impl Watcher {
     ) -> Result<Vec<Diagnostic>, WorkspaceError> {
         let mut diagnostics = vec![];
         for path in paths {
-            let Some(project_key) = workspace.find_project_for_path(&path) else {
-                return Ok(vec![]);
-            };
-            diagnostics.extend(workspace.unload_file(&path, project_key)?);
+            diagnostics.extend(workspace.unload_file(&path)?);
         }
 
         Ok(diagnostics)
@@ -409,10 +406,7 @@ impl Watcher {
     ) -> Result<Vec<Diagnostic>, WorkspaceError> {
         let mut diagnostics = vec![];
         for path in &paths {
-            let Some(project_key) = workspace.find_project_for_path(path) else {
-                return Ok(vec![]);
-            };
-            let result = workspace.unload_path(path, project_key)?;
+            let result = workspace.unload_path(path)?;
             diagnostics.extend(result);
         }
 
@@ -425,13 +419,10 @@ impl Watcher {
         to: &Utf8Path,
     ) -> Result<Vec<Diagnostic>, WorkspaceError> {
         let mut diagnostics = vec![];
-        let Some(project_key) = workspace.find_project_for_path(from) else {
-            return Ok(vec![]);
-        };
         if workspace.fs().path_is_file(from) {
-            diagnostics.extend(workspace.unload_file(from, project_key)?);
+            diagnostics.extend(workspace.unload_file(from)?);
         } else {
-            diagnostics.extend(workspace.unload_path(from, project_key)?);
+            diagnostics.extend(workspace.unload_path(from)?);
         }
         diagnostics.extend(Self::index_path(workspace, to)?);
         Ok(diagnostics)
diff --git a/crates/biome_service/src/scanner/workspace_bridges.rs b/crates/biome_service/src/scanner/workspace_bridges.rs
index 884b26927d..e85cd175e4 100644
--- a/crates/biome_service/src/scanner/workspace_bridges.rs
+++ b/crates/biome_service/src/scanner/workspace_bridges.rs
@@ -86,11 +86,7 @@ pub(crate) trait WorkspaceScannerBridge: Send + Sync + RefUnwindSafe {
 
     /// Unloads the index of the file with the given `path` within the
     /// workspace.
-    fn unload_file(
-        &self,
-        path: &Utf8Path,
-        project_key: ProjectKey,
-    ) -> Result<Vec<Diagnostic>, WorkspaceError>;
+    fn unload_file(&self, path: &Utf8Path) -> Result<Vec<Diagnostic>, WorkspaceError>;
 
     /// Unloads the given `path` from the workspace index.
     ///
@@ -101,11 +97,7 @@ pub(crate) trait WorkspaceScannerBridge: Send + Sync + RefUnwindSafe {
     ///
     /// If you already know the path is a file, you should use
     /// [`WorkspaceWatcherBridge::unload_file()`] directly instead.
-    fn unload_path(
-        &self,
-        path: &Utf8Path,
-        project_key: ProjectKey,
-    ) -> Result<Vec<Diagnostic>, WorkspaceError>;
+    fn unload_path(&self, path: &Utf8Path) -> Result<Vec<Diagnostic>, WorkspaceError>;
 }
 
 /// Trait used to give access to workspace functionality required by the
@@ -165,11 +157,7 @@ pub trait WorkspaceWatcherBridge {
 
     /// Unloads the index of the file with the given `path` within the
     /// workspace.
-    fn unload_file(
-        &self,
-        path: &Utf8Path,
-        project_key: ProjectKey,
-    ) -> Result<Vec<Diagnostic>, WorkspaceError>;
+    fn unload_file(&self, path: &Utf8Path) -> Result<Vec<Diagnostic>, WorkspaceError>;
 
     /// Unloads the given `path` from the workspace index.
     ///
@@ -180,11 +168,7 @@ pub trait WorkspaceWatcherBridge {
     ///
     /// If you already know the path is a file, you should use
     /// [`WorkspaceWatcherBridge::unload_file()`] directly instead.
-    fn unload_path(
-        &self,
-        path: &Utf8Path,
-        project_key: ProjectKey,
-    ) -> Result<Vec<Diagnostic>, WorkspaceError>;
+    fn unload_path(&self, path: &Utf8Path) -> Result<Vec<Diagnostic>, WorkspaceError>;
 
     /// Notifies service notification listeners that the watcher has stopped.
     fn notify_stopped(&self);
@@ -286,21 +270,13 @@ where
     }
 
     #[inline]
-    fn unload_file(
-        &self,
-        path: &Utf8Path,
-        project_key: ProjectKey,
-    ) -> Result<Vec<Diagnostic>, WorkspaceError> {
-        self.workspace.unload_file(path, project_key)
+    fn unload_file(&self, path: &Utf8Path) -> Result<Vec<Diagnostic>, WorkspaceError> {
+        self.workspace.unload_file(path)
     }
 
     #[inline]
-    fn unload_path(
-        &self,
-        path: &Utf8Path,
-        project_key: ProjectKey,
-    ) -> Result<Vec<Diagnostic>, WorkspaceError> {
-        self.workspace.unload_path(path, project_key)
+    fn unload_path(&self, path: &Utf8Path) -> Result<Vec<Diagnostic>, WorkspaceError> {
+        self.workspace.unload_path(path)
     }
 
     #[inline]
diff --git a/crates/biome_service/src/scanner/workspace_scanner_bridge.tests.rs b/crates/biome_service/src/scanner/workspace_scanner_bridge.tests.rs
index 86ee9eeca3..51627948ec 100644
--- a/crates/biome_service/src/scanner/workspace_scanner_bridge.tests.rs
+++ b/crates/biome_service/src/scanner/workspace_scanner_bridge.tests.rs
@@ -15,9 +15,7 @@ use biome_fs::{BiomePath, MemoryFileSystem, TemporaryFs};
 use biome_glob::NormalizedGlob;
 use camino::{Utf8Path, Utf8PathBuf};
 
-use super::{ScanKind, WorkspaceScannerBridge};
 use crate::scanner::IndexTrigger;
-use crate::settings::ModuleGraphResolutionKind;
 use crate::test_utils::setup_workspace_and_open_project;
 use crate::workspace::{
     CloseFileParams, FileContent, GetFileContentParams, OpenFileParams, ScanProjectParams,
@@ -25,6 +23,8 @@ use crate::workspace::{
 };
 use crate::{Workspace, WorkspaceError};
 
+use super::{ScanKind, WorkspaceScannerBridge};
+
 #[test]
 fn close_file_through_watcher_before_client() {
     const FILE_CONTENT: &str = "import 'foo';";
@@ -62,7 +62,7 @@ fn close_file_through_watcher_before_client() {
     );
 
     workspace
-        .unload_file(&file_path, project_key)
+        .unload_file(&file_path)
         .expect("can unload indexed file");
 
     assert!(
@@ -147,7 +147,7 @@ fn close_file_from_client_before_watcher() {
     );
 
     workspace
-        .unload_file(&file_path, project_key)
+        .unload_file(&file_path)
         .expect("can unload file from index");
 
     assert!(
@@ -202,7 +202,6 @@ fn should_not_index_an_ignored_file_inside_vcs_ignore_file() {
                 ..Default::default()
             },
             extended_configurations: Default::default(),
-            module_graph_resolution_kind: ModuleGraphResolutionKind::ModulesAndTypes,
         })
         .expect("can update settings");
 
@@ -243,7 +242,6 @@ fn should_not_index_an_ignored_file_inside_file_includes() {
                 ..Default::default()
             },
             extended_configurations: Default::default(),
-            module_graph_resolution_kind: ModuleGraphResolutionKind::ModulesAndTypes,
         })
         .expect("can update settings");
 
@@ -285,7 +283,6 @@ fn should_index_an_ignored_file_if_it_is_a_dependency_of_a_non_ignored_file() {
                 ..Default::default()
             },
             extended_configurations: Default::default(),
-            module_graph_resolution_kind: ModuleGraphResolutionKind::ModulesAndTypes,
         })
         .expect("can update settings");
 
@@ -334,7 +331,6 @@ fn should_not_index_a_force_ignored_file_even_if_it_is_a_dependency() {
                 ..Default::default()
             },
             extended_configurations: Default::default(),
-            module_graph_resolution_kind: ModuleGraphResolutionKind::ModulesAndTypes,
         })
         .expect("can update settings");
 
@@ -378,7 +374,6 @@ fn should_not_index_dependency_with_scan_kind_known_files() {
                 ..Default::default()
             },
             extended_configurations: Default::default(),
-            module_graph_resolution_kind: ModuleGraphResolutionKind::ModulesAndTypes,
         })
         .expect("can update settings");
 
@@ -420,7 +415,6 @@ fn should_not_index_inside_an_ignored_folder_inside_file_includes() {
                 ..Default::default()
             },
             extended_configurations: Default::default(),
-            module_graph_resolution_kind: ModuleGraphResolutionKind::ModulesAndTypes,
         })
         .expect("can update settings");
 
@@ -463,7 +457,6 @@ fn should_not_index_inside_an_ignored_folder_inside_vcs_ignore_file() {
                 ..Default::default()
             },
             extended_configurations: Default::default(),
-            module_graph_resolution_kind: ModuleGraphResolutionKind::ModulesAndTypes,
         })
         .expect("can update settings");
 
diff --git a/crates/biome_service/src/settings.rs b/crates/biome_service/src/settings.rs
index 7f418f56c3..73c47e6ed5 100644
--- a/crates/biome_service/src/settings.rs
+++ b/crates/biome_service/src/settings.rs
@@ -1,4 +1,4 @@
-use crate::workspace::{DocumentFileSource, FeatureKind, ScanKind};
+use crate::workspace::{DocumentFileSource, FeatureKind};
 use crate::{WorkspaceError, is_dir};
 use biome_analyze::{AnalyzerOptions, AnalyzerRules};
 use biome_configuration::analyzer::assist::{Actions, AssistConfiguration, AssistEnabled};
@@ -55,8 +55,6 @@ pub struct Settings {
     /// The configuration that originated this setting, if applicable.
     source: Option<Arc<ConfigurationSource>>,
 
-    pub(crate) module_graph_resolution_kind: ModuleGraphResolutionKind,
-
     /// Formatter settings applied to all files in the project.
     pub formatter: FormatSettings,
     /// Linter settings applied to all files in the project.
@@ -366,34 +364,6 @@ impl Settings {
     }
 }
 
-#[derive(Clone, Debug, Default, PartialEq, serde::Serialize, serde::Deserialize)]
-#[cfg_attr(feature = "schema", derive(schemars::JsonSchema))]
-#[serde(rename_all = "camelCase")]
-pub enum ModuleGraphResolutionKind {
-    #[default]
-    None,
-    Modules,
-    ModulesAndTypes,
-}
-
-impl ModuleGraphResolutionKind {
-    pub const fn is_modules_and_types(&self) -> bool {
-        matches!(self, Self::ModulesAndTypes)
-    }
-}
-
-impl From<&ScanKind> for ModuleGraphResolutionKind {
-    fn from(value: &ScanKind) -> Self {
-        match value {
-            ScanKind::NoScanner | ScanKind::KnownFiles | ScanKind::TargetedKnownFiles { .. } => {
-                Self::None
-            }
-            ScanKind::Project => Self::Modules,
-            ScanKind::TypeAware => Self::ModulesAndTypes,
-        }
-    }
-}
-
 pub type SettingsWithEditor<'a> = SettingsHandle<'a, Option<Configuration>>;
 
 /// Handle object holding a temporary lock on the workspace settings until
diff --git a/crates/biome_service/src/settings.tests.rs b/crates/biome_service/src/settings.tests.rs
index 519c209ea1..0b9da0103e 100644
--- a/crates/biome_service/src/settings.tests.rs
+++ b/crates/biome_service/src/settings.tests.rs
@@ -1,8 +1,4 @@
-use crate::scanner::ScanKind;
-use crate::settings::{
-    LanguageSettings, ModuleGraphResolutionKind, ServiceLanguage, Settings,
-    to_json_language_settings,
-};
+use crate::settings::{LanguageSettings, ServiceLanguage, Settings, to_json_language_settings};
 use crate::workspace::DocumentFileSource;
 use biome_analyze::RuleFilter;
 use biome_configuration::analyzer::{GroupPlainConfiguration, Nursery, SeverityOrGroup};
@@ -235,63 +231,3 @@ fn override_inherits_global_formatter_when_not_specified() {
         "Formatter should be enabled for .js files"
     );
 }
-
-#[test]
-fn test_module_graph_resolution_kind_from_scan_kind() {
-    // Test all ScanKind variants map to correct ModuleGraphResolutionKind
-    assert_eq!(
-        ModuleGraphResolutionKind::from(&ScanKind::NoScanner),
-        ModuleGraphResolutionKind::None
-    );
-
-    assert_eq!(
-        ModuleGraphResolutionKind::from(&ScanKind::KnownFiles),
-        ModuleGraphResolutionKind::None
-    );
-
-    assert_eq!(
-        ModuleGraphResolutionKind::from(&ScanKind::TargetedKnownFiles {
-            target_paths: vec![],
-            descend_from_targets: false,
-        }),
-        ModuleGraphResolutionKind::None
-    );
-
-    assert_eq!(
-        ModuleGraphResolutionKind::from(&ScanKind::Project),
-        ModuleGraphResolutionKind::Modules
-    );
-
-    assert_eq!(
-        ModuleGraphResolutionKind::from(&ScanKind::TypeAware),
-        ModuleGraphResolutionKind::ModulesAndTypes
-    );
-}
-
-#[test]
-fn test_module_graph_resolution_kind_is_modules_and_types() {
-    // Test is_modules_and_types predicate
-    assert!(!ModuleGraphResolutionKind::None.is_modules_and_types());
-    assert!(!ModuleGraphResolutionKind::Modules.is_modules_and_types());
-    assert!(ModuleGraphResolutionKind::ModulesAndTypes.is_modules_and_types());
-}
-
-#[test]
-fn test_type_aware_scan_enables_module_graph_type_inference() {
-    // This test verifies that TypeAware scan kind results in type inference being enabled
-    let type_aware_kind = ModuleGraphResolutionKind::from(&ScanKind::TypeAware);
-    assert!(
-        type_aware_kind.is_modules_and_types(),
-        "TypeAware scan should enable type inference"
-    );
-}
-
-#[test]
-fn test_project_scan_disables_module_graph_type_inference() {
-    // This test verifies that Project scan kind does NOT enable type inference
-    let project_kind = ModuleGraphResolutionKind::from(&ScanKind::Project);
-    assert!(
-        !project_kind.is_modules_and_types(),
-        "Project scan should NOT enable type inference"
-    );
-}
diff --git a/crates/biome_service/src/workspace.rs b/crates/biome_service/src/workspace.rs
index a22ad50b56..7396551b82 100644
--- a/crates/biome_service/src/workspace.rs
+++ b/crates/biome_service/src/workspace.rs
@@ -95,7 +95,7 @@ pub use crate::{
 #[cfg(feature = "schema")]
 use schemars::{Schema, SchemaGenerator};
 
-use crate::settings::{ModuleGraphResolutionKind, SettingsWithEditor};
+use crate::settings::SettingsWithEditor;
 pub use client::{TransportRequest, WorkspaceClient, WorkspaceTransport};
 pub use server::OpenFileReason;
 
@@ -750,8 +750,6 @@ pub struct UpdateSettingsParams {
     pub workspace_directory: Option<BiomePath>,
     #[serde(skip_serializing_if = "Vec::is_empty", default)]
     pub extended_configurations: Vec<(BiomePath, Configuration)>,
-    #[serde(default)]
-    pub module_graph_resolution_kind: ModuleGraphResolutionKind,
 }
 
 #[derive(Debug, serde::Serialize, serde::Deserialize)]
@@ -951,7 +949,6 @@ pub struct CloseFileParams {
 #[cfg_attr(feature = "schema", derive(schemars::JsonSchema))]
 #[serde(rename_all = "camelCase")]
 pub struct UpdateModuleGraphParams {
-    pub project_key: ProjectKey,
     pub path: BiomePath,
     /// The kind of update to apply to the module graph
     pub update_kind: UpdateKind,
diff --git a/crates/biome_service/src/workspace.tests.rs b/crates/biome_service/src/workspace.tests.rs
index c4bbccc1a4..67e831138d 100644
--- a/crates/biome_service/src/workspace.tests.rs
+++ b/crates/biome_service/src/workspace.tests.rs
@@ -15,16 +15,16 @@ use biome_plugin_loader::{PluginConfiguration, Plugins};
 use camino::Utf8PathBuf;
 use insta::{assert_debug_snapshot, assert_snapshot};
 
+use crate::file_handlers::DocumentFileSource;
+use crate::projects::ProjectKey;
+use crate::{Workspace, WorkspaceError};
+
 use super::{
     CloseFileParams, CloseProjectParams, FileContent, FileFeaturesResult, FileGuard,
     GetModuleGraphParams, GetSyntaxTreeParams, OpenFileParams, OpenProjectParams,
     OpenProjectResult, PullDiagnosticsParams, ScanKind, ScanProjectParams, UpdateKind,
     UpdateModuleGraphParams, UpdateSettingsParams, server,
 };
-use crate::file_handlers::DocumentFileSource;
-use crate::projects::ProjectKey;
-use crate::settings::ModuleGraphResolutionKind;
-use crate::{Workspace, WorkspaceError};
 
 fn create_server() -> (Box<dyn Workspace>, ProjectKey) {
     let workspace = server(Arc::new(MemoryFileSystem::default()), None);
@@ -471,7 +471,6 @@ fn too_large_files_are_tracked_but_not_parsed() {
             },
             workspace_directory: None,
             extended_configurations: Default::default(),
-            module_graph_resolution_kind: ModuleGraphResolutionKind::None,
         })
         .unwrap();
 
@@ -532,7 +531,6 @@ fn plugins_are_loaded_and_used_during_analysis() {
             },
             workspace_directory: Some(BiomePath::new("/project")),
             extended_configurations: Default::default(),
-            module_graph_resolution_kind: ModuleGraphResolutionKind::None,
         })
         .unwrap();
 
@@ -603,7 +601,6 @@ language css;
             },
             workspace_directory: Some(BiomePath::new("/project")),
             extended_configurations: Default::default(),
-            module_graph_resolution_kind: ModuleGraphResolutionKind::None,
         })
         .unwrap();
 
@@ -670,7 +667,6 @@ fn plugins_may_use_invalid_span() {
             },
             workspace_directory: Some(BiomePath::new("/project")),
             extended_configurations: Default::default(),
-            module_graph_resolution_kind: ModuleGraphResolutionKind::None,
         })
         .unwrap();
 
@@ -791,7 +787,6 @@ const hasOwn = Object.hasOwn({ foo: 'bar' }, 'foo');"#,
             },
             workspace_directory: Some(BiomePath::new("/project")),
             extended_configurations: Default::default(),
-            module_graph_resolution_kind: ModuleGraphResolutionKind::None,
         })
         .unwrap();
 
@@ -1022,14 +1017,12 @@ export const squash = function squash() {};
         .update_module_graph(UpdateModuleGraphParams {
             path: BiomePath::new("/project/file.js"),
             update_kind: UpdateKind::AddOrUpdate,
-            project_key,
         })
         .unwrap();
     workspace
         .update_module_graph(UpdateModuleGraphParams {
             path: BiomePath::new("/project/utils.js"),
             update_kind: UpdateKind::AddOrUpdate,
-            project_key,
         })
         .unwrap();
 
@@ -1037,7 +1030,6 @@ export const squash = function squash() {};
         .update_module_graph(UpdateModuleGraphParams {
             path: BiomePath::new("/project/dynamic.js"),
             update_kind: UpdateKind::AddOrUpdate,
-            project_key,
         })
         .unwrap();
 
diff --git a/crates/biome_service/src/workspace/server.rs b/crates/biome_service/src/workspace/server.rs
index 4c8488ecc2..662ef4d8b7 100644
--- a/crates/biome_service/src/workspace/server.rs
+++ b/crates/biome_service/src/workspace/server.rs
@@ -4,7 +4,7 @@ use std::sync::{Arc, Mutex};
 
 use super::{document::Document, *};
 use crate::Watcher;
-use crate::configuration::{LoadedConfiguration, ProjectScanComputer, read_config};
+use crate::configuration::{LoadedConfiguration, read_config};
 use crate::diagnostics::{FileTooLarge, NoIgnoreFileFound, VcsDiagnostic};
 use crate::file_handlers::{
     Capabilities, CodeActionsParams, DiagnosticsAndActionsParams, DocumentFileSource, Features,
@@ -530,11 +530,8 @@ impl WorkspaceServer {
                 .and_then(Result::ok)
                 .map(|node| node.unwrap_as_send_node())
         {
-            let (dependencies, diagnostics) = self.update_service_data(
-                &path,
-                UpdateKind::AddedOrChanged(reason, root, services),
-                project_key,
-            )?;
+            let (dependencies, diagnostics) = self
+                .update_service_data(&path, UpdateKind::AddedOrChanged(reason, root, services))?;
 
             Ok(InternalOpenFileResult {
                 dependencies,
@@ -783,7 +780,7 @@ impl WorkspaceServer {
             PathKind::Directory { .. } => {
                 if path.is_dependency() {
                     // Every mode ignores dependencies, except project mode.
-                    return Ok(!scan_kind.is_project() && !scan_kind.is_type_aware());
+                    return Ok(!scan_kind.is_project());
                 }
 
                 if self.projects.is_ignored_by_top_level_config(
@@ -827,7 +824,7 @@ impl WorkspaceServer {
                             )
                         }),
                     },
-                    ScanKind::Project | ScanKind::TypeAware => {
+                    ScanKind::Project => {
                         if path.is_dependency() {
                             // During the initial scan, we only care about
                             // `package.json` files inside `node_modules`, so that
@@ -943,7 +940,6 @@ impl WorkspaceServer {
         &self,
         path: &BiomePath,
         update_kind: &UpdateKind,
-        infer_types: bool,
     ) -> (ModuleDependencies, Vec<ModuleDiagnostic>) {
         match update_kind {
             UpdateKind::AddedOrChanged(_, root, services) => {
@@ -953,7 +949,6 @@ impl WorkspaceServer {
                         self.fs.as_ref(),
                         &self.project_layout,
                         &[(path, js_root)],
-                        infer_types,
                     )
                 } else if let (Some(css_root), Some(services)) = (
                     SendNode::into_language_root::<AnyCssRoot>(root.clone()),
@@ -985,22 +980,13 @@ impl WorkspaceServer {
         &self,
         path: &Utf8Path,
         update_kind: UpdateKind,
-        project_key: ProjectKey,
     ) -> Result<(ModuleDependencies, Vec<ModuleDiagnostic>), WorkspaceError> {
         let path = BiomePath::from(path);
         if path.is_manifest() {
             self.update_project_layout(&path, &update_kind)?;
         }
-        let settings = self
-            .projects
-            .get_settings_based_on_path(project_key, &path)
-            .ok_or_else(WorkspaceError::no_project)?;
 
-        let result = self.update_module_graph_internal(
-            &path,
-            &update_kind,
-            settings.module_graph_resolution_kind.is_modules_and_types(),
-        );
+        let result = self.update_module_graph_internal(&path, &update_kind);
 
         match update_kind {
             UpdateKind::AddedOrChanged(OpenFileReason::Index(IndexTrigger::InitialScan), _, _) => {
@@ -1095,7 +1081,6 @@ impl Workspace for WorkspaceServer {
             configuration,
             project_key,
             extended_configurations,
-            module_graph_resolution_kind,
         } = params;
         let mut diagnostics: Vec<biome_diagnostics::serde::Diagnostic> = vec![];
         let workspace_directory = workspace_directory.map(|p| p.to_path_buf());
@@ -1117,7 +1102,6 @@ impl Workspace for WorkspaceServer {
                 .get_root_settings(project_key)
                 .ok_or_else(WorkspaceError::no_project)?
         };
-        settings.module_graph_resolution_kind = module_graph_resolution_kind;
 
         settings.merge_with_configuration(
             configuration,
@@ -1551,7 +1535,6 @@ impl Workspace for WorkspaceServer {
             let (dependencies, diagnostics) = self.update_service_data(
                 &path,
                 UpdateKind::AddedOrChanged(OpenFileReason::ClientRequest, root, services),
-                project_key,
             )?;
             final_diagnostics.extend(
                 diagnostics
@@ -2211,10 +2194,6 @@ impl Workspace for WorkspaceServer {
 
     fn update_module_graph(&self, params: UpdateModuleGraphParams) -> Result<(), WorkspaceError> {
         let (parsed, services) = self.get_parse_and_services(params.path.as_path())?;
-        let settings = self
-            .projects
-            .get_settings_based_on_path(params.project_key, &params.path)
-            .ok_or_else(WorkspaceError::no_project)?;
         let update_kind = match params.update_kind {
             super::UpdateKind::AddOrUpdate => UpdateKind::AddedOrChanged(
                 OpenFileReason::ClientRequest,
@@ -2224,11 +2203,7 @@ impl Workspace for WorkspaceServer {
             super::UpdateKind::Remove => UpdateKind::Removed,
         };
 
-        self.update_module_graph_internal(
-            &params.path,
-            &update_kind,
-            settings.module_graph_resolution_kind.is_modules_and_types(),
-        );
+        self.update_module_graph_internal(&params.path, &update_kind);
         Ok(())
     }
 
@@ -2450,8 +2425,6 @@ impl WorkspaceScannerBridge for WorkspaceServer {
                 nested_configuration
             };
 
-            let scan_kind = ProjectScanComputer::new(&nested_configuration).compute();
-
             let result = self.update_settings(UpdateSettingsParams {
                 project_key,
                 workspace_directory: nested_directory_path.map(BiomePath::from),
@@ -2460,7 +2433,6 @@ impl WorkspaceScannerBridge for WorkspaceServer {
                     .into_iter()
                     .map(|(path, config)| (BiomePath::from(path), config))
                     .collect(),
-                module_graph_resolution_kind: ModuleGraphResolutionKind::from(&scan_kind),
             })?;
 
             returned_diagnostics.extend(result.diagnostics)
@@ -2519,9 +2491,8 @@ impl WorkspaceScannerBridge for WorkspaceServer {
     fn unload_file(
         &self,
         path: &Utf8Path,
-        project_key: ProjectKey,
     ) -> Result<Vec<biome_diagnostics::serde::Diagnostic>, WorkspaceError> {
-        self.update_service_data(path, UpdateKind::Removed, project_key)
+        self.update_service_data(path, UpdateKind::Removed)
             .map(|(_, diagnostics)| {
                 diagnostics
                     .into_iter()
@@ -2533,7 +2504,6 @@ impl WorkspaceScannerBridge for WorkspaceServer {
     fn unload_path(
         &self,
         path: &Utf8Path,
-        project_key: ProjectKey,
     ) -> Result<Vec<biome_diagnostics::serde::Diagnostic>, WorkspaceError> {
         // Note that we cannot check the kind of the path, because the watcher
         // would only attempt to unload a file or folder after it has been
@@ -2547,7 +2517,7 @@ impl WorkspaceScannerBridge for WorkspaceServer {
         self.project_layout.unload_folder(path);
 
         // Finally unloads the path itself.
-        self.unload_file(path, project_key)
+        self.unload_file(path)
     }
 }
 
diff --git a/crates/biome_service/src/workspace/server.tests.rs b/crates/biome_service/src/workspace/server.tests.rs
index b1b0e1d7e5..b8b536a19f 100644
--- a/crates/biome_service/src/workspace/server.tests.rs
+++ b/crates/biome_service/src/workspace/server.tests.rs
@@ -243,7 +243,6 @@ function Foo({cond}) {
             configuration,
             workspace_directory: Some(BiomePath::new("/project")),
             extended_configurations: Default::default(),
-            module_graph_resolution_kind: ModuleGraphResolutionKind::None,
         })
         .unwrap();
 
@@ -360,7 +359,6 @@ function Foo({cond}) {
             configuration,
             workspace_directory: Some(BiomePath::new("/project")),
             extended_configurations: Default::default(),
-            module_graph_resolution_kind: ModuleGraphResolutionKind::None,
         })
         .unwrap();
 
@@ -518,7 +516,6 @@ const Bar = styled(Component)`
                 ..Default::default()
             },
             extended_configurations: vec![],
-            module_graph_resolution_kind: ModuleGraphResolutionKind::None,
         })
         .unwrap();
 
@@ -590,7 +587,6 @@ const Bar = graphql(`
                 ..Default::default()
             },
             extended_configurations: vec![],
-            module_graph_resolution_kind: ModuleGraphResolutionKind::None,
         })
         .unwrap();
 
diff --git a/crates/biome_test_utils/src/lib.rs b/crates/biome_test_utils/src/lib.rs
index 0b535e8d2d..15e7fe250b 100644
--- a/crates/biome_test_utils/src/lib.rs
+++ b/crates/biome_test_utils/src/lib.rs
@@ -251,7 +251,7 @@ pub fn module_graph_for_test_file(
     let fs = OsFileSystem::new(dir);
     let paths = get_added_js_paths(&fs, &paths);
 
-    module_graph.update_graph_for_js_paths(&fs, project_layout, &paths, true);
+    module_graph.update_graph_for_js_paths(&fs, project_layout, &paths);
 
     Arc::new(module_graph)
 }
diff --git a/packages/@biomejs/backend-jsonrpc/src/workspace.ts b/packages/@biomejs/backend-jsonrpc/src/workspace.ts
index 4a329ed019..df26ece24a 100644
--- a/packages/@biomejs/backend-jsonrpc/src/workspace.ts
+++ b/packages/@biomejs/backend-jsonrpc/src/workspace.ts
@@ -979,8 +979,7 @@ export type RuleDomain =
 	| "vue"
 	| "project"
 	| "tailwind"
-	| "turborepo"
-	| "types";
+	| "turborepo";
 export type RuleDomainValue = "all" | "none" | "recommended";
 export type SeverityOrA11y = GroupPlainConfiguration | A11y;
 export type SeverityOrComplexity = GroupPlainConfiguration | Complexity;
@@ -1106,7 +1105,7 @@ See <https://biomejs.dev/linter/rules/no-aria-unsupported-elements>
 	 */
 	noAriaUnsupportedElements?: NoAriaUnsupportedElementsConfiguration;
 	/**
-	* Enforce that the autofocus attribute is not used on elements.
+	* Enforce that autoFocus prop is not used on elements.
 See <https://biomejs.dev/linter/rules/no-autofocus> 
 	 */
 	noAutofocus?: NoAutofocusConfiguration;
@@ -7140,13 +7139,7 @@ export type UseGetterReturnOptions = {};
 export type UseGoogleFontDisplayOptions = {};
 export type UseGuardForInOptions = {};
 export type UseIsArrayOptions = {};
-export interface UseIterableCallbackReturnOptions {
-	/**
-	* When `true`, the rule reports `forEach` callbacks that return a value (default behaviour).
-When `false` or unset, such callbacks are ignored. 
-	 */
-	checkForEach?: boolean;
-}
+export type UseIterableCallbackReturnOptions = {};
 export type UseNamespaceKeywordOptions = {};
 export type UseNumberToFixedDigitsArgumentOptions = {};
 export type UseStaticResponseMethodsOptions = {};
@@ -7381,11 +7374,9 @@ export type SupportKind =
 export interface UpdateSettingsParams {
 	configuration: Configuration;
 	extendedConfigurations?: [BiomePath, Configuration][];
-	moduleGraphResolutionKind?: ModuleGraphResolutionKind;
 	projectKey: ProjectKey;
 	workspaceDirectory?: BiomePath;
 }
-export type ModuleGraphResolutionKind = "none" | "modules" | "modulesAndTypes";
 export interface UpdateSettingsResult {
 	diagnostics: Diagnostic[];
 }
@@ -8035,8 +8026,7 @@ Target paths must be absolute.
 				targetPaths: BiomePath[];
 			};
 	  }
-	| "project"
-	| "typeAware";
+	| "project";
 export interface ScanProjectResult {
 	/**
 	 * A list of child configuration files found inside the project
@@ -8215,7 +8205,6 @@ When this field is empty, Biome checks only `files.includes`.
 export type IgnoreKind = "path" | "ancestors";
 export interface UpdateModuleGraphParams {
 	path: BiomePath;
-	projectKey: ProjectKey;
 	/**
 	 * The kind of update to apply to the module graph
 	 */
diff --git a/packages/@biomejs/biome/configuration_schema.json b/packages/@biomejs/biome/configuration_schema.json
index 1a70d7eab8..5c60a07904 100644
--- a/packages/@biomejs/biome/configuration_schema.json
+++ b/packages/@biomejs/biome/configuration_schema.json
@@ -100,7 +100,7 @@
 					]
 				},
 				"noAutofocus": {
-					"description": "Enforce that the autofocus attribute is not used on elements.\nSee <https://biomejs.dev/linter/rules/no-autofocus>",
+					"description": "Enforce that autoFocus prop is not used on elements.\nSee <https://biomejs.dev/linter/rules/no-autofocus>",
 					"anyOf": [
 						{ "$ref": "#/$defs/NoAutofocusConfiguration" },
 						{ "type": "null" }
@@ -6238,11 +6238,6 @@
 					"description": "Turborepo build system rules",
 					"type": "string",
 					"const": "turborepo"
-				},
-				{
-					"description": "Rules that require type inference",
-					"type": "string",
-					"const": "types"
 				}
 			]
 		},
@@ -12457,12 +12452,6 @@
 		},
 		"UseIterableCallbackReturnOptions": {
 			"type": "object",
-			"properties": {
-				"checkForEach": {
-					"description": "When `true`, the rule reports `forEach` callbacks that return a value (default behaviour).\nWhen `false` or unset, such callbacks are ignored.",
-					"type": ["boolean", "null"]
-				}
-			},
 			"additionalProperties": false
 		},
 		"UseJsonImportAttributesConfiguration": {
diff --git a/xtask/rules_check/src/lib.rs b/xtask/rules_check/src/lib.rs
index d476cb2b3a..177b272f5b 100644
--- a/xtask/rules_check/src/lib.rs
+++ b/xtask/rules_check/src/lib.rs
@@ -508,7 +508,7 @@ fn assert_lint(
 
                 let options = test.create_analyzer_options::<HtmlLanguage>(config)?;
 
-                biome_html_analyze::analyze(&root, filter, &options, source, |signal| {
+                biome_html_analyze::analyze(&root, filter, &options, |signal| {
                     if let Some(mut diag) = signal.diagnostic() {
                         for action in signal.actions() {
                             if !action.is_suppression() {
