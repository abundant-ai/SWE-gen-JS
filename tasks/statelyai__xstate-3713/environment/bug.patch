diff --git a/.changeset/silly-buses-perform.md b/.changeset/silly-buses-perform.md
deleted file mode 100644
index 26b2eb78b1..0000000000
--- a/.changeset/silly-buses-perform.md
+++ /dev/null
@@ -1,5 +0,0 @@
----
-'xstate': patch
----
-
-Fixed an issue that prevented events sent from the exit actions of the invoking state to be delivered to the invoked actor (when leaving that state).
diff --git a/packages/core/src/StateNode.ts b/packages/core/src/StateNode.ts
index f431c7ea3a..61d4a15a52 100644
--- a/packages/core/src/StateNode.ts
+++ b/packages/core/src/StateNode.ts
@@ -1011,10 +1011,7 @@ class StateNode<
     _event: SCXML.Event<TEvent>,
     prevState?: State<TContext, any, any, any, any>,
     predictableExec?: PredictableActionArgumentsExec
-  ): Array<{
-    type: string;
-    actions: Array<ActionObject<TContext, TEvent>>;
-  }> {
+  ): Array<Array<ActionObject<TContext, TEvent>>> {
     const prevConfig = prevState
       ? getConfiguration([], this.getStateNodes(prevState.value))
       : [];
@@ -1088,40 +1085,29 @@ class StateNode<
         const invokeActions = stateNode.activities.map((activity) =>
           start(activity)
         );
-        return {
-          type: 'entry',
-          actions: toActionObjects(
-            predictableExec
-              ? [...entryActions, ...invokeActions]
-              : [...invokeActions, ...entryActions],
-            this.machine.options.actions as any
-          )
-        };
+        return toActionObjects(
+          predictableExec
+            ? [...entryActions, ...invokeActions]
+            : [...invokeActions, ...entryActions],
+          this.machine.options.actions as any
+        );
       })
-      .concat({
-        type: 'state_done',
-        actions: doneEvents.map(raise) as Array<ActionObject<TContext, TEvent>>
-      });
-
-    const exitActions = Array.from(exitStates).map((stateNode) => ({
-      type: 'exit',
-      actions: toActionObjects(
+      .concat([doneEvents.map(raise) as Array<ActionObject<TContext, TEvent>>]);
+
+    const exitActions = Array.from(exitStates).map((stateNode) =>
+      toActionObjects(
         [
           ...stateNode.onExit,
           ...stateNode.activities.map((activity) => stop(activity))
         ],
         this.machine.options.actions as any
       )
-    }));
+    );
 
     const actions = exitActions
-      .concat({
-        type: 'transition',
-        actions: toActionObjects(
-          transition.actions,
-          this.machine.options.actions as any
-        )
-      })
+      .concat([
+        toActionObjects(transition.actions, this.machine.options.actions as any)
+      ])
       .concat(entryActions);
 
     if (isDone) {
@@ -1138,7 +1124,7 @@ class StateNode<
           (action.type !== actionTypes.send ||
             (!!action.to && action.to !== SpecialTargets.Internal))
       );
-      return actions.concat({ type: 'stop', actions: stopActions });
+      return actions.concat([stopActions]);
     }
 
     return actions;
@@ -1302,7 +1288,7 @@ class StateNode<
     );
     const activities = currentState ? { ...currentState.activities } : {};
     for (const block of actionBlocks) {
-      for (const action of block.actions) {
+      for (const action of block) {
         if (action.type === actionTypes.start) {
           activities[
             action.activity!.id || action.activity!.type
diff --git a/packages/core/src/actions.ts b/packages/core/src/actions.ts
index 95c28cb477..b9ad522951 100644
--- a/packages/core/src/actions.ts
+++ b/packages/core/src/actions.ts
@@ -627,19 +627,16 @@ export function choose<TContext, TEvent extends EventObject>(
 }
 
 const pluckAssigns = <TContext, TEvent extends EventObject>(
-  actionBlocks: Array<{
-    type: string;
-    actions: Array<ActionObject<TContext, TEvent>>;
-  }>
+  actionBlocks: Array<Array<ActionObject<TContext, TEvent>>>
 ): AssignAction<TContext, TEvent>[] => {
   const assignActions: AssignAction<TContext, TEvent>[] = [];
 
   for (const block of actionBlocks) {
     let i = 0;
-    while (i < block.actions.length) {
-      if (block.actions[i].type === actionTypes.assign) {
-        assignActions.push(block.actions[i] as AssignAction<TContext, TEvent>);
-        block.actions.splice(i, 1);
+    while (i < block.length) {
+      if (block[i].type === actionTypes.assign) {
+        assignActions.push(block[i] as AssignAction<TContext, TEvent>);
+        block.splice(i, 1);
         continue;
       }
       i++;
@@ -654,10 +651,7 @@ export function resolveActions<TContext, TEvent extends EventObject>(
   currentState: State<TContext, TEvent, any, any, any> | undefined,
   currentContext: TContext,
   _event: SCXML.Event<TEvent>,
-  actionBlocks: Array<{
-    type: string;
-    actions: Array<ActionObject<TContext, TEvent>>;
-  }>,
+  actionBlocks: Array<Array<ActionObject<TContext, TEvent>>>,
   predictableExec?: PredictableActionArgumentsExec,
   preserveActionOrder: boolean = false
 ): [Array<ActionObject<TContext, TEvent>>, TContext] {
@@ -673,10 +667,7 @@ export function resolveActions<TContext, TEvent extends EventObject>(
 
   const deferredToBlockEnd: Array<ActionObject<TContext, TEvent>> = [];
 
-  function handleAction(
-    blockType: string,
-    actionObject: ActionObject<TContext, TEvent>
-  ) {
+  function handleAction(actionObject: ActionObject<TContext, TEvent>) {
     switch (actionObject.type) {
       case actionTypes.raise: {
         return resolveRaise(actionObject as RaiseAction<TEvent>);
@@ -700,11 +691,7 @@ export function resolveActions<TContext, TEvent extends EventObject>(
         }
 
         if (predictableExec && sendAction.to !== SpecialTargets.Internal) {
-          if (blockType === 'entry') {
-            deferredToBlockEnd.push(sendAction);
-          } else {
-            predictableExec?.(sendAction, updatedContext, _event);
-          }
+          deferredToBlockEnd.push(sendAction);
         }
 
         return sendAction;
@@ -746,13 +733,10 @@ export function resolveActions<TContext, TEvent extends EventObject>(
           updatedContext,
           _event,
           [
-            {
-              type: blockType,
-              actions: toActionObjects(
-                toArray(matchedActions),
-                machine.options.actions as any
-              )
-            }
+            toActionObjects(
+              toArray(matchedActions),
+              machine.options.actions as any
+            )
           ],
           predictableExec,
           preserveActionOrder
@@ -775,13 +759,10 @@ export function resolveActions<TContext, TEvent extends EventObject>(
           updatedContext,
           _event,
           [
-            {
-              type: blockType,
-              actions: toActionObjects(
-                toArray(matchedActions),
-                machine.options.actions as any
-              )
-            }
+            toActionObjects(
+              toArray(matchedActions),
+              machine.options.actions as any
+            )
           ],
           predictableExec,
           preserveActionOrder
@@ -831,14 +812,11 @@ export function resolveActions<TContext, TEvent extends EventObject>(
     }
   }
 
-  function processBlock(block: {
-    type: string;
-    actions: ActionObject<TContext, TEvent>[];
-  }) {
+  function processBlock(block: ActionObject<TContext, TEvent>[]) {
     let resolvedActions: Array<ActionObject<TContext, TEvent>> = [];
 
-    for (const action of block.actions) {
-      const resolved = handleAction(block.type, action);
+    for (const action of block) {
+      const resolved = handleAction(action);
       if (resolved) {
         resolvedActions = resolvedActions.concat(resolved);
       }
diff --git a/packages/core/src/interpreter.ts b/packages/core/src/interpreter.ts
index 80fc64d520..b0d12ccdd3 100644
--- a/packages/core/src/interpreter.ts
+++ b/packages/core/src/interpreter.ts
@@ -645,12 +645,7 @@ export class Interpreter<
           this.state,
           this.state.context,
           _event,
-          [
-            {
-              type: 'exit',
-              actions: exitActions
-            }
-          ],
+          [exitActions],
           this.machine.config.predictableActionArguments
             ? this._exec
             : undefined,
diff --git a/packages/core/test/predictableExec.test.ts b/packages/core/test/predictableExec.test.ts
index b393996d34..ab5a7b27c0 100644
--- a/packages/core/test/predictableExec.test.ts
+++ b/packages/core/test/predictableExec.test.ts
@@ -3,8 +3,7 @@ import {
   interpret,
   assign,
   spawn,
-  AnyInterpreter,
-  sendTo
+  AnyInterpreter
 } from '../src';
 import { raise, stop, send, sendParent } from '../src/actions';
 
@@ -776,35 +775,4 @@ describe('predictableExec', () => {
 
     expect(gotEvent).toBe(true);
   });
-
-  // https://github.com/statelyai/xstate/issues/3617
-  it('should deliver events sent from the exit actions to a service invoked in the same state', (done) => {
-    const machine = createMachine({
-      initial: 'active',
-      predictableActionArguments: true,
-      states: {
-        active: {
-          invoke: {
-            id: 'my-service',
-            src: (_, __) => (_, onReceive) => {
-              onReceive((event) => {
-                if (event.type === 'MY_EVENT') {
-                  done();
-                }
-              });
-            }
-          },
-          exit: sendTo('my-service', { type: 'MY_EVENT' }),
-          on: {
-            TOGGLE: 'inactive'
-          }
-        },
-        inactive: {}
-      }
-    });
-
-    const actor = interpret(machine).start();
-
-    actor.send({ type: 'TOGGLE' });
-  });
 });
