diff --git a/index.js b/index.js
index 297a24d..d7c6058 100644
--- a/index.js
+++ b/index.js
@@ -94,7 +94,7 @@ function handleShell(fn, command, options) {
 
 function makeAllStream(spawned) {
 	if (!spawned.stdout && !spawned.stderr) {
-		return null;
+		return;
 	}
 
 	const mixed = mergeStream();
@@ -112,7 +112,7 @@ function makeAllStream(spawned) {
 
 function getStream(process, stream, {encoding, buffer, maxBuffer}) {
 	if (!process[stream]) {
-		return null;
+		return;
 	}
 
 	let ret;
@@ -161,7 +161,9 @@ function makeError(result, options) {
 	error.stdout = stdout;
 	error.stderr = stderr;
 	error.failed = true;
-	error.signal = signal || null;
+	// `signal` emitted on `spawned.on('exit')` event can be `null`. We normalize
+	// it to `undefined`
+	error.signal = signal || undefined;
 	error.cmd = joinedCommand;
 	error.timedOut = Boolean(timedOut);
 
@@ -237,13 +239,13 @@ module.exports = (command, args, options) => {
 		});
 	}
 
-	let timeoutId = null;
+	let timeoutId;
 	let timedOut = false;
 
 	const cleanup = () => {
-		if (timeoutId) {
+		if (timeoutId !== undefined) {
 			clearTimeout(timeoutId);
-			timeoutId = null;
+			timeoutId = undefined;
 		}
 
 		if (removeExitHandler) {
@@ -253,7 +255,7 @@ module.exports = (command, args, options) => {
 
 	if (parsed.options.timeout > 0) {
 		timeoutId = setTimeout(() => {
-			timeoutId = null;
+			timeoutId = undefined;
 			timedOut = true;
 			spawned.kill(parsed.options.killSignal);
 		}, parsed.options.timeout);
@@ -332,7 +334,6 @@ module.exports = (command, args, options) => {
 			exitCodeName: 'SUCCESS',
 			failed: false,
 			killed: false,
-			signal: null,
 			cmd: joinedCommand,
 			timedOut: false
 		};
@@ -401,7 +402,6 @@ module.exports.sync = (command, args, options) => {
 		exitCode: 0,
 		exitCodeName: 'SUCCESS',
 		failed: false,
-		signal: null,
 		cmd: joinedCommand,
 		timedOut: false
 	};
diff --git a/lib/errname.js b/lib/errname.js
index 8f9e1fb..151c53f 100644
--- a/lib/errname.js
+++ b/lib/errname.js
@@ -16,7 +16,7 @@ if (typeof util.getSystemErrorName === 'function') {
 		}
 	} catch (error) {
 		console.error('execa/lib/errname: unable to establish process.binding(\'uv\')', error);
-		uv = null;
+		uv = undefined;
 	}
 
 	module.exports = code => errname(uv, code);
@@ -26,7 +26,7 @@ if (typeof util.getSystemErrorName === 'function') {
 module.exports.__test__ = errname;
 
 function errname(uv, code) {
-	if (uv) {
+	if (uv !== undefined) {
 		return uv.errname(code);
 	}
 
diff --git a/lib/stdio.js b/lib/stdio.js
index a82d468..5b4cb9e 100644
--- a/lib/stdio.js
+++ b/lib/stdio.js
@@ -5,7 +5,7 @@ const hasAlias = opts => alias.some(x => Boolean(opts[x]));
 
 module.exports = opts => {
 	if (!opts) {
-		return null;
+		return;
 	}
 
 	if (opts.stdio && hasAlias(opts)) {
@@ -26,7 +26,7 @@ module.exports = opts => {
 	const len = Math.max(stdio.length, alias.length);
 
 	for (let i = 0; i < len; i++) {
-		let value = null;
+		let value;
 
 		if (stdio[i] !== undefined) {
 			value = stdio[i];
diff --git a/readme.md b/readme.md
index c6d9d83..26cbdbc 100644
--- a/readme.md
+++ b/readme.md
@@ -68,7 +68,6 @@ const execa = require('execa');
 			stderr: '',
 			all: '',
 			failed: true,
-			signal: null,
 			cmd: 'exit 3',
 			timedOut: false,
 			killed: false
@@ -91,7 +90,6 @@ try {
 		stdout: '',
 		stderr: '',
 		failed: true,
-		signal: null,
 		cmd: 'exit 3',
 		timedOut: false
 	}
diff --git a/test.js b/test.js
index 9c043a4..1265c65 100644
--- a/test.js
+++ b/test.js
@@ -210,7 +210,7 @@ test('opts.stdout:ignore - stdout will not collect data', async t => {
 		input: 'hello',
 		stdio: [null, 'ignore', null]
 	});
-	t.is(stdout, null);
+	t.is(stdout, undefined);
 });
 
 test('helpful error trying to provide an input stream in sync mode', t => {
@@ -367,13 +367,13 @@ if (process.platform !== 'win32') {
 	});
 }
 
-test('result.signal is null for successful execution', async t => {
-	t.is((await execa('noop')).signal, null);
+test('result.signal is undefined for successful execution', async t => {
+	t.is((await execa('noop')).signal, undefined);
 });
 
-test('result.signal is null if process failed, but was not killed', async t => {
+test('result.signal is undefined if process failed, but was not killed', async t => {
 	const error = await t.throwsAsync(execa('exit', [2]), {message: getExitRegExp('2')});
-	t.is(error.signal, null);
+	t.is(error.signal, undefined);
 });
 
 async function code(t, num) {
