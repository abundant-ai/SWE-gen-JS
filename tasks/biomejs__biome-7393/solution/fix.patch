diff --git a/.changeset/big-keys-play.md b/.changeset/big-keys-play.md
deleted file mode 100644
index 86b1cbadae..0000000000
--- a/.changeset/big-keys-play.md
+++ /dev/null
@@ -1,5 +0,0 @@
----
-"@biomejs/biome": patch
----
-
-Fixed [#7381](https://github.com/biomejs/biome/issues/7381), now the [`useOptionalChain`](https://biomejs.dev/ja/linter/rules/use-optional-chain/) rule recognizes optional chaining using Yoda expressions (e.g., `undefined !== foo && foo.bar`).
diff --git a/.changeset/tender-results-fix.md b/.changeset/tender-results-fix.md
deleted file mode 100644
index a56b01cdd9..0000000000
--- a/.changeset/tender-results-fix.md
+++ /dev/null
@@ -1,20 +0,0 @@
----
-"@biomejs/biome": patch
----
-
-Fixed [#7344](https://github.com/biomejs/biome/issues/7344). [`useNamingConvention`](https://biomejs.dev/linter/rules/use-naming-convention/) no longer reports interfaces defined in global declarations.
-
-Interfaces declared in global declarations augment existing interfaces.
-Thus, they must be ignored.
-
-In the following example, `useNamingConvention` reported `HTMLElement`.
-It is now ignored.
-
-```ts
-export {};
-declare global {
-  interface HTMLElement {
-    foo(): void;
-  }
-}
-```
diff --git a/crates/biome_analyze/src/options.rs b/crates/biome_analyze/src/options.rs
index 6acb245668..6cb105f7a4 100644
--- a/crates/biome_analyze/src/options.rs
+++ b/crates/biome_analyze/src/options.rs
@@ -3,7 +3,6 @@ use rustc_hash::FxHashMap;
 
 use crate::{FixKind, Rule, RuleKey};
 use std::any::{Any, TypeId};
-use std::fmt::Debug;
 use std::sync::Arc;
 
 /// A convenient new type data structure to store the options that belong to a rule
diff --git a/crates/biome_js_analyze/src/lint/complexity/use_optional_chain.rs b/crates/biome_js_analyze/src/lint/complexity/use_optional_chain.rs
index 54f69aff86..abb730d1d7 100644
--- a/crates/biome_js_analyze/src/lint/complexity/use_optional_chain.rs
+++ b/crates/biome_js_analyze/src/lint/complexity/use_optional_chain.rs
@@ -263,10 +263,10 @@ impl Rule for UseOptionalChain {
 /// Normalize optional chain like.
 /// E.g. `foo != null` is normalized to `foo`
 fn normalized_optional_chain_like(expression: AnyJsExpression) -> SyntaxResult<AnyJsExpression> {
-    if let AnyJsExpression::JsBinaryExpression(binary_expression) = &expression
-        && let Some(expr) = binary_expression.extract_optional_chain_like()?
+    if let AnyJsExpression::JsBinaryExpression(expression) = &expression
+        && expression.is_optional_chain_like()?
     {
-        return Ok(expr);
+        return expression.left();
     }
     Ok(expression)
 }
@@ -561,9 +561,10 @@ impl LogicalAndChain {
                 // ```js
                 // foo && foo.bar;
                 // ```
-                AnyJsExpression::JsBinaryExpression(expression) => {
-                    expression.extract_optional_chain_like().ok()??
-                }
+                AnyJsExpression::JsBinaryExpression(expression) => expression
+                    .is_optional_chain_like()
+                    .ok()?
+                    .then_some(expression.left().ok()?)?,
                 expression => expression,
             };
             let head = match expression {
diff --git a/crates/biome_js_analyze/src/lint/style/use_naming_convention.rs b/crates/biome_js_analyze/src/lint/style/use_naming_convention.rs
index ff16c4659b..bec4087809 100644
--- a/crates/biome_js_analyze/src/lint/style/use_naming_convention.rs
+++ b/crates/biome_js_analyze/src/lint/style/use_naming_convention.rs
@@ -286,14 +286,6 @@ declare_lint_rule! {
     ///   }
     ///   ```
     ///
-    /// - Declarations inside a global declaration
-    ///
-    ///   ```ts
-    ///   declare global {
-    ///     interface HTMLElement {}
-    ///   }
-    ///   ```
-    ///
     /// ## Options
     ///
     /// The rule provides several options that are detailed in the following subsections.
@@ -1203,6 +1195,7 @@ fn selector_from_binding_declaration(decl: &AnyJsBindingDeclaration) -> Option<S
             | AnyJsBindingDeclaration::JsArrayBindingPatternRestElement(_)
             | AnyJsBindingDeclaration::JsObjectBindingPatternProperty(_)
             | AnyJsBindingDeclaration::JsObjectBindingPatternRest(_) => {
+
                 selector_from_parent_binding_pattern_declaration(&decl.parent_binding_pattern_declaration()?)
             }
             AnyJsBindingDeclaration::JsVariableDeclarator(var) => {
@@ -1247,12 +1240,9 @@ fn selector_from_binding_declaration(decl: &AnyJsBindingDeclaration) -> Option<S
             }
             AnyJsBindingDeclaration::TsImportEqualsDeclaration(_)
             | AnyJsBindingDeclaration::JsDefaultImportSpecifier(_)
-            | AnyJsBindingDeclaration::JsNamedImportSpecifier(_) =>
-                Some(Selector::with_scope(Kind::ImportAlias, Scope::Global)),
-            AnyJsBindingDeclaration::TsModuleDeclaration(_) =>
-                Some(Selector::with_scope(Kind::Namespace, Scope::Global)),
-            AnyJsBindingDeclaration::TsTypeAliasDeclaration(_) =>
-                Some(Selector::with_scope(Kind::TypeAlias, scope_from_declaration(decl)?)),
+            | AnyJsBindingDeclaration::JsNamedImportSpecifier(_) => Some(Selector::with_scope(Kind::ImportAlias, Scope::Global)),
+            AnyJsBindingDeclaration::TsModuleDeclaration(_) => Some(Selector::with_scope(Kind::Namespace, Scope::Global)),
+            AnyJsBindingDeclaration::TsTypeAliasDeclaration(_) => Some(Selector::with_scope(Kind::TypeAlias, scope_from_declaration(decl)?)),
             AnyJsBindingDeclaration::JsClassDeclaration(class) => {
                 Some(Selector {
                     kind: Kind::Class,
@@ -1278,10 +1268,8 @@ fn selector_from_binding_declaration(decl: &AnyJsBindingDeclaration) -> Option<S
             AnyJsBindingDeclaration::JsClassExpression(_) => {
                 Some(Selector::with_scope(Kind::Class, scope_from_declaration(decl)?))
             }
-            AnyJsBindingDeclaration::TsInterfaceDeclaration(_) =>
-                Some(Selector::with_scope(Kind::Interface, scope_from_declaration(decl)?)),
-            AnyJsBindingDeclaration::TsEnumDeclaration(_) =>
-                Some(Selector::with_scope(Kind::Enum, scope_from_declaration(decl)?)),
+            AnyJsBindingDeclaration::TsInterfaceDeclaration(_) => Some(Selector::with_scope(Kind::Interface, scope_from_declaration(decl)?)),
+            AnyJsBindingDeclaration::TsEnumDeclaration(_) => Some(Selector::with_scope(Kind::Enum, scope_from_declaration(decl)?)),
             AnyJsBindingDeclaration::JsObjectBindingPatternShorthandProperty(_)
             | AnyJsBindingDeclaration::JsShorthandNamedImportSpecifier(_)
             | AnyJsBindingDeclaration::JsBogusNamedImportSpecifier(_)
@@ -1464,15 +1452,14 @@ fn scope_from_declaration(node: &AnyJsBindingDeclaration) -> Option<Scope> {
         AnyJsControlFlowRoot::can_cast(x.kind())
             || x.kind() == JsSyntaxKind::TS_DECLARATION_MODULE
             || x.kind() == JsSyntaxKind::TS_EXTERNAL_MODULE_DECLARATION
-            || x.kind() == JsSyntaxKind::TS_GLOBAL_DECLARATION
     })?;
     match control_flow_root.kind() {
         JsSyntaxKind::JS_MODULE
         | JsSyntaxKind::JS_SCRIPT
         | JsSyntaxKind::TS_DECLARATION_MODULE
         | JsSyntaxKind::TS_MODULE_DECLARATION => Some(Scope::Global),
-        // Ignore declarations in external module declaration and global declarations.
-        JsSyntaxKind::TS_EXTERNAL_MODULE_DECLARATION | JsSyntaxKind::TS_GLOBAL_DECLARATION => None,
+        // Ignore declarations in an external module declaration
+        JsSyntaxKind::TS_EXTERNAL_MODULE_DECLARATION => None,
         _ => Some(Scope::Any),
     }
 }
diff --git a/crates/biome_js_syntax/src/expr_ext.rs b/crates/biome_js_syntax/src/expr_ext.rs
index 74baa0e2c4..c1396a9503 100644
--- a/crates/biome_js_syntax/src/expr_ext.rs
+++ b/crates/biome_js_syntax/src/expr_ext.rs
@@ -320,52 +320,24 @@ impl JsBinaryExpression {
         )
     }
 
-    /// Extract the left or right operand of an optional chain-like expression.
+    /// Whether this is a comparison operation similar to the optional chain
     /// ```js
-    /// foo !== undefined;  // -> Some(foo)
-    /// foo != undefined;  // -> Some(foo)
-    /// foo !== null;  // -> Some(foo)
-    /// foo != null;  // -> Some(foo)
-    /// undefined !== foo;  // -> Some(foo)
-    /// undefined != foo;  // -> Some(foo)
-    /// null !== foo;  // -> Some(foo)
-    /// null != foo;  // -> Some(foo)
-    /// foo !== bar;  // -> None
-    /// foo != bar;  // -> None
-    /// undefined !== null;  // -> None
-    /// undefined != null;  // -> None
-    /// null !== undefined;  // -> None
-    /// null != undefined;  // -> None
-    /// undefined !== undefined;  // -> None
-    /// undefined != undefined;  // -> None
-    /// null !== null;  // -> None
-    /// null != null;  // -> None
+    /// foo !== undefined;
+    /// foo != undefined;
+    /// foo !== null;
+    /// foo != null;
     ///```
-    pub fn extract_optional_chain_like(&self) -> SyntaxResult<Option<AnyJsExpression>> {
-        fn is_nullish(expression: &AnyJsExpression) -> bool {
-            expression
-                .as_static_value()
-                .is_some_and(|x| x.is_null_or_undefined())
-        }
+    pub fn is_optional_chain_like(&self) -> SyntaxResult<bool> {
         if matches!(
             self.operator(),
             Ok(JsBinaryOperator::StrictInequality | JsBinaryOperator::Inequality)
         ) {
-            let left = self.left()?;
-            let right = self.right()?;
-            let left_is_nullish = is_nullish(&left);
-            let right_is_nullish = is_nullish(&right);
-            // right only nullish: `foo !== undefined` -> return foo (left)
-            if !left_is_nullish && right_is_nullish {
-                return Ok(Some(left));
-            }
-            // left only nullish: `undefined !== foo` -> return foo (right)
-            if left_is_nullish && !right_is_nullish {
-                return Ok(Some(right));
-            }
-            Ok(None)
+            Ok(self
+                .right()?
+                .as_static_value()
+                .is_some_and(|x| x.is_null_or_undefined()))
         } else {
-            Ok(None)
+            Ok(false)
         }
     }
 }
diff --git a/crates/biome_js_type_info/src/conditionals.rs b/crates/biome_js_type_info/src/conditionals.rs
index a96587900e..4d6ce5a50f 100644
--- a/crates/biome_js_type_info/src/conditionals.rs
+++ b/crates/biome_js_type_info/src/conditionals.rs
@@ -54,14 +54,18 @@ impl ConditionalType {
                 return ConditionalType::Unknown;
             }
 
-            let derive_from_reference = |reference: &TypeReference| -> ConditionalType {
-                let reference = ty.apply_module_id_to_reference(reference);
-                match resolver.resolve_and_get(&reference) {
+            let derive_from_resolved_reference = |reference: &TypeReference| -> ConditionalType {
+                match resolver.resolve_and_get(reference) {
                     Some(ty) => derive_conditional_type(ty, resolver, depth),
                     None => ConditionalType::Unknown,
                 }
             };
 
+            let derive_from_reference = |reference: &TypeReference| -> ConditionalType {
+                let reference = ty.apply_module_id_to_reference(reference);
+                derive_from_resolved_reference(&reference)
+            };
+
             match ConditionalType::from_data_shallow(ty.as_raw_data()) {
                 Some(conditional) => conditional,
                 None => match ty.as_raw_data() {
@@ -106,7 +110,7 @@ impl ConditionalType {
                     TypeData::Union(_) => {
                         let mut conditional = ConditionalType::Unknown;
                         for ty in ty.flattened_union_variants(resolver) {
-                            let next = derive_from_reference(&ty);
+                            let next = derive_from_resolved_reference(&ty);
                             conditional = if conditional == ConditionalType::Unknown {
                                 next
                             } else {
@@ -427,7 +431,7 @@ fn to_filtered_value(
                     .collect();
                 Some(TypeData::union_of(resolver, types))
             }
-            _ => None,
+            _ => Some(resolved.clone()),
         },
         FilteredData::Stripped => None,
     }
diff --git a/crates/biome_js_type_info/src/helpers.rs b/crates/biome_js_type_info/src/helpers.rs
index 420a91d072..77e8b6349b 100644
--- a/crates/biome_js_type_info/src/helpers.rs
+++ b/crates/biome_js_type_info/src/helpers.rs
@@ -583,6 +583,7 @@ generate_matcher!(is_interface, Interface, _);
 generate_matcher!(is_null, Null);
 generate_matcher!(is_reference, Reference, _);
 generate_matcher!(is_never_keyword, NeverKeyword);
+generate_matcher!(is_undefined, Undefined);
 generate_matcher!(is_union, Union, _);
 generate_matcher!(is_unknown_keyword, UnknownKeyword);
 generate_matcher!(is_void_keyword, VoidKeyword);
diff --git a/crates/biome_js_type_info/src/lib.rs b/crates/biome_js_type_info/src/lib.rs
index a2a2e03f31..7f8406ae10 100644
--- a/crates/biome_js_type_info/src/lib.rs
+++ b/crates/biome_js_type_info/src/lib.rs
@@ -11,6 +11,7 @@ mod r#type;
 mod type_data;
 mod type_store;
 
+pub use conditionals::*;
 pub use flattening::MAX_FLATTEN_DEPTH;
 pub use globals::{GLOBAL_RESOLVER, GLOBAL_UNKNOWN_ID, GlobalsResolver, NUM_PREDEFINED_TYPES};
 pub use resolver::*;
diff --git a/crates/biome_js_type_info/src/type.rs b/crates/biome_js_type_info/src/type.rs
index 11f8a14931..5c81dbcee1 100644
--- a/crates/biome_js_type_info/src/type.rs
+++ b/crates/biome_js_type_info/src/type.rs
@@ -129,6 +129,17 @@ impl Type {
         }
     }
 
+    /// Returns whether this type is a boolean with the given `value`.
+    pub fn is_boolean_literal(&self, value: bool) -> bool {
+        self.as_raw_data().is_some_and(|ty| match ty {
+            TypeData::Literal(literal) => match literal.as_ref() {
+                Literal::Boolean(literal) => literal.as_bool() == value,
+                _ => false,
+            },
+            _ => false,
+        })
+    }
+
     /// Returns whether `self` is a function with a return type matching the
     /// given `predicate`.
     pub fn is_function_with_return_type(&self, predicate: impl Fn(Self) -> bool) -> bool {
@@ -176,6 +187,19 @@ impl Type {
             })
     }
 
+    /// Returns whether this type is a number with the given `value`.
+    pub fn is_number_literal(&self, value: f64) -> bool {
+        self.as_raw_data().is_some_and(|ty| match ty {
+            TypeData::Literal(literal) => match literal.as_ref() {
+                Literal::Number(literal) => literal
+                    .to_f64()
+                    .is_some_and(|literal_value| literal_value == value),
+                _ => false,
+            },
+            _ => false,
+        })
+    }
+
     /// Returns whether this type is the `Promise` class.
     pub fn is_promise(&self) -> bool {
         self.id == GLOBAL_PROMISE_ID
