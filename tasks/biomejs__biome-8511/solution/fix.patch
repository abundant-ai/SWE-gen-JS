diff --git a/.changeset/dry-birds-design.md b/.changeset/dry-birds-design.md
new file mode 100644
index 0000000000..d11d7005e6
--- /dev/null
+++ b/.changeset/dry-birds-design.md
@@ -0,0 +1,5 @@
+---
+"@biomejs/biome": patch
+---
+
+Improved the diagnostics of the rules `useSortedClasses` and `noUnnecessaryConditions`. The diagnostics now state that these rules are a work in progress and link to the relevant GitHub issue.
diff --git a/crates/biome_analyze/CONTRIBUTING.md b/crates/biome_analyze/CONTRIBUTING.md
index 486a482b42..e3e2f8c2d9 100644
--- a/crates/biome_analyze/CONTRIBUTING.md
+++ b/crates/biome_analyze/CONTRIBUTING.md
@@ -20,6 +20,7 @@ The analyzer allows implementors to create **three different** types of rules:
       - [Naming Conventions for Rules](#naming-conventions-for-rules)
       - [What a Rule should say to the User](#what-a-rule-should-say-to-the-user)
       - [Placement of New Rules](#placement-of-new-rules)
+    + [Mark a rule as a work in progress](#mark-a-rule-as-a-work-in-progress)
     + [Creating and Implementing the Rule](#creating-and-implementing-the-rule)
     + [Coding Tips for Rules](#coding-tips-for-rules)
       - [`declare_lint_rule!` macro](#declare_lint_rule-macro)
@@ -219,6 +220,26 @@ New rules **must** be placed inside the `nursery` group. This group is meant as
 >
 > If you aren't familiar with Biome's APIs, this is an option that you have. If you decide to use this option, you should make sure to describe your plan in an issue.
 
+### Mark a rule as a work in progress
+
+Sometimes nursery rules aren't completed yet – missing use cases, code actions, etc. – and you might want to communicate that to your users.
+
+You can add `issue_number` to the rule macro, and Biome will:
+- Add a footnote to the diagnostic of the rule with a link to the issue, e.g. `https://github.com/biomejs/biome/issues/1111`
+- Add a note on the website, with a link to the issue.
+
+```rust
+declare_lint_rule! {
+    /// Docs
+    pub(crate) NoVar {
+        version: "next",
+        name: "noVar",
+        language: "js",
+        issue_number: Some("1111"),
+    }
+}
+```
+
 ### Creating and Implementing the Rule
 
 Let's say we want to create a new **lint** rule called `useMyRuleName`, follow these steps:
diff --git a/crates/biome_analyze/src/rule.rs b/crates/biome_analyze/src/rule.rs
index 00e9891b48..429f26d9b2 100644
--- a/crates/biome_analyze/src/rule.rs
+++ b/crates/biome_analyze/src/rule.rs
@@ -44,6 +44,9 @@ pub struct RuleMetadata {
     pub severity: Severity,
     /// Domains applied by this rule
     pub domains: &'static [RuleDomain],
+    /// Use this field to tag the rule as being worked, which means the rule is still far from being completed.
+    /// Possible bugs should be reported in that issue.
+    pub issue_number: Option<&'static str>,
 }
 
 #[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
@@ -609,6 +612,7 @@ impl RuleMetadata {
             sources: &[],
             severity: Severity::Information,
             domains: &[],
+            issue_number: None,
         }
     }
 
@@ -647,6 +651,11 @@ impl RuleMetadata {
         self
     }
 
+    pub const fn issue_number(mut self, issue_number: Option<&'static str>) -> Self {
+        self.issue_number = issue_number;
+        self
+    }
+
     pub fn applicability(&self) -> Applicability {
         self.fix_kind
             .try_into()
diff --git a/crates/biome_analyze/src/signals.rs b/crates/biome_analyze/src/signals.rs
index 805e535d63..adfd0a23e8 100644
--- a/crates/biome_analyze/src/signals.rs
+++ b/crates/biome_analyze/src/signals.rs
@@ -9,7 +9,7 @@ use crate::{
     registry::{RuleLanguage, RuleRoot},
     rule::Rule,
 };
-use biome_console::MarkupBuf;
+use biome_console::{MarkupBuf, markup};
 use biome_diagnostics::{Applicability, CodeSuggestion, Error, advice::CodeSuggestionAdvice};
 use biome_rowan::{BatchMutation, Language};
 use std::iter::FusedIterator;
@@ -376,6 +376,13 @@ where
 
         R::diagnostic(&ctx, &self.state).map(|mut diagnostic| {
             diagnostic.severity = ctx.metadata().severity;
+
+            if let Some(issue_number) = ctx.metadata().issue_number {
+                let url = format!("https://github.com/biomejs/biome/issues/{}", issue_number);
+                diagnostic = diagnostic.note(markup! {
+                         "This rule is still being actively worked on, so it may be missing features or have rough edges. Visit "<Hyperlink href={url.as_str()}>{url.as_str()}</Hyperlink>" for more information or to report possible bugs."
+                     });
+            }
             AnalyzerDiagnostic::from(diagnostic)
         })
     }
diff --git a/crates/biome_js_analyze/src/lint/nursery/no_unnecessary_conditions.rs b/crates/biome_js_analyze/src/lint/nursery/no_unnecessary_conditions.rs
index b4f3aefa4e..eed6b69a00 100644
--- a/crates/biome_js_analyze/src/lint/nursery/no_unnecessary_conditions.rs
+++ b/crates/biome_js_analyze/src/lint/nursery/no_unnecessary_conditions.rs
@@ -91,6 +91,7 @@ declare_lint_rule! {
         recommended: false,
         severity: Severity::Warning,
         domains: &[RuleDomain::Project],
+        issue_number: Some("6611"),
     }
 }
 
diff --git a/crates/biome_js_analyze/src/lint/nursery/use_sorted_classes.rs b/crates/biome_js_analyze/src/lint/nursery/use_sorted_classes.rs
index fbf03fbf7a..27d826aa89 100644
--- a/crates/biome_js_analyze/src/lint/nursery/use_sorted_classes.rs
+++ b/crates/biome_js_analyze/src/lint/nursery/use_sorted_classes.rs
@@ -156,6 +156,7 @@ declare_lint_rule! {
         language: "js",
         recommended: false,
         fix_kind: FixKind::Unsafe,
+        issue_number: Some("1274"),
     }
 }
 
diff --git a/crates/biome_json_analyze/Cargo.toml b/crates/biome_json_analyze/Cargo.toml
index 012307bf8b..67cb8177c8 100644
--- a/crates/biome_json_analyze/Cargo.toml
+++ b/crates/biome_json_analyze/Cargo.toml
@@ -14,9 +14,8 @@ version              = "0.5.7"
 # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
 
 [dependencies]
-biome_analyze = { workspace = true }
-# biome_configuration is optional because the codegen disables it. The codegen generates the configuration schema, and it depends on this crate to to that. It's kinda like a circular dependency. A chicken and egg problem, if you will.
-biome_configuration = { workspace = true, optional = true }
+biome_analyze       = { workspace = true }
+biome_configuration = { workspace = true }
 biome_console       = { workspace = true }
 biome_diagnostics   = { workspace = true }
 biome_json_factory  = { workspace = true }
@@ -28,10 +27,6 @@ biome_suppression   = { workspace = true }
 camino              = { workspace = true }
 rustc-hash          = { workspace = true }
 
-[features]
-configuration = ["dep:biome_configuration"]
-default       = ["configuration"]
-
 [dev-dependencies]
 biome_json_parser = { path = "../biome_json_parser" }
 biome_test_utils  = { path = "../biome_test_utils" }
diff --git a/crates/biome_json_analyze/src/lib.rs b/crates/biome_json_analyze/src/lib.rs
index dc92a38332..674a30cec1 100644
--- a/crates/biome_json_analyze/src/lib.rs
+++ b/crates/biome_json_analyze/src/lib.rs
@@ -16,10 +16,7 @@ use biome_analyze::{
     LanguageRoot, MatchQueryParams, MetadataRegistry, RuleAction, RuleRegistry,
     to_analyzer_suppressions,
 };
-#[cfg(feature = "configuration")]
 use biome_configuration::ConfigurationSource;
-#[cfg(not(feature = "configuration"))]
-pub struct ConfigurationSource;
 use biome_diagnostics::Error;
 use biome_json_syntax::{JsonFileSource, JsonLanguage, TextRange};
 use biome_suppression::{SuppressionDiagnostic, parse_suppression_comment};
diff --git a/crates/biome_json_analyze/src/lint/suspicious/no_biome_first_exception.rs b/crates/biome_json_analyze/src/lint/suspicious/no_biome_first_exception.rs
index b847d16979..a97d307d9b 100644
--- a/crates/biome_json_analyze/src/lint/suspicious/no_biome_first_exception.rs
+++ b/crates/biome_json_analyze/src/lint/suspicious/no_biome_first_exception.rs
@@ -87,7 +87,6 @@ impl Rule for NoBiomeFirstException {
         let file_path = ctx.file_path();
 
         // we check if and extended package starts with `**`
-        #[cfg(feature = "configuration")]
         let extends_starts_with_catch_all = ctx.extends().is_some_and(|mut extends| {
             extends.any(|c| {
                 c.files
@@ -96,8 +95,6 @@ impl Rule for NoBiomeFirstException {
                     .is_some_and(|globs| globs.first().is_some_and(|glob| glob.as_str() == "**"))
             })
         });
-        #[cfg(not(feature = "configuration"))]
-        let extends_starts_with_catch_all = false;
         // we use ends_with so it works only during testing
         if !file_path
             .file_name()
diff --git a/crates/biome_json_analyze/src/services/config_source.rs b/crates/biome_json_analyze/src/services/config_source.rs
index 89b198b018..b3fec1fb95 100644
--- a/crates/biome_json_analyze/src/services/config_source.rs
+++ b/crates/biome_json_analyze/src/services/config_source.rs
@@ -2,22 +2,14 @@ use biome_analyze::{
     AddVisitor, FromServices, Phase, Phases, QueryKey, Queryable, RuleKey, RuleMetadata,
     ServiceBag, ServicesDiagnostic, SyntaxVisitor,
 };
-#[cfg(feature = "configuration")]
 use biome_configuration::{ConfigurationSource, ExtendedConfigurationIterator};
 use biome_json_syntax::{JsonLanguage, JsonRoot, JsonSyntaxNode};
 use biome_rowan::AstNode;
-#[cfg(feature = "configuration")]
 use std::sync::Arc;
 
-#[cfg(feature = "configuration")]
 #[derive(Debug, Default)]
-pub struct ConfigurationSourceService(Option<std::sync::Arc<ConfigurationSource>>);
+pub struct ConfigurationSourceService(Option<Arc<ConfigurationSource>>);
 
-#[cfg(not(feature = "configuration"))]
-#[derive(Debug, Default)]
-pub struct ConfigurationSourceService;
-
-#[cfg(feature = "configuration")]
 impl ConfigurationSourceService {
     pub(crate) fn extends(&self) -> Option<ExtendedConfigurationIterator<'_>> {
         self.0
@@ -26,7 +18,6 @@ impl ConfigurationSourceService {
     }
 }
 
-#[cfg(feature = "configuration")]
 impl FromServices for ConfigurationSourceService {
     fn from_services(
         rule_key: &RuleKey,
@@ -42,17 +33,6 @@ impl FromServices for ConfigurationSourceService {
     }
 }
 
-#[cfg(not(feature = "configuration"))]
-impl FromServices for ConfigurationSourceService {
-    fn from_services(
-        _rule_key: &RuleKey,
-        _rule_metadata: &RuleMetadata,
-        _services: &ServiceBag,
-    ) -> Result<Self, ServicesDiagnostic> {
-        Ok(Self)
-    }
-}
-
 impl Phase for ConfigurationSourceService {
     fn phase() -> Phases {
         Phases::Syntax
diff --git a/xtask/codegen/Cargo.toml b/xtask/codegen/Cargo.toml
index ef59371db4..70a5c7f867 100644
--- a/xtask/codegen/Cargo.toml
+++ b/xtask/codegen/Cargo.toml
@@ -32,18 +32,16 @@ biome_js_factory      = { workspace = true, optional = true }
 biome_js_formatter    = { workspace = true, optional = true }
 biome_js_parser       = { workspace = true, optional = true }
 biome_js_syntax       = { workspace = true, optional = true }
-# HACK: This is a path dependency and not a workspace dependency because
-# `default-features` is not allowed to override the workspace default, for whatever reason.
-biome_json_analyze   = { path = "../../crates/biome_json_analyze", optional = true, default-features = false }
-biome_json_formatter = { workspace = true, optional = true }
-biome_json_parser    = { workspace = true, optional = true }
-biome_json_syntax    = { workspace = true, optional = true }
-biome_rowan          = { workspace = true, optional = true }
-biome_service        = { workspace = true, features = ["schema"], optional = true }
-biome_string_case    = { workspace = true }
-biome_ungrammar      = { workspace = true }
-schemars             = { workspace = true, optional = true }
-serde_json           = { workspace = true, optional = true }
+biome_json_analyze    = { workspace = true, optional = true }
+biome_json_formatter  = { workspace = true, optional = true }
+biome_json_parser     = { workspace = true, optional = true }
+biome_json_syntax     = { workspace = true, optional = true }
+biome_rowan           = { workspace = true, optional = true }
+biome_service         = { workspace = true, features = ["schema"], optional = true }
+biome_string_case     = { workspace = true }
+biome_ungrammar       = { workspace = true }
+schemars              = { workspace = true, optional = true }
+serde_json            = { workspace = true, optional = true }
 
 [features]
 configuration = [
diff --git a/xtask/rules_check/src/lib.rs b/xtask/rules_check/src/lib.rs
index dcdbb18da5..5ef7979282 100644
--- a/xtask/rules_check/src/lib.rs
+++ b/xtask/rules_check/src/lib.rs
@@ -69,6 +69,15 @@ pub fn check_rules() -> anyhow::Result<()> {
             let group = R::Group::NAME;
             let rule_name = R::METADATA.name;
             let rule_severity = R::METADATA.severity;
+
+            if let Some(issue_number) = R::METADATA.issue_number
+                && group != "nursery"
+            {
+                self.errors.push(Errors::new(format!(
+                    "The rule '{rule_name}' has an issue number set to '{issue_number}'. The presence of an issue number indicates that the rule is not yet completed. Rules that have an issue number must belong to the 'nursery' group. Change the group of the rule to 'nursery' or remove the issue number."
+                )));
+            }
+
             if matches!(group, "a11y" | "correctness" | "security")
                 && rule_severity != Severity::Error
                 && !matches!(
