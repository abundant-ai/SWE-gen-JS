diff --git a/cSpell.json b/cSpell.json
index a8c28dc3e..08fce1d1c 100644
--- a/cSpell.json
+++ b/cSpell.json
@@ -66,6 +66,7 @@
     "sidharth",
     "sphinxcontrib",
     "statediagram",
+    "stylis",
     "substate",
     "sveidqvist",
     "techn",
diff --git a/docs/config/setup/modules/mermaidAPI.md b/docs/config/setup/modules/mermaidAPI.md
index 1ef1853ed..c4e512f3f 100644
--- a/docs/config/setup/modules/mermaidAPI.md
+++ b/docs/config/setup/modules/mermaidAPI.md
@@ -16,7 +16,7 @@ Renames and re-exports [mermaidAPI](mermaidAPI.md#mermaidapi)
 
 ### mermaidAPI
 
-• `Const` **mermaidAPI**: `Readonly`<{ `defaultConfig`: `MermaidConfig` = configApi.defaultConfig; `getConfig`: () => `MermaidConfig` = configApi.getConfig; `getSiteConfig`: () => `MermaidConfig` = configApi.getSiteConfig; `globalReset`: () => `void` ; `initialize`: (`options`: `MermaidConfig`) => `Promise`<`void`> ; `parse`: (`text`: `string`, `parseError?`: `ParseErrorFunction`) => `boolean` ; `parseDirective`: (`p`: `any`, `statement`: `string`, `context`: `string`, `type`: `string`) => `void` ; `render`: (`id`: `string`, `text`: `string`, `cb`: (`svgCode`: `string`, `bindFunctions?`: (`element`: `Element`) => `void`) => `void`, `container?`: `Element`) => `Promise`<`void`> ; `reset`: () => `void` ; `setConfig`: (`conf`: `MermaidConfig`) => `MermaidConfig` = configApi.setConfig; `updateSiteConfig`: (`conf`: `MermaidConfig`) => `MermaidConfig` = configApi.updateSiteConfig }>
+• `Const` **mermaidAPI**: `Readonly`<{ `defaultConfig`: `MermaidConfig` = configApi.defaultConfig; `getConfig`: () => `MermaidConfig` = configApi.getConfig; `getSiteConfig`: () => `MermaidConfig` = configApi.getSiteConfig; `globalReset`: () => `void` ; `initialize`: (`options`: `MermaidConfig`) => `Promise`<`void`> ; `parse`: (`text`: `string`, `parseError?`: `ParseErrorFunction`) => `boolean` ; `parseDirective`: (`p`: `any`, `statement`: `string`, `context`: `string`, `type`: `string`) => `void` ; `render`: (`id`: `string`, `text`: `string`, `cb`: (`svgCode`: `string`, `bindFunctions?`: (`element`: `Element`) => `void`) => `void`, `svgContainingElement?`: `Element`) => `Promise`<`void`> ; `reset`: () => `void` ; `setConfig`: (`conf`: `MermaidConfig`) => `MermaidConfig` = configApi.setConfig; `updateSiteConfig`: (`conf`: `MermaidConfig`) => `MermaidConfig` = configApi.updateSiteConfig }>
 
 ## mermaidAPI configuration defaults
 
@@ -80,19 +80,152 @@ mermaid.initialize(config);
 
 #### Defined in
 
-[mermaidAPI.ts:546](https://github.com/mermaid-js/mermaid/blob/master/packages/mermaid/src/mermaidAPI.ts#L546)
+[mermaidAPI.ts:740](https://github.com/mermaid-js/mermaid/blob/master/packages/mermaid/src/mermaidAPI.ts#L740)
 
 ## Functions
 
+### appendDivSvgG
+
+▸ **appendDivSvgG**(`parentRoot`, `id`, `enclosingDivId`, `divStyle?`, `svgXlink?`): `any`
+
+Append an enclosing div, then svg, then g (group) to the d3 parentRoot. Set attributes.
+Only set the style attribute on the enclosing div if divStyle is given.
+Only set the xmlns:xlink attribute on svg if svgXlink is given.
+Return the last node appended
+
+#### Parameters
+
+| Name             | Type     | Description                                      |
+| :--------------- | :------- | :----------------------------------------------- |
+| `parentRoot`     | `any`    | the d3 node to append things to                  |
+| `id`             | `string` | the value to set the id attr to                  |
+| `enclosingDivId` | `string` | the id to set the enclosing div to               |
+| `divStyle?`      | `string` | if given, the style to set the enclosing div to  |
+| `svgXlink?`      | `string` | if given, the link to set the new svg element to |
+
+#### Returns
+
+`any`
+
+- returns the parentRoot that had nodes appended
+
+#### Defined in
+
+[mermaidAPI.ts:283](https://github.com/mermaid-js/mermaid/blob/master/packages/mermaid/src/mermaidAPI.ts#L283)
+
+---
+
+### cleanUpSvgCode
+
+▸ **cleanUpSvgCode**(`svgCode?`, `inSandboxMode`, `useArrowMarkerUrls`): `string`
+
+Clean up svgCode. Do replacements needed
+
+#### Parameters
+
+| Name                 | Type      | Default value | Description                                                 |
+| :------------------- | :-------- | :------------ | :---------------------------------------------------------- |
+| `svgCode`            | `string`  | `''`          | the code to clean up                                        |
+| `inSandboxMode`      | `boolean` | `undefined`   | security level                                              |
+| `useArrowMarkerUrls` | `boolean` | `undefined`   | should arrow marker's use full urls? (vs. just the anchors) |
+
+#### Returns
+
+`string`
+
+the cleaned up svgCode
+
+#### Defined in
+
+[mermaidAPI.ts:234](https://github.com/mermaid-js/mermaid/blob/master/packages/mermaid/src/mermaidAPI.ts#L234)
+
+---
+
+### createCssStyles
+
+▸ **createCssStyles**(`config`, `graphType`, `classDefs?`): `string`
+
+Create the user styles
+
+#### Parameters
+
+| Name        | Type            | Description                                            |
+| :---------- | :-------------- | :----------------------------------------------------- | ------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------- |
+| `config`    | `MermaidConfig` | configuration that has style and theme settings to use |
+| `graphType` | `string`        | used for checking if classDefs should be applied       |
+| `classDefs` | `undefined`     | `null`                                                 | `Record`<`string`, `DiagramStyleClassDef`> | the classDefs in the diagram text. Might be null if none were defined. Usually is the result of a call to getClasses(...) |
+
+#### Returns
+
+`string`
+
+the string with all the user styles
+
+#### Defined in
+
+[mermaidAPI.ts:161](https://github.com/mermaid-js/mermaid/blob/master/packages/mermaid/src/mermaidAPI.ts#L161)
+
+---
+
+### createUserStyles
+
+▸ **createUserStyles**(`config`, `graphType`, `classDefs`, `svgId`): `string`
+
+#### Parameters
+
+| Name        | Type                                       |
+| :---------- | :----------------------------------------- |
+| `config`    | `MermaidConfig`                            |
+| `graphType` | `string`                                   |
+| `classDefs` | `Record`<`string`, `DiagramStyleClassDef`> |
+| `svgId`     | `string`                                   |
+
+#### Returns
+
+`string`
+
+#### Defined in
+
+[mermaidAPI.ts:211](https://github.com/mermaid-js/mermaid/blob/master/packages/mermaid/src/mermaidAPI.ts#L211)
+
+---
+
+### cssImportantStyles
+
+▸ **cssImportantStyles**(`cssClass`, `element`, `cssClasses?`): `string`
+
+Create a CSS style that starts with the given class name, then the element,
+with an enclosing block that has each of the cssClasses followed by !important;
+
+#### Parameters
+
+| Name         | Type        | Default value | Description                                    |
+| :----------- | :---------- | :------------ | :--------------------------------------------- |
+| `cssClass`   | `string`    | `undefined`   | CSS class name                                 |
+| `element`    | `string`    | `undefined`   | CSS element                                    |
+| `cssClasses` | `string`\[] | `[]`          | list of CSS styles to append after the element |
+
+#### Returns
+
+`string`
+
+- the constructed string
+
+#### Defined in
+
+[mermaidAPI.ts:145](https://github.com/mermaid-js/mermaid/blob/master/packages/mermaid/src/mermaidAPI.ts#L145)
+
+---
+
 ### decodeEntities
 
 ▸ **decodeEntities**(`text`): `string`
 
 #### Parameters
 
-| Name   | Type     |
-| :----- | :------- |
-| `text` | `string` |
+| Name   | Type     | Description        |
+| :----- | :------- | :----------------- |
+| `text` | `string` | text to be decoded |
 
 #### Returns
 
@@ -100,7 +233,7 @@ mermaid.initialize(config);
 
 #### Defined in
 
-[mermaidAPI.ts:72](https://github.com/mermaid-js/mermaid/blob/master/packages/mermaid/src/mermaidAPI.ts#L72)
+[mermaidAPI.ts:119](https://github.com/mermaid-js/mermaid/blob/master/packages/mermaid/src/mermaidAPI.ts#L119)
 
 ---
 
@@ -110,9 +243,9 @@ mermaid.initialize(config);
 
 #### Parameters
 
-| Name   | Type     |
-| :----- | :------- |
-| `text` | `string` |
+| Name   | Type     | Description        |
+| :----- | :------- | :----------------- |
+| `text` | `string` | text to be encoded |
 
 #### Returns
 
@@ -120,4 +253,56 @@ mermaid.initialize(config);
 
 #### Defined in
 
-[mermaidAPI.ts:46](https://github.com/mermaid-js/mermaid/blob/master/packages/mermaid/src/mermaidAPI.ts#L46)
+[mermaidAPI.ts:90](https://github.com/mermaid-js/mermaid/blob/master/packages/mermaid/src/mermaidAPI.ts#L90)
+
+---
+
+### putIntoIFrame
+
+▸ **putIntoIFrame**(`svgCode?`, `svgElement?`): `string`
+
+Put the svgCode into an iFrame. Return the iFrame code
+
+#### Parameters
+
+| Name          | Type     | Default value | Description                                                                  |
+| :------------ | :------- | :------------ | :--------------------------------------------------------------------------- |
+| `svgCode`     | `string` | `''`          | the svg code to put inside the iFrame                                        |
+| `svgElement?` | `any`    | `undefined`   | the d3 node that has the current svgElement so we can get the height from it |
+
+#### Returns
+
+`string`
+
+- the code with the iFrame that now contains the svgCode
+  TODO replace btoa(). Replace with buf.toString('base64')?
+
+#### Defined in
+
+[mermaidAPI.ts:262](https://github.com/mermaid-js/mermaid/blob/master/packages/mermaid/src/mermaidAPI.ts#L262)
+
+---
+
+### removeExistingElements
+
+▸ **removeExistingElements**(`doc`, `isSandboxed`, `id`, `divSelector`, `iFrameSelector`): `void`
+
+Remove any existing elements from the given document
+
+#### Parameters
+
+| Name             | Type       | Description                                     |
+| :--------------- | :--------- | :---------------------------------------------- |
+| `doc`            | `Document` | the document to removed elements from           |
+| `isSandboxed`    | `boolean`  | whether or not we are in sandboxed mode         |
+| `id`             | `string`   | id for any existing SVG element                 |
+| `divSelector`    | `string`   | selector for any existing enclosing div element |
+| `iFrameSelector` | `string`   | selector for any existing iFrame element        |
+
+#### Returns
+
+`void`
+
+#### Defined in
+
+[mermaidAPI.ts:334](https://github.com/mermaid-js/mermaid/blob/master/packages/mermaid/src/mermaidAPI.ts#L334)
diff --git a/packages/mermaid/src/diagrams/flowchart/flowDb.js b/packages/mermaid/src/diagrams/flowchart/flowDb.js
index e91ab2fef..6abc22659 100644
--- a/packages/mermaid/src/diagrams/flowchart/flowDb.js
+++ b/packages/mermaid/src/diagrams/flowchart/flowDb.js
@@ -17,7 +17,7 @@ let vertexCounter = 0;
 let config = configApi.getConfig();
 let vertices = {};
 let edges = [];
-let classes = [];
+let classes = {};
 let subGraphs = [];
 let subGraphLookup = {};
 let tooltips = {};
diff --git a/packages/mermaid/src/diagrams/flowchart/flowRenderer.js b/packages/mermaid/src/diagrams/flowchart/flowRenderer.js
index 0c3aa3623..c403b7fe3 100644
--- a/packages/mermaid/src/diagrams/flowchart/flowRenderer.js
+++ b/packages/mermaid/src/diagrams/flowchart/flowRenderer.js
@@ -279,7 +279,8 @@ export const getClasses = function (text, diagObj) {
     diagObj.parse(text);
     return diagObj.db.getClasses();
   } catch (e) {
-    return;
+    log.error(e);
+    return {};
   }
 };
 
diff --git a/packages/mermaid/src/mermaidAPI.ts b/packages/mermaid/src/mermaidAPI.ts
index 384b456f8..b921655ab 100644
--- a/packages/mermaid/src/mermaidAPI.ts
+++ b/packages/mermaid/src/mermaidAPI.ts
@@ -29,10 +29,49 @@ import utils, { directiveSanitizer } from './utils';
 import DOMPurify from 'dompurify';
 import { MermaidConfig } from './config.type';
 import { evaluate } from './diagrams/common/common';
+import { isEmpty } from 'lodash';
 
 // diagram names that support classDef statements
 const CLASSDEF_DIAGRAMS = ['graph', 'flowchart', 'flowchart-v2', 'stateDiagram'];
 
+const MAX_TEXTLENGTH_EXCEEDED_MSG =
+  'graph TB;a[Maximum text size in diagram exceeded];style a fill:#faa';
+
+const SECURITY_LVL_SANDBOX = 'sandbox';
+const SECURITY_LVL_LOOSE = 'loose';
+
+const XMLNS_SVG_STD = 'http://www.w3.org/2000/svg';
+const XMLNS_XLINK_STD = 'http://www.w3.org/1999/xlink';
+const XMLNS_XHTML_STD = 'http://www.w3.org/1999/xhtml';
+
+// ------------------------------
+// iFrame
+const IFRAME_WIDTH = '100%';
+const IFRAME_HEIGHT = '100%';
+const IFRAME_STYLES = 'border:0;margin:0;';
+const IFRAME_BODY_STYLE = 'margin:0';
+const IFRAME_SANDBOX_OPTS = 'allow-top-navigation-by-user-activation allow-popups';
+const IFRAME_NOT_SUPPORTED_MSG = 'The "iframe" tag is not supported by your browser.';
+
+// DOMPurify settings for svgCode
+const DOMPURE_TAGS = ['foreignobject'];
+const DOMPURE_ATTR = ['dominant-baseline'];
+
+// This is what is returned from getClasses(...) methods.
+// It is slightly renamed to ..StyleClassDef instead of just ClassDef because "class" is a greatly ambiguous and overloaded word.
+// It makes it clear we're working with a style class definition, even though defining the type is currently difficult.
+interface DiagramStyleClassDef {
+  id: string;
+  styles?: string[];
+  textStyles?: string[];
+}
+
+// This makes it clear that we're working with a d3 selected element of some kind, even though it's hard to specify the exact type.
+// @ts-ignore Could replicate the type definition in d3. This also makes it possible to use the untyped info from the js diagram files.
+type D3Element = any;
+
+// ----------------------------------------------------------------------------
+
 /**
  * @param text - The mermaid diagram definition.
  * @param parseError - If set, handles errors.
@@ -43,16 +82,19 @@ function parse(text: string, parseError?: ParseErrorFunction): boolean {
   return diagram.parse(text, parseError);
 }
 
+/**
+ *
+ * @param  text - text to be encoded
+ * @returns
+ */
 export const encodeEntities = function (text: string): string {
   let txt = text;
 
-  txt = txt.replace(/style.*:\S*#.*;/g, function (s) {
-    const innerTxt = s.substring(0, s.length - 1);
-    return innerTxt;
+  txt = txt.replace(/style.*:\S*#.*;/g, function (s): string {
+    return s.substring(0, s.length - 1);
   });
-  txt = txt.replace(/classDef.*:\S*#.*;/g, function (s) {
-    const innerTxt = s.substring(0, s.length - 1);
-    return innerTxt;
+  txt = txt.replace(/classDef.*:\S*#.*;/g, function (s): string {
+    return s.substring(0, s.length - 1);
   });
 
   txt = txt.replace(/#\w+;/g, function (s) {
@@ -69,6 +111,11 @@ export const encodeEntities = function (text: string): string {
   return txt;
 };
 
+/**
+ *
+ * @param  text - text to be decoded
+ * @returns
+ */
 export const decodeEntities = function (text: string): string {
   let txt = text;
 
@@ -84,6 +131,226 @@ export const decodeEntities = function (text: string): string {
 
   return txt;
 };
+
+// append !important; to each cssClass followed by a final !important, all enclosed in { }
+//
+/**
+ * Create a CSS style that starts with the given class name, then the element,
+ * with an enclosing block that has each of the cssClasses followed by !important;
+ * @param cssClass - CSS class name
+ * @param element - CSS element
+ * @param cssClasses - list of CSS styles to append after the element
+ * @returns - the constructed string
+ */
+export const cssImportantStyles = (
+  cssClass: string,
+  element: string,
+  cssClasses: string[] = []
+): string => {
+  return `\n.${cssClass} ${element} { ${cssClasses.join(' !important; ')} !important; }`;
+};
+
+/**
+ * Create the user styles
+ *
+ * @param  config - configuration that has style and theme settings to use
+ * @param graphType - used for checking if classDefs should be applied
+ * @param  classDefs - the classDefs in the diagram text. Might be null if none were defined. Usually is the result of a call to getClasses(...)
+ * @returns  the string with all the user styles
+ */
+export const createCssStyles = (
+  config: MermaidConfig,
+  graphType: string,
+  classDefs: Record<string, DiagramStyleClassDef> | null | undefined = {}
+): string => {
+  let cssStyles = '';
+
+  // user provided theme CSS info
+  // If you add more configuration driven data into the user styles make sure that the value is
+  // sanitized by the sanitize CSS function TODO where is this method?  what should be used to replace it?  refactor so that it's always sanitized
+  if (config.themeCSS !== undefined) {
+    cssStyles += `\n${config.themeCSS}`;
+  }
+
+  if (config.fontFamily !== undefined) {
+    cssStyles += `\n:root { --mermaid-font-family: ${config.fontFamily}}`;
+  }
+  if (config.altFontFamily !== undefined) {
+    cssStyles += `\n:root { --mermaid-alt-font-family: ${config.altFontFamily}}`;
+  }
+
+  // classDefs defined in the diagram text
+  if (!isEmpty(classDefs)) {
+    if (CLASSDEF_DIAGRAMS.includes(graphType)) {
+      const htmlLabels = config.htmlLabels || config.flowchart?.htmlLabels; // TODO why specifically check the Flowchart diagram config?
+
+      const cssHtmlElements = ['> *', 'span']; // TODO make a constant
+      const cssShapeElements = ['rect', 'polygon', 'ellipse', 'circle']; // TODO make a constant
+
+      const cssElements = htmlLabels ? cssHtmlElements : cssShapeElements;
+
+      // create the CSS styles needed for each styleClass definition and css element
+      for (const classId in classDefs) {
+        const styleClassDef = classDefs[classId];
+        // create the css styles for each cssElement and the styles (only if there are styles)
+        if (!isEmpty(styleClassDef.styles)) {
+          cssElements.forEach((cssElement) => {
+            cssStyles += cssImportantStyles(styleClassDef.id, cssElement, styleClassDef.styles);
+          });
+        }
+        // create the css styles for the tspan element and the text styles (only if there are textStyles)
+        if (!isEmpty(styleClassDef.textStyles)) {
+          cssStyles += cssImportantStyles(styleClassDef.id, 'tspan', styleClassDef.textStyles);
+        }
+      }
+    }
+  }
+  return cssStyles;
+};
+
+export const createUserStyles = (
+  config: MermaidConfig,
+  graphType: string,
+  classDefs: Record<string, DiagramStyleClassDef>,
+  svgId: string
+): string => {
+  const userCSSstyles = createCssStyles(config, graphType, classDefs);
+  const allStyles = getStyles(graphType, userCSSstyles, config.themeVariables);
+
+  // Now turn all of the styles into a (compiled) string that starts with the id
+  // use the stylis library to compile the css, turn the results into a valid CSS string (serialize(...., stringify))
+  // @see https://github.com/thysultan/stylis
+  return serialize(compile(`${svgId}{${allStyles}}`), stringify);
+};
+
+/**
+ * Clean up svgCode. Do replacements needed
+ *
+ * @param svgCode - the code to clean up
+ * @param inSandboxMode - security level
+ * @param useArrowMarkerUrls - should arrow marker's use full urls? (vs. just the anchors)
+ * @returns the cleaned up svgCode
+ */
+export const cleanUpSvgCode = (
+  svgCode = '',
+  inSandboxMode: boolean,
+  useArrowMarkerUrls: boolean
+): string => {
+  let cleanedUpSvg = svgCode;
+
+  // Replace marker-end urls with just the # anchor (remove the preceding part of the URL)
+  if (!useArrowMarkerUrls && !inSandboxMode) {
+    cleanedUpSvg = cleanedUpSvg.replace(/marker-end="url\(.*?#/g, 'marker-end="url(#');
+  }
+
+  cleanedUpSvg = decodeEntities(cleanedUpSvg);
+
+  // replace old br tags with newer style
+  cleanedUpSvg = cleanedUpSvg.replace(/<br>/g, '<br/>');
+
+  return cleanedUpSvg;
+};
+
+/**
+ * Put the svgCode into an iFrame. Return the iFrame code
+ *
+ * @param svgCode - the svg code to put inside the iFrame
+ * @param svgElement - the d3 node that has the current svgElement so we can get the height from it
+ * @returns  - the code with the iFrame that now contains the svgCode
+ * TODO replace btoa(). Replace with  buf.toString('base64')?
+ */
+export const putIntoIFrame = (svgCode = '', svgElement?: D3Element): string => {
+  const height = svgElement ? svgElement.viewBox.baseVal.height + 'px' : IFRAME_HEIGHT;
+  const base64encodedSrc = btoa('<body style="' + IFRAME_BODY_STYLE + '">' + svgCode + '</body>');
+  return `<iframe style="width:${IFRAME_WIDTH};height:${height};${IFRAME_STYLES}" src="data:text/html;base64,${base64encodedSrc}" sandbox="${IFRAME_SANDBOX_OPTS}">
+  ${IFRAME_NOT_SUPPORTED_MSG}
+</iframe>`;
+};
+
+/**
+ * Append an enclosing div, then svg, then g (group) to the d3 parentRoot. Set attributes.
+ * Only set the style attribute on the enclosing div if divStyle is given.
+ * Only set the xmlns:xlink attribute on svg if svgXlink is given.
+ * Return the last node appended
+ *
+ * @param parentRoot - the d3 node to append things to
+ * @param id - the value to set the id attr to
+ * @param enclosingDivId - the id to set the enclosing div to
+ * @param divStyle - if given, the style to set the enclosing div to
+ * @param svgXlink - if given, the link to set the new svg element to
+ * @returns - returns the parentRoot that had nodes appended
+ */
+export const appendDivSvgG = (
+  parentRoot: D3Element,
+  id: string,
+  enclosingDivId: string,
+  divStyle?: string,
+  svgXlink?: string
+): D3Element => {
+  const enclosingDiv = parentRoot.append('div');
+  enclosingDiv.attr('id', enclosingDivId);
+  if (divStyle) {
+    enclosingDiv.attr('style', divStyle);
+  }
+
+  const svgNode = enclosingDiv
+    .append('svg')
+    .attr('id', id)
+    .attr('width', '100%')
+    .attr('xmlns', XMLNS_SVG_STD);
+  if (svgXlink) {
+    svgNode.attr('xmlns:xlink', svgXlink);
+  }
+
+  svgNode.append('g');
+  return parentRoot;
+};
+
+/**
+ * Append an iFrame node to the given parentNode and set the id, style, and 'sandbox' attributes
+ *  Return the appended iframe d3 node
+ *
+ * @param parentNode - the d3 node to append the iFrame node to
+ * @param iFrameId - id to use for the iFrame
+ * @returns the appended iframe d3 node
+ */
+function sandboxedIframe(parentNode: D3Element, iFrameId: string): D3Element {
+  return parentNode
+    .append('iframe')
+    .attr('id', iFrameId)
+    .attr('style', 'width: 100%; height: 100%;')
+    .attr('sandbox', '');
+}
+
+/**
+ * Remove any existing elements from the given document
+ *
+ * @param doc - the document to removed elements from
+ * @param isSandboxed - whether or not we are in sandboxed mode
+ * @param id - id for any existing SVG element
+ * @param divSelector - selector for any existing enclosing div element
+ * @param iFrameSelector - selector for any existing iFrame element
+ */
+export const removeExistingElements = (
+  doc: Document,
+  isSandboxed: boolean,
+  id: string,
+  divSelector: string,
+  iFrameSelector: string
+) => {
+  // Remove existing SVG element if it exists
+  const existingSvg = doc.getElementById(id);
+  if (existingSvg) {
+    existingSvg.remove();
+  }
+
+  // Remove previous temporary element if it exists
+  const element = isSandboxed ? doc.querySelector(iFrameSelector) : doc.querySelector(divSelector);
+  if (element) {
+    element.remove();
+  }
+};
+
 /**
  * Function that renders an svg with a graph from a chart definition. Usage example below.
  *
@@ -100,10 +367,12 @@ export const decodeEntities = function (text: string): string {
  * });
  * ```
  *
- * @param id - The id of the element to be rendered
- * @param text - The graph definition
- * @param cb - Callback which is called after rendering is finished with the svg code as param.
- * @param container - Selector to element in which a div with the graph temporarily will be
+ * @param id - The id for the SVG element (the element to be rendered)
+ * @param text - The text for the graph definition
+ * @param cb - Callback which is called after rendering is finished with the svg code as in param.
+ * @param svgContainingElement - HTML element where the svg will be inserted. (Is usually element with the .mermaid class)
+ *   If no svgContainingElement is provided then the SVG element will be appended to the body.
+ *    Selector to element in which a div with the graph temporarily will be
  *   inserted. If one is provided a hidden div will be inserted in the body of the page instead. The
  *   element will be removed when rendering is completed.
  * @returns - Resolves when finished rendering.
@@ -112,115 +381,92 @@ const render = async function (
   id: string,
   text: string,
   cb: (svgCode: string, bindFunctions?: (element: Element) => void) => void,
-  container?: Element
+  svgContainingElement?: Element
 ): Promise<void> {
   addDiagrams();
+
   configApi.reset();
-  text = text.replace(/\r\n?/g, '\n'); // parser problems on CRLF ignore all CR and leave LF;;
+
+  // Add Directives. Must do this before getting the config and before creating the diagram.
   const graphInit = utils.detectInit(text);
   if (graphInit) {
     directiveSanitizer(graphInit);
     configApi.addDirective(graphInit);
   }
-  const cnf = configApi.getConfig();
 
-  log.debug(cnf);
+  const config = configApi.getConfig();
+  log.debug(config);
 
   // Check the maximum allowed text size
-  if (text.length > cnf.maxTextSize!) {
-    text = 'graph TB;a[Maximum text size in diagram exceeded];style a fill:#faa';
+  // TODO: Remove magic number
+  if (text.length > (config?.maxTextSize ?? 50000)) {
+    text = MAX_TEXTLENGTH_EXCEEDED_MSG;
   }
 
+  // clean up text CRLFs
+  text = text.replace(/\r\n?/g, '\n'); // parser problems on CRLF ignore all CR and leave LF;;
+
+  const idSelector = '#' + id;
+  const iFrameID = 'i' + id;
+  const iFrameID_selector = '#' + iFrameID;
+  const enclosingDivID = 'd' + id;
+  const enclosingDivID_selector = '#' + enclosingDivID;
+
   let root: any = select('body');
 
-  // In regular execution the container will be the div with a mermaid class
-  if (typeof container !== 'undefined') {
-    // A container was provided by the caller
-    if (container) {
-      container.innerHTML = '';
+  const isSandboxed = config.securityLevel === SECURITY_LVL_SANDBOX;
+  const isLooseSecurityLevel = config.securityLevel === SECURITY_LVL_LOOSE;
+
+  const fontFamily = config.fontFamily;
+
+  // -------------------------------------------------------------------------------
+  // Define the root d3 node
+  // In regular execution the svgContainingElement will be the element with a mermaid class
+
+  if (typeof svgContainingElement !== 'undefined') {
+    if (svgContainingElement) {
+      svgContainingElement.innerHTML = '';
     }
 
-    if (cnf.securityLevel === 'sandbox') {
-      // IF we are in sandboxed mode, we do everything mermaid related
-      // in a sandboxed div
-      const iframe = select(container)
-        .append('iframe')
-        .attr('id', 'i' + id)
-        .attr('style', 'width: 100%; height: 100%;')
-        .attr('sandbox', '');
-      // const iframeBody = ;
+    if (isSandboxed) {
+      // If we are in sandboxed mode, we do everything mermaid related in a (sandboxed )iFrame
+      const iframe = sandboxedIframe(select(svgContainingElement), iFrameID);
       root = select(iframe.nodes()[0]!.contentDocument!.body);
       root.node().style.margin = 0;
     } else {
-      root = select(container);
+      root = select(svgContainingElement);
     }
-
-    root
-      .append('div')
-      .attr('id', 'd' + id)
-      .attr('style', 'font-family: ' + cnf.fontFamily)
-      .append('svg')
-      .attr('id', id)
-      .attr('width', '100%')
-      .attr('xmlns', 'http://www.w3.org/2000/svg')
-      .attr('xmlns:xlink', 'http://www.w3.org/1999/xlink')
-      .append('g');
+    appendDivSvgG(root, id, enclosingDivID, `font-family: ${fontFamily}`, XMLNS_XLINK_STD);
   } else {
-    // No container was provided
-    // If there is an existing element with the id, we remove it
-    // this likely a previously rendered diagram
-    const existingSvg = document.getElementById(id);
-    if (existingSvg) {
-      existingSvg.remove();
-    }
-
-    // Remove previous tpm element if it exists
-    let element;
-    if (cnf.securityLevel === 'sandbox') {
-      element = document.querySelector('#i' + id);
-    } else {
-      element = document.querySelector('#d' + id);
-    }
-
-    if (element) {
-      element.remove();
-    }
+    // No svgContainingElement was provided
 
-    // Add the tmp div used for rendering with the id `d${id}`
-    // d+id it will contain a svg with the id "id"
+    // If there is an existing element with the id, we remove it. This likely a previously rendered diagram
+    removeExistingElements(document, isSandboxed, id, iFrameID_selector, enclosingDivID_selector);
 
-    if (cnf.securityLevel === 'sandbox') {
-      // IF we are in sandboxed mode, we do everything mermaid related
-      // in a sandboxed div
-      const iframe = select('body')
-        .append('iframe')
-        .attr('id', 'i' + id)
-        .attr('style', 'width: 100%; height: 100%;')
-        .attr('sandbox', '');
+    // Add the temporary div used for rendering with the enclosingDivID.
+    // This temporary div will contain a svg with the id == id
 
+    if (isSandboxed) {
+      // If we are in sandboxed mode, we do everything mermaid related in a (sandboxed) iFrame
+      const iframe = sandboxedIframe(select('body'), iFrameID);
       root = select(iframe.nodes()[0]!.contentDocument!.body);
       root.node().style.margin = 0;
     } else {
       root = select('body');
     }
 
-    // This is the temporary div
-    root
-      .append('div')
-      .attr('id', 'd' + id)
-      // this is the seed of the svg to be rendered
-      .append('svg')
-      .attr('id', id)
-      .attr('width', '100%')
-      .attr('xmlns', 'http://www.w3.org/2000/svg')
-      .append('g');
+    appendDivSvgG(root, id, enclosingDivID);
   }
 
   text = encodeEntities(text);
 
+  // -------------------------------------------------------------------------------
+  // Create the diagram
+
   // Important that we do not create the diagram until after the directives have been included
   let diag;
   let parseEncounteredException;
+
   try {
     // diag = new Diagram(text);
     diag = await getDiagramFromText(text);
@@ -228,75 +474,35 @@ const render = async function (
     diag = new Diagram('error');
     parseEncounteredException = error;
   }
-  // Get the tmp element containing the the svg
-  const element = root.select('#d' + id).node();
+
+  // Get the temporary div element containing the svg
+  const element = root.select(enclosingDivID_selector).node();
   const graphType = diag.type;
 
-  // insert inline style into svg
+  // -------------------------------------------------------------------------------
+  // Create and insert the styles (user styles, theme styles, config styles)
+
+  // Insert an element into svg. This is where we put the styles
   const svg = element.firstChild;
   const firstChild = svg.firstChild;
-
-  let userStyles = '';
-  // user provided theme CSS
-  // If you add more configuration driven data into the user styles make sure that the value is
-  // sanitized bye the sanitizeCSS function
-  if (cnf.themeCSS !== undefined) {
-    userStyles += `\n${cnf.themeCSS}`;
-  }
-  // user provided theme CSS
-  if (cnf.fontFamily !== undefined) {
-    userStyles += `\n:root { --mermaid-font-family: ${cnf.fontFamily}}`;
-  }
-  // user provided theme CSS
-  if (cnf.altFontFamily !== undefined) {
-    userStyles += `\n:root { --mermaid-alt-font-family: ${cnf.altFontFamily}}`;
-  }
-
-  // classDef
-  if (CLASSDEF_DIAGRAMS.includes(graphType)) {
-    const classes: any = diag.renderer.getClasses(text, diag);
-    const htmlLabels = cnf.htmlLabels || cnf.flowchart?.htmlLabels;
-    for (const className in classes) {
-      if (htmlLabels) {
-        userStyles += `\n.${className} > * { ${classes[className].styles.join(
-          ' !important; '
-        )} !important; }`;
-        userStyles += `\n.${className} span { ${classes[className].styles.join(
-          ' !important; '
-        )} !important; }`;
-      } else {
-        userStyles += `\n.${className} path { ${classes[className].styles.join(
-          ' !important; '
-        )} !important; }`;
-        userStyles += `\n.${className} rect { ${classes[className].styles.join(
-          ' !important; '
-        )} !important; }`;
-        userStyles += `\n.${className} polygon { ${classes[className].styles.join(
-          ' !important; '
-        )} !important; }`;
-        userStyles += `\n.${className} ellipse { ${classes[className].styles.join(
-          ' !important; '
-        )} !important; }`;
-        userStyles += `\n.${className} circle { ${classes[className].styles.join(
-          ' !important; '
-        )} !important; }`;
-        if (classes[className].textStyles) {
-          userStyles += `\n.${className} tspan { ${classes[className].textStyles.join(
-            ' !important; '
-          )} !important; }`;
-        }
-      }
-    }
-  }
-
-  const stylis = (selector: string, styles: string) =>
-    serialize(compile(`${selector}{${styles}}`), stringify);
-  const rules = stylis(`#${id}`, getStyles(graphType, userStyles, cnf.themeVariables));
+  const diagramClassDefs = CLASSDEF_DIAGRAMS.includes(graphType)
+    ? diag.renderer.getClasses(text, diag)
+    : {};
+
+  const rules = createUserStyles(
+    config,
+    graphType,
+    // @ts-ignore convert renderer to TS.
+    diagramClassDefs,
+    idSelector
+  );
 
   const style1 = document.createElement('style');
-  style1.innerHTML = `#${id} ` + rules;
+  style1.innerHTML = `${idSelector} ` + rules;
   svg.insertBefore(style1, firstChild);
 
+  // -------------------------------------------------------------------------------
+  // Draw the diagram with the renderer
   try {
     await diag.renderer.draw(text, id, pkg.version, diag);
   } catch (e) {
@@ -304,45 +510,29 @@ const render = async function (
     throw e;
   }
 
-  root
-    .select(`[id="${id}"]`)
-    .selectAll('foreignobject > *')
-    .attr('xmlns', 'http://www.w3.org/1999/xhtml');
+  // -------------------------------------------------------------------------------
+  // Clean up SVG code
+  root.select(`[id="${id}"]`).selectAll('foreignobject > *').attr('xmlns', XMLNS_XHTML_STD);
 
   // Fix for when the base tag is used
-  let svgCode = root.select('#d' + id).node().innerHTML;
-
-  log.debug('cnf.arrowMarkerAbsolute', cnf.arrowMarkerAbsolute);
-  if (!evaluate(cnf.arrowMarkerAbsolute) && cnf.securityLevel !== 'sandbox') {
-    svgCode = svgCode.replace(/marker-end="url\(.*?#/g, 'marker-end="url(#', 'g');
-  }
-
-  svgCode = decodeEntities(svgCode);
-
-  // Fix for when the br tag is used
-  svgCode = svgCode.replace(/<br>/g, '<br/>');
-
-  if (cnf.securityLevel === 'sandbox') {
-    const svgEl = root.select('#d' + id + ' svg').node();
-    const width = '100%';
-    let height = '100%';
-    if (svgEl) {
-      height = svgEl.viewBox.baseVal.height + 'px';
-    }
-    svgCode = `<iframe style="width:${width};height:${height};border:0;margin:0;" src="data:text/html;base64,${btoa(
-      '<body style="margin:0">' + svgCode + '</body>'
-    )}" sandbox="allow-top-navigation-by-user-activation allow-popups">
-  The “iframe” tag is not supported by your browser.
-</iframe>`;
-  } else {
-    if (cnf.securityLevel !== 'loose') {
-      svgCode = DOMPurify.sanitize(svgCode, {
-        ADD_TAGS: ['foreignobject'],
-        ADD_ATTR: ['dominant-baseline'],
-      });
-    }
+  let svgCode = root.select(enclosingDivID_selector).node().innerHTML;
+
+  log.debug('config.arrowMarkerAbsolute', config.arrowMarkerAbsolute);
+  svgCode = cleanUpSvgCode(svgCode, isSandboxed, evaluate(config.arrowMarkerAbsolute));
+
+  if (isSandboxed) {
+    const svgEl = root.select(enclosingDivID_selector + ' svg').node();
+    svgCode = putIntoIFrame(svgCode, svgEl);
+  } else if (isLooseSecurityLevel) {
+    // Sanitize the svgCode using DOMPurify
+    svgCode = DOMPurify.sanitize(svgCode, {
+      ADD_TAGS: DOMPURE_TAGS,
+      ADD_ATTR: DOMPURE_ATTR,
+    });
   }
 
+  // -------------------------------------------------------------------------------
+  // Do any callbacks (cb = callback)
   if (typeof cb !== 'undefined') {
     switch (graphType) {
       case 'flowchart':
@@ -364,7 +554,9 @@ const render = async function (
   }
   attachFunctions();
 
-  const tmpElementSelector = cnf.securityLevel === 'sandbox' ? '#i' + id : '#d' + id;
+  // -------------------------------------------------------------------------------
+  // Remove the temporary element if appropriate
+  const tmpElementSelector = isSandboxed ? iFrameID_selector : enclosingDivID_selector;
   const node = select(tmpElementSelector).node();
   if (node && 'remove' in node) {
     node.remove();
@@ -454,7 +646,9 @@ const handleDirective = function (p: any, directive: any, type: string): void {
   }
 };
 
-/** @param options - Initial Mermaid options */
+/**
+ * @param  options - Initial Mermaid options
+ * */
 async function initialize(options: MermaidConfig) {
   // Handle legacy location of font-family configuration
   if (options?.fontFamily) {
diff --git a/packages/mermaid/typedoc.json b/packages/mermaid/typedoc.json
index 0e3b12b91..971f6d562 100644
--- a/packages/mermaid/typedoc.json
+++ b/packages/mermaid/typedoc.json
@@ -2,7 +2,7 @@
   "plugin": ["typedoc-plugin-markdown"],
   "readme": "none",
   "githubPages": false,
-  "gitRemote": "origin",
+  "sourceLinkTemplate": "https://github.com/mermaid-js/mermaid/blob/{gitRevision}/{path}#L{line}",
   "gitRevision": "master",
   "out": "src/docs/config/setup",
   "entryPointStrategy": "expand",
