diff --git a/src/classes/worker.ts b/src/classes/worker.ts
index a8ee43202e..7d078e9b1d 100644
--- a/src/classes/worker.ts
+++ b/src/classes/worker.ts
@@ -683,7 +683,7 @@ export class Worker<
             // since we're not waiting for the job to end attach
             // an error handler to avoid crashing the whole process
             closePoolPromise?.catch(err => {
-              console.error(err); // TODO: emit error in next breaking change version
+              console.error(err);
             });
             return;
           }
diff --git a/src/commands/includes/removeJobsByMaxAge.lua b/src/commands/includes/removeJobsByMaxAge.lua
deleted file mode 100644
index 2acd93b11c..0000000000
--- a/src/commands/includes/removeJobsByMaxAge.lua
+++ /dev/null
@@ -1,15 +0,0 @@
---[[
-  Functions to remove jobs by max age.
-]]
-
--- Includes
---- @include "removeJob"
-
-local function removeJobsByMaxAge(timestamp, maxAge, targetSet, prefix)
-  local start = timestamp - maxAge * 1000
-  local jobIds = rcall("ZREVRANGEBYSCORE", targetSet, start, "-inf")
-  for i, jobId in ipairs(jobIds) do
-    removeJob(jobId, false, prefix)
-  end
-  rcall("ZREMRANGEBYSCORE", targetSet, "-inf", start)
-end
diff --git a/src/commands/includes/removeJobsByMaxCount.lua b/src/commands/includes/removeJobsByMaxCount.lua
deleted file mode 100644
index ae1d256326..0000000000
--- a/src/commands/includes/removeJobsByMaxCount.lua
+++ /dev/null
@@ -1,15 +0,0 @@
---[[
-  Functions to remove jobs by max count.
-]]
-
--- Includes
---- @include "removeJob"
-
-local function removeJobsByMaxCount(timestamp, maxCount, targetSet, prefix)
-  local start = maxCount
-  local jobIds = rcall("ZREVRANGE", targetSet, start, -1)
-  for i, jobId in ipairs(jobIds) do
-    removeJob(jobId, false, prefix)
-  end
-  rcall("ZREMRANGEBYRANK", targetSet, 0, -(maxCount + 1))
-end
diff --git a/src/commands/moveStalledJobsToWait-8.lua b/src/commands/moveStalledJobsToWait-8.lua
index 78bf7ed5d2..b0d67117c4 100644
--- a/src/commands/moveStalledJobsToWait-8.lua
+++ b/src/commands/moveStalledJobsToWait-8.lua
@@ -25,9 +25,6 @@ local rcall = redis.call
 
 -- Includes
 --- @include "includes/batches"
---- @include "includes/removeJob"
---- @include "includes/removeJobsByMaxAge"
---- @include "includes/removeJobsByMaxCount"
 --- @include "includes/trimEvents"
 
 -- Check if we need to check for stalled jobs now.
@@ -70,38 +67,14 @@ if (#stalling > 0) then
                 local stalledCount = rcall("HINCRBY", jobKey, "stalledCounter",
                                            1)
                 if (stalledCount > MAX_STALLED_JOB_COUNT) then
-                  local rawOpts = rcall("HGET",jobKey, "opts")
-                  local opts = cjson.decode(rawOpts)
-                  local removeOnFailType = type(opts["removeOnFail"])
-                  rcall("ZADD", KEYS[4], ARGV[3], jobId)
-                  local failedReason = "job stalled more than allowable limit" 
-                  rcall("HMSET", jobKey, "failedReason",
-                        failedReason, "finishedOn", ARGV[3])
-                  rcall("XADD", KEYS[8], "*", "event", "failed", "jobId",
-                        jobId, 'prev', 'active', 'failedReason',
-                        failedReason)
-
-                  if removeOnFailType == "number" then
-                    removeJobsByMaxCount(ARGV[3], opts["removeOnFail"], KEYS[4], ARGV[2])
-                  elseif removeOnFailType == "boolean" then
-                    if opts["removeOnFail"] then
-                      removeJob(jobId, false, ARGV[2])
-                      rcall("ZREM", KEYS[4], jobId)
-                    end                  
-                  elseif removeOnFailType ~= "nil" then
-                    local maxAge = opts["removeOnFail"]["age"]
-                    local maxCount = opts["removeOnFail"]["count"]
-
-                    if maxAge ~= nil then
-                      removeJobsByMaxAge(ARGV[3], maxAge, KEYS[4], ARGV[2])
-                    end
-            
-                    if maxCount ~= nil and maxCount > 0 then
-                      removeJobsByMaxCount(ARGV[3], maxCount, KEYS[4], ARGV[2])
-                    end
-                  end
-
-                  table.insert(failed, jobId)                    
+                    local failedReason = "job stalled more than allowable limit" 
+                    rcall("ZADD", KEYS[4], ARGV[3], jobId)
+                    rcall("HMSET", jobKey, "failedReason",
+                          failedReason, "finishedOn", ARGV[3])
+                    rcall("XADD", KEYS[8], "*", "event", "failed", "jobId",
+                          jobId, 'prev', 'active', 'failedReason',
+                          failedReason)
+                    table.insert(failed, jobId)
                 else
                     -- Move the job back to the wait queue, to immediately be picked up by a waiting worker.
                     rcall("RPUSH", dst, jobId)
diff --git a/src/commands/moveToFinished-12.lua b/src/commands/moveToFinished-12.lua
index 826f2cd3c0..96bf4a454a 100644
--- a/src/commands/moveToFinished-12.lua
+++ b/src/commands/moveToFinished-12.lua
@@ -57,8 +57,7 @@ local rcall = redis.call
 --- Includes
 --- @include "includes/destructureJobKey"
 --- @include "includes/moveJobFromWaitToActive"
---- @include "includes/removeJobsByMaxAge"
---- @include "includes/removeJobsByMaxCount"
+--- @include "includes/removeJob"
 --- @include "includes/trimEvents"
 --- @include "includes/updateParentDepsIfNeeded"
 --- @include "includes/collectMetrics"
@@ -133,11 +132,21 @@ if rcall("EXISTS", jobIdKey) == 1 then -- // Make sure job exists
         local prefix = ARGV[8]
 
         if maxAge ~= nil then
-            removeJobsByMaxAge(timestamp, maxAge, targetSet, prefix)
+            local start = timestamp - maxAge * 1000
+            local jobIds = rcall("ZREVRANGEBYSCORE", targetSet, start, "-inf")
+            for i, jobId in ipairs(jobIds) do
+                removeJob(jobId, false, prefix)
+            end
+            rcall("ZREMRANGEBYSCORE", targetSet, "-inf", start)
         end
 
         if maxCount ~= nil and maxCount > 0 then
-            removeJobsByMaxCount(timestamp, maxCount, targetSet, prefix)
+            local start = maxCount
+            local jobIds = rcall("ZREVRANGE", targetSet, start, -1)
+            for i, jobId in ipairs(jobIds) do
+                removeJob(jobId, false, prefix)
+            end
+            rcall("ZREMRANGEBYRANK", targetSet, 0, -(maxCount + 1))
         end
     else
         rcall("DEL", jobIdKey, jobIdKey .. ':logs', jobIdKey .. ':processed')
diff --git a/tests/test_stalled_jobs.ts b/tests/test_stalled_jobs.ts
index 2ca71adf31..3c495cc79e 100644
--- a/tests/test_stalled_jobs.ts
+++ b/tests/test_stalled_jobs.ts
@@ -169,286 +169,6 @@ describe('stalled jobs', function () {
     await queueScheduler.close();
   });
 
-  describe('when stalled jobs stall more than allowable stalled limit', function () {
-    it('moves jobs to failed', async function () {
-      this.timeout(6000);
-
-      const queueEvents = new QueueEvents(queueName, { connection });
-      await queueEvents.waitUntilReady();
-
-      const concurrency = 4;
-
-      const worker = new Worker(
-        queueName,
-        async () => {
-          return delay(10000);
-        },
-        {
-          connection,
-          lockDuration: 1000,
-          concurrency,
-        },
-      );
-
-      const allActive = new Promise(resolve => {
-        worker.on('active', after(concurrency, resolve));
-      });
-
-      await worker.waitUntilReady();
-
-      await Promise.all([
-        queue.add('test', { bar: 'baz' }, { removeOnFail: true }),
-        queue.add('test', { bar1: 'baz1' }, { removeOnFail: true }),
-        queue.add('test', { bar2: 'baz2' }, { removeOnFail: true }),
-        queue.add('test', { bar3: 'baz3' }, { removeOnFail: true }),
-      ]);
-
-      await allActive;
-
-      const queueScheduler = new QueueScheduler(queueName, {
-        connection,
-        stalledInterval: 100,
-        maxStalledCount: 0,
-      });
-      await queueScheduler.waitUntilReady();
-
-      await worker.close(true);
-
-      const errorMessage = 'job stalled more than allowable limit';
-      const allFailed = new Promise<void>(resolve => {
-        queueScheduler.on(
-          'failed',
-          after(concurrency, async (jobId, failedReason, prev) => {
-            const job = await queue.getJob(jobId);
-            expect(job).to.be.undefined;
-            expect(prev).to.be.equal('active');
-            expect(failedReason.message).to.be.equal(errorMessage);
-            resolve();
-          }),
-        );
-      });
-
-      const globalAllFailed = new Promise<void>(resolve => {
-        queueEvents.on('failed', ({ failedReason }) => {
-          expect(failedReason).to.be.equal(errorMessage);
-          resolve();
-        });
-      });
-
-      await allFailed;
-      await globalAllFailed;
-
-      await queueEvents.close();
-      await queueScheduler.close();
-    });
-
-    describe('when removeOnFail is provided as a number', function () {
-      it('keeps the specified number of jobs in failed', async function () {
-        this.timeout(6000);
-        const concurrency = 4;
-
-        const worker = new Worker(
-          queueName,
-          async () => {
-            return delay(10000);
-          },
-          {
-            connection,
-            lockDuration: 1000,
-            concurrency,
-          },
-        );
-
-        const allActive = new Promise(resolve => {
-          worker.on('active', after(concurrency, resolve));
-        });
-
-        await worker.waitUntilReady();
-
-        const jobs = Array.from(Array(4).keys()).map(index => ({
-          name: 'test',
-          data: { index },
-          opts: {
-            removeOnFail: 3,
-          },
-        }));
-
-        await queue.addBulk(jobs);
-
-        await allActive;
-
-        const queueScheduler = new QueueScheduler(queueName, {
-          connection,
-          stalledInterval: 100,
-          maxStalledCount: 0,
-        });
-        await queueScheduler.waitUntilReady();
-
-        await worker.close(true);
-
-        const errorMessage = 'job stalled more than allowable limit';
-        const allFailed = new Promise<void>(resolve => {
-          queueScheduler.on(
-            'failed',
-            after(concurrency, async (jobId, failedReason, prev) => {
-              const failedCount = await queue.getFailedCount();
-              expect(failedCount).to.equal(3);
-
-              const job = await queue.getJob(jobId);
-              expect(job.data.index).to.be.equal(3);
-              expect(prev).to.be.equal('active');
-              expect(failedReason.message).to.be.equal(errorMessage);
-              resolve();
-            }),
-          );
-        });
-
-        await allFailed;
-
-        await queueScheduler.close();
-      });
-    });
-
-    describe('when removeOnFail is provided as boolean', function () {
-      it('keeps the jobs with removeOnFail as false in failed', async function () {
-        this.timeout(6000);
-        const concurrency = 4;
-
-        const worker = new Worker(
-          queueName,
-          async () => {
-            return delay(10000);
-          },
-          {
-            connection,
-            lockDuration: 1000,
-            concurrency,
-          },
-        );
-
-        const allActive = new Promise(resolve => {
-          worker.on('active', after(concurrency, resolve));
-        });
-
-        await worker.waitUntilReady();
-
-        const jobs = Array.from(Array(4).keys()).map(index => ({
-          name: 'test',
-          data: { index },
-          opts: {
-            removeOnFail: index % 2 == 1,
-          },
-        }));
-
-        await queue.addBulk(jobs);
-
-        await allActive;
-
-        const queueScheduler = new QueueScheduler(queueName, {
-          connection,
-          stalledInterval: 100,
-          maxStalledCount: 0,
-        });
-        await queueScheduler.waitUntilReady();
-
-        await worker.close(true);
-
-        const errorMessage = 'job stalled more than allowable limit';
-        const allFailed = new Promise<void>(resolve => {
-          queueScheduler.on(
-            'failed',
-            after(concurrency, async (jobId, failedReason, prev) => {
-              const job = await queue.getJob(jobId);
-              expect(job).to.be.undefined;
-              const failedCount = await queue.getFailedCount();
-              expect(failedCount).to.equal(2);
-
-              expect(prev).to.be.equal('active');
-              expect(failedReason.message).to.be.equal(errorMessage);
-              resolve();
-            }),
-          );
-        });
-
-        await allFailed;
-
-        await queueScheduler.close();
-      });
-    });
-
-    describe('when removeOnFail is provided as a object', function () {
-      it('keeps the specified number of jobs in failed respecting the age', async function () {
-        this.timeout(6000);
-        const concurrency = 4;
-
-        const queueScheduler = new QueueScheduler(queueName, {
-          connection,
-          stalledInterval: 100,
-          maxStalledCount: 0,
-        });
-        await queueScheduler.waitUntilReady();
-
-        const worker = new Worker(
-          queueName,
-          async job => {
-            if (job.data.index < 2) {
-              throw new Error('fail');
-            }
-            return delay(10000);
-          },
-          {
-            connection,
-            lockDuration: 1000,
-            concurrency,
-          },
-        );
-
-        const allActive = new Promise(resolve => {
-          worker.on('active', after(concurrency, resolve));
-        });
-
-        await worker.waitUntilReady();
-
-        const jobs = Array.from(Array(4).keys()).map(index => ({
-          name: 'test',
-          data: { index },
-          opts: {
-            removeOnFail: {
-              count: 4,
-              age: 1,
-            },
-          },
-        }));
-
-        await queue.addBulk(jobs);
-
-        await allActive;
-
-        await worker.close(true);
-
-        const errorMessage = 'job stalled more than allowable limit';
-        const allFailed = new Promise<void>(resolve => {
-          queueScheduler.on('failed', async (jobId, failedReason, prev) => {
-            if (jobId == '4') {
-              const failedCount = await queue.getFailedCount();
-              expect(failedCount).to.equal(2);
-
-              const job = await queue.getJob(jobId);
-              expect(job.data.index).to.be.equal(3);
-              expect(prev).to.be.equal('active');
-              expect(failedReason.message).to.be.equal(errorMessage);
-              resolve();
-            }
-          });
-        });
-
-        await allFailed;
-
-        await queueScheduler.close();
-      });
-    });
-  });
-
   it('jobs not stalled while lock is extended', async function () {
     this.timeout(5000);
     const numJobs = 4;
@@ -473,7 +193,7 @@ describe('stalled jobs', function () {
 
     const jobs = Array.from(Array(numJobs).keys()).map(index => ({
       name: 'test',
-      data: { bar: `baz-${index}` },
+      data: { bar: `baz-${index}` }
     }));
 
     await queue.addBulk(jobs);
