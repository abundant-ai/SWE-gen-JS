diff --git a/docs/scripts.md b/docs/scripts.md
index 762429e..5aaa1e7 100644
--- a/docs/scripts.md
+++ b/docs/scripts.md
@@ -636,7 +636,7 @@ await $`echo example`.pipe(fs.createWriteStream('file.txt'));
 
 ```js
 // Execa
-await $({stdout: {file: 'file.txt'}})`echo example`;
+await $`echo example`.pipeStdout('file.txt');
 ```
 
 ### Piping stdin from a file
diff --git a/index.d.ts b/index.d.ts
index ea67373..a36ec0f 100644
--- a/index.d.ts
+++ b/index.d.ts
@@ -657,21 +657,21 @@ type ExecaCommonReturnValue<IsSync extends boolean = boolean, OptionsType extend
 	/**
 	The output of the process on `stdout`.
 
-	This is `undefined` if the `stdout` option is set to only [`'inherit'`, `'ipc'`, `'ignore'`, `Stream` or `integer`](https://nodejs.org/api/child_process.html#child_process_options_stdio). This is an array if the `lines` option is `true, or if the `stdout` option is a transform in object mode.
+	This is `undefined` if the `stdout` option is set to [`'inherit'`, `'ipc'`, `'ignore'`, `Stream` or `integer`](https://nodejs.org/api/child_process.html#child_process_options_stdio). This is an array if the `lines` option is `true, or if the `stdout` option is a transform in object mode.
 	*/
 	stdout: StdioOutput<'1', OptionsType>;
 
 	/**
 	The output of the process on `stderr`.
 
-	This is `undefined` if the `stderr` option is set to only [`'inherit'`, `'ipc'`, `'ignore'`, `Stream` or `integer`](https://nodejs.org/api/child_process.html#child_process_options_stdio). This is an array if the `lines` option is `true, or if the `stderr` option is a transform in object mode.
+	This is `undefined` if the `stderr` option is set to [`'inherit'`, `'ipc'`, `'ignore'`, `Stream` or `integer`](https://nodejs.org/api/child_process.html#child_process_options_stdio). This is an array if the `lines` option is `true, or if the `stderr` option is a transform in object mode.
 	*/
 	stderr: StdioOutput<'2', OptionsType>;
 
 	/**
 	The output of the process on `stdin`, `stdout`, `stderr` and other file descriptors.
 
-	Items are `undefined` when their corresponding `stdio` option is set to only [`'inherit'`, `'ipc'`, `'ignore'`, `Stream` or `integer`](https://nodejs.org/api/child_process.html#child_process_options_stdio). Items are arrays when their corresponding `stdio` option is a transform in object mode.
+	Items are `undefined` when their corresponding `stdio` option is set to [`'inherit'`, `'ipc'`, `'ignore'`, `Stream` or `integer`](https://nodejs.org/api/child_process.html#child_process_options_stdio). Items are arrays when their corresponding `stdio` option is a transform in object mode.
 	*/
 	stdio: StdioArrayOutput<OptionsType>;
 
@@ -810,27 +810,33 @@ export type ExecaChildPromise<OptionsType extends Options = Options> = {
 	): Promise<ExecaReturnValue<OptionsType> | ResultType>;
 
 	/**
-	[Pipe](https://nodejs.org/api/stream.html#readablepipedestination-options) the child process' `stdout` to another Execa child process' `stdin`.
+	[Pipe](https://nodejs.org/api/stream.html#readablepipedestination-options) the child process's `stdout` to `target`, which can be:
+	- Another `execa()` return value
+	- A writable stream
+	- A file path string
 
-	Returns `execaChildProcess`, which allows chaining `pipeStdout()` then `await`ing the final result.
+	If the `target` is another `execa()` return value, it is returned. Otherwise, the original `execa()` return value is returned. This allows chaining `pipeStdout()` then `await`ing the final result.
 
-	`childProcess.stdout` must not be `undefined`.
+	The `stdout` option] must be kept as `pipe`, its default value.
 	*/
 	pipeStdout?<Target extends ExecaChildProcess>(target: Target): Target;
+	pipeStdout?(target: Writable | string): ExecaChildProcess<OptionsType>;
 
 	/**
 	Like `pipeStdout()` but piping the child process's `stderr` instead.
 
-	`childProcess.stderr` must not be `undefined`.
+	The `stderr` option must be kept as `pipe`, its default value.
 	*/
 	pipeStderr?<Target extends ExecaChildProcess>(target: Target): Target;
+	pipeStderr?(target: Writable | string): ExecaChildProcess<OptionsType>;
 
 	/**
 	Combines both `pipeStdout()` and `pipeStderr()`.
 
-	The `all` option must be set to `true`.
+	Either the `stdout` option or the `stderr` option must be kept as `pipe`, their default value. Also, the `all` option must be set to `true`.
 	*/
 	pipeAll?<Target extends ExecaChildProcess>(target: Target): Target;
+	pipeAll?(target: Writable | string): ExecaChildProcess<OptionsType>;
 };
 
 export type ExecaChildProcess<OptionsType extends Options = Options> = ChildProcess &
diff --git a/index.test-d.ts b/index.test-d.ts
index b4bc972..2682006 100644
--- a/index.test-d.ts
+++ b/index.test-d.ts
@@ -83,18 +83,30 @@ try {
 	const writeStream = createWriteStream('output.txt');
 
 	expectAssignable<Function | undefined>(execaPromise.pipeStdout);
+	expectAssignable<ExecaChildProcess>(execaPromise.pipeStdout!('file.txt'));
+	expectAssignable<ExecaChildProcess>(execaBufferPromise.pipeStdout!('file.txt'));
+	expectAssignable<ExecaChildProcess>(execaPromise.pipeStdout!(writeStream));
+	expectAssignable<ExecaChildProcess>(execaBufferPromise.pipeStdout!(writeStream));
 	expectAssignable<ExecaChildProcess>(execaPromise.pipeStdout!(execaPromise));
 	expectAssignable<ExecaChildProcess>(execaPromise.pipeStdout!(execaBufferPromise));
 	expectAssignable<ExecaChildProcess>(execaBufferPromise.pipeStdout!(execaPromise));
 	expectAssignable<ExecaChildProcess>(execaBufferPromise.pipeStdout!(execaBufferPromise));
 
 	expectAssignable<Function | undefined>(execaPromise.pipeStderr);
+	expectAssignable<ExecaChildProcess>(execaPromise.pipeStderr!('file.txt'));
+	expectAssignable<ExecaChildProcess>(execaBufferPromise.pipeStderr!('file.txt'));
+	expectAssignable<ExecaChildProcess>(execaPromise.pipeStderr!(writeStream));
+	expectAssignable<ExecaChildProcess>(execaBufferPromise.pipeStderr!(writeStream));
 	expectAssignable<ExecaChildProcess>(execaPromise.pipeStderr!(execaPromise));
 	expectAssignable<ExecaChildProcess>(execaPromise.pipeStderr!(execaBufferPromise));
 	expectAssignable<ExecaChildProcess>(execaBufferPromise.pipeStderr!(execaPromise));
 	expectAssignable<ExecaChildProcess>(execaBufferPromise.pipeStderr!(execaBufferPromise));
 
 	expectAssignable<Function | undefined>(execaPromise.pipeAll);
+	expectAssignable<ExecaChildProcess>(execaPromise.pipeAll!('file.txt'));
+	expectAssignable<ExecaChildProcess>(execaBufferPromise.pipeAll!('file.txt'));
+	expectAssignable<ExecaChildProcess>(execaPromise.pipeAll!(writeStream));
+	expectAssignable<ExecaChildProcess>(execaBufferPromise.pipeAll!(writeStream));
 	expectAssignable<ExecaChildProcess>(execaPromise.pipeAll!(execaPromise));
 	expectAssignable<ExecaChildProcess>(execaPromise.pipeAll!(execaBufferPromise));
 	expectAssignable<ExecaChildProcess>(execaBufferPromise.pipeAll!(execaPromise));
diff --git a/lib/pipe.js b/lib/pipe.js
index 3326f39..e73ffcc 100644
--- a/lib/pipe.js
+++ b/lib/pipe.js
@@ -1,11 +1,22 @@
+import {createWriteStream} from 'node:fs';
 import {ChildProcess} from 'node:child_process';
 import {isWritableStream} from 'is-stream';
 
 const isExecaChildProcess = target => target instanceof ChildProcess && typeof target.then === 'function';
 
 const pipeToTarget = (spawned, streamName, target) => {
+	if (typeof target === 'string') {
+		spawned[streamName].pipe(createWriteStream(target));
+		return spawned;
+	}
+
+	if (isWritableStream(target)) {
+		spawned[streamName].pipe(target);
+		return spawned;
+	}
+
 	if (!isExecaChildProcess(target)) {
-		throw new TypeError('The second argument must be an Execa child process.');
+		throw new TypeError('The second argument must be a string, a stream or an Execa child process.');
 	}
 
 	if (!isWritableStream(target.stdin)) {
diff --git a/readme.md b/readme.md
index b8a5ab4..6258e80 100644
--- a/readme.md
+++ b/readme.md
@@ -146,13 +146,13 @@ rainbows
 import {execa} from 'execa';
 
 // Similar to `echo unicorns > stdout.txt` in Bash
-await execa('echo', ['unicorns'], {stdout: {file: 'stdout.txt'}});
+await execa('echo', ['unicorns']).pipeStdout('stdout.txt');
 
 // Similar to `echo unicorns 2> stdout.txt` in Bash
-await execa('echo', ['unicorns'], {stderr: {file: 'stderr.txt'}});
+await execa('echo', ['unicorns']).pipeStderr('stderr.txt');
 
 // Similar to `echo unicorns &> stdout.txt` in Bash
-await execa('echo', ['unicorns'], {stdout: {file: 'all.txt'}, stderr: {file: 'all.txt'}});
+await execa('echo', ['unicorns'], {all: true}).pipeAll('all.txt');
 ```
 
 #### Redirect input from a file
@@ -171,7 +171,7 @@ console.log(stdout);
 ```js
 import {execa} from 'execa';
 
-const {stdout} = await execa('echo', ['unicorns'], {stdout: ['pipe', 'inherit']});
+const {stdout} = await execa('echo', ['unicorns']).pipeStdout(process.stdout);
 // Prints `unicorns`
 console.log(stdout);
 // Also returns 'unicorns'
@@ -319,31 +319,28 @@ This is `undefined` if either:
 - the [`all` option](#all-2) is `false` (the default value)
 - both [`stdout`](#stdout-1) and [`stderr`](#stderr-1) options are set to [`'inherit'`, `'ipc'`, `'ignore'`, `Stream` or `integer`](https://nodejs.org/api/child_process.html#child_process_options_stdio)
 
-#### pipeStdout(execaChildProcess)
+#### pipeStdout(target)
 
-`execaChildProcess`: [`execa()` return value](#pipe-multiple-processes)
+[Pipe](https://nodejs.org/api/stream.html#readablepipedestination-options) the child process's `stdout` to `target`, which can be:
+- Another [`execa()` return value](#pipe-multiple-processes)
+- A [writable stream](#save-and-pipe-output-from-a-child-process)
+- A [file path string](#redirect-output-to-a-file)
 
-[Pipe](https://nodejs.org/api/stream.html#readablepipedestination-options) the child process' `stdout` to another Execa child process' `stdin`.
+If the `target` is another [`execa()` return value](#execacommandcommand-options), it is returned. Otherwise, the original `execa()` return value is returned. This allows chaining `pipeStdout()` then `await`ing the [final result](#childprocessresult).
 
-Returns `execaChildProcess`, which allows chaining `pipeStdout()` then `await`ing the [final result](#childprocessresult).
+The [`stdout` option](#stdout-1) must be kept as `pipe`, its default value.
 
-[`childProcess.stdout`](#stdout) must not be `undefined`.
+#### pipeStderr(target)
 
-#### pipeStderr(execaChildProcess)
+Like [`pipeStdout()`](#pipestdouttarget) but piping the child process's `stderr` instead.
 
-`execaChildProcess`: [`execa()` return value](#pipe-multiple-processes)
+The [`stderr` option](#stderr-1) must be kept as `pipe`, its default value.
 
-Like [`pipeStdout()`](#pipestdoutexecachildprocess) but piping the child process's `stderr` instead.
+#### pipeAll(target)
 
-[`childProcess.stderr`](#stderr) must not be `undefined`.
+Combines both [`pipeStdout()`](#pipestdouttarget) and [`pipeStderr()`](#pipestderrtarget).
 
-#### pipeAll(execaChildProcess)
-
-`execaChildProcess`: [`execa()` return value](#pipe-multiple-processes)
-
-Combines both [`pipeStdout()`](#pipestdoutexecachildprocess) and [`pipeStderr()`](#pipestderrexecachildprocess).
-
-The [`all` option](#all-2) must be set to `true`.
+Either the [`stdout` option](#stdout-1) or the [`stderr` option](#stderr-1) must be kept as `pipe`, their default value. Also, the [`all` option](#all-2) must be set to `true`.
 
 ### childProcessResult
 
@@ -389,7 +386,7 @@ Type: `string | Uint8Array | string[] | Uint8Array[] | unknown[] | undefined`
 
 The output of the process on `stdout`.
 
-This is `undefined` if the [`stdout`](#stdout-1) option is set to only [`'inherit'`, `'ipc'`, `'ignore'`, `Stream` or `integer`](https://nodejs.org/api/child_process.html#child_process_options_stdio). This is an array if the [`lines` option](#lines) is `true, or if the `stdout` option is a [transform in object mode](docs/transform.md#object-mode).
+This is `undefined` if the [`stdout`](#stdout-1) option is set to [`'inherit'`, `'ipc'`, `'ignore'`, `Stream` or `integer`](https://nodejs.org/api/child_process.html#child_process_options_stdio). This is an array if the [`lines` option](#lines) is `true, or if the `stdout` option is a [transform in object mode](docs/transform.md#object-mode).
 
 #### stderr
 
@@ -397,7 +394,7 @@ Type: `string | Uint8Array | string[] | Uint8Array[] | unknown[] | undefined`
 
 The output of the process on `stderr`.
 
-This is `undefined` if the [`stderr`](#stderr-1) option is set to only [`'inherit'`, `'ipc'`, `'ignore'`, `Stream` or `integer`](https://nodejs.org/api/child_process.html#child_process_options_stdio). This is an array if the [`lines` option](#lines) is `true, or if the `stderr` option is a [transform in object mode](docs/transform.md#object-mode).
+This is `undefined` if the [`stderr`](#stderr-1) option is set to [`'inherit'`, `'ipc'`, `'ignore'`, `Stream` or `integer`](https://nodejs.org/api/child_process.html#child_process_options_stdio). This is an array if the [`lines` option](#lines) is `true, or if the `stderr` option is a [transform in object mode](docs/transform.md#object-mode).
 
 #### all
 
@@ -407,7 +404,7 @@ The output of the process with `stdout` and `stderr` [interleaved](#ensuring-all
 
 This is `undefined` if either:
 - the [`all` option](#all-2) is `false` (the default value)
-- both [`stdout`](#stdout-1) and [`stderr`](#stderr-1) options are set to only [`'inherit'`, `'ipc'`, `'ignore'`, `Stream` or `integer`](https://nodejs.org/api/child_process.html#child_process_options_stdio)
+- both [`stdout`](#stdout-1) and [`stderr`](#stderr-1) options are set to [`'inherit'`, `'ipc'`, `'ignore'`, `Stream` or `integer`](https://nodejs.org/api/child_process.html#child_process_options_stdio)
 
 This is an array if the [`lines` option](#lines) is `true, or if either the `stdout` or `stderr` option is a [transform in object mode](docs/transform.md#object-mode).
 
diff --git a/test/pipe.js b/test/pipe.js
index ebffb8b..a0d156a 100644
--- a/test/pipe.js
+++ b/test/pipe.js
@@ -1,6 +1,9 @@
-import {PassThrough} from 'node:stream';
+import {PassThrough, Readable} from 'node:stream';
 import {spawn} from 'node:child_process';
+import {readFile, rm} from 'node:fs/promises';
+import tempfile from 'tempfile';
 import test from 'ava';
+import getStream from 'get-stream';
 import {execa} from '../index.js';
 import {setFixtureDir} from './helpers/fixtures-dir.js';
 
@@ -16,12 +19,41 @@ test('pipeStderr() can pipe to Execa child processes', pipeToProcess, 2, 'pipeSt
 test('pipeAll() can pipe stdout to Execa child processes', pipeToProcess, 1, 'pipeAll');
 test('pipeAll() can pipe stderr to Execa child processes', pipeToProcess, 2, 'pipeAll');
 
+const pipeToStream = async (t, index, funcName) => {
+	const stream = new PassThrough();
+	const result = await execa('noop-fd.js', [`${index}`, 'test'], {all: true})[funcName](stream);
+	t.is(result.stdio[index], 'test');
+	t.is(await getStream(stream), 'test');
+};
+
+test('pipeStdout() can pipe to streams', pipeToStream, 1, 'pipeStdout');
+test('pipeStderr() can pipe to streams', pipeToStream, 2, 'pipeStderr');
+test('pipeAll() can pipe stdout to streams', pipeToStream, 1, 'pipeAll');
+test('pipeAll() can pipe stderr to streams', pipeToStream, 2, 'pipeAll');
+
+const pipeToFile = async (t, index, funcName) => {
+	const file = tempfile();
+	const result = await execa('noop-fd.js', [`${index}`, 'test'], {all: true})[funcName](file);
+	t.is(result.stdio[index], 'test');
+	t.is(await readFile(file, 'utf8'), 'test');
+	await rm(file);
+};
+
+// `test.serial()` is due to a race condition: `execa(...).pipe*(file)` might resolve before the file stream has resolved
+test.serial('pipeStdout() can pipe to files', pipeToFile, 1, 'pipeStdout');
+test.serial('pipeStderr() can pipe to files', pipeToFile, 2, 'pipeStderr');
+test.serial('pipeAll() can pipe stdout to files', pipeToFile, 1, 'pipeAll');
+test.serial('pipeAll() can pipe stderr to files', pipeToFile, 2, 'pipeAll');
+
 const invalidTarget = (t, funcName, getTarget) => {
 	t.throws(() => execa('empty.js', {all: true})[funcName](getTarget()), {
-		message: /an Execa child process/,
+		message: /a stream or an Execa child process/,
 	});
 };
 
+test('pipeStdout() can only pipe to writable streams', invalidTarget, 'pipeStdout', () => new Readable());
+test('pipeStderr() can only pipe to writable streams', invalidTarget, 'pipeStderr', () => new Readable());
+test('pipeAll() can only pipe to writable streams', invalidTarget, 'pipeAll', () => new Readable());
 test('pipeStdout() cannot pipe to non-processes', invalidTarget, 'pipeStdout', () => ({stdin: new PassThrough()}));
 test('pipeStderr() cannot pipe to non-processes', invalidTarget, 'pipeStderr', () => ({stdin: new PassThrough()}));
 test('pipeAll() cannot pipe to non-processes', invalidTarget, 'pipeStderr', () => ({stdin: new PassThrough()}));
