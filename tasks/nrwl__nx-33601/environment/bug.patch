diff --git a/docs/blog/2025-11-19-the-compounding-effect-how-nx-features-multiply-performance-gains.md b/docs/blog/2025-11-19-the-compounding-effect-how-nx-features-multiply-performance-gains.md
index f49c6be5c9..acb6d3c87f 100644
--- a/docs/blog/2025-11-19-the-compounding-effect-how-nx-features-multiply-performance-gains.md
+++ b/docs/blog/2025-11-19-the-compounding-effect-how-nx-features-multiply-performance-gains.md
@@ -7,7 +7,7 @@ authors: ['Jeff Cross', 'Madeline Hennessy']
 tags: [webinar]
 cover_image: /blog/images/2025-11-19/Nov-2025-Webinar-Card.avif
 time: 12pm ET/5pm UTC
-status: Upcoming
+status: Past - Gated
 registrationUrl: https://go.nx.dev/nov2025-webinar
 ---
 
@@ -21,4 +21,4 @@ Remote caching delivers such dramatic improvements that many teams stop there, t
 
 Join us on Nov. 19th to learn how to strategically leverage the capabilities you already have access toâ€”and see exactly how much time your team is leaving on the table.
 
-{% call-to-action title="Register today!" url="https://go.nx.dev/nov2025-webinar" description="Save your spot" /%}
+{% call-to-action title="Download the recording!" url="https://go.nx.dev/nov2025-webinar" description="Sign up to gain access" /%}
diff --git a/e2e/gradle/src/gradle-dsl.test.ts b/e2e/gradle/src/gradle-dsl.test.ts
index 942c17e174..af1a30719e 100644
--- a/e2e/gradle/src/gradle-dsl.test.ts
+++ b/e2e/gradle/src/gradle-dsl.test.ts
@@ -57,12 +57,7 @@ describe('Gradle DSL - nx {} configuration', () => {
 
           runCLI('reset');
           const config = JSON.parse(
-            runCLI('show project app --json', {
-              env: {
-                NX_VERBOSE_LOGGING: 'false',
-                NX_GRADLE_VERBOSE_LOGGING: 'false',
-              },
-            })
+            runCLI('show project app --json', { verbose: false })
           );
 
           expect(config.type).toBe('custom-app-name');
@@ -81,12 +76,7 @@ describe('Gradle DSL - nx {} configuration', () => {
 
           runCLI('reset');
           const config = JSON.parse(
-            runCLI('show project app --json', {
-              env: {
-                NX_VERBOSE_LOGGING: 'false',
-                NX_GRADLE_VERBOSE_LOGGING: 'false',
-              },
-            })
+            runCLI('show project app --json', { verbose: false })
           );
 
           expect(config.priority).toBe(10);
@@ -105,12 +95,7 @@ describe('Gradle DSL - nx {} configuration', () => {
 
           runCLI('reset');
           const config = JSON.parse(
-            runCLI('show project app --json', {
-              env: {
-                NX_VERBOSE_LOGGING: 'false',
-                NX_GRADLE_VERBOSE_LOGGING: 'false',
-              },
-            })
+            runCLI('show project app --json', { verbose: false })
           );
 
           expect(config.isPublic).toBe(true);
@@ -129,12 +114,7 @@ describe('Gradle DSL - nx {} configuration', () => {
 
           runCLI('reset');
           const config = JSON.parse(
-            runCLI('show project app --json', {
-              env: {
-                NX_VERBOSE_LOGGING: 'false',
-                NX_GRADLE_VERBOSE_LOGGING: 'false',
-              },
-            })
+            runCLI('show project app --json', { verbose: false })
           );
 
           expect(config.tags).toEqual(['api', 'backend', 'tier:1']);
@@ -153,12 +133,7 @@ describe('Gradle DSL - nx {} configuration', () => {
 
           runCLI('reset');
           const config = JSON.parse(
-            runCLI('show project app --json', {
-              env: {
-                NX_VERBOSE_LOGGING: 'false',
-                NX_GRADLE_VERBOSE_LOGGING: 'false',
-              },
-            })
+            runCLI('show project app --json', { verbose: false })
           );
 
           expect(config.generators['@nx/react:component']).toBe('components');
@@ -178,12 +153,7 @@ describe('Gradle DSL - nx {} configuration', () => {
 
           runCLI('reset');
           const config = JSON.parse(
-            runCLI('show project app --json', {
-              env: {
-                NX_VERBOSE_LOGGING: 'false',
-                NX_GRADLE_VERBOSE_LOGGING: 'false',
-              },
-            })
+            runCLI('show project app --json', { verbose: false })
           );
 
           expect(config.type).toBe('my-custom-app');
@@ -210,12 +180,7 @@ describe('Gradle DSL - nx {} configuration', () => {
 
           runCLI('reset');
           const config = JSON.parse(
-            runCLI('show project app --json', {
-              env: {
-                NX_VERBOSE_LOGGING: 'false',
-                NX_GRADLE_VERBOSE_LOGGING: 'false',
-              },
-            })
+            runCLI('show project app --json', { verbose: false })
           );
 
           expect(config.config.level1.level2.value).toBe('deep');
@@ -234,12 +199,7 @@ describe('Gradle DSL - nx {} configuration', () => {
 
           runCLI('reset');
           const config = JSON.parse(
-            runCLI('show project app --json', {
-              env: {
-                NX_VERBOSE_LOGGING: 'false',
-                NX_GRADLE_VERBOSE_LOGGING: 'false',
-              },
-            })
+            runCLI('show project app --json', { verbose: false })
           );
 
           expect(config.generators.frameworks).toEqual([
@@ -265,12 +225,7 @@ describe('Gradle DSL - nx {} configuration', () => {
 
           runCLI('reset');
           const config = JSON.parse(
-            runCLI('show project app --json', {
-              env: {
-                NX_VERBOSE_LOGGING: 'false',
-                NX_GRADLE_VERBOSE_LOGGING: 'false',
-              },
-            })
+            runCLI('show project app --json', { verbose: false })
           );
 
           expect(config.targets.myBuild.cache).toBe(false);
@@ -289,12 +244,7 @@ describe('Gradle DSL - nx {} configuration', () => {
 
           runCLI('reset');
           const config = JSON.parse(
-            runCLI('show project app --json', {
-              env: {
-                NX_VERBOSE_LOGGING: 'false',
-                NX_GRADLE_VERBOSE_LOGGING: 'false',
-              },
-            })
+            runCLI('show project app --json', { verbose: false })
           );
 
           expect(config.targets.myTest.inputs).toContain('src/**/*');
@@ -314,12 +264,7 @@ describe('Gradle DSL - nx {} configuration', () => {
 
           runCLI('reset');
           const config = JSON.parse(
-            runCLI('show project app --json', {
-              env: {
-                NX_VERBOSE_LOGGING: 'false',
-                NX_GRADLE_VERBOSE_LOGGING: 'false',
-              },
-            })
+            runCLI('show project app --json', { verbose: false })
           );
 
           expect(
@@ -340,12 +285,7 @@ describe('Gradle DSL - nx {} configuration', () => {
 
           runCLI('reset');
           const config = JSON.parse(
-            runCLI('show project app --json', {
-              env: {
-                NX_VERBOSE_LOGGING: 'false',
-                NX_GRADLE_VERBOSE_LOGGING: 'false',
-              },
-            })
+            runCLI('show project app --json', { verbose: false })
           );
 
           expect(config.targets.e2e.cache).toBe(false);
@@ -367,12 +307,7 @@ describe('Gradle DSL - nx {} configuration', () => {
 
           runCLI('reset');
           const config = JSON.parse(
-            runCLI('show project app --json', {
-              env: {
-                NX_VERBOSE_LOGGING: 'false',
-                NX_GRADLE_VERBOSE_LOGGING: 'false',
-              },
-            })
+            runCLI('show project app --json', { verbose: false })
           );
 
           expect(config.targets.customBuild.cache).toBe(true);
@@ -396,12 +331,7 @@ describe('Gradle DSL - nx {} configuration', () => {
 
           runCLI('reset');
           const config = JSON.parse(
-            runCLI('show project app --json', {
-              env: {
-                NX_VERBOSE_LOGGING: 'false',
-                NX_GRADLE_VERBOSE_LOGGING: 'false',
-              },
-            })
+            runCLI('show project app --json', { verbose: false })
           );
 
           // Project-level config
@@ -426,12 +356,7 @@ describe('Gradle DSL - nx {} configuration', () => {
 
           runCLI('reset');
           const config = JSON.parse(
-            runCLI('show project app --json', {
-              env: {
-                NX_VERBOSE_LOGGING: 'false',
-                NX_GRADLE_VERBOSE_LOGGING: 'false',
-              },
-            })
+            runCLI('show project app --json', { verbose: false })
           );
 
           // Project-level
@@ -483,20 +408,10 @@ describe('Gradle DSL - nx {} configuration', () => {
           runCLI('reset');
 
           const appConfig = JSON.parse(
-            runCLI('show project app --json', {
-              env: {
-                NX_VERBOSE_LOGGING: 'false',
-                NX_GRADLE_VERBOSE_LOGGING: 'false',
-              },
-            })
+            runCLI('show project app --json', { verbose: false })
           );
           const listConfig = JSON.parse(
-            runCLI('show project list --json', {
-              env: {
-                NX_VERBOSE_LOGGING: 'false',
-                NX_GRADLE_VERBOSE_LOGGING: 'false',
-              },
-            })
+            runCLI('show project list --json', { verbose: false })
           );
 
           expect(appConfig.type).toBe('app-project');
diff --git a/e2e/release/src/conventional-commits-config.test.ts b/e2e/release/src/conventional-commits-config.test.ts
index 40f183a91f..de71df6881 100644
--- a/e2e/release/src/conventional-commits-config.test.ts
+++ b/e2e/release/src/conventional-commits-config.test.ts
@@ -399,7 +399,7 @@ describe('nx release conventional commits config', () => {
 
       ### âš ï¸  Breaking Changes
 
-      - âš ï¸  **{project-name}:** this is a breaking change
+      - **{project-name}:** this is a breaking change
     `);
 
     const pkg2Changelog = readFile(`${pkg2}/CHANGELOG.md`);
diff --git a/e2e/release/src/conventional-commits-config.workspaces.test.ts b/e2e/release/src/conventional-commits-config.workspaces.test.ts
index 7365cfced6..e5197c9e01 100644
--- a/e2e/release/src/conventional-commits-config.workspaces.test.ts
+++ b/e2e/release/src/conventional-commits-config.workspaces.test.ts
@@ -406,7 +406,7 @@ describe('nx release conventional commits config', () => {
 
       ### âš ï¸  Breaking Changes
 
-      - âš ï¸  **{project-name}:** this is a breaking change
+      - **{project-name}:** this is a breaking change
     `);
 
     const pkg2Changelog = readFile(`${pkg2}/CHANGELOG.md`);
diff --git a/graph/client/src/app/feature-tasks/tasks-shell.tsx b/graph/client/src/app/feature-tasks/tasks-shell.tsx
index 632494b09a..c4e4067619 100644
--- a/graph/client/src/app/feature-tasks/tasks-shell.tsx
+++ b/graph/client/src/app/feature-tasks/tasks-shell.tsx
@@ -69,9 +69,37 @@ export function TasksShell() {
     'selectedWorkspace'
   ) as ProjectGraphClientResponse;
 
+  const tasksRouteData = useRouteLoaderData('tasks') as TaskGraphClientResponse;
+  const allTasksRouteData = useRouteLoaderData(
+    'tasksAll'
+  ) as TaskGraphClientResponse;
+
+  const taskGraphError = useMemo(
+    () => allTasksRouteData?.error || tasksRouteData?.error,
+    [allTasksRouteData, tasksRouteData]
+  );
+
   useLayoutEffect(() => {
-    setErrors(routerErrors);
-  }, [routerErrors]);
+    const allErrors: GraphError[] = [];
+
+    if (routerErrors) {
+      allErrors.push(...routerErrors);
+    }
+
+    if (taskGraphError) {
+      allErrors.push({
+        message: taskGraphError,
+        pluginName: 'graph',
+        cause: 'TaskGraphClientResponse error',
+        name: 'graph',
+        stack: '',
+      });
+    }
+
+    if (allErrors.length === 0) return;
+
+    setErrors(allErrors);
+  }, [routerErrors, taskGraphError]);
 
   return (
     <>
diff --git a/nx-dev/ui-common/src/lib/webinar-notifier.tsx b/nx-dev/ui-common/src/lib/webinar-notifier.tsx
index b6eae9f36d..b3634dceff 100644
--- a/nx-dev/ui-common/src/lib/webinar-notifier.tsx
+++ b/nx-dev/ui-common/src/lib/webinar-notifier.tsx
@@ -1,14 +1,15 @@
 'use client';
 
 import { MouseEvent, ReactElement, useEffect, useState } from 'react';
-import { motion } from 'framer-motion';
-import {
-  MegaphoneIcon,
-  VideoCameraIcon,
-  XMarkIcon,
-} from '@heroicons/react/24/outline';
+// import { motion } from 'framer-motion';
+// import {
+//   MegaphoneIcon,
+//   VideoCameraIcon,
+//   XMarkIcon,
+// } from '@heroicons/react/24/outline';
 
 export function WebinarNotifier(): ReactElement | null {
+  /*
   const [isMounted, setIsMounted] = useState(false);
   const [isVisible, setIsVisible] = useState<boolean>(true);
   const localStorageKey = 'webinar-november-19-2025--notifier-closed';
@@ -85,4 +86,7 @@ export function WebinarNotifier(): ReactElement | null {
       </div>
     </motion.div>
   );
+  */
+
+  return null;
 }
diff --git a/nx-dev/ui-enterprise/src/lib/webinar-section.tsx b/nx-dev/ui-enterprise/src/lib/webinar-section.tsx
index eb7e89e991..dd11ceb6dd 100644
--- a/nx-dev/ui-enterprise/src/lib/webinar-section.tsx
+++ b/nx-dev/ui-enterprise/src/lib/webinar-section.tsx
@@ -1,7 +1,8 @@
 import React from 'react';
-import { ChevronRightIcon } from '@heroicons/react/24/outline';
+// import { ChevronRightIcon } from '@heroicons/react/24/outline';
 
 export const WebinarSection: React.FC = () => {
+  /*
   return (
     <p>
       <a
@@ -22,4 +23,7 @@ export const WebinarSection: React.FC = () => {
       </a>
     </p>
   );
+  */
+
+  return null;
 };
diff --git a/packages/nest/src/generators/application/application.spec.ts b/packages/nest/src/generators/application/application.spec.ts
index f79c9c6c40..b74a240338 100644
--- a/packages/nest/src/generators/application/application.spec.ts
+++ b/packages/nest/src/generators/application/application.spec.ts
@@ -157,6 +157,7 @@ describe('application generator', () => {
     const tsConfig = devkit.readJson(tree, `${appDirectory}/tsconfig.app.json`);
     expect(tsConfig.compilerOptions.emitDecoratorMetadata).toBe(true);
     expect(tsConfig.compilerOptions.target).toBe('es2021');
+    expect(tsConfig.compilerOptions.moduleResolution).toBe('node');
     expect(tsConfig.exclude).toEqual([
       'jest.config.ts',
       'jest.config.cts',
diff --git a/packages/nest/src/generators/application/lib/update-tsconfig.ts b/packages/nest/src/generators/application/lib/update-tsconfig.ts
index 693bb4cabd..e484fc2eb3 100644
--- a/packages/nest/src/generators/application/lib/update-tsconfig.ts
+++ b/packages/nest/src/generators/application/lib/update-tsconfig.ts
@@ -11,6 +11,11 @@ export function updateTsConfig(tree: Tree, options: NormalizedOptions): void {
       json.compilerOptions.experimentalDecorators = true;
       json.compilerOptions.emitDecoratorMetadata = true;
       json.compilerOptions.target = 'es2021';
+
+      // Only set this when not using TS solution setup, as TS solution setup uses 'nodenext'
+      if (!isUsingTsSolutionSetup(tree)) {
+        json.compilerOptions.moduleResolution = 'node';
+      }
       if (options.strict) {
         json.compilerOptions = {
           ...json.compilerOptions,
diff --git a/packages/next/migrations.json b/packages/next/migrations.json
index cbe97c5e72..8dc4f48596 100644
--- a/packages/next/migrations.json
+++ b/packages/next/migrations.json
@@ -5,6 +5,12 @@
       "version": "22.0.0-beta.0",
       "description": "Updates next.config.js files to add SVGR webpack configuration directly instead of using the nx.svgr option in withNx.",
       "factory": "./src/migrations/update-22-0-0/add-svgr-to-next-config"
+    },
+    "update-22-2-0-create-ai-instructions-for-next-16": {
+      "cli": "nx",
+      "version": "22.2.0-beta.0",
+      "description": "Create AI Instructions to help migrate users workspaces to Next.js 16.",
+      "factory": "./src/migrations/update-22-2-0/create-ai-instructions-for-next-16"
     }
   },
   "packageJsonUpdates": {
diff --git a/packages/next/src/migrations/update-22-2-0/create-ai-instructions-for-next-16.ts b/packages/next/src/migrations/update-22-2-0/create-ai-instructions-for-next-16.ts
new file mode 100644
index 0000000000..c92920067f
--- /dev/null
+++ b/packages/next/src/migrations/update-22-2-0/create-ai-instructions-for-next-16.ts
@@ -0,0 +1,20 @@
+import { join } from 'path';
+import { existsSync, readFileSync } from 'fs';
+import { Tree } from '@nx/devkit';
+
+export default async function createAiInstructionsForNext16(tree: Tree) {
+  const pathToAiInstructions = join(
+    __dirname,
+    'files',
+    'ai-instructions-for-next-16.md'
+  );
+  if (!existsSync(pathToAiInstructions)) {
+    return;
+  }
+
+  const contents = readFileSync(pathToAiInstructions, 'utf-8');
+  tree.write('ai-migrations/MIGRATE_NEXT_16.md', contents);
+  return [
+    `We created 'ai-migrations/MIGRATE_NEXT_16.md' with instructions for an AI Agent to help migrate your Next.js projects to Next.js 16.`,
+  ];
+}
diff --git a/packages/next/src/migrations/update-22-2-0/files/ai-instructions-for-next-16.md b/packages/next/src/migrations/update-22-2-0/files/ai-instructions-for-next-16.md
new file mode 100644
index 0000000000..c1d2c798d0
--- /dev/null
+++ b/packages/next/src/migrations/update-22-2-0/files/ai-instructions-for-next-16.md
@@ -0,0 +1,845 @@
+# Next.js 16 Migration Instructions for LLM
+
+## Overview
+
+These instructions guide you through migrating an Nx workspace containing Next.js projects from Next.js 15 to Next.js 16. Work systematically through each breaking change category.
+
+## Pre-Migration Checklist
+
+1. **Identify all Next.js projects**:
+
+   ```bash
+   nx show projects --with-target build | xargs -I {} nx show project {} --json | jq -r 'select(.targets.build.executor | contains("next")) | .name'
+   ```
+
+   Or search for Next.js configuration files:
+
+   ```bash
+   find . -name "next.config.*" -not -path "*/node_modules/*"
+   ```
+
+2. **Update packages**:
+
+   ```bash
+   npm install next@latest react@latest react-dom@latest
+   npm install -D @types/react @types/react-dom  # if using TypeScript
+   ```
+
+3. **Verify minimum requirements**:
+   - Node.js 20.9+ (Node.js 18 is no longer supported)
+   - TypeScript 5.1.0+
+   - Browser support: Chrome 111+, Edge 111+, Firefox 111+, Safari 16.4+
+
+## Migration Steps by Category
+
+### 1. Async Request APIs (Major Breaking Change)
+
+This is the most impactful change in Next.js 16. All dynamic request APIs are now asynchronous.
+
+**Search Patterns**:
+
+- `cookies()` usage in server components
+- `headers()` usage in server components
+- `draftMode()` usage
+- `params` in page, layout, route handlers, and metadata files
+- `searchParams` in page components
+
+#### 1.1 Page Components with params
+
+**Changes Required**:
+
+```tsx
+// BEFORE (Next.js 15)
+export default function Page({ params }) {
+  const { slug } = params;
+  return <h1>{slug}</h1>;
+}
+
+// AFTER (Next.js 16)
+export default async function Page(props) {
+  const { slug } = await props.params;
+  return <h1>{slug}</h1>;
+}
+```
+
+**Action Items**:
+
+- [ ] Make all page components that use `params` async
+- [ ] Add `await` before accessing `props.params`
+- [ ] Update TypeScript types if applicable
+
+#### 1.2 Page Components with searchParams
+
+**Changes Required**:
+
+```tsx
+// BEFORE (Next.js 15)
+export default function Page({ searchParams }) {
+  const query = searchParams.q;
+  return <Results query={query} />;
+}
+
+// AFTER (Next.js 16)
+export default async function Page(props) {
+  const searchParams = await props.searchParams;
+  const query = searchParams.q;
+  return <Results query={query} />;
+}
+```
+
+**Action Items**:
+
+- [ ] Make all page components that use `searchParams` async
+- [ ] Add `await` before accessing `props.searchParams`
+
+#### 1.3 Layout Components with params
+
+**Changes Required**:
+
+```tsx
+// BEFORE (Next.js 15)
+export default function Layout({ children, params }) {
+  const { locale } = params;
+  return <div data-locale={locale}>{children}</div>;
+}
+
+// AFTER (Next.js 16)
+export default async function Layout(props) {
+  const { locale } = await props.params;
+  return <div data-locale={locale}>{props.children}</div>;
+}
+```
+
+#### 1.4 Route Handlers
+
+**Changes Required**:
+
+```tsx
+// BEFORE (Next.js 15)
+export async function GET(request, { params }) {
+  const { id } = params;
+  return Response.json({ id });
+}
+
+// AFTER (Next.js 16)
+export async function GET(request, props) {
+  const { id } = await props.params;
+  return Response.json({ id });
+}
+```
+
+#### 1.5 cookies() and headers()
+
+**Changes Required**:
+
+```tsx
+// BEFORE (Next.js 15)
+import { cookies, headers } from 'next/headers';
+
+export default function Page() {
+  const cookieStore = cookies();
+  const headersList = headers();
+  const theme = cookieStore.get('theme');
+  const userAgent = headersList.get('user-agent');
+  return <div>...</div>;
+}
+
+// AFTER (Next.js 16)
+import { cookies, headers } from 'next/headers';
+
+export default async function Page() {
+  const cookieStore = await cookies();
+  const headersList = await headers();
+  const theme = cookieStore.get('theme');
+  const userAgent = headersList.get('user-agent');
+  return <div>...</div>;
+}
+```
+
+#### 1.6 draftMode()
+
+**Changes Required**:
+
+```tsx
+// BEFORE (Next.js 15)
+import { draftMode } from 'next/headers';
+
+export default function Page() {
+  const { isEnabled } = draftMode();
+  return <div>{isEnabled ? 'Draft' : 'Published'}</div>;
+}
+
+// AFTER (Next.js 16)
+import { draftMode } from 'next/headers';
+
+export default async function Page() {
+  const { isEnabled } = await draftMode();
+  return <div>{isEnabled ? 'Draft' : 'Published'}</div>;
+}
+```
+
+#### 1.7 generateMetadata with params
+
+**Changes Required**:
+
+```tsx
+// BEFORE (Next.js 15)
+export async function generateMetadata({ params }) {
+  const { slug } = params;
+  return { title: slug };
+}
+
+// AFTER (Next.js 16)
+export async function generateMetadata(props) {
+  const { slug } = await props.params;
+  return { title: slug };
+}
+```
+
+#### 1.8 Automated Migration
+
+Run the Next.js codemod for automated migration:
+
+```bash
+npx @next/codemod@canary upgrade latest
+```
+
+Generate type helpers for safer migrations (Next.js 15.5+):
+
+```bash
+npx next typegen
+```
+
+This generates `PageProps`, `LayoutProps`, and `RouteContext` helpers.
+
+### 2. Image Generation Functions
+
+**Search Pattern**: `generateImageMetadata`, `default function Image` in opengraph-image or twitter-image files
+
+**Changes Required**:
+
+```tsx
+// BEFORE (Next.js 15)
+export function generateImageMetadata({ params }) {
+  const { slug } = params;
+  return [{ id: '1' }];
+}
+
+export default function Image({ params, id }) {
+  const slug = params.slug;
+  return new ImageResponse(/* ... */);
+}
+
+// AFTER (Next.js 16)
+export async function generateImageMetadata({ params }) {
+  const { slug } = await params;
+  return [{ id: '1' }];
+}
+
+export default async function Image({ params, id }) {
+  const { slug } = await params;
+  const imageId = await id;
+  return new ImageResponse(/* ... */);
+}
+```
+
+**Action Items**:
+
+- [ ] Make `generateImageMetadata` functions async
+- [ ] Make Image components async
+- [ ] Add `await` for both `params` and `id` access
+
+### 3. Sitemap Generation
+
+**Search Pattern**: `sitemap` functions with `id` parameter
+
+**Changes Required**:
+
+```tsx
+// BEFORE (Next.js 15)
+export default async function sitemap({ id }) {
+  const start = id * 50000;
+  // ...
+}
+
+// AFTER (Next.js 16)
+export default async function sitemap({ id }) {
+  const resolvedId = await id;
+  const start = resolvedId * 50000;
+  // ...
+}
+```
+
+### 4. Turbopack Configuration
+
+Turbopack is now the default bundler for development.
+
+**Search Pattern**: `--turbo` or `--turbopack` flags in package.json scripts, `turbopack` in next.config
+
+#### 4.1 Remove Explicit Turbopack Flags
+
+```json
+// BEFORE (Next.js 15)
+{
+  "scripts": {
+    "dev": "next dev --turbo"
+  }
+}
+
+// AFTER (Next.js 16) - Turbopack is default
+{
+  "scripts": {
+    "dev": "next dev"
+  }
+}
+```
+
+#### 4.2 Opt Out to Webpack (if needed)
+
+```json
+{
+  "scripts": {
+    "build": "next build --webpack"
+  }
+}
+```
+
+#### 4.3 Move Turbopack Config Out of Experimental
+
+```ts
+// BEFORE (Next.js 15)
+const nextConfig = {
+  experimental: {
+    turbopack: {
+      /* options */
+    },
+  },
+};
+
+// AFTER (Next.js 16)
+const nextConfig = {
+  turbopack: {
+    /* options */
+  },
+};
+```
+
+#### 4.4 Update Sass Imports (Turbopack Specific)
+
+```scss
+/* BEFORE */
+@import '~bootstrap/dist/css/bootstrap.min.css';
+
+/* AFTER - Remove tilde prefix */
+@import 'bootstrap/dist/css/bootstrap.min.css';
+```
+
+**Action Items**:
+
+- [ ] Remove `--turbo` and `--turbopack` flags from scripts
+- [ ] Move `turbopack` config from `experimental` to root level
+- [ ] Remove tilde (`~`) prefix from Sass imports
+- [ ] Add `--webpack` flag if Webpack is required
+
+### 5. Middleware to Proxy Rename
+
+**Search Pattern**: `middleware.ts` or `middleware.js` files
+
+**Changes Required**:
+
+```bash
+# Rename the file
+mv middleware.ts proxy.ts
+```
+
+```ts
+// BEFORE (middleware.ts)
+export function middleware(request) {
+  // ...
+}
+
+// AFTER (proxy.ts)
+export function proxy(request) {
+  // ...
+}
+```
+
+**Config Updates**:
+
+```js
+// BEFORE
+{
+  skipMiddlewareUrlNormalize: true;
+}
+
+// AFTER
+{
+  skipProxyUrlNormalize: true;
+}
+```
+
+**Important**: The Edge runtime is no longer supported in `proxy`. It now uses Node.js runtime.
+
+**Action Items**:
+
+- [ ] Rename `middleware.ts/js` to `proxy.ts/js`
+- [ ] Rename exported function from `middleware` to `proxy`
+- [ ] Update config option names
+- [ ] Remove Edge runtime usage from proxy files
+
+### 6. Parallel Routes default.js Requirement
+
+**Search Pattern**: Directories starting with `@` in the app folder (parallel route slots)
+
+All parallel route slots now require an explicit `default.js` file.
+
+**Changes Required**:
+
+```tsx
+// Create app/@modal/default.tsx for each parallel route slot
+import { notFound } from 'next/navigation';
+
+export default function Default() {
+  notFound(); // or return null
+}
+```
+
+**Action Items**:
+
+- [ ] Find all parallel route slots (`app/@*/`)
+- [ ] Create `default.tsx` in each slot that doesn't have one
+
+### 7. Image Optimization Changes
+
+#### 7.1 Local Images with Query Strings
+
+```tsx
+// Now requires explicit configuration
+<Image src="/assets/photo?v=1" alt="Photo" width="100" height="100" />
+```
+
+```js
+// next.config.js
+module.exports = {
+  images: {
+    localPatterns: [
+      {
+        pathname: '/assets/**',
+        search: '?v=1',
+      },
+    ],
+  },
+};
+```
+
+#### 7.2 Default Value Changes
+
+Add these to `next.config.js` if you need the old defaults:
+
+```js
+module.exports = {
+  images: {
+    // minimumCacheTTL changed from 60 to 14400 seconds
+    minimumCacheTTL: 60,
+
+    // Value 16 removed from default imageSizes
+    imageSizes: [16, 32, 48, 64, 96, 128, 256, 384],
+
+    // qualities now defaults to [75] only
+    qualities: [50, 75, 100],
+
+    // Local IP now blocked by default
+    dangerouslyAllowLocalIP: true, // only for private networks
+
+    // Maximum redirects changed from unlimited to 3
+    maximumRedirects: 5,
+  },
+};
+```
+
+#### 7.3 Deprecated images.domains
+
+```js
+// BEFORE - Remove this
+module.exports = {
+  images: {
+    domains: ['example.com'],
+  },
+};
+
+// AFTER - Use remotePatterns instead
+module.exports = {
+  images: {
+    remotePatterns: [
+      {
+        protocol: 'https',
+        hostname: 'example.com',
+      },
+    ],
+  },
+};
+```
+
+**Action Items**:
+
+- [ ] Add `localPatterns` for images with query strings
+- [ ] Migrate `images.domains` to `images.remotePatterns`
+- [ ] Review and update default values if needed
+
+### 8. Caching API Updates
+
+#### 8.1 Remove unstable\_ Prefix
+
+```ts
+// BEFORE (Next.js 15)
+import {
+  unstable_cacheLife as cacheLife,
+  unstable_cacheTag as cacheTag,
+} from 'next/cache';
+
+// AFTER (Next.js 16)
+import { cacheLife, cacheTag } from 'next/cache';
+```
+
+#### 8.2 New Cache Functions
+
+**revalidateTag with cacheLife profile**:
+
+```ts
+'use server';
+import { revalidateTag } from 'next/cache';
+
+export async function updateArticle(articleId: string) {
+  revalidateTag(`article-${articleId}`, 'max');
+}
+```
+
+**updateTag (new)**:
+
+```ts
+'use server';
+import { updateTag } from 'next/cache';
+
+export async function updateUserProfile(userId: string, profile: Profile) {
+  await db.users.update(userId, profile);
+  updateTag(`user-${userId}`);
+}
+```
+
+**refresh (new)**:
+
+```ts
+'use server';
+import { refresh } from 'next/cache';
+
+export async function markNotificationAsRead(notificationId: string) {
+  await db.notifications.markAsRead(notificationId);
+  refresh();
+}
+```
+
+**Action Items**:
+
+- [ ] Remove `unstable_` prefix from `cacheLife` and `cacheTag` imports
+- [ ] Consider using new `updateTag` and `refresh` functions
+
+### 9. React Compiler Support
+
+React Compiler is now stable and supported:
+
+```ts
+// next.config.ts
+const nextConfig = {
+  reactCompiler: true,
+};
+
+export default nextConfig;
+```
+
+Install the plugin:
+
+```bash
+npm install -D babel-plugin-react-compiler
+```
+
+**Note**: Expect higher compile times with React Compiler enabled.
+
+### 10. Scroll Behavior Override
+
+Next.js no longer overrides `scroll-behavior: smooth` during navigation.
+
+To restore previous behavior:
+
+```tsx
+// app/layout.tsx
+export default function RootLayout({ children }) {
+  return (
+    <html lang="en" data-scroll-behavior="smooth">
+      <body>{children}</body>
+    </html>
+  );
+}
+```
+
+### 11. ESLint Migration
+
+The `next lint` command has been removed. Migrate to ESLint CLI directly.
+
+```bash
+# Run migration codemod
+npx @next/codemod@canary next-lint-to-eslint-cli .
+```
+
+Remove from `next.config.js`:
+
+```js
+// Remove this
+{
+  eslint: {
+  }
+}
+```
+
+**Action Items**:
+
+- [ ] Run the ESLint migration codemod
+- [ ] Remove `eslint` config from `next.config.js`
+- [ ] Update CI scripts to use `eslint` directly instead of `next lint`
+
+### 12. Feature Removals
+
+#### 12.1 AMP Support Removed
+
+- All AMP APIs have been deleted
+- Remove `useAmp` hook usage
+- Remove `amp` config option
+- Delete AMP-specific pages
+
+#### 12.2 Runtime Configuration Removed
+
+```js
+// BEFORE - Remove these
+module.exports = {
+  serverRuntimeConfig: { dbUrl: process.env.DATABASE_URL },
+  publicRuntimeConfig: { apiUrl: '/api' },
+};
+```
+
+**Migration for server-side config**:
+
+```tsx
+// Use environment variables directly
+async function fetchData() {
+  const dbUrl = process.env.DATABASE_URL;
+  return await db.query(dbUrl, 'SELECT * FROM users');
+}
+```
+
+**Migration for client-side config**:
+
+```bash
+# .env.local
+NEXT_PUBLIC_API_URL="/api"
+```
+
+```tsx
+'use client';
+export default function Component() {
+  const apiUrl = process.env.NEXT_PUBLIC_API_URL;
+  // ...
+}
+```
+
+#### 12.3 devIndicators Options Removed
+
+Remove these from `next.config.js`:
+
+- `appIsrStatus`
+- `buildActivity`
+- `buildActivityPosition`
+
+#### 12.4 experimental.dynamicIO Renamed
+
+```js
+// BEFORE
+{
+  experimental: {
+    dynamicIO: true;
+  }
+}
+
+// AFTER
+{
+  cacheComponents: true;
+}
+```
+
+#### 12.5 unstable_rootParams Removed
+
+This API is removed. Await alternative API in a future minor release.
+
+**Action Items**:
+
+- [ ] Remove all AMP-related code
+- [ ] Migrate runtime configuration to environment variables
+- [ ] Remove deprecated devIndicators options
+- [ ] Rename `dynamicIO` to `cacheComponents`
+
+### 13. Development Changes
+
+#### 13.1 Concurrent dev and build
+
+Development now outputs to `.next/dev` (separate from build).
+
+**Update Turbopack tracing command**:
+
+```bash
+npx next internal trace .next/dev/trace-turbopack
+```
+
+## Post-Migration Validation
+
+### 1. Run Build Per Project
+
+```bash
+# Build each Next.js project individually
+nx run PROJECT_NAME:build
+```
+
+### 2. Run Development Server
+
+```bash
+# Start dev server to verify Turbopack works
+nx run PROJECT_NAME:serve
+```
+
+### 3. Run All Affected Builds
+
+```bash
+# Build all affected projects
+nx affected -t build
+```
+
+### 4. Run Full Validation
+
+```bash
+# Run full CI validation
+nx prepush
+```
+
+### 5. Review Migration Checklist
+
+- [ ] All async request APIs updated
+- [ ] All page/layout components using params are async
+- [ ] Turbopack configuration updated
+- [ ] Middleware renamed to proxy
+- [ ] Parallel routes have default.js files
+- [ ] Image configuration updated
+- [ ] Cache imports updated (removed unstable\_ prefix)
+- [ ] AMP code removed
+- [ ] Runtime config migrated to env vars
+- [ ] ESLint configuration migrated
+- [ ] All projects build successfully
+- [ ] Development servers start correctly
+
+## Common Issues and Solutions
+
+### Issue: "cookies() expects to be called in a synchronous context"
+
+**Solution**: Make the function async and await `cookies()`
+
+### Issue: "params should be awaited before accessing properties"
+
+**Solution**: Add `await` before accessing `props.params`
+
+### Issue: Build fails with Turbopack
+
+**Solution**: Add `--webpack` flag to build script, then gradually address Turbopack compatibility
+
+### Issue: Middleware not working after rename
+
+**Solution**: Ensure both file and function are renamed from `middleware` to `proxy`
+
+### Issue: Parallel route not rendering
+
+**Solution**: Add `default.tsx` file to the parallel route slot
+
+### Issue: Images with query strings not loading
+
+**Solution**: Add `localPatterns` configuration for those images
+
+### Issue: TypeScript errors with params types
+
+**Solution**: Run `npx next typegen` to generate type helpers, then use `PageProps`, `LayoutProps` types
+
+## Files to Review
+
+Create a checklist of all files that need review:
+
+```bash
+# Find all pages with potential params usage
+find . -path "*/app/*" -name "page.tsx" -o -name "page.ts" | xargs grep -l "params\|searchParams"
+
+# Find all layouts
+find . -path "*/app/*" -name "layout.tsx" -o -name "layout.ts"
+
+# Find all route handlers
+find . -path "*/app/*" -name "route.ts" -o -name "route.tsx"
+
+# Find middleware files
+find . -name "middleware.ts" -o -name "middleware.js"
+
+# Find files using cookies/headers
+rg "from 'next/headers'" --type ts --type tsx
+
+# Find next.config files
+find . -name "next.config.*" -not -path "*/node_modules/*"
+
+# Find parallel routes
+find . -path "*/app/@*" -type d
+```
+
+## Migration Strategy for Large Workspaces
+
+1. **Migrate in phases**: Start with a small project, validate, then expand
+2. **Use the codemod**: Run `npx @next/codemod@canary upgrade latest` for automated fixes
+3. **Generate types**: Run `npx next typegen` for type-safe migrations
+4. **Run tests frequently**: After each configuration change, run affected tests
+5. **Document issues**: Keep track of project-specific issues and solutions
+
+## Useful Commands During Migration
+
+```bash
+# Find all Next.js projects
+nx show projects --with-target build
+
+# Build specific project
+nx build PROJECT_NAME
+
+# Serve specific project
+nx serve PROJECT_NAME
+
+# Build all affected
+nx affected -t build
+
+# View project details
+nx show project PROJECT_NAME --web
+
+# Clear Nx cache if needed
+nx reset
+```
+
+---
+
+## Notes for LLM Execution
+
+When executing this migration:
+
+1. **Work systematically**: Complete one category before moving to the next
+2. **Test after each change**: Don't batch all changes without validation
+3. **Keep user informed**: Report progress through each section
+4. **Handle errors promptly**: If builds fail, fix immediately before proceeding
+5. **Use the codemod first**: Let `@next/codemod` handle repetitive async/await changes
+6. **Prioritize breaking changes**: Focus on async APIs first as they're most impactful
+7. **Create meaningful commits**: Group related changes together with clear messages
+8. **Use TodoWrite tool**: Track migration progress for visibility
diff --git a/packages/node/src/generators/application/application.spec.ts b/packages/node/src/generators/application/application.spec.ts
index bc998e0bae..d55c86c394 100644
--- a/packages/node/src/generators/application/application.spec.ts
+++ b/packages/node/src/generators/application/application.spec.ts
@@ -967,7 +967,7 @@ describe('app', () => {
               assets: ["./src/assets"],
               optimization: false,
               outputHashing: 'none',
-              generatePackageJson: true,
+              generatePackageJson: false,
               sourceMaps: true,
             })
           ],
diff --git a/packages/node/src/generators/application/files/common/webpack.config.js__tmpl__ b/packages/node/src/generators/application/files/common/webpack.config.js__tmpl__
index 7b2284be96..f23af4c19a 100644
--- a/packages/node/src/generators/application/files/common/webpack.config.js__tmpl__
+++ b/packages/node/src/generators/application/files/common/webpack.config.js__tmpl__
@@ -19,7 +19,7 @@ module.exports = {
       assets: <%- JSON.stringify(webpackPluginOptions.assets) %>,
       optimization: false,
       outputHashing: 'none',
-      generatePackageJson: true,
+      generatePackageJson: <%= webpackPluginOptions.generatePackageJson %>,
       sourceMaps: true,
     })
   ],
diff --git a/packages/node/src/generators/application/lib/create-files.ts b/packages/node/src/generators/application/lib/create-files.ts
index a9cf1614dc..9dd8b39c43 100644
--- a/packages/node/src/generators/application/lib/create-files.ts
+++ b/packages/node/src/generators/application/lib/create-files.ts
@@ -39,6 +39,7 @@ export function addAppFiles(tree: Tree, options: NormalizedSchema) {
               main: './src/main' + (options.js ? '.js' : '.ts'),
               tsConfig: './tsconfig.app.json',
               assets: ['./src/assets'],
+              generatePackageJson: !options.isUsingTsSolutionConfig,
             }
           : null,
     }
diff --git a/packages/nx/bin/init-local.ts b/packages/nx/bin/init-local.ts
index 363b77c12c..193dc31b5d 100644
--- a/packages/nx/bin/init-local.ts
+++ b/packages/nx/bin/init-local.ts
@@ -3,7 +3,9 @@ import { performance } from 'perf_hooks';
 import { commandsObject } from '../src/command-line/nx-commands';
 import { WorkspaceTypeAndRoot } from '../src/utils/find-workspace-root';
 import { stripIndents } from '../src/utils/strip-indents';
-import { ensureNxConsoleInstalled } from '../src/utils/nx-console-prompt';
+import { daemonClient } from '../src/daemon/client/client';
+import { prompt } from 'enquirer';
+import { output } from '../src/utils/output';
 
 /**
  * Nx is being run inside a workspace.
@@ -33,7 +35,7 @@ export async function initLocal(workspace: WorkspaceTypeAndRoot) {
 
     // Ensure NxConsole is installed if the user has it configured.
     try {
-      await ensureNxConsoleInstalled();
+      await ensureNxConsoleInstalledViaDaemon();
     } catch {}
 
     const command = process.argv[2];
@@ -121,6 +123,51 @@ function shouldDelegateToAngularCLI() {
   return commands.indexOf(command) > -1;
 }
 
+async function ensureNxConsoleInstalledViaDaemon(): Promise<void> {
+  // Only proceed if daemon is available
+  if (!daemonClient.enabled()) {
+    return;
+  }
+
+  // Get status from daemon
+  const status = await daemonClient.getNxConsoleStatus();
+
+  // If we should prompt the user
+  if (status.shouldPrompt && process.stdout.isTTY) {
+    output.log({
+      title: "Install Nx's official editor extension to:",
+      bodyLines: [
+        '- Enable your AI assistant to do more by understanding your workspace',
+        '- Add IntelliSense for Nx configuration files',
+        '- Explore your workspace visually',
+      ],
+    });
+
+    try {
+      const { shouldInstallNxConsole } = await prompt<{
+        shouldInstallNxConsole: boolean;
+      }>({
+        type: 'confirm',
+        name: 'shouldInstallNxConsole',
+        message: 'Install Nx Console? (you can uninstall anytime)',
+        initial: true,
+      });
+
+      // Set preference and install if user said yes
+      const result = await daemonClient.setNxConsolePreferenceAndInstall(
+        shouldInstallNxConsole
+      );
+
+      if (result.installed) {
+        output.log({ title: 'Successfully installed Nx Console!' });
+      }
+    } catch (error) {
+      // User cancelled or error occurred, save preference as false
+      await daemonClient.setNxConsolePreferenceAndInstall(false);
+    }
+  }
+}
+
 function handleAngularCLIFallbacks(workspace: WorkspaceTypeAndRoot) {
   if (process.argv[2] === 'update' && process.env.FORCE_NG_UPDATE != 'true') {
     console.log(
diff --git a/packages/nx/release/changelog-renderer/index.spec.ts b/packages/nx/release/changelog-renderer/index.spec.ts
index 5eaad7cd47..de0497f231 100644
--- a/packages/nx/release/changelog-renderer/index.spec.ts
+++ b/packages/nx/release/changelog-renderer/index.spec.ts
@@ -708,20 +708,20 @@ describe('ChangelogRenderer', () => {
         }).render();
 
         expect(markdown).toMatchInlineSnapshot(`
-                  "## v1.1.0
+          "## v1.1.0
 
-                  ### ðŸš€ Features
+          ### ðŸš€ Features
 
-                  - âš ï¸  **WebSocketSubject:** no longer extends \`Subject\`.
+          - âš ï¸  **WebSocketSubject:** no longer extends \`Subject\`.
 
-                  ### âš ï¸  Breaking Changes
+          ### âš ï¸  Breaking Changes
 
-                  - âš ï¸  **WebSocketSubject:** no longer extends \`Subject\`.
+          - **WebSocketSubject:** no longer extends \`Subject\`.
 
-                  ### â¤ï¸ Thank You
+          ### â¤ï¸ Thank You
 
-                  - James Henry"
-              `);
+          - James Henry"
+        `);
       });
 
       it('should extract the explanation of a breaking change and render it preferentially with references', async () => {
diff --git a/packages/nx/release/changelog-renderer/index.ts b/packages/nx/release/changelog-renderer/index.ts
index e9926be2d7..4d63ca0cc0 100644
--- a/packages/nx/release/changelog-renderer/index.ts
+++ b/packages/nx/release/changelog-renderer/index.ts
@@ -408,42 +408,44 @@ export default class DefaultChangelogRenderer {
     return changeLine;
   }
 
-  protected formatBreakingChange(change: ChangelogChange): string {
-    const explanation = this.extractBreakingChangeExplanation(change.body);
-
-    if (!explanation) {
-      // No explanation found, use the regular formatChange which includes references
-      return this.formatChange(change);
-    }
-
-    // Build the breaking change line with scope, explanation, and references
+  protected formatBreakingChangeBase(change: ChangelogChange): string {
     let breakingLine = '- ';
 
     if (change.scope) {
       breakingLine += `**${change.scope.trim()}:** `;
     }
-    // Ensure first line of the breaking change contains the commit title
+
     if (change.description) {
-      breakingLine += `${change.description.trim()} `;
+      breakingLine += `${change.description.trim()}`;
     }
 
-    // Add PR/commit references
     if (
       this.remoteReleaseClient.getRemoteRepoData() &&
       this.changelogRenderOptions.commitReferences &&
       change.githubReferences
     ) {
-      breakingLine += `${this.remoteReleaseClient.formatReferences(
+      breakingLine += ` ${this.remoteReleaseClient.formatReferences(
         change.githubReferences
       )}`;
     }
 
+    return breakingLine;
+  }
+
+  protected formatBreakingChange(change: ChangelogChange): string {
+    const explanation = this.extractBreakingChangeExplanation(change.body);
+    const baseLine = this.formatBreakingChangeBase(change);
+
+    if (!explanation) {
+      return baseLine;
+    }
+
     const indentation = '  ';
-    breakingLine += `\n${indentation}`;
+    let breakingLine = baseLine + `\n${indentation}`;
 
     // Handle multi-line explanations
     let explanationText = explanation;
-    let extraLines = [];
+    let extraLines: string[] = [];
     if (explanation.includes('\n')) {
       [explanationText, ...extraLines] = explanation.split('\n');
     }
diff --git a/packages/nx/src/ai/constants.ts b/packages/nx/src/ai/constants.ts
index 5f228596d0..2726cef069 100644
--- a/packages/nx/src/ai/constants.ts
+++ b/packages/nx/src/ai/constants.ts
@@ -1,6 +1,6 @@
-import { readFileSync } from 'fs';
 import { homedir } from 'os';
 import { join } from 'path';
+import { major } from 'semver';
 import { readJsonFile } from '../utils/fileutils';
 import { getAgentRules } from './set-up-ai-agents/get-agent-rules';
 
@@ -49,8 +49,18 @@ export const getAgentRulesWrapped = (writeNxCloudRules: boolean) => {
 };
 
 export const nxMcpTomlHeader = `[mcp_servers."nx-mcp"]`;
-export const nxMcpTomlConfig = `${nxMcpTomlHeader}
+
+/**
+ * Get the MCP TOML configuration based on the Nx version.
+ * For Nx 22+, uses 'nx mcp'
+ * For Nx < 22, uses 'nx-mcp'
+ */
+export function getNxMcpTomlConfig(nxVersion: string): string {
+  const majorVersion = major(nxVersion);
+  const args = majorVersion >= 22 ? '["nx", "mcp"]' : '["nx-mcp"]';
+  return `${nxMcpTomlHeader}
 type = "stdio"
 command = "npx"
-args = ["nx", "mcp"]
+args = ${args}
 `;
+}
diff --git a/packages/nx/src/ai/set-up-ai-agents/set-up-ai-agents.spec.ts b/packages/nx/src/ai/set-up-ai-agents/set-up-ai-agents.spec.ts
index 74f1196705..4e53adf5c7 100644
--- a/packages/nx/src/ai/set-up-ai-agents/set-up-ai-agents.spec.ts
+++ b/packages/nx/src/ai/set-up-ai-agents/set-up-ai-agents.spec.ts
@@ -5,18 +5,33 @@ import { setupAiAgentsGenerator } from './set-up-ai-agents';
 import { SetupAiAgentsGeneratorSchema } from './schema';
 import { readJson } from '../../generators/utils/json';
 import { getAgentRulesWrapped } from '../constants';
+import * as packageJsonUtils from '../../utils/package-json';
+import * as fs from 'fs';
 
 describe('setup-ai-agents generator', () => {
   let tree: Tree;
+  let readModulePackageJsonSpy: jest.SpyInstance;
 
   beforeEach(() => {
     tree = createTreeWithEmptyWorkspace();
     // Use local implementation instead of fetching from latest
     process.env.NX_AI_FILES_USE_LOCAL = 'true';
+
+    // Mock readModulePackageJson to return Nx 22+ by default
+    // This ensures existing tests pass by defaulting to the new format
+    readModulePackageJsonSpy = jest
+      .spyOn(packageJsonUtils, 'readModulePackageJson')
+      .mockReturnValue({
+        packageJson: { name: 'nx', version: '22.0.0' },
+        path: '/fake/path/package.json',
+      });
   });
 
   afterEach(() => {
     delete process.env.NX_AI_FILES_USE_LOCAL;
+    if (readModulePackageJsonSpy) {
+      readModulePackageJsonSpy.mockRestore();
+    }
   });
 
   it('should respect writeNxCloudRules option', async () => {
@@ -466,5 +481,101 @@ describe('setup-ai-agents generator', () => {
         expect(tree.exists('.gemini/settings.json')).toBe(false);
       });
     });
+
+    describe('Nx version-specific MCP configuration', () => {
+      it('should use "nx mcp" for Nx 22+', async () => {
+        readModulePackageJsonSpy.mockReturnValue({
+          packageJson: { name: 'nx', version: '22.0.0' },
+          path: '/fake/path/package.json',
+        });
+
+        const options: SetupAiAgentsGeneratorSchema = {
+          directory: '.',
+          agents: ['claude'],
+        };
+
+        await setupAiAgentsGenerator(tree, options);
+
+        const config = JSON.parse(tree.read('.mcp.json')?.toString() ?? '{}');
+        expect(config.mcpServers['nx-mcp']).toEqual({
+          type: 'stdio',
+          command: 'npx',
+          args: ['nx', 'mcp'],
+        });
+      });
+
+      it('should use "nx-mcp" for Nx < 22', async () => {
+        readModulePackageJsonSpy.mockReturnValue({
+          packageJson: { name: 'nx', version: '21.0.0' },
+          path: '/fake/path/package.json',
+        });
+
+        const options: SetupAiAgentsGeneratorSchema = {
+          directory: '.',
+          agents: ['claude'],
+        };
+
+        await setupAiAgentsGenerator(tree, options);
+
+        const config = JSON.parse(tree.read('.mcp.json')?.toString() ?? '{}');
+        expect(config.mcpServers['nx-mcp']).toEqual({
+          type: 'stdio',
+          command: 'npx',
+          args: ['nx-mcp'],
+        });
+      });
+
+      it('should use "nx mcp" as fallback when version cannot be determined', async () => {
+        readModulePackageJsonSpy.mockImplementation(() => {
+          throw new Error('Module not found');
+        });
+
+        // Also mock readFileSync to fail so it falls back to default version
+        const readFileSyncSpy = jest
+          .spyOn(fs, 'readFileSync')
+          .mockImplementation(() => {
+            throw new Error('File not found');
+          });
+
+        const options: SetupAiAgentsGeneratorSchema = {
+          directory: '.',
+          agents: ['claude'],
+        };
+
+        await setupAiAgentsGenerator(tree, options);
+
+        const config = JSON.parse(tree.read('.mcp.json')?.toString() ?? '{}');
+        expect(config.mcpServers['nx-mcp']).toEqual({
+          type: 'stdio',
+          command: 'npx',
+          args: ['nx', 'mcp'],
+        });
+
+        readFileSyncSpy.mockRestore();
+      });
+
+      it('should use "nx mcp" for Nx 23+', async () => {
+        readModulePackageJsonSpy.mockReturnValue({
+          packageJson: { name: 'nx', version: '23.1.0' },
+          path: '/fake/path/package.json',
+        });
+
+        const options: SetupAiAgentsGeneratorSchema = {
+          directory: '.',
+          agents: ['gemini'],
+        };
+
+        await setupAiAgentsGenerator(tree, options);
+
+        const config = JSON.parse(
+          tree.read('.gemini/settings.json')?.toString() ?? '{}'
+        );
+        expect(config.mcpServers['nx-mcp']).toEqual({
+          type: 'stdio',
+          command: 'npx',
+          args: ['nx', 'mcp'],
+        });
+      });
+    });
   });
 });
diff --git a/packages/nx/src/ai/set-up-ai-agents/set-up-ai-agents.ts b/packages/nx/src/ai/set-up-ai-agents/set-up-ai-agents.ts
index f51b4da229..2627a0a827 100644
--- a/packages/nx/src/ai/set-up-ai-agents/set-up-ai-agents.ts
+++ b/packages/nx/src/ai/set-up-ai-agents/set-up-ai-agents.ts
@@ -7,6 +7,7 @@ import {
 } from 'fs';
 import { homedir } from 'os';
 import { join } from 'path';
+import { major } from 'semver';
 import { formatChangedFilesWithPrettierIfAvailable } from '../../generators/internal-utils/format-changed-files-with-prettier-if-available';
 import { Tree } from '../../generators/tree';
 import { readJson, updateJson, writeJson } from '../../generators/utils/json';
@@ -20,13 +21,17 @@ import {
   CLIErrorMessageConfig,
   CLINoteMessageConfig,
 } from '../../utils/output';
-import { installPackageToTmp } from '../../utils/package-json';
+import {
+  installPackageToTmp,
+  readModulePackageJson,
+} from '../../utils/package-json';
 import { ensurePackageHasProvenance } from '../../utils/provenance';
+import { workspaceRoot } from '../../utils/workspace-root';
 import { agentsMdPath, codexConfigTomlPath, geminiMdPath } from '../constants';
 import { Agent, supportedAgents } from '../utils';
 import {
   getAgentRulesWrapped,
-  nxMcpTomlConfig,
+  getNxMcpTomlConfig,
   nxMcpTomlHeader,
   nxRulesMarkerCommentDescription,
   nxRulesMarkerCommentEnd,
@@ -43,6 +48,39 @@ export type ModificationResults = {
   errors: CLIErrorMessageConfig[];
 };
 
+/**
+ * Get the installed Nx version, with fallback to workspace package.json or default version.
+ */
+function getNxVersion(): string {
+  try {
+    // Try to read from node_modules first
+    const {
+      packageJson: { version },
+    } = readModulePackageJson('nx');
+    return version;
+  } catch {
+    try {
+      // Fallback: try to read from workspace package.json
+      const workspacePackageJson = JSON.parse(
+        readFileSync(join(workspaceRoot, 'package.json'), 'utf-8')
+      );
+      // Check devDependencies first, then dependencies
+      const nxVersion =
+        workspacePackageJson.devDependencies?.nx ||
+        workspacePackageJson.dependencies?.nx;
+      if (nxVersion) {
+        // Remove any semver range characters (^, ~, >=, etc.)
+        return nxVersion.replace(/^[\^~>=<]+/, '');
+      }
+      throw new Error('Nx not found in package.json');
+    } catch {
+      // If we can't determine the version, default to the newer format
+      // This handles cases where nx might not be installed or is globally installed
+      return '22.0.0';
+    }
+  }
+}
+
 export async function setupAiAgentsGenerator(
   tree: Tree,
   options: SetupAiAgentsGeneratorSchema,
@@ -100,6 +138,7 @@ export async function setupAiAgentsGeneratorImpl(
   options: NormalizedSetupAiAgentsGeneratorSchema
 ): Promise<() => Promise<ModificationResults>> {
   const hasAgent = (agent: Agent) => options.agents.includes(agent);
+  const nxVersion = getNxVersion();
 
   const agentsMd = agentsMdPath(options.directory);
 
@@ -116,7 +155,7 @@ export async function setupAiAgentsGeneratorImpl(
     if (!tree.exists(mcpJsonPath)) {
       writeJson(tree, mcpJsonPath, {});
     }
-    updateJson(tree, mcpJsonPath, mcpConfigUpdater);
+    updateJson(tree, mcpJsonPath, (json) => mcpConfigUpdater(json, nxVersion));
   }
 
   if (hasAgent('gemini')) {
@@ -128,7 +167,9 @@ export async function setupAiAgentsGeneratorImpl(
     if (!tree.exists(geminiSettingsPath)) {
       writeJson(tree, geminiSettingsPath, {});
     }
-    updateJson(tree, geminiSettingsPath, mcpConfigUpdater);
+    updateJson(tree, geminiSettingsPath, (json) =>
+      mcpConfigUpdater(json, nxVersion)
+    );
 
     const contextFileName: string | undefined = readJson(
       tree,
@@ -164,7 +205,10 @@ export async function setupAiAgentsGeneratorImpl(
         const tomlContents = readFileSync(codexConfigTomlPath, 'utf-8');
         if (!tomlContents.includes(nxMcpTomlHeader)) {
           if (!check) {
-            appendFileSync(codexConfigTomlPath, `\n${nxMcpTomlConfig}`);
+            appendFileSync(
+              codexConfigTomlPath,
+              `\n${getNxMcpTomlConfig(nxVersion)}`
+            );
           }
           messages.push({
             title: `Updated ${codexConfigTomlPath} with nx-mcp server`,
@@ -173,7 +217,7 @@ export async function setupAiAgentsGeneratorImpl(
       } else {
         if (!check) {
           mkdirSync(join(homedir(), '.codex'), { recursive: true });
-          writeFileSync(codexConfigTomlPath, nxMcpTomlConfig);
+          writeFileSync(codexConfigTomlPath, getNxMcpTomlConfig(nxVersion));
         }
         messages.push({
           title: `Created ${codexConfigTomlPath} with nx-mcp server`,
@@ -281,19 +325,22 @@ function writeAgentRules(tree: Tree, path: string, writeNxCloudRules: boolean) {
   }
 }
 
-function mcpConfigUpdater(existing: any): any {
+function mcpConfigUpdater(existing: any, nxVersion: string): any {
+  const majorVersion = major(nxVersion);
+  const mcpArgs = majorVersion >= 22 ? ['nx', 'mcp'] : ['nx-mcp'];
+
   if (existing.mcpServers) {
     existing.mcpServers['nx-mcp'] = {
       type: 'stdio',
       command: 'npx',
-      args: ['nx', 'mcp'],
+      args: mcpArgs,
     };
   } else {
     existing.mcpServers = {
       'nx-mcp': {
         type: 'stdio',
         command: 'npx',
-        args: ['nx', 'mcp'],
+        args: mcpArgs,
       },
     };
   }
diff --git a/packages/nx/src/command-line/report/report.ts b/packages/nx/src/command-line/report/report.ts
index 017ac3d72c..cea61a3fbf 100644
--- a/packages/nx/src/command-line/report/report.ts
+++ b/packages/nx/src/command-line/report/report.ts
@@ -3,6 +3,7 @@ import { output } from '../../utils/output';
 import { join } from 'path';
 import {
   detectPackageManager,
+  getPackageManagerCommand,
   getPackageManagerVersion,
   PackageManager,
 } from '../../utils/package-manager';
@@ -23,6 +24,8 @@ import { getNxRequirePaths } from '../../utils/installation-directory';
 import { NxJsonConfiguration, readNxJson } from '../../config/nx-json';
 import { ProjectGraph } from '../../config/project-graph';
 import { ProjectGraphError } from '../../project-graph/error-types';
+import { reverse } from '../../project-graph/operators';
+import { nxVersion } from '../../utils/versions';
 import {
   getNxKeyInformation,
   NxKeyNotInstalledError,
@@ -79,6 +82,7 @@ export async function reportHandler() {
     registeredPlugins,
     packageVersionsWeCareAbout,
     outOfSyncPackageGroup,
+    mismatchedNxVersions,
     projectGraphError,
     nativeTarget,
     cache,
@@ -221,6 +225,32 @@ export async function reportHandler() {
     );
   }
 
+  if (mismatchedNxVersions && mismatchedNxVersions.length > 0) {
+    bodyLines.push(LINE_SEPARATOR);
+    bodyLines.push(chalk.yellow('âš ï¸ Multiple Nx versions detected'));
+    bodyLines.push('');
+    bodyLines.push(
+      `Your workspace uses nx@${nxVersion}, but other packages depend on a different version:`
+    );
+    for (const { version, chain } of mismatchedNxVersions) {
+      if (chain.length === 0) {
+        bodyLines.push(`  - ${chalk.bold(`nx@${version}`)}`);
+      } else {
+        bodyLines.push(
+          `  - ${chain.reverse().join(' â†’ ')} â†’ ${chalk.bold(`nx@${version}`)}`
+        );
+      }
+    }
+    bodyLines.push('');
+    bodyLines.push(
+      'These packages should not have nx as a dependency. Please report this issue to the package maintainers.'
+    );
+    const whyCommand = getPackageManagerCommand(pm).why;
+    for (const { version } of mismatchedNxVersions) {
+      bodyLines.push(`Run \`${whyCommand} nx@${version}\` for more details.`);
+    }
+  }
+
   if (projectGraphError) {
     bodyLines.push(LINE_SEPARATOR);
     bodyLines.push('âš ï¸ Unable to construct project graph.');
@@ -255,6 +285,10 @@ export interface ReportData {
     }[];
     migrateTarget: string;
   };
+  mismatchedNxVersions?: Array<{
+    version: string;
+    chain: string[];
+  }>;
   projectGraphError?: Error | null;
   nativeTarget: string | null;
   cache: {
@@ -263,6 +297,71 @@ export interface ReportData {
   } | null;
 }
 
+function findDependencyChain(
+  graph: ProjectGraph,
+  targetNode: string
+): string[] {
+  const reversedGraph = reverse(graph);
+
+  // BFS to find shortest path to root dependency
+  const queue: { node: string; path: string[] }[] = [
+    { node: targetNode, path: [] },
+  ];
+  const visited = new Set<string>();
+
+  while (queue.length > 0) {
+    const { node, path } = queue.shift()!;
+
+    if (visited.has(node)) continue;
+    visited.add(node);
+
+    const deps = reversedGraph.dependencies[node] || [];
+
+    // Check for unvisited dependents
+    const unvisitedDeps = deps.filter((dep) => !visited.has(dep.target));
+
+    // No unvisited dependents - this is our shortest path
+    if (unvisitedDeps.length === 0) {
+      return path;
+    }
+
+    for (const dep of unvisitedDeps) {
+      const depName =
+        graph.externalNodes?.[dep.target]?.data?.packageName ?? dep.target;
+      queue.push({
+        node: dep.target,
+        path: [...path, depName],
+      });
+    }
+  }
+
+  return [];
+}
+
+function findMismatchedNxVersions(
+  graph: ProjectGraph
+): Array<{ version: string; chain: string[] }> {
+  if (!graph || !graph.externalNodes) {
+    return [];
+  }
+
+  const result: Array<{ version: string; chain: string[] }> = [];
+
+  // Find all nx package versions that don't match the workspace version
+  for (const nodeName of Object.keys(graph.externalNodes)) {
+    const node = graph.externalNodes[nodeName];
+    if (node.data?.packageName === 'nx') {
+      const version = node.data.version || 'unknown';
+      if (version !== nxVersion) {
+        const chain = findDependencyChain(graph, nodeName);
+        result.push({ version, chain });
+      }
+    }
+  }
+
+  return result;
+}
+
 export async function getReportData(): Promise<ReportData> {
   const pm = detectPackageManager();
   const pmVersion = getPackageManagerVersion(pm);
@@ -289,6 +388,8 @@ export async function getReportData(): Promise<ReportData> {
 
   const outOfSyncPackageGroup = findMisalignedPackagesForPackage(nxPackageJson);
 
+  const mismatchedNxVersions = findMismatchedNxVersions(graph);
+
   const native = isNativeAvailable();
 
   let nxKey = null;
@@ -319,6 +420,7 @@ export async function getReportData(): Promise<ReportData> {
     registeredPlugins,
     packageVersionsWeCareAbout,
     outOfSyncPackageGroup,
+    mismatchedNxVersions,
     projectGraphError,
     nativeTarget: native ? native.getBinaryTarget() : null,
     cache,
diff --git a/packages/nx/src/daemon/cache.ts b/packages/nx/src/daemon/cache.ts
index 3c4160afb9..435955f5c2 100644
--- a/packages/nx/src/daemon/cache.ts
+++ b/packages/nx/src/daemon/cache.ts
@@ -2,9 +2,12 @@ import { existsSync, unlinkSync } from 'node:fs';
 import { join } from 'path';
 import { DAEMON_DIR_FOR_CURRENT_WORKSPACE } from './tmp-dir';
 import { readJsonFile, writeJsonFileAsync } from '../utils/fileutils';
+import { nxVersion } from '../utils/versions';
 
 export interface DaemonProcessJson {
   processId: number;
+  socketPath: string;
+  nxVersion: string;
 }
 
 export const serverProcessJsonPath = join(
@@ -13,10 +16,16 @@ export const serverProcessJsonPath = join(
 );
 
 export function readDaemonProcessJsonCache(): DaemonProcessJson | null {
-  if (!existsSync(serverProcessJsonPath)) {
+  try {
+    const daemonJson = readJsonFile(serverProcessJsonPath);
+    // If the daemon version doesn't match the client version, treat it as stale
+    if (daemonJson.nxVersion !== nxVersion) {
+      return null;
+    }
+    return daemonJson;
+  } catch {
     return null;
   }
-  return readJsonFile(serverProcessJsonPath);
 }
 
 export function deleteDaemonJsonProcessCache(): void {
@@ -35,31 +44,6 @@ export async function writeDaemonJsonProcessCache(
   });
 }
 
-export async function waitForDaemonToExitAndCleanupProcessJson(): Promise<void> {
-  const daemonProcessJson = readDaemonProcessJsonCache();
-  if (daemonProcessJson && daemonProcessJson.processId) {
-    await new Promise<void>((resolve, reject) => {
-      let count = 0;
-      const interval = setInterval(() => {
-        try {
-          // sending a signal 0 to a process checks if the process is running instead of actually killing it
-          process.kill(daemonProcessJson.processId, 0);
-        } catch (e) {
-          clearInterval(interval);
-          resolve();
-        }
-        if ((count += 1) > 200) {
-          clearInterval(interval);
-          reject(
-            `Daemon process ${daemonProcessJson.processId} didn't exit after 2 seconds.`
-          );
-        }
-      }, 10);
-    });
-    deleteDaemonJsonProcessCache();
-  }
-}
-
 // Must be sync for the help output use case
 export function getDaemonProcessIdSync(): number | null {
   if (!existsSync(serverProcessJsonPath)) {
diff --git a/packages/nx/src/daemon/client/client.ts b/packages/nx/src/daemon/client/client.ts
index 1fb05e632a..f1ee085d46 100644
--- a/packages/nx/src/daemon/client/client.ts
+++ b/packages/nx/src/daemon/client/client.ts
@@ -12,7 +12,6 @@ import { connect } from 'net';
 import { join } from 'path';
 import { performance } from 'perf_hooks';
 import { output } from '../../utils/output';
-import { getFullOsSocketPath, killSocketOrPath } from '../socket-utils';
 import {
   DAEMON_DIR_FOR_CURRENT_WORKSPACE,
   DAEMON_OUTPUT_LOG_FILE,
@@ -25,10 +24,8 @@ import { hasNxJson, NxJsonConfiguration } from '../../config/nx-json';
 import { readNxJson } from '../../config/configuration';
 import { PromisedBasedQueue } from '../../utils/promised-based-queue';
 import { DaemonSocketMessenger, Message } from './daemon-socket-messenger';
-import {
-  getDaemonProcessIdSync,
-  waitForDaemonToExitAndCleanupProcessJson,
-} from '../cache';
+import { getDaemonProcessIdSync, readDaemonProcessJsonCache } from '../cache';
+import { isNxVersionMismatch } from '../is-nx-version-mismatch';
 import { Hash } from '../../hasher/task-hasher';
 import { Task, TaskGraph } from '../../config/task-graph';
 import { ConfigurationSourceMaps } from '../../project-graph/utils/project-configuration-utils';
@@ -100,6 +97,14 @@ import {
   PRE_TASKS_EXECUTION,
 } from '../message-types/run-tasks-execution-hooks';
 import { REGISTER_PROJECT_GRAPH_LISTENER } from '../message-types/register-project-graph-listener';
+import {
+  GET_NX_CONSOLE_STATUS,
+  type HandleGetNxConsoleStatusMessage,
+  type HandleSetNxConsolePreferenceAndInstallMessage,
+  type NxConsoleStatusResponse,
+  SET_NX_CONSOLE_PREFERENCE_AND_INSTALL,
+  type SetNxConsolePreferenceAndInstallResponse,
+} from '../message-types/nx-console';
 import { deserialize } from 'node:v8';
 import { isJsonMessage } from '../../utils/consume-messages-from-socket';
 import { isV8SerializerEnabled } from '../is-v8-serializer-enabled';
@@ -173,7 +178,9 @@ export class DaemonClient {
       // docker=true,env=false => no daemon
       // docker=true,env=true => daemon
       // WASM => no daemon because file watching does not work
+      // version mismatch => no daemon because the installed nx version differs from the running one
       if (
+        isNxVersionMismatch() ||
         ((isCI() || isDocker()) && env !== 'true') ||
         isDaemonDisabled() ||
         nxJsonIsNotPresent() ||
@@ -216,6 +223,18 @@ export class DaemonClient {
     );
   }
 
+  private getSocketPath(): string {
+    const daemonProcessJson = readDaemonProcessJsonCache();
+
+    if (daemonProcessJson?.socketPath) {
+      return daemonProcessJson.socketPath;
+    } else {
+      throw daemonProcessException(
+        'Unable to connect to daemon: no socket path available'
+      );
+    }
+  }
+
   async requestShutdown(): Promise<void> {
     return this.sendToDaemonViaQueue({ type: 'REQUEST_SHUTDOWN' });
   }
@@ -300,10 +319,12 @@ export class DaemonClient {
     }
     let messenger: DaemonSocketMessenger | undefined;
 
-    await this.queue.sendToQueue(() => {
-      messenger = new DaemonSocketMessenger(
-        connect(getFullOsSocketPath())
-      ).listen(
+    await this.queue.sendToQueue(async () => {
+      await this.startDaemonIfNecessary();
+
+      const socketPath = this.getSocketPath();
+
+      messenger = new DaemonSocketMessenger(connect(socketPath)).listen(
         (message) => {
           try {
             const parsedMessage = isJsonMessage(message)
@@ -338,10 +359,12 @@ export class DaemonClient {
   ): Promise<UnregisterCallback> {
     let messenger: DaemonSocketMessenger | undefined;
 
-    await this.queue.sendToQueue(() => {
-      messenger = new DaemonSocketMessenger(
-        connect(getFullOsSocketPath())
-      ).listen(
+    await this.queue.sendToQueue(async () => {
+      await this.startDaemonIfNecessary();
+
+      const socketPath = this.getSocketPath();
+
+      messenger = new DaemonSocketMessenger(connect(socketPath)).listen(
         (message) => {
           try {
             const parsedMessage = isJsonMessage(message)
@@ -552,10 +575,32 @@ export class DaemonClient {
     return this.sendToDaemonViaQueue(message);
   }
 
+  getNxConsoleStatus(): Promise<NxConsoleStatusResponse> {
+    const message: HandleGetNxConsoleStatusMessage = {
+      type: GET_NX_CONSOLE_STATUS,
+    };
+    return this.sendToDaemonViaQueue(message);
+  }
+
+  setNxConsolePreferenceAndInstall(
+    preference: boolean
+  ): Promise<SetNxConsolePreferenceAndInstallResponse> {
+    const message: HandleSetNxConsolePreferenceAndInstallMessage = {
+      type: SET_NX_CONSOLE_PREFERENCE_AND_INSTALL,
+      preference,
+    };
+    return this.sendToDaemonViaQueue(message);
+  }
+
   async isServerAvailable(): Promise<boolean> {
     return new Promise((resolve) => {
       try {
-        const socket = connect(getFullOsSocketPath(), () => {
+        const socketPath = this.getSocketPath();
+        if (!socketPath) {
+          resolve(false);
+          return;
+        }
+        const socket = connect(socketPath, () => {
           socket.destroy();
           resolve(true);
         });
@@ -568,6 +613,31 @@ export class DaemonClient {
     });
   }
 
+  private async startDaemonIfNecessary() {
+    if (this._daemonStatus == DaemonStatus.CONNECTED) {
+      return;
+    }
+    // Ensure daemon is running and socket path is available
+    if (this._daemonStatus == DaemonStatus.DISCONNECTED) {
+      this._daemonStatus = DaemonStatus.CONNECTING;
+
+      let daemonPid: number | null = null;
+      if (!(await this.isServerAvailable())) {
+        daemonPid = await this.startInBackground();
+      }
+      this.setUpConnection();
+      this._daemonStatus = DaemonStatus.CONNECTED;
+      this._daemonReady();
+
+      daemonPid ??= getDaemonProcessIdSync();
+      await this.registerDaemonProcessWithMetricsService(daemonPid);
+    } else if (this._daemonStatus == DaemonStatus.CONNECTING) {
+      await this._waitForDaemonReady;
+      const daemonPid = getDaemonProcessIdSync();
+      await this.registerDaemonProcessWithMetricsService(daemonPid);
+    }
+  }
+
   private async sendToDaemonViaQueue(
     messageToDaemon: Message,
     force?: 'v8' | 'json'
@@ -578,8 +648,10 @@ export class DaemonClient {
   }
 
   private setUpConnection() {
+    const socketPath = this.getSocketPath();
+
     this.socketMessenger = new DaemonSocketMessenger(
-      connect(getFullOsSocketPath())
+      connect(socketPath)
     ).listen(
       (message) => this.handleMessage(message),
       () => {
@@ -616,7 +688,6 @@ export class DaemonClient {
           error = daemonProcessException(
             `A server instance had not been fully shut down. Please try running the command again.`
           );
-          killSocketOrPath();
         } else if (err.message.startsWith('read ECONNRESET')) {
           error = daemonProcessException(
             `Unable to connect to the daemon process.`
@@ -633,24 +704,7 @@ export class DaemonClient {
     message: Message,
     force?: 'v8' | 'json'
   ): Promise<any> {
-    if (this._daemonStatus == DaemonStatus.DISCONNECTED) {
-      this._daemonStatus = DaemonStatus.CONNECTING;
-
-      let daemonPid: number | null = null;
-      if (!(await this.isServerAvailable())) {
-        daemonPid = await this.startInBackground();
-      }
-      this.setUpConnection();
-      this._daemonStatus = DaemonStatus.CONNECTED;
-      this._daemonReady();
-
-      daemonPid ??= getDaemonProcessIdSync();
-      await this.registerDaemonProcessWithMetricsService(daemonPid);
-    } else if (this._daemonStatus == DaemonStatus.CONNECTING) {
-      await this._waitForDaemonReady;
-      const daemonPid = getDaemonProcessIdSync();
-      await this.registerDaemonProcessWithMetricsService(daemonPid);
-    }
+    await this.startDaemonIfNecessary();
     // An open promise isn't enough to keep the event loop
     // alive, so we set a timeout here and clear it when we hear
     // back
diff --git a/packages/nx/src/daemon/is-nx-version-mismatch.ts b/packages/nx/src/daemon/is-nx-version-mismatch.ts
new file mode 100644
index 0000000000..cca8fef4b7
--- /dev/null
+++ b/packages/nx/src/daemon/is-nx-version-mismatch.ts
@@ -0,0 +1,22 @@
+import { readJsonFile } from '../utils/fileutils';
+import type { PackageJson } from '../utils/package-json';
+import { nxVersion } from '../utils/versions';
+import { workspaceRoot } from '../utils/workspace-root';
+import { getNxRequirePaths } from '../utils/installation-directory';
+
+export function getInstalledNxVersion(): string | null {
+  try {
+    const nxPackageJsonPath = require.resolve('nx/package.json', {
+      paths: getNxRequirePaths(workspaceRoot),
+    });
+    const { version } = readJsonFile<PackageJson>(nxPackageJsonPath);
+    return version;
+  } catch {
+    // node modules are absent
+    return null;
+  }
+}
+
+export function isNxVersionMismatch(): boolean {
+  return getInstalledNxVersion() !== nxVersion;
+}
diff --git a/packages/nx/src/daemon/message-types/nx-console.ts b/packages/nx/src/daemon/message-types/nx-console.ts
new file mode 100644
index 0000000000..3af2cd65fb
--- /dev/null
+++ b/packages/nx/src/daemon/message-types/nx-console.ts
@@ -0,0 +1,42 @@
+export const GET_NX_CONSOLE_STATUS = 'GET_NX_CONSOLE_STATUS' as const;
+export const SET_NX_CONSOLE_PREFERENCE_AND_INSTALL =
+  'SET_NX_CONSOLE_PREFERENCE_AND_INSTALL' as const;
+
+export type HandleGetNxConsoleStatusMessage = {
+  type: typeof GET_NX_CONSOLE_STATUS;
+};
+
+export type NxConsoleStatusResponse = {
+  shouldPrompt: boolean;
+};
+
+export type HandleSetNxConsolePreferenceAndInstallMessage = {
+  type: typeof SET_NX_CONSOLE_PREFERENCE_AND_INSTALL;
+  preference: boolean;
+};
+
+export type SetNxConsolePreferenceAndInstallResponse = {
+  installed: boolean;
+};
+
+export function isHandleGetNxConsoleStatusMessage(
+  message: unknown
+): message is HandleGetNxConsoleStatusMessage {
+  return (
+    typeof message === 'object' &&
+    message !== null &&
+    'type' in message &&
+    message['type'] === GET_NX_CONSOLE_STATUS
+  );
+}
+
+export function isHandleSetNxConsolePreferenceAndInstallMessage(
+  message: unknown
+): message is HandleSetNxConsolePreferenceAndInstallMessage {
+  return (
+    typeof message === 'object' &&
+    message !== null &&
+    'type' in message &&
+    message['type'] === SET_NX_CONSOLE_PREFERENCE_AND_INSTALL
+  );
+}
diff --git a/packages/nx/src/daemon/server/handle-nx-console.ts b/packages/nx/src/daemon/server/handle-nx-console.ts
new file mode 100644
index 0000000000..989fc4bae4
--- /dev/null
+++ b/packages/nx/src/daemon/server/handle-nx-console.ts
@@ -0,0 +1,69 @@
+import type {
+  NxConsoleStatusResponse,
+  SetNxConsolePreferenceAndInstallResponse,
+} from '../message-types/nx-console';
+import type { HandlerResult } from './server';
+import {
+  getNxConsoleStatus,
+  handleNxConsolePreferenceAndInstall,
+} from './nx-console-operations';
+
+// Module-level state for caching
+let cachedShouldPrompt: boolean | null = null;
+let isComputing = false;
+
+export async function handleGetNxConsoleStatus(): Promise<HandlerResult> {
+  // Return cached result if available
+  if (cachedShouldPrompt !== null) {
+    const response: NxConsoleStatusResponse = {
+      shouldPrompt: cachedShouldPrompt,
+    };
+    return {
+      response,
+      description: 'handleGetNxConsoleStatus',
+    };
+  }
+
+  // Kick off background computation if not already running
+  if (!isComputing) {
+    isComputing = true;
+    getNxConsoleStatus()
+      .then((result) => {
+        cachedShouldPrompt = result;
+        isComputing = false;
+      })
+      .catch(() => {
+        cachedShouldPrompt = null;
+        isComputing = false;
+      });
+  }
+
+  // Return false for shouldPrompt if cache not ready (main process will noop)
+  const response: NxConsoleStatusResponse = {
+    shouldPrompt: false,
+  };
+
+  return {
+    response,
+    description: 'handleGetNxConsoleStatus',
+  };
+}
+
+export async function handleSetNxConsolePreferenceAndInstall(
+  preference: boolean
+): Promise<HandlerResult> {
+  // Immediately update cache - we know the answer now!
+  // User answered the prompt, so we won't prompt again
+  cachedShouldPrompt = false;
+
+  const result = await handleNxConsolePreferenceAndInstall({ preference });
+
+  const response: SetNxConsolePreferenceAndInstallResponse = {
+    installed: result.installed,
+  };
+
+  return {
+    response,
+    description: 'handleSetNxConsolePreferenceAndInstall',
+  };
+}
diff --git a/packages/nx/src/daemon/server/nx-console-operations.ts b/packages/nx/src/daemon/server/nx-console-operations.ts
new file mode 100644
index 0000000000..2321450c15
--- /dev/null
+++ b/packages/nx/src/daemon/server/nx-console-operations.ts
@@ -0,0 +1,181 @@
+import { installPackageToTmpAsync } from '../../devkit-internals';
+import { homedir } from 'os';
+import {
+  canInstallNxConsole,
+  installNxConsole,
+  NxConsolePreferences,
+} from '../../native';
+import { serverLogger } from './logger';
+
+// Module-level state - persists across invocations within daemon lifecycle
+let latestNxTmpPath: string | null = null;
+let cleanupFn: (() => void) | null = null;
+
+const log = (...messageParts: unknown[]) => {
+  serverLogger.log('[NX-CONSOLE]:', ...messageParts);
+};
+
+/**
+ * Gets the Nx Console status (whether we should prompt the user to install).
+ * Uses latest Nx version if available, falls back to local implementation.
+ *
+ * @returns boolean indicating whether we should prompt the user
+ */
+export async function getNxConsoleStatus({
+  inner,
+}: {
+  inner?: boolean;
+} = {}): Promise<boolean> {
+  // Use local implementation if explicitly requested
+  if (process.env.NX_USE_LOCAL === 'true' || inner === true) {
+    log('Using local implementation (NX_USE_LOCAL=true or inner call)');
+    return await getNxConsoleStatusImpl();
+  }
+
+  try {
+    // If we don't have a tmp path yet, pull latest Nx
+    if (latestNxTmpPath === null) {
+      log('Pulling latest Nx (latest) to check console status...');
+      const packageInstallResults = await installPackageToTmpAsync(
+        'nx',
+        'latest'
+      );
+      latestNxTmpPath = packageInstallResults.tempDir;
+      cleanupFn = packageInstallResults.cleanup;
+      log('Successfully pulled latest Nx to', latestNxTmpPath);
+    } else {
+      log('Reusing cached Nx installation from', latestNxTmpPath);
+    }
+
+    // Try to use the cached tmp path
+    const modulePath = require.resolve(
+      'nx/src/daemon/server/nx-console-operations.js',
+      { paths: [latestNxTmpPath] }
+    );
+
+    const module = await import(modulePath);
+    const result = await module.getNxConsoleStatus({ inner: true });
+    log('Console status check completed, shouldPrompt:', result);
+    return result;
+  } catch (error) {
+    // If tmp path failed (e.g., directory was deleted), fall back to local immediately
+    log(
+      'Failed to use latest Nx, falling back to local implementation. Error:',
+      error.message
+    );
+    return await getNxConsoleStatusImpl();
+  }
+}
+
+/**
+ * Handles user preference submission and installs Nx Console if requested.
+ * Uses latest Nx version if available, falls back to local implementation.
+ *
+ * @param preference - whether the user wants to install Nx Console
+ * @returns object indicating whether installation succeeded
+ */
+export async function handleNxConsolePreferenceAndInstall({
+  preference,
+  inner,
+}: {
+  preference: boolean;
+  inner?: boolean;
+}): Promise<{ installed: boolean }> {
+  log('Handling user preference:', preference);
+
+  // Use local implementation if explicitly requested
+  if (process.env.NX_USE_LOCAL === 'true' || inner === true) {
+    log('Using local implementation (NX_USE_LOCAL=true or inner call)');
+    return await handleNxConsolePreferenceAndInstallImpl(preference);
+  }
+
+  try {
+    // If we don't have a tmp path yet, pull latest Nx
+    if (latestNxTmpPath === null) {
+      log('Pulling latest Nx (latest) to handle preference and install...');
+      const packageInstallResults = await installPackageToTmpAsync(
+        'nx',
+        'latest'
+      );
+      latestNxTmpPath = packageInstallResults.tempDir;
+      cleanupFn = packageInstallResults.cleanup;
+      log('Successfully pulled latest Nx to', latestNxTmpPath);
+    } else {
+      log('Reusing cached Nx installation from', latestNxTmpPath);
+    }
+
+    // Try to use the cached tmp path
+    const modulePath = require.resolve(
+      'nx/src/daemon/server/nx-console-operations.js',
+      { paths: [latestNxTmpPath] }
+    );
+
+    const module = await import(modulePath);
+    const result = await module.handleNxConsolePreferenceAndInstall({
+      preference,
+      inner: true,
+    });
+    log(
+      'Preference saved and installation',
+      result.installed ? 'succeeded' : 'skipped/failed'
+    );
+    return result;
+  } catch (error) {
+    // If tmp path failed (e.g., directory was deleted), fall back to local immediately
+    log(
+      'Failed to use latest Nx, falling back to local implementation. Error:',
+      error.message
+    );
+    return await handleNxConsolePreferenceAndInstallImpl(preference);
+  }
+}
+
+/**
+ * Clean up the latest Nx installation on daemon shutdown.
+ */
+export function cleanupLatestNxInstallation(): void {
+  if (cleanupFn) {
+    log('Cleaning up latest Nx installation from', latestNxTmpPath);
+    cleanupFn();
+  }
+  latestNxTmpPath = null;
+  cleanupFn = null;
+}
+
+export async function getNxConsoleStatusImpl(): Promise<boolean> {
+  // If no cached preference, read from disk
+  const preferences = new NxConsolePreferences(homedir());
+  const preference = preferences.getAutoInstallPreference();
+
+  const canInstallConsole = canInstallNxConsole();
+
+  // If user previously opted in but extension is not installed,
+  // they must have manually uninstalled it - respect that choice
+  if (preference === true && canInstallConsole) {
+    const preferences = new NxConsolePreferences(homedir());
+    preferences.setAutoInstallPreference(false);
+    return false; // Don't prompt
+  }
+
+  // Noop if can't install
+  if (!canInstallConsole) {
+    return false;
+  }
+
+  // Prompt if we can install and user hasn't answered yet
+  return typeof preference !== 'boolean';
+}
+
+export async function handleNxConsolePreferenceAndInstallImpl(
+  preference: boolean
+): Promise<{ installed: boolean }> {
+  const preferences = new NxConsolePreferences(homedir());
+  preferences.setAutoInstallPreference(preference);
+
+  let installed = false;
+  if (preference) {
+    installed = installNxConsole();
+  }
+
+  return { installed };
+}
diff --git a/packages/nx/src/daemon/server/server.ts b/packages/nx/src/daemon/server/server.ts
index 106488d43d..ee90a3c03b 100644
--- a/packages/nx/src/daemon/server/server.ts
+++ b/packages/nx/src/daemon/server/server.ts
@@ -8,12 +8,11 @@ import {
   consumeMessagesFromSocket,
   isJsonMessage,
 } from '../../utils/consume-messages-from-socket';
-import { readJsonFile } from '../../utils/fileutils';
-import { PackageJson } from '../../utils/package-json';
 import { nxVersion } from '../../utils/versions';
 import { setupWorkspaceContext } from '../../utils/workspace-context';
 import { workspaceRoot } from '../../utils/workspace-root';
 import { getDaemonProcessIdSync, writeDaemonJsonProcessCache } from '../cache';
+import { isNxVersionMismatch } from '../is-nx-version-mismatch';
 import {
   getFullOsSocketPath,
   isWindows,
@@ -141,6 +140,16 @@ import {
   isRegisterProjectGraphListenerMessage,
   REGISTER_PROJECT_GRAPH_LISTENER,
 } from '../message-types/register-project-graph-listener';
+import {
+  GET_NX_CONSOLE_STATUS,
+  isHandleGetNxConsoleStatusMessage,
+  isHandleSetNxConsolePreferenceAndInstallMessage,
+  SET_NX_CONSOLE_PREFERENCE_AND_INSTALL,
+} from '../message-types/nx-console';
+import {
+  handleGetNxConsoleStatus,
+  handleSetNxConsolePreferenceAndInstall,
+} from './handle-nx-console';
 import { deserialize, serialize } from 'v8';
 
 let performanceObserver: PerformanceObserver | undefined;
@@ -419,6 +428,20 @@ async function handleMessage(socket: Socket, data: string) {
       () => handleRunPostTasksExecution(payload.context),
       mode
     );
+  } else if (isHandleGetNxConsoleStatusMessage(payload)) {
+    await handleResult(
+      socket,
+      GET_NX_CONSOLE_STATUS,
+      () => handleGetNxConsoleStatus(),
+      mode
+    );
+  } else if (isHandleSetNxConsolePreferenceAndInstallMessage(payload)) {
+    await handleResult(
+      socket,
+      SET_NX_CONSOLE_PREFERENCE_AND_INSTALL,
+      () => handleSetNxConsolePreferenceAndInstall(payload.preference),
+      mode
+    );
   } else {
     await respondWithErrorAndExit(
       socket,
@@ -509,7 +532,7 @@ function registerProcessTerminationListeners() {
 let existingLockHash: string | undefined;
 
 function daemonIsOutdated(): string | null {
-  if (nxVersionChanged()) {
+  if (isNxVersionMismatch()) {
     return 'NX_VERSION_CHANGED';
   } else if (lockFileHashChanged()) {
     return 'LOCK_FILES_CHANGED';
@@ -517,22 +540,6 @@ function daemonIsOutdated(): string | null {
   return null;
 }
 
-function nxVersionChanged(): boolean {
-  return nxVersion !== getInstalledNxVersion();
-}
-
-const nxPackageJsonPath = require.resolve('nx/package.json');
-
-function getInstalledNxVersion() {
-  try {
-    const { version } = readJsonFile<PackageJson>(nxPackageJsonPath);
-    return version;
-  } catch (e) {
-    // node modules are absent, so we can return null, which would shut down the daemon
-    return null;
-  }
-}
-
 function lockFileHashChanged(): boolean {
   const lockHashes = [
     join(workspaceRoot, 'package-lock.json'),
@@ -660,9 +667,13 @@ const handleOutputsChanges: FileWatcherCallback = async (err, changeEvents) => {
 export async function startServer(): Promise<Server> {
   setupWorkspaceContext(workspaceRoot);
 
+  const socketPath = getFullOsSocketPath();
+
   // Persist metadata about the background process so that it can be cleaned up later if needed
   await writeDaemonJsonProcessCache({
     processId: process.pid,
+    socketPath,
+    nxVersion,
   });
 
   // See notes in socket-command-line-utils.ts on OS differences regarding clean up of existings connections.
@@ -682,9 +693,9 @@ export async function startServer(): Promise<Server> {
 
   return new Promise(async (resolve, reject) => {
     try {
-      server.listen(getFullOsSocketPath(), async () => {
+      server.listen(socketPath, async () => {
         try {
-          serverLogger.log(`Started listening on: ${getFullOsSocketPath()}`);
+          serverLogger.log(`Started listening on: ${socketPath}`);
 
           // this triggers the storage of the lock file hash
           daemonIsOutdated();
@@ -712,6 +723,11 @@ export async function startServer(): Promise<Server> {
           // trigger an initial project graph recomputation
           addUpdatedAndDeletedFiles([], [], []);
 
+          // Kick off Nx Console check in background to prime the cache
+          handleGetNxConsoleStatus().catch(() => {
+            // Ignore errors, this is a background operation
+          });
+
           return resolve(server);
         } catch (err) {
           await handleWorkspaceChanges(err, []);
diff --git a/packages/nx/src/daemon/server/shutdown-utils.ts b/packages/nx/src/daemon/server/shutdown-utils.ts
index 306e3c41c2..6aa1de83b2 100644
--- a/packages/nx/src/daemon/server/shutdown-utils.ts
+++ b/packages/nx/src/daemon/server/shutdown-utils.ts
@@ -11,6 +11,7 @@ import {
 import { removeDbConnections } from '../../utils/db-connection';
 import { cleanupPlugins } from '../../project-graph/plugins/get-plugins';
 import { MESSAGE_END_SEQ } from '../../utils/consume-messages-from-socket';
+import { cleanupLatestNxInstallation } from './nx-console-operations';
 
 export const SERVER_INACTIVITY_TIMEOUT_MS = 10800000 as const; // 10800000 ms = 3 hours
 
@@ -75,6 +76,9 @@ export async function handleServerProcessTermination({
 
     removeDbConnections();
 
+    // Clean up Nx Console latest installation
+    cleanupLatestNxInstallation();
+
     serverLogger.log(`Server stopped because: "${reason}"`);
   } finally {
     process.exit(0);
diff --git a/packages/nx/src/daemon/tmp-dir.ts b/packages/nx/src/daemon/tmp-dir.ts
index 107c7a838a..a563209dce 100644
--- a/packages/nx/src/daemon/tmp-dir.ts
+++ b/packages/nx/src/daemon/tmp-dir.ts
@@ -49,6 +49,7 @@ export function isDaemonDisabled() {
 function socketDirName() {
   const hasher = createHash('sha256');
   hasher.update(workspaceRoot.toLowerCase());
+  hasher.update(String(process.pid));
   const unique = hasher.digest('hex').substring(0, 20);
   return join(tmpdir, unique);
 }
diff --git a/packages/nx/src/devkit-internals.ts b/packages/nx/src/devkit-internals.ts
index 14464da0e4..13a4ba10da 100644
--- a/packages/nx/src/devkit-internals.ts
+++ b/packages/nx/src/devkit-internals.ts
@@ -24,6 +24,7 @@ export { stripIndent } from './utils/logger';
 export {
   readModulePackageJson,
   installPackageToTmp,
+  installPackageToTmpAsync,
 } from './utils/package-json';
 export { splitByColons } from './utils/split-target';
 export { hashObject } from './hasher/file-hasher';
diff --git a/packages/nx/src/tasks-runner/pseudo-terminal.ts b/packages/nx/src/tasks-runner/pseudo-terminal.ts
index 493b4b5782..17345f30b7 100644
--- a/packages/nx/src/tasks-runner/pseudo-terminal.ts
+++ b/packages/nx/src/tasks-runner/pseudo-terminal.ts
@@ -191,7 +191,7 @@ export class PseudoTtyProcess implements RunningTask {
   kill(s?: NodeJS.Signals): void {
     if (this.isAlive) {
       try {
-        this.childProcess.kill(s);
+        this.childProcess.kill(s || 'SIGTERM');
       } catch {
         // when the child process completes before we explicitly call kill, this will throw
         // do nothing
diff --git a/packages/nx/src/tasks-runner/task-orchestrator.ts b/packages/nx/src/tasks-runner/task-orchestrator.ts
index 1fc4152989..3411226daf 100644
--- a/packages/nx/src/tasks-runner/task-orchestrator.ts
+++ b/packages/nx/src/tasks-runner/task-orchestrator.ts
@@ -85,6 +85,7 @@ export class TaskOrchestrator {
   private groups = [];
 
   private bailed = false;
+  private cleaningUp = false;
 
   private runningContinuousTasks = new Map<string, RunningTask>();
   private runningRunCommandsTasks = new Map<string, RunningTask>();
@@ -732,14 +733,22 @@ export class TaskOrchestrator {
       );
 
       this.runningContinuousTasks.set(task.id, runningTask);
-      runningTask.onExit(() => {
-        if (this.tuiEnabled) {
+      runningTask.onExit((code) => {
+        if (this.tuiEnabled && !this.completedTasks[task.id]) {
           this.options.lifeCycle.setTaskStatus(
             task.id,
             NativeTaskStatus.Stopped
           );
         }
         this.runningContinuousTasks.delete(task.id);
+
+        // we're not cleaning up, so this is an unexpected exit, fail the task
+        if (!this.cleaningUp) {
+          console.error(
+            `Task "${task.id}" is continuous but exited with code ${code}`
+          );
+          this.complete([{ taskId: task.id, status: 'failure' }]);
+        }
       });
 
       // task is already running by another process, we schedule the next tasks
@@ -802,13 +811,22 @@ export class TaskOrchestrator {
     this.runningTasksService.addRunningTask(task.id);
     this.runningContinuousTasks.set(task.id, childProcess);
 
-    childProcess.onExit(() => {
-      if (this.tuiEnabled) {
+    childProcess.onExit((code) => {
+      // Only set status to Stopped if task hasn't been completed yet
+      if (this.tuiEnabled && !this.completedTasks[task.id]) {
         this.options.lifeCycle.setTaskStatus(task.id, NativeTaskStatus.Stopped);
       }
       if (this.runningContinuousTasks.delete(task.id)) {
         this.runningTasksService.removeRunningTask(task.id);
       }
+
+      // we're not cleaning up, so this is an unexpected exit, fail the task
+      if (!this.cleaningUp) {
+        console.error(
+          `Task "${task.id}" is continuous but exited with code ${code}`
+        );
+        this.complete([{ taskId: task.id, status: 'failure' }]);
+      }
     });
     await this.scheduleNextTasksAndReleaseThreads();
     if (this.initializingTaskIds.has(task.id)) {
@@ -1025,6 +1043,7 @@ export class TaskOrchestrator {
   // endregion utils
 
   private async cleanup() {
+    this.cleaningUp = true;
     this.forkedProcessTaskRunner.cleanup();
     await Promise.all([
       ...Array.from(this.runningContinuousTasks).map(async ([taskId, t]) => {
@@ -1054,8 +1073,13 @@ export class TaskOrchestrator {
 
   private cleanUpUnneededContinuousTasks() {
     const incompleteTasks = this.tasksSchedule.getIncompleteTasks();
-    const neededContinuousTasks = new Set(this.initializingTaskIds);
+    const neededContinuousTasks = new Set<string>();
     for (const task of incompleteTasks) {
+      // Keep initiating tasks that are still incomplete
+      if (task.continuous && this.initializingTaskIds.has(task.id)) {
+        neededContinuousTasks.add(task.id);
+      }
+
       const continuousDependencies =
         this.taskGraph.continuousDependencies[task.id];
       for (const continuousDependency of continuousDependencies) {
diff --git a/packages/nx/src/utils/package-json.ts b/packages/nx/src/utils/package-json.ts
index 3af8abe7b0..e1f9cf486a 100644
--- a/packages/nx/src/utils/package-json.ts
+++ b/packages/nx/src/utils/package-json.ts
@@ -1,6 +1,9 @@
-import { execSync } from 'child_process';
+import { exec, execSync } from 'child_process';
+import { promisify } from 'util';
 import { existsSync, writeFileSync } from 'fs';
 import { dirname, join, resolve } from 'path';
+
+const execAsync = promisify(exec);
 import { dirSync } from 'tmp';
 import { NxJsonConfiguration } from '../config/nx-json';
 import {
@@ -348,13 +351,11 @@ export function readModulePackageJson(
   };
 }
 
-export function installPackageToTmp(
-  pkg: string,
-  requiredVersion: string
-): {
-  tempDir: string;
-  cleanup: () => void;
-} {
+/**
+ * Prepares all necessary information for installing a package to a temporary directory.
+ * This is used by both sync and async installation functions.
+ */
+function preparePackageInstallation(pkg: string, requiredVersion: string) {
   const { dir: tempDir, cleanup } = createTempNpmDirectory?.() ?? {
     dir: dirSync().name,
     cleanup: () => {},
@@ -364,31 +365,49 @@ export function installPackageToTmp(
   const packageManager = detectPackageManager();
   const isVerbose = process.env.NX_VERBOSE_LOGGING === 'true';
   generatePackageManagerFiles(tempDir, packageManager);
+
   const preInstallCommand = getPackageManagerCommand(packageManager).preInstall;
-  if (preInstallCommand) {
-    // ensure package.json and repo in tmp folder is set to a proper package manager state
-    execSync(preInstallCommand, {
-      cwd: tempDir,
-      stdio: isVerbose ? 'inherit' : 'ignore',
-      windowsHide: false,
-    });
-  }
   const pmCommands = getPackageManagerCommand(packageManager);
   let addCommand = pmCommands.addDev;
   if (packageManager === 'pnpm') {
     addCommand = 'pnpm add -D'; // we need to ensure that we are not using workspace command
   }
 
-  execSync(
-    `${addCommand} ${pkg}@${requiredVersion} ${
-      pmCommands.ignoreScriptsFlag ?? ''
-    }`,
-    {
-      cwd: tempDir,
-      stdio: isVerbose ? 'inherit' : 'ignore',
-      windowsHide: false,
-    }
-  );
+  const installCommand = `${addCommand} ${pkg}@${requiredVersion} ${
+    pmCommands.ignoreScriptsFlag ?? ''
+  }`;
+
+  const execOptions = {
+    cwd: tempDir,
+    stdio: isVerbose ? 'inherit' : 'ignore',
+    windowsHide: false,
+  } as const;
+
+  return {
+    tempDir,
+    cleanup,
+    preInstallCommand,
+    installCommand,
+    execOptions,
+  };
+}
+
+export function installPackageToTmp(
+  pkg: string,
+  requiredVersion: string
+): {
+  tempDir: string;
+  cleanup: () => void;
+} {
+  const { tempDir, cleanup, preInstallCommand, installCommand, execOptions } =
+    preparePackageInstallation(pkg, requiredVersion);
+
+  if (preInstallCommand) {
+    // ensure package.json and repo in tmp folder is set to a proper package manager state
+    execSync(preInstallCommand, execOptions);
+  }
+
+  execSync(installCommand, execOptions);
 
   return {
     tempDir,
@@ -396,6 +415,35 @@ export function installPackageToTmp(
   };
 }
 
+export async function installPackageToTmpAsync(
+  pkg: string,
+  requiredVersion: string
+): Promise<{
+  tempDir: string;
+  cleanup: () => void;
+}> {
+  const { tempDir, cleanup, preInstallCommand, installCommand, execOptions } =
+    preparePackageInstallation(pkg, requiredVersion);
+
+  try {
+    if (preInstallCommand) {
+      // ensure package.json and repo in tmp folder is set to a proper package manager state
+      await execAsync(preInstallCommand, execOptions);
+    }
+
+    await execAsync(installCommand, execOptions);
+
+    return {
+      tempDir,
+      cleanup,
+    };
+  } catch (error) {
+    // Clean up on error
+    cleanup();
+    throw error;
+  }
+}
+
 /**
  * Get the resolved version of a dependency from package.json.
  *
diff --git a/packages/nx/src/utils/package-manager.ts b/packages/nx/src/utils/package-manager.ts
index 21df5dbd27..8484022a73 100644
--- a/packages/nx/src/utils/package-manager.ts
+++ b/packages/nx/src/utils/package-manager.ts
@@ -42,6 +42,7 @@ export interface PackageManagerCommands {
   exec: string;
   dlx: string;
   list: string;
+  why: string;
   run: (script: string, args?: string) => string;
   // Make this required once bun adds programatically support for reading config https://github.com/oven-sh/bun/issues/7140
   getRegistryUrl?: string;
@@ -148,6 +149,7 @@ export function getPackageManagerCommand(
         run: (script: string, args?: string) =>
           `yarn ${script}${args ? ` ${args}` : ''}`,
         list: useBerry ? 'yarn info --name-only' : 'yarn list',
+        why: 'yarn why',
         getRegistryUrl: useBerry
           ? 'yarn config get npmRegistryServer'
           : 'yarn config get registry',
@@ -195,6 +197,7 @@ export function getPackageManagerCommand(
               : ''
           }`,
         list: 'pnpm ls --depth 100',
+        why: 'pnpm why',
         getRegistryUrl: 'pnpm config get registry',
         publish: (packageRoot, registry, registryConfigKey, tag) =>
           `pnpm publish "${packageRoot}" --json --"${
@@ -216,6 +219,7 @@ export function getPackageManagerCommand(
         run: (script: string, args?: string) =>
           `npm run ${script}${args ? ' -- ' + args : ''}`,
         list: 'npm ls',
+        why: 'npm explain',
         getRegistryUrl: 'npm config get registry',
         publish: (packageRoot, registry, registryConfigKey, tag) =>
           `npm publish "${packageRoot}" --json --"${registryConfigKey}=${registry}" --tag=${tag}`,
@@ -235,6 +239,7 @@ export function getPackageManagerCommand(
         dlx: 'bunx',
         run: (script: string, args: string) => `bun run ${script} -- ${args}`,
         list: 'bun pm ls',
+        why: 'bun why',
         // Unlike npm, bun publish does not support a custom registryConfigKey option
         publish: (packageRoot, registry, registryConfigKey, tag) =>
           `bun publish --cwd="${packageRoot}" --json --registry="${registry}" --tag=${tag}`,
diff --git a/packages/rollup/package.json b/packages/rollup/package.json
index 70ccac9804..60cd57de69 100644
--- a/packages/rollup/package.json
+++ b/packages/rollup/package.json
@@ -42,6 +42,7 @@
     "picomatch": "catalog:",
     "postcss": "^8.4.38",
     "rollup": "^4.14.0",
+    "rollup-plugin-copy": "^3.5.0",
     "rollup-plugin-postcss": "^4.0.2",
     "rollup-plugin-typescript2": "^0.36.0",
     "tslib": "catalog:typescript"
diff --git a/packages/rollup/src/plugins/nx-copy-assets.plugin.spec.ts b/packages/rollup/src/plugins/nx-copy-assets.plugin.spec.ts
deleted file mode 100644
index 9cd26428c2..0000000000
--- a/packages/rollup/src/plugins/nx-copy-assets.plugin.spec.ts
+++ /dev/null
@@ -1,58 +0,0 @@
-import { extractGlobLiteralPrefix } from './nx-copy-assets.plugin';
-
-describe('extractGlobLiteralPrefix', () => {
-  it('should extract literal directory prefix from path without globs', () => {
-    expect(extractGlobLiteralPrefix('libs/mylib/README.md')).toEqual({
-      prefix: 'libs/mylib',
-      glob: 'README.md',
-    });
-  });
-
-  it('should return "." prefix for filename-only patterns', () => {
-    expect(extractGlobLiteralPrefix('README.md')).toEqual({
-      prefix: '.',
-      glob: 'README.md',
-    });
-  });
-
-  it('should return "." prefix when glob starts with wildcard', () => {
-    expect(extractGlobLiteralPrefix('**/*.md')).toEqual({
-      prefix: '.',
-      glob: '**/*.md',
-    });
-
-    expect(extractGlobLiteralPrefix('*.md')).toEqual({
-      prefix: '.',
-      glob: '*.md',
-    });
-  });
-
-  it('should split at glob boundary', () => {
-    expect(extractGlobLiteralPrefix('docs/*.md')).toEqual({
-      prefix: 'docs',
-      glob: '*.md',
-    });
-
-    expect(extractGlobLiteralPrefix('libs/mylib/src/assets/**/*.png')).toEqual({
-      prefix: 'libs/mylib/src/assets',
-      glob: '**/*.png',
-    });
-  });
-
-  it('should handle other glob characters', () => {
-    expect(extractGlobLiteralPrefix('libs/[abc]/file.ts')).toEqual({
-      prefix: 'libs',
-      glob: '[abc]/file.ts',
-    });
-
-    expect(extractGlobLiteralPrefix('libs/{a,b}/file.ts')).toEqual({
-      prefix: 'libs',
-      glob: '{a,b}/file.ts',
-    });
-
-    expect(extractGlobLiteralPrefix('libs/file?.ts')).toEqual({
-      prefix: 'libs',
-      glob: 'file?.ts',
-    });
-  });
-});
diff --git a/packages/rollup/src/plugins/nx-copy-assets.plugin.ts b/packages/rollup/src/plugins/nx-copy-assets.plugin.ts
deleted file mode 100644
index 9c7852246e..0000000000
--- a/packages/rollup/src/plugins/nx-copy-assets.plugin.ts
+++ /dev/null
@@ -1,99 +0,0 @@
-import { isAbsolute, join, relative } from 'node:path';
-import type { Plugin } from 'rollup';
-import { isDaemonEnabled, workspaceRoot } from '@nx/devkit';
-import { AssetGlob } from '@nx/js/src/utils/assets/assets';
-import { CopyAssetsHandler } from '@nx/js/src/utils/assets/copy-assets-handler';
-
-export interface NxCopyAssetsPluginOptions {
-  assets: (string | AssetGlob)[];
-  outputPath: string;
-  projectRoot: string;
-}
-
-/**
- * Splits a glob into its literal directory prefix and the remaining pattern.
- * CopyAssetsHandler expects input to be a directory and glob to be a pattern
- * within it (e.g., input: 'docs', glob: '**\/*.md'), not combined paths.
- *
- * 'libs/mylib/README.md' => { prefix: 'libs/mylib', glob: 'README.md' }
- * 'docs/*.md' => { prefix: 'docs', glob: '*.md' }
- * '**\/*.md' => { prefix: '.', glob: '**\/*.md' }
- *
- * @visibleForTesting
- */
-export function extractGlobLiteralPrefix(glob: string): {
-  prefix: string;
-  glob: string;
-} {
-  const parts = glob.split('/');
-  const isGlobPart = (p: string) =>
-    p.includes('*') || p.includes('?') || p.includes('[') || p.includes('{');
-
-  const firstGlobIndex = parts.findIndex(isGlobPart);
-  const hasGlob = firstGlobIndex !== -1;
-
-  const prefixParts = hasGlob
-    ? parts.slice(0, firstGlobIndex)
-    : parts.slice(0, -1);
-  const globParts = hasGlob ? parts.slice(firstGlobIndex) : parts.slice(-1);
-
-  return {
-    prefix: prefixParts.join('/') || '.',
-    glob: globParts.join('/'),
-  };
-}
-
-export function nxCopyAssetsPlugin(options: NxCopyAssetsPluginOptions): Plugin {
-  let handler: CopyAssetsHandler;
-  let dispose: () => void;
-
-  if (global.NX_GRAPH_CREATION) return { name: 'nx-copy-assets-plugin' };
-
-  const relativeProjectRoot = relative(workspaceRoot, options.projectRoot);
-
-  return {
-    name: 'nx-copy-assets-plugin',
-    async buildStart() {
-      // Input must be relative to rootDir because CopyAssetsHandler computes
-      // destination paths using path.relative(input, globResult), and glob
-      // returns paths relative to rootDir.
-      const assets = options.assets.map((a) => {
-        if (typeof a === 'string') {
-          return join(relativeProjectRoot, a);
-        } else {
-          // relative() returns '' when paths are equal, normalize to '.'
-          const relativeInput = relative(workspaceRoot, a.input) || '.';
-          const { prefix: globPrefix, glob: normalizedGlob } =
-            extractGlobLiteralPrefix(a.glob);
-
-          return {
-            ...a,
-            input: join(relativeInput, globPrefix),
-            glob: normalizedGlob,
-          };
-        }
-      });
-
-      const outputDir = isAbsolute(options.outputPath)
-        ? options.outputPath
-        : join(workspaceRoot, options.outputPath);
-
-      handler = new CopyAssetsHandler({
-        rootDir: workspaceRoot,
-        projectDir: options.projectRoot,
-        outputDir,
-        assets,
-      });
-
-      if (this.meta.watchMode && isDaemonEnabled()) {
-        dispose = await handler.watchAndProcessOnAssetChange();
-      }
-    },
-    async writeBundle() {
-      await handler.processAllAssetsOnce();
-    },
-    closeWatcher() {
-      dispose?.();
-    },
-  };
-}
diff --git a/packages/rollup/src/plugins/with-nx/with-nx.ts b/packages/rollup/src/plugins/with-nx/with-nx.ts
index 3c56d474e1..79e25cf961 100644
--- a/packages/rollup/src/plugins/with-nx/with-nx.ts
+++ b/packages/rollup/src/plugins/with-nx/with-nx.ts
@@ -26,18 +26,18 @@ import { PackageJson } from 'nx/src/utils/package-json';
 import * as rollup from 'rollup';
 import { analyze } from '../analyze';
 import { deleteOutput } from '../delete-output';
-import { nxCopyAssetsPlugin } from '../nx-copy-assets.plugin';
 import { generatePackageJson } from '../package-json/generate-package-json';
 import { swc } from '../swc';
 import { getProjectNode } from './get-project-node';
 import { normalizeOptions } from './normalize-options';
-import { RollupWithNxPluginOptions } from './with-nx-options';
+import { AssetGlobPattern, RollupWithNxPluginOptions } from './with-nx-options';
 
 // These use require because the ES import isn't correct.
 const commonjs = require('@rollup/plugin-commonjs');
 const image = require('@rollup/plugin-image');
 
 const json = require('@rollup/plugin-json');
+const copy = require('rollup-plugin-copy');
 const postcss = require('rollup-plugin-postcss');
 
 const fileExtensions = ['.js', '.jsx', '.ts', '.tsx'];
@@ -241,10 +241,11 @@ export function withNx(
       : finalConfig.output.dir;
 
     finalConfig.plugins = [
-      nxCopyAssetsPlugin({
-        assets: options.assets,
-        outputPath: options.outputPath,
-        projectRoot,
+      copy({
+        targets: convertCopyAssetsToRollupOptions(
+          options.outputPath,
+          options.assets
+        ),
       }),
       image(),
       json(),
@@ -387,6 +388,23 @@ function createTsCompilerOptions(
   return compilerOptions;
 }
 
+interface RollupCopyAssetOption {
+  src: string;
+  dest: string;
+}
+
+function convertCopyAssetsToRollupOptions(
+  outputPath: string,
+  assets: AssetGlobPattern[]
+): RollupCopyAssetOption[] {
+  return assets
+    ? assets.map((a) => ({
+        src: join(a.input, a.glob).replace(/\\/g, '/'),
+        dest: join(workspaceRoot, outputPath, a.output).replace(/\\/g, '/'),
+      }))
+    : undefined;
+}
+
 function readCompatibleFormats(
   config: ReturnType<typeof ts.parseJsonConfigFileContent>
 ): ('cjs' | 'esm')[] {
diff --git a/pnpm-lock.yaml b/pnpm-lock.yaml
index ac0e9234ed..f7f66ea10a 100644
--- a/pnpm-lock.yaml
+++ b/pnpm-lock.yaml
@@ -3988,6 +3988,9 @@ importers:
       rollup:
         specifier: ^4.14.0
         version: 4.44.2
+      rollup-plugin-copy:
+        specifier: ^3.5.0
+        version: 3.5.0
       rollup-plugin-postcss:
         specifier: ^4.0.2
         version: 4.0.2(postcss@8.5.3)(ts-node@10.9.1(@swc/core@1.5.7(@swc/helpers@0.5.17))(@types/node@24.2.0)(typescript@5.9.2))
