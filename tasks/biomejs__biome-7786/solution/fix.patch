diff --git a/.changeset/ripe-rabbits-build.md b/.changeset/ripe-rabbits-build.md
new file mode 100644
index 0000000000..aab1e50d64
--- /dev/null
+++ b/.changeset/ripe-rabbits-build.md
@@ -0,0 +1,5 @@
+---
+"@biomejs/biome": patch
+---
+
+Fixed [#7601](https://github.com/biomejs/biome/issues/7601): Properly match Grit plugin's code snippet with only one child.
diff --git a/Cargo.lock b/Cargo.lock
index 19519d10f2..69dcab70c4 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -3964,9 +3964,9 @@ dependencies = [
 
 [[package]]
 name = "proc-macro2"
-version = "1.0.103"
+version = "1.0.101"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "5ee95bc4ef87b8d5ba32e8b7714ccc834865276eab0aed5c9958d00ec45f49e8"
+checksum = "89ae43fd86e4158d6db51ad8e2b80f313af9cc74f5c0e03ccb87de09998732de"
 dependencies = [
  "unicode-ident",
 ]
@@ -4805,9 +4805,9 @@ dependencies = [
 
 [[package]]
 name = "tikv-jemalloc-sys"
-version = "0.6.1+5.3.0-1-ge13ca993e8ccb9ba9847cc330696e02839f328f7"
+version = "0.6.0+5.3.0-1-ge13ca993e8ccb9ba9847cc330696e02839f328f7"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "cd8aa5b2ab86a2cefa406d889139c162cbb230092f7d1d7cbc1716405d852a3b"
+checksum = "cd3c60906412afa9c2b5b5a48ca6a5abe5736aec9eb48ad05037a677e52e4e2d"
 dependencies = [
  "cc",
  "libc",
@@ -4815,9 +4815,9 @@ dependencies = [
 
 [[package]]
 name = "tikv-jemallocator"
-version = "0.6.1"
+version = "0.6.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "0359b4327f954e0567e69fb191cf1436617748813819c94b8cd4a431422d053a"
+checksum = "4cec5ff18518d81584f477e9bfdf957f5bb0979b0bac3af4ca30b5b3ae2d2865"
 dependencies = [
  "libc",
  "tikv-jemalloc-sys",
diff --git a/Cargo.toml b/Cargo.toml
index 78cba0975a..0e39d1bcf4 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -214,7 +214,7 @@ mimalloc             = "0.1.48"
 papaya               = "0.2.3"
 path-absolutize      = { version = "3.1.1", optional = false, features = ["use_unix_paths_on_wasm"] }
 proc-macro-error2    = { version = "2.0.1", default-features = false }
-proc-macro2          = "1.0.103"
+proc-macro2          = "1.0.101"
 quickcheck           = "1.0.3"
 quickcheck_macros    = "1.1.0"
 quote                = "1.0.41"
@@ -231,7 +231,7 @@ static_assertions    = "1.1"
 syn                  = "1.0.109"
 termcolor            = "1.4.1"
 terminal_size        = "0.4.3"
-tikv-jemallocator    = "0.6.1"
+tikv-jemallocator    = "0.6.0"
 tokio                = "1.47.1"
 tower                = "0.5.2"
 tower-lsp-server     = "0.22.1"
diff --git a/crates/biome_grit_patterns/src/grit_code_snippet.rs b/crates/biome_grit_patterns/src/grit_code_snippet.rs
index 832574274d..538ce82094 100644
--- a/crates/biome_grit_patterns/src/grit_code_snippet.rs
+++ b/crates/biome_grit_patterns/src/grit_code_snippet.rs
@@ -1,13 +1,14 @@
 use crate::grit_context::{GritExecContext, GritQueryContext};
 use crate::grit_resolved_pattern::GritResolvedPattern;
 use crate::grit_target_node::GritTargetSyntaxKind;
+use biome_js_syntax::JsSyntaxKind;
 use grit_pattern_matcher::binding::Binding;
 use grit_pattern_matcher::context::ExecContext;
 use grit_pattern_matcher::pattern::{
     CodeSnippet, DynamicPattern, Matcher, Pattern, PatternName, ResolvedPattern, State,
 };
-use grit_util::AnalysisLogs;
 use grit_util::error::GritResult;
+use grit_util::{AnalysisLogs, AstNode};
 
 #[derive(Clone, Debug)]
 pub struct GritCodeSnippet {
@@ -42,11 +43,28 @@ impl Matcher<GritQueryContext> for GritCodeSnippet {
             return Ok(false);
         };
 
-        if let Some((_, pattern)) = self.patterns.iter().find(|(kind, _)| *kind == node.kind()) {
-            pattern.execute(resolved, state, context, logs)
-        } else {
-            Ok(false)
+        // First, try to match with the exact kind (fast path)
+        if let Some((_, pattern)) = self.patterns.iter().find(|(kind, _)| *kind == node.kind())
+            && pattern.execute(resolved, state, context, logs)?
+        {
+            return Ok(true);
         }
+
+        // If node has a single child, try matching against the child
+        // This handles wrapper nodes like JS_IDENTIFIER_EXPRESSION wrapping JS_REFERENCE_IDENTIFIER
+        if node.kind() == GritTargetSyntaxKind::JsSyntaxKind(JsSyntaxKind::JS_IDENTIFIER_EXPRESSION)
+            && let Some(child) = node.first_child()
+            && child.next_sibling().is_none()
+        {
+            let child_binding = GritResolvedPattern::from_node_binding(child);
+            for (_, pattern) in &self.patterns {
+                if pattern.execute(&child_binding, state, context, logs)? {
+                    return Ok(true);
+                }
+            }
+        }
+
+        Ok(false)
     }
 }
 
diff --git a/crates/biome_grit_patterns/src/pattern_compiler/snippet_compiler.rs b/crates/biome_grit_patterns/src/pattern_compiler/snippet_compiler.rs
index 056cdaa92a..a34e28cf87 100644
--- a/crates/biome_grit_patterns/src/pattern_compiler/snippet_compiler.rs
+++ b/crates/biome_grit_patterns/src/pattern_compiler/snippet_compiler.rs
@@ -494,6 +494,25 @@ mod tests {
     use grit_util::Parser;
     use regex::Regex;
 
+    #[test]
+    fn test_snippet_node_from_tree() {
+        let snippet: SnippetTree<GritTargetTree> =
+            GritJsParser.parse_snippet("", "buildConfig", "");
+        let node = node_from_tree(&snippet).expect("no node found");
+        let formatted = format!("{node:#?}");
+        insta::assert_snapshot!(&formatted, @r#"
+        GritTargetNode {
+            node: JsLanguage(
+                Node(
+                    0: JS_REFERENCE_IDENTIFIER@0..11
+                      0: IDENT@0..11 "buildConfig" [] []
+                    ,
+                ),
+            ),
+        }
+        "#);
+    }
+
     #[test]
     fn test_node_from_tree() {
         let snippet = GritJsParser.parse_snippet("", "console.log('hello')", "");
