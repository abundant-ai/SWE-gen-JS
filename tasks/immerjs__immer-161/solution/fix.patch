diff --git a/package.json b/package.json
index e722af9..f436663 100644
--- a/package.json
+++ b/package.json
@@ -39,7 +39,7 @@
     "dist/"
   ],
   "devDependencies": {
-    "@types/jest": "^22.0.0",
+    "@types/jest": "^22.2.3",
     "babel-cli": "^6.26.0",
     "babel-core": "^6.26.0",
     "babel-jest": "^22.0.4",
@@ -68,7 +68,8 @@
     "rollup-plugin-filesize": "^1.5.0",
     "rollup-plugin-node-resolve": "^3.0.2",
     "rollup-plugin-uglify": "^2.0.1",
-    "typescript": "^2.6.2",
+    "ts-jest": "^22.4.6",
+    "typescript": "^2.9.1",
     "uglify-es": "^3.3.6",
     "yarn-or-npm": "^2.0.4"
   },
@@ -80,7 +81,23 @@
   },
   "jest": {
     "transform": {
-      "^.+\\.jsx?$": "babel-jest"
-    }
+      "^.+\\.jsx?$": "babel-jest",
+      "^.+\\.tsx?$": "ts-jest"
+    },
+    "testRegex": "/__tests__/[^/]*[jt]sx?$",
+    "globals": {
+      "ts-jest": {
+        "enableTsDiagnostics": true,
+        "tsConfigFile": "__tests__/test.tsconfig.json"
+      }
+    },
+    "moduleFileExtensions": [
+      "ts",
+      "tsx",
+      "js",
+      "jsx",
+      "json",
+      "node"
+    ]
   }
 }
diff --git a/readme.md b/readme.md
index 07dafc3..90f580c 100644
--- a/readme.md
+++ b/readme.md
@@ -289,6 +289,30 @@ console.log(increment(base).counter) // 1
 
 The Immer package ships with type definitions inside the package, which should be picked up by TypeScript and Flow out of the box and without further configuration.
 
+The TypeScript typings automatically remove `readonly` modifiers from your draft types and return a value that matches your original type. See this practical example:
+
+```ts
+import produce from 'immer';
+
+interface State {
+  readonly x: number;
+}
+
+// `x` cannot be modified here
+const state: State = {
+  x: 0;
+};
+
+const newState = produce<State>(draft => {
+  // `x` can be modified here
+  draft.x++;
+});
+
+// `newState.x` cannot be modified here
+```
+
+This ensures that the only place you can modify your state is in your produce callbacks. It even works recursively and with `ReadonlyArray`s!
+
 ## Immer on older JavaScript environments?
 
 By default `produce` tries to use proxies for optimal performance. However, on older JavaScript engines `Proxy` is not available. For example, when running Microsoft Internet Explorer or React Native on Android. In such cases Immer will fallback to an ES5 compatible implementation which works identical, but is a bit slower.
diff --git a/src/immer.d.ts b/src/immer.d.ts
index e5e5839..51700ee 100644
--- a/src/immer.d.ts
+++ b/src/immer.d.ts
@@ -1,3 +1,15 @@
+// Mapped type to remove readonly modifiers from state
+// Based on https://github.com/Microsoft/TypeScript/blob/d4dc67aab233f5a8834dff16531baf99b16fea78/tests/cases/conformance/types/conditional/conditionalTypes1.ts#L120-L129
+export type DraftObject<T> = {
+  -readonly [P in keyof T]: Draft<T[P]>;
+};
+export interface DraftArray<T> extends Array<Draft<T>> { }
+export type Draft<T> =
+  T extends any[] ? DraftArray<T[number]> :
+  T extends ReadonlyArray<any> ? DraftArray<T[number]> :
+  T extends object ? DraftObject<T> :
+  T;
+
 /**
  * Immer takes a state, and runs a function against it.
  * That function can freely mutate the state, as it will create copies-on-write.
@@ -13,60 +25,60 @@
  */
 export default function<S = any>(
     currentState: S,
-    recipe: (this: S, draftState: S) => void | S
+    recipe: (this: Draft<S>, draftState: Draft<S>) => void | S
 ): S
 
 // curried invocations with default initial state
 // 0 additional arguments
 export default function<S = any>(
-    recipe: (this: S, draftState: S) => void | S,
+    recipe: (this: Draft<S>, draftState: Draft<S>) => void | S,
     initialState: S
 ): (currentState: S | undefined) => S
 // 1 additional argument of type A
 export default function<S = any, A = any>(
-    recipe: (this: S, draftState: S, a: A) => void | S,
+    recipe: (this: Draft<S>, draftState: Draft<S>, a: A) => void | S,
     initialState: S
 ): (currentState: S | undefined, a: A) => S
 // 2 additional arguments of types A and B
 export default function<S = any, A = any, B = any>(
-    recipe: (this: S, draftState: S, a: A, b: B) => void | S,
+    recipe: (this: Draft<S>, draftState: Draft<S>, a: A, b: B) => void | S,
     initialState: S
 ): (currentState: S | undefined, a: A, b: B) => S
 // 3 additional arguments of types A, B and C
 export default function<S = any, A = any, B = any, C = any>(
-    recipe: (this: S, draftState: S, a: A, b: B, c: C) => void | S,
+    recipe: (this: Draft<S>, draftState: Draft<S>, a: A, b: B, c: C) => void | S,
     initialState: S
 ): (currentState: S | undefined, a: A, b: B, c: C) => S
 // any number of additional arguments, but with loss of type safety
 // this may be alleviated if "variadic kinds" makes it into Typescript:
 // https://github.com/Microsoft/TypeScript/issues/5453
 export default function<S = any>(
-    recipe: (this: S, draftState: S, ...extraArgs: any[]) => void | S,
+    recipe: (this: Draft<S>, draftState: Draft<S>, ...extraArgs: any[]) => void | S,
     initialState: S
 ): (currentState: S | undefined, ...extraArgs: any[]) => S
 
 // curried invocations without default initial state
 // 0 additional arguments
 export default function<S = any>(
-    recipe: (this: S, draftState: S) => void | S
+    recipe: (this: Draft<S>, draftState: Draft<S>) => void | S
 ): (currentState: S) => S
 // 1 additional argument of type A
 export default function<S = any, A = any>(
-    recipe: (this: S, draftState: S, a: A) => void | S
+    recipe: (this: Draft<S>, draftState: Draft<S>, a: A) => void | S
 ): (currentState: S, a: A) => S
 // 2 additional arguments of types A and B
 export default function<S = any, A = any, B = any>(
-    recipe: (this: S, draftState: S, a: A, b: B) => void | S
+    recipe: (this: Draft<S>, draftState: Draft<S>, a: A, b: B) => void | S
 ): (currentState: S, a: A, b: B) => S
 // 3 additional arguments of types A, B and C
 export default function<S = any, A = any, B = any, C = any>(
-    recipe: (this: S, draftState: S, a: A, b: B, c: C) => void | S
+    recipe: (this: Draft<S>, draftState: Draft<S>, a: A, b: B, c: C) => void | S
 ): (currentState: S, a: A, b: B, c: C) => S
 // any number of additional arguments, but with loss of type safety
 // this may be alleviated if "variadic kinds" makes it into Typescript:
 // https://github.com/Microsoft/TypeScript/issues/5453
 export default function<S = any>(
-    recipe: (this: S, draftState: S, ...extraArgs: any[]) => void | S
+    recipe: (this: Draft<S>, draftState: Draft<S>, ...extraArgs: any[]) => void | S
 ): (currentState: S, ...extraArgs: any[]) => S
 /**
  * Automatically freezes any state trees generated by immer.
