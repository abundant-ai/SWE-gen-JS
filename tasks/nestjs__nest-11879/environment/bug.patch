diff --git a/packages/common/pipes/parse-bool.pipe.ts b/packages/common/pipes/parse-bool.pipe.ts
index 3d6d894cc..7f6bdffef 100644
--- a/packages/common/pipes/parse-bool.pipe.ts
+++ b/packages/common/pipes/parse-bool.pipe.ts
@@ -9,7 +9,6 @@ import {
   ErrorHttpStatusCode,
   HttpErrorByCode,
 } from '../utils/http-error-by-code.util';
-import { isNil } from '../utils/shared.utils';
 
 /**
  * @publicApi
@@ -17,7 +16,6 @@ import { isNil } from '../utils/shared.utils';
 export interface ParseBoolPipeOptions {
   errorHttpStatusCode?: ErrorHttpStatusCode;
   exceptionFactory?: (error: string) => any;
-  optional?: boolean;
 }
 
 /**
@@ -33,7 +31,7 @@ export class ParseBoolPipe
 {
   protected exceptionFactory: (error: string) => any;
 
-  constructor(@Optional() protected readonly options?: ParseBoolPipeOptions) {
+  constructor(@Optional() options?: ParseBoolPipeOptions) {
     options = options || {};
     const { exceptionFactory, errorHttpStatusCode = HttpStatus.BAD_REQUEST } =
       options;
@@ -53,9 +51,6 @@ export class ParseBoolPipe
     value: string | boolean,
     metadata: ArgumentMetadata,
   ): Promise<boolean> {
-    if (isNil(value) && this.options.optional) {
-      return value;
-    }
     if (this.isTrue(value)) {
       return true;
     }
diff --git a/packages/common/pipes/parse-enum.pipe.ts b/packages/common/pipes/parse-enum.pipe.ts
index 3fb75cbfb..7a88b5043 100644
--- a/packages/common/pipes/parse-enum.pipe.ts
+++ b/packages/common/pipes/parse-enum.pipe.ts
@@ -5,13 +5,11 @@ import {
   ErrorHttpStatusCode,
   HttpErrorByCode,
 } from '../utils/http-error-by-code.util';
-import { isNil } from '../utils/shared.utils';
 
 /**
  * @publicApi
  */
 export interface ParseEnumPipeOptions {
-  optional?: boolean;
   errorHttpStatusCode?: ErrorHttpStatusCode;
   exceptionFactory?: (error: string) => any;
 }
@@ -26,9 +24,10 @@ export interface ParseEnumPipeOptions {
 @Injectable()
 export class ParseEnumPipe<T = any> implements PipeTransform<T> {
   protected exceptionFactory: (error: string) => any;
+
   constructor(
     protected readonly enumType: T,
-    @Optional() protected readonly options?: ParseEnumPipeOptions,
+    @Optional() options?: ParseEnumPipeOptions,
   ) {
     if (!enumType) {
       throw new Error(
@@ -52,9 +51,6 @@ export class ParseEnumPipe<T = any> implements PipeTransform<T> {
    * @param metadata contains metadata about the currently processed route argument
    */
   async transform(value: T, metadata: ArgumentMetadata): Promise<T> {
-    if (isNil(value) && this.options.optional) {
-      return value;
-    }
     if (!this.isEnum(value)) {
       throw this.exceptionFactory(
         'Validation failed (enum string is expected)',
diff --git a/packages/common/pipes/parse-float.pipe.ts b/packages/common/pipes/parse-float.pipe.ts
index e5f8f0a59..c410303d4 100644
--- a/packages/common/pipes/parse-float.pipe.ts
+++ b/packages/common/pipes/parse-float.pipe.ts
@@ -5,7 +5,6 @@ import {
   ErrorHttpStatusCode,
   HttpErrorByCode,
 } from '../utils/http-error-by-code.util';
-import { isNil } from '../utils/shared.utils';
 
 /**
  * @publicApi
@@ -13,7 +12,6 @@ import { isNil } from '../utils/shared.utils';
 export interface ParseFloatPipeOptions {
   errorHttpStatusCode?: ErrorHttpStatusCode;
   exceptionFactory?: (error: string) => any;
-  optional?: boolean;
 }
 
 /**
@@ -27,7 +25,7 @@ export interface ParseFloatPipeOptions {
 export class ParseFloatPipe implements PipeTransform<string> {
   protected exceptionFactory: (error: string) => any;
 
-  constructor(@Optional() protected readonly options?: ParseFloatPipeOptions) {
+  constructor(@Optional() options?: ParseFloatPipeOptions) {
     options = options || {};
     const { exceptionFactory, errorHttpStatusCode = HttpStatus.BAD_REQUEST } =
       options;
@@ -45,9 +43,6 @@ export class ParseFloatPipe implements PipeTransform<string> {
    * @param metadata contains metadata about the currently processed route argument
    */
   async transform(value: string, metadata: ArgumentMetadata): Promise<number> {
-    if (isNil(value) && this.options.optional) {
-      return value;
-    }
     if (!this.isNumeric(value)) {
       throw this.exceptionFactory(
         'Validation failed (numeric string is expected)',
diff --git a/packages/common/pipes/parse-int.pipe.ts b/packages/common/pipes/parse-int.pipe.ts
index aeb305211..11303c7e4 100644
--- a/packages/common/pipes/parse-int.pipe.ts
+++ b/packages/common/pipes/parse-int.pipe.ts
@@ -9,7 +9,6 @@ import {
   ErrorHttpStatusCode,
   HttpErrorByCode,
 } from '../utils/http-error-by-code.util';
-import { isNil } from '../utils/shared.utils';
 
 /**
  * @publicApi
@@ -17,7 +16,6 @@ import { isNil } from '../utils/shared.utils';
 export interface ParseIntPipeOptions {
   errorHttpStatusCode?: ErrorHttpStatusCode;
   exceptionFactory?: (error: string) => any;
-  optional?: boolean;
 }
 
 /**
@@ -31,7 +29,7 @@ export interface ParseIntPipeOptions {
 export class ParseIntPipe implements PipeTransform<string> {
   protected exceptionFactory: (error: string) => any;
 
-  constructor(@Optional() protected readonly options?: ParseIntPipeOptions) {
+  constructor(@Optional() options?: ParseIntPipeOptions) {
     options = options || {};
     const { exceptionFactory, errorHttpStatusCode = HttpStatus.BAD_REQUEST } =
       options;
@@ -49,9 +47,6 @@ export class ParseIntPipe implements PipeTransform<string> {
    * @param metadata contains metadata about the currently processed route argument
    */
   async transform(value: string, metadata: ArgumentMetadata): Promise<number> {
-    if (isNil(value) && this.options.optional) {
-      return value;
-    }
     if (!this.isNumeric(value)) {
       throw this.exceptionFactory(
         'Validation failed (numeric string is expected)',
diff --git a/packages/common/pipes/parse-uuid.pipe.ts b/packages/common/pipes/parse-uuid.pipe.ts
index 7fea9f8b3..2379e36b6 100644
--- a/packages/common/pipes/parse-uuid.pipe.ts
+++ b/packages/common/pipes/parse-uuid.pipe.ts
@@ -9,7 +9,7 @@ import {
   ErrorHttpStatusCode,
   HttpErrorByCode,
 } from '../utils/http-error-by-code.util';
-import { isNil, isString } from '../utils/shared.utils';
+import { isString } from '../utils/shared.utils';
 
 /**
  * @publicApi
@@ -18,7 +18,6 @@ export interface ParseUUIDPipeOptions {
   version?: '3' | '4' | '5';
   errorHttpStatusCode?: ErrorHttpStatusCode;
   exceptionFactory?: (errors: string) => any;
-  optional?: boolean;
 }
 
 /**
@@ -39,7 +38,7 @@ export class ParseUUIDPipe implements PipeTransform<string> {
   private readonly version: '3' | '4' | '5';
   protected exceptionFactory: (errors: string) => any;
 
-  constructor(@Optional() protected readonly options?: ParseUUIDPipeOptions) {
+  constructor(@Optional() options?: ParseUUIDPipeOptions) {
     options = options || {};
     const {
       exceptionFactory,
@@ -54,9 +53,6 @@ export class ParseUUIDPipe implements PipeTransform<string> {
   }
 
   async transform(value: string, metadata: ArgumentMetadata): Promise<string> {
-    if (isNil(value) && this.options.optional) {
-      return value;
-    }
     if (!this.isUUID(value, this.version)) {
       throw this.exceptionFactory(
         `Validation failed (uuid${
diff --git a/packages/common/test/pipes/parse-bool.pipe.spec.ts b/packages/common/test/pipes/parse-bool.pipe.spec.ts
index c6420187f..7286db127 100644
--- a/packages/common/test/pipes/parse-bool.pipe.spec.ts
+++ b/packages/common/test/pipes/parse-bool.pipe.spec.ts
@@ -18,12 +18,6 @@ describe('ParseBoolPipe', () => {
         expect(await target.transform(false, {} as ArgumentMetadata)).to.be
           .false;
       });
-
-      it('should not throw an error if the value is undefined/null and optional is true', async () => {
-        const target = new ParseBoolPipe({ optional: true });
-        const value = await target.transform(undefined, {} as ArgumentMetadata);
-        expect(value).to.equal(undefined);
-      });
     });
     describe('when validation fails', () => {
       it('should throw an error', async () => {
diff --git a/packages/common/test/pipes/parse-enum.pipe.spec.ts b/packages/common/test/pipes/parse-enum.pipe.spec.ts
index ac49f4caf..77b57624e 100644
--- a/packages/common/test/pipes/parse-enum.pipe.spec.ts
+++ b/packages/common/test/pipes/parse-enum.pipe.spec.ts
@@ -14,17 +14,10 @@ describe('ParseEnumPipe', () => {
     Up = 'UP',
   }
   let target: ParseEnumPipe;
-  let tatargetWithOptionIsTrue: ParseEnumPipe;
-
   beforeEach(() => {
     target = new ParseEnumPipe(Direction, {
       exceptionFactory: (error: any) => new CustomTestError(),
     });
-
-    tatargetWithOptionIsTrue = new ParseEnumPipe(Direction, {
-      exceptionFactory: (error: any) => new CustomTestError(),
-      optional: true,
-    });
   });
   describe('transform', () => {
     describe('when validation passes', () => {
@@ -33,12 +26,6 @@ describe('ParseEnumPipe', () => {
           Direction.Up,
         );
       });
-
-      it('should not throw an error if enumType is undefined/null and optional is true', async () => {
-        const target = new ParseEnumPipe('DOWN', { optional: true });
-        const value = await target.transform(undefined, {} as ArgumentMetadata);
-        expect(value).to.equal(undefined);
-      });
     });
     describe('when validation fails', () => {
       it('should throw an error', async () => {
@@ -46,12 +33,6 @@ describe('ParseEnumPipe', () => {
           target.transform('DOWN', {} as ArgumentMetadata),
         ).to.be.rejectedWith(CustomTestError);
       });
-
-      it('should throw an error if enumType is wrong even optional is true', async () => {
-        return expect(
-          tatargetWithOptionIsTrue.transform('DOWN', {} as ArgumentMetadata),
-        ).to.be.rejectedWith(CustomTestError);
-      });
     });
   });
   describe('constructor', () => {
diff --git a/packages/common/test/pipes/parse-float.pipe.spec.ts b/packages/common/test/pipes/parse-float.pipe.spec.ts
index ff4351c43..ba92cba4d 100644
--- a/packages/common/test/pipes/parse-float.pipe.spec.ts
+++ b/packages/common/test/pipes/parse-float.pipe.spec.ts
@@ -25,11 +25,6 @@ describe('ParseFloatPipe', () => {
           parseFloat(num),
         );
       });
-      it('should not throw an error if the value is undefined/null and optional is true', async () => {
-        const target = new ParseFloatPipe({ optional: true });
-        const value = await target.transform(undefined, {} as ArgumentMetadata);
-        expect(value).to.equal(undefined);
-      });
     });
     describe('when validation fails', () => {
       it('should throw an error', async () => {
diff --git a/packages/common/test/pipes/parse-int.pipe.spec.ts b/packages/common/test/pipes/parse-int.pipe.spec.ts
index 8906b5a3a..d9d78de27 100644
--- a/packages/common/test/pipes/parse-int.pipe.spec.ts
+++ b/packages/common/test/pipes/parse-int.pipe.spec.ts
@@ -30,11 +30,6 @@ describe('ParseIntPipe', () => {
           -3,
         );
       });
-      it('should not throw an error if the value is undefined/null and optional is true', async () => {
-        const target = new ParseIntPipe({ optional: true });
-        const value = await target.transform(undefined, {} as ArgumentMetadata);
-        expect(value).to.equal(undefined);
-      });
     });
     describe('when validation fails', () => {
       it('should throw an error', async () => {
diff --git a/packages/common/test/pipes/parse-uuid.pipe.spec.ts b/packages/common/test/pipes/parse-uuid.pipe.spec.ts
index ae8c86b21..bcb3a76b3 100644
--- a/packages/common/test/pipes/parse-uuid.pipe.spec.ts
+++ b/packages/common/test/pipes/parse-uuid.pipe.spec.ts
@@ -41,11 +41,6 @@ describe('ParseUUIDPipe', () => {
         target = new ParseUUIDPipe({ version: '5', exceptionFactory });
         expect(await target.transform(v5, {} as ArgumentMetadata)).to.equal(v5);
       });
-      it('should not throw an error if the value is undefined/null and optional is true', async () => {
-        const target = new ParseUUIDPipe({ optional: true });
-        const value = await target.transform(undefined, {} as ArgumentMetadata);
-        expect(value).to.equal(undefined);
-      });
     });
 
     describe('when validation fails', () => {
