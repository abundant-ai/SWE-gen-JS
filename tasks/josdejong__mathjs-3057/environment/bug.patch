diff --git a/src/expression/embeddedDocs/function/matrix/eigs.js b/src/expression/embeddedDocs/function/matrix/eigs.js
index 09171abf4..ec389a198 100644
--- a/src/expression/embeddedDocs/function/matrix/eigs.js
+++ b/src/expression/embeddedDocs/function/matrix/eigs.js
@@ -4,10 +4,9 @@ export const eigsDocs = {
   syntax: [
     'eigs(x)'
   ],
-  description: 'Calculate the eigenvalues and optionally eigenvectors of a square matrix',
+  description: 'Calculate the eigenvalues and eigenvectors of a real symmetric matrix',
   examples: [
-    'eigs([[5, 2.3], [2.3, 1]])',
-    'eigs([[1, 2, 3], [4, 5, 6], [7, 8, 9]], { precision: 1e-6, eigenvectors: false }'
+    'eigs([[5, 2.3], [2.3, 1]])'
   ],
   seealso: [
     'inv'
diff --git a/src/function/matrix/eigs.js b/src/function/matrix/eigs.js
index 140176126..50edd5cb7 100644
--- a/src/function/matrix/eigs.js
+++ b/src/function/matrix/eigs.js
@@ -13,7 +13,7 @@ export const createEigs = /* #__PURE__ */ factory(name, dependencies, ({ config,
   const doComplexEigs = createComplexEigs({ config, addScalar, subtract, multiply, multiplyScalar, flatten, divideScalar, sqrt, abs, bignumber, diag, size, reshape, qr, inv, usolve, usolveAll, equal, complex, larger, smaller, matrixFromColumns, dot })
 
   /**
-   * Compute eigenvalues and optionally eigenvectors of a square matrix.
+   * Compute eigenvalues and eigenvectors of a square matrix.
    * The eigenvalues are sorted by their absolute value, ascending, and
    * returned as a vector in the `values` property of the returned project.
    * An eigenvalue with algebraic multiplicity k will be listed k times, so
@@ -31,21 +31,9 @@ export const createEigs = /* #__PURE__ */ factory(name, dependencies, ({ config,
    * in that case, however, you may still find useful information
    * in `err.values` and `err.vectors`.
    *
-   * Note that the 'precision' option does not directly specify the _accuracy_
-   * of the returned eigenvalues. Rather, it determines how small an entry
-   * of the iterative approximations to an upper triangular matrix must be
-   * in order to be considered zero. The actual accuracy of the returned
-   * eigenvalues may be greater or less than the precision, depending on the
-   * conditioning of the matrix and how far apart or close the actual
-   * eigenvalues are. Note that currently, relatively simple, "traditional"
-   * methods of eigenvalue computation are being used; this is not a modern,
-   * high-precision eigenvalue computation. That said, it should typically
-   * produce fairly reasonable results.
-   *
    * Syntax:
    *
    *     math.eigs(x, [prec])
-   *     math.eigs(x, {options})
    *
    * Examples:
    *
@@ -59,17 +47,14 @@ export const createEigs = /* #__PURE__ */ factory(name, dependencies, ({ config,
    *     const UTxHxU = multiply(transpose(U), H, U) // diagonalizes H if possible
    *     E[0] == UTxHxU[0][0]  // returns true always
    *
-   *     // Compute only approximate eigenvalues:
-   *     const {values} = eigs(H, {eigenvectors: false, precision: 1e-6})
-   *
    * See also:
    *
    *     inv
    *
    * @param {Array | Matrix} x  Matrix to be diagonalized
    *
-   * @param {number | BigNumber | OptsObject} [opts] Object with keys `precision`, defaulting to config.epsilon, and `eigenvectors`, defaulting to true and specifying whether to compute eigenvectors. If just a number, specifies precision.
-   * @return {{values: Array|Matrix, eigenvectors?: Array<EVobj>}} Object containing an array of eigenvalues and an array of {value: number|BigNumber, vector: Array|Matrix} objects. The eigenvectors property is undefined if eigenvectors were not requested.
+   * @param {number | BigNumber} [prec] Precision, default value: 1e-15
+   * @return {{values: Array|Matrix, eigenvectors: Array<EVobj>}} Object containing an array of eigenvalues and an array of {value: number|BigNumber, vector: Array|Matrix} objects.
    *
    */
   return typed('eigs', {
@@ -82,46 +67,38 @@ export const createEigs = /* #__PURE__ */ factory(name, dependencies, ({ config,
     // is a roundabout way of doing type detection.
     Array: function (x) { return doEigs(matrix(x)) },
     'Array, number|BigNumber': function (x, prec) {
-      return doEigs(matrix(x), { precision: prec })
+      return doEigs(matrix(x), prec)
     },
-    'Array, Object' (x, opts) { return doEigs(matrix(x), opts) },
     Matrix: function (mat) {
-      return doEigs(mat, { matricize: true })
+      return doEigs(mat, undefined, true)
     },
     'Matrix, number|BigNumber': function (mat, prec) {
-      return doEigs(mat, { precision: prec, matricize: true })
-    },
-    'Matrix, Object': function (mat, opts) {
-      const useOpts = { matricize: true }
-      Object.assign(useOpts, opts)
-      return doEigs(mat, useOpts)
+      return doEigs(mat, prec, true)
     }
   })
 
-  function doEigs (mat, opts = {}) {
-    const computeVectors = 'eigenvectors' in opts ? opts.eigenvectors : true
-    const prec = opts.precision ?? config.epsilon
-    const result = computeValuesAndVectors(mat, prec, computeVectors)
-    if (opts.matricize) {
+  function doEigs (mat, prec, matricize = false) {
+    const result = computeValuesAndVectors(mat, prec)
+    if (matricize) {
       result.values = matrix(result.values)
-      if (computeVectors) {
-        result.eigenvectors = result.eigenvectors.map(({ value, vector }) =>
-          ({ value, vector: matrix(vector) }))
-      }
-    }
-    if (computeVectors) {
-      Object.defineProperty(result, 'vectors', {
-        enumerable: false, // to make sure that the eigenvectors can still be
-        // converted to string.
-        get: () => {
-          throw new Error('eigs(M).vectors replaced with eigs(M).eigenvectors')
-        }
-      })
+      result.eigenvectors = result.eigenvectors.map(({ value, vector }) =>
+        ({ value, vector: matrix(vector) }))
     }
+    Object.defineProperty(result, 'vectors', {
+      enumerable: false, // to make sure that the eigenvectors can still be
+      // converted to string.
+      get: () => {
+        throw new Error('eigs(M).vectors replaced with eigs(M).eigenvectors')
+      }
+    })
     return result
   }
 
-  function computeValuesAndVectors (mat, prec, computeVectors) {
+  function computeValuesAndVectors (mat, prec) {
+    if (prec === undefined) {
+      prec = config.epsilon
+    }
+
     const arr = mat.toArray() // NOTE: arr is guaranteed to be unaliased
     // and so safe to modify in place
     const asize = mat.size()
@@ -137,12 +114,12 @@ export const createEigs = /* #__PURE__ */ factory(name, dependencies, ({ config,
 
       if (isSymmetric(arr, N, prec)) {
         const type = coerceTypes(mat, arr, N) // modifies arr by side effect
-        return doRealSymmetric(arr, N, prec, type, computeVectors)
+        return doRealSymmetric(arr, N, prec, type)
       }
     }
 
     const type = coerceTypes(mat, arr, N) // modifies arr by side effect
-    return doComplexEigs(arr, N, prec, type, computeVectors)
+    return doComplexEigs(arr, N, prec, type)
   }
 
   /** @return {boolean} */
diff --git a/src/function/matrix/eigs/complexEigs.js b/src/function/matrix/eigs/complexEigs.js
index 8c0b2eb22..fc376577f 100644
--- a/src/function/matrix/eigs/complexEigs.js
+++ b/src/function/matrix/eigs/complexEigs.js
@@ -10,7 +10,11 @@ export function createComplexEigs ({ addScalar, subtract, flatten, multiply, mul
    *
    * @returns {{ values: number[], vectors: number[][] }}
    */
-  function complexEigs (arr, N, prec, type, findVectors = true) {
+  function complexEigs (arr, N, prec, type, findVectors) {
+    if (findVectors === undefined) {
+      findVectors = true
+    }
+
     // TODO check if any row/col are zero except the diagonal
 
     // make sure corresponding rows and columns have similar magnitude
@@ -42,12 +46,13 @@ export function createComplexEigs ({ addScalar, subtract, flatten, multiply, mul
     // (So U = C^-1 arr C and the relationship between current arr
     // and original A is unchanged.)
 
+    let eigenvectors
+
     if (findVectors) {
-      const eigenvectors = findEigenvectors(arr, N, C, R, values, prec, type)
-      return { values, eigenvectors }
+      eigenvectors = findEigenvectors(arr, N, C, R, values, prec, type)
     }
 
-    return { values }
+    return { values, eigenvectors }
   }
 
   /**
@@ -90,8 +95,9 @@ export function createComplexEigs ({ addScalar, subtract, flatten, multiply, mul
 
         for (let j = 0; j < N; j++) {
           if (i === j) continue
-          colNorm = addScalar(colNorm, abs(arr[j][i]))
-          rowNorm = addScalar(rowNorm, abs(arr[i][j]))
+          const c = abs(arr[i][j]) // should be real
+          colNorm = addScalar(colNorm, c)
+          rowNorm = addScalar(rowNorm, c)
         }
 
         if (!equal(colNorm, 0) && !equal(rowNorm, 0)) {
@@ -130,13 +136,13 @@ export function createComplexEigs ({ addScalar, subtract, flatten, multiply, mul
               if (i === j) {
                 continue
               }
-              arr[i][j] = multiplyScalar(arr[i][j], g)
-              arr[j][i] = multiplyScalar(arr[j][i], f)
+              arr[i][j] = multiplyScalar(arr[i][j], f)
+              arr[j][i] = multiplyScalar(arr[j][i], g)
             }
 
             // keep track of transformations
             if (findVectors) {
-              Rdiag[i] = multiplyScalar(Rdiag[i], g)
+              Rdiag[i] = multiplyScalar(Rdiag[i], f)
             }
           }
         }
@@ -144,7 +150,7 @@ export function createComplexEigs ({ addScalar, subtract, flatten, multiply, mul
     }
 
     // return the diagonal row transformation matrix
-    return findVectors ? diag(Rdiag) : null
+    return diag(Rdiag)
   }
 
   /**
diff --git a/src/function/matrix/eigs/realSymmetric.js b/src/function/matrix/eigs/realSymmetric.js
index 2090a9a34..7e24d406d 100644
--- a/src/function/matrix/eigs/realSymmetric.js
+++ b/src/function/matrix/eigs/realSymmetric.js
@@ -7,31 +7,28 @@ export function createRealSymmetric ({ config, addScalar, subtract, abs, atan, c
    * @param {number} prec
    * @param {'number' | 'BigNumber'} type
    */
-  function main (arr, N, prec = config.epsilon, type, computeVectors) {
+  function main (arr, N, prec = config.epsilon, type) {
     if (type === 'number') {
-      return diag(arr, prec, computeVectors)
+      return diag(arr, prec)
     }
 
     if (type === 'BigNumber') {
-      return diagBig(arr, prec, computeVectors)
+      return diagBig(arr, prec)
     }
 
     throw TypeError('Unsupported data type: ' + type)
   }
 
   // diagonalization implementation for number (efficient)
-  function diag (x, precision, computeVectors) {
+  function diag (x, precision) {
     const N = x.length
     const e0 = Math.abs(precision / N)
     let psi
-    let Sij
-    if (computeVectors) {
-      Sij = new Array(N)
-      // Sij is Identity Matrix
-      for (let i = 0; i < N; i++) {
-        Sij[i] = Array(N).fill(0)
-        Sij[i][i] = 1.0
-      }
+    let Sij = new Array(N)
+    // Sij is Identity Matrix
+    for (let i = 0; i < N; i++) {
+      Sij[i] = Array(N).fill(0)
+      Sij[i][i] = 1.0
     }
     // initial error
     let Vab = getAij(x)
@@ -40,29 +37,26 @@ export function createRealSymmetric ({ config, addScalar, subtract, abs, atan, c
       const j = Vab[0][1]
       psi = getTheta(x[i][i], x[j][j], x[i][j])
       x = x1(x, psi, i, j)
-      if (computeVectors) Sij = Sij1(Sij, psi, i, j)
+      Sij = Sij1(Sij, psi, i, j)
       Vab = getAij(x)
     }
     const Ei = Array(N).fill(0) // eigenvalues
     for (let i = 0; i < N; i++) {
       Ei[i] = x[i][i]
     }
-    return sorting(clone(Ei), Sij, computeVectors)
+    return sorting(clone(Ei), clone(Sij))
   }
 
   // diagonalization implementation for bigNumber
-  function diagBig (x, precision, computeVectors) {
+  function diagBig (x, precision) {
     const N = x.length
     const e0 = abs(precision / N)
     let psi
-    let Sij
-    if (computeVectors) {
-      Sij = new Array(N)
-      // Sij is Identity Matrix
-      for (let i = 0; i < N; i++) {
-        Sij[i] = Array(N).fill(0)
-        Sij[i][i] = 1.0
-      }
+    let Sij = new Array(N)
+    // Sij is Identity Matrix
+    for (let i = 0; i < N; i++) {
+      Sij[i] = Array(N).fill(0)
+      Sij[i][i] = 1.0
     }
     // initial error
     let Vab = getAijBig(x)
@@ -71,7 +65,7 @@ export function createRealSymmetric ({ config, addScalar, subtract, abs, atan, c
       const j = Vab[0][1]
       psi = getThetaBig(x[i][i], x[j][j], x[i][j])
       x = x1Big(x, psi, i, j)
-      if (computeVectors) Sij = Sij1Big(Sij, psi, i, j)
+      Sij = Sij1Big(Sij, psi, i, j)
       Vab = getAijBig(x)
     }
     const Ei = Array(N).fill(0) // eigenvalues
@@ -79,7 +73,7 @@ export function createRealSymmetric ({ config, addScalar, subtract, abs, atan, c
       Ei[i] = x[i][i]
     }
     // return [clone(Ei), clone(Sij)]
-    return sorting(clone(Ei), Sij, computeVectors)
+    return sorting(clone(Ei), clone(Sij))
   }
 
   // get angle
@@ -240,15 +234,13 @@ export function createRealSymmetric ({ config, addScalar, subtract, abs, atan, c
   }
 
   // sort results
-  function sorting (E, S, computeVectors) {
+  function sorting (E, S) {
     const N = E.length
     const values = Array(N)
-    let vecs
-    if (computeVectors) {
-      vecs = Array(N)
-      for (let k = 0; k < N; k++) {
-        vecs[k] = Array(N)
-      }
+    const vecs = Array(N)
+
+    for (let k = 0; k < N; k++) {
+      vecs[k] = Array(N)
     }
     for (let i = 0; i < N; i++) {
       let minID = 0
@@ -260,14 +252,11 @@ export function createRealSymmetric ({ config, addScalar, subtract, abs, atan, c
         }
       }
       values[i] = E.splice(minID, 1)[0]
-      if (computeVectors) {
-        for (let k = 0; k < N; k++) {
-          vecs[i][k] = S[k][minID]
-          S[k].splice(minID, 1)
-        }
+      for (let k = 0; k < N; k++) {
+        vecs[i][k] = S[k][minID]
+        S[k].splice(minID, 1)
       }
     }
-    if (!computeVectors) return { values }
     const eigenvectors = vecs.map((vector, i) => ({ value: values[i], vector }))
     return { values, eigenvectors }
   }
diff --git a/test/typescript-tests/testTypes.ts b/test/typescript-tests/testTypes.ts
index c9ea0d5a3..23a1a34fd 100644
--- a/test/typescript-tests/testTypes.ts
+++ b/test/typescript-tests/testTypes.ts
@@ -1291,13 +1291,6 @@ Matrices examples
     const eig = math.eigs(D)
     assert.ok(math.deepEqual(eig.values, [1, 1]))
     assert.deepStrictEqual(eig.eigenvectors, [{ value: 1, vector: [1, 0] }])
-    const eigvv = math.eigs(D, { precision: 1e-6 })
-    assert.ok(math.deepEqual(eigvv.values, [1, 1]))
-    assert.deepStrictEqual(eigvv.eigenvectors, [{ value: 1, vector: [1, 0] }])
-    const eigv = math.eigs(D, { eigenvectors: false })
-    assert.ok(math.deepEqual(eigv.values, [1, 1]))
-    //@ts-expect-error  ...verify that eigenvectors not expected to be there
-    eigv.eigenvectors
   }
 
   // Fourier transform and inverse
diff --git a/test/unit-tests/function/matrix/eigs.test.js b/test/unit-tests/function/matrix/eigs.test.js
index 985022467..f77862d65 100644
--- a/test/unit-tests/function/matrix/eigs.test.js
+++ b/test/unit-tests/function/matrix/eigs.test.js
@@ -30,17 +30,13 @@ describe('eigs', function () {
       vector => assert(Array.isArray(vector) && vector[0] instanceof Complex)
     )
 
-    const id2 = matrix([[1, 0], [0, 1]])
-    const realSymMatrix = eigs(id2)
+    const realSymMatrix = eigs(matrix([[1, 0], [0, 1]]))
     assert(realSymMatrix.values instanceof Matrix)
     assert.deepStrictEqual(size(realSymMatrix.values), matrix([2]))
     testEigenvectors(realSymMatrix, vector => {
       assert(vector instanceof Matrix)
       assert.deepStrictEqual(size(vector), matrix([2]))
     })
-    // Check we get exact values in this trivial case with lower precision
-    const rough = eigs(id2, { precision: 1e-6 })
-    assert.deepStrictEqual(realSymMatrix, rough)
 
     const genericMatrix = eigs(matrix([[0, 1], [-1, 0]]))
     assert(genericMatrix.values instanceof Matrix)
@@ -98,18 +94,13 @@ describe('eigs', function () {
         [1.0, 1.0, 1.0]]).values,
     [0, 0, 3]
     )
-    const sym4 =
+    approx.deepEqual(eigs(
       [[0.6163396801190624, -3.8571699139231796, 2.852995822026198, 4.1957619745869845],
         [-3.8571699139231796, 0.7047577966772156, 0.9122549659760404, 0.9232933211541949],
         [2.852995822026198, 0.9122549659760404, 1.6598316026960402, -1.2931270747054358],
-        [4.1957619745869845, 0.9232933211541949, -1.2931270747054358, -4.665994662426116]]
-    const fullValues = eigs(sym4).values
-    approx.deepEqual(fullValues,
-      [-0.9135495807127523, 2.26552473288741, 5.6502090685149735, -8.687249803623432]
+        [4.1957619745869845, 0.9232933211541949, -1.2931270747054358, -4.665994662426116]]).values,
+    [-0.9135495807127523, 2.26552473288741, 5.6502090685149735, -8.687249803623432]
     )
-    const justEigs = eigs(sym4, { eigenvectors: false })
-    assert.deepStrictEqual(fullValues, justEigs.values)
-    assert.ok(!('eigenvectors' in justEigs))
   })
 
   it('calculates eigenvalues and eigenvectors for 5x5 matrix', function () {
@@ -156,12 +147,9 @@ describe('eigs', function () {
       [4.14, 4.27, 3.05, 2.24, 2.73, -4.47]]
     const ans = eigs(H)
     const E = ans.values
-    const justvalues = eigs(H, { eigenvectors: false })
-    assert.deepStrictEqual(E, justvalues.values)
     testEigenvectors(ans,
       (v, j) => approx.deepEqual(multiply(E[j], v), multiply(H, v))
     )
-    assert.ok(!('eigenvectors' in justvalues))
     const Vcols = ans.eigenvectors.map(obj => obj.vector)
     const V = matrixFromColumns(...Vcols)
     const VtHV = multiply(transpose(V), H, V)
@@ -240,17 +228,13 @@ describe('eigs', function () {
     const difficult = [[2, 0, 0], [-1, -1, 9], [0, -1, 5]]
     const poor = eigs(difficult, 1e-14)
     assert.strictEqual(poor.values.length, 3)
-    approx.deepEqual(poor.values, [2, 2, 2], 7e-6)
+    approx.deepEqual(poor.values, [2, 2, 2], 6e-6)
     // Note the eigenvectors are junk, so we don't test them. The function
     // eigs thinks there are three of them, for example. Hopefully some
     // future iteration of mathjs will be able to discover there is really
     // only one.
     const poorm = eigs(matrix(difficult), 1e-14)
     assert.deepStrictEqual(poorm.values.size(), [3])
-    // Make sure the precision argument can go in the options object
-    const stillbad = eigs(difficult, { precision: 1e-14, eigenvectors: false })
-    assert.deepStrictEqual(stillbad.values, poor.values)
-    assert.ok(!('eigenvectors' in stillbad))
   })
 
   it('diagonalizes matrix with bigNumber', function () {
@@ -267,9 +251,6 @@ describe('eigs', function () {
       [4.24, -4.68, -3.33, 1.67, 2.80, 2.73],
       [4.14, 4.27, 3.05, 2.24, 2.73, -4.47]])
     const ans = eigs(H)
-    const justvalues = eigs(H, { eigenvectors: false })
-    assert.deepStrictEqual(ans.values, justvalues.values)
-    assert.ok(!('eigenvectors' in justvalues))
     const E = ans.values
     const Vcols = ans.eigenvectors.map(obj => obj.vector)
     const V = matrixFromColumns(...Vcols)
diff --git a/types/index.d.ts b/types/index.d.ts
index c91a46526..a013d1c2d 100644
--- a/types/index.d.ts
+++ b/types/index.d.ts
@@ -1763,10 +1763,7 @@ declare namespace math {
      */
     eigs(
       x: MathCollection,
-      opts?:
-        | number
-        | BigNumber
-        | { precision?: number | BigNumber; eigenvectors?: true }
+      prec?: number | BigNumber
     ): {
       values: MathCollection
       eigenvectors: {
@@ -1774,10 +1771,7 @@ declare namespace math {
         vector: MathCollection
       }[]
     }
-    eigs(
-      x: MathCollection,
-      opts: { eigenvectors: false; precision?: number | BigNumber }
-    ): { values: MathCollection }
+
     /**
      * Compute the matrix exponential, expm(A) = e^A. The matrix must be
      * square. Not to be confused with exp(a), which performs element-wise
