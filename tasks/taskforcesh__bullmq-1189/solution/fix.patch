diff --git a/src/classes/queue-base.ts b/src/classes/queue-base.ts
index 7987c56fcc..46b2388ca6 100644
--- a/src/classes/queue-base.ts
+++ b/src/classes/queue-base.ts
@@ -1,5 +1,6 @@
 import { EventEmitter } from 'events';
 import { QueueBaseOptions, RedisClient } from '../interfaces';
+import { delay, DELAY_TIME_5, isNotConnectionError } from '../utils';
 import { RedisConnection } from './redis-connection';
 import { KeysMap, QueueKeys } from './queue-keys';
 
@@ -88,4 +89,23 @@ export class QueueBase extends EventEmitter {
   disconnect(): Promise<void> {
     return this.connection.disconnect();
   }
+
+  protected async checkConnectionError<T>(
+    fn: () => Promise<T>,
+    delayInMs = DELAY_TIME_5,
+  ): Promise<T> {
+    try {
+      return await fn();
+    } catch (error) {
+      if (isNotConnectionError(error as Error)) {
+        this.emit('error', <Error>error);
+      }
+
+      if (!this.closing && delayInMs) {
+        await delay(delayInMs);
+      } else {
+        return;
+      }
+    }
+  }
 }
diff --git a/src/classes/queue-events.ts b/src/classes/queue-events.ts
index 92e071e8ab..12e99fc9c4 100644
--- a/src/classes/queue-events.ts
+++ b/src/classes/queue-events.ts
@@ -2,11 +2,8 @@ import { QueueEventsOptions, RedisClient, StreamReadRaw } from '../interfaces';
 import {
   array2obj,
   clientCommandMessageReg,
-  DELAY_TIME_5,
-  delay,
-  isNotConnectionError,
   isRedisInstance,
-  QUEUE_EVENT_SUFFIX
+  QUEUE_EVENT_SUFFIX,
 } from '../utils';
 import { QueueBase } from './queue-base';
 import { RedisConnection } from './redis-connection';
@@ -225,16 +222,13 @@ export class QueueEvents extends QueueBase {
         const client = await this.client;
 
         try {
-          await client.client(
-            'setname',
-            this.clientName(QUEUE_EVENT_SUFFIX),
-          );
+          await client.client('setname', this.clientName(QUEUE_EVENT_SUFFIX));
         } catch (err) {
           if (!clientCommandMessageReg.test((<Error>err).message)) {
             throw err;
           }
         }
-      
+
         await this.consumeEvents(client);
       } catch (error) {
         this.running = false;
@@ -245,59 +239,46 @@ export class QueueEvents extends QueueBase {
     }
   }
 
-  private async consumeEvents(client: RedisClient) {
+  private async consumeEvents(client: RedisClient): Promise<void> {
     const opts: QueueEventsOptions = this.opts;
 
     const key = this.keys.events;
     let id = opts.lastEventId || '$';
 
     while (!this.closing) {
-      try {
-        // Cast to actual return type, see: https://github.com/DefinitelyTyped/DefinitelyTyped/issues/44301
-        const data: StreamReadRaw = (await client.xread(
-          'BLOCK',
-          opts.blockingTimeout,
-          'STREAMS',
-          key,
-          id,
-        )) as any;
-
-        if (data) {
-          const stream = data[0];
-          const events = stream[1];
-
-          for (let i = 0; i < events.length; i++) {
-            id = events[i][0];
-            const args = array2obj(events[i][1]);
-
-            //
-            // TODO: we may need to have a separate xtream for progress data
-            // to avoid this hack.
-            switch (args.event) {
-              case 'progress':
-                args.data = JSON.parse(args.data);
-                break;
-              case 'completed':
-                args.returnvalue = JSON.parse(args.returnvalue);
-                break;
-            }
-
-            const { event, ...restArgs } = args;
-
-            if (event === 'drained') {
-              this.emit(event, id);
-            } else {
-              this.emit(event as any, restArgs, id);
-              this.emit(`${event}:${restArgs.jobId}` as any, restArgs, id);
-            }
+      // Cast to actual return type, see: https://github.com/DefinitelyTyped/DefinitelyTyped/issues/44301
+      const data: StreamReadRaw = await this.checkConnectionError(() =>
+        client.xread('BLOCK', opts.blockingTimeout, 'STREAMS', key, id),
+      );
+      if (data) {
+        const stream = data[0];
+        const events = stream[1];
+
+        for (let i = 0; i < events.length; i++) {
+          id = events[i][0];
+          const args = array2obj(events[i][1]);
+
+          //
+          // TODO: we may need to have a separate xtream for progress data
+          // to avoid this hack.
+          switch (args.event) {
+            case 'progress':
+              args.data = JSON.parse(args.data);
+              break;
+            case 'completed':
+              args.returnvalue = JSON.parse(args.returnvalue);
+              break;
           }
-        }
-      } catch (err) {
-        if (isNotConnectionError(err as Error)) {
-          throw err;
-        }
 
-        await delay(DELAY_TIME_5);
+          const { event, ...restArgs } = args;
+
+          if (event === 'drained') {
+            this.emit(event, id);
+          } else {
+            this.emit(event as any, restArgs, id);
+            this.emit(`${event}:${restArgs.jobId}` as any, restArgs, id);
+          }
+        }
       }
     }
   }
diff --git a/src/classes/queue-scheduler.ts b/src/classes/queue-scheduler.ts
index 23642dd0ea..c88d222262 100644
--- a/src/classes/queue-scheduler.ts
+++ b/src/classes/queue-scheduler.ts
@@ -6,6 +6,9 @@ import {
 import {
   array2obj,
   clientCommandMessageReg,
+  DELAY_TIME_5,
+  delay,
+  isNotConnectionError,
   isRedisInstance,
   QUEUE_SCHEDULER_SUFFIX,
 } from '../utils';
@@ -15,11 +18,11 @@ import { RedisConnection } from './redis-connection';
 
 export interface QueueSchedulerListener {
   /**
-   * Listen to 'stalled' event.
+   * Listen to 'error' event.
    *
-   * This event is triggered when a job gets stalled.
+   * This event is triggered when an exception is thrown.
    */
-  stalled: (jobId: string, prev: string) => void;
+  error: (error: Error) => void;
 
   /**
    * Listen to 'failed' event.
@@ -27,6 +30,13 @@ export interface QueueSchedulerListener {
    * This event is triggered when a job has thrown an exception.
    */
   failed: (jobId: string, failedReason: Error, prev: string) => void;
+
+  /**
+   * Listen to 'stalled' event.
+   *
+   * This event is triggered when a job gets stalled.
+   */
+  stalled: (jobId: string, prev: string) => void;
 }
 
 /**
@@ -46,6 +56,7 @@ export interface QueueSchedulerListener {
  *
  */
 export class QueueScheduler extends QueueBase {
+  opts: QueueSchedulerOptions;
   private nextTimestamp = Number.MAX_VALUE;
   private isBlocked = false;
   private running = false;
@@ -70,13 +81,13 @@ export class QueueScheduler extends QueueBase {
       Connection,
     );
 
-    if (!(this.opts as QueueSchedulerOptions).stalledInterval) {
+    if (!this.opts.stalledInterval) {
       throw new Error('Stalled interval cannot be zero or undefined');
     }
 
     if (autorun) {
       this.run().catch(error => {
-        console.error(error);
+        this.emit('error', error);
       });
     }
   }
@@ -143,7 +154,7 @@ export class QueueScheduler extends QueueBase {
 
         while (!this.closing) {
           // Check if at least the min stalled check time has passed.
-          await this.moveStalledJobsToWait();
+          await this.checkConnectionError(() => this.moveStalledJobsToWait());
 
           // Listen to the delay event stream from lastDelayStreamTimestamp
           // Can we use XGROUPS to reduce redundancy?
@@ -179,15 +190,18 @@ export class QueueScheduler extends QueueBase {
             // for all kind of scenarios.
             //
             if (!this.closing) {
-              await client.xtrim(key, 'MAXLEN', '~', 100);
+              await this.checkConnectionError<number>(() =>
+                client.xtrim(key, 'MAXLEN', '~', 100),
+              );
             }
           }
 
           const now = Date.now();
-          const delay = this.nextTimestamp - now;
+          const nextDelayedJobDelay = this.nextTimestamp - now;
 
-          if (delay <= 0) {
+          if (nextDelayedJobDelay <= 0) {
             const [nextTimestamp, id] = await this.updateDelaySet(now);
+
             if (nextTimestamp) {
               this.nextTimestamp = nextTimestamp;
               streamLastId = id;
@@ -230,14 +244,18 @@ export class QueueScheduler extends QueueBase {
           );
         } catch (err) {
           // We can ignore closed connection errors
-          if ((<Error>err).message !== 'Connection is closed.') {
+          if (isNotConnectionError(err as Error)) {
             throw err;
           }
+
+          await delay(DELAY_TIME_5);
         } finally {
           this.isBlocked = false;
         }
       } else {
-        data = await client.xread('STREAMS', key, streamLastId);
+        data = await this.checkConnectionError(() =>
+          client.xread('STREAMS', key, streamLastId),
+        );
       }
 
       // Cast to actual return type, see: https://github.com/DefinitelyTyped/DefinitelyTyped/issues/44301
@@ -247,7 +265,11 @@ export class QueueScheduler extends QueueBase {
 
   private async updateDelaySet(timestamp: number): Promise<[number, string]> {
     if (!this.closing) {
-      return Scripts.updateDelaySet(this, timestamp);
+      const result = await this.checkConnectionError(() =>
+        Scripts.updateDelaySet(this, timestamp),
+      );
+
+      return result;
     }
     return [0, '0'];
   }
diff --git a/src/classes/redis-connection.ts b/src/classes/redis-connection.ts
index 68e4804d46..40b076c201 100644
--- a/src/classes/redis-connection.ts
+++ b/src/classes/redis-connection.ts
@@ -35,6 +35,7 @@ export class RedisConnection extends EventEmitter {
   private closing: boolean;
   private version: string;
   private handleClientError: (e: Error) => void;
+  private handleClientClose: () => void;
 
   constructor(
     opts?: ConnectionOptions,
@@ -81,6 +82,10 @@ export class RedisConnection extends EventEmitter {
       this.emit('error', err);
     };
 
+    this.handleClientClose = (): void => {
+      this.emit('error', new Error(CONNECTION_CLOSED_ERROR_MSG));
+    };
+
     this.initializing = this.init();
     this.initializing.catch(err => this.emit('error', err));
   }
@@ -161,6 +166,8 @@ export class RedisConnection extends EventEmitter {
     }
 
     this._client.on('error', this.handleClientError);
+    // ioredis treats connection errors as a different event ('close')
+    this._client.on('close', this.handleClientClose);
 
     await RedisConnection.waitUntilReady(this._client);
     await this.loadCommands();
@@ -219,6 +226,7 @@ export class RedisConnection extends EventEmitter {
         }
       } finally {
         this._client.off('error', this.handleClientError);
+        this._client.off('close', this.handleClientClose);
       }
     }
   }
diff --git a/src/classes/worker.ts b/src/classes/worker.ts
index 9fd047df3f..a7be573be9 100644
--- a/src/classes/worker.ts
+++ b/src/classes/worker.ts
@@ -173,8 +173,8 @@ export class Worker<
       drainDelay: 5,
       concurrency: 1,
       lockDuration: 30000,
-      runRetryDelay: 15000,
       autorun: true,
+      runRetryDelay: 15000,
       ...this.opts,
     };
 
