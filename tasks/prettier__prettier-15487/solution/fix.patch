diff --git a/src/language-js/parse/babel.js b/src/language-js/parse/babel.js
index 8e901e995..88c02de4f 100644
--- a/src/language-js/parse/babel.js
+++ b/src/language-js/parse/babel.js
@@ -26,6 +26,7 @@ const parseOptions = {
   allowUndeclaredExports: true,
   errorRecovery: true,
   createParenthesizedExpressions: true,
+  createImportExpressions: true,
   plugins: [
     // When adding a plugin, please add a test in `tests/format/js/babel-plugins`,
     // To remove plugins, remove it here and run `yarn test tests/format/js/babel-plugins` to verify
@@ -45,6 +46,8 @@ const parseOptions = {
     "importReflection",
     "explicitResourceManagement",
     ["importAttributes", { deprecatedAssertSyntax: true }],
+    "sourcePhaseImports",
+    "deferredImportEvaluation",
     ["optionalChainingAssign", { version: "2023-07" }],
   ],
   tokens: true,
diff --git a/src/language-js/print/call-expression.js b/src/language-js/print/call-expression.js
index 77dc92ef5..3b2755447 100644
--- a/src/language-js/print/call-expression.js
+++ b/src/language-js/print/call-expression.js
@@ -68,7 +68,7 @@ function printCallExpression(path, options, print) {
 
   const contents = [
     isNew ? "new " : "",
-    isDynamicImport ? "import" : print("callee"),
+    isDynamicImport ? printDynamicImportCallee(node) : print("callee"),
     optional,
     printFunctionTypeParameters(path, options, print),
     printCallArguments(path, options, print),
@@ -83,6 +83,13 @@ function printCallExpression(path, options, print) {
   return contents;
 }
 
+function printDynamicImportCallee(node) {
+  if (!node.phase) {
+    return "import";
+  }
+  return `import.${node.phase}`;
+}
+
 function isCommonsJsOrAmdCall(node, parentNode) {
   if (node.callee.type !== "Identifier") {
     return false;
diff --git a/src/language-js/print/module.js b/src/language-js/print/module.js
index fdae117fe..f5ffd1697 100644
--- a/src/language-js/print/module.js
+++ b/src/language-js/print/module.js
@@ -34,6 +34,7 @@ function printImportDeclaration(path, options, print) {
   return [
     "import",
     node.module ? " module" : "",
+    node.phase ? ` ${node.phase}` : "",
     printImportKind(node),
     printModuleSpecifiers(path, options, print),
     printModuleSource(path, options, print),
diff --git a/src/language-js/utils/index.js b/src/language-js/utils/index.js
index 754c0a99e..864fbd7a4 100644
--- a/src/language-js/utils/index.js
+++ b/src/language-js/utils/index.js
@@ -1050,9 +1050,15 @@ function getCallArguments(node) {
   if (node.type === "ImportExpression") {
     args = [node.source];
 
+    // import attributes
     if (node.attributes) {
       args.push(node.attributes);
     }
+
+    // deprecated import assertions
+    if (node.options) {
+      args.push(node.options);
+    }
   }
 
   callArgumentsCache.set(node, args);
@@ -1064,9 +1070,15 @@ function iterateCallArgumentsPath(path, iteratee) {
   if (node.type === "ImportExpression") {
     path.call((sourcePath) => iteratee(sourcePath, 0), "source");
 
+    // import attributes
     if (node.attributes) {
       path.call((sourcePath) => iteratee(sourcePath, 1), "attributes");
     }
+
+    // deprecated import assertions
+    if (node.options) {
+      path.call((sourcePath) => iteratee(sourcePath, 1), "options");
+    }
   } else {
     path.each(iteratee, "arguments");
   }
@@ -1074,12 +1086,17 @@ function iterateCallArgumentsPath(path, iteratee) {
 
 function getCallArgumentSelector(node, index) {
   if (node.type === "ImportExpression") {
-    if (index === 0 || index === (node.attributes ? -2 : -1)) {
+    if (index === 0 || index === (node.attributes || node.options ? -2 : -1)) {
       return "source";
     }
+    // import attributes
     if (node.attributes && (index === 1 || index === -1)) {
       return "attributes";
     }
+    // deprecated import assertions
+    if (node.options && (index === 1 || index === -1)) {
+      return "options";
+    }
     throw new RangeError("Invalid argument index");
   }
   if (index < 0) {
