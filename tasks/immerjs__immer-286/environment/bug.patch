diff --git a/__tests__/base.js b/__tests__/base.js
index c494f33..c73eb1f 100644
--- a/__tests__/base.js
+++ b/__tests__/base.js
@@ -1,16 +1,12 @@
 "use strict"
-import {Immer, nothing, original, isDraft, immerable} from "../src/index"
-import {each, shallowCopy, isEnumerable} from "../src/common"
+import {Immer, nothing, original, isDraft} from "../src/index"
+import {shallowCopy} from "../src/common"
 import deepFreeze from "deep-freeze"
 import cloneDeep from "lodash.clonedeep"
 import * as lodash from "lodash"
 
 jest.setTimeout(1000)
 
-test("immer should have no dependencies", () => {
-    expect(require("../package.json").dependencies).toBeUndefined()
-})
-
 runBaseTest("proxy (no freeze)", true, false)
 runBaseTest("proxy (autofreeze)", true, true)
 runBaseTest("proxy (autofreeze)(patch listener)", true, true, true)
@@ -47,7 +43,12 @@ function runBaseTest(name, useProxies, autoFreeze, useListener) {
             origBaseState = baseState = createBaseState()
         })
 
-        it("returns the original state when no changes are made", () => {
+        it("should return the original without modifications", () => {
+            const nextState = produce(baseState, () => {})
+            expect(nextState).toBe(baseState)
+        })
+
+        it("should return the original without modifications when reading stuff", () => {
             const nextState = produce(baseState, s => {
                 expect(s.aProp).toBe("hi")
                 expect(s.anObject.nested).toMatchObject({yummie: true})
@@ -55,16 +56,30 @@ function runBaseTest(name, useProxies, autoFreeze, useListener) {
             expect(nextState).toBe(baseState)
         })
 
-        it("does structural sharing", () => {
-            const random = Math.random()
+        it("should return a copy when modifying stuff", () => {
             const nextState = produce(baseState, s => {
-                s.aProp = random
+                s.aProp = "hello world"
             })
             expect(nextState).not.toBe(baseState)
-            expect(nextState.aProp).toBe(random)
+            expect(baseState.aProp).toBe("hi")
+            expect(nextState.aProp).toBe("hello world")
+            // structural sharing?
             expect(nextState.nested).toBe(baseState.nested)
         })
 
+        it("should preserve type", () => {
+            const nextState = produce(baseState, s => {
+                expect(Object.getPrototypeOf(s)).toBe(Object.prototype)
+                expect(Array.isArray(s.anArray)).toBe(true)
+                s.anArray.push(3)
+                s.aProp = "hello world"
+                expect(Object.getPrototypeOf(s)).toBe(Object.prototype)
+                expect(Array.isArray(s.anArray)).toBe(true)
+            })
+            expect(Object.getPrototypeOf(nextState)).toBe(Object.prototype)
+            expect(Array.isArray(nextState.anArray)).toBe(true)
+        })
+
         it("deep change bubbles up", () => {
             const nextState = produce(baseState, s => {
                 s.anObject.nested.yummie = false
@@ -110,396 +125,298 @@ function runBaseTest(name, useProxies, autoFreeze, useListener) {
             }
         })
 
-        it("can get property descriptors", () => {
-            const getDescriptor = Object.getOwnPropertyDescriptor
-            const baseState = deepFreeze([{a: 1}])
-            produce(baseState, arr => {
-                const obj = arr[0]
-                const desc = {
-                    configurable: true,
-                    enumerable: true,
-                    ...(useProxies && {writable: true})
-                }
-
-                // Known property
-                expect(getDescriptor(obj, "a")).toMatchObject(desc)
-                expect(getDescriptor(arr, 0)).toMatchObject(desc)
-
-                // Deleted property
-                delete obj.a
-                arr.pop()
-                expect(getDescriptor(obj, "a")).toBeUndefined()
-                expect(getDescriptor(arr, 0)).toBeUndefined()
-
-                // Unknown property
-                expect(getDescriptor(obj, "b")).toBeUndefined()
-                expect(getDescriptor(arr, 100)).toBeUndefined()
-
-                // Added property
-                obj.b = 2
-                arr[100] = 1
-                expect(getDescriptor(obj, "b")).toBeDefined()
-                expect(getDescriptor(arr, 100)).toBeDefined()
+        it("ignores single non-modification", () => {
+            const nextState = produce(baseState, s => {
+                s.aProp = "hi"
             })
+            expect(nextState).toBe(baseState)
         })
 
-        describe("array drafts", () => {
-            it("supports Array.isArray()", () => {
-                const nextState = produce(baseState, s => {
-                    expect(Array.isArray(s.anArray)).toBeTruthy()
-                    s.anArray.push(1)
-                })
-                expect(Array.isArray(nextState.anArray)).toBeTruthy()
-            })
-
-            it("supports index access", () => {
-                const value = baseState.anArray[0]
-                const nextState = produce(baseState, s => {
-                    expect(s.anArray[0]).toBe(value)
-                })
-                expect(nextState).toBe(baseState)
+        it("processes single modification", () => {
+            const nextState = produce(baseState, s => {
+                s.aProp = "hello"
+                s.aProp = "hi"
             })
+            expect(nextState).not.toBe(baseState)
+            expect(nextState).toEqual(baseState)
+        })
 
-            it("supports iteration", () => {
-                const base = [{id: 1, a: 1}, {id: 2, a: 1}]
-                const findById = (collection, id) => {
-                    for (const item of collection) {
-                        if (item.id === id) return item
-                    }
-                    return null
+        it("processes with for loop", () => {
+            const base = [{id: 1, a: 1}, {id: 2, a: 1}]
+            const findById = (collection, id) => {
+                for (const item of collection) {
+                    if (item.id === id) return item
                 }
-                const result = produce(base, draft => {
-                    const obj1 = findById(draft, 1)
-                    const obj2 = findById(draft, 2)
-                    obj1.a = 2
-                    obj2.a = 2
-                })
-                expect(result[0].a).toEqual(2)
-                expect(result[1].a).toEqual(2)
-            })
-
-            it("can assign an index via bracket notation", () => {
-                const nextState = produce(baseState, s => {
-                    s.anArray[3] = true
-                })
-                expect(nextState).not.toBe(baseState)
-                expect(nextState.anArray).not.toBe(baseState.anArray)
-                expect(nextState.anArray[3]).toEqual(true)
-            })
-
-            it("can use splice() to both add and remove items", () => {
-                const nextState = produce(baseState, s => {
-                    s.anArray.splice(1, 1, "a", "b")
-                })
-                expect(nextState.anArray).not.toBe(baseState.anArray)
-                expect(nextState.anArray[1]).toBe("a")
-                expect(nextState.anArray[2]).toBe("b")
-            })
-
-            it("can truncate via the length property", () => {
-                const baseLength = baseState.anArray.length
-                const nextState = produce(baseState, s => {
-                    s.anArray.length = baseLength - 1
-                })
-                expect(nextState.anArray).not.toBe(baseState.anArray)
-                expect(nextState.anArray.length).toBe(baseLength - 1)
-            })
-
-            it("can extend via the length property", () => {
-                const baseLength = baseState.anArray.length
-                const nextState = produce(baseState, s => {
-                    s.anArray.length = baseLength + 1
-                })
-                expect(nextState.anArray).not.toBe(baseState.anArray)
-                expect(nextState.anArray.length).toBe(baseLength + 1)
-            })
-
-            // Reported here: https://github.com/mweststrate/immer/issues/116
-            it("can pop then push", () => {
-                const nextState = produce([1, 2, 3], s => {
-                    s.pop()
-                    s.push(100)
-                })
-                expect(nextState).toEqual([1, 2, 100])
-            })
-
-            it("can be sorted", () => {
-                const baseState = [3, 1, 2]
-                const nextState = produce(baseState, s => {
-                    s.sort()
-                })
-                expect(nextState).not.toBe(baseState)
-                expect(nextState).toEqual([1, 2, 3])
+                return null
+            }
+            const result = produce(base, draft => {
+                const obj1 = findById(draft, 1)
+                const obj2 = findById(draft, 2)
+                obj1.a = 2
+                obj2.a = 2
             })
+            expect(result[0].a).toEqual(2)
+            expect(result[1].a).toEqual(2)
+        })
 
-            it("supports modifying nested objects", () => {
-                const baseState = [{a: 1}, {}]
-                const nextState = produce(baseState, s => {
-                    s[0].a++
-                    s[1].a = 0
-                })
-                expect(nextState).not.toBe(baseState)
-                expect(nextState[0].a).toBe(2)
-                expect(nextState[1].a).toBe(0)
-            })
+        it("works with objects without proto", () => {
+            const base = Object.create(null)
+            base.x = 1
+            base.y = Object.create(null)
+            base.y.y = 2
+            expect(base.__proto__).toBe(undefined)
+            const next = produce(base, draft => {
+                draft.y.z = 3
+                draft.y.y++
+                draft.x++
+            })
+            expect(next).toEqual({
+                x: 2,
+                y: {y: 3, z: 3}
+            })
+            expect(next.__proto__).toBe(undefined)
+        })
 
-            it("never preserves non-numeric properties", () => {
-                const baseState = []
-                baseState.x = 7
-                const nextState = produce(baseState, s => {
-                    s.push(3)
-                })
-                expect("x" in nextState).toBeFalsy()
+        it("should support reading arrays", () => {
+            const nextState = produce(baseState, s => {
+                s.anArray.slice()
             })
-
-            if (useProxies) {
-                it("throws when a non-numeric property is added", () => {
-                    expect(() => {
-                        produce([], d => {
-                            d.x = 3
-                        })
-                    }).toThrow(
-                        "Immer only supports setting array indices and the 'length' property"
-                    )
-                })
-
-                it("throws when a non-numeric property is deleted", () => {
-                    expect(() => {
-                        const baseState = []
-                        baseState.x = 7
-                        produce(baseState, d => {
-                            delete d.x
-                        })
-                    }).toThrow("Immer only supports deleting array indices")
-                })
-            }
+            expect(nextState.anArray).toBe(baseState.anArray)
+            expect(nextState).toBe(baseState)
         })
 
-        it("supports `immerable` symbol on constructor", () => {
-            class One {}
-            One[immerable] = true
-            const baseState = new One()
-            const nextState = produce(baseState, draft => {
-                expect(draft).not.toBe(baseState)
-                draft.foo = true
+        it("should support changing arrays", () => {
+            const nextState = produce(baseState, s => {
+                s.anArray[3] = true
             })
             expect(nextState).not.toBe(baseState)
-            expect(nextState.foo).toBeTruthy()
+            expect(nextState.anArray).not.toBe(baseState.anArray)
+            expect(nextState.anArray[3]).toEqual(true)
         })
 
-        it("preserves symbol properties", () => {
-            const test = Symbol("test")
-            const baseState = {[test]: true}
+        it("should support changing arrays - 2", () => {
             const nextState = produce(baseState, s => {
-                expect(s[test]).toBeTruthy()
-                s.foo = true
-            })
-            expect(nextState).toEqual({
-                [test]: true,
-                foo: true
+                s.anArray.splice(1, 1, "a", "b")
             })
+            expect(nextState).not.toBe(baseState)
+            expect(nextState.anArray).not.toBe(baseState.anArray)
+
+            expect(enumerableOnly(nextState.anArray)).toEqual([
+                3,
+                "a",
+                "b",
+                {c: 3},
+                1
+            ])
         })
 
-        it("preserves non-enumerable properties", () => {
-            const baseState = {}
-            // Non-enumerable object property
-            Object.defineProperty(baseState, "foo", {
-                value: {a: 1},
-                enumerable: false
-            })
-            // Non-enumerable primitive property
-            Object.defineProperty(baseState, "bar", {
-                value: 1,
-                enumerable: false
+        // Reported here: https://github.com/mweststrate/immer/issues/116
+        it("should support changing arrays - 3", () => {
+            const nextState = produce([1, 2, 3], s => {
+                s.pop()
+                s.push(100)
             })
+            expect(nextState).toEqual([1, 2, 100])
+        })
+
+        it("can delete array items", () => {
             const nextState = produce(baseState, s => {
-                expect(s.foo).toBeTruthy()
-                expect(isEnumerable(s, "foo")).toBeFalsy()
-                s.bar++
-                expect(isEnumerable(s, "foo")).toBeFalsy()
-                s.foo.a++
-                expect(isEnumerable(s, "foo")).toBeFalsy()
+                s.anArray.length = 3
             })
-            expect(nextState.foo).toBeTruthy()
-            expect(isEnumerable(nextState, "foo")).toBeFalsy()
+            expect(nextState).not.toBe(baseState)
+            expect(nextState.anObject).toBe(baseState.anObject)
+            expect(nextState.anArray).not.toBe(baseState.anArray)
+            expect(nextState.anArray).toEqual([3, 2, {c: 3}])
         })
 
-        it("throws on computed properties", () => {
-            const baseState = {}
-            Object.defineProperty(baseState, "foo", {
-                get: () => {},
-                enumerable: true
+        it("should support sorting arrays", () => {
+            const nextState = produce(baseState, s => {
+                s.anArray[2].c = 4
+                s.anArray.sort()
+                s.anArray[3].c = 5
             })
-            expect(() => {
-                produce(baseState, s => {
-                    // Proxies only throw once a change is made.
-                    if (useProxies) {
-                        s.modified = true
-                    }
-                })
-            }).toThrowError("Immer drafts cannot have computed properties")
+            expect(nextState).not.toBe(baseState)
+            expect(nextState.anArray).not.toBe(baseState.anArray)
+            expect(enumerableOnly(nextState.anArray)).toEqual([1, 2, 3, {c: 5}])
         })
 
-        it("allows inherited computed properties", () => {
-            const proto = {}
-            Object.defineProperty(proto, "foo", {
-                get() {
-                    return this.bar
-                },
-                set(val) {
-                    this.bar = val
-                }
+        it("should expose property descriptors", () => {
+            const nextState = produce([], s => {
+                expect(Object.getOwnPropertyDescriptor(s, 0)).toBe(undefined)
+                s.unshift("x")
+                expect(Object.getOwnPropertyDescriptor(s, 0)).toEqual({
+                    configurable: true,
+                    enumerable: true,
+                    value: "x",
+                    writable: true
+                })
+                expect(s.length).toBe(1)
+                expect(s[0] === "x").toBe(true)
             })
-            const baseState = Object.create(proto)
-            produce(baseState, s => {
-                expect(s.bar).toBeUndefined()
-                s.foo = {}
-                expect(s.bar).toBeDefined()
-                expect(s.foo).toBe(s.bar)
+            expect(nextState).toEqual(["x"])
+            expect(Object.getOwnPropertyDescriptor(nextState, 0)).toEqual({
+                configurable: !autoFreeze,
+                enumerable: true,
+                value: "x",
+                writable: !autoFreeze
             })
         })
 
-        it("supports a base state with multiple references to an object", () => {
-            const obj = {}
-            const res = produce({a: obj, b: obj}, d => {
-                // Two drafts are created for each occurrence of an object in the base state.
-                expect(d.a).not.toBe(d.b)
-                d.a.z = true
-                expect(d.b.z).toBeUndefined()
+        it("should support sorting arrays - 2", () => {
+            const nextState = produce(baseState, s => {
+                s.anArray.unshift("x")
+                s.anArray[3].c = 4
+                s.anArray.sort()
+                s.anArray[3].c = 5
+                s.anArray.unshift("y")
             })
-            expect(res.b).toBe(obj)
-            expect(res.a).not.toBe(res.b)
-            expect(res.a.z).toBeTruthy()
+            expect(nextState).not.toBe(baseState)
+            expect(nextState.anArray).not.toBe(baseState.anArray)
+            expect(enumerableOnly(nextState.anArray)).toEqual([
+                "y",
+                1,
+                2,
+                3,
+                {c: 5},
+                "x"
+            ])
         })
 
-        // NOTE: Except the root draft.
-        it("supports multiple references to any modified draft", () => {
-            const next = produce({a: {b: 1}}, d => {
-                d.a.b++
-                d.b = d.a
+        it("should updating inside arrays", () => {
+            const nextState = produce(baseState, s => {
+                s.anArray[2].test = true
             })
-            expect(next.a).toBe(next.b)
+            expect(nextState).not.toBe(baseState)
+            expect(nextState.anArray).not.toBe(baseState.anArray)
+            expect(nextState.anArray).toEqual([3, 2, {c: 3, test: true}, 1])
         })
 
         it("can rename nested objects (no changes)", () => {
-            const nextState = produce({obj: {}}, s => {
-                s.foo = s.obj
-                delete s.obj
+            const nextState = produce(baseState, s => {
+                const obj = s.anObject
+                delete s.anObject
+                s.renamed = obj
+            })
+            expect(nextState).not.toBe(baseState)
+            expect(nextState.anArray).toBe(baseState.anArray)
+            expect(nextState.renamed.nested).toBe(baseState.anObject.nested)
+            expect(enumerableOnly(nextState)).toEqual({
+                anArray: [3, 2, {c: 3}, 1],
+                aProp: "hi",
+                renamed: {
+                    nested: {
+                        yummie: true
+                    },
+                    coffee: false
+                }
             })
-            expect(nextState).toEqual({foo: {}})
         })
 
         // Very similar to the test before, but the reused object has one
         // property changed, one added, and one removed.
         it("can rename nested objects (with changes)", () => {
-            const nextState = produce({obj: {a: 1, b: 1}}, s => {
-                s.obj.a = true // change
-                delete s.obj.b // delete
-                s.obj.c = true // add
+            const nextState = produce(baseState, s => {
+                const obj = s.anObject
+                delete s.anObject
+
+                obj.coffee = true // change
+                obj.nested.yummy = true // add
+                delete obj.nested.yummie // delete
 
-                s.foo = s.obj
-                delete s.obj
+                s.renamed = obj
+            })
+            expect(nextState).not.toBe(baseState)
+            expect(nextState.anArray).toBe(baseState.anArray)
+            expect(nextState.renamed.nested).not.toBe(baseState.anObject.nested)
+            expect(enumerableOnly(nextState)).toEqual({
+                anArray: [3, 2, {c: 3}, 1],
+                aProp: "hi",
+                renamed: {
+                    nested: {
+                        yummy: true
+                    },
+                    coffee: true
+                }
             })
-            expect(nextState).toEqual({foo: {a: true, c: true}})
         })
 
         it("can nest a draft in a new object (no changes)", () => {
-            const baseState = {obj: {}}
             const nextState = produce(baseState, s => {
-                s.foo = {bar: s.obj}
-                delete s.obj
+                s.foo = {bar: s.anObject}
+                delete s.anObject
             })
-            expect(nextState.foo.bar).toBe(baseState.obj)
+            expect(nextState).not.toBe(baseState)
+            expect(nextState.foo.bar).toBe(baseState.anObject)
         })
 
-        it("can nest a modified draft in a new object", () => {
-            const nextState = produce({obj: {a: 1, b: 1}}, s => {
-                s.obj.a = true // change
-                delete s.obj.b // delete
-                s.obj.c = true // add
+        it("can nest a draft in a new object (with changes)", () => {
+            const nextState = produce(baseState, s => {
+                const obj = s.anObject
+                delete s.anObject
 
-                s.foo = {bar: s.obj}
-                delete s.obj
-            })
-            expect(nextState).toEqual({foo: {bar: {a: true, c: true}}})
-        })
+                obj.coffee = true // change
+                obj.nested.yummy = true // add
+                delete obj.nested.yummie // delete
 
-        it("supports assigning undefined to an existing property", () => {
-            const nextState = produce(baseState, s => {
-                s.aProp = undefined
+                s.foo = {bar: obj}
             })
             expect(nextState).not.toBe(baseState)
-            expect(nextState.aProp).toBe(undefined)
+            expect(nextState.foo.bar).not.toBe(baseState.anObject)
+            expect(nextState.foo).toEqual({
+                bar: {
+                    coffee: true,
+                    nested: {yummy: true}
+                }
+            })
         })
 
-        it("supports assigning undefined to a new property", () => {
-            const baseState = {}
+        it("should allow setting to undefined a defined draft property", () => {
             const nextState = produce(baseState, s => {
                 s.aProp = undefined
             })
             expect(nextState).not.toBe(baseState)
+            expect(baseState.aProp).toBe("hi")
             expect(nextState.aProp).toBe(undefined)
         })
 
-        // NOTE: ES5 drafts only protect existing properties when revoked.
-        it("revokes the draft once produce returns", () => {
-            const expectRevoked = (fn, shouldThrow = true) => {
-                if (shouldThrow) expect(fn).toThrowError(/revoked/)
-                else expect(fn).not.toThrow()
-            }
-
-            // Test object drafts:
-            let draft
-            produce({a: 1, b: 1}, s => {
-                draft = s
-                delete s.b
-            })
-
-            // Access known property on object draft.
-            expectRevoked(() => {
-                draft.a
-            })
-
-            // Assign known property on object draft.
-            expectRevoked(() => {
-                draft.a = true
-            })
-
-            // Access unknown property on object draft.
-            expectRevoked(() => {
-                draft.z
-            }, useProxies)
-
-            // Assign unknown property on object draft.
-            expectRevoked(() => {
-                draft.z = true
-            }, useProxies)
+        // ES implementation does't protect against all outside modifications, just some..
+        if (useProxies) {
+            it("should revoke the proxy of the baseState after immer function is executed", () => {
+                let proxy
+                const nextState = produce(baseState, s => {
+                    proxy = s
+                    s.aProp = "hello"
+                })
+                expect(nextState).not.toBe(baseState)
+                expect(baseState.aProp).toBe("hi")
+                expect(nextState.aProp).toBe("hello")
 
-            // Test array drafts:
-            produce([1, 2], s => {
-                draft = s
-                s.pop()
-            })
+                expect(() => {
+                    proxy.aProp = "Hallo"
+                }).toThrowError(/revoked/)
+                expect(() => {
+                    const aProp = proxy.aProp
+                }).toThrowError(/revoked/)
 
-            // Access known index of an array draft.
-            expectRevoked(() => {
-                draft[0]
+                expect(nextState).not.toBe(baseState)
+                expect(baseState.aProp).toBe("hi")
+                expect(nextState.aProp).toBe("hello")
             })
+        }
 
-            // Assign known index of an array draft.
-            expectRevoked(() => {
-                draft[0] = true
+        it("should revoke the proxy of the baseState after immer function is executed - 2", () => {
+            let proxy
+            const nextState = produce(baseState, s => {
+                proxy = s.anObject
             })
-
-            // Access unknown index of an array draft.
-            expectRevoked(() => {
-                draft[1]
-            }, useProxies)
-
-            // Assign unknown index of an array draft.
-            expectRevoked(() => {
-                draft[1] = true
-            }, useProxies)
+            expect(nextState).toBe(baseState)
+            expect(() => {
+                // In ES5 implemenation only protects existing props, but alas..
+                proxy.coffee = "Hallo"
+            }).toThrowError(/revoked/)
+            expect(() => {
+                const test = proxy.coffee
+            }).toThrowError(/revoked/)
         })
 
         it("can access a child draft that was created before the draft was modified", () => {
@@ -526,8 +443,93 @@ function runBaseTest(name, useProxies, autoFreeze, useListener) {
             })
         })
 
-        if (useProxies)
-            it("throws when Object.defineProperty() is used on drafts", () => {
+        it("should be able to get property descriptors from objects", () => {
+            produce({a: 1}, draft => {
+                expect("a" in draft).toBe(true)
+                expect("b" in draft).toBe(false)
+                expect(
+                    Reflect.ownKeys(draft).filter(x => typeof x === "string")
+                ).toEqual(["a"])
+
+                expect(
+                    Object.getOwnPropertyDescriptor(draft, "a")
+                ).toMatchObject({
+                    configurable: true,
+                    enumerable: true
+                })
+                draft.a = 2
+                expect(
+                    Object.getOwnPropertyDescriptor(draft, "a")
+                ).toMatchObject({
+                    configurable: true,
+                    enumerable: true
+                })
+                expect(
+                    Object.getOwnPropertyDescriptor(draft, "b")
+                ).toBeUndefined()
+                draft.b = 2
+                expect(
+                    Object.getOwnPropertyDescriptor(draft, "b")
+                ).toMatchObject({
+                    configurable: true,
+                    enumerable: true
+                })
+                expect("a" in draft).toBe(true)
+                expect("b" in draft).toBe(true)
+                expect(
+                    Reflect.ownKeys(draft).filter(x => typeof x === "string")
+                ).toEqual(["a", "b"])
+            })
+        })
+
+        it("should be able to get property descriptors from arrays", () => {
+            produce([1], draft => {
+                expect(0 in draft).toBe(true)
+                expect(1 in draft).toBe(false)
+                expect("0" in draft).toBe(true)
+                expect("1" in draft).toBe(false)
+                expect(length in draft).toBe(true)
+                expect(
+                    Reflect.ownKeys(draft).filter(x => typeof x === "string")
+                ).toEqual(["0", "length"])
+
+                expect(
+                    Object.getOwnPropertyDescriptor(draft, "length")
+                ).toMatchObject({
+                    configurable: false,
+                    enumerable: false
+                })
+                draft[0] = 2
+                expect(Object.getOwnPropertyDescriptor(draft, 0)).toMatchObject(
+                    {
+                        configurable: true,
+                        enumerable: true
+                    }
+                )
+                expect(Object.getOwnPropertyDescriptor(draft, 0)).toMatchObject(
+                    {
+                        configurable: true,
+                        enumerable: true
+                    }
+                )
+                expect(
+                    Object.getOwnPropertyDescriptor(draft, 1)
+                ).toBeUndefined()
+                draft[1] = 2
+                expect(Object.getOwnPropertyDescriptor(draft, 1)).toMatchObject(
+                    {
+                        configurable: true,
+                        enumerable: true
+                    }
+                )
+                expect(
+                    Reflect.ownKeys(draft).filter(x => typeof x === "string")
+                ).toEqual(["0", "1", "length"])
+            })
+        })
+
+        if (useProxies === true) {
+            it("should not be possible to set property descriptors", () => {
                 expect(() => {
                     produce({}, draft => {
                         Object.defineProperty(draft, "xx", {
@@ -536,17 +538,122 @@ function runBaseTest(name, useProxies, autoFreeze, useListener) {
                             value: 2
                         })
                     })
+                }).toThrowError(/not support/)
+            })
+
+            it("should not be possible to add properties to arrays", () => {
+                expect(() => {
+                    produce([], d => {
+                        d.x = 3
+                    })
+                }).toThrow(
+                    "Immer does not support setting non-numeric properties on arrays"
+                )
+            })
+
+            it("should not be possible to remove properties from arrays", () => {
+                expect(() => {
+                    const base = []
+                    base.x = 7
+                    produce(base, d => {
+                        delete d.x
+                    })
                 }).toThrow(
-                    "Object.defineProperty() cannot be used on an Immer draft"
+                    "Immer does not support deleting properties from arrays"
                 )
             })
+        }
+
+        it("non-numeric array properties will be lost", () => {
+            const base = []
+            base.x = 7
+            const next = produce(base, d => {
+                d.push(3)
+            })
+            expect(next.x).toBe(undefined)
+        })
+
+        it("should not throw error, see #53 - 1", () => {
+            const base = {arr: [{count: 1}, {count: 2}, {count: 3}]}
+            const result = produce(base, draft => {
+                draft.arr = draft.arr.filter(item => item.count > 2)
+            })
+            expect(result.arr[0].count).toEqual(3)
+            expect(result).toEqual({
+                arr: [{count: 3}]
+            })
+            expect(result.arr[0]).toBe(base.arr[2])
+        })
+
+        it("should not throw error, see #53 - 2", () => {
+            const base = {arr: [{count: 1}, {count: 2}, {count: 3}]}
+            const result = produce(base, draft => {
+                draft.newArr = draft.arr.filter(item => item.count > 2)
+            })
+            expect(result.newArr[0].count).toEqual(3)
+            expect(result.arr).toBe(base.arr)
+            expect(result).toEqual({
+                arr: [
+                    {
+                        count: 1
+                    },
+                    {
+                        count: 2
+                    },
+                    {
+                        count: 3
+                    }
+                ],
+                newArr: [
+                    {
+                        count: 3
+                    }
+                ]
+            })
+            expect(result.newArr[0]).toBe(base.arr[2])
+            expect(result.arr[2]).toBe(base.arr[2])
+        })
+
+        it("should not throw error, see #53 - 3", () => {
+            const base = {arr: [{count: 1}, {count: 2}, {count: 3}]}
+            const result = produce(base, draft => {
+                draft.newArr = draft.arr.filter(item => item.count > 2)
+                delete draft.arr
+            })
+            expect(result.newArr[0].count).toEqual(3)
+            expect(result).toEqual({
+                newArr: [{count: 3}]
+            })
+            expect(result.newArr[0]).toBe(base.arr[2])
+        })
+
+        it("should not throw error, see #53 - 4", () => {
+            const base = {bear: {age: 10}}
+            const result = produce(base, draft => {
+                draft.bear.legs = 4
+                draft.room = {elephant: {kiddo: draft.bear}}
+            })
+            expect(result).toEqual({
+                bear: {age: 10, legs: 4},
+                room: {elephant: {kiddo: {age: 10, legs: 4}}}
+            })
+
+            const result2 = produce(result, draft => {
+                draft.bear.age = 11
+                draft.room.elephant.kiddo.legs = 5
+            })
+            expect(result2).toEqual({
+                bear: {age: 11, legs: 4},
+                room: {elephant: {kiddo: {age: 10, legs: 5}}}
+            })
+        })
 
         it("should handle constructor correctly", () => {
-            const baseState = {
+            const base = {
                 arr: new Array(),
                 obj: new Object()
             }
-            const result = produce(baseState, draft => {
+            const result = produce(base, draft => {
                 draft.arrConstructed = draft.arr.constructor(1)
                 draft.objConstructed = draft.obj.constructor(1)
             })
@@ -554,57 +661,96 @@ function runBaseTest(name, useProxies, autoFreeze, useListener) {
             expect(result.objConstructed).toEqual(new Object().constructor(1))
         })
 
+        it("should handle dates correctly", () => {
+            const data = {date: new Date()}
+            const next = produce(data, draft => {
+                draft.x = true
+            })
+            expect(next).toEqual({x: true, date: data.date})
+            expect(next.date).toBe(data.date)
+            const next2 = produce(next, draft => {
+                draft.date.setYear(2015)
+            })
+            // This still holds; because produce won't proxy Date objects
+            // and the original is actually modified!
+            expect(next2).toEqual({x: true, date: data.date})
+            expect(next2.date).toBe(next.date)
+            expect(next2.date).toBe(data.date)
+            expect(next2).toBe(next)
+        })
+
         it("should handle equality correctly - 1", () => {
-            const baseState = {
+            const base = {
                 y: 3 / 0,
                 z: NaN
             }
-            const nextState = produce(baseState, draft => {
+            const next = produce(base, draft => {
                 draft.y = 4 / 0
                 draft.z = NaN
             })
-            expect(nextState).toBe(baseState)
+            expect(next).toEqual(base)
+            expect(next).toBe(base)
         })
 
         it("should handle equality correctly - 2", () => {
-            const baseState = {
+            const base = {
                 x: -0
             }
-            const nextState = produce(baseState, draft => {
-                draft.x = +0
+            const next = produce(base, draft => {
+                draft.x = +1
             })
-            expect(nextState).not.toBe(baseState)
-            expect(nextState).not.toEqual(baseState)
+            expect(next).not.toEqual(base)
+            expect(next).not.toBe(base)
         })
 
         // AKA: recursive produce calls
-        describe("nested producers", () => {
+        describe("a nested producer", () => {
             describe("when base state is not a draft", () => {
                 // This test ensures the global state used to manage proxies is
                 // never left in a corrupted state by a nested `produce` call.
                 it("never affects its parent producer implicitly", () => {
-                    const base = {obj: {a: 1}}
-                    const next = produce(base, draft => {
-                        // Notice how `base.obj` is passed, not `draft.obj`
-                        const obj2 = produce(base.obj, draft2 => {
-                            draft2.a = 0
+                    const bear = {paw: {honey: true}}
+                    const next = produce(bear, draft => {
+                        const paw2 = produce(bear.paw, draft => {
+                            draft.honey = false
+                        })
+                        expect(paw2.honey).toBe(false)
+                        expect(draft.paw.honey).toBe(true) // effects should not be visible outside
+                    })
+                    expect(next.paw.honey).toBe(true)
+                    expect(next).toBe(bear)
+                })
+
+                it("returns a normal object", () => {
+                    const bear = {paw: {honey: true}}
+                    const next = produce(bear, draft => {
+                        const paw2 = produce(bear.paw, draft => {
+                            draft.honey = false
                         })
-                        expect(obj2.a).toBe(0)
-                        expect(draft.obj.a).toBe(1) // effects should not be visible outside
+                        expect(paw2.honey).toBe(false)
+                        expect(draft.paw.honey).toBe(true)
+                        draft.paw = paw2
+                        expect(draft.paw.honey).toBe(false)
                     })
-                    expect(next).toBe(base)
+                    expect(next.paw.honey).toBe(false)
+                    expect(next).not.toBe(bear)
                 })
             })
 
             describe("when base state is a draft", () => {
-                it("always wraps the draft in a new draft", () => {
-                    produce({}, parent => {
-                        produce(parent, child => {
-                            expect(child).not.toBe(parent)
-                            expect(isDraft(child)).toBeTruthy()
-                            expect(original(child)).toBe(parent)
+                it("always reuses the draft", () => {
+                    const bear = {paw: {honey: true}}
+                    const next = produce(bear, bear => {
+                        const paw2 = produce(bear.paw, paw => {
+                            expect(paw).toBe(bear.paw)
+                            paw.honey = false
                         })
+                        expect(paw2).toBe(bear.paw)
+                        expect(paw2.honey).toBe(false)
+                        expect(bear.paw.honey).toBe(false)
                     })
+                    expect(next.paw.honey).toBe(false)
+                    expect(next).not.toBe(bear)
                 })
             })
 
@@ -614,7 +760,6 @@ function runBaseTest(name, useProxies, autoFreeze, useListener) {
                         produce({a: parent.a}, child => {
                             expect(child.a).not.toBe(parent.a)
                             expect(isDraft(child.a)).toBeTruthy()
-                            expect(original(child.a)).toBe(parent.a)
                         })
                     })
                 })
@@ -690,32 +835,72 @@ function runBaseTest(name, useProxies, autoFreeze, useListener) {
             })
         })
 
+        it("should not try to change immutable data, see #66", () => {
+            const user = require("./test-data")
+
+            const base = {}
+            const next = produce(base, draft => {
+                draft.user = user
+            })
+            expect(next.user).toBe(user)
+            expect(next).not.toBe(base)
+            expect(next.user).toEqual(user)
+        })
+
+        it("should not try to change immutable data, see #66 - 2", () => {
+            const user = deepFreeze(cloneDeep(require("./test-data")))
+
+            const base = {}
+            const next = produce(base, draft => {
+                draft.user = user
+            })
+            expect(next.user).toBe(user)
+            expect(next).not.toBe(base)
+            expect(next.user).toEqual(user)
+        })
+
+        it("should structurally share identical objects in the tree", () => {
+            const base = {bear: {legs: 4}, eagle: {legs: 3}}
+            const next = produce(base, draft => {
+                const animal = draft.bear
+                animal.legs = animal.legs + 1
+                draft.bear = animal
+                draft.eagle = animal
+                draft.cow = animal
+                draft.kiddo = animal
+            })
+            expect(next).toEqual({
+                bear: {legs: 5},
+                eagle: {legs: 5},
+                cow: {legs: 5},
+                kiddo: {legs: 5}
+            })
+            expect(next.bear).toBe(next.cow)
+            expect(next.kiddo).toBe(next.cow)
+        })
+
         if (useProxies)
-            it("throws when Object.setPrototypeOf() is used on a draft", () => {
+            it("should not allow changing prototype", () => {
                 produce({}, draft => {
                     expect(() => Object.setPrototypeOf(draft, Array)).toThrow(
-                        "Object.setPrototypeOf() cannot be used on an Immer draft"
+                        /does not support `setPrototype/
                     )
                 })
             })
 
-        it("supports the 'in' operator", () => {
-            produce(baseState, draft => {
-                // Known property
+        it("'in' should work", () => {
+            produce(createBaseState(), draft => {
                 expect("anArray" in draft).toBe(true)
                 expect(Reflect.has(draft, "anArray")).toBe(true)
 
-                // Unknown property
                 expect("bla" in draft).toBe(false)
                 expect(Reflect.has(draft, "bla")).toBe(false)
 
-                // Known index
                 expect(0 in draft.anArray).toBe(true)
                 expect("0" in draft.anArray).toBe(true)
                 expect(Reflect.has(draft.anArray, 0)).toBe(true)
                 expect(Reflect.has(draft.anArray, "0")).toBe(true)
 
-                // Unknown index
                 expect(17 in draft.anArray).toBe(false)
                 expect("17" in draft.anArray).toBe(false)
                 expect(Reflect.has(draft.anArray, 17)).toBe(false)
@@ -732,7 +917,7 @@ function runBaseTest(name, useProxies, autoFreeze, useListener) {
             expect(next1.x).toBe(4)
         })
 
-        it("'this' should work - 2", () => {
+        it("'this' should work - 1", () => {
             const base = {x: 3}
             const incrementor = produce(function() {
                 this.x = 4
@@ -743,7 +928,7 @@ function runBaseTest(name, useProxies, autoFreeze, useListener) {
         })
 
         // See here: https://github.com/mweststrate/immer/issues/89
-        it("supports the spread operator", () => {
+        it("works with the spread operator", () => {
             const base = {foo: {x: 0, y: 0}, bar: [0, 0]}
             const result = produce(base, draft => {
                 draft.foo = {x: 1, ...draft.foo, y: 1}
@@ -774,66 +959,35 @@ function runBaseTest(name, useProxies, autoFreeze, useListener) {
             expect(result[0].a).toEqual(2)
         })
 
-        describe("recipe functions", () => {
-            it("can return a new object", () => {
-                const base = {x: 3}
-                const res = produce(base, d => {
-                    return {x: d.x + 1}
+        it("can produce from no state", () => {
+            expect(
+                produce(3, draft => {
+                    expect(draft).toBe(3)
+                    return 5
                 })
-                expect(res).not.toBe(base)
-                expect(res).toEqual({x: 4})
-            })
-
-            it("can return the draft", () => {
-                const base = {x: 3}
-                const res = produce(base, d => {
-                    d.x = 4
-                    return d
-                })
-                expect(res).not.toBe(base)
-                expect(res).toEqual({x: 4})
-            })
-
-            it("can return a child draft", () => {
-                const base = {a: {}}
-                const res = produce(base, d => {
-                    return d.a
-                })
-                expect(res).toBe(base.a)
-            })
-
-            it("can return a frozen object", () => {
-                const res = deepFreeze([{x: 3}])
-                expect(produce({}, () => res)).toBe(res)
-            })
-
-            it("can return an object with two references to another object", () => {
-                const next = produce({}, d => {
-                    const obj = {}
-                    return {obj, arr: [obj]}
-                })
-                expect(next.obj).toBe(next.arr[0])
-            })
+            ).toBe(5)
+        })
 
-            it("can return an object with two references to any pristine draft", () => {
-                const base = {a: {}}
-                const next = produce(base, d => {
-                    return [d.a, d.a]
-                })
-                expect(next[0]).toBe(base.a)
-                expect(next[0]).toBe(next[1])
+        it("can return something new ", () => {
+            const base = {x: 3}
+            const res = produce(base, draft => {
+                return {x: draft.x + 1}
             })
+            expect(res).not.toBe(base)
+            expect(res).toEqual({x: 4})
+        })
 
-            it("cannot return an object that references itself", () => {
-                const res = {}
-                res.self = res
-                expect(() => {
-                    produce(res, () => res.self)
-                }).toThrow("Immer forbids circular references")
+        it("can return the draft new ", () => {
+            const base = {x: 3}
+            const res = produce(base, draft => {
+                draft.x = 4
+                return draft
             })
+            expect(res).not.toBe(base)
+            expect(res).toEqual({x: 4})
         })
 
-        it("throws when the draft is modified and another object is returned", () => {
+        it("should throw if modifying the draft and returning something new", () => {
             const base = {x: 3}
             expect(() => {
                 produce(base, draft => {
@@ -843,7 +997,7 @@ function runBaseTest(name, useProxies, autoFreeze, useListener) {
             }).toThrow(/An immer producer returned a new value/)
         })
 
-        it("should fix #117 - 1", () => {
+        it("should fix #117", () => {
             const reducer = (state, action) =>
                 produce(state, draft => {
                     switch (action.type) {
@@ -890,7 +1044,23 @@ function runBaseTest(name, useProxies, autoFreeze, useListener) {
             expect(next).toEqual({dots: base.availableStartingDots})
         })
 
-        it("cannot always detect noop assignments - 0", () => {
+        it("should return an unmodified primitive baseState (#148)", () => {
+            const baseState = "some string"
+            const nextState = produce(baseState, () => {
+                /* no modification  */
+            })
+            expect(nextState).toBe(baseState)
+        })
+
+        it("should return an unmodified null baseState (#148)", () => {
+            const baseState = null
+            const nextState = produce(baseState, () => {
+                /* no modification  */
+            })
+            expect(nextState).toBe(baseState)
+        })
+
+        it("should not detect noop assignments - 0", () => {
             const baseState = {x: {y: 3}}
             const nextState = produce(baseState, d => {
                 const a = d.x
@@ -899,7 +1069,7 @@ function runBaseTest(name, useProxies, autoFreeze, useListener) {
             expect(nextState).toBe(baseState)
         })
 
-        it("cannot always detect noop assignments - 1", () => {
+        it("should not detect noop assignments - 1", () => {
             const baseState = {x: {y: 3}}
             const nextState = produce(baseState, d => {
                 const a = d.x
@@ -912,7 +1082,7 @@ function runBaseTest(name, useProxies, autoFreeze, useListener) {
             expect(nextState).not.toBe(baseState)
         })
 
-        it("cannot always detect noop assignments - 2", () => {
+        it("should not detect noop assignments - 2", () => {
             const baseState = {x: {y: 3}}
             const nextState = produce(baseState, d => {
                 const a = d.x
@@ -926,7 +1096,7 @@ function runBaseTest(name, useProxies, autoFreeze, useListener) {
             expect(nextState).not.toBe(baseState)
         })
 
-        it("cannot always detect noop assignments - 3", () => {
+        it("should not detect noop assignments - 3", () => {
             const baseState = {x: 3}
             const nextState = produce(baseState, d => {
                 d.x = 3
@@ -934,7 +1104,7 @@ function runBaseTest(name, useProxies, autoFreeze, useListener) {
             expect(nextState).toBe(baseState)
         })
 
-        it("cannot always detect noop assignments - 4", () => {
+        it("should not detect noop assignments - 4", () => {
             const baseState = {x: 3}
             const nextState = produce(baseState, d => {
                 d.x = 4
@@ -946,7 +1116,45 @@ function runBaseTest(name, useProxies, autoFreeze, useListener) {
             expect(nextState).not.toBe(baseState)
         })
 
-        it("cannot produce undefined by returning undefined", () => {
+        it("immer should have no dependencies", () => {
+            expect(require("../package.json").dependencies).toEqual(undefined)
+        })
+
+        it("#174", () => {
+            const nextState = produce([1, 2, 3], s => {
+                s.pop()
+                s.push(100)
+            })
+            expect(nextState).toEqual([1, 2, 100])
+        })
+
+        it("#195 should be able to find items", () => {
+            const state = {
+                items: [
+                    {
+                        id: 0,
+                        task: "drink milk"
+                    },
+                    {id: 1, task: "eat cookie"}
+                ]
+            }
+            produce(state, draft => {
+                expect(draft.items.find(({id}) => id === 1).task).toBe(
+                    "eat cookie"
+                )
+            })
+        })
+
+        it("allows a function as the base state", () => {
+            let fn = () => {}
+            expect(
+                produce(fn, draft => {
+                    expect(fn).toBe(draft)
+                })
+            ).toBe(fn)
+        })
+
+        it("cannot return and produce undefined!", () => {
             const base = 3
             expect(produce(base, () => 4)).toBe(4)
             expect(produce(base, () => null)).toBe(null)
@@ -963,20 +1171,98 @@ function runBaseTest(name, useProxies, autoFreeze, useListener) {
             expect(produce(() => nothing)(3)).toBe(undefined)
         })
 
-        describe("base state type", () => {
-            testObjectTypes(produce)
-            testLiteralTypes(produce)
-        })
+        // TODO: use fuzz testing
+        {
+            class Foo {}
+            const primitives = {
+                "falsy number": 0,
+                "truthy number": 1,
+                "negative number": -1,
+                infinity: 1 / 0,
+                true: true,
+                false: false,
+                "empty string": "",
+                "truthy string": "1",
+                null: null,
+                undefined: undefined,
+
+                /**
+                 * These objects are treated as primitives because Immer
+                 * chooses not to make drafts for them.
+                 */
+                "regexp object": /.+/g,
+                "boxed number": new Number(0),
+                "boxed string": new String(""),
+                "boxed boolean": new Boolean(),
+                "date object": new Date(),
+                "class instance": new Foo()
+            }
+            for (const name in primitives) {
+                describe("base state type - " + name, () => {
+                    const value = primitives[name]
+                    it("does not create a draft", () => {
+                        produce(value, draft => {
+                            expect(draft).toBe(value)
+                        })
+                    })
+                    it("returns the same value when the producer returns undefined", () => {
+                        expect(produce(value, () => {})).toBe(value)
+                    })
+                    if (value && typeof value == "object") {
+                        it("does not return a copy when the producer makes changes", () => {
+                            expect(
+                                produce(value, draft => {
+                                    draft.foo = true
+                                })
+                            ).toBe(value)
+                        })
+                    }
+                })
+            }
+            const objects = {
+                "empty object": {},
+                "plain object": {a: 1, b: {c: 1}},
+                "frozen object": Object.freeze({}),
+                "null-prototype object": Object.create(null),
+                "frozen null-prototype object": Object.freeze(
+                    Object.create(null)
+                ),
+                "empty array": [],
+                "plain array": [1, [2, [3, []]]],
+                "frozen array": Object.freeze([])
+            }
+            for (const name in objects) {
+                describe("base state type - " + name, () => {
+                    const value = objects[name]
+                    it("creates a draft", () => {
+                        produce(value, draft => {
+                            expect(draft).not.toBe(value)
+                            expect(enumerableOnly(draft)).toEqual(value)
+                        })
+                    })
+                    it("returns the same value when the producer does nothing", () => {
+                        expect(produce(value, () => {})).toBe(value)
+                    })
+                    it("returns a copy when changes are made", () => {
+                        const random = Math.random()
+                        const result = produce(value, draft => {
+                            draft[0] = random
+                        })
+                        expect(result).not.toBe(value)
+                        expect(result.constructor).toBe(value.constructor)
+                        expect(result[0]).toBe(random)
+                    })
+                })
+            }
+        }
 
         afterEach(() => {
             expect(baseState).toBe(origBaseState)
             expect(baseState).toEqual(createBaseState())
         })
 
-        class Foo {}
         function createBaseState() {
             const data = {
-                anInstance: new Foo(),
                 anArray: [3, 2, {c: 3}, 1],
                 aProp: "hi",
                 anObject: {
@@ -1032,120 +1318,13 @@ function runBaseTest(name, useProxies, autoFreeze, useListener) {
     })
 }
 
-function testObjectTypes(produce) {
-    class Foo {
-        constructor(foo) {
-            this.foo = foo
-            this[immerable] = true
-        }
-    }
-    const values = {
-        "empty object": {},
-        "plain object": {a: 1, b: 2},
-        "object (no prototype)": Object.create(null),
-        "empty array": [],
-        "plain array": [1, 2],
-        "class instance (draftable)": new Foo(1)
-    }
-    for (const name in values) {
-        const value = values[name]
-        const copy = shallowCopy(value)
-        testObjectType(name, value)
-        testObjectType(name + " (frozen)", Object.freeze(copy))
-    }
-    function testObjectType(name, base) {
-        describe(name, () => {
-            it("creates a draft", () => {
-                produce(base, draft => {
-                    expect(draft).not.toBe(base)
-                    expect(shallowCopy(draft, true)).toEqual(base)
-                })
-            })
-
-            it("preserves the prototype", () => {
-                const proto = Object.getPrototypeOf(base)
-                produce(base, draft => {
-                    expect(Object.getPrototypeOf(draft)).toBe(proto)
-                })
-            })
-
-            it("returns the base state when no changes are made", () => {
-                expect(produce(base, () => {})).toBe(base)
-            })
-
-            it("returns a copy when changes are made", () => {
-                const random = Math.random()
-                const result = produce(base, draft => {
-                    draft[0] = random
-                })
-                expect(result).not.toBe(base)
-                expect(result.constructor).toBe(base.constructor)
-                expect(result[0]).toBe(random)
-            })
-        })
-    }
-}
-
-function testLiteralTypes(produce) {
-    class Foo {}
-    const values = {
-        "falsy number": 0,
-        "truthy number": 1,
-        "negative number": -1,
-        NaN: NaN,
-        infinity: 1 / 0,
-        true: true,
-        false: false,
-        "empty string": "",
-        "truthy string": "1",
-        null: null,
-        undefined: undefined,
-
-        /**
-         * These objects are treated as literals because Immer
-         * does not know how to draft them.
-         */
-        function: () => {},
-        "regexp object": /.+/g,
-        "boxed number": new Number(0),
-        "boxed string": new String(""),
-        "boxed boolean": new Boolean(),
-        "date object": new Date(),
-        "class instance (not draftable)": new Foo()
-    }
-    for (const name in values) {
-        describe(name, () => {
-            const value = values[name]
-
-            it("does not create a draft", () => {
-                produce(value, draft => {
-                    expect(draft).toBe(value)
-                })
-            })
-
-            it("returns the base state when no changes are made", () => {
-                expect(produce(value, () => {})).toBe(value)
-            })
-
-            if (value && typeof value == "object") {
-                it("does not return a copy when changes are made", () => {
-                    expect(
-                        produce(value, draft => {
-                            draft.foo = true
-                        })
-                    ).toBe(value)
-                })
-            }
-        })
-    }
-}
-
 function enumerableOnly(x) {
-    const copy = Array.isArray(x) ? x.slice() : Object.assign({}, x)
-    each(copy, (prop, value) => {
+    const copy = shallowCopy(x)
+    for (const key in copy) {
+        const value = copy[key]
         if (value && typeof value === "object") {
-            copy[prop] = enumerableOnly(value)
+            copy[key] = enumerableOnly(value)
         }
-    })
+    }
     return copy
 }
diff --git a/__tests__/patch.js b/__tests__/patch.js
index 463bf3d..1785ff7 100644
--- a/__tests__/patch.js
+++ b/__tests__/patch.js
@@ -292,7 +292,8 @@ describe("same value replacement - 2", () => {
             d.x = 4
             d.x = a
         },
-        []
+        // immer does not detect this is not an actual change
+        [{op: "replace", path: ["x"], value: {y: 3}}]
     )
 })
 
@@ -313,7 +314,8 @@ describe("same value replacement - 4", () => {
             d.x = 4
             d.x = 3
         },
-        []
+        // immer does not detect this is not an actual change
+        [{op: "replace", path: ["x"], value: 3}]
     )
 })
 
diff --git a/__tests__/polyfills.js b/__tests__/polyfills.js
deleted file mode 100644
index 3c47ce6..0000000
--- a/__tests__/polyfills.js
+++ /dev/null
@@ -1,70 +0,0 @@
-const {assign} = Object
-const {ownKeys} = Reflect
-const SymbolConstructor = Symbol
-
-Symbol = undefined
-Object.assign = undefined
-Reflect.ownKeys = undefined
-
-jest.resetModules()
-const common = require("../src/common")
-
-// Reset the globals to avoid unintended effects.
-Symbol = SymbolConstructor
-Object.assign = assign
-Reflect.ownKeys = ownKeys
-
-describe("Symbol", () => {
-    test("NOTHING", () => {
-        const value = common.NOTHING
-        expect(value).toBeTruthy()
-        expect(typeof value).toBe("object")
-    })
-    test("DRAFTABLE", () => {
-        const value = common.DRAFTABLE
-        expect(typeof value).toBe("string")
-    })
-    test("DRAFT_STATE", () => {
-        const value = common.DRAFT_STATE
-        expect(typeof value).toBe("string")
-    })
-})
-
-describe("Object.assign", () => {
-    const {assign} = common
-
-    it("only copies enumerable keys", () => {
-        const src = {a: 1}
-        Object.defineProperty(src, "b", {value: 1})
-        const dest = {}
-        assign(dest, src)
-        expect(dest.a).toBe(1)
-        expect(dest.b).toBeUndefined()
-    })
-
-    it("only copies own properties", () => {
-        const src = Object.create({a: 1})
-        src.b = 1
-        const dest = {}
-        assign(dest, src)
-        expect(dest.a).toBeUndefined()
-        expect(dest.b).toBe(1)
-    })
-})
-
-describe("Reflect.ownKeys", () => {
-    const {ownKeys} = common
-
-    // Symbol keys are always last.
-    it("includes symbol keys", () => {
-        const s = SymbolConstructor()
-        const obj = {[s]: 1, b: 1}
-        expect(ownKeys(obj)).toEqual(["b", s])
-    })
-
-    it("includes non-enumerable keys", () => {
-        const obj = {a: 1}
-        Object.defineProperty(obj, "b", {value: 1})
-        expect(ownKeys(obj)).toEqual(["a", "b"])
-    })
-})
diff --git a/__tests__/produce.ts b/__tests__/produce.ts
index 41cdfcd..f98c055 100644
--- a/__tests__/produce.ts
+++ b/__tests__/produce.ts
@@ -197,8 +197,7 @@ it("does not enforce immutability at the type level", () => {
 })
 
 it("can produce nothing", () => {
-    let result = produce({}, _ => nothing)
-    exactType(result, undefined)
+    let val: undefined = produce({}, s => nothing)
 })
 
 it("works with `void` hack", () => {
diff --git a/src/common.js b/src/common.js
index ddcf7dc..a78e5b0 100644
--- a/src/common.js
+++ b/src/common.js
@@ -3,11 +3,6 @@ export const NOTHING =
         ? Symbol("immer-nothing")
         : {["immer-nothing"]: true}
 
-export const DRAFTABLE =
-    typeof Symbol !== "undefined"
-        ? Symbol("immer-draftable")
-        : "__$immer_draftable"
-
 export const DRAFT_STATE =
     typeof Symbol !== "undefined" ? Symbol("immer-state") : "__$immer_state"
 
@@ -16,11 +11,11 @@ export function isDraft(value) {
 }
 
 export function isDraftable(value) {
-    if (!value || typeof value !== "object") return false
+    if (!value) return false
+    if (typeof value !== "object") return false
     if (Array.isArray(value)) return true
     const proto = Object.getPrototypeOf(value)
-    if (!proto || proto === Object.prototype) return true
-    return !!value[DRAFTABLE] || !!value.constructor[DRAFTABLE]
+    return proto === null || proto === Object.prototype
 }
 
 export function original(value) {
@@ -41,53 +36,20 @@ export const assign =
         return target
     }
 
-export const ownKeys =
-    typeof Reflect !== "undefined" && Reflect.ownKeys
-        ? Reflect.ownKeys
-        : obj =>
-              Object.getOwnPropertyNames(obj).concat(
-                  Object.getOwnPropertySymbols(obj)
-              )
-
-export function shallowCopy(base, invokeGetters = false) {
-    if (Array.isArray(base)) return base.slice()
-    const clone = Object.create(Object.getPrototypeOf(base))
-    ownKeys(base).forEach(key => {
-        if (key === DRAFT_STATE) {
-            return // Never copy over draft state.
-        }
-        const desc = Object.getOwnPropertyDescriptor(base, key)
-        if (desc.get) {
-            if (!invokeGetters) {
-                throw new Error("Immer drafts cannot have computed properties")
-            }
-            desc.value = desc.get.call(base)
-        }
-        if (desc.enumerable) {
-            clone[key] = desc.value
-        } else {
-            Object.defineProperty(clone, key, {
-                value: desc.value,
-                writable: true,
-                configurable: true
-            })
-        }
-    })
-    return clone
+export function shallowCopy(value) {
+    if (Array.isArray(value)) return value.slice()
+    const target = value.__proto__ === undefined ? Object.create(null) : {}
+    return assign(target, value)
 }
 
 export function each(value, cb) {
     if (Array.isArray(value)) {
         for (let i = 0; i < value.length; i++) cb(i, value[i], value)
     } else {
-        ownKeys(value).forEach(key => cb(key, value[key], value))
+        for (let key in value) cb(key, value[key], value)
     }
 }
 
-export function isEnumerable(base, prop) {
-    return Object.getOwnPropertyDescriptor(base, prop).enumerable
-}
-
 export function has(thing, prop) {
     return Object.prototype.hasOwnProperty.call(thing, prop)
 }
diff --git a/src/es5.js b/src/es5.js
index 05414f4..3262790 100644
--- a/src/es5.js
+++ b/src/es5.js
@@ -7,7 +7,6 @@ import {
     is,
     isDraft,
     isDraftable,
-    isEnumerable,
     shallowCopy,
     DRAFT_STATE
 } from "./common"
@@ -29,10 +28,18 @@ export function willFinalize(result, baseDraft, needPatches) {
 }
 
 export function createDraft(base, parent) {
-    const isArray = Array.isArray(base)
-    const draft = clonePotentialDraft(base)
-    each(draft, prop => {
-        proxyProperty(draft, prop, isArray || isEnumerable(base, prop))
+    let draft
+    if (isDraft(base)) {
+        const state = base[DRAFT_STATE]
+        // Avoid creating new drafts when copying.
+        state.finalizing = true
+        draft = shallowCopy(state.draft)
+        state.finalizing = false
+    } else {
+        draft = shallowCopy(base)
+    }
+    each(base, prop => {
+        Object.defineProperty(draft, "" + prop, createPropertyProxy("" + prop))
     })
 
     // See "proxy.js" for property documentation.
@@ -93,44 +100,30 @@ function markChanged(state) {
 }
 
 function prepareCopy(state) {
-    if (!state.copy) state.copy = clonePotentialDraft(state.base)
+    if (!state.copy) state.copy = shallowCopy(state.base)
 }
 
-function clonePotentialDraft(base) {
-    const state = base && base[DRAFT_STATE]
-    if (state) {
-        state.finalizing = true
-        const draft = shallowCopy(state.draft, true)
-        state.finalizing = false
-        return draft
-    }
-    return shallowCopy(base)
-}
-
-function proxyProperty(draft, prop, enumerable) {
-    let desc = descriptors[prop]
-    if (desc) {
-        desc.enumerable = enumerable
-    } else {
-        descriptors[prop] = desc = {
+function createPropertyProxy(prop) {
+    return (
+        descriptors[prop] ||
+        (descriptors[prop] = {
             configurable: true,
-            enumerable,
+            enumerable: true,
             get() {
                 return get(this[DRAFT_STATE], prop)
             },
             set(value) {
                 set(this[DRAFT_STATE], prop, value)
             }
-        }
-    }
-    Object.defineProperty(draft, prop, desc)
+        })
+    )
 }
 
 function assertUnrevoked(state) {
     if (state.revoked === true)
         throw new Error(
             "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " +
-                JSON.stringify(source(state))
+                JSON.stringify(state.copy || state.base)
         )
 }
 
diff --git a/src/immer.d.ts b/src/immer.d.ts
index 44bbf09..c1b9e78 100644
--- a/src/immer.d.ts
+++ b/src/immer.d.ts
@@ -122,16 +122,6 @@ declare class Nothing {
  */
 export const nothing: Nothing
 
-/**
- * To let Immer treat your class instances as plain immutable objects
- * (albeit with a custom prototype), you must define either an instance property
- * or a static property on each of your custom classes.
- *
- * Otherwise, your class instance will never be drafted, which means it won't be
- * safe to mutate in a produce callback.
- */
-export const immerable: unique symbol
-
 /**
  * Pass true to automatically freeze all copies created by Immer.
  *
@@ -154,22 +144,16 @@ export function setUseProxies(useProxies: boolean): void
  */
 export function applyPatches<S>(base: S, patches: Patch[]): S
 
-/** Get the underlying object that is represented by the given draft */
 export function original<T>(value: T): T | void
 
-/** For detecting an Immer draft */
 export function isDraft(value: any): boolean
 
 export class Immer {
     constructor(config: {
         useProxies?: boolean
         autoFreeze?: boolean
-        onAssign?: (
-            state: ImmerState,
-            prop: string | number,
-            value: unknown
-        ) => void
-        onDelete?: (state: ImmerState, prop: string | number) => void
+        onAssign?: (state: ImmerState, prop: keyof any, value: any) => void
+        onDelete?: (state: ImmerState, prop: keyof any) => void
         onCopy?: (state: ImmerState) => void
     })
     /**
@@ -219,5 +203,5 @@ export interface ImmerState<T = any> {
     parent?: ImmerState
     base: T
     copy: T
-    assigned: {[prop: string]: boolean; [index: number]: boolean}
+    assigned: {[prop: string]: boolean}
 }
diff --git a/src/immer.js b/src/immer.js
index b713fb0..ac50ec2 100644
--- a/src/immer.js
+++ b/src/immer.js
@@ -4,11 +4,9 @@ import {generatePatches} from "./patches"
 import {
     assign,
     each,
-    has,
     is,
     isDraft,
     isDraftable,
-    isEnumerable,
     shallowCopy,
     DRAFT_STATE,
     NOTHING
@@ -56,6 +54,11 @@ export class Immer {
             result = recipe(base)
             if (result === undefined) return base
         }
+        // See #100, don't nest producers
+        else if (isDraft(base)) {
+            result = recipe.call(base, base)
+            if (result === undefined) return base
+        }
         // The given value must be proxied.
         else {
             this.scopes.push([])
@@ -135,18 +138,9 @@ export class Immer {
             state.finalized = true
             this.finalizeTree(state.draft, path, patches, inversePatches)
             if (this.onDelete) {
-                // The `assigned` object is unreliable with ES5 drafts.
-                if (this.useProxies) {
-                    const {assigned} = state
-                    for (const prop in assigned) {
-                        if (!assigned[prop]) this.onDelete(state, prop)
-                    }
-                } else {
-                    const {base, copy} = state
-                    each(base, prop => {
-                        if (!has(copy, prop)) this.onDelete(state, prop)
-                    })
-                }
+                const {assigned} = state
+                for (const prop in assigned)
+                    assigned[prop] || this.onDelete(state, prop)
             }
             if (this.onCopy) this.onCopy(state)
 
@@ -167,38 +161,25 @@ export class Immer {
     finalizeTree(root, path, patches, inversePatches) {
         const state = root[DRAFT_STATE]
         if (state) {
-            if (!this.useProxies) {
-                state.finalizing = true
-                state.copy = shallowCopy(state.draft, true)
-                state.finalizing = false
-            }
-            root = state.copy
+            root = this.useProxies
+                ? state.copy
+                : (state.copy = shallowCopy(state.draft))
         }
 
         const {onAssign} = this
         const finalizeProperty = (prop, value, parent) => {
-            if (value === parent) {
-                throw Error("Immer forbids circular references")
-            }
-
-            // The only possible draft (in the scope of a `finalizeTree` call) is the `root` object.
+            // Only `root` can be a draft in here.
             const inDraft = !!state && parent === root
 
             if (isDraft(value)) {
-                value =
+                // prettier-ignore
+                parent[prop] = value =
                     // Patches are never generated for assigned properties.
                     patches && inDraft && !state.assigned[prop]
-                        ? this.finalize(value, path.concat(prop), patches, inversePatches) // prettier-ignore
+                        ? this.finalize(value, path.concat(prop), patches, inversePatches)
                         : this.finalize(value)
 
-                // Preserve non-enumerable properties.
-                if (Array.isArray(parent) || isEnumerable(parent, prop)) {
-                    parent[prop] = value
-                } else {
-                    Object.defineProperty(parent, prop, {value})
-                }
-
-                // Unchanged drafts are never passed to the `onAssign` hook.
+                // Unchanged drafts are ignored.
                 if (inDraft && value === state.base[prop]) return
             }
             // Unchanged draft properties are ignored.
diff --git a/src/index.js b/src/index.js
index 990c0a9..d7cf54c 100644
--- a/src/index.js
+++ b/src/index.js
@@ -47,11 +47,6 @@ export const setUseProxies = value => immer.setUseProxies(value)
  */
 export const applyPatches = produce(applyPatchesImpl)
 
-export {
-    original,
-    isDraft,
-    NOTHING as nothing,
-    DRAFTABLE as immerable
-} from "./common"
+export {original, isDraft, NOTHING as nothing} from "./common"
 
 export {Immer}
diff --git a/src/patches.js b/src/patches.js
index 5ce7bb2..6833fd9 100644
--- a/src/patches.js
+++ b/src/patches.js
@@ -58,7 +58,7 @@ function generateObjectPatches(state, basePath, patches, inversePatches) {
         const origValue = base[key]
         const value = copy[key]
         const op = !assignedValue ? "remove" : key in base ? "replace" : "add"
-        if (origValue === value && op === "replace") return
+        if (origValue === base && op === "replace") return
         const path = basePath.concat(key)
         patches.push(op === "remove" ? {op, path} : {op, path, value})
         inversePatches.push(
diff --git a/src/proxy.js b/src/proxy.js
index 6aee2a6..bc5b92d 100644
--- a/src/proxy.js
+++ b/src/proxy.js
@@ -65,14 +65,9 @@ const objectTraps = {
     set,
     deleteProperty,
     getOwnPropertyDescriptor,
-    defineProperty() {
-        throw new Error("Object.defineProperty() cannot be used on an Immer draft") // prettier-ignore
-    },
-    getPrototypeOf(target) {
-        return Object.getPrototypeOf(target.base)
-    },
+    defineProperty,
     setPrototypeOf() {
-        throw new Error("Object.setPrototypeOf() cannot be used on an Immer draft") // prettier-ignore
+        throw new Error("Immer does not support `setPrototypeOf()`.")
     }
 }
 
@@ -84,15 +79,18 @@ each(objectTraps, (key, fn) => {
     }
 })
 arrayTraps.deleteProperty = function(state, prop) {
-    if (isNaN(parseInt(prop))) {
-        throw new Error("Immer only supports deleting array indices") // prettier-ignore
-    }
+    if (isNaN(parseInt(prop)))
+        throw new Error(
+            "Immer does not support deleting properties from arrays: " + prop
+        )
     return objectTraps.deleteProperty.call(this, state[0], prop)
 }
 arrayTraps.set = function(state, prop, value) {
-    if (prop !== "length" && isNaN(parseInt(prop))) {
-        throw new Error("Immer only supports setting array indices and the 'length' property") // prettier-ignore
-    }
+    if (prop !== "length" && isNaN(parseInt(prop)))
+        throw new Error(
+            "Immer does not support setting non-numeric properties on arrays: " +
+                prop
+        )
     return objectTraps.set.call(this, state[0], prop, value)
 }
 
@@ -150,13 +148,21 @@ function deleteProperty(state, prop) {
 }
 
 function getOwnPropertyDescriptor(state, prop) {
-    const owner = source(state)
-    const desc = Reflect.getOwnPropertyDescriptor(owner, prop)
-    if (desc) {
-        desc.writable = true
-        desc.configurable = !Array.isArray(owner) || prop !== "length"
-    }
-    return desc
+    const owner = state.modified
+        ? state.copy
+        : has(state.drafts, prop)
+        ? state.drafts
+        : state.base
+    const descriptor = Reflect.getOwnPropertyDescriptor(owner, prop)
+    if (descriptor && !(Array.isArray(owner) && prop === "length"))
+        descriptor.configurable = true
+    return descriptor
+}
+
+function defineProperty() {
+    throw new Error(
+        "Immer does not support defining properties on draft objects."
+    )
 }
 
 function markChanged(state) {
