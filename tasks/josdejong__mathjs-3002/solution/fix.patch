diff --git a/src/expression/transform/quantileSeq.transform.js b/src/expression/transform/quantileSeq.transform.js
new file mode 100644
index 000000000..aa83d759f
--- /dev/null
+++ b/src/expression/transform/quantileSeq.transform.js
@@ -0,0 +1,27 @@
+import { factory } from '../../utils/factory.js'
+import { createQuantileSeq } from '../../function/statistics/quantileSeq.js'
+import { lastDimToZeroBase } from './utils/lastDimToZeroBase.js'
+
+const name = 'quantileSeq'
+const dependencies = ['typed', 'add', 'multiply', 'partitionSelect', 'compare', 'isInteger']
+
+/**
+ * Attach a transform function to math.quantileSeq
+ * Adds a property transform containing the transform function.
+ *
+ * This transform changed the `dim` parameter of function std
+ * from one-based to zero based
+ */
+export const createQuantileSeqTransform = /* #__PURE__ */ factory(name, dependencies, ({ typed, add, multiply, partitionSelect, compare, isInteger }) => {
+  const quantileSeq = createQuantileSeq({ typed, add, multiply, partitionSelect, compare, isInteger })
+
+  return typed('quantileSeq', {
+    'Array|Matrix, number|BigNumber|Array, number': (arr, prob, dim) => quantileSeq(arr, prob, dimToZeroBase(dim)),
+    'Array|Matrix, number|BigNumber|Array, boolean, number': (arr, prob, sorted, dim) => quantileSeq(arr, prob, sorted, dimToZeroBase(dim))
+  })
+
+  function dimToZeroBase (dim) {
+    // TODO: find a better way, maybe lastDimToZeroBase could apply to more cases.
+    return lastDimToZeroBase([[], dim])[1]
+  }
+}, { isTransformFunction: true })
diff --git a/src/factoriesAny.js b/src/factoriesAny.js
index 704c25c90..00b5fe195 100644
--- a/src/factoriesAny.js
+++ b/src/factoriesAny.js
@@ -352,5 +352,6 @@ export { createConcatTransform } from './expression/transform/concat.transform.j
 export { createDiffTransform } from './expression/transform/diff.transform.js'
 export { createStdTransform } from './expression/transform/std.transform.js'
 export { createSumTransform } from './expression/transform/sum.transform.js'
+export { createQuantileSeqTransform } from './expression/transform/quantileSeq.transform.js'
 export { createCumSumTransform } from './expression/transform/cumsum.transform.js'
 export { createVarianceTransform } from './expression/transform/variance.transform.js'
diff --git a/src/function/statistics/quantileSeq.js b/src/function/statistics/quantileSeq.js
index dbf8a351d..6d772c8fb 100644
--- a/src/function/statistics/quantileSeq.js
+++ b/src/function/statistics/quantileSeq.js
@@ -1,12 +1,12 @@
 import { isBigNumber, isCollection, isNumber } from '../../utils/is.js'
-import { isInteger } from '../../utils/number.js'
 import { flatten } from '../../utils/array.js'
 import { factory } from '../../utils/factory.js'
+import { createApply } from '../matrix/apply.js'
 
 const name = 'quantileSeq'
-const dependencies = ['typed', 'add', 'multiply', 'partitionSelect', 'compare']
+const dependencies = ['typed', 'add', 'multiply', 'partitionSelect', 'compare', 'isInteger']
 
-export const createQuantileSeq = /* #__PURE__ */ factory(name, dependencies, ({ typed, add, multiply, partitionSelect, compare }) => {
+export const createQuantileSeq = /* #__PURE__ */ factory(name, dependencies, ({ typed, add, multiply, partitionSelect, compare, isInteger }) => {
   /**
    * Compute the prob order quantile of a matrix or a list with values.
    * The sequence is sorted and the middle value is returned.
@@ -41,6 +41,32 @@ export const createQuantileSeq = /* #__PURE__ */ factory(name, dependencies, ({
    * @param {Boolean} sorted=false              is data sorted in ascending order
    * @return {Number, BigNumber, Unit, Array}   Quantile(s)
    */
+
+  const apply = createApply({ typed, isInteger })
+  /**
+   * Check if array value types are valid, throw error otherwise.
+   * @param {number | BigNumber | Unit} x
+   * @param {number | BigNumber | Unit} x
+   * @private
+   */
+  const validate = typed({
+    'number | BigNumber | Unit': function (x) {
+      return x
+    }
+  })
+
+  return typed(name, {
+    'Array|Matrix, number|BigNumber|Array': (data, prob) => quantileSeq(data, prob, false),
+    'Array|Matrix, number|BigNumber|Array, boolean': quantileSeq,
+    'Array|Matrix, number|BigNumber|Array, number': (data, prob, dim) => _quantileSeqDim(data, prob, false, dim),
+    'Array|Matrix, number|BigNumber|Array, boolean, number': (data, prob, sorted, dim) => _quantileSeqDim(data, prob, sorted, dim)
+  })
+
+  function _quantileSeqDim (data, prob, sorted, dim) {
+    // return [1.3, 1.2]
+    return apply(data, dim, x => quantileSeq(x, prob, sorted))
+  }
+
   function quantileSeq (data, probOrN, sorted) {
     let probArr, dataArr, one
 
@@ -238,18 +264,4 @@ export const createQuantileSeq = /* #__PURE__ */ factory(name, dependencies, ({
     const one = new fracPart.constructor(1)
     return add(multiply(left, one.minus(fracPart)), multiply(right, fracPart))
   }
-
-  /**
-   * Check if array value types are valid, throw error otherwise.
-   * @param {number | BigNumber | Unit} x
-   * @param {number | BigNumber | Unit} x
-   * @private
-   */
-  const validate = typed({
-    'number | BigNumber | Unit': function (x) {
-      return x
-    }
-  })
-
-  return quantileSeq
 })
