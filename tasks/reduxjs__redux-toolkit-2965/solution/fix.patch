diff --git a/packages/toolkit/src/createAsyncThunk.ts b/packages/toolkit/src/createAsyncThunk.ts
index 58df87bb..5a805ebc 100644
--- a/packages/toolkit/src/createAsyncThunk.ts
+++ b/packages/toolkit/src/createAsyncThunk.ts
@@ -590,18 +590,10 @@ If you want to use the AbortController to react to \`abort\` events, please cons
         const abortController = new AC()
         let abortReason: string | undefined
 
-        const abortedPromise = new Promise<never>((_, reject) =>
-          abortController.signal.addEventListener('abort', () =>
-            reject({ name: 'AbortError', message: abortReason || 'Aborted' })
-          )
-        )
-
         let started = false
         function abort(reason?: string) {
-          if (started) {
-            abortReason = reason
-            abortController.abort()
-          }
+          abortReason = reason
+          abortController.abort()
         }
 
         const promise = (async function () {
@@ -611,7 +603,8 @@ If you want to use the AbortController to react to \`abort\` events, please cons
             if (isThenable(conditionResult)) {
               conditionResult = await conditionResult
             }
-            if (conditionResult === false) {
+
+            if (conditionResult === false || abortController.signal.aborted) {
               // eslint-disable-next-line no-throw-literal
               throw {
                 name: 'ConditionError',
@@ -619,6 +612,15 @@ If you want to use the AbortController to react to \`abort\` events, please cons
               }
             }
             started = true
+
+            const abortedPromise = new Promise<never>((_, reject) =>
+              abortController.signal.addEventListener('abort', () =>
+                reject({
+                  name: 'AbortError',
+                  message: abortReason || 'Aborted',
+                })
+              )
+            )
             dispatch(
               pending(
                 requestId,
diff --git a/packages/toolkit/src/query/core/buildSlice.ts b/packages/toolkit/src/query/core/buildSlice.ts
index ef4fc26f..3343b6dc 100644
--- a/packages/toolkit/src/query/core/buildSlice.ts
+++ b/packages/toolkit/src/query/core/buildSlice.ts
@@ -181,6 +181,8 @@ export function buildSlice({
 
               if (merge) {
                 if (substate.data !== undefined) {
+                  const { fulfilledTimeStamp, arg, baseQueryMeta, requestId } =
+                    meta
                   // There's existing cache data. Let the user merge it in themselves.
                   // We're already inside an Immer-powered reducer, and the user could just mutate `substate.data`
                   // themselves inside of `merge()`. But, they might also want to return a new value.
@@ -189,7 +191,12 @@ export function buildSlice({
                     substate.data,
                     (draftSubstateData) => {
                       // As usual with Immer, you can mutate _or_ return inside here, but not both
-                      return merge(draftSubstateData, payload)
+                      return merge(draftSubstateData, payload, {
+                        arg: arg.originalArgs,
+                        baseQueryMeta,
+                        fulfilledTimeStamp,
+                        requestId,
+                      })
                     }
                   )
                   substate.data = newData
diff --git a/packages/toolkit/src/query/endpointDefinitions.ts b/packages/toolkit/src/query/endpointDefinitions.ts
index f5243f29..5ace421d 100644
--- a/packages/toolkit/src/query/endpointDefinitions.ts
+++ b/packages/toolkit/src/query/endpointDefinitions.ts
@@ -445,7 +445,13 @@ export interface QueryExtraOptions<
    */
   merge?(
     currentCacheData: ResultType,
-    responseData: ResultType
+    responseData: ResultType,
+    otherArgs: {
+      arg: QueryArg
+      baseQueryMeta: BaseQueryMeta<BaseQuery>
+      requestId: string
+      fulfilledTimeStamp: number
+    }
   ): ResultType | void
 
   /**
