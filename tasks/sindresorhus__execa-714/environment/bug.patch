diff --git a/index.d.ts b/index.d.ts
index e6e1eb5..1c2d4de 100644
--- a/index.d.ts
+++ b/index.d.ts
@@ -468,26 +468,6 @@ type CommonOptions<IsSync extends boolean = boolean> = {
 	*/
 	readonly killSignal?: string | number;
 
-	/**
-	If the child process is terminated but does not exit, forcefully exit it by sending [`SIGKILL`](https://en.wikipedia.org/wiki/Signal_(IPC)#SIGKILL).
-
-	The grace period is 5 seconds by default. This feature can be disabled with `false`.
-
-	This works when the child process is terminated by either:
-	- the `signal`, `timeout`, `maxBuffer` or `cleanup` option
-	- calling [`subprocess.kill()`](https://nodejs.org/api/child_process.html#subprocesskillsignal) with no arguments
-
-	This does not work when the child process is terminated by either:
-	- calling [`subprocess.kill()`](https://nodejs.org/api/child_process.html#subprocesskillsignal) with an argument
-	- calling [`process.kill(subprocess.pid)`](https://nodejs.org/api/process.html#processkillpid-signal)
-	- sending a termination signal from another process
-
-	Also, this does not work on Windows, because Windows [doesn't support signals](https://nodejs.org/api/process.html#process_signal_events): `SIGKILL` and `SIGTERM` both terminate the process immediately. Other packages (such as [`taskkill`](https://github.com/sindresorhus/taskkill)) can be used to achieve fail-safe termination on Windows.
-
-	@default 5000
-	*/
-	forceKillAfterTimeout?: number | false;
-
 	/**
 	If `true`, no quoting or escaping of arguments is done on Windows. Ignored on other platforms. This is set to `true` automatically when the `shell` option is `true`.
 
@@ -741,6 +721,17 @@ type ExecaCommonError = {
 export type ExecaError<OptionsType extends Options = Options> = ExecaCommonReturnValue<false, OptionsType> & ExecaCommonError;
 export type ExecaSyncError<OptionsType extends SyncOptions = SyncOptions> = ExecaCommonReturnValue<true, OptionsType> & ExecaCommonError;
 
+export type KillOptions = {
+	/**
+	Milliseconds to wait for the child process to terminate before sending `SIGKILL`.
+
+	Can be disabled with `false`.
+
+	@default 5000
+	*/
+	forceKillAfterTimeout?: number | false;
+};
+
 type StreamUnlessIgnored<
 	StreamIndex extends string,
 	OptionsType extends Options = Options,
@@ -788,6 +779,11 @@ export type ExecaChildPromise<OptionsType extends Options = Options> = {
 		onRejected?: (reason: ExecaError<OptionsType>) => ResultType | PromiseLike<ResultType>
 	): Promise<ExecaReturnValue<OptionsType> | ResultType>;
 
+	/**
+	Same as the original [`child_process#kill()`](https://nodejs.org/api/child_process.html#child_process_subprocess_kill_signal), except if `signal` is `SIGTERM` (the default value) and the child process is not terminated after 5 seconds, force it by sending `SIGKILL`. Note that this graceful termination does not work on Windows, because Windows [doesn't support signals](https://nodejs.org/api/process.html#process_signal_events) (`SIGKILL` and `SIGTERM` has the same effect of force-killing the process immediately.) If you want to achieve graceful termination on Windows, you have to use other means, such as [`taskkill`](https://github.com/sindresorhus/taskkill).
+	*/
+	kill(signal?: string, options?: KillOptions): void;
+
 	/**
 	[Pipe](https://nodejs.org/api/stream.html#readablepipedestination-options) the child process's `stdout` to `target`, which can be:
 	- Another `execa()` return value
@@ -921,6 +917,17 @@ try {
 	\*\/
 }
 ```
+
+@example <caption>Graceful termination</caption>
+```
+const subprocess = execa('node');
+
+setTimeout(() => {
+	subprocess.kill('SIGTERM', {
+		forceKillAfterTimeout: 2000
+	});
+}, 1000);
+```
 */
 export function execa<OptionsType extends Options = {}>(
 	file: string | URL,
diff --git a/index.js b/index.js
index 728c0ad..c78346e 100644
--- a/index.js
+++ b/index.js
@@ -10,7 +10,7 @@ import {makeError} from './lib/error.js';
 import {handleInputAsync, pipeOutputAsync} from './lib/stdio/async.js';
 import {handleInputSync, pipeOutputSync} from './lib/stdio/sync.js';
 import {normalizeStdioNode} from './lib/stdio/normalize.js';
-import {spawnedKill, validateTimeout, normalizeForceKillAfterTimeout} from './lib/kill.js';
+import {spawnedKill, validateTimeout} from './lib/kill.js';
 import {addPipeMethods} from './lib/pipe.js';
 import {getSpawnedResult, makeAllStream} from './lib/stream.js';
 import {mergePromise} from './lib/promise.js';
@@ -53,7 +53,6 @@ const handleArguments = (rawFile, rawArgs, rawOptions = {}) => {
 	validateTimeout(options);
 	options.shell = normalizeFileUrl(options.shell);
 	options.env = getEnv(options);
-	options.forceKillAfterTimeout = normalizeForceKillAfterTimeout(options.forceKillAfterTimeout);
 
 	if (process.platform === 'win32' && path.basename(file, '.exe') === 'cmd') {
 		// #116
@@ -81,7 +80,6 @@ const addDefaultOptions = ({
 	windowsHide = true,
 	verbose = verboseDefault,
 	killSignal = 'SIGTERM',
-	forceKillAfterTimeout = true,
 	...options
 }) => ({
 	...options,
@@ -100,7 +98,6 @@ const addDefaultOptions = ({
 	windowsHide,
 	verbose,
 	killSignal,
-	forceKillAfterTimeout,
 });
 
 const handleOutput = (options, value) => {
@@ -143,28 +140,26 @@ export function execa(rawFile, rawArgs, rawOptions) {
 		return dummySpawned;
 	}
 
-	const controller = new AbortController();
-
 	pipeOutputAsync(spawned, stdioStreamsGroups);
 
-	spawned.kill = spawnedKill.bind(null, spawned.kill.bind(spawned), options, controller);
+	spawned.kill = spawnedKill.bind(null, spawned.kill.bind(spawned));
 	spawned.all = makeAllStream(spawned, options);
 
 	addPipeMethods(spawned);
 
-	const promise = handlePromise({spawned, options, stdioStreamsGroups, command, escapedCommand, controller});
+	const promise = handlePromise({spawned, options, stdioStreamsGroups, command, escapedCommand});
 	mergePromise(spawned, promise);
 	return spawned;
 }
 
-const handlePromise = async ({spawned, options, stdioStreamsGroups, command, escapedCommand, controller}) => {
+const handlePromise = async ({spawned, options, stdioStreamsGroups, command, escapedCommand}) => {
 	const context = {timedOut: false};
 
 	const [
 		[exitCode, signal, error],
 		stdioResults,
 		allResult,
-	] = await getSpawnedResult({spawned, options, context, stdioStreamsGroups, controller});
+	] = await getSpawnedResult(spawned, options, context, stdioStreamsGroups);
 	const stdio = stdioResults.map(stdioResult => handleOutput(options, stdioResult));
 	const all = handleOutput(options, allResult);
 
diff --git a/index.test-d.ts b/index.test-d.ts
index 73c48bb..4ee948c 100644
--- a/index.test-d.ts
+++ b/index.test-d.ts
@@ -1187,14 +1187,6 @@ execa('unicorns', {killSignal: 'SIGTERM'});
 execaSync('unicorns', {killSignal: 'SIGTERM'});
 execa('unicorns', {killSignal: 9});
 execaSync('unicorns', {killSignal: 9});
-execa('unicorns', {forceKillAfterTimeout: false});
-execaSync('unicorns', {forceKillAfterTimeout: false});
-execa('unicorns', {forceKillAfterTimeout: 42});
-execaSync('unicorns', {forceKillAfterTimeout: 42});
-execa('unicorns', {forceKillAfterTimeout: undefined});
-execaSync('unicorns', {forceKillAfterTimeout: undefined});
-expectError(execa('unicorns', {forceKillAfterTimeout: 'true'}));
-expectError(execaSync('unicorns', {forceKillAfterTimeout: 'true'}));
 execa('unicorns', {signal: new AbortController().signal});
 expectError(execaSync('unicorns', {signal: new AbortController().signal}));
 execa('unicorns', {windowsVerbatimArguments: true});
@@ -1207,7 +1199,10 @@ execaSync('unicorns', {verbose: false});
 execa('unicorns').kill();
 execa('unicorns').kill('SIGKILL');
 execa('unicorns').kill(undefined);
-expectError(execa('unicorns').kill('SIGKILL', {}));
+execa('unicorns').kill('SIGKILL', {});
+execa('unicorns').kill('SIGKILL', {forceKillAfterTimeout: false});
+execa('unicorns').kill('SIGKILL', {forceKillAfterTimeout: 42});
+execa('unicorns').kill('SIGKILL', {forceKillAfterTimeout: undefined});
 
 expectError(execa(['unicorns', 'arg']));
 expectType<ExecaChildProcess>(execa('unicorns'));
diff --git a/lib/kill.js b/lib/kill.js
index ae10671..7cc6836 100644
--- a/lib/kill.js
+++ b/lib/kill.js
@@ -1,36 +1,34 @@
 import os from 'node:os';
-import {setTimeout} from 'node:timers/promises';
+import {setTimeout as pSetTimeout} from 'node:timers/promises';
 import {onExit} from 'signal-exit';
 
 const DEFAULT_FORCE_KILL_TIMEOUT = 1000 * 5;
 
 // Monkey-patches `childProcess.kill()` to add `forceKillAfterTimeout` behavior
-export const spawnedKill = (kill, {forceKillAfterTimeout}, controller, signal) => {
+export const spawnedKill = (kill, signal = 'SIGTERM', {forceKillAfterTimeout = true} = {}) => {
 	const killResult = kill(signal);
-	setKillTimeout({kill, signal, forceKillAfterTimeout, killResult, controller});
+	const timeout = getForceKillAfterTimeout(signal, forceKillAfterTimeout, killResult);
+	setKillTimeout(kill, timeout);
 	return killResult;
 };
 
-const setKillTimeout = async ({kill, signal, forceKillAfterTimeout, killResult, controller}) => {
-	if (!shouldForceKill(signal, forceKillAfterTimeout, killResult)) {
+const setKillTimeout = async (kill, timeout) => {
+	if (timeout === undefined) {
 		return;
 	}
 
-	try {
-		await setTimeout(forceKillAfterTimeout, undefined, {signal: controller.signal});
-		kill('SIGKILL');
-	} catch {}
+	await pSetTimeout(timeout, undefined, {ref: false});
+	kill('SIGKILL');
 };
 
 const shouldForceKill = (signal, forceKillAfterTimeout, killResult) => isSigterm(signal) && forceKillAfterTimeout !== false && killResult;
 
-const isSigterm = signal => signal === undefined
-	|| signal === os.constants.signals.SIGTERM
+const isSigterm = signal => signal === os.constants.signals.SIGTERM
 	|| (typeof signal === 'string' && signal.toUpperCase() === 'SIGTERM');
 
-export const normalizeForceKillAfterTimeout = forceKillAfterTimeout => {
-	if (forceKillAfterTimeout === false) {
-		return forceKillAfterTimeout;
+const getForceKillAfterTimeout = (signal, forceKillAfterTimeout, killResult) => {
+	if (!shouldForceKill(signal, forceKillAfterTimeout, killResult)) {
+		return;
 	}
 
 	if (forceKillAfterTimeout === true) {
@@ -45,18 +43,20 @@ export const normalizeForceKillAfterTimeout = forceKillAfterTimeout => {
 };
 
 const killAfterTimeout = async ({spawned, timeout, killSignal, context, controller}) => {
-	await setTimeout(timeout, undefined, {signal: controller.signal});
+	await pSetTimeout(timeout, undefined, {ref: false, signal: controller.signal});
 	spawned.kill(killSignal);
 	Object.assign(context, {timedOut: true, signal: killSignal});
 	throw new Error('Timed out');
 };
 
 // `timeout` option handling
-export const throwOnTimeout = ({spawned, timeout, killSignal, context, controller}) => {
+export const throwOnTimeout = ({spawned, timeout, killSignal, context, finalizers}) => {
 	if (timeout === 0 || timeout === undefined) {
 		return [];
 	}
 
+	const controller = new AbortController();
+	finalizers.push(controller.abort.bind(controller));
 	return [killAfterTimeout({spawned, timeout, killSignal, context, controller})];
 };
 
@@ -67,12 +67,13 @@ export const validateTimeout = ({timeout}) => {
 };
 
 // `cleanup` option handling
-export const cleanupOnExit = (spawned, cleanup, detached) => {
+export const cleanupOnExit = (spawned, cleanup, detached, finalizers) => {
 	if (!cleanup || detached) {
 		return;
 	}
 
-	return onExit(() => {
+	const removeExitHandler = onExit(() => {
 		spawned.kill();
 	});
+	finalizers.push(removeExitHandler);
 };
diff --git a/lib/stream.js b/lib/stream.js
index 153acff..23f1f46 100644
--- a/lib/stream.js
+++ b/lib/stream.js
@@ -106,14 +106,14 @@ const cleanupStdioStreams = (customStreams, error) => {
 };
 
 // Retrieve result of child process: exit code, signal, error, streams (stdout/stderr/all)
-export const getSpawnedResult = async ({
+export const getSpawnedResult = async (
 	spawned,
-	options: {encoding, buffer, maxBuffer, timeout, killSignal, cleanup, detached},
+	{encoding, buffer, maxBuffer, timeout, killSignal, cleanup, detached},
 	context,
 	stdioStreamsGroups,
-	controller,
-}) => {
-	const removeExitHandler = cleanupOnExit(spawned, cleanup, detached);
+) => {
+	const finalizers = [];
+	cleanupOnExit(spawned, cleanup, detached, finalizers);
 	const customStreams = getCustomStreams(stdioStreamsGroups);
 
 	const stdioPromises = spawned.stdio.map((stream, index) => getStdioPromise({stream, stdioStreams: stdioStreamsGroups[index], encoding, buffer, maxBuffer}));
@@ -129,7 +129,7 @@ export const getSpawnedResult = async ({
 			]),
 			...throwOnCustomStreamsError(customStreams),
 			...throwIfStreamError(spawned.stdin),
-			...throwOnTimeout({spawned, timeout, killSignal, context, controller}),
+			...throwOnTimeout({spawned, timeout, killSignal, context, finalizers}),
 		]);
 	} catch (error) {
 		spawned.kill();
@@ -141,7 +141,8 @@ export const getSpawnedResult = async ({
 		cleanupStdioStreams(customStreams, error);
 		return results;
 	} finally {
-		controller.abort();
-		removeExitHandler?.();
+		for (const finalizer of finalizers) {
+			finalizer();
+		}
 	}
 };
diff --git a/readme.md b/readme.md
index 89cb363..c590b88 100644
--- a/readme.md
+++ b/readme.md
@@ -50,7 +50,7 @@ This package improves [`child_process`](https://nodejs.org/api/child_process.htm
 - Redirect [`stdin`](#stdin)/[`stdout`](#stdout-1)/[`stderr`](#stderr-1) from/to files, streams, iterables, strings, `Uint8Array` or [objects](docs/transform.md#object-mode).
 - [Transform](docs/transform.md) `stdin`/`stdout`/`stderr` with simple functions.
 - Iterate over [each text line](docs/transform.md#binary-data) output by the process.
-- [Fail-safe process termination](#forcekillaftertimeout).
+- [Graceful termination](#optionsforcekillaftertimeout).
 - Get [interleaved output](#all) from `stdout` and `stderr` similar to what is printed on the terminal.
 - [Strips the final newline](#stripfinalnewline) from the output so you don't have to do `stdout.trim()`.
 - Convenience methods to pipe processes' [input](#input) and [output](#redirect-output-to-a-file).
@@ -221,6 +221,20 @@ try {
 }
 ```
 
+### Graceful termination
+
+Using SIGTERM, and after 2 seconds, kill it with SIGKILL.
+
+```js
+const subprocess = execa('node');
+
+setTimeout(() => {
+	subprocess.kill('SIGTERM', {
+		forceKillAfterTimeout: 2000
+	});
+}, 1000);
+```
+
 ## API
 
 ### Methods
@@ -309,6 +323,21 @@ The return value of all [asynchronous methods](#methods) is both:
 - a `Promise` resolving or rejecting with a [`childProcessResult`](#childProcessResult).
 - a [`child_process` instance](https://nodejs.org/api/child_process.html#child_process_class_childprocess) with the following additional methods and properties.
 
+#### kill(signal?, options?)
+
+Same as the original [`child_process#kill()`](https://nodejs.org/api/child_process.html#child_process_subprocess_kill_signal) except: if `signal` is `SIGTERM` (the default value) and the child process is not terminated after 5 seconds, force it by sending `SIGKILL`.
+
+Note that this graceful termination does not work on Windows, because Windows [doesn't support signals](https://nodejs.org/api/process.html#process_signal_events) (`SIGKILL` and `SIGTERM` has the same effect of force-killing the process immediately.) If you want to achieve graceful termination on Windows, you have to use other means, such as [`taskkill`](https://github.com/sindresorhus/taskkill).
+
+##### options.forceKillAfterTimeout
+
+Type: `number | false`\
+Default: `5000`
+
+Milliseconds to wait for the child process to terminate before sending `SIGKILL`.
+
+Can be disabled with `false`.
+
 #### all
 
 Type: `ReadableStream | undefined`
@@ -439,7 +468,7 @@ Whether the process was canceled using the [`signal`](#signal-1) option.
 Type: `boolean`
 
 Whether the process was terminated using either:
-- `childProcess.kill()`.
+- [`childProcess.kill()`](#killsignal-options).
 - A signal sent by another process. This case is [not supported on Windows](https://nodejs.org/api/process.html#signal-events).
 
 #### signal
@@ -447,7 +476,7 @@ Whether the process was terminated using either:
 Type: `string | undefined`
 
 The name of the signal (like `SIGFPE`) that terminated the process using either:
-- `childProcess.kill()`.
+- [`childProcess.kill()`](#killsignal-options).
 - A signal sent by another process. This case is [not supported on Windows](https://nodejs.org/api/process.html#signal-events).
 
 If a signal terminated the process, this property is defined and included in the error message. Otherwise it is `undefined`.
@@ -754,26 +783,6 @@ Default: `SIGTERM`
 
 Signal value to be used when the spawned process will be killed.
 
-#### forceKillAfterTimeout
-
-Type: `number | false`\
-Default: `5000`
-
-If the child process is terminated but does not exit, forcefully exit it by sending [`SIGKILL`](https://en.wikipedia.org/wiki/Signal_(IPC)#SIGKILL).
-
-The grace period is 5 seconds by default. This feature can be disabled with `false`.
-
-This works when the child process is terminated by either:
-- the [`signal`](#signal-1), [`timeout`](#timeout), [`maxBuffer`](#maxbuffer) or [`cleanup`](#cleanup) option
-- calling [`subprocess.kill()`](https://nodejs.org/api/child_process.html#subprocesskillsignal) with no arguments
-
-This does not work when the child process is terminated by either:
-- calling [`subprocess.kill()`](https://nodejs.org/api/child_process.html#subprocesskillsignal) with an argument
-- calling [`process.kill(subprocess.pid)`](https://nodejs.org/api/process.html#processkillpid-signal)
-- sending a termination signal from another process
-
-Also, this does not work on Windows, because Windows [doesn't support signals](https://nodejs.org/api/process.html#process_signal_events): `SIGKILL` and `SIGTERM` both terminate the process immediately. Other packages (such as [`taskkill`](https://github.com/sindresorhus/taskkill)) can be used to achieve fail-safe termination on Windows.
-
 #### signal
 
 Type: [`AbortSignal`](https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal)
@@ -852,7 +861,7 @@ This limitation can be worked around by passing either:
 
 ### Retry on error
 
-Safely handle failures by using automatic retries and exponential backoff with the [`p-retry`](https://github.com/sindresorhus/p-retry) package:
+Gracefully handle failures by using automatic retries and exponential backoff with the [`p-retry`](https://github.com/sindresorhus/p-retry) package:
 
 ```js
 import pRetry from 'p-retry';
diff --git a/test/fixtures/no-killable.js b/test/fixtures/no-killable.js
index 05568a2..b27edf7 100755
--- a/test/fixtures/no-killable.js
+++ b/test/fixtures/no-killable.js
@@ -1,13 +1,11 @@
 #!/usr/bin/env node
 import process from 'node:process';
 
-const noop = () => {};
-
-process.on('SIGTERM', noop);
-process.on('SIGINT', noop);
+process.on('SIGTERM', () => {
+	console.log('Received SIGTERM, but we ignore it');
+});
 
 process.send('');
-console.log('.');
 
 setInterval(() => {
 	// Run forever
diff --git a/test/kill.js b/test/kill.js
index 2909ddd..864c136 100644
--- a/test/kill.js
+++ b/test/kill.js
@@ -10,110 +10,58 @@ setFixtureDir();
 
 const TIMEOUT_REGEXP = /timed out after/;
 
-const spawnNoKillable = async (forceKillAfterTimeout, options) => {
-	const subprocess = execa('no-killable.js', {
-		stdio: ['pipe', 'pipe', 'pipe', 'ipc'],
-		forceKillAfterTimeout,
-		...options,
-	});
-	await pEvent(subprocess, 'message');
-	return {subprocess};
-};
-
 test('kill("SIGKILL") should terminate cleanly', async t => {
-	const {subprocess} = await spawnNoKillable();
+	const subprocess = execa('no-killable.js', {stdio: ['ipc']});
+	await pEvent(subprocess, 'message');
 
 	subprocess.kill('SIGKILL');
 
-	const {isTerminated, signal} = await t.throwsAsync(subprocess);
-	t.true(isTerminated);
+	const {signal} = await t.throwsAsync(subprocess);
 	t.is(signal, 'SIGKILL');
 });
 
 // `SIGTERM` cannot be caught on Windows, and it always aborts the process (like `SIGKILL` on Unix).
 // Therefore, this feature and those tests do not make sense on Windows.
 if (process.platform !== 'win32') {
-	const testNoForceKill = async (t, forceKillAfterTimeout, killArgument) => {
-		const {subprocess} = await spawnNoKillable(forceKillAfterTimeout);
+	test('`forceKillAfterTimeout: false` should not kill after a timeout', async t => {
+		const subprocess = execa('no-killable.js', {stdio: ['ipc']});
+		await pEvent(subprocess, 'message');
 
-		subprocess.kill(killArgument);
+		subprocess.kill('SIGTERM', {forceKillAfterTimeout: false});
 
-		await setTimeout(6e3);
 		t.true(isRunning(subprocess.pid));
 		subprocess.kill('SIGKILL');
 
-		const {isTerminated, signal} = await t.throwsAsync(subprocess);
-		t.true(isTerminated);
+		const {signal} = await t.throwsAsync(subprocess);
 		t.is(signal, 'SIGKILL');
-	};
-
-	test('`forceKillAfterTimeout: false` should not kill after a timeout', testNoForceKill, false);
-	test('`forceKillAfterTimeout` should not kill after a timeout with other signals', testNoForceKill, true, 'SIGINT');
+	});
 
-	const testForceKill = async (t, forceKillAfterTimeout, killArgument) => {
-		const {subprocess} = await spawnNoKillable(forceKillAfterTimeout);
+	const testForceKill = async (t, killArguments) => {
+		const subprocess = execa('no-killable.js', {stdio: ['ipc']});
+		await pEvent(subprocess, 'message');
 
-		subprocess.kill(killArgument);
+		subprocess.kill(...killArguments);
 
-		const {isTerminated, signal} = await t.throwsAsync(subprocess);
-		t.true(isTerminated);
+		const {signal} = await t.throwsAsync(subprocess);
 		t.is(signal, 'SIGKILL');
 	};
 
-	test('`forceKillAfterTimeout: number` should kill after a timeout', testForceKill, 50);
-	test('`forceKillAfterTimeout: true` should kill after a timeout', testForceKill, true);
-	test('`forceKillAfterTimeout: undefined` should kill after a timeout', testForceKill, undefined);
-	test('`forceKillAfterTimeout` should kill after a timeout with the killSignal', testForceKill, 50, 'SIGTERM');
+	test('`forceKillAfterTimeout: number` should kill after a timeout', testForceKill, ['SIGTERM', {forceKillAfterTimeout: 50}]);
+	test('`forceKillAfterTimeout: true` should kill after a timeout', testForceKill, ['SIGTERM', {forceKillAfterTimeout: true}]);
+	test('kill("SIGTERM") should kill after a timeout', testForceKill, ['SIGTERM']);
+	test('kill() with no arguments should kill after a timeout', testForceKill, []);
 
 	const testInvalidForceKill = async (t, forceKillAfterTimeout) => {
+		const childProcess = execa('noop.js');
 		t.throws(() => {
-			execa('empty.js', {forceKillAfterTimeout});
+			childProcess.kill('SIGTERM', {forceKillAfterTimeout});
 		}, {instanceOf: TypeError, message: /non-negative integer/});
+		const {signal} = await t.throwsAsync(childProcess);
+		t.is(signal, 'SIGTERM');
 	};
 
 	test('`forceKillAfterTimeout` should not be NaN', testInvalidForceKill, Number.NaN);
 	test('`forceKillAfterTimeout` should not be negative', testInvalidForceKill, -1);
-
-	test('`forceKillAfterTimeout` works with the "signal" option', async t => {
-		const abortController = new AbortController();
-		const {subprocess} = await spawnNoKillable(1, {signal: abortController.signal});
-		abortController.abort();
-		const {isTerminated, signal, isCanceled} = await t.throwsAsync(subprocess);
-		t.false(isTerminated);
-		t.is(signal, undefined);
-		t.true(isCanceled);
-	});
-
-	test.serial('`forceKillAfterTimeout` works with the "timeout" option', async t => {
-		const {subprocess} = await spawnNoKillable(1, {timeout: 2e3});
-		const {isTerminated, signal, timedOut} = await t.throwsAsync(subprocess);
-		t.true(isTerminated);
-		t.is(signal, 'SIGTERM');
-		t.true(timedOut);
-	});
-
-	test('`forceKillAfterTimeout` works with the "maxBuffer" option', async t => {
-		const {subprocess} = await spawnNoKillable(1, {maxBuffer: 1});
-		const {isTerminated, signal} = await t.throwsAsync(subprocess);
-		t.false(isTerminated);
-		t.is(signal, undefined);
-	});
-
-	test('`forceKillAfterTimeout` works with "error" events on childProcess', async t => {
-		const {subprocess} = await spawnNoKillable(1);
-		subprocess.emit('error', new Error('test'));
-		const {isTerminated, signal} = await t.throwsAsync(subprocess);
-		t.false(isTerminated);
-		t.is(signal, undefined);
-	});
-
-	test('`forceKillAfterTimeout` works with "error" events on childProcess.stdout', async t => {
-		const {subprocess} = await spawnNoKillable(1);
-		subprocess.stdout.destroy(new Error('test'));
-		const {isTerminated, signal} = await t.throwsAsync(subprocess);
-		t.false(isTerminated);
-		t.is(signal, undefined);
-	});
 }
 
 test('execa() returns a promise with kill()', async t => {
