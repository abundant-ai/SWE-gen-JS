diff --git a/changelog_unreleased/javascript/16700.md b/changelog_unreleased/javascript/16700.md
new file mode 100644
index 000000000..f4a1ec81f
--- /dev/null
+++ b/changelog_unreleased/javascript/16700.md
@@ -0,0 +1,28 @@
+#### Improve word wrapping edge cases in JSX (#16700 by @seiyab)
+
+<!-- prettier-ignore -->
+```jsx
+// Input
+br_triggers_expression_break =
+  <div><br />
+  text text text text text text text text text text text {this.props.type} </div>
+
+// Prettier stable
+br_triggers_expression_break = (
+  <div>
+    <br />
+    text text text text text text text text text text text {
+      this.props.type
+    }{" "}
+  </div>
+);
+
+// Prettier main
+br_triggers_expression_break = (
+  <div>
+    <br />
+    text text text text text text text text text text text{" "}
+    {this.props.type}{" "}
+  </div>
+);
+```
diff --git a/src/document/builders.js b/src/document/builders.js
index a0c150e26..460478e87 100644
--- a/src/document/builders.js
+++ b/src/document/builders.js
@@ -13,7 +13,11 @@ import {
   DOC_TYPE_LINE_SUFFIX_BOUNDARY,
   DOC_TYPE_TRIM,
 } from "./constants.js";
-import { assertDoc, assertDocArray } from "./utils/assert-doc.js";
+import {
+  assertDoc,
+  assertDocArray,
+  assertDocFillParts,
+} from "./utils/assert-doc.js";
 
 /**
  * TBD properly tagged union for Doc object type is needed here.
@@ -106,7 +110,7 @@ function conditionalGroup(states, opts) {
  * @returns Doc
  */
 function fill(parts) {
-  assertDocArray(parts);
+  assertDocFillParts(parts);
 
   return { type: DOC_TYPE_FILL, parts };
 }
diff --git a/src/document/utils.js b/src/document/utils.js
index 98da38327..9e9d7be0a 100644
--- a/src/document/utils.js
+++ b/src/document/utils.js
@@ -370,12 +370,38 @@ function inheritLabel(doc, fn) {
     : fn(doc);
 }
 
+/**
+ * returns true iff cleanDoc(doc) === ""
+ * @param {import("./builders.js").Doc} doc
+ * @returns {boolean}
+ */
+function isEmptyDoc(doc) {
+  let isEmpty = true;
+  traverseDoc(doc, (doc) => {
+    switch (getDocType(doc)) {
+      case DOC_TYPE_STRING:
+        if (doc === "") {
+          break;
+        }
+      // fallthrough
+      case DOC_TYPE_TRIM:
+      case DOC_TYPE_LINE_SUFFIX_BOUNDARY:
+      case DOC_TYPE_LINE:
+      case DOC_TYPE_BREAK_PARENT:
+        isEmpty = false;
+        return false;
+    }
+  });
+  return isEmpty;
+}
+
 export {
   canBreak,
   cleanDoc,
   findInDoc,
   getDocType,
   inheritLabel,
+  isEmptyDoc,
   mapDoc,
   propagateBreaks,
   removeLines,
diff --git a/src/document/utils/assert-doc.js b/src/document/utils/assert-doc.js
index adb34d4d9..2c148e329 100644
--- a/src/document/utils/assert-doc.js
+++ b/src/document/utils/assert-doc.js
@@ -1,5 +1,16 @@
+import {
+  DOC_TYPE_IF_BREAK,
+  DOC_TYPE_LINE,
+  DOC_TYPE_STRING,
+} from "../constants.js";
+import { isEmptyDoc } from "../utils.js";
+import getDocType from "./get-doc-type.js";
 import traverseDoc from "./traverse-doc.js";
 
+/**
+ * @typedef {import("../builders.js").Doc} Doc
+ */
+
 const checked = process.env.NODE_ENV !== "production" && new WeakSet();
 const noop = () => {};
 const assertDoc =
@@ -34,4 +45,58 @@ const assertDocArray =
         }
       };
 
-export { assertDoc, assertDocArray };
+const assertDocFillParts =
+  process.env.NODE_ENV === "production"
+    ? noop
+    : /**
+       * @param {Doc[]} parts
+       */
+      function (parts) {
+        assertDocArray(parts);
+        if (parts.length > 1 && isEmptyDoc(parts.at(-1))) {
+          // stripTrailingHardline can transform trailing hardline into empty string.
+          // The trailing empty string is not a problem even if it's a line element.
+          parts = parts.slice(0, -1);
+        }
+        for (const [i, doc] of parts.entries()) {
+          if (i % 2 === 1 && !isValidSeparator(doc)) {
+            const type = getDocType(doc);
+            throw new Error(
+              `Unexpected non-line-break doc at ${i}. Doc type is ${type}.`,
+            );
+          }
+        }
+      };
+
+/**
+ * @param {Doc} doc
+ * @returns {boolean}
+ */
+function isValidSeparator(doc) {
+  let hasLine = false;
+  let hasUnexpectedString = false;
+  function rec(doc) {
+    switch (getDocType(doc)) {
+      case DOC_TYPE_LINE:
+        hasLine = true;
+        return;
+      case DOC_TYPE_STRING:
+        if (doc === "{' '}" || doc === '{" "}' || doc === " ") {
+          // As of now, we can include `{' '}` in line part of `fill()`.
+          // This sometimes causes overflows https://github.com/prettier/prettier/issues/2553
+          // We don't have a good way to handle this case.
+          return;
+        }
+        hasUnexpectedString = true;
+        return;
+      case DOC_TYPE_IF_BREAK:
+        traverseDoc(doc.breakContents, rec);
+        return false;
+      default:
+    }
+  }
+  traverseDoc(doc, rec);
+  return hasLine && !hasUnexpectedString;
+}
+
+export { assertDoc, assertDocArray, assertDocFillParts };
diff --git a/src/language-js/print/jsx.js b/src/language-js/print/jsx.js
index eaf544c76..6cd4961fb 100644
--- a/src/language-js/print/jsx.js
+++ b/src/language-js/print/jsx.js
@@ -11,7 +11,11 @@ import {
   lineSuffixBoundary,
   softline,
 } from "../../document/builders.js";
-import { replaceEndOfLine, willBreak } from "../../document/utils.js";
+import {
+  isEmptyDoc,
+  replaceEndOfLine,
+  willBreak,
+} from "../../document/utils.js";
 import {
   printComments,
   printDanglingComments,
@@ -125,7 +129,7 @@ function printJsxElementInternal(path, options, print) {
 
   const rawJsxWhitespace = options.singleQuote ? "{' '}" : '{" "}';
   const jsxWhitespace = isMdxBlock
-    ? " "
+    ? line
     : ifBreak([rawJsxWhitespace, softline], " ");
 
   const isFacebookTranslationTag = node.openingElement?.name?.name === "fbt";
@@ -200,34 +204,51 @@ function printJsxElementInternal(path, options, print) {
     children.shift();
   }
 
-  // Tweak how we format children if outputting this element over multiple lines.
-  // Also detect whether we will force this element to output over multiple lines.
-  const multilineChildren = [];
+  /*
+   * Tweak how we format children if outputting this element over multiple lines.
+   * Also detect whether we will force this element to output over multiple lines.
+   *
+   * Moreover, we need to ensure that we always have line-like doc at odd index, that is rule of fill().
+   * Assuming that parts.length is always odd, satisfying the above can be straightforwardly done by:
+   * - if we push line-like doc, we push empty string after it
+   * - if we push non-line-like doc, push [parts.pop(), doc] instead
+   */
+  /** @type {Doc[]} */
+  const multilineChildren = [""];
   for (const [i, child] of children.entries()) {
     // There are a number of situations where we need to ensure we display
     // whitespace as `{" "}` when outputting this element over multiple lines.
     if (child === jsxWhitespace) {
-      if (i === 1 && children[i - 1] === "") {
+      if (i === 1 && isEmptyDoc(children[i - 1])) {
         if (children.length === 2) {
           // Solitary whitespace
-          multilineChildren.push(rawJsxWhitespace);
+          multilineChildren.push([multilineChildren.pop(), rawJsxWhitespace]);
           continue;
         }
         // Leading whitespace
-        multilineChildren.push([rawJsxWhitespace, hardline]);
+        multilineChildren.push([rawJsxWhitespace, hardline], "");
         continue;
       } else if (i === children.length - 1) {
         // Trailing whitespace
-        multilineChildren.push(rawJsxWhitespace);
+        multilineChildren.push([multilineChildren.pop(), rawJsxWhitespace]);
         continue;
       } else if (children[i - 1] === "" && children[i - 2] === hardline) {
         // Whitespace after line break
-        multilineChildren.push(rawJsxWhitespace);
+        multilineChildren.push([multilineChildren.pop(), rawJsxWhitespace]);
         continue;
       }
     }
 
-    multilineChildren.push(child);
+    // Note that children always satisfy the rule of fill() content.
+    // - printJsxChildren always returns valid fill() content
+    // - we always remove even number (containing zero) of leading items from children.
+    if (i % 2 === 0) {
+      // non-line-like
+      multilineChildren.push([multilineChildren.pop(), child]);
+    } else {
+      // line-like
+      multilineChildren.push(child, "");
+    }
 
     if (willBreak(child)) {
       forcedBreak = true;
@@ -293,10 +314,7 @@ function printJsxElementInternal(path, options, print) {
 // Leading, trailing, and lone whitespace all need to
 // turn themselves into the rather ugly `{' '}` when breaking.
 //
-// We print JSX using the `fill` doc primitive.
-// This requires that we give it an array of alternating
-// content and whitespace elements.
-// To ensure this we add dummy `""` content elements as needed.
+// This function returns Doc array that satisfies rule of `fill()`.
 function printJsxChildren(
   path,
   options,
@@ -304,7 +322,22 @@ function printJsxChildren(
   jsxWhitespace,
   isFacebookTranslationTag,
 ) {
-  const parts = [];
+  /** @type {Doc} */
+  let prevPart = "";
+  /** @type {Doc[]} */
+  const parts = [prevPart];
+  // To ensure rule of `fill()`, we use `push()` and `pushLine()` instead of `parts.push()`.
+  function push(doc) {
+    prevPart = doc;
+    parts.push([parts.pop(), doc]);
+  }
+  function pushLine(doc) {
+    if (doc === "") {
+      return;
+    }
+    prevPart = doc;
+    parts.push(doc, "");
+  }
   path.each(({ node, next }) => {
     if (node.type === "JSXText") {
       const text = rawText(node);
@@ -318,10 +351,9 @@ function printJsxChildren(
 
         // Starts with whitespace
         if (words[0] === "") {
-          parts.push("");
           words.shift();
           if (/\n/u.test(words[0])) {
-            parts.push(
+            pushLine(
               separatorWithWhitespace(
                 isFacebookTranslationTag,
                 words[1],
@@ -330,7 +362,7 @@ function printJsxChildren(
               ),
             );
           } else {
-            parts.push(jsxWhitespace);
+            pushLine(jsxWhitespace);
           }
           words.shift();
         }
@@ -349,30 +381,30 @@ function printJsxChildren(
 
         for (const [i, word] of words.entries()) {
           if (i % 2 === 1) {
-            parts.push(line);
+            pushLine(line);
           } else {
-            parts.push(word);
+            push(word);
           }
         }
 
         if (endWhitespace !== undefined) {
           if (/\n/u.test(endWhitespace)) {
-            parts.push(
+            pushLine(
               separatorWithWhitespace(
                 isFacebookTranslationTag,
-                parts.at(-1),
+                prevPart,
                 node,
                 next,
               ),
             );
           } else {
-            parts.push(jsxWhitespace);
+            pushLine(jsxWhitespace);
           }
         } else {
-          parts.push(
+          pushLine(
             separatorNoWhitespace(
               isFacebookTranslationTag,
-              parts.at(-1),
+              prevPart,
               node,
               next,
             ),
@@ -382,21 +414,21 @@ function printJsxChildren(
         // Keep (up to one) blank line between tags/expressions/text.
         // Note: We don't keep blank lines between text elements.
         if (text.match(/\n/gu).length > 1) {
-          parts.push("", hardline);
+          pushLine(hardline);
         }
       } else {
-        parts.push("", jsxWhitespace);
+        pushLine(jsxWhitespace);
       }
     } else {
       const printedChild = print();
-      parts.push(printedChild);
+      push(printedChild);
 
       const directlyFollowedByMeaningfulText =
         next && isMeaningfulJsxText(next);
       if (directlyFollowedByMeaningfulText) {
         const trimmed = jsxWhitespaceUtils.trim(rawText(next));
         const [firstWord] = jsxWhitespaceUtils.split(trimmed);
-        parts.push(
+        pushLine(
           separatorNoWhitespace(
             isFacebookTranslationTag,
             firstWord,
@@ -405,7 +437,7 @@ function printJsxChildren(
           ),
         );
       } else {
-        parts.push(hardline);
+        pushLine(hardline);
       }
     }
   }, "children");
