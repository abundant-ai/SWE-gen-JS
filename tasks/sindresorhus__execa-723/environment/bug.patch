diff --git a/index.d.ts b/index.d.ts
index 83274b0..e6e1eb5 100644
--- a/index.d.ts
+++ b/index.d.ts
@@ -486,7 +486,7 @@ type CommonOptions<IsSync extends boolean = boolean> = {
 
 	@default 5000
 	*/
-	forceKillAfterDelay?: number | false;
+	forceKillAfterTimeout?: number | false;
 
 	/**
 	If `true`, no quoting or escaping of arguments is done on Windows. Ignored on other platforms. This is set to `true` automatically when the `shell` option is `true`.
diff --git a/index.js b/index.js
index 47bf992..728c0ad 100644
--- a/index.js
+++ b/index.js
@@ -10,7 +10,7 @@ import {makeError} from './lib/error.js';
 import {handleInputAsync, pipeOutputAsync} from './lib/stdio/async.js';
 import {handleInputSync, pipeOutputSync} from './lib/stdio/sync.js';
 import {normalizeStdioNode} from './lib/stdio/normalize.js';
-import {spawnedKill, validateTimeout, normalizeForceKillAfterDelay} from './lib/kill.js';
+import {spawnedKill, validateTimeout, normalizeForceKillAfterTimeout} from './lib/kill.js';
 import {addPipeMethods} from './lib/pipe.js';
 import {getSpawnedResult, makeAllStream} from './lib/stream.js';
 import {mergePromise} from './lib/promise.js';
@@ -53,7 +53,7 @@ const handleArguments = (rawFile, rawArgs, rawOptions = {}) => {
 	validateTimeout(options);
 	options.shell = normalizeFileUrl(options.shell);
 	options.env = getEnv(options);
-	options.forceKillAfterDelay = normalizeForceKillAfterDelay(options.forceKillAfterDelay);
+	options.forceKillAfterTimeout = normalizeForceKillAfterTimeout(options.forceKillAfterTimeout);
 
 	if (process.platform === 'win32' && path.basename(file, '.exe') === 'cmd') {
 		// #116
@@ -81,7 +81,7 @@ const addDefaultOptions = ({
 	windowsHide = true,
 	verbose = verboseDefault,
 	killSignal = 'SIGTERM',
-	forceKillAfterDelay = true,
+	forceKillAfterTimeout = true,
 	...options
 }) => ({
 	...options,
@@ -100,7 +100,7 @@ const addDefaultOptions = ({
 	windowsHide,
 	verbose,
 	killSignal,
-	forceKillAfterDelay,
+	forceKillAfterTimeout,
 });
 
 const handleOutput = (options, value) => {
diff --git a/index.test-d.ts b/index.test-d.ts
index 3a5faf8..73c48bb 100644
--- a/index.test-d.ts
+++ b/index.test-d.ts
@@ -1187,14 +1187,14 @@ execa('unicorns', {killSignal: 'SIGTERM'});
 execaSync('unicorns', {killSignal: 'SIGTERM'});
 execa('unicorns', {killSignal: 9});
 execaSync('unicorns', {killSignal: 9});
-execa('unicorns', {forceKillAfterDelay: false});
-execaSync('unicorns', {forceKillAfterDelay: false});
-execa('unicorns', {forceKillAfterDelay: 42});
-execaSync('unicorns', {forceKillAfterDelay: 42});
-execa('unicorns', {forceKillAfterDelay: undefined});
-execaSync('unicorns', {forceKillAfterDelay: undefined});
-expectError(execa('unicorns', {forceKillAfterDelay: 'true'}));
-expectError(execaSync('unicorns', {forceKillAfterDelay: 'true'}));
+execa('unicorns', {forceKillAfterTimeout: false});
+execaSync('unicorns', {forceKillAfterTimeout: false});
+execa('unicorns', {forceKillAfterTimeout: 42});
+execaSync('unicorns', {forceKillAfterTimeout: 42});
+execa('unicorns', {forceKillAfterTimeout: undefined});
+execaSync('unicorns', {forceKillAfterTimeout: undefined});
+expectError(execa('unicorns', {forceKillAfterTimeout: 'true'}));
+expectError(execaSync('unicorns', {forceKillAfterTimeout: 'true'}));
 execa('unicorns', {signal: new AbortController().signal});
 expectError(execaSync('unicorns', {signal: new AbortController().signal}));
 execa('unicorns', {windowsVerbatimArguments: true});
diff --git a/lib/kill.js b/lib/kill.js
index 6de59eb..ae10671 100644
--- a/lib/kill.js
+++ b/lib/kill.js
@@ -4,44 +4,44 @@ import {onExit} from 'signal-exit';
 
 const DEFAULT_FORCE_KILL_TIMEOUT = 1000 * 5;
 
-// Monkey-patches `childProcess.kill()` to add `forceKillAfterDelay` behavior
-export const spawnedKill = (kill, {forceKillAfterDelay}, controller, signal) => {
+// Monkey-patches `childProcess.kill()` to add `forceKillAfterTimeout` behavior
+export const spawnedKill = (kill, {forceKillAfterTimeout}, controller, signal) => {
 	const killResult = kill(signal);
-	setKillTimeout({kill, signal, forceKillAfterDelay, killResult, controller});
+	setKillTimeout({kill, signal, forceKillAfterTimeout, killResult, controller});
 	return killResult;
 };
 
-const setKillTimeout = async ({kill, signal, forceKillAfterDelay, killResult, controller}) => {
-	if (!shouldForceKill(signal, forceKillAfterDelay, killResult)) {
+const setKillTimeout = async ({kill, signal, forceKillAfterTimeout, killResult, controller}) => {
+	if (!shouldForceKill(signal, forceKillAfterTimeout, killResult)) {
 		return;
 	}
 
 	try {
-		await setTimeout(forceKillAfterDelay, undefined, {signal: controller.signal});
+		await setTimeout(forceKillAfterTimeout, undefined, {signal: controller.signal});
 		kill('SIGKILL');
 	} catch {}
 };
 
-const shouldForceKill = (signal, forceKillAfterDelay, killResult) => isSigterm(signal) && forceKillAfterDelay !== false && killResult;
+const shouldForceKill = (signal, forceKillAfterTimeout, killResult) => isSigterm(signal) && forceKillAfterTimeout !== false && killResult;
 
 const isSigterm = signal => signal === undefined
 	|| signal === os.constants.signals.SIGTERM
 	|| (typeof signal === 'string' && signal.toUpperCase() === 'SIGTERM');
 
-export const normalizeForceKillAfterDelay = forceKillAfterDelay => {
-	if (forceKillAfterDelay === false) {
-		return forceKillAfterDelay;
+export const normalizeForceKillAfterTimeout = forceKillAfterTimeout => {
+	if (forceKillAfterTimeout === false) {
+		return forceKillAfterTimeout;
 	}
 
-	if (forceKillAfterDelay === true) {
+	if (forceKillAfterTimeout === true) {
 		return DEFAULT_FORCE_KILL_TIMEOUT;
 	}
 
-	if (!Number.isFinite(forceKillAfterDelay) || forceKillAfterDelay < 0) {
-		throw new TypeError(`Expected the \`forceKillAfterDelay\` option to be a non-negative integer, got \`${forceKillAfterDelay}\` (${typeof forceKillAfterDelay})`);
+	if (!Number.isFinite(forceKillAfterTimeout) || forceKillAfterTimeout < 0) {
+		throw new TypeError(`Expected the \`forceKillAfterTimeout\` option to be a non-negative integer, got \`${forceKillAfterTimeout}\` (${typeof forceKillAfterTimeout})`);
 	}
 
-	return forceKillAfterDelay;
+	return forceKillAfterTimeout;
 };
 
 const killAfterTimeout = async ({spawned, timeout, killSignal, context, controller}) => {
diff --git a/readme.md b/readme.md
index 2ac752c..89cb363 100644
--- a/readme.md
+++ b/readme.md
@@ -50,7 +50,7 @@ This package improves [`child_process`](https://nodejs.org/api/child_process.htm
 - Redirect [`stdin`](#stdin)/[`stdout`](#stdout-1)/[`stderr`](#stderr-1) from/to files, streams, iterables, strings, `Uint8Array` or [objects](docs/transform.md#object-mode).
 - [Transform](docs/transform.md) `stdin`/`stdout`/`stderr` with simple functions.
 - Iterate over [each text line](docs/transform.md#binary-data) output by the process.
-- [Fail-safe process termination](#forcekillafterdelay).
+- [Fail-safe process termination](#forcekillaftertimeout).
 - Get [interleaved output](#all) from `stdout` and `stderr` similar to what is printed on the terminal.
 - [Strips the final newline](#stripfinalnewline) from the output so you don't have to do `stdout.trim()`.
 - Convenience methods to pipe processes' [input](#input) and [output](#redirect-output-to-a-file).
@@ -754,7 +754,7 @@ Default: `SIGTERM`
 
 Signal value to be used when the spawned process will be killed.
 
-#### forceKillAfterDelay
+#### forceKillAfterTimeout
 
 Type: `number | false`\
 Default: `5000`
diff --git a/test/kill.js b/test/kill.js
index 220cc53..2909ddd 100644
--- a/test/kill.js
+++ b/test/kill.js
@@ -10,10 +10,10 @@ setFixtureDir();
 
 const TIMEOUT_REGEXP = /timed out after/;
 
-const spawnNoKillable = async (forceKillAfterDelay, options) => {
+const spawnNoKillable = async (forceKillAfterTimeout, options) => {
 	const subprocess = execa('no-killable.js', {
 		stdio: ['pipe', 'pipe', 'pipe', 'ipc'],
-		forceKillAfterDelay,
+		forceKillAfterTimeout,
 		...options,
 	});
 	await pEvent(subprocess, 'message');
@@ -33,8 +33,8 @@ test('kill("SIGKILL") should terminate cleanly', async t => {
 // `SIGTERM` cannot be caught on Windows, and it always aborts the process (like `SIGKILL` on Unix).
 // Therefore, this feature and those tests do not make sense on Windows.
 if (process.platform !== 'win32') {
-	const testNoForceKill = async (t, forceKillAfterDelay, killArgument) => {
-		const {subprocess} = await spawnNoKillable(forceKillAfterDelay);
+	const testNoForceKill = async (t, forceKillAfterTimeout, killArgument) => {
+		const {subprocess} = await spawnNoKillable(forceKillAfterTimeout);
 
 		subprocess.kill(killArgument);
 
@@ -47,11 +47,11 @@ if (process.platform !== 'win32') {
 		t.is(signal, 'SIGKILL');
 	};
 
-	test('`forceKillAfterDelay: false` should not kill after a timeout', testNoForceKill, false);
-	test('`forceKillAfterDelay` should not kill after a timeout with other signals', testNoForceKill, true, 'SIGINT');
+	test('`forceKillAfterTimeout: false` should not kill after a timeout', testNoForceKill, false);
+	test('`forceKillAfterTimeout` should not kill after a timeout with other signals', testNoForceKill, true, 'SIGINT');
 
-	const testForceKill = async (t, forceKillAfterDelay, killArgument) => {
-		const {subprocess} = await spawnNoKillable(forceKillAfterDelay);
+	const testForceKill = async (t, forceKillAfterTimeout, killArgument) => {
+		const {subprocess} = await spawnNoKillable(forceKillAfterTimeout);
 
 		subprocess.kill(killArgument);
 
@@ -60,21 +60,21 @@ if (process.platform !== 'win32') {
 		t.is(signal, 'SIGKILL');
 	};
 
-	test('`forceKillAfterDelay: number` should kill after a timeout', testForceKill, 50);
-	test('`forceKillAfterDelay: true` should kill after a timeout', testForceKill, true);
-	test('`forceKillAfterDelay: undefined` should kill after a timeout', testForceKill, undefined);
-	test('`forceKillAfterDelay` should kill after a timeout with the killSignal', testForceKill, 50, 'SIGTERM');
+	test('`forceKillAfterTimeout: number` should kill after a timeout', testForceKill, 50);
+	test('`forceKillAfterTimeout: true` should kill after a timeout', testForceKill, true);
+	test('`forceKillAfterTimeout: undefined` should kill after a timeout', testForceKill, undefined);
+	test('`forceKillAfterTimeout` should kill after a timeout with the killSignal', testForceKill, 50, 'SIGTERM');
 
-	const testInvalidForceKill = async (t, forceKillAfterDelay) => {
+	const testInvalidForceKill = async (t, forceKillAfterTimeout) => {
 		t.throws(() => {
-			execa('empty.js', {forceKillAfterDelay});
+			execa('empty.js', {forceKillAfterTimeout});
 		}, {instanceOf: TypeError, message: /non-negative integer/});
 	};
 
-	test('`forceKillAfterDelay` should not be NaN', testInvalidForceKill, Number.NaN);
-	test('`forceKillAfterDelay` should not be negative', testInvalidForceKill, -1);
+	test('`forceKillAfterTimeout` should not be NaN', testInvalidForceKill, Number.NaN);
+	test('`forceKillAfterTimeout` should not be negative', testInvalidForceKill, -1);
 
-	test('`forceKillAfterDelay` works with the "signal" option', async t => {
+	test('`forceKillAfterTimeout` works with the "signal" option', async t => {
 		const abortController = new AbortController();
 		const {subprocess} = await spawnNoKillable(1, {signal: abortController.signal});
 		abortController.abort();
@@ -84,7 +84,7 @@ if (process.platform !== 'win32') {
 		t.true(isCanceled);
 	});
 
-	test.serial('`forceKillAfterDelay` works with the "timeout" option', async t => {
+	test.serial('`forceKillAfterTimeout` works with the "timeout" option', async t => {
 		const {subprocess} = await spawnNoKillable(1, {timeout: 2e3});
 		const {isTerminated, signal, timedOut} = await t.throwsAsync(subprocess);
 		t.true(isTerminated);
@@ -92,14 +92,14 @@ if (process.platform !== 'win32') {
 		t.true(timedOut);
 	});
 
-	test('`forceKillAfterDelay` works with the "maxBuffer" option', async t => {
+	test('`forceKillAfterTimeout` works with the "maxBuffer" option', async t => {
 		const {subprocess} = await spawnNoKillable(1, {maxBuffer: 1});
 		const {isTerminated, signal} = await t.throwsAsync(subprocess);
 		t.false(isTerminated);
 		t.is(signal, undefined);
 	});
 
-	test('`forceKillAfterDelay` works with "error" events on childProcess', async t => {
+	test('`forceKillAfterTimeout` works with "error" events on childProcess', async t => {
 		const {subprocess} = await spawnNoKillable(1);
 		subprocess.emit('error', new Error('test'));
 		const {isTerminated, signal} = await t.throwsAsync(subprocess);
@@ -107,7 +107,7 @@ if (process.platform !== 'win32') {
 		t.is(signal, undefined);
 	});
 
-	test('`forceKillAfterDelay` works with "error" events on childProcess.stdout', async t => {
+	test('`forceKillAfterTimeout` works with "error" events on childProcess.stdout', async t => {
 		const {subprocess} = await spawnNoKillable(1);
 		subprocess.stdout.destroy(new Error('test'));
 		const {isTerminated, signal} = await t.throwsAsync(subprocess);
