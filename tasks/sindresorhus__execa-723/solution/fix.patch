diff --git a/index.d.ts b/index.d.ts
index e6e1eb5..83274b0 100644
--- a/index.d.ts
+++ b/index.d.ts
@@ -486,7 +486,7 @@ type CommonOptions<IsSync extends boolean = boolean> = {
 
 	@default 5000
 	*/
-	forceKillAfterTimeout?: number | false;
+	forceKillAfterDelay?: number | false;
 
 	/**
 	If `true`, no quoting or escaping of arguments is done on Windows. Ignored on other platforms. This is set to `true` automatically when the `shell` option is `true`.
diff --git a/index.js b/index.js
index 728c0ad..47bf992 100644
--- a/index.js
+++ b/index.js
@@ -10,7 +10,7 @@ import {makeError} from './lib/error.js';
 import {handleInputAsync, pipeOutputAsync} from './lib/stdio/async.js';
 import {handleInputSync, pipeOutputSync} from './lib/stdio/sync.js';
 import {normalizeStdioNode} from './lib/stdio/normalize.js';
-import {spawnedKill, validateTimeout, normalizeForceKillAfterTimeout} from './lib/kill.js';
+import {spawnedKill, validateTimeout, normalizeForceKillAfterDelay} from './lib/kill.js';
 import {addPipeMethods} from './lib/pipe.js';
 import {getSpawnedResult, makeAllStream} from './lib/stream.js';
 import {mergePromise} from './lib/promise.js';
@@ -53,7 +53,7 @@ const handleArguments = (rawFile, rawArgs, rawOptions = {}) => {
 	validateTimeout(options);
 	options.shell = normalizeFileUrl(options.shell);
 	options.env = getEnv(options);
-	options.forceKillAfterTimeout = normalizeForceKillAfterTimeout(options.forceKillAfterTimeout);
+	options.forceKillAfterDelay = normalizeForceKillAfterDelay(options.forceKillAfterDelay);
 
 	if (process.platform === 'win32' && path.basename(file, '.exe') === 'cmd') {
 		// #116
@@ -81,7 +81,7 @@ const addDefaultOptions = ({
 	windowsHide = true,
 	verbose = verboseDefault,
 	killSignal = 'SIGTERM',
-	forceKillAfterTimeout = true,
+	forceKillAfterDelay = true,
 	...options
 }) => ({
 	...options,
@@ -100,7 +100,7 @@ const addDefaultOptions = ({
 	windowsHide,
 	verbose,
 	killSignal,
-	forceKillAfterTimeout,
+	forceKillAfterDelay,
 });
 
 const handleOutput = (options, value) => {
diff --git a/index.test-d.ts b/index.test-d.ts
index 73c48bb..3a5faf8 100644
--- a/index.test-d.ts
+++ b/index.test-d.ts
@@ -1187,14 +1187,14 @@ execa('unicorns', {killSignal: 'SIGTERM'});
 execaSync('unicorns', {killSignal: 'SIGTERM'});
 execa('unicorns', {killSignal: 9});
 execaSync('unicorns', {killSignal: 9});
-execa('unicorns', {forceKillAfterTimeout: false});
-execaSync('unicorns', {forceKillAfterTimeout: false});
-execa('unicorns', {forceKillAfterTimeout: 42});
-execaSync('unicorns', {forceKillAfterTimeout: 42});
-execa('unicorns', {forceKillAfterTimeout: undefined});
-execaSync('unicorns', {forceKillAfterTimeout: undefined});
-expectError(execa('unicorns', {forceKillAfterTimeout: 'true'}));
-expectError(execaSync('unicorns', {forceKillAfterTimeout: 'true'}));
+execa('unicorns', {forceKillAfterDelay: false});
+execaSync('unicorns', {forceKillAfterDelay: false});
+execa('unicorns', {forceKillAfterDelay: 42});
+execaSync('unicorns', {forceKillAfterDelay: 42});
+execa('unicorns', {forceKillAfterDelay: undefined});
+execaSync('unicorns', {forceKillAfterDelay: undefined});
+expectError(execa('unicorns', {forceKillAfterDelay: 'true'}));
+expectError(execaSync('unicorns', {forceKillAfterDelay: 'true'}));
 execa('unicorns', {signal: new AbortController().signal});
 expectError(execaSync('unicorns', {signal: new AbortController().signal}));
 execa('unicorns', {windowsVerbatimArguments: true});
diff --git a/lib/kill.js b/lib/kill.js
index ae10671..6de59eb 100644
--- a/lib/kill.js
+++ b/lib/kill.js
@@ -4,44 +4,44 @@ import {onExit} from 'signal-exit';
 
 const DEFAULT_FORCE_KILL_TIMEOUT = 1000 * 5;
 
-// Monkey-patches `childProcess.kill()` to add `forceKillAfterTimeout` behavior
-export const spawnedKill = (kill, {forceKillAfterTimeout}, controller, signal) => {
+// Monkey-patches `childProcess.kill()` to add `forceKillAfterDelay` behavior
+export const spawnedKill = (kill, {forceKillAfterDelay}, controller, signal) => {
 	const killResult = kill(signal);
-	setKillTimeout({kill, signal, forceKillAfterTimeout, killResult, controller});
+	setKillTimeout({kill, signal, forceKillAfterDelay, killResult, controller});
 	return killResult;
 };
 
-const setKillTimeout = async ({kill, signal, forceKillAfterTimeout, killResult, controller}) => {
-	if (!shouldForceKill(signal, forceKillAfterTimeout, killResult)) {
+const setKillTimeout = async ({kill, signal, forceKillAfterDelay, killResult, controller}) => {
+	if (!shouldForceKill(signal, forceKillAfterDelay, killResult)) {
 		return;
 	}
 
 	try {
-		await setTimeout(forceKillAfterTimeout, undefined, {signal: controller.signal});
+		await setTimeout(forceKillAfterDelay, undefined, {signal: controller.signal});
 		kill('SIGKILL');
 	} catch {}
 };
 
-const shouldForceKill = (signal, forceKillAfterTimeout, killResult) => isSigterm(signal) && forceKillAfterTimeout !== false && killResult;
+const shouldForceKill = (signal, forceKillAfterDelay, killResult) => isSigterm(signal) && forceKillAfterDelay !== false && killResult;
 
 const isSigterm = signal => signal === undefined
 	|| signal === os.constants.signals.SIGTERM
 	|| (typeof signal === 'string' && signal.toUpperCase() === 'SIGTERM');
 
-export const normalizeForceKillAfterTimeout = forceKillAfterTimeout => {
-	if (forceKillAfterTimeout === false) {
-		return forceKillAfterTimeout;
+export const normalizeForceKillAfterDelay = forceKillAfterDelay => {
+	if (forceKillAfterDelay === false) {
+		return forceKillAfterDelay;
 	}
 
-	if (forceKillAfterTimeout === true) {
+	if (forceKillAfterDelay === true) {
 		return DEFAULT_FORCE_KILL_TIMEOUT;
 	}
 
-	if (!Number.isFinite(forceKillAfterTimeout) || forceKillAfterTimeout < 0) {
-		throw new TypeError(`Expected the \`forceKillAfterTimeout\` option to be a non-negative integer, got \`${forceKillAfterTimeout}\` (${typeof forceKillAfterTimeout})`);
+	if (!Number.isFinite(forceKillAfterDelay) || forceKillAfterDelay < 0) {
+		throw new TypeError(`Expected the \`forceKillAfterDelay\` option to be a non-negative integer, got \`${forceKillAfterDelay}\` (${typeof forceKillAfterDelay})`);
 	}
 
-	return forceKillAfterTimeout;
+	return forceKillAfterDelay;
 };
 
 const killAfterTimeout = async ({spawned, timeout, killSignal, context, controller}) => {
diff --git a/readme.md b/readme.md
index 89cb363..2ac752c 100644
--- a/readme.md
+++ b/readme.md
@@ -50,7 +50,7 @@ This package improves [`child_process`](https://nodejs.org/api/child_process.htm
 - Redirect [`stdin`](#stdin)/[`stdout`](#stdout-1)/[`stderr`](#stderr-1) from/to files, streams, iterables, strings, `Uint8Array` or [objects](docs/transform.md#object-mode).
 - [Transform](docs/transform.md) `stdin`/`stdout`/`stderr` with simple functions.
 - Iterate over [each text line](docs/transform.md#binary-data) output by the process.
-- [Fail-safe process termination](#forcekillaftertimeout).
+- [Fail-safe process termination](#forcekillafterdelay).
 - Get [interleaved output](#all) from `stdout` and `stderr` similar to what is printed on the terminal.
 - [Strips the final newline](#stripfinalnewline) from the output so you don't have to do `stdout.trim()`.
 - Convenience methods to pipe processes' [input](#input) and [output](#redirect-output-to-a-file).
@@ -754,7 +754,7 @@ Default: `SIGTERM`
 
 Signal value to be used when the spawned process will be killed.
 
-#### forceKillAfterTimeout
+#### forceKillAfterDelay
 
 Type: `number | false`\
 Default: `5000`
