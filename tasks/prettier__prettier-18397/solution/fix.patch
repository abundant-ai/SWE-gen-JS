diff --git a/changelog_unreleased/javascript/18397.md b/changelog_unreleased/javascript/18397.md
new file mode 100644
index 000000000..0d8eb39e7
--- /dev/null
+++ b/changelog_unreleased/javascript/18397.md
@@ -0,0 +1,13 @@
+#### Avoid double parentheses around logical expression (#18397 by @fisker)
+
+<!-- prettier-ignore -->
+```jsx
+// Input
+const a = !(x || y /* foo */);
+
+// Prettier stable
+const a = !((x || y) /* foo */);
+
+// Prettier main
+const a = !(x || y /* foo */);
+```
diff --git a/src/language-js/parentheses/needs-parentheses.js b/src/language-js/parentheses/needs-parentheses.js
index 9de0107c4..e442fdf8b 100644
--- a/src/language-js/parentheses/needs-parentheses.js
+++ b/src/language-js/parentheses/needs-parentheses.js
@@ -4,6 +4,7 @@ import {
   getFunctionParameters,
   getLeftSidePathName,
   getPrecedence,
+  hasComment,
   hasNakedLeftSide,
   hasNode,
   isArrayExpression,
@@ -380,7 +381,6 @@ function needsParentheses(path, options) {
 
         case "TSTypeAssertion":
         case "TaggedTemplateExpression":
-        case "UnaryExpression":
         case "JSXSpreadAttribute":
         case "SpreadElement":
         case "BindExpression":
@@ -388,6 +388,12 @@ function needsParentheses(path, options) {
         case "TSNonNullExpression":
         case "UpdateExpression":
           return true;
+        case "UnaryExpression":
+          // `UnaryExpression` adds parentheses and indention when argument has comment
+          if (!hasComment(node)) {
+            return true;
+          }
+          break;
 
         case "MemberExpression":
         case "OptionalMemberExpression":
@@ -451,6 +457,7 @@ function needsParentheses(path, options) {
         default:
           return false;
       }
+      break;
 
     case "SequenceExpression":
       // Although parentheses wouldn't hurt around sequence
diff --git a/src/language-js/print/binaryish.js b/src/language-js/print/binaryish.js
index 33d6022bf..bd99a1fc5 100644
--- a/src/language-js/print/binaryish.js
+++ b/src/language-js/print/binaryish.js
@@ -85,7 +85,8 @@ function printBinaryishExpression(path, options, print) {
   if (
     (key === "callee" &&
       (isCallExpression(parent) || parent.type === "NewExpression")) ||
-    parent.type === "UnaryExpression" ||
+    // `UnaryExpression` adds parentheses and indention when argument has comment
+    (parent.type === "UnaryExpression" && !hasComment(node)) ||
     (isMemberExpression(parent) && !parent.computed)
   ) {
     return group([indent([softline, ...parts]), softline]);
@@ -112,6 +113,7 @@ function printBinaryishExpression(path, options, print) {
       !isCallExpression(grandparent) &&
       grandparent.type !== "NewExpression") ||
     parent.type === "TemplateLiteral" ||
+    (key === "argument" && parent.type === "UnaryExpression") ||
     isBooleanTypeCoercion(path);
 
   const shouldIndentIfInlining =
diff --git a/src/language-js/print/estree.js b/src/language-js/print/estree.js
index fbf9a1ef0..ddf9bf1c5 100644
--- a/src/language-js/print/estree.js
+++ b/src/language-js/print/estree.js
@@ -292,12 +292,14 @@ function printEstree(path, options, print, args) {
         parts.push(" ");
       }
 
+      const argumentDoc = print("argument");
+
       if (hasComment(node.argument)) {
         parts.push(
-          group(["(", indent([softline, print("argument")]), softline, ")"]),
+          group(["(", indent([softline, argumentDoc]), softline, ")"]),
         );
       } else {
-        parts.push(print("argument"));
+        parts.push(argumentDoc);
       }
 
       return parts;
