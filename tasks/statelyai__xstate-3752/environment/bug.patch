diff --git a/.changeset/quiet-swans-divide.md b/.changeset/quiet-swans-divide.md
deleted file mode 100644
index 26c521ebad..0000000000
--- a/.changeset/quiet-swans-divide.md
+++ /dev/null
@@ -1,5 +0,0 @@
----
-'@xstate/react': patch
----
-
-Computing the initial state is now consistent with `useMachine` and `useActor`, avoiding stale initial state problems with nested machines
diff --git a/packages/xstate-react/src/useActor.ts b/packages/xstate-react/src/useActor.ts
index 5787e19787..6e58144b16 100644
--- a/packages/xstate-react/src/useActor.ts
+++ b/packages/xstate-react/src/useActor.ts
@@ -3,7 +3,6 @@ import useIsomorphicLayoutEffect from 'use-isomorphic-layout-effect';
 import { ActorRef, EventObject, Sender } from 'xstate';
 import useConstant from './useConstant';
 import { useSyncExternalStore } from 'use-sync-external-store/shim';
-import { getServiceSnapshot, isService } from './utils';
 
 export function isActorWithState<T extends ActorRef<any>>(
   actorRef: T
@@ -25,9 +24,7 @@ function defaultGetSnapshot<TEmitted>(
   actorRef: ActorRef<any, TEmitted>
 ): TEmitted | undefined {
   return 'getSnapshot' in actorRef
-    ? isService(actorRef)
-      ? getServiceSnapshot(actorRef as any)
-      : actorRef.getSnapshot()
+    ? actorRef.getSnapshot()
     : isActorWithState(actorRef)
     ? actorRef.state
     : undefined;
diff --git a/packages/xstate-react/src/useSelector.ts b/packages/xstate-react/src/useSelector.ts
index 0684e8e882..0f480baa36 100644
--- a/packages/xstate-react/src/useSelector.ts
+++ b/packages/xstate-react/src/useSelector.ts
@@ -1,8 +1,12 @@
 import { useCallback, useRef } from 'react';
 import { useSyncExternalStoreWithSelector } from 'use-sync-external-store/shim/with-selector';
-import { ActorRef, AnyState, Subscribable } from 'xstate';
+import { ActorRef, AnyState, Interpreter, Subscribable } from 'xstate';
 import { isActorWithState } from './useActor';
-import { getServiceSnapshot, isService } from './utils';
+import { getServiceSnapshot } from './utils';
+
+function isService(actor: any): actor is Interpreter<any, any, any, any> {
+  return 'state' in actor && 'machine' in actor;
+}
 
 const defaultCompare = (a, b) => a === b;
 const defaultGetSnapshot = (a, initialStateCacheRef) => {
diff --git a/packages/xstate-react/src/utils.ts b/packages/xstate-react/src/utils.ts
index 34f65616fb..5c01e2ed1e 100644
--- a/packages/xstate-react/src/utils.ts
+++ b/packages/xstate-react/src/utils.ts
@@ -62,9 +62,3 @@ export function shallowEqual(objA: any, objB: any) {
 
   return true;
 }
-
-export function isService(
-  actor: any
-): actor is Interpreter<any, any, any, any> {
-  return 'state' in actor && 'machine' in actor;
-}
diff --git a/packages/xstate-react/test/useInterpret.test.tsx b/packages/xstate-react/test/useInterpret.test.tsx
index e4709e55d8..f68f8e2a07 100644
--- a/packages/xstate-react/test/useInterpret.test.tsx
+++ b/packages/xstate-react/test/useInterpret.test.tsx
@@ -1,9 +1,8 @@
 import * as React from 'react';
-import { ActorRefFrom, createMachine, spawn } from 'xstate';
-import { fireEvent, screen, waitFor } from '@testing-library/react';
-import { useActor, useInterpret, useMachine } from '../src';
+import { createMachine } from 'xstate';
+import { fireEvent, screen } from '@testing-library/react';
+import { useInterpret, useMachine } from '../src';
 import { describeEachReactMode } from './utils';
-import { sendTo } from 'xstate/lib/actions';
 
 const originalConsoleWarn = console.warn;
 
@@ -179,119 +178,4 @@ describeEachReactMode('useInterpret (%s)', ({ suiteKey, render }) => {
       `);
     }
   });
-
-  it('should change state when started', async () => {
-    const childMachine = createMachine({
-      initial: 'waiting',
-      states: {
-        waiting: {
-          on: {
-            EVENT: 'received'
-          }
-        },
-        received: {}
-      }
-    });
-
-    const parentMachine = createMachine<{
-      childRef: ActorRefFrom<typeof childMachine>;
-    }>({
-      context: () => ({
-        childRef: spawn(childMachine)
-      }),
-      on: {
-        SEND_TO_CHILD: {
-          actions: sendTo((ctx) => ctx.childRef, { type: 'EVENT' })
-        }
-      }
-    });
-
-    const App = () => {
-      const parentActor = useInterpret(parentMachine);
-      const [parentState, parentSend] = useActor(parentActor);
-      const [childState] = useActor(parentState.context.childRef);
-
-      return (
-        <>
-          <button
-            data-testid="button"
-            onClick={() => parentSend({ type: 'SEND_TO_CHILD' })}
-          >
-            Send to child
-          </button>
-          <div data-testid="child-state">{childState.value}</div>
-        </>
-      );
-    };
-
-    render(<App />);
-
-    const button = screen.getByTestId('button');
-    const childState = screen.getByTestId('child-state');
-
-    expect(childState.textContent).toBe('waiting');
-
-    fireEvent.click(button);
-
-    await waitFor(() => {
-      expect(childState.textContent).toBe('received');
-    });
-  });
-
-  it('should change state when started (useMachine)', async () => {
-    const childMachine = createMachine({
-      initial: 'waiting',
-      states: {
-        waiting: {
-          on: {
-            EVENT: 'received'
-          }
-        },
-        received: {}
-      }
-    });
-
-    const parentMachine = createMachine<{
-      childRef: ActorRefFrom<typeof childMachine>;
-    }>({
-      context: () => ({
-        childRef: spawn(childMachine)
-      }),
-      on: {
-        SEND_TO_CHILD: {
-          actions: sendTo((ctx) => ctx.childRef, { type: 'EVENT' })
-        }
-      }
-    });
-
-    const App = () => {
-      const [parentState, parentSend] = useMachine(parentMachine);
-      const [childState] = useActor(parentState.context.childRef);
-
-      return (
-        <>
-          <button
-            data-testid="button"
-            onClick={() => parentSend({ type: 'SEND_TO_CHILD' })}
-          >
-            Send to child
-          </button>
-          <div data-testid="child-state">{childState.value}</div>
-        </>
-      );
-    };
-
-    render(<App />);
-
-    const button = screen.getByTestId('button');
-    const childState = screen.getByTestId('child-state');
-
-    expect(childState.textContent).toBe('waiting');
-
-    fireEvent.click(button);
-
-    await waitFor(() => {
-      expect(childState.textContent).toBe('received');
-    });
-  });
 });
