diff --git a/.gitignore b/.gitignore
index faec1c5f1..918e0f285 100644
--- a/.gitignore
+++ b/.gitignore
@@ -5,6 +5,7 @@ _site
 *swp
 *.log
 *.bak
+*~
 
 node_modules
 .nyc_output
diff --git a/src/expression/embeddedDocs/embeddedDocs.js b/src/expression/embeddedDocs/embeddedDocs.js
index 9c6d12416..2e4383beb 100644
--- a/src/expression/embeddedDocs/embeddedDocs.js
+++ b/src/expression/embeddedDocs/embeddedDocs.js
@@ -155,6 +155,7 @@ import { transposeDocs } from './function/matrix/transpose.js'
 import { zerosDocs } from './function/matrix/zeros.js'
 import { fftDocs } from './function/matrix/fft.js'
 import { ifftDocs } from './function/matrix/ifft.js'
+import { bernoulliDocs } from './function/probability/bernoulli.js'
 import { combinationsDocs } from './function/probability/combinations.js'
 import { combinationsWithRepDocs } from './function/probability/combinationsWithRep.js'
 import { factorialDocs } from './function/probability/factorial.js'
@@ -501,6 +502,7 @@ export const embeddedDocs = {
   solveODE: solveODEDocs,
 
   // functions - probability
+  bernoulli: bernoulliDocs,
   combinations: combinationsDocs,
   combinationsWithRep: combinationsWithRepDocs,
   // distribution: distributionDocs,
diff --git a/src/expression/embeddedDocs/function/combinatorics/stirlingS2.js b/src/expression/embeddedDocs/function/combinatorics/stirlingS2.js
index 3f736c39a..780898675 100644
--- a/src/expression/embeddedDocs/function/combinatorics/stirlingS2.js
+++ b/src/expression/embeddedDocs/function/combinatorics/stirlingS2.js
@@ -4,9 +4,9 @@ export const stirlingS2Docs = {
   syntax: [
     'stirlingS2(n, k)'
   ],
-  description: 'he Stirling numbers of the second kind, counts the number of ways to partition a set of n labelled objects into k nonempty unlabelled subsets. `stirlingS2` only takes integer arguments. The following condition must be enforced: k <= n. If n = k or k = 1, then s(n,k) = 1.',
+  description: 'The Stirling numbers of the second kind, counts the number of ways to partition a set of n labelled objects into k nonempty unlabelled subsets. `stirlingS2` only takes integer arguments. The following condition must be enforced: k <= n. If n = k or k = 1, then s(n,k) = 1.',
   examples: [
     'stirlingS2(5, 3)'
   ],
-  seealso: ['bellNumbers']
+  seealso: ['bellNumbers', 'bernoulli']
 }
diff --git a/src/expression/embeddedDocs/function/probability/bernoulli.js b/src/expression/embeddedDocs/function/probability/bernoulli.js
new file mode 100644
index 000000000..bebbefca8
--- /dev/null
+++ b/src/expression/embeddedDocs/function/probability/bernoulli.js
@@ -0,0 +1,13 @@
+export const bernoulliDocs = {
+  name: 'bernoulli',
+  category: 'Probability',
+  syntax: [
+    'bernoulli(n)'
+  ],
+  description: 'The nth Bernoulli number',
+  examples: [
+    'bernoulli(4)',
+    'bernoulli(fraction(12))'
+  ],
+  seealso: ['combinations', 'gamma', 'stirlingS2']
+}
diff --git a/src/factoriesAny.js b/src/factoriesAny.js
index 89b49af02..15ea5de0d 100644
--- a/src/factoriesAny.js
+++ b/src/factoriesAny.js
@@ -244,6 +244,7 @@ export { createVariance } from './function/statistics/variance.js'
 export { createQuantileSeq } from './function/statistics/quantileSeq.js'
 export { createStd } from './function/statistics/std.js'
 export { createCorr } from './function/statistics/corr.js'
+export { createBernoulli } from './function/probability/bernoulli.js'
 export { createCombinations } from './function/probability/combinations.js'
 export { createCombinationsWithRep } from './function/probability/combinationsWithRep.js'
 export { createGamma } from './function/probability/gamma.js'
diff --git a/src/factoriesNumber.js b/src/factoriesNumber.js
index 0047dc362..73a0eaafb 100644
--- a/src/factoriesNumber.js
+++ b/src/factoriesNumber.js
@@ -224,6 +224,7 @@ export const createSubset = /* #__PURE__ */ factory('subset', [], () => noSubset
 export { createPartitionSelect } from './function/matrix/partitionSelect.js'
 
 // probability
+export { createBernoulli } from './function/probability/bernoulli.js'
 export const createCombinations = createNumberFactory('combinations', combinationsNumber)
 export const createGamma = createNumberFactory('gamma', gammaNumber)
 export const createLgamma = createNumberFactory('lgamma', lgammaNumber)
diff --git a/src/function/probability/bernoulli.js b/src/function/probability/bernoulli.js
new file mode 100644
index 000000000..e591ee1fd
--- /dev/null
+++ b/src/function/probability/bernoulli.js
@@ -0,0 +1,112 @@
+import { factory } from '../../utils/factory.js'
+import { isInteger } from '../../utils/number.js'
+
+const name = 'bernoulli'
+const dependencies = [
+  'typed', 'config', 'isInteger', 'number', '?BigNumber', '?Fraction'
+]
+
+export const createBernoulli = /* #__PURE__ */ factory(name, dependencies, ({
+  typed, config, number, BigNumber, Fraction
+}) => {
+  /**
+   * Return the `n`th Bernoulli number, for positive integers `n`
+   *
+   * Syntax:
+   *
+   *     math.bernoulli(n)
+   *
+   * Examples:
+   *
+   *     math.bernoulli(1)                  // returns -0.5
+   *     // All other odd Bernoulli numbers are 0:
+   *     math.bernoulli(7)                  // returns 0
+   *     math.bernoulli(math.bignumber(6))  // value bignumber(1).div(42)
+   *     // Produces exact rationals for bigint or fraction input:
+   *     math.bernoulli(8n)                 // Fraction -1,30
+   *     math.bernoulli(math.fraction(10))  // Fraction 5,66
+   *
+   * See also:
+   *
+   *     combinations, gamma, stirlingS2
+   *
+   * @param {number | BigNumber | bigint | Fraction} n
+   *    Index of the Bernoulli number
+   * @return {number | BigNumber | Fraction}
+   *    nth Bernoulli number, of a type corresponding to the argument n
+   */
+
+  const numberCache = [undefined]
+  const fractionCache = [undefined]
+  let bigCache = [undefined]
+  let cachedPrecision = 50
+  return typed(name, {
+    number: index => _bernoulli(
+      index, n => n, numberCache,
+      (a, b) => a + b, (a, b) => a * b, (a, b) => a / b),
+    'bigint | Fraction': index => _bernoulli(
+      number(index), n => new Fraction(n), fractionCache,
+      (a, b) => a.add(b), (a, b) => a.mul(b), (a, b) => a.div(b)),
+    BigNumber: index => {
+      if (config.precision !== cachedPrecision) {
+        bigCache = [undefined]
+        cachedPrecision = config.precision
+      }
+      return _bernoulli(
+        number(index), n => new BigNumber(n), bigCache,
+        (a, b) => a.add(b), (a, b) => a.mul(b), (a, b) => a.div(b))
+    }
+  })
+})
+
+/**
+ * Underlying implementation, with all operations passed in.
+ * Parameters:
+ * 1. index: a (positive integer) number specifying which Bernoulli number
+ *    to compute.
+ * 2. promote: a function that takes an integer number and returns
+ *    the desired type for the Bernoulli number values.
+ * 3. A: a cache array of partial computation data that _bernoulli should use.
+ *    Different cache arrays should be provided for different types.
+ * 4. plus: a function that adds two values of the desired type.
+ * 5. times: a function that multiplies two values of the desired type.
+ * 6. divide: a function that divides one value of the desired type by another.
+ */
+function _bernoulli (index, promote, A, plus, times, divide) {
+  if (index < 0 || !isInteger(index)) {
+    throw new RangeError('Bernoulli index must be nonnegative integer')
+  }
+  if (index === 0) return promote(1)
+  if (index === 1) return divide(promote(-1), promote(2))
+  if (index % 2 === 1) return promote(0)
+  // We proceed as in https://math.stackexchange.com/a/2844337
+  // (by no means the most efficient, but very simple to implement)
+  // A cache entry consists of a triple
+  // [cotangent coefficient a_n, prefactor, Bernouilli number B_2n]
+  const one = promote(1)
+  if (A.length === 1) {
+    A.push([
+      divide(one, promote(-3)),
+      divide(one, promote(-2)),
+      divide(one, promote(6))
+    ])
+  }
+  const half = index / 2
+  const zero = promote(0)
+  const two = promote(2)
+  while (A.length <= half) {
+    const i = A.length // next cotangent coefficient to compute
+    const lim = Math.floor((i + 1) / 2)
+    let a = zero
+    for (let m = 1; m < lim; ++m) {
+      a = plus(a, times(A[m][0], A[i - m][0]))
+    }
+    a = times(a, two)
+    if (i % 2 === 0) a = plus(a, times(A[lim][0], A[lim][0]))
+    a = divide(a, promote(-(2 * i + 1)))
+    const prefactor = divide(
+      times(A[i - 1][1], promote(-i * (2 * i - 1))), two)
+    A.push([a, prefactor, times(prefactor, a)])
+  }
+  return A[half][2]
+}
diff --git a/tools/approx.js b/tools/approx.js
index e1a297739..7deaf2775 100644
--- a/tools/approx.js
+++ b/tools/approx.js
@@ -35,10 +35,25 @@ export function approxEqual (a, b, epsilon) {
       assert.ok(Math.abs(a) < epsilon, (a + ' ~= ' + b))
     } else {
       const diff = Math.abs(a - b)
-      const max = Math.max(a, b)
+      const max = Math.max(Math.abs(a), Math.abs(b))
       const maxDiff = Math.abs(max * epsilon)
       assert.ok(diff <= maxDiff, (a + ' ~= ' + b + ' (epsilon: ' + epsilon + ')'))
     }
+  } else if (a && b && a.isBigNumber && b.isBigNumber) {
+    if (!a.equals(b)) {
+      if (a.isNaN()) assert.ok(b.isNaN())
+      else if (a.equals(0)) {
+        assert.ok(b.abs().lt(epsilon))
+      } else if (b.equals(0)) {
+        assert.ok(a.abs().lt(epsilon))
+      } else {
+        const diff = a.minus(b).abs()
+        let mx = a.abs()
+        if (mx.lt(b.abs())) mx = b.abs()
+        const maxDiff = mx.mul(epsilon)
+        assert.ok(diff.lt(maxDiff), `Diff ${diff} exceeds ${maxDiff}`)
+      }
+    }
   } else if (a && a.isBigNumber) {
     return approxEqual(a.toNumber(), b, epsilon)
   } else if (b && b.isBigNumber) {
diff --git a/types/index.d.ts b/types/index.d.ts
index 4c4dd60d7..f443b7192 100644
--- a/types/index.d.ts
+++ b/types/index.d.ts
@@ -2496,6 +2496,14 @@ export interface MathJsInstance extends MathJsFactory {
    * Probability functions
    ************************************************************************/
 
+  /**
+   * Compute the nth Bernoulli number
+   * @param n  index
+   * @returns  nth Bernoulli number
+   */
+  bernoulli<T extends number | Fraction | BigNumber>(n: T): NoLiteralType<T>
+  bernoulli(n: bigint): Fraction
+
   /**
    * Compute the number of ways of picking k unordered outcomes from n
    * possibilities. Combinations only takes integer arguments. The
@@ -4119,6 +4127,7 @@ export const {
   ifftDependencies,
 
   // probability dependencies
+  bernoulliDependencies,
   combinationsDependencies,
   factorialDependencies,
   gammaDependencies,
@@ -6346,6 +6355,14 @@ export interface MathJsChain<TValue> {
    * Probability functions
    ************************************************************************/
 
+  /**
+   * Bernoulli number at this index
+   */
+  bernoulli<T extends number | BigNumber | Fraction>(
+    this: MathJsChain<T>
+  ): MathJsChain<NoLiteralType<T>>
+  bernoulli(this: MathJsChain<bigint>): MathJsChain<Fraction>
+
   /**
    * Compute the number of ways of picking k unordered outcomes from n
    * possibilities. Combinations only takes integer arguments. The
@@ -7639,6 +7656,7 @@ export const {
   ifft,
 
   // probability
+  bernoulli,
   combinations,
   factorial,
   gamma,
