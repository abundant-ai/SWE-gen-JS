diff --git a/.gitignore b/.gitignore
index 918e0f285..faec1c5f1 100644
--- a/.gitignore
+++ b/.gitignore
@@ -5,7 +5,6 @@ _site
 *swp
 *.log
 *.bak
-*~
 
 node_modules
 .nyc_output
diff --git a/src/expression/embeddedDocs/embeddedDocs.js b/src/expression/embeddedDocs/embeddedDocs.js
index 2e4383beb..9c6d12416 100644
--- a/src/expression/embeddedDocs/embeddedDocs.js
+++ b/src/expression/embeddedDocs/embeddedDocs.js
@@ -155,7 +155,6 @@ import { transposeDocs } from './function/matrix/transpose.js'
 import { zerosDocs } from './function/matrix/zeros.js'
 import { fftDocs } from './function/matrix/fft.js'
 import { ifftDocs } from './function/matrix/ifft.js'
-import { bernoulliDocs } from './function/probability/bernoulli.js'
 import { combinationsDocs } from './function/probability/combinations.js'
 import { combinationsWithRepDocs } from './function/probability/combinationsWithRep.js'
 import { factorialDocs } from './function/probability/factorial.js'
@@ -502,7 +501,6 @@ export const embeddedDocs = {
   solveODE: solveODEDocs,
 
   // functions - probability
-  bernoulli: bernoulliDocs,
   combinations: combinationsDocs,
   combinationsWithRep: combinationsWithRepDocs,
   // distribution: distributionDocs,
diff --git a/src/expression/embeddedDocs/function/combinatorics/stirlingS2.js b/src/expression/embeddedDocs/function/combinatorics/stirlingS2.js
index 780898675..3f736c39a 100644
--- a/src/expression/embeddedDocs/function/combinatorics/stirlingS2.js
+++ b/src/expression/embeddedDocs/function/combinatorics/stirlingS2.js
@@ -4,9 +4,9 @@ export const stirlingS2Docs = {
   syntax: [
     'stirlingS2(n, k)'
   ],
-  description: 'The Stirling numbers of the second kind, counts the number of ways to partition a set of n labelled objects into k nonempty unlabelled subsets. `stirlingS2` only takes integer arguments. The following condition must be enforced: k <= n. If n = k or k = 1, then s(n,k) = 1.',
+  description: 'he Stirling numbers of the second kind, counts the number of ways to partition a set of n labelled objects into k nonempty unlabelled subsets. `stirlingS2` only takes integer arguments. The following condition must be enforced: k <= n. If n = k or k = 1, then s(n,k) = 1.',
   examples: [
     'stirlingS2(5, 3)'
   ],
-  seealso: ['bellNumbers', 'bernoulli']
+  seealso: ['bellNumbers']
 }
diff --git a/src/expression/embeddedDocs/function/probability/bernoulli.js b/src/expression/embeddedDocs/function/probability/bernoulli.js
deleted file mode 100644
index bebbefca8..000000000
--- a/src/expression/embeddedDocs/function/probability/bernoulli.js
+++ /dev/null
@@ -1,13 +0,0 @@
-export const bernoulliDocs = {
-  name: 'bernoulli',
-  category: 'Probability',
-  syntax: [
-    'bernoulli(n)'
-  ],
-  description: 'The nth Bernoulli number',
-  examples: [
-    'bernoulli(4)',
-    'bernoulli(fraction(12))'
-  ],
-  seealso: ['combinations', 'gamma', 'stirlingS2']
-}
diff --git a/src/factoriesAny.js b/src/factoriesAny.js
index 15ea5de0d..89b49af02 100644
--- a/src/factoriesAny.js
+++ b/src/factoriesAny.js
@@ -244,7 +244,6 @@ export { createVariance } from './function/statistics/variance.js'
 export { createQuantileSeq } from './function/statistics/quantileSeq.js'
 export { createStd } from './function/statistics/std.js'
 export { createCorr } from './function/statistics/corr.js'
-export { createBernoulli } from './function/probability/bernoulli.js'
 export { createCombinations } from './function/probability/combinations.js'
 export { createCombinationsWithRep } from './function/probability/combinationsWithRep.js'
 export { createGamma } from './function/probability/gamma.js'
diff --git a/src/factoriesNumber.js b/src/factoriesNumber.js
index 73a0eaafb..0047dc362 100644
--- a/src/factoriesNumber.js
+++ b/src/factoriesNumber.js
@@ -224,7 +224,6 @@ export const createSubset = /* #__PURE__ */ factory('subset', [], () => noSubset
 export { createPartitionSelect } from './function/matrix/partitionSelect.js'
 
 // probability
-export { createBernoulli } from './function/probability/bernoulli.js'
 export const createCombinations = createNumberFactory('combinations', combinationsNumber)
 export const createGamma = createNumberFactory('gamma', gammaNumber)
 export const createLgamma = createNumberFactory('lgamma', lgammaNumber)
diff --git a/src/function/probability/bernoulli.js b/src/function/probability/bernoulli.js
deleted file mode 100644
index e591ee1fd..000000000
--- a/src/function/probability/bernoulli.js
+++ /dev/null
@@ -1,112 +0,0 @@
-import { factory } from '../../utils/factory.js'
-import { isInteger } from '../../utils/number.js'
-
-const name = 'bernoulli'
-const dependencies = [
-  'typed', 'config', 'isInteger', 'number', '?BigNumber', '?Fraction'
-]
-
-export const createBernoulli = /* #__PURE__ */ factory(name, dependencies, ({
-  typed, config, number, BigNumber, Fraction
-}) => {
-  /**
-   * Return the `n`th Bernoulli number, for positive integers `n`
-   *
-   * Syntax:
-   *
-   *     math.bernoulli(n)
-   *
-   * Examples:
-   *
-   *     math.bernoulli(1)                  // returns -0.5
-   *     // All other odd Bernoulli numbers are 0:
-   *     math.bernoulli(7)                  // returns 0
-   *     math.bernoulli(math.bignumber(6))  // value bignumber(1).div(42)
-   *     // Produces exact rationals for bigint or fraction input:
-   *     math.bernoulli(8n)                 // Fraction -1,30
-   *     math.bernoulli(math.fraction(10))  // Fraction 5,66
-   *
-   * See also:
-   *
-   *     combinations, gamma, stirlingS2
-   *
-   * @param {number | BigNumber | bigint | Fraction} n
-   *    Index of the Bernoulli number
-   * @return {number | BigNumber | Fraction}
-   *    nth Bernoulli number, of a type corresponding to the argument n
-   */
-
-  const numberCache = [undefined]
-  const fractionCache = [undefined]
-  let bigCache = [undefined]
-  let cachedPrecision = 50
-  return typed(name, {
-    number: index => _bernoulli(
-      index, n => n, numberCache,
-      (a, b) => a + b, (a, b) => a * b, (a, b) => a / b),
-    'bigint | Fraction': index => _bernoulli(
-      number(index), n => new Fraction(n), fractionCache,
-      (a, b) => a.add(b), (a, b) => a.mul(b), (a, b) => a.div(b)),
-    BigNumber: index => {
-      if (config.precision !== cachedPrecision) {
-        bigCache = [undefined]
-        cachedPrecision = config.precision
-      }
-      return _bernoulli(
-        number(index), n => new BigNumber(n), bigCache,
-        (a, b) => a.add(b), (a, b) => a.mul(b), (a, b) => a.div(b))
-    }
-  })
-})
-
-/**
- * Underlying implementation, with all operations passed in.
- * Parameters:
- * 1. index: a (positive integer) number specifying which Bernoulli number
- *    to compute.
- * 2. promote: a function that takes an integer number and returns
- *    the desired type for the Bernoulli number values.
- * 3. A: a cache array of partial computation data that _bernoulli should use.
- *    Different cache arrays should be provided for different types.
- * 4. plus: a function that adds two values of the desired type.
- * 5. times: a function that multiplies two values of the desired type.
- * 6. divide: a function that divides one value of the desired type by another.
- */
-function _bernoulli (index, promote, A, plus, times, divide) {
-  if (index < 0 || !isInteger(index)) {
-    throw new RangeError('Bernoulli index must be nonnegative integer')
-  }
-  if (index === 0) return promote(1)
-  if (index === 1) return divide(promote(-1), promote(2))
-  if (index % 2 === 1) return promote(0)
-  // We proceed as in https://math.stackexchange.com/a/2844337
-  // (by no means the most efficient, but very simple to implement)
-  // A cache entry consists of a triple
-  // [cotangent coefficient a_n, prefactor, Bernouilli number B_2n]
-  const one = promote(1)
-  if (A.length === 1) {
-    A.push([
-      divide(one, promote(-3)),
-      divide(one, promote(-2)),
-      divide(one, promote(6))
-    ])
-  }
-  const half = index / 2
-  const zero = promote(0)
-  const two = promote(2)
-  while (A.length <= half) {
-    const i = A.length // next cotangent coefficient to compute
-    const lim = Math.floor((i + 1) / 2)
-    let a = zero
-    for (let m = 1; m < lim; ++m) {
-      a = plus(a, times(A[m][0], A[i - m][0]))
-    }
-    a = times(a, two)
-    if (i % 2 === 0) a = plus(a, times(A[lim][0], A[lim][0]))
-    a = divide(a, promote(-(2 * i + 1)))
-    const prefactor = divide(
-      times(A[i - 1][1], promote(-i * (2 * i - 1))), two)
-    A.push([a, prefactor, times(prefactor, a)])
-  }
-  return A[half][2]
-}
diff --git a/test/node-tests/doc.test.js b/test/node-tests/doc.test.js
index 01e3ee8fd..fdf8f5112 100644
--- a/test/node-tests/doc.test.js
+++ b/test/node-tests/doc.test.js
@@ -49,7 +49,6 @@ function extractValue (spec) {
     DenseMatrix: "math.matrix(_, 'dense')",
     string: '_',
     Node: 'math.parse(_)',
-    value: 'math._',
     throws: "'_'"
   }
   if (words[0] in keywords) {
@@ -162,9 +161,6 @@ function checkExpectation (want, got) {
   ) {
     return true // we obtained the expected error type
   }
-  if (want && got && want.isBigNumber && got.isBigNumber) {
-    return approxEqual(got, want, 1e-50)
-  }
   if (typeof want !== 'undefined') {
     return approxDeepEqual(got, want)
   } else {
diff --git a/test/typescript-tests/testTypes.ts b/test/typescript-tests/testTypes.ts
index 9e2d4b684..fa8db01a0 100644
--- a/test/typescript-tests/testTypes.ts
+++ b/test/typescript-tests/testTypes.ts
@@ -999,11 +999,6 @@ Chaining examples
     MathJsChain<MathCollection>
   >()
 
-  // bernoulli
-  expectTypeOf(math.chain(math.bigint(4)).bernoulli()).toMatchTypeOf<
-    MathJsChain<Fraction>
-  >()
-
   // TODO complete the rest of these...
 }
 
@@ -2892,7 +2887,6 @@ Probability function examples
 {
   const math = create(all, {})
 
-  expectTypeOf(math.bernoulli(math.fraction(12))).toMatchTypeOf<Fraction>()
   expectTypeOf(math.lgamma(1.5)).toMatchTypeOf<number>()
   expectTypeOf(math.lgamma(math.complex(1.5, -1.5))).toMatchTypeOf<Complex>()
 }
diff --git a/test/unit-tests/function/probability/bernoulli.test.js b/test/unit-tests/function/probability/bernoulli.test.js
deleted file mode 100644
index be016efb9..000000000
--- a/test/unit-tests/function/probability/bernoulli.test.js
+++ /dev/null
@@ -1,48 +0,0 @@
-import assert from 'assert'
-import { approxEqual } from '../../../../tools/approx.js'
-import math from '../../../../src/defaultInstance.js'
-const bernoulli = math.bernoulli
-
-const EPSILON = 1e-14
-const BEPSILON = 1e-50
-
-describe('bernoulli', function () {
-  it('should calculate number values of the Bernoulli numbers', function () {
-    assert.strictEqual(bernoulli(0), 1)
-    assert.strictEqual(bernoulli(1), -1 / 2)
-    assert.strictEqual(bernoulli(2), 1 / 6)
-    assert.strictEqual(bernoulli(3), 0)
-    approxEqual(bernoulli(4), -1 / 30, EPSILON)
-    approxEqual(bernoulli(22), 854513 / 138, EPSILON)
-  })
-
-  it('should calculate BigNumber values of the Bernoulli numbers', function () {
-    const big = math.bignumber
-    assert.deepStrictEqual(bernoulli(big(1)), big(-1 / 2))
-    assert.deepStrictEqual(bernoulli(big(5)), big(0))
-    approxEqual(
-      bernoulli(big(30)),
-      math.divide(big('8615841276005'), big(14322)),
-      BEPSILON
-    )
-  })
-
-  it('should calculate Fraction values of the Bernoulli numbers', function () {
-    const frac = math.fraction
-    assert.deepStrictEqual(bernoulli(frac(1)), frac(-1, 2))
-    assert.deepStrictEqual(bernoulli(frac(7)), frac(0))
-    assert.deepStrictEqual(
-      bernoulli(frac(50)), frac(495057205241079648212477525n, 66n))
-    assert.deepStrictEqual(
-      bernoulli(68n),
-      frac(-78773130858718728141909149208474606244347001n, 30n))
-  })
-
-  it('should throw on illegal index values', function () {
-    assert.throws(() => bernoulli(-3), RangeError)
-    assert.throws(() => bernoulli(1.5), RangeError)
-    assert.throws(() => bernoulli(math.bignumber(6.28)), RangeError)
-    assert.throws(() => bernoulli(math.fraction(5, 3)), RangeError)
-    assert.throws(() => bernoulli(-2n), RangeError)
-  })
-})
diff --git a/tools/approx.js b/tools/approx.js
index 7deaf2775..e1a297739 100644
--- a/tools/approx.js
+++ b/tools/approx.js
@@ -35,25 +35,10 @@ export function approxEqual (a, b, epsilon) {
       assert.ok(Math.abs(a) < epsilon, (a + ' ~= ' + b))
     } else {
       const diff = Math.abs(a - b)
-      const max = Math.max(Math.abs(a), Math.abs(b))
+      const max = Math.max(a, b)
       const maxDiff = Math.abs(max * epsilon)
       assert.ok(diff <= maxDiff, (a + ' ~= ' + b + ' (epsilon: ' + epsilon + ')'))
     }
-  } else if (a && b && a.isBigNumber && b.isBigNumber) {
-    if (!a.equals(b)) {
-      if (a.isNaN()) assert.ok(b.isNaN())
-      else if (a.equals(0)) {
-        assert.ok(b.abs().lt(epsilon))
-      } else if (b.equals(0)) {
-        assert.ok(a.abs().lt(epsilon))
-      } else {
-        const diff = a.minus(b).abs()
-        let mx = a.abs()
-        if (mx.lt(b.abs())) mx = b.abs()
-        const maxDiff = mx.mul(epsilon)
-        assert.ok(diff.lt(maxDiff), `Diff ${diff} exceeds ${maxDiff}`)
-      }
-    }
   } else if (a && a.isBigNumber) {
     return approxEqual(a.toNumber(), b, epsilon)
   } else if (b && b.isBigNumber) {
diff --git a/types/index.d.ts b/types/index.d.ts
index f443b7192..4c4dd60d7 100644
--- a/types/index.d.ts
+++ b/types/index.d.ts
@@ -2496,14 +2496,6 @@ export interface MathJsInstance extends MathJsFactory {
    * Probability functions
    ************************************************************************/
 
-  /**
-   * Compute the nth Bernoulli number
-   * @param n  index
-   * @returns  nth Bernoulli number
-   */
-  bernoulli<T extends number | Fraction | BigNumber>(n: T): NoLiteralType<T>
-  bernoulli(n: bigint): Fraction
-
   /**
    * Compute the number of ways of picking k unordered outcomes from n
    * possibilities. Combinations only takes integer arguments. The
@@ -4127,7 +4119,6 @@ export const {
   ifftDependencies,
 
   // probability dependencies
-  bernoulliDependencies,
   combinationsDependencies,
   factorialDependencies,
   gammaDependencies,
@@ -6355,14 +6346,6 @@ export interface MathJsChain<TValue> {
    * Probability functions
    ************************************************************************/
 
-  /**
-   * Bernoulli number at this index
-   */
-  bernoulli<T extends number | BigNumber | Fraction>(
-    this: MathJsChain<T>
-  ): MathJsChain<NoLiteralType<T>>
-  bernoulli(this: MathJsChain<bigint>): MathJsChain<Fraction>
-
   /**
    * Compute the number of ways of picking k unordered outcomes from n
    * possibilities. Combinations only takes integer arguments. The
@@ -7656,7 +7639,6 @@ export const {
   ifft,
 
   // probability
-  bernoulli,
   combinations,
   factorial,
   gamma,
