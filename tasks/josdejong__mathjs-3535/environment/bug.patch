diff --git a/docs/datatypes/matrices.md b/docs/datatypes/matrices.md
index e9e360efb..b362a4ead 100644
--- a/docs/datatypes/matrices.md
+++ b/docs/datatypes/matrices.md
@@ -1,8 +1,8 @@
 # Matrices
 
-Math.js supports multidimensional matrices and arrays. Matrices can be
+Math.js supports multi dimensional matrices and arrays. Matrices can be
 created, manipulated, and used in calculations. Both regular JavaScript
-arrays and the matrix type implemented by math.js can be used
+arrays as well as the matrix type implemented by math.js can be used
 interchangeably in all relevant math.js functions. math.js supports both
 dense and sparse matrices.
 
@@ -11,7 +11,7 @@ dense and sparse matrices.
 
 Math.js supports two types of matrices:
 
-- `Array`, a regular JavaScript array. A multidimensional array can be created
+- `Array`, a regular JavaScript array. A multi dimensional array can be created
   by nesting arrays.
 - `Matrix`, a matrix implementation by math.js. A `Matrix` is an object wrapped
   around a regular JavaScript `Array`, providing utility functions for easy
@@ -22,12 +22,7 @@ function input: An `Array` as input will return an `Array`, a `Matrix` as input
 will return a `Matrix`. In case of mixed input, a `Matrix` is returned.
 For functions where the type of output cannot be determined from the
 input, the output is determined by the configuration option `matrix`,
-which can be a string `'Matrix'` (default) or `'Array'`. The function `size` is
-an exception: `size` always returns an `Array` containing numbers. Having a 
-consistent output type in this case is most practical since the size is often
-used in JavaScript loops where the code can only use a flat Array with numbers.
-This also makes the function `size` consistent with the matrix method 
-`matrix.size()`.
+which can be a string `'Matrix'` (default) or `'Array'`.
 
 ```js
 // create an array and a matrix
@@ -51,7 +46,7 @@ math.ones(2, 3)                               // Matrix, [[1, 1, 1], [1, 1, 1]]
 ## Creation
 
 A matrix can be created from an array using the function `math.matrix`. The
-provided array can contain nested arrays in order to create a multidimensional matrix. When called without arguments, an empty matrix will be
+provided array can contain nested arrays in order to create a multi-dimensional matrix. When called without arguments, an empty matrix will be
 created.
 
 ```js
@@ -179,7 +174,7 @@ Math.js uses geometric dimensions:
 
 - A scalar is zero-dimensional.
 - A vector is one-dimensional.
-- A matrix is two or multidimensional.
+- A matrix is two or multi-dimensional.
 
 The size of a matrix can be calculated with the function `size`. Function `size`
 returns a `Matrix` or `Array`, depending on the configuration option `matrix`.
@@ -211,7 +206,7 @@ math.size(c)                                  // Array, [2, 2, 3]
 ```
 
 Note that the dimensions themselves do not have a meaning attached. 
-When creating and printing a two-dimensional matrix, the first dimension is 
+When creating and printing a two dimensional matrix, the first dimension is 
 normally rendered as the _column_, and the second dimension is rendered as 
 the _row_. For example:
 
@@ -280,7 +275,7 @@ created using the function `index`. The way `subset` returns results depends on
 - If you use a scalar (single number) as an index for a dimension, that dimension is removed from the result.
 - If you use an array, matrix or range (even with just one element) as an index, that dimension is preserved in the result.
 
-This means that scalar indices eliminate dimensions, while array, matrix or range indices retain them. See the section [Migrate to v15](#migrate-indexing-behavior-to-mathjs-v15) for more details and examples of this behavior.
+This means that scalar indices eliminate dimensions, while array, matrix or range indices retain them. See the section [Migrate to v15](#migrate-to-v15) for more details and examples of this behavior.
 
 For example:
 
@@ -380,7 +375,7 @@ p.set([0, 1], 5)
 p.get([1, 0]) // 3
 ```
 
-When setting a value at a location outside the current matrix size using the
+When setting a value at a location outside of the current matrix size using the
 method `.set()`, the matrix will be resized. By default, new items will be 
 initialized with zero, but it is possible to specify an alternative value using
 the optional third argument `defaultValue`.
@@ -468,7 +463,7 @@ const cum = a.map(function (value, index, matrix) {
 console.log(cum.toString())  // [[0, 1], [3, 6], [10, 15]]
 ```
 
-### Iterating over multiple Matrices or Arrays
+### Iterating over multiple Matrixes or Arrays
 
 You can iterate over multiple matrices or arrays by using the `map` function. Mapping allows to perform element-wise operations on matrices by automatically adjusting their sizes to match each other.
 
@@ -503,11 +498,11 @@ At this moment `forEach` doesn't include the same functionality.
 
 ## Storage types
 
-Math.js supports both dense matrices and sparse matrices. Sparse matrices are efficient for matrices largely containing zeros. In that case they save a lot of memory, and calculations can be much faster than for dense matrices.
+Math.js supports both dense matrices as well as sparse matrices. Sparse matrices are efficient for matrices largely containing zeros. In that case they save a lot of memory, and calculations can be much faster than for dense matrices.
 
 Math.js supports two type of matrices:
 
-- Dense matrix (`'dense'`, `default`) A regular, dense matrix, supporting multidimensional matrices. This is the default matrix type.
+- Dense matrix (`'dense'`, `default`) A regular, dense matrix, supporting multi-dimensional matrices. This is the default matrix type.
 - Sparse matrix (`'sparse'`): A two dimensional sparse matrix implementation.
 
 The type of matrix can be selected when creating a matrix using the construction functions `matrix`, `diag`, `identity`, `ones`, and `zeros`.
diff --git a/src/expression/node/IndexNode.js b/src/expression/node/IndexNode.js
index 8dc207179..8cd0fa2d9 100644
--- a/src/expression/node/IndexNode.js
+++ b/src/expression/node/IndexNode.js
@@ -87,7 +87,7 @@ export const createIndexNode = /* #__PURE__ */ factory(name, dependencies, ({ No
                   typeOf(context))
             }
 
-            const s = size(context)
+            const s = size(context).valueOf()
             const childArgs = Object.create(args)
             childArgs.end = s[i]
 
diff --git a/src/function/logical/nullish.js b/src/function/logical/nullish.js
index cd3a7af52..30eabda02 100644
--- a/src/function/logical/nullish.js
+++ b/src/function/logical/nullish.js
@@ -57,8 +57,8 @@ export const createNullish = /* #__PURE__ */ factory(
 
         // SparseMatrix-first with collection RHS: enforce exact shape match
         'SparseMatrix, Array | Matrix': (x, y) => {
-          const sx = size(x)
-          const sy = size(y)
+          const sx = flatten(size(x).valueOf()) // work around #3529/#3530
+          const sy = flatten(size(y).valueOf())
           if (deepEqual(sx, sy)) return x
           throw new DimensionError(sx, sy)
         },
diff --git a/src/function/matrix/dot.js b/src/function/matrix/dot.js
index e04eca815..3f69ca575 100644
--- a/src/function/matrix/dot.js
+++ b/src/function/matrix/dot.js
@@ -34,8 +34,8 @@ export const createDot = /* #__PURE__ */ factory(name, dependencies, ({ typed, a
   })
 
   function _validateDim (x, y) {
-    const xSize = size(x)
-    const ySize = size(y)
+    const xSize = _size(x)
+    const ySize = _size(y)
     let xLen, yLen
 
     if (xSize.length === 1) {
@@ -70,8 +70,8 @@ export const createDot = /* #__PURE__ */ factory(name, dependencies, ({ typed, a
     const bdt = isMatrix(b) ? b._datatype || b.getDataType() : undefined
 
     // are these 2-dimensional column vectors? (as opposed to 1-dimensional vectors)
-    const aIsColumn = size(a).length === 2
-    const bIsColumn = size(b).length === 2
+    const aIsColumn = _size(a).length === 2
+    const bIsColumn = _size(b).length === 2
 
     let add = addScalar
     let mul = multiplyScalar
@@ -158,4 +158,9 @@ export const createDot = /* #__PURE__ */ factory(name, dependencies, ({ typed, a
 
     return c
   }
+
+  // TODO remove this once #1771 is fixed
+  function _size (x) {
+    return isMatrix(x) ? x.size() : size(x)
+  }
 })
diff --git a/src/function/matrix/size.js b/src/function/matrix/size.js
index 21067f0e0..221106b01 100644
--- a/src/function/matrix/size.js
+++ b/src/function/matrix/size.js
@@ -1,15 +1,13 @@
 import { arraySize } from '../../utils/array.js'
 import { factory } from '../../utils/factory.js'
+import { noMatrix } from '../../utils/noop.js'
 
 const name = 'size'
-const dependencies = ['typed']
+const dependencies = ['typed', 'config', '?matrix']
 
-export const createSize = /* #__PURE__ */ factory(name, dependencies, ({ typed }) => {
+export const createSize = /* #__PURE__ */ factory(name, dependencies, ({ typed, config, matrix }) => {
   /**
-   * Calculate the size of a matrix or scalar. Always returns an Array containing numbers.
-   *
-   * Note that in mathjs v14 and older, function size could return a Matrix depending on
-   * the input type and configuration.
+   * Calculate the size of a matrix or scalar.
    *
    * Syntax:
    *
@@ -29,16 +27,24 @@ export const createSize = /* #__PURE__ */ factory(name, dependencies, ({ typed }
    *     count, resize, squeeze, subset
    *
    * @param {boolean | number | Complex | Unit | string | Array | Matrix} x  A matrix
-   * @return {Array} A vector with size of `x`.
+   * @return {Array | Matrix} A vector with size of `x`.
    */
   return typed(name, {
-    Matrix: x => x.size(),
+    Matrix: function (x) {
+      return x.create(x.size(), 'number')
+    },
 
     Array: arraySize,
 
-    string: x => [x.length],
+    string: function (x) {
+      return (config.matrix === 'Array') ? [x.length] : matrix([x.length], 'dense', 'number')
+    },
 
-    // scalar
-    'number | Complex | BigNumber | Unit | boolean | null': _x => []
+    'number | Complex | BigNumber | Unit | boolean | null': function (x) {
+      // scalar
+      return (config.matrix === 'Array')
+        ? []
+        : matrix ? matrix([], 'dense', 'number') : noMatrix()
+    }
   })
 })
diff --git a/test/unit-tests/expression/parse.test.js b/test/unit-tests/expression/parse.test.js
index 309ad3512..2da13b055 100644
--- a/test/unit-tests/expression/parse.test.js
+++ b/test/unit-tests/expression/parse.test.js
@@ -792,7 +792,7 @@ describe('parse', function () {
     it('should get/set the matrix correctly for 3d matrices', function () {
       const scope = {}
       assert.deepStrictEqual(parseAndEval('f=[1,2;3,4]', scope), math.matrix([[1, 2], [3, 4]]))
-      assert.deepStrictEqual(parseAndEval('size(f)', scope), [2, 2])
+      assert.deepStrictEqual(parseAndEval('size(f)', scope), math.matrix([2, 2], 'dense', 'number'))
 
       parseAndEval('f[:,:,2]=[5,6;7,8]', scope)
       assert.deepStrictEqual(scope.f, math.matrix([
@@ -806,7 +806,7 @@ describe('parse', function () {
         ]
       ]))
 
-      assert.deepStrictEqual(parseAndEval('size(f)', scope), [2, 2, 2])
+      assert.deepStrictEqual(parseAndEval('size(f)', scope), math.matrix([2, 2, 2], 'dense', 'number'))
       assert.deepStrictEqual(parseAndEval('f[:,:,1]', scope), math.matrix([[1, 2], [3, 4]]))
       assert.deepStrictEqual(parseAndEval('f[:,:,2]', scope), math.matrix([[5, 6], [7, 8]]))
       assert.deepStrictEqual(parseAndEval('f[:,2,:]', scope), math.matrix([[2, 6], [4, 8]]))
@@ -853,11 +853,11 @@ describe('parse', function () {
       assert.deepStrictEqual(parseAndEval('d=1:3', scope), math.matrix([1, 2, 3]))
       assert.deepStrictEqual(parseAndEval('concat(d,d)', scope), math.matrix([1, 2, 3, 1, 2, 3]))
       assert.deepStrictEqual(parseAndEval('e=1+d', scope), math.matrix([2, 3, 4]))
-      assert.deepStrictEqual(parseAndEval('size(e)', scope), [3])
+      assert.deepStrictEqual(parseAndEval('size(e)', scope), math.matrix([3], 'dense', 'number'))
       assert.deepStrictEqual(parseAndEval('concat(e,e)', scope), math.matrix([2, 3, 4, 2, 3, 4]))
       assert.deepStrictEqual(parseAndEval('[[],[]]', scope), math.matrix([[], []]))
       assert.deepStrictEqual(parseAndEval('[[],[]]', scope).size(), [2, 0])
-      assert.deepStrictEqual(parseAndEval('size([[],[]])', scope), [2, 0])
+      assert.deepStrictEqual(parseAndEval('size([[],[]])', scope), math.matrix([2, 0], 'dense', 'number'))
     })
 
     it('should disable arrays as range in a matrix index', function () {
@@ -1993,7 +1993,7 @@ describe('parse', function () {
       assert.ok(parseAndEval('[1,2,3;4,5,6]\'') instanceof Matrix)
       assert.deepStrictEqual(parseAndEval('[1:5]'), math.matrix([[1, 2, 3, 4, 5]]))
       assert.deepStrictEqual(parseAndEval('[1:5]\''), math.matrix([[1], [2], [3], [4], [5]]))
-      assert.deepStrictEqual(parseAndEval('size([1:5])'), [1, 5])
+      assert.deepStrictEqual(parseAndEval('size([1:5])'), math.matrix([1, 5], 'dense', 'number'))
       assert.deepStrictEqual(parseAndEval('[1,2;3,4]\''), math.matrix([[1, 3], [2, 4]]))
     })
 
diff --git a/test/unit-tests/function/algebra/simplify.test.js b/test/unit-tests/function/algebra/simplify.test.js
index 6a34e0fc0..00fefdb42 100644
--- a/test/unit-tests/function/algebra/simplify.test.js
+++ b/test/unit-tests/function/algebra/simplify.test.js
@@ -158,7 +158,7 @@ describe('simplify', function () {
     simplifyAndCompare('foo("0xffff")', 'foo("0xffff")')
     simplifyAndCompare('"1234"', '"1234"')
     simplifyAndCompare('concat("a","b")', '"ab"')
-    simplifyAndCompare('matrix(size(concat("A","4/2")))', '[4]')
+    simplifyAndCompare('size(concat("A","4/2"))', '[4]')
     simplifyAndCompare('string(4/2)', '"2"')
     simplifyAndCompare('2+number("2")', '4')
   })
diff --git a/test/unit-tests/function/matrix/eigs.test.js b/test/unit-tests/function/matrix/eigs.test.js
index 03fc5b8b5..8d28045f2 100644
--- a/test/unit-tests/function/matrix/eigs.test.js
+++ b/test/unit-tests/function/matrix/eigs.test.js
@@ -33,10 +33,10 @@ describe('eigs', function () {
     const id2 = matrix([[1, 0], [0, 1]])
     const realSymMatrix = eigs(id2)
     assert(realSymMatrix.values instanceof Matrix)
-    assert.deepStrictEqual(size(realSymMatrix.values), [2])
+    assert.deepStrictEqual(size(realSymMatrix.values), matrix([2], 'dense', 'number'))
     testEigenvectors(realSymMatrix, vector => {
       assert(vector instanceof Matrix)
-      assert.deepStrictEqual(size(vector), [2])
+      assert.deepStrictEqual(size(vector), matrix([2], 'dense', 'number'))
     })
     // Check we get exact values in this trivial case with lower precision
     const rough = eigs(id2, { precision: 1e-6 })
@@ -44,10 +44,10 @@ describe('eigs', function () {
 
     const genericMatrix = eigs(matrix([[0, 1], [-1, 0]]))
     assert(genericMatrix.values instanceof Matrix)
-    assert.deepStrictEqual(size(genericMatrix.values), [2])
+    assert.deepStrictEqual(size(genericMatrix.values), matrix([2], 'dense', 'number'))
     testEigenvectors(genericMatrix, vector => {
       assert(vector instanceof Matrix)
-      assert.deepStrictEqual(size(vector), [2])
+      assert.deepStrictEqual(size(vector), matrix([2], 'dense', 'number'))
     })
   })
 
diff --git a/test/unit-tests/function/matrix/ones.test.js b/test/unit-tests/function/matrix/ones.test.js
index 3485a109c..9ef242518 100644
--- a/test/unit-tests/function/matrix/ones.test.js
+++ b/test/unit-tests/function/matrix/ones.test.js
@@ -4,7 +4,6 @@ import assert from 'assert'
 import math from '../../../../src/defaultInstance.js'
 const ones = math.ones
 const matrix = math.matrix
-const size = math.size
 
 describe('ones', function () {
   it('should create an empty matrix', function () {
@@ -66,12 +65,10 @@ describe('ones', function () {
 
   it('should create a matrix with ones with the same size as original matrix', function () {
     const a = matrix([[1, 2, 3], [4, 5, 6]])
-    assert.deepStrictEqual(ones(size(a)), [[1, 1, 1], [1, 1, 1]])
-    assert.deepStrictEqual(ones(matrix(size(a))), matrix([[1, 1, 1], [1, 1, 1]]))
-    assert.deepStrictEqual(ones(size(a), 'dense'), matrix([[1, 1, 1], [1, 1, 1]]))
+    assert.deepStrictEqual(ones(math.size(a)).size(), a.size())
   })
 
-  // TODO: test with invalid inputs
+  // TODO: test with invalid input
 
   it('should LaTeX ones', function () {
     const expression = math.parse('ones(2)')
diff --git a/test/unit-tests/function/matrix/size.test.js b/test/unit-tests/function/matrix/size.test.js
index a01f6eaef..9e2750321 100644
--- a/test/unit-tests/function/matrix/size.test.js
+++ b/test/unit-tests/function/matrix/size.test.js
@@ -21,27 +21,27 @@ describe('size', function () {
   })
 
   it('should calculate the size of a DenseMatrix', function () {
-    assert.deepStrictEqual(size(matrix()), [0])
-    assert.deepStrictEqual(size(matrix([[1, 2, 3], [4, 5, 6]])), [2, 3])
-    assert.deepStrictEqual(size(matrix([[], []])), [2, 0])
+    assert.deepStrictEqual(size(matrix()), matrix([0], 'dense', 'number'))
+    assert.deepStrictEqual(size(matrix([[1, 2, 3], [4, 5, 6]])), matrix([2, 3], 'dense', 'number'))
+    assert.deepStrictEqual(size(matrix([[], []])), matrix([2, 0], 'dense', 'number'))
   })
 
   it('should calculate the size of a SparseMatrix', function () {
-    assert.deepStrictEqual(size(matrix('sparse')), [0, 0])
-    assert.deepStrictEqual(size(matrix([[1, 2, 3], [4, 5, 6]], 'sparse')), [2, 3])
-    assert.deepStrictEqual(size(matrix([[], []], 'sparse')), [2, 0])
+    assert.deepStrictEqual(size(matrix('sparse')), matrix([0, 0], 'sparse', 'number'))
+    assert.deepStrictEqual(size(matrix([[1, 2, 3], [4, 5, 6]], 'sparse')), matrix([2, 3], 'sparse', 'number'))
+    assert.deepStrictEqual(size(matrix([[], []], 'sparse')), matrix([2, 0], 'sparse', 'number'))
   })
 
   it('should calculate the size of a range', function () {
-    assert.deepStrictEqual(size(math.range(2, 6)), [4])
+    assert.deepStrictEqual(size(math.range(2, 6)), matrix([4], 'dense', 'number'))
   })
 
   it('should calculate the size of a scalar', function () {
-    assert.deepStrictEqual(size(2), [])
-    assert.deepStrictEqual(size(math.bignumber(2)), [])
-    assert.deepStrictEqual(size(math.complex(2, 3)), [])
-    assert.deepStrictEqual(size(true), [])
-    assert.deepStrictEqual(size(null), [])
+    assert.deepStrictEqual(size(2), matrix([], 'dense', 'number'))
+    assert.deepStrictEqual(size(math.bignumber(2)), matrix([], 'dense', 'number'))
+    assert.deepStrictEqual(size(math.complex(2, 3)), matrix([], 'dense', 'number'))
+    assert.deepStrictEqual(size(true), matrix([], 'dense', 'number'))
+    assert.deepStrictEqual(size(null), matrix([], 'dense', 'number'))
   })
 
   it('should calculate the size of a scalar with setting matrix=="array"', function () {
@@ -53,8 +53,8 @@ describe('size', function () {
   })
 
   it('should calculate the size of a string', function () {
-    assert.deepStrictEqual(size('hello'), [5])
-    assert.deepStrictEqual(size(''), [0])
+    assert.deepStrictEqual(size('hello'), matrix([5], 'dense', 'number'))
+    assert.deepStrictEqual(size(''), matrix([0], 'dense', 'number'))
   })
 
   it('should throw an error if called with an invalid number of arguments', function () {
diff --git a/test/unit-tests/function/matrix/squeeze.test.js b/test/unit-tests/function/matrix/squeeze.test.js
index 2cb2976f4..1e091dad6 100644
--- a/test/unit-tests/function/matrix/squeeze.test.js
+++ b/test/unit-tests/function/matrix/squeeze.test.js
@@ -9,14 +9,14 @@ const matrix = math.matrix
 describe('squeeze', function () {
   it('should squeeze an matrix', function () {
     let m = math.ones(matrix([1, 3, 2]))
-    assert.deepStrictEqual(size(m), [1, 3, 2])
+    assert.deepStrictEqual(size(m), matrix([1, 3, 2], 'dense', 'number'))
     assert.deepStrictEqual(size(m.valueOf()), [1, 3, 2])
-    assert.deepStrictEqual(size(squeeze(m)), [3, 2])
+    assert.deepStrictEqual(size(squeeze(m)), matrix([3, 2], 'dense', 'number'))
 
     m = math.ones(matrix([1, 1, 3]))
-    assert.deepStrictEqual(size(m), [1, 1, 3])
-    assert.deepStrictEqual(size(squeeze(m)), [3])
-    assert.deepStrictEqual(size(squeeze(math.range(1, 6))), [5])
+    assert.deepStrictEqual(size(m), matrix([1, 1, 3], 'dense', 'number'))
+    assert.deepStrictEqual(size(squeeze(m)), matrix([3], 'dense', 'number'))
+    assert.deepStrictEqual(size(squeeze(math.range(1, 6))), matrix([5], 'dense', 'number'))
 
     assert.deepStrictEqual(squeeze(2.3), 2.3)
     assert.deepStrictEqual(squeeze(matrix([[5]])), 5)
diff --git a/test/unit-tests/function/matrix/zeros.test.js b/test/unit-tests/function/matrix/zeros.test.js
index d386c012b..bb3535fcb 100644
--- a/test/unit-tests/function/matrix/zeros.test.js
+++ b/test/unit-tests/function/matrix/zeros.test.js
@@ -4,7 +4,6 @@ import assert from 'assert'
 import math from '../../../../src/defaultInstance.js'
 const zeros = math.zeros
 const matrix = math.matrix
-const size = math.size
 
 describe('zeros', function () {
   it('should create an empty matrix', function () {
@@ -67,9 +66,7 @@ describe('zeros', function () {
 
   it('should create a matrix with zeros with the same size as original matrix', function () {
     const a = matrix([[1, 2, 3], [4, 5, 6]])
-    assert.deepStrictEqual(zeros(size(a)), [[0, 0, 0], [0, 0, 0]])
-    assert.deepStrictEqual(zeros(matrix(size(a))), matrix([[0, 0, 0], [0, 0, 0]]))
-    assert.deepStrictEqual(zeros(size(a), 'dense'), matrix([[0, 0, 0], [0, 0, 0]]))
+    assert.deepStrictEqual(zeros(math.size(a)).size(), a.size())
   })
 
   // TODO: test with invalid input
diff --git a/test/unit-tests/type/chain/Chain.test.js b/test/unit-tests/type/chain/Chain.test.js
index 3048a0871..b1cb7a69f 100644
--- a/test/unit-tests/type/chain/Chain.test.js
+++ b/test/unit-tests/type/chain/Chain.test.js
@@ -85,7 +85,7 @@ describe('Chain', function () {
   })
 
   it('should not break with null or true as value', function () {
-    assert.deepStrictEqual(new Chain(null).size().done(), [])
+    assert.deepStrictEqual(new Chain(null).size().done(), math.matrix([], 'dense', 'number'))
     assert.strictEqual(new Chain(true).add(1).done(), 2)
   })
 
diff --git a/test/unit-tests/type/matrix/function/matrix.test.js b/test/unit-tests/type/matrix/function/matrix.test.js
index 7b335f1f8..527752083 100644
--- a/test/unit-tests/type/matrix/function/matrix.test.js
+++ b/test/unit-tests/type/matrix/function/matrix.test.js
@@ -8,19 +8,19 @@ describe('matrix', function () {
   it('should create an empty matrix with one dimension if called without argument', function () {
     const a = matrix()
     assert.ok(a instanceof math.Matrix)
-    assert.deepStrictEqual(math.size(a), [0]) // TODO: wouldn't it be nicer if an empty matrix has zero dimensions?
+    assert.deepStrictEqual(math.size(a), matrix([0], 'dense', 'number')) // TODO: wouldn't it be nicer if an empty matrix has zero dimensions?
   })
 
   it('should create empty matrix, dense format', function () {
     const a = matrix('dense')
     assert.ok(a instanceof math.Matrix)
-    assert.deepStrictEqual(math.size(a), [0])
+    assert.deepStrictEqual(math.size(a), matrix([0], 'dense', 'number'))
   })
 
   it('should create empty matrix, dense format, number datatype', function () {
     const a = matrix('dense', 'number')
     assert.ok(a instanceof math.Matrix)
-    assert.deepStrictEqual(math.size(a), [0])
+    assert.deepStrictEqual(math.size(a), matrix([0], 'dense', 'number'))
     assert(a.datatype(), 'number')
   })
 
@@ -33,7 +33,7 @@ describe('matrix', function () {
     const b = matrix([[1, 2], [3, 4]])
     assert.ok(b instanceof math.Matrix)
     assert.deepStrictEqual(b, matrix([[1, 2], [3, 4]]))
-    assert.deepStrictEqual(math.size(b), [2, 2])
+    assert.deepStrictEqual(math.size(b), matrix([2, 2], 'dense', 'number'))
   })
 
   it('should be the identity if called with a matrix, dense format', function () {
@@ -41,7 +41,7 @@ describe('matrix', function () {
     const c = matrix(b, 'dense')
     assert.ok(c._data !== b._data) // data should be cloned
     assert.deepStrictEqual(c, matrix([[1, 2], [3, 4]], 'dense'))
-    assert.deepStrictEqual(math.size(c), [2, 2])
+    assert.deepStrictEqual(math.size(c), matrix([2, 2], 'dense', 'number'))
   })
 
   it('should be the identity if called with a matrix, dense format, number datatype', function () {
@@ -73,7 +73,7 @@ describe('matrix', function () {
     const d = matrix(math.range(1, 6))
     assert.ok(d instanceof math.Matrix)
     assert.deepStrictEqual(d, matrix([1, 2, 3, 4, 5]))
-    assert.deepStrictEqual(math.size(d), [5])
+    assert.deepStrictEqual(math.size(d), matrix([5], 'dense', 'number'))
   })
 
   it('should throw an error if called with an invalid argument', function () {
