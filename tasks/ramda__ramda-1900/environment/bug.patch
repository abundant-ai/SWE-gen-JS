diff --git a/src/ap.js b/src/ap.js
index 3b10e512..e85dd788 100644
--- a/src/ap.js
+++ b/src/ap.js
@@ -16,24 +16,22 @@ var map = require('./map');
  * @category Function
  * @sig [a -> b] -> [a] -> [b]
  * @sig Apply f => f (a -> b) -> f a -> f b
- * @param {*} applyF
- * @param {*} applyX
- * @return {*}
+ * @param {Array} fns An array of functions
+ * @param {Array} vs An array of values
+ * @return {Array} An array of results of applying each of `fns` to all of `vs` in turn.
  * @example
  *
  *      R.ap([R.multiply(2), R.add(3)], [1,2,3]); //=> [2, 4, 6, 4, 5, 6]
  *      R.ap([R.concat('tasty '), R.toUpper], ['pizza', 'salad']); //=> ["tasty pizza", "tasty salad", "PIZZA", "SALAD"]
  * @symb R.ap([f, g], [a, b]) = [f(a), f(b), g(a), g(b)]
  */
-module.exports = _curry2(function ap(applyF, applyX) {
+module.exports = _curry2(function ap(applicative, fn) {
   return (
-    typeof applyX['fantasy-land/ap'] === 'function' ?
-      applyX['fantasy-land/ap'](applyF) :
-    typeof applyF.ap === 'function' ?
-      applyF.ap(applyX) :
-    typeof applyF === 'function' ?
-      function(x) { return applyF(x)(applyX(x)); } :
+    typeof applicative.ap === 'function' ?
+      applicative.ap(fn) :
+    typeof applicative === 'function' ?
+      function(x) { return applicative(x)(fn(x)); } :
     // else
-      _reduce(function(acc, f) { return _concat(acc, map(f, applyX)); }, [], applyF)
+      _reduce(function(acc, f) { return _concat(acc, map(f, fn)); }, [], applicative)
   );
 });
diff --git a/src/chain.js b/src/chain.js
index 2cbfec29..24395c5a 100644
--- a/src/chain.js
+++ b/src/chain.js
@@ -27,7 +27,7 @@ var map = require('./map');
  *
  *      R.chain(R.append, R.head)([1, 2, 3]); //=> [1, 2, 3, 1]
  */
-module.exports = _curry2(_dispatchable(['fantasy-land/chain', 'chain'], _xchain, function chain(fn, monad) {
+module.exports = _curry2(_dispatchable(['chain'], _xchain, function chain(fn, monad) {
   if (typeof monad === 'function') {
     return function(x) { return fn(monad(x))(x); };
   }
diff --git a/src/concat.js b/src/concat.js
index 0d294315..5972c1bd 100644
--- a/src/concat.js
+++ b/src/concat.js
@@ -1,7 +1,6 @@
 var _curry2 = require('./internal/_curry2');
 var _isArray = require('./internal/_isArray');
 var _isFunction = require('./internal/_isFunction');
-var _isString = require('./internal/_isString');
 var toString = require('./toString');
 
 
@@ -31,23 +30,11 @@ var toString = require('./toString');
  *      R.concat('ABC', 'DEF'); // 'ABCDEF'
  */
 module.exports = _curry2(function concat(a, b) {
-  if (_isArray(a)) {
-    if (_isArray(b)) {
-      return a.concat(b);
-    }
-    throw new TypeError(toString(b) + ' is not an array');
-  }
-  if (_isString(a)) {
-    if (_isString(b)) {
-      return a + b;
-    }
-    throw new TypeError(toString(b) + ' is not a string');
+  if (a == null || !_isFunction(a.concat)) {
+    throw new TypeError(toString(a) + ' does not have a method named "concat"');
   }
-  if (a != null && _isFunction(a['fantasy-land/concat'])) {
-    return a['fantasy-land/concat'](b);
-  }
-  if (a != null && _isFunction(a.concat)) {
-    return a.concat(b);
+  if (_isArray(a) && !_isArray(b)) {
+    throw new TypeError(toString(b) + ' is not an array');
   }
-  throw new TypeError(toString(a) + ' does not have a method named "concat" or "fantasy-land/concat"');
+  return a.concat(b);
 });
diff --git a/src/empty.js b/src/empty.js
index 4251f231..4ba6af76 100644
--- a/src/empty.js
+++ b/src/empty.js
@@ -29,10 +29,6 @@ var _isString = require('./internal/_isString');
  */
 module.exports = _curry1(function empty(x) {
   return (
-    (x != null && typeof x['fantasy-land/empty'] === 'function') ?
-      x['fantasy-land/empty']() :
-    (x != null && x.constructor != null && typeof x.constructor['fantasy-land/empty'] === 'function') ?
-      x.constructor['fantasy-land/empty']() :
     (x != null && typeof x.empty === 'function') ?
       x.empty() :
     (x != null && x.constructor != null && typeof x.constructor.empty === 'function') ?
diff --git a/src/internal/_equals.js b/src/internal/_equals.js
index 040623c8..6bdb54fc 100644
--- a/src/internal/_equals.js
+++ b/src/internal/_equals.js
@@ -19,11 +19,6 @@ module.exports = function _equals(a, b, stackA, stackB) {
     return false;
   }
 
-  if (typeof a['fantasy-land/equals'] === 'function' || typeof b['fantasy-land/equals'] === 'function') {
-    return typeof a['fantasy-land/equals'] === 'function' && a['fantasy-land/equals'](b) &&
-           typeof b['fantasy-land/equals'] === 'function' && b['fantasy-land/equals'](a);
-  }
-
   if (typeof a.equals === 'function' || typeof b.equals === 'function') {
     return typeof a.equals === 'function' && a.equals(b) &&
            typeof b.equals === 'function' && b.equals(a);
diff --git a/src/internal/_reduce.js b/src/internal/_reduce.js
index 43d21f12..ec42783f 100644
--- a/src/internal/_reduce.js
+++ b/src/internal/_reduce.js
@@ -31,8 +31,8 @@ module.exports = (function() {
     return xf['@@transducer/result'](acc);
   }
 
-  function _methodReduce(xf, acc, obj, methodName) {
-    return xf['@@transducer/result'](obj[methodName](bind(xf['@@transducer/step'], xf), acc));
+  function _methodReduce(xf, acc, obj) {
+    return xf['@@transducer/result'](obj.reduce(bind(xf['@@transducer/step'], xf), acc));
   }
 
   var symIterator = (typeof Symbol !== 'undefined') ? Symbol.iterator : '@@iterator';
@@ -43,11 +43,8 @@ module.exports = (function() {
     if (isArrayLike(list)) {
       return _arrayReduce(fn, acc, list);
     }
-    if (typeof list['fantasy-land/reduce'] === 'function') {
-      return _methodReduce(fn, acc, list, 'fantasy-land/reduce');
-    }
     if (typeof list.reduce === 'function') {
-      return _methodReduce(fn, acc, list, 'reduce');
+      return _methodReduce(fn, acc, list);
     }
     if (list[symIterator] != null) {
       return _iterableReduce(fn, acc, list[symIterator]());
diff --git a/src/map.js b/src/map.js
index 29442bd3..d231ffae 100644
--- a/src/map.js
+++ b/src/map.js
@@ -42,7 +42,7 @@ var keys = require('./keys');
  * @symb R.map(f, { x: a, y: b }) = { x: f(a), y: f(b) }
  * @symb R.map(f, functor_o) = functor_o.map(f)
  */
-module.exports = _curry2(_dispatchable(['fantasy-land/map', 'map'], _xmap, function map(fn, functor) {
+module.exports = _curry2(_dispatchable(['map'], _xmap, function map(fn, functor) {
   switch (Object.prototype.toString.call(functor)) {
     case '[object Function]':
       return curryN(functor.length, function() {
diff --git a/src/traverse.js b/src/traverse.js
index 9ab6c740..bb3b1507 100644
--- a/src/traverse.js
+++ b/src/traverse.js
@@ -30,7 +30,5 @@ var sequence = require('./sequence');
  *      R.traverse(Maybe.of, safeDiv(10), [2, 0, 5]); //=> Nothing
  */
 module.exports = _curry3(function traverse(of, f, traversable) {
-  return typeof traversable['fantasy-land/traverse'] === 'function' ?
-    traversable['fantasy-land/traverse'](f, of) :
-    sequence(of, map(f, traversable));
+  return sequence(of, map(f, traversable));
 });
diff --git a/src/view.js b/src/view.js
index fc020e90..91f98f64 100644
--- a/src/view.js
+++ b/src/view.js
@@ -25,7 +25,7 @@ var _curry2 = require('./internal/_curry2');
 module.exports = (function() {
   // `Const` is a functor that effectively ignores the function given to `map`.
   var Const = function(x) {
-    return {value: x, 'fantasy-land/map': function() { return this; }};
+    return {value: x, map: function() { return this; }};
   };
 
   return _curry2(function view(lens, x) {
diff --git a/test/lift.js b/test/lift.js
index cf67d54a..f9c48e24 100644
--- a/test/lift.js
+++ b/test/lift.js
@@ -39,7 +39,7 @@ describe('lift', function() {
 
   it('works with other functors such as "Maybe"', function() {
     var addM = R.lift(R.add);
-    eq(addM(Maybe.Just(3), Maybe.Just(5)), Maybe.Just(8));
+    eq(addM(Maybe.of(3), Maybe.of(5)), Maybe.of(8));
   });
 
 });
diff --git a/test/liftN.js b/test/liftN.js
index f896e8c5..68c8f5ff 100644
--- a/test/liftN.js
+++ b/test/liftN.js
@@ -41,7 +41,7 @@ describe('liftN', function() {
 
   it('works with other functors such as "Maybe"', function() {
     var addM = R.liftN(2, R.add);
-    eq(addM(Maybe.Just(3), Maybe.Just(5)), Maybe.Just(8));
+    eq(addM(Maybe(3), Maybe(5)), Maybe(8));
   });
 
   it('interprets [a] as a functor', function() {
diff --git a/test/shared/Id.js b/test/shared/Id.js
index 2718882c..fa0279be 100644
--- a/test/shared/Id.js
+++ b/test/shared/Id.js
@@ -1,23 +1,28 @@
-var concat = require('../../src/concat');
-var equals = require('../../src/equals');
-var map = require('../../src/map');
-var toString = require('../../src/toString');
+var R = require('../..');
 
 
-//  Id :: a -> Id a
-module.exports = function Id(value) {
-  return {
-    '@@type': 'ramda/Id',
-    'fantasy-land/equals': function(other) { return other != null && other['@@type'] === this['@@type'] && equals(other.value, value); },
-    'fantasy-land/concat': function(id) { return Id(concat(value, id.value)); },
-    'fantasy-land/map': function(f) { return Id(f(value)); },
-    'fantasy-land/ap': function(id) { return Id(id.value(value)); },
-    'fantasy-land/chain': function(f) { return f(value); },
-    'fantasy-land/reduce': function(f, x) { return f(x, value); },
-    'fantasy-land/traverse': function(f, of) { return map(Id, f(value)); },
-    sequence: function(of) { return map(Id, this.value); },
-    constructor: {'fantasy-land/of': Id},
-    toString: function() { return 'Id(' + toString(value) + ')'; },
-    value: value
-  };
+function Id(x) {
+  if (!(this instanceof Id)) {
+    return new Id(x);
+  }
+  this.value = x;
+}
+
+Id.prototype.ap = function(id) {
+  return Id(this.value(id.value));
+};
+
+Id.prototype.map = function(f) {
+  return Id(f(this.value));
+};
+
+Id.prototype.sequence = function(of) {
+  void of;
+  return this.value.map(Id);
+};
+
+Id.prototype.toString = function() {
+  return 'Id(' + R.toString(this.value) + ')';
 };
+
+module.exports = Id;
diff --git a/test/shared/Maybe.js b/test/shared/Maybe.js
index 1c8067c1..dda1619a 100644
--- a/test/shared/Maybe.js
+++ b/test/shared/Maybe.js
@@ -1,60 +1,87 @@
-var equals = require('../../src/equals');
-var toString = require('../../src/toString');
+var util = require('./internal/util.js');
 
+function Maybe(x) {
+  return x == null ? _nothing : Maybe.Just(x);
+}
 
-var sentinel = {};
+function _Just(x) {
+  this.value = x;
+}
+util.extend(_Just, Maybe);
 
-var Maybe = module.exports = function(x, box) {
-  if (x !== sentinel) {
-    throw new Error('Cannot instantiate Maybe');
-  }
-  var isJust = box.length > 0;
-  if (isJust) {
-    this.value = box[0];
-  }
-  this.isNothing = !isJust;
-  this.isJust = isJust;
+function _Nothing() {}
+util.extend(_Nothing, Maybe);
+
+var _nothing = new _Nothing();
+
+Maybe.Nothing = function() {
+  return _nothing;
 };
 
-//  Nothing :: Maybe a
-var Nothing = Maybe.Nothing = new Maybe(sentinel, []);
+Maybe.Just = function(x) {
+  return new _Just(x);
+};
 
-//  Just :: a -> Maybe a
-var Just = Maybe.Just = function(value) { return new Maybe(sentinel, [value]); };
+Maybe.of = Maybe.Just;
 
-//  Maybe.of :: a -> Maybe a
-Maybe['fantasy-land/of'] = Just;
+Maybe.prototype.of = Maybe.Just;
 
-//  Maybe#@@type :: String
-Maybe.prototype['@@type'] = 'ramda/Maybe';
 
-//  Maybe#equals :: Maybe a ~> Maybe a -> Boolean
-Maybe.prototype['fantasy-land/equals'] = function(other) {
-  return other != null && other['@@type'] === this['@@type'] &&
-         this.isJust ? other.isJust && equals(other.value, this.value) : other.isNothing;
+_Just.prototype.toString = function() {
+  return 'Just(' + this.value + ')';
 };
 
-//  Maybe#map :: Maybe a ~> (a -> b) -> Maybe b
-Maybe.prototype['fantasy-land/map'] = function(f) {
-  return this.isJust ? Just(f(this.value)) : Nothing;
+_Nothing.prototype.toString = function() {
+  return 'Nothing()';
 };
 
-//  Maybe#ap :: Maybe a ~> Maybe (a -> b) -> Maybe b
-Maybe.prototype['fantasy-land/ap'] = function(maybe) {
-  return this.isJust && maybe.isJust ? Just(maybe.value(this.value)) : Nothing;
+
+// functor
+_Just.prototype.map = function(f) {
+  return this.of(f(this.value));
 };
 
-//  Maybe#chain :: Maybe a ~> (a -> Maybe b) -> Maybe b
-Maybe.prototype['fantasy-land/chain'] = function(f) {
-  return this.isJust ? f(this.value) : Nothing;
+_Nothing.prototype.map = util.returnThis;
+
+// apply
+// takes a Maybe that wraps a function (`app`) and applies its `map`
+// method to this Maybe's value, which must be a function.
+_Just.prototype.ap = function(m) {
+  return m.map(this.value);
 };
 
-//  Maybe#filter :: Maybe a ~> (a -> Boolean) -> Maybe a
-Maybe.prototype.filter = function(pred) {
-  return this.isJust && pred(this.value) ? this : Nothing;
+_Nothing.prototype.ap = util.identity;
+
+// applicative
+// `of` inherited from `Maybe`
+
+
+// chain
+//  f must be a function which returns a value
+//  f must return a value of the same Chain
+//  chain must return a value of the same Chain
+_Just.prototype.chain = util.baseMap;
+
+_Nothing.prototype.chain = util.returnThis;
+
+
+//
+_Just.prototype.datatype = _Just;
+
+_Nothing.prototype.datatype = _Nothing;
+
+// monad
+// A value that implements the Monad specification must also implement the Applicative and Chain specifications.
+// see above.
+
+// equality method to enable testing
+_Just.prototype.equals = function(that) {
+  return that instanceof _Just && this.value === that.value;
 };
 
-//  Maybe#toString :: Maybe a ~> String
-Maybe.prototype.toString = function() {
-  return this.isJust ? 'Just(' + toString(this.value) + ')' : 'Nothing';
+_Nothing.prototype.equals = function(that) {
+  return that === _nothing;
 };
+
+
+module.exports = Maybe;
diff --git a/test/shared/internal/util.js b/test/shared/internal/util.js
new file mode 100644
index 00000000..c057e821
--- /dev/null
+++ b/test/shared/internal/util.js
@@ -0,0 +1,32 @@
+module.exports = {
+
+  baseMap: function(f) {
+    return f(this.value);
+  },
+
+  extend: function(Child, Parent) {
+    function Ctor() {
+      this.constructor = Child;
+    }
+    Ctor.prototype = Parent.prototype;
+    Child.prototype = new Ctor();
+    Child.super_ = Parent.prototype;
+  },
+
+  identity: function(x) { return x; },
+
+  notImplemented: function(str) {
+    return function() {
+      throw new Error(str + ' is not implemented');
+    };
+  },
+
+  notCallable: function(fn) {
+    return function() {
+      throw new Error(fn + ' cannot be called directly');
+    };
+  },
+
+  returnThis: function() { return this; }
+
+};
diff --git a/test/unnest.js b/test/unnest.js
index 9f197e71..1aeed3ad 100644
--- a/test/unnest.js
+++ b/test/unnest.js
@@ -34,9 +34,9 @@ describe('unnest', function() {
     var Nothing = Maybe.Nothing;
     var Just = Maybe.Just;
 
-    eq(R.unnest(Nothing), Nothing);
-    eq(R.unnest(Just(Nothing)), Nothing);
-    eq(R.unnest(Just(Just(Nothing))), Just(Nothing));
+    eq(R.unnest(Nothing()), Nothing());
+    eq(R.unnest(Just(Nothing())), Nothing());
+    eq(R.unnest(Just(Just(Nothing()))), Just(Nothing()));
     eq(R.unnest(Just(Just(42))), Just(42));
     eq(R.unnest(Just(Just(Just(42)))), Just(Just(42)));
   });
