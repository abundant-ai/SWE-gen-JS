diff --git a/changelog_unreleased/typescript/16458.md b/changelog_unreleased/typescript/16458.md
new file mode 100644
index 000000000..ed889ee99
--- /dev/null
+++ b/changelog_unreleased/typescript/16458.md
@@ -0,0 +1,18 @@
+#### Add parentheses for decorator expressions (#16458 by @y-schneider)
+
+Prevent parentheses around member expressions or tagged template literals from being removed to follow the stricter parsing rules of TypeScript 5.5.
+
+<!-- prettier-ignore -->
+```ts
+// Input
+@(foo`tagged template`)
+class X {}
+
+// Prettier stable
+@foo`tagged template`
+class X {}
+
+// Prettier main
+@(foo`tagged template`)
+class X {}
+```
diff --git a/cspell.json b/cspell.json
index 8f2942f1e..ca070d1a5 100644
--- a/cspell.json
+++ b/cspell.json
@@ -292,6 +292,7 @@
         "unaries",
         "uncook",
         "unparenthesised",
+        "Unparenthesized",
         "Unrestrict",
         "upvoted",
         "upvotes",
diff --git a/src/language-js/needs-parens.js b/src/language-js/needs-parens.js
index 4b8c2ac4c..e279b150d 100644
--- a/src/language-js/needs-parens.js
+++ b/src/language-js/needs-parens.js
@@ -224,40 +224,10 @@ function needsParens(path, options) {
       );
 
     case "Decorator":
-      if (key === "expression") {
-        if (isMemberExpression(node) && node.computed) {
-          return true;
-        }
-
-        let hasCallExpression = false;
-        let hasMemberExpression = false;
-        let current = node;
-        while (current) {
-          switch (current.type) {
-            case "MemberExpression":
-              hasMemberExpression = true;
-              current = current.object;
-              break;
-            case "CallExpression":
-              if (
-                /** @(x().y) */ hasMemberExpression ||
-                /** @(x().y()) */ hasCallExpression
-              ) {
-                return options.parser !== "typescript";
-              }
-              hasCallExpression = true;
-              current = current.callee;
-              break;
-            case "Identifier":
-              return false;
-            case "TaggedTemplateExpression":
-              // babel-parser cannot parse
-              //   @foo`bar`
-              return options.parser !== "typescript";
-            default:
-              return true;
-          }
-        }
+      if (
+        key === "expression" &&
+        !canDecoratorExpressionUnparenthesized(node)
+      ) {
         return true;
       }
       break;
@@ -1258,4 +1228,36 @@ function shouldAddParenthesesToChainElement(path) {
   return false;
 }
 
+function isDecoratorMemberExpression(node) {
+  if (node.type === "Identifier") {
+    return true;
+  }
+
+  if (isMemberExpression(node)) {
+    return (
+      !node.computed &&
+      !node.optional &&
+      node.property.type === "Identifier" &&
+      isDecoratorMemberExpression(node.object)
+    );
+  }
+
+  return false;
+}
+
+// Based on babel implementation
+// https://github.com/nicolo-ribaudo/babel/blob/c4b88a4e5005364255f7e964fe324cf7bfdfb019/packages/babel-generator/src/node/index.ts#L111
+function canDecoratorExpressionUnparenthesized(node) {
+  if (node.type === "ChainExpression") {
+    node = node.expression;
+  }
+
+  return (
+    isDecoratorMemberExpression(node) ||
+    (isCallExpression(node) &&
+      !node.optional &&
+      isDecoratorMemberExpression(node.callee))
+  );
+}
+
 export default needsParens;
