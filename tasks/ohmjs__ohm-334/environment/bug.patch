diff --git a/CHANGELOG.md b/CHANGELOG.md
index 597597c2..a34fc57b 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,9 +1,5 @@
 # Changelog
 
-## Next
-
-- [] Add `experimentalApplySyntactic`, an experimental built-in rule to allow application of a syntactic rule from a lexical context (see #136 for details).
-
 ## v16.0.0 - Oct 1, 2021
 
 Ohm v16 is primarily about improving the experience of [using Ohm with TypeScript][using-ohm-with-typescript]. In order to do that, we needed to make some minor breaking changes. With the major version change, we also took the opportunity to clean up and simplify some parts of the API.
diff --git a/doc/releases/ohm-js-16.0.md b/doc/releases/ohm-js-16.0.md
index ea60cb46..4252f281 100644
--- a/doc/releases/ohm-js-16.0.md
+++ b/doc/releases/ohm-js-16.0.md
@@ -3,13 +3,11 @@
 ## Upgrading
 
 ### Args to _\_iter_ and _\_nonterminal_ actions
-
 <!-- https://git.io/Jz4CI -->
 
 The [`_iter` and `_nonterminal` actions](../api-reference.md#special-actions) now take a variable number of arguments, rather than a single `Node[]` argument containing the child nodes. To make existing code work with Ohm v16, you should change the parameter to a [rest parameter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters) — e.g., `_iter(children) { ... }` should be changed to `_iter(...children) { ... }`. You can easily find code that needs to change because `addOperation` and friends will now throw an exception if your actions have a single parameter which is _not_ a rest parameter. See [#324](https://github.com/harc/ohm/issues/324) for the reasons behind this change.
 
 ### Default semantic actions
-
 <!-- https://git.io/JRwtG -->
 
 In operations and attributes, if you haven't defined a semantic action for a particular rule application node, a default action will be used in some cases. For example, your grammar has an _AddExp_ rule but your action dictionary doesn't contain a semantic action named 'AddExp'. **In Ohm v16.0, there is no longer a default action for iteration nodes** — it is _only_ defined for non-terminal nodes with exactly one child. See [#309](https://github.com/harc/ohm/issues/309) for context on this change.
@@ -25,7 +23,6 @@ _iter(...children) {
 ```
 
 ### grammarFromScriptElement / grammarsFromScriptElements
-
 <!-- https://git.io/Jwow5 -->
 
 The functions `grammarFromScriptElement` and `grammarsFromScriptElements` have been removed. When using Ohm in the browser, it's now recommended to put your grammar in a [template literal with String.raw](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/raw):
diff --git a/doc/syntax-reference.md b/doc/syntax-reference.md
index da675aa1..228d15bf 100644
--- a/doc/syntax-reference.md
+++ b/doc/syntax-reference.md
@@ -241,8 +241,6 @@ AddExp_plus = AddExp "+" MulExp
 
 <h3 id="syntactic-lexical">Syntactic vs. Lexical Rules</h3>
 
-<!-- https://git.io/JiYgP -->
-
 A _syntactic rule_ is a rule whose name begins with an uppercase letter, and _lexical rule_ is one whose name begins with a lowercase letter. The difference between lexical and syntactic rules is that syntactic rules implicitly skip whitespace characters.
 
 For the purposes of a syntactic rule, a "whitespace character" is anything that matches its enclosing grammar's "space" rule. The default implementation of "space" matches ' ', '\t', '\n', '\r', and any other character that is considered whitespace in the [ES5 spec](http://ecma-international.org/ecma-262/5.1/#sec-7.2).
diff --git a/packages/ohm-js/dist/built-in-rules.js b/packages/ohm-js/dist/built-in-rules.js
index 004c1de9..71ac9c66 100644
--- a/packages/ohm-js/dist/built-in-rules.js
+++ b/packages/ohm-js/dist/built-in-rules.js
@@ -1,2 +1,2 @@
 var ohm = require('..');
-module.exports = ohm.makeRecipe(["grammar",{"source":"BuiltInRules {\n\n  alnum  (an alpha-numeric character)\n    = letter\n    | digit\n\n  letter  (a letter)\n    = lower\n    | upper\n    | unicodeLtmo\n\n  digit  (a digit)\n    = \"0\"..\"9\"\n\n  hexDigit  (a hexadecimal digit)\n    = digit\n    | \"a\"..\"f\"\n    | \"A\"..\"F\"\n\n  ListOf<elem, sep>\n    = NonemptyListOf<elem, sep>\n    | EmptyListOf<elem, sep>\n\n  NonemptyListOf<elem, sep>\n    = elem (sep elem)*\n\n  EmptyListOf<elem, sep>\n    = /* nothing */\n\n  listOf<elem, sep>\n    = nonemptyListOf<elem, sep>\n    | emptyListOf<elem, sep>\n\n  nonemptyListOf<elem, sep>\n    = elem (sep elem)*\n\n  emptyListOf<elem, sep>\n    = /* nothing */\n\n  // Allows a syntactic rule application within a lexical context.\n  experimentalApplySyntactic<app> = app\n}"},"BuiltInRules",null,null,{"alnum":["define",{"sourceInterval":[18,78]},"an alpha-numeric character",[],["alt",{"sourceInterval":[60,78]},["app",{"sourceInterval":[60,66]},"letter",[]],["app",{"sourceInterval":[73,78]},"digit",[]]]],"letter":["define",{"sourceInterval":[82,142]},"a letter",[],["alt",{"sourceInterval":[107,142]},["app",{"sourceInterval":[107,112]},"lower",[]],["app",{"sourceInterval":[119,124]},"upper",[]],["app",{"sourceInterval":[131,142]},"unicodeLtmo",[]]]],"digit":["define",{"sourceInterval":[146,177]},"a digit",[],["range",{"sourceInterval":[169,177]},"0","9"]],"hexDigit":["define",{"sourceInterval":[181,254]},"a hexadecimal digit",[],["alt",{"sourceInterval":[219,254]},["app",{"sourceInterval":[219,224]},"digit",[]],["range",{"sourceInterval":[231,239]},"a","f"],["range",{"sourceInterval":[246,254]},"A","F"]]],"ListOf":["define",{"sourceInterval":[258,336]},null,["elem","sep"],["alt",{"sourceInterval":[282,336]},["app",{"sourceInterval":[282,307]},"NonemptyListOf",[["param",{"sourceInterval":[297,301]},0],["param",{"sourceInterval":[303,306]},1]]],["app",{"sourceInterval":[314,336]},"EmptyListOf",[["param",{"sourceInterval":[326,330]},0],["param",{"sourceInterval":[332,335]},1]]]]],"NonemptyListOf":["define",{"sourceInterval":[340,388]},null,["elem","sep"],["seq",{"sourceInterval":[372,388]},["param",{"sourceInterval":[372,376]},0],["star",{"sourceInterval":[377,388]},["seq",{"sourceInterval":[378,386]},["param",{"sourceInterval":[378,381]},1],["param",{"sourceInterval":[382,386]},0]]]]],"EmptyListOf":["define",{"sourceInterval":[392,434]},null,["elem","sep"],["seq",{"sourceInterval":[438,438]}]],"listOf":["define",{"sourceInterval":[438,516]},null,["elem","sep"],["alt",{"sourceInterval":[462,516]},["app",{"sourceInterval":[462,487]},"nonemptyListOf",[["param",{"sourceInterval":[477,481]},0],["param",{"sourceInterval":[483,486]},1]]],["app",{"sourceInterval":[494,516]},"emptyListOf",[["param",{"sourceInterval":[506,510]},0],["param",{"sourceInterval":[512,515]},1]]]]],"nonemptyListOf":["define",{"sourceInterval":[520,568]},null,["elem","sep"],["seq",{"sourceInterval":[552,568]},["param",{"sourceInterval":[552,556]},0],["star",{"sourceInterval":[557,568]},["seq",{"sourceInterval":[558,566]},["param",{"sourceInterval":[558,561]},1],["param",{"sourceInterval":[562,566]},0]]]]],"emptyListOf":["define",{"sourceInterval":[572,682]},null,["elem","sep"],["seq",{"sourceInterval":[685,685]}]],"experimentalApplySyntactic":["define",{"sourceInterval":[685,722]},null,["app"],["param",{"sourceInterval":[719,722]},0]]}]);
+module.exports = ohm.makeRecipe(["grammar",{"source":"BuiltInRules {\n\n  alnum  (an alpha-numeric character)\n    = letter\n    | digit\n\n  letter  (a letter)\n    = lower\n    | upper\n    | unicodeLtmo\n\n  digit  (a digit)\n    = \"0\"..\"9\"\n\n  hexDigit  (a hexadecimal digit)\n    = digit\n    | \"a\"..\"f\"\n    | \"A\"..\"F\"\n\n  ListOf<elem, sep>\n    = NonemptyListOf<elem, sep>\n    | EmptyListOf<elem, sep>\n\n  NonemptyListOf<elem, sep>\n    = elem (sep elem)*\n\n  EmptyListOf<elem, sep>\n    = /* nothing */\n\n  listOf<elem, sep>\n    = nonemptyListOf<elem, sep>\n    | emptyListOf<elem, sep>\n\n  nonemptyListOf<elem, sep>\n    = elem (sep elem)*\n\n  emptyListOf<elem, sep>\n    = /* nothing */\n\n}"},"BuiltInRules",null,null,{"alnum":["define",{"sourceInterval":[18,78]},"an alpha-numeric character",[],["alt",{"sourceInterval":[60,78]},["app",{"sourceInterval":[60,66]},"letter",[]],["app",{"sourceInterval":[73,78]},"digit",[]]]],"letter":["define",{"sourceInterval":[82,142]},"a letter",[],["alt",{"sourceInterval":[107,142]},["app",{"sourceInterval":[107,112]},"lower",[]],["app",{"sourceInterval":[119,124]},"upper",[]],["app",{"sourceInterval":[131,142]},"unicodeLtmo",[]]]],"digit":["define",{"sourceInterval":[146,177]},"a digit",[],["range",{"sourceInterval":[169,177]},"0","9"]],"hexDigit":["define",{"sourceInterval":[181,254]},"a hexadecimal digit",[],["alt",{"sourceInterval":[219,254]},["app",{"sourceInterval":[219,224]},"digit",[]],["range",{"sourceInterval":[231,239]},"a","f"],["range",{"sourceInterval":[246,254]},"A","F"]]],"ListOf":["define",{"sourceInterval":[258,336]},null,["elem","sep"],["alt",{"sourceInterval":[282,336]},["app",{"sourceInterval":[282,307]},"NonemptyListOf",[["param",{"sourceInterval":[297,301]},0],["param",{"sourceInterval":[303,306]},1]]],["app",{"sourceInterval":[314,336]},"EmptyListOf",[["param",{"sourceInterval":[326,330]},0],["param",{"sourceInterval":[332,335]},1]]]]],"NonemptyListOf":["define",{"sourceInterval":[340,388]},null,["elem","sep"],["seq",{"sourceInterval":[372,388]},["param",{"sourceInterval":[372,376]},0],["star",{"sourceInterval":[377,388]},["seq",{"sourceInterval":[378,386]},["param",{"sourceInterval":[378,381]},1],["param",{"sourceInterval":[382,386]},0]]]]],"EmptyListOf":["define",{"sourceInterval":[392,434]},null,["elem","sep"],["seq",{"sourceInterval":[438,438]}]],"listOf":["define",{"sourceInterval":[438,516]},null,["elem","sep"],["alt",{"sourceInterval":[462,516]},["app",{"sourceInterval":[462,487]},"nonemptyListOf",[["param",{"sourceInterval":[477,481]},0],["param",{"sourceInterval":[483,486]},1]]],["app",{"sourceInterval":[494,516]},"emptyListOf",[["param",{"sourceInterval":[506,510]},0],["param",{"sourceInterval":[512,515]},1]]]]],"nonemptyListOf":["define",{"sourceInterval":[520,568]},null,["elem","sep"],["seq",{"sourceInterval":[552,568]},["param",{"sourceInterval":[552,556]},0],["star",{"sourceInterval":[557,568]},["seq",{"sourceInterval":[558,566]},["param",{"sourceInterval":[558,561]},1],["param",{"sourceInterval":[562,566]},0]]]]],"emptyListOf":["define",{"sourceInterval":[572,614]},null,["elem","sep"],["seq",{"sourceInterval":[616,616]}]]}]);
diff --git a/packages/ohm-js/index.d.ts b/packages/ohm-js/index.d.ts
index 015d9802..2dfdeccf 100644
--- a/packages/ohm-js/index.d.ts
+++ b/packages/ohm-js/index.d.ts
@@ -248,7 +248,6 @@ declare namespace ohm {
       arg2: IterationNode
     ) => T;
     emptyListOf?: (this: NonterminalNode) => T;
-    experimentalApplySyntactic?: (this: NonterminalNode, arg0: Node) => T;
   }
 
   /**
diff --git a/packages/ohm-js/src/MatchState.js b/packages/ohm-js/src/MatchState.js
index 1903337c..e7219403 100644
--- a/packages/ohm-js/src/MatchState.js
+++ b/packages/ohm-js/src/MatchState.js
@@ -9,18 +9,11 @@ const MatchResult = require('./MatchResult');
 const PosInfo = require('./PosInfo');
 const Trace = require('./Trace');
 const pexprs = require('./pexprs');
-const util = require('./util');
 
 // --------------------------------------------------------------------
 // Private stuff
 // --------------------------------------------------------------------
 
-let builtInApplySyntacticBody;
-
-util.awaitBuiltInRules(builtInRules => {
-  builtInApplySyntacticBody = builtInRules.rules.experimentalApplySyntactic.body;
-});
-
 const applySpaces = new pexprs.Apply('spaces');
 
 function MatchState(matcher, startExpr, optPositionToRecordFailures) {
@@ -91,6 +84,9 @@ MatchState.prototype = {
   },
 
   inSyntacticContext() {
+    if (typeof this.inputStream.source !== 'string') {
+      return false;
+    }
     const currentApplication = this.currentApplication();
     if (currentApplication) {
       return currentApplication.isSyntactic() && !this.inLexifiedContext();
@@ -143,7 +139,6 @@ MatchState.prototype = {
   truncateBindings(newLength) {
     // Yes, this is this really faster than setting the `length` property (tested with
     // bin/es5bench on Node v6.1.0).
-    // Update 2021-10-25: still true on v14.15.5 — it's ~20% speedup on es5bench.
     while (this._bindings.length > newLength) {
       this.popBinding();
     }
@@ -346,12 +341,6 @@ MatchState.prototype = {
       this.recordFailures(origRecordedFailures, false);
     }
 
-    // The built-in experimentalApplySyntactic rule needs special handling: we want to skip
-    // trailing spaces, just as with the top-level application of a syntactic rule.
-    if (expr === builtInApplySyntacticBody) {
-      this.skipSpaces();
-    }
-
     return ans;
   },
 
diff --git a/packages/ohm-js/src/built-in-rules.ohm b/packages/ohm-js/src/built-in-rules.ohm
index 76150930..5df09d6c 100644
--- a/packages/ohm-js/src/built-in-rules.ohm
+++ b/packages/ohm-js/src/built-in-rules.ohm
@@ -37,6 +37,4 @@ BuiltInRules {
   emptyListOf<elem, sep>
     = /* nothing */
 
-  // Allows a syntactic rule application within a lexical context.
-  experimentalApplySyntactic<app> = app
 }
diff --git a/packages/ohm-js/src/errors.js b/packages/ohm-js/src/errors.js
index d5e78f06..5f5ce6b0 100644
--- a/packages/ohm-js/src/errors.js
+++ b/packages/ohm-js/src/errors.js
@@ -166,10 +166,6 @@ function invalidParameter(ruleName, expr) {
 
 // Application of syntactic rule from lexical rule
 
-const syntacticVsLexicalNote =
-  'NOTE: A _syntactic rule_ is a rule whose name begins with a capital letter. ' +
-  'See https://git.io/JiYgP for more details.';
-
 function applicationOfSyntacticRuleFromLexicalContext(ruleName, applyExpr) {
   return createError(
       'Cannot apply syntactic rule ' + ruleName + ' from here (inside a lexical context)',
@@ -177,17 +173,6 @@ function applicationOfSyntacticRuleFromLexicalContext(ruleName, applyExpr) {
   );
 }
 
-// Lexical rule application used with experimentalApplySyntactic
-
-function experimentalApplySyntacticWithLexicalRuleApplication(applyExpr) {
-  const {ruleName} = applyExpr;
-  return createError(
-      `experimentalApplySyntactic is for syntactic rules, but '${ruleName}' is a lexical rule. ` +
-      syntacticVsLexicalNote,
-      applyExpr.source
-  );
-}
-
 // Incorrect argument type
 
 function incorrectArgumentType(expectedType, expr) {
@@ -295,7 +280,6 @@ function missingSemanticAction(ctorName, name, type, stack) {
 
 module.exports = {
   applicationOfSyntacticRuleFromLexicalContext,
-  experimentalApplySyntacticWithLexicalRuleApplication,
   cannotExtendUndeclaredRule,
   cannotOverrideUndeclaredRule,
   duplicateGrammarDeclaration,
diff --git a/packages/ohm-js/src/pexprs-assertAllApplicationsAreValid.js b/packages/ohm-js/src/pexprs-assertAllApplicationsAreValid.js
index ac697eac..9f584bbd 100644
--- a/packages/ohm-js/src/pexprs-assertAllApplicationsAreValid.js
+++ b/packages/ohm-js/src/pexprs-assertAllApplicationsAreValid.js
@@ -4,7 +4,7 @@
 // Imports
 // --------------------------------------------------------------------
 
-const {abstract, isSyntactic} = require('./common');
+const common = require('./common');
 const errors = require('./errors');
 const pexprs = require('./pexprs');
 const util = require('./util');
@@ -26,7 +26,7 @@ pexprs.PExpr.prototype.assertAllApplicationsAreValid = function(ruleName, gramma
   this._assertAllApplicationsAreValid(ruleName, grammar);
 };
 
-pexprs.PExpr.prototype._assertAllApplicationsAreValid = abstract(
+pexprs.PExpr.prototype._assertAllApplicationsAreValid = common.abstract(
     '_assertAllApplicationsAreValid'
 );
 
@@ -65,11 +65,7 @@ pexprs.Iter.prototype._assertAllApplicationsAreValid =
       this.expr._assertAllApplicationsAreValid(ruleName, grammar);
     };
 
-pexprs.Apply.prototype._assertAllApplicationsAreValid = function(
-    ruleName,
-    grammar,
-    skipSyntacticCheck = false
-) {
+pexprs.Apply.prototype._assertAllApplicationsAreValid = function(ruleName, grammar) {
   const ruleInfo = grammar.rules[this.ruleName];
 
   // Make sure that the rule exists...
@@ -79,9 +75,8 @@ pexprs.Apply.prototype._assertAllApplicationsAreValid = function(
 
   // ...and that this application is allowed
   if (
-    !skipSyntacticCheck &&
-    isSyntactic(this.ruleName) &&
-    (!isSyntactic(ruleName) || lexifyCount > 0)
+    common.isSyntactic(this.ruleName) &&
+    (!common.isSyntactic(ruleName) || lexifyCount > 0)
   ) {
     throw errors.applicationOfSyntacticRuleFromLexicalContext(this.ruleName, this);
   }
@@ -93,16 +88,9 @@ pexprs.Apply.prototype._assertAllApplicationsAreValid = function(
     throw errors.wrongNumberOfArguments(this.ruleName, expected, actual, this.source);
   }
 
-  const isBuiltInApplySyntactic =
-    BuiltInRules && ruleInfo === BuiltInRules.rules.experimentalApplySyntactic;
-  const isBuiltInCaseInsensitive =
-    BuiltInRules && ruleInfo === BuiltInRules.rules.caseInsensitive;
-
   // ...and that all of the argument expressions only have valid applications and have arity 1.
-  // If `this` is an application of the built-in experimentalApplySyntactic rule, then its arg is
-  // allowed (and expected) to be a syntactic rule, even if we're in a lexical context.
   this.args.forEach(arg => {
-    arg._assertAllApplicationsAreValid(ruleName, grammar, isBuiltInApplySyntactic);
+    arg._assertAllApplicationsAreValid(ruleName, grammar);
     if (arg.getArity() !== 1) {
       throw errors.invalidParameter(this.ruleName, arg);
     }
@@ -111,19 +99,9 @@ pexprs.Apply.prototype._assertAllApplicationsAreValid = function(
   // Extra checks for "special" applications
 
   // If it's an application of 'caseInsensitive', ensure that the argument is a Terminal.
-  if (isBuiltInCaseInsensitive) {
+  if (BuiltInRules && ruleInfo === BuiltInRules.rules.caseInsensitive) {
     if (!(this.args[0] instanceof pexprs.Terminal)) {
       throw errors.incorrectArgumentType('a Terminal (e.g. "abc")', this.args[0]);
     }
   }
-
-  if (isBuiltInApplySyntactic) {
-    const arg = this.args[0];
-    if (!(arg instanceof pexprs.Apply)) {
-      throw errors.incorrectArgumentType('a syntactic rule application', arg);
-    }
-    if (!isSyntactic(arg.ruleName)) {
-      throw errors.experimentalApplySyntacticWithLexicalRuleApplication(arg);
-    }
-  }
 };
diff --git a/packages/ohm-js/test/snapshots/test-grammar.js.md b/packages/ohm-js/test/snapshots/test-grammar.js.md
index 34f4dabf..67544ab9 100644
--- a/packages/ohm-js/test/snapshots/test-grammar.js.md
+++ b/packages/ohm-js/test/snapshots/test-grammar.js.md
@@ -45,8 +45,6 @@ Generated by [AVA](https://avajs.dev).
       },␊
       emptyListOf: function() {␊
       },␊
-      experimentalApplySyntactic: function(_) {␊
-      },␊
       any: function(_) {␊
       },␊
       end: function(_) {␊
@@ -104,8 +102,6 @@ Generated by [AVA](https://avajs.dev).
       },␊
       emptyListOf: function() {␊
       },␊
-      experimentalApplySyntactic: function(_) {␊
-      },␊
       any: function(_) {␊
       },␊
       end: function(_) {␊
diff --git a/packages/ohm-js/test/snapshots/test-grammar.js.snap b/packages/ohm-js/test/snapshots/test-grammar.js.snap
index 4d7dbf2a..3e20bc07 100644
Binary files a/packages/ohm-js/test/snapshots/test-grammar.js.snap and b/packages/ohm-js/test/snapshots/test-grammar.js.snap differ
diff --git a/packages/ohm-js/test/test-built-in-rules.js b/packages/ohm-js/test/test-built-in-rules.js
deleted file mode 100644
index 71b04907..00000000
--- a/packages/ohm-js/test/test-built-in-rules.js
+++ /dev/null
@@ -1,123 +0,0 @@
-'use strict';
-
-const test = require('ava');
-
-const ohm = require('..');
-
-test('case-insensitive matching', t => {
-  const g = ohm.grammar(`
-    G {
-      start = caseInsensitive<"blerg">
-      WithSpaces = "bl" caseInsensitive<"erg">
-      withUmlaut = caseInsensitive<"blërg">
-      eszett = caseInsensitive<"ß">
-      dotlessI = caseInsensitive<"ı">
-      dottedI = caseInsensitive<"İ">
-      insideRepetition1 = (caseInsensitive<"a">)+
-      insideRepetition2 = (caseInsensitive<"a">)*
-    }
-  `);
-  let result = g.match('BLERG');
-  t.is(result.succeeded(), true);
-
-  const s = g.createSemantics().addAttribute('matchedString', {
-    _terminal() {
-      return this.sourceString;
-    },
-    _nonterminal(...children) {
-      return children.map(c => c.matchedString).join('');
-    },
-  });
-  t.is(s(result).matchedString, 'BLERG');
-
-  result = g.match('bl ErG', 'WithSpaces');
-  t.is(result.succeeded(), true);
-  t.is(s(result).matchedString, 'blErG');
-
-  t.is(g.match('blËrg', 'withUmlaut').succeeded(), true);
-
-  result = g.match('blErg', 'withUmlaut');
-  t.is(result.failed(), true);
-  t.is(result.shortMessage, 'Line 1, col 1: expected "blërg" (case-insensitive)');
-
-  t.is(g.match('ı', 'dotlessI').succeeded(), true, 'matches same code point');
-  t.is(g.match('I', 'dotlessI').succeeded(), true, 'matches uppercase dotless I');
-  t.is(g.match('İ', 'dottedI').succeeded(), true, 'matches some code point');
-
-  // Getting this right is really tricky. Our implementation currently doesn't treat "i" and "İ"
-  // as being case-insensitive-equal. TODO: Maybe fix this?
-  t.is(g.match('i', 'dottedI').succeeded(), false, "regular i WON'T match uppercase dotted I");
-
-  t.is(g.match('s', 'eszett').failed(), true);
-  t.is(g.match('ss', 'eszett').failed(), true);
-
-  t.is(g.match('aaaA', 'insideRepetition1').succeeded(), true, 'works inside +');
-  t.is(g.match('aaaA', 'insideRepetition2').succeeded(), true, 'works inside *');
-
-  t.throws(
-      () => {
-        ohm.grammar('G { start = caseInsensitive<start> }');
-      },
-      {message: /Incorrect argument type/},
-      'throws when argument is not a Terminal'
-  );
-
-  // TODO: Maybe allow Ranges here?
-  t.throws(
-      () => {
-        ohm.grammar('G { start = caseInsensitive<"a".."z"> }');
-      },
-      {message: /Incorrect argument type/},
-      'throws when argument is a Range'
-  );
-});
-
-test('experimentalApplySyntactic', t => {
-  // Syntactic rule can be passed to experimentalApplySyntactic in a lexical context
-  t.notThrows(() => ohm.grammar('G { foo = experimentalApplySyntactic<X>\nX = }'));
-  t.notThrows(() => ohm.grammar('G { Foo = #(experimentalApplySyntactic<X>)\nX = }'));
-
-  const g = ohm.grammar(`
-    G {
-      start = "a" experimentalApplySyntactic<Number>
-      Number = digit+
-
-      leftRecursion = experimentalApplySyntactic<NumberLR>
-      NumberLR = NumberLR digit -- rec
-               | digit
-
-      disallowLeadingSpace = ~space experimentalApplySyntactic<Number>
-    }
-  `);
-  t.is(g.match('a 9').succeeded(), true, 'space is skipped before the syntactic rule');
-  t.is(g.match('a 9 8').succeeded(), true, 'space is skipped inside the syntactic rule');
-  t.is(g.match('a 9 ').succeeded(), true, 'trailing space is skipped');
-
-  t.is(g.match(' 0  12 3', 'leftRecursion').succeeded(), true);
-
-  t.is(g.match(' 0', 'disallowLeadingSpace').failed(), true);
-
-  t.throws(
-      () => ohm.grammar('G { foo = experimentalApplySyntactic<"bad"> }'),
-      {
-        message: /expected a syntactic rule application/,
-      },
-      'other arg types (e.g. Terminal) are not allowed'
-  );
-
-  t.throws(
-      () => ohm.grammar('G { foo = experimentalApplySyntactic<x>\nx = }'),
-      {
-        message: /experimentalApplySyntactic is for syntactic rules, but 'x' is a lexical rule/,
-      },
-      'error if arg is a lexical rule application'
-  );
-});
-
-// TODO: Get this working (or should it just warn?)
-test.failing('experimentalApplySyntactic with a lexical arg', t => {
-  // experimentalApplySyntactic can't appear in a syntatic context, and or lexical args.
-  t.throws(() => ohm.grammar('G { Foo = experimentalApplySyntactic<X>\nX = }'), {
-    message: /fixme/,
-  });
-});
diff --git a/packages/ohm-js/test/test-ohm-syntax.js b/packages/ohm-js/test/test-ohm-syntax.js
index 901bcbaf..7cd3d705 100644
--- a/packages/ohm-js/test/test-ohm-syntax.js
+++ b/packages/ohm-js/test/test-ohm-syntax.js
@@ -1261,6 +1261,74 @@ test('space skipping semantics', t => {
   );
 });
 
+test('case-insensitive matching', t => {
+  const g = ohm.grammar(`
+    G {
+      start = caseInsensitive<"blerg">
+      WithSpaces = "bl" caseInsensitive<"erg">
+      withUmlaut = caseInsensitive<"blërg">
+      eszett = caseInsensitive<"ß">
+      dotlessI = caseInsensitive<"ı">
+      dottedI = caseInsensitive<"İ">
+      insideRepetition1 = (caseInsensitive<"a">)+
+      insideRepetition2 = (caseInsensitive<"a">)*
+    }
+  `);
+  let result = g.match('BLERG');
+  t.is(result.succeeded(), true);
+
+  const s = g.createSemantics().addAttribute('matchedString', {
+    _terminal() {
+      return this.sourceString;
+    },
+    _nonterminal(...children) {
+      return children.map(c => c.matchedString).join('');
+    },
+  });
+  t.is(s(result).matchedString, 'BLERG');
+
+  result = g.match('bl ErG', 'WithSpaces');
+  t.is(result.succeeded(), true);
+  t.is(s(result).matchedString, 'blErG');
+
+  t.is(g.match('blËrg', 'withUmlaut').succeeded(), true);
+
+  result = g.match('blErg', 'withUmlaut');
+  t.is(result.failed(), true);
+  t.is(result.shortMessage, 'Line 1, col 1: expected "blërg" (case-insensitive)');
+
+  t.is(g.match('ı', 'dotlessI').succeeded(), true, 'matches same code point');
+  t.is(g.match('I', 'dotlessI').succeeded(), true, 'matches uppercase dotless I');
+  t.is(g.match('İ', 'dottedI').succeeded(), true, 'matches some code point');
+
+  // Getting this right is really tricky. Our implementation currently doesn't treat "i" and "İ"
+  // as being case-insensitive-equal. TODO: Maybe fix this?
+  t.is(g.match('i', 'dottedI').succeeded(), false, "regular i WON'T match uppercase dotted I");
+
+  t.is(g.match('s', 'eszett').failed(), true);
+  t.is(g.match('ss', 'eszett').failed(), true);
+
+  t.is(g.match('aaaA', 'insideRepetition1').succeeded(), true, 'works inside +');
+  t.is(g.match('aaaA', 'insideRepetition2').succeeded(), true, 'works inside *');
+
+  t.throws(
+      () => {
+        ohm.grammar('G { start = caseInsensitive<start> }');
+      },
+      {message: /Incorrect argument type/},
+      'throws when argument is not a Terminal'
+  );
+
+  // TODO: Maybe allow Ranges here?
+  t.throws(
+      () => {
+        ohm.grammar('G { start = caseInsensitive<"a".."z"> }');
+      },
+      {message: /Incorrect argument type/},
+      'throws when argument is a Range'
+  );
+});
+
 // https://github.com/harc/ohm/issues/282
 test('single-line comment after case name (#282)', t => {
   const {ohmGrammar} = ohm;
