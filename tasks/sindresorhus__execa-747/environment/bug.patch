diff --git a/index.d.ts b/index.d.ts
index a854119..6d940fe 100644
--- a/index.d.ts
+++ b/index.d.ts
@@ -538,11 +538,9 @@ type CommonOptions<IsSync extends boolean = boolean> = {
 	readonly cleanup?: IfAsync<IsSync, boolean>;
 
 	/**
-	Whether to return the child process' output using the `result.stdout`, `result.stderr`, `result.all` and `result.stdio` properties.
+	Buffer the output from the spawned process. When set to `false`, you must read the output of `stdout` and `stderr` (or `all` if the `all` option is `true`). Otherwise the returned promise will not be resolved/rejected.
 
-	On failure, the `error.stdout`, `error.stderr`, `error.all` and `error.stdio` properties are used instead.
-
-	When `buffer` is `false`, the output can still be read using the `childProcess.stdout`, `childProcess.stderr`, `childProcess.stdio` and `childProcess.all` streams. If the output is read, this should be done right away to avoid missing any data.
+	If the spawned process fails, `error.stdout`, `error.stderr`, and `error.all` will contain the buffered data.
 
 	@default true
 	*/
diff --git a/lib/stream.js b/lib/stream.js
index ff0d449..ebef5a5 100644
--- a/lib/stream.js
+++ b/lib/stream.js
@@ -1,6 +1,5 @@
 import {once} from 'node:events';
 import {finished} from 'node:stream/promises';
-import {setImmediate} from 'node:timers/promises';
 import getStream, {getStreamAsArrayBuffer, getStreamAsArray} from 'get-stream';
 import mergeStreams from '@sindresorhus/merge-streams';
 import {throwOnTimeout, cleanupOnExit} from './kill.js';
@@ -12,6 +11,23 @@ export const makeAllStream = ({stdout, stderr}, {all}) => all && (stdout || stde
 	? mergeStreams([stdout, stderr].filter(Boolean))
 	: undefined;
 
+// `childProcess.stdout|stderr` do not end until they have been consumed by `childProcess.all`.
+// `childProcess.all` does not end until `childProcess.stdout|stderr` have ended.
+// That's a good thing, since it ensures those streams are fully read and destroyed, even on errors.
+// However, this creates a deadlock if `childProcess.all` is not being read.
+// Doing so prevents the process from exiting, even when it failed.
+// It also prevents those streams from being properly destroyed.
+// This can only happen when:
+//  - `all` is `true`
+//  - `buffer` is `false`
+//  - `childProcess.all` is not read by the user
+// Therefore, we forcefully resume `childProcess.all` flow on errors.
+const resumeAll = all => {
+	if (all?.readableFlowing === null) {
+		all.resume();
+	}
+};
+
 // On failure, `result.stdout|stderr|all` should contain the currently buffered stream
 // They are automatically closed and flushed by Node.js when the child process exits
 // We guarantee this by calling `childProcess.kill()`
@@ -55,8 +71,7 @@ const getStreamPromise = async ({stream, encoding, buffer, maxBuffer}) => {
 	}
 
 	if (!buffer) {
-		await Promise.all([finished(stream), resumeStream(stream)]);
-		return;
+		return finished(stream);
 	}
 
 	if (stream.readableObjectMode) {
@@ -69,15 +84,6 @@ const getStreamPromise = async ({stream, encoding, buffer, maxBuffer}) => {
 	return applyEncoding(contents, encoding);
 };
 
-// When using `buffer: false`, users need to read `childProcess.stdout|stderr|all` right away
-// See https://github.com/sindresorhus/execa/issues/730 and https://github.com/sindresorhus/execa/pull/729#discussion_r1465496310
-const resumeStream = async stream => {
-	await setImmediate();
-	if (stream.readableFlowing === null) {
-		stream.resume();
-	}
-};
-
 const applyEncoding = (contents, encoding) => encoding === 'buffer' ? new Uint8Array(contents) : contents;
 
 // Retrieve streams created by the `std*` options
@@ -167,6 +173,7 @@ export const getSpawnedResult = async ({
 		]);
 	} catch (error) {
 		spawned.kill();
+		resumeAll(spawned.all);
 		const results = await Promise.all([
 			error,
 			waitForFailedProcess(processSpawnPromise, processErrorPromise, processExitPromise),
diff --git a/readme.md b/readme.md
index 9d4c34a..cddd189 100644
--- a/readme.md
+++ b/readme.md
@@ -534,11 +534,9 @@ For example, this can be used together with [`get-node`](https://github.com/ehmi
 Type: `boolean`\
 Default: `true`
 
-Whether to return the child process' output using the [`result.stdout`](#stdout), [`result.stderr`](#stderr), [`result.all`](#all-1) and [`result.stdio`](#stdio) properties.
+Buffer the output from the spawned process. When set to `false`, you must read the output of [`stdout`](#stdout-1) and [`stderr`](#stderr-1) (or [`all`](#all) if the [`all`](#all-2) option is `true`). Otherwise the returned promise will not be resolved/rejected.
 
-On failure, the [`error.stdout`](#stdout), [`error.stderr`](#stderr), [`error.all`](#all-1) and [`error.stdio`](#stdio) properties are used instead.
-
-When `buffer` is `false`, the output can still be read using the [`childProcess.stdout`](#stdout-1), [`childProcess.stderr`](#stderr-1), [`childProcess.stdio`](https://nodejs.org/api/child_process.html#subprocessstdio) and [`childProcess.all`](#all) streams. If the output is read, this should be done right away to avoid missing any data.
+If the spawned process fails, [`error.stdout`](#stdout), [`error.stderr`](#stderr), [`error.all`](#all) and [`error.stdio`](#stdio) will contain the buffered data.
 
 #### input
 
diff --git a/test/fixtures/noop-fd-ipc.js b/test/fixtures/noop-fd-ipc.js
deleted file mode 100755
index d2c3bed..0000000
--- a/test/fixtures/noop-fd-ipc.js
+++ /dev/null
@@ -1,6 +0,0 @@
-#!/usr/bin/env node
-import process from 'node:process';
-import {writeSync} from 'node:fs';
-
-writeSync(Number(process.argv[2]), process.argv[3] || 'foobar');
-process.send('');
diff --git a/test/stream.js b/test/stream.js
index a1fb400..219463f 100644
--- a/test/stream.js
+++ b/test/stream.js
@@ -1,5 +1,6 @@
 import {Buffer} from 'node:buffer';
 import {once} from 'node:events';
+import process from 'node:process';
 import {getDefaultHighWaterMark} from 'node:stream';
 import {setTimeout, setImmediate} from 'node:timers/promises';
 import test from 'ava';
@@ -84,28 +85,6 @@ const getFirstDataEvent = async stream => {
 	return output.toString();
 };
 
-const testLateStream = async (t, index, all) => {
-	const subprocess = execa('noop-fd-ipc.js', [`${index}`, foobarString], {...getStdio(4, 'ipc', 4), buffer: false, all});
-	await once(subprocess, 'message');
-	await setImmediate();
-	const [output, allOutput] = await Promise.all([
-		getStream(subprocess.stdio[index]),
-		all ? getStream(subprocess.all) : undefined,
-		subprocess,
-	]);
-
-	t.is(output, '');
-
-	if (all) {
-		t.is(allOutput, '');
-	}
-};
-
-test('Lacks some data when stdout is read too late `buffer` set to `false`', testLateStream, 1, false);
-test('Lacks some data when stderr is read too late `buffer` set to `false`', testLateStream, 2, false);
-test('Lacks some data when stdio[*] is read too late `buffer` set to `false`', testLateStream, 3, false);
-test('Lacks some data when all is read too late `buffer` set to `false`', testLateStream, 1, true);
-
 // eslint-disable-next-line max-params
 const testIterationBuffer = async (t, index, buffer, useDataEvents, all) => {
 	const subprocess = execa('noop-fd.js', [`${index}`, foobarString], {...fullStdio, buffer, all});
@@ -289,27 +268,32 @@ test('Process buffers stdout, which does not prevent exit if ignored', testBuffe
 test('Process buffers stderr, which does not prevent exit if ignored', testBufferIgnore, 2, false);
 test('Process buffers all, which does not prevent exit if ignored', testBufferIgnore, 1, true);
 
-const testBufferNotRead = async (t, index, all) => {
-	const subprocess = execa('max-buffer.js', [`${index}`], {...fullStdio, buffer: false, all});
-	await t.notThrowsAsync(subprocess);
-};
-
-test('Process buffers stdout, which does not prevent exit if not read and buffer is false', testBufferNotRead, 1, false);
-test('Process buffers stderr, which does not prevent exit if not read and buffer is false', testBufferNotRead, 2, false);
-test('Process buffers stdio[*], which does not prevent exit if not read and buffer is false', testBufferNotRead, 3, false);
-test('Process buffers all, which does not prevent exit if not read and buffer is false', testBufferNotRead, 1, true);
-
-const testBufferRead = async (t, index, all) => {
-	const subprocess = execa('max-buffer.js', [`${index}`], {...fullStdio, buffer: false, all});
-	const stream = all ? subprocess.all : subprocess.stdio[index];
-	stream.resume();
-	await t.notThrowsAsync(subprocess);
-};
-
-test('Process buffers stdout, which does not prevent exit if read and buffer is false', testBufferRead, 1, false);
-test('Process buffers stderr, which does not prevent exit if read and buffer is false', testBufferRead, 2, false);
-test('Process buffers stdio[*], which does not prevent exit if read and buffer is false', testBufferRead, 3, false);
-test('Process buffers all, which does not prevent exit if read and buffer is false', testBufferRead, 1, true);
+// This specific behavior does not happen on Windows.
+// Also, on macOS, it randomly happens, which would make those tests randomly fail.
+if (process.platform === 'linux') {
+	const testBufferNotRead = async (t, index, all) => {
+		const subprocess = execa('max-buffer.js', [`${index}`], {...fullStdio, buffer: false, all, timeout: 1e3});
+		const {timedOut} = await t.throwsAsync(subprocess);
+		t.true(timedOut);
+	};
+
+	test('Process buffers stdout, which prevents exit if not read and buffer is false', testBufferNotRead, 1, false);
+	test('Process buffers stderr, which prevents exit if not read and buffer is false', testBufferNotRead, 2, false);
+	test('Process buffers stdio[*], which prevents exit if not read and buffer is false', testBufferNotRead, 3, false);
+	test('Process buffers all, which prevents exit if not read and buffer is false', testBufferNotRead, 1, true);
+
+	const testBufferRead = async (t, index, all) => {
+		const subprocess = execa('max-buffer.js', [`${index}`], {...fullStdio, buffer: false, all, timeout: 1e4});
+		const stream = all ? subprocess.all : subprocess.stdio[index];
+		stream.resume();
+		await t.notThrowsAsync(subprocess);
+	};
+
+	test.serial('Process buffers stdout, which does not prevent exit if read and buffer is false', testBufferRead, 1, false);
+	test.serial('Process buffers stderr, which does not prevent exit if read and buffer is false', testBufferRead, 2, false);
+	test.serial('Process buffers stdio[*], which does not prevent exit if read and buffer is false', testBufferRead, 3, false);
+	test.serial('Process buffers all, which does not prevent exit if read and buffer is false', testBufferRead, 1, true);
+}
 
 const testStreamDestroy = async (t, index) => {
 	const childProcess = execa('forever.js', fullStdio);
