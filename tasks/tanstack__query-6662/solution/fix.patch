diff --git a/knip.ts b/knip.ts
index 5bf569354..1e26d6d15 100644
--- a/knip.ts
+++ b/knip.ts
@@ -15,6 +15,9 @@ export default {
       ignore: ['**/__mocks__/**'],
       ignoreDependencies: ['vue2', 'vue2.7'],
     },
+    'packages/angular-query-experimental': {
+      ignore: ['**/*.test-d.ts'],
+    },
     'integrations/angular-cli-standalone-17': {
       entry: ['src/main.ts'],
     },
diff --git a/packages/angular-query-experimental/src/create-base-query.ts b/packages/angular-query-experimental/src/create-base-query.ts
index 3b85bf5b5..c5a0e1183 100644
--- a/packages/angular-query-experimental/src/create-base-query.ts
+++ b/packages/angular-query-experimental/src/create-base-query.ts
@@ -81,5 +81,5 @@ export function createBaseQuery<
   )
   destroyRef.onDestroy(unsubscribe)
 
-  return signalProxy(resultSignal)
+  return signalProxy(resultSignal) as CreateBaseQueryResult<TData, TError>
 }
diff --git a/packages/angular-query-experimental/src/inject-mutation.ts b/packages/angular-query-experimental/src/inject-mutation.ts
index d40c87465..973fb39c9 100644
--- a/packages/angular-query-experimental/src/inject-mutation.ts
+++ b/packages/angular-query-experimental/src/inject-mutation.ts
@@ -56,7 +56,12 @@ export function injectMutation<
       mutateAsync: result().mutate,
     }))
 
-    return signalProxy(resultSignal)
+    return signalProxy(resultSignal) as unknown as CreateMutationResult<
+      TData,
+      TError,
+      TVariables,
+      TContext
+    >
   })
 }
 
diff --git a/packages/angular-query-experimental/src/types.ts b/packages/angular-query-experimental/src/types.ts
index 8bd069c42..77f828e17 100644
--- a/packages/angular-query-experimental/src/types.ts
+++ b/packages/angular-query-experimental/src/types.ts
@@ -26,11 +26,42 @@ export interface CreateBaseQueryOptions<
     'queryKey'
   > {}
 
+type CreateStatusBasedQueryResult<
+  TStatus extends QueryObserverResult['status'],
+  TData = unknown,
+  TError = DefaultError,
+> = Extract<QueryObserverResult<TData, TError>, { status: TStatus }>
+
+export interface BaseQueryNarrowing<TData = unknown, TError = DefaultError> {
+  isSuccess(
+    this: CreateBaseQueryResult<TData, TError>,
+  ): this is CreateBaseQueryResult<
+    TData,
+    TError,
+    CreateStatusBasedQueryResult<'success', TData, TError>
+  >
+  isError(
+    this: CreateBaseQueryResult<TData, TError>,
+  ): this is CreateBaseQueryResult<
+    TData,
+    TError,
+    CreateStatusBasedQueryResult<'error', TData, TError>
+  >
+  isPending(
+    this: CreateBaseQueryResult<TData, TError>,
+  ): this is CreateBaseQueryResult<
+    TData,
+    TError,
+    CreateStatusBasedQueryResult<'pending', TData, TError>
+  >
+}
+
 export type CreateBaseQueryResult<
   TData = unknown,
   TError = DefaultError,
   State = QueryObserverResult<TData, TError>,
-> = MapToSignals<State>
+> = BaseQueryNarrowing<TData, TError> &
+  MapToSignals<Omit<State, keyof BaseQueryNarrowing>>
 
 export interface CreateQueryOptions<
   TQueryFnData = unknown,
@@ -122,12 +153,93 @@ export type CreateBaseMutationResult<
   mutateAsync: CreateMutateAsyncFunction<TData, TError, TVariables, TContext>
 }
 
+type CreateStatusBasedMutationResult<
+  TStatus extends CreateBaseMutationResult['status'],
+  TData = unknown,
+  TError = DefaultError,
+  TVariables = unknown,
+  TContext = unknown,
+> = Extract<
+  CreateBaseMutationResult<TData, TError, TVariables, TContext>,
+  { status: TStatus }
+>
+
+export interface BaseMutationNarrowing<
+  TData = unknown,
+  TError = DefaultError,
+  TVariables = unknown,
+  TContext = unknown,
+> {
+  isSuccess(
+    this: CreateMutationResult<TData, TError, TVariables, TContext>,
+  ): this is CreateMutationResult<
+    TData,
+    TError,
+    TVariables,
+    TContext,
+    CreateStatusBasedMutationResult<
+      'success',
+      TData,
+      TError,
+      TVariables,
+      TContext
+    >
+  >
+  isError(
+    this: CreateMutationResult<TData, TError, TVariables, TContext>,
+  ): this is CreateMutationResult<
+    TData,
+    TError,
+    TVariables,
+    TContext,
+    CreateStatusBasedMutationResult<
+      'error',
+      TData,
+      TError,
+      TVariables,
+      TContext
+    >
+  >
+  isPending(
+    this: CreateMutationResult<TData, TError, TVariables, TContext>,
+  ): this is CreateMutationResult<
+    TData,
+    TError,
+    TVariables,
+    TContext,
+    CreateStatusBasedMutationResult<
+      'pending',
+      TData,
+      TError,
+      TVariables,
+      TContext
+    >
+  >
+  isIdle(
+    this: CreateMutationResult<TData, TError, TVariables, TContext>,
+  ): this is CreateMutationResult<
+    TData,
+    TError,
+    TVariables,
+    TContext,
+    CreateStatusBasedMutationResult<'idle', TData, TError, TVariables, TContext>
+  >
+}
+
 /** Result from createMutation */
 export type CreateMutationResult<
   TData = unknown,
   TError = DefaultError,
   TVariables = unknown,
   TContext = unknown,
-> = MapToSignals<CreateBaseMutationResult<TData, TError, TVariables, TContext>>
+  State = CreateStatusBasedMutationResult<
+    CreateBaseMutationResult['status'],
+    TData,
+    TError,
+    TVariables,
+    TContext
+  >,
+> = BaseMutationNarrowing<TData, TError, TVariables, TContext> &
+  MapToSignals<Omit<State, keyof BaseMutationNarrowing>>
 
 type Override<A, B> = { [K in keyof A]: K extends keyof B ? B[K] : A[K] }
