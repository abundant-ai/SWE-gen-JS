diff --git a/knip.ts b/knip.ts
index 1e26d6d15..5bf569354 100644
--- a/knip.ts
+++ b/knip.ts
@@ -15,9 +15,6 @@ export default {
       ignore: ['**/__mocks__/**'],
       ignoreDependencies: ['vue2', 'vue2.7'],
     },
-    'packages/angular-query-experimental': {
-      ignore: ['**/*.test-d.ts'],
-    },
     'integrations/angular-cli-standalone-17': {
       entry: ['src/main.ts'],
     },
diff --git a/packages/angular-query-experimental/src/__tests__/inject-mutation.test-d.ts b/packages/angular-query-experimental/src/__tests__/inject-mutation.test-d.ts
deleted file mode 100644
index 8ff5c69f3..000000000
--- a/packages/angular-query-experimental/src/__tests__/inject-mutation.test-d.ts
+++ /dev/null
@@ -1,71 +0,0 @@
-import { describe, expectTypeOf } from 'vitest'
-import { injectMutation } from '../inject-mutation'
-import { successMutator } from './test-utils'
-import type { Signal } from '@angular/core'
-
-describe('Discriminated union return type', () => {
-  test('data should be possibly undefined by default', () => {
-    const mutation = injectMutation(() => ({
-      mutationFn: successMutator<string>,
-    }))
-
-    expectTypeOf(mutation.data).toEqualTypeOf<Signal<string | undefined>>()
-  })
-
-  test('data should be defined when mutation is success', () => {
-    const mutation = injectMutation(() => ({
-      mutationFn: successMutator<string>,
-    }))
-
-    if (mutation.isSuccess()) {
-      expectTypeOf(mutation.data).toEqualTypeOf<Signal<string>>()
-    }
-  })
-
-  test('error should be null when mutation is success', () => {
-    const mutation = injectMutation(() => ({
-      mutationFn: successMutator<string>,
-    }))
-
-    if (mutation.isSuccess()) {
-      expectTypeOf(mutation.error).toEqualTypeOf<Signal<null>>()
-    }
-  })
-
-  test('data should be undefined when mutation is pending', () => {
-    const mutation = injectMutation(() => ({
-      mutationFn: successMutator<string>,
-    }))
-
-    if (mutation.isPending()) {
-      expectTypeOf(mutation.data).toEqualTypeOf<Signal<undefined>>()
-    }
-  })
-
-  test('error should be defined when mutation is error', () => {
-    const mutation = injectMutation(() => ({
-      mutationFn: successMutator<string>,
-    }))
-
-    if (mutation.isError()) {
-      expectTypeOf(mutation.error).toEqualTypeOf<Signal<Error>>()
-    }
-  })
-
-  test('should narrow variables', () => {
-    const mutation = injectMutation(() => ({
-      mutationFn: successMutator<string>,
-    }))
-
-    if (mutation.isIdle()) {
-      expectTypeOf(mutation.variables).toEqualTypeOf<Signal<undefined>>()
-    }
-    if (mutation.isPending()) {
-      expectTypeOf(mutation.variables).toEqualTypeOf<Signal<string>>()
-    }
-    if (mutation.isSuccess()) {
-      expectTypeOf(mutation.variables).toEqualTypeOf<Signal<string>>()
-    }
-    expectTypeOf(mutation.variables).toEqualTypeOf<Signal<string | undefined>>()
-  })
-})
diff --git a/packages/angular-query-experimental/src/__tests__/inject-query.test-d.ts b/packages/angular-query-experimental/src/__tests__/inject-query.test-d.ts
deleted file mode 100644
index 4f8bcdcad..000000000
--- a/packages/angular-query-experimental/src/__tests__/inject-query.test-d.ts
+++ /dev/null
@@ -1,59 +0,0 @@
-import { describe, expectTypeOf } from 'vitest'
-import { injectQuery } from '../inject-query'
-import { simpleFetcher } from './test-utils'
-import type { Signal } from '@angular/core'
-
-describe('Discriminated union return type', () => {
-  test('data should be possibly undefined by default', () => {
-    const query = injectQuery(() => ({
-      queryKey: ['key'],
-      queryFn: simpleFetcher,
-    }))
-
-    expectTypeOf(query.data).toEqualTypeOf<Signal<string | undefined>>()
-  })
-
-  test('data should be defined when query is success', () => {
-    const query = injectQuery(() => ({
-      queryKey: ['key'],
-      queryFn: simpleFetcher,
-    }))
-
-    if (query.isSuccess()) {
-      expectTypeOf(query.data).toEqualTypeOf<Signal<string>>()
-    }
-  })
-
-  test('error should be null when query is success', () => {
-    const query = injectQuery(() => ({
-      queryKey: ['key'],
-      queryFn: simpleFetcher,
-    }))
-
-    if (query.isSuccess()) {
-      expectTypeOf(query.error).toEqualTypeOf<Signal<null>>()
-    }
-  })
-
-  test('data should be undefined when query is pending', () => {
-    const query = injectQuery(() => ({
-      queryKey: ['key'],
-      queryFn: simpleFetcher,
-    }))
-
-    if (query.isPending()) {
-      expectTypeOf(query.data).toEqualTypeOf<Signal<undefined>>()
-    }
-  })
-
-  test('error should be defined when query is error', () => {
-    const query = injectQuery(() => ({
-      queryKey: ['key'],
-      queryFn: simpleFetcher,
-    }))
-
-    if (query.isError()) {
-      expectTypeOf(query.error).toEqualTypeOf<Signal<Error>>()
-    }
-  })
-})
diff --git a/packages/angular-query-experimental/src/create-base-query.ts b/packages/angular-query-experimental/src/create-base-query.ts
index c5a0e1183..3b85bf5b5 100644
--- a/packages/angular-query-experimental/src/create-base-query.ts
+++ b/packages/angular-query-experimental/src/create-base-query.ts
@@ -81,5 +81,5 @@ export function createBaseQuery<
   )
   destroyRef.onDestroy(unsubscribe)
 
-  return signalProxy(resultSignal) as CreateBaseQueryResult<TData, TError>
+  return signalProxy(resultSignal)
 }
diff --git a/packages/angular-query-experimental/src/inject-mutation.ts b/packages/angular-query-experimental/src/inject-mutation.ts
index 973fb39c9..d40c87465 100644
--- a/packages/angular-query-experimental/src/inject-mutation.ts
+++ b/packages/angular-query-experimental/src/inject-mutation.ts
@@ -56,12 +56,7 @@ export function injectMutation<
       mutateAsync: result().mutate,
     }))
 
-    return signalProxy(resultSignal) as unknown as CreateMutationResult<
-      TData,
-      TError,
-      TVariables,
-      TContext
-    >
+    return signalProxy(resultSignal)
   })
 }
 
diff --git a/packages/angular-query-experimental/src/types.ts b/packages/angular-query-experimental/src/types.ts
index 77f828e17..8bd069c42 100644
--- a/packages/angular-query-experimental/src/types.ts
+++ b/packages/angular-query-experimental/src/types.ts
@@ -26,42 +26,11 @@ export interface CreateBaseQueryOptions<
     'queryKey'
   > {}
 
-type CreateStatusBasedQueryResult<
-  TStatus extends QueryObserverResult['status'],
-  TData = unknown,
-  TError = DefaultError,
-> = Extract<QueryObserverResult<TData, TError>, { status: TStatus }>
-
-export interface BaseQueryNarrowing<TData = unknown, TError = DefaultError> {
-  isSuccess(
-    this: CreateBaseQueryResult<TData, TError>,
-  ): this is CreateBaseQueryResult<
-    TData,
-    TError,
-    CreateStatusBasedQueryResult<'success', TData, TError>
-  >
-  isError(
-    this: CreateBaseQueryResult<TData, TError>,
-  ): this is CreateBaseQueryResult<
-    TData,
-    TError,
-    CreateStatusBasedQueryResult<'error', TData, TError>
-  >
-  isPending(
-    this: CreateBaseQueryResult<TData, TError>,
-  ): this is CreateBaseQueryResult<
-    TData,
-    TError,
-    CreateStatusBasedQueryResult<'pending', TData, TError>
-  >
-}
-
 export type CreateBaseQueryResult<
   TData = unknown,
   TError = DefaultError,
   State = QueryObserverResult<TData, TError>,
-> = BaseQueryNarrowing<TData, TError> &
-  MapToSignals<Omit<State, keyof BaseQueryNarrowing>>
+> = MapToSignals<State>
 
 export interface CreateQueryOptions<
   TQueryFnData = unknown,
@@ -153,93 +122,12 @@ export type CreateBaseMutationResult<
   mutateAsync: CreateMutateAsyncFunction<TData, TError, TVariables, TContext>
 }
 
-type CreateStatusBasedMutationResult<
-  TStatus extends CreateBaseMutationResult['status'],
-  TData = unknown,
-  TError = DefaultError,
-  TVariables = unknown,
-  TContext = unknown,
-> = Extract<
-  CreateBaseMutationResult<TData, TError, TVariables, TContext>,
-  { status: TStatus }
->
-
-export interface BaseMutationNarrowing<
-  TData = unknown,
-  TError = DefaultError,
-  TVariables = unknown,
-  TContext = unknown,
-> {
-  isSuccess(
-    this: CreateMutationResult<TData, TError, TVariables, TContext>,
-  ): this is CreateMutationResult<
-    TData,
-    TError,
-    TVariables,
-    TContext,
-    CreateStatusBasedMutationResult<
-      'success',
-      TData,
-      TError,
-      TVariables,
-      TContext
-    >
-  >
-  isError(
-    this: CreateMutationResult<TData, TError, TVariables, TContext>,
-  ): this is CreateMutationResult<
-    TData,
-    TError,
-    TVariables,
-    TContext,
-    CreateStatusBasedMutationResult<
-      'error',
-      TData,
-      TError,
-      TVariables,
-      TContext
-    >
-  >
-  isPending(
-    this: CreateMutationResult<TData, TError, TVariables, TContext>,
-  ): this is CreateMutationResult<
-    TData,
-    TError,
-    TVariables,
-    TContext,
-    CreateStatusBasedMutationResult<
-      'pending',
-      TData,
-      TError,
-      TVariables,
-      TContext
-    >
-  >
-  isIdle(
-    this: CreateMutationResult<TData, TError, TVariables, TContext>,
-  ): this is CreateMutationResult<
-    TData,
-    TError,
-    TVariables,
-    TContext,
-    CreateStatusBasedMutationResult<'idle', TData, TError, TVariables, TContext>
-  >
-}
-
 /** Result from createMutation */
 export type CreateMutationResult<
   TData = unknown,
   TError = DefaultError,
   TVariables = unknown,
   TContext = unknown,
-  State = CreateStatusBasedMutationResult<
-    CreateBaseMutationResult['status'],
-    TData,
-    TError,
-    TVariables,
-    TContext
-  >,
-> = BaseMutationNarrowing<TData, TError, TVariables, TContext> &
-  MapToSignals<Omit<State, keyof BaseMutationNarrowing>>
+> = MapToSignals<CreateBaseMutationResult<TData, TError, TVariables, TContext>>
 
 type Override<A, B> = { [K in keyof A]: K extends keyof B ? B[K] : A[K] }
