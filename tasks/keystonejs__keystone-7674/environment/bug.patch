diff --git a/.changeset/fifty-kids-pay.md b/.changeset/fifty-kids-pay.md
new file mode 100644
index 000000000..a42c525cb
--- /dev/null
+++ b/.changeset/fifty-kids-pay.md
@@ -0,0 +1,5 @@
+---
+'@keystone-6/core': patch
+---
+
+Refactor the types-for-list file to add some extra clarity
diff --git a/.changeset/six-poems-appear.md b/.changeset/six-poems-appear.md
index 6c1c4ff9c..ea8f08f3d 100644
--- a/.changeset/six-poems-appear.md
+++ b/.changeset/six-poems-appear.md
@@ -2,4 +2,4 @@
 '@keystone-6/core': minor
 ---
 
-Added support for changing the auto-generated names of lists used in the Admin UI with `ui.label`, `ui.singular`, `ui.plural` and `ui.path`
+Adds the ability to set ambiguous plurals - like `Firmware` or `Shrimp` - as list names without receiving an error. This builds on the existing `graphql.plural` configuration by adding the configuration options of `ui.label`, `ui.singular`, `ui.plural` and `ui.path` to change the auto-generated names of lists used in the Admin UI
diff --git a/.changeset/yellow-houses-doubt.md b/.changeset/yellow-houses-doubt.md
deleted file mode 100644
index bb2106344..000000000
--- a/.changeset/yellow-houses-doubt.md
+++ /dev/null
@@ -1,5 +0,0 @@
----
-'@keystone-6/fields-document': patch
----
-
-When new fields are added to an object field in a component block, the GraphQL will no longer error when returning data where some fields are missing in the saved data and the Admin UI will add the missing fields when a item is opened. Note that the missing fields won't be automatically added when fetched from the GraphQL, you will still have to handle the field being missing when consuming the data from the GraphQL API.
diff --git a/packages/core/src/lib/core/prisma-schema.ts b/packages/core/src/lib/core/prisma-schema.ts
index d5dfd9b7d..5d4bce22e 100644
--- a/packages/core/src/lib/core/prisma-schema.ts
+++ b/packages/core/src/lib/core/prisma-schema.ts
@@ -1,5 +1,5 @@
 import { ScalarDBField, ScalarDBFieldDefault, DatabaseProvider } from '../../types';
-import { ResolvedDBField, ListsWithResolvedRelations } from './resolve-relationships';
+import { ResolvedDBField } from './resolve-relationships';
 import { InitialisedList } from './types-for-lists';
 import { getDBFieldKeyForFieldOnMultiField } from './utils';
 
@@ -54,7 +54,7 @@ function printField(
   fieldPath: string,
   field: Exclude<ResolvedDBField, { kind: 'none' }>,
   datasourceName: string,
-  lists: ListsWithResolvedRelations
+  lists: Record<string, InitialisedList>
 ): string {
   if (field.kind === 'scalar') {
     const nativeType = printNativeType(field.nativeType, datasourceName);
@@ -112,7 +112,7 @@ function printField(
   return assertNever(field);
 }
 
-function collectEnums(lists: ListsWithResolvedRelations) {
+function collectEnums(lists: Record<string, InitialisedList>) {
   const enums: Record<string, { values: readonly string[]; firstDefinedByRef: string }> = {};
   for (const [listKey, { resolvedDbFields }] of Object.entries(lists)) {
     for (const [fieldPath, field] of Object.entries(resolvedDbFields)) {
diff --git a/packages/core/src/lib/core/resolve-relationships.ts b/packages/core/src/lib/core/resolve-relationships.ts
index 3ad694935..34c2c8c8b 100644
--- a/packages/core/src/lib/core/resolve-relationships.ts
+++ b/packages/core/src/lib/core/resolve-relationships.ts
@@ -16,10 +16,7 @@ export type ResolvedRelationDBField =
       foreignIdField: { kind: 'none' } | { kind: 'owned' | 'owned-unique'; map: string };
     });
 
-export type ListsWithResolvedRelations = Record<
-  string,
-  { resolvedDbFields: FieldsWithResolvedRelations }
->;
+export type ListsWithResolvedRelations = Record<string, FieldsWithResolvedRelations>;
 
 export type ResolvedDBField =
   | ResolvedRelationDBField
@@ -288,7 +285,7 @@ export function resolveRelationships(
       );
       // then we add the opposites to one-sided relations
       Object.assign(resolvedDbFields, outOfOrderDbFields);
-      return [listKey, { resolvedDbFields }];
+      return [listKey, resolvedDbFields];
     })
   );
 }
diff --git a/packages/core/src/lib/core/types-for-lists.ts b/packages/core/src/lib/core/types-for-lists.ts
index c8b93f0a5..999590eb3 100644
--- a/packages/core/src/lib/core/types-for-lists.ts
+++ b/packages/core/src/lib/core/types-for-lists.ts
@@ -38,7 +38,7 @@ export type InitialisedField = Omit<NextFieldType, 'dbField' | 'access' | 'graph
       filter: boolean | ((args: FilterOrderArgs<BaseListTypeInfo>) => MaybePromise<boolean>);
       orderBy: boolean | ((args: FilterOrderArgs<BaseListTypeInfo>) => MaybePromise<boolean>);
     };
-    cacheHint?: CacheHint | undefined;
+    cacheHint: CacheHint | undefined;
   };
 };
 
@@ -57,33 +57,30 @@ export type InitialisedList = {
   lists: Record<string, InitialisedList>;
   dbMap: string | undefined;
   graphql: {
-    isEnabled: {
-      type: boolean;
-      query: boolean;
-
-      create: boolean;
-      update: boolean;
-      delete: boolean;
-    };
+    isEnabled: IsEnabled;
   };
 };
 
-export function initialiseLists(config: KeystoneConfig): Record<string, InitialisedList> {
-  const listsConfig = config.lists;
-  const { provider } = config.db;
-  const listInfos: Record<string, ListGraphQLTypes> = {};
-  const isEnabled: Record<
-    string,
-    {
-      type: boolean;
-      query: boolean;
-      create: boolean;
-      update: boolean;
-      delete: boolean;
-      filter: boolean | ((args: FilterOrderArgs<BaseListTypeInfo>) => MaybePromise<boolean>);
-      orderBy: boolean | ((args: FilterOrderArgs<BaseListTypeInfo>) => MaybePromise<boolean>);
-    }
-  > = {};
+type IsEnabled = {
+  type: boolean;
+  query: boolean;
+  create: boolean;
+  update: boolean;
+  delete: boolean;
+  filter: boolean | ((args: FilterOrderArgs<BaseListTypeInfo>) => MaybePromise<boolean>);
+  orderBy: boolean | ((args: FilterOrderArgs<BaseListTypeInfo>) => MaybePromise<boolean>);
+};
+
+function throwIfNotAFilter(x: unknown, listKey: string, fieldKey: string) {
+  if (['boolean', 'undefined', 'function'].includes(typeof x)) return;
+
+  throw new Error(
+    `Configuration option '${listKey}.${fieldKey}' must be either a boolean value or a function. Received '${x}'.`
+  );
+}
+
+function getIsEnabled(listsConfig: KeystoneConfig['lists']) {
+  const isEnabled: Record<string, IsEnabled> = {};
 
   for (const [listKey, listConfig] of Object.entries(listsConfig)) {
     const omit = listConfig.graphql?.omit;
@@ -92,16 +89,8 @@ export function initialiseLists(config: KeystoneConfig): Record<string, Initiali
       // We explicity check for boolean/function values here to ensure the dev hasn't made a mistake
       // when defining these values. We avoid duck-typing here as this is security related
       // and we want to make it hard to write incorrect code.
-      if (!['boolean', 'undefined', 'function'].includes(typeof defaultIsFilterable)) {
-        throw new Error(
-          `Configuration option '${listKey}.defaultIsFilterable' must be either a boolean value or a function. Recieved '${typeof defaultIsFilterable}'.`
-        );
-      }
-      if (!['boolean', 'undefined', 'function'].includes(typeof defaultIsOrderable)) {
-        throw new Error(
-          `Configuration option '${listKey}.defaultIsOrderable' must be either a boolean value or a function. Recieved '${typeof defaultIsOrderable}'.`
-        );
-      }
+      throwIfNotAFilter(defaultIsFilterable, listKey, 'defaultIsFilterable');
+      throwIfNotAFilter(defaultIsOrderable, listKey, 'defaultIsOrderable');
     }
     if (omit === true) {
       isEnabled[listKey] = {
@@ -136,13 +125,87 @@ export function initialiseLists(config: KeystoneConfig): Record<string, Initiali
     }
   }
 
+  return isEnabled;
+}
+
+function getListsWithInitialisedFields(
+  { storage: configStorage, lists: listsConfig, db: { provider } }: KeystoneConfig,
+  listGraphqlTypes: Record<string, ListGraphQLTypes>,
+  intermediateLists: Record<string, { graphql: { isEnabled: IsEnabled } }>
+) {
+  return Object.fromEntries(
+    Object.entries(listsConfig).map(([listKey, list]) => [
+      listKey,
+      {
+        fields: Object.fromEntries(
+          Object.entries(list.fields).map(([fieldKey, fieldFunc]) => {
+            if (typeof fieldFunc !== 'function') {
+              throw new Error(`The field at ${listKey}.${fieldKey} does not provide a function`);
+            }
+            const f = fieldFunc({
+              fieldKey,
+              listKey,
+              lists: listGraphqlTypes,
+              provider,
+              getStorage: storage => configStorage?.[storage],
+            });
+
+            const omit = f.graphql?.omit;
+            const read = omit !== true && !omit?.includes('read');
+
+            // We explicity check for boolean values here to ensure the dev hasn't made a mistake
+            // when defining these values. We avoid duck-typing here as this is security related
+            // and we want to make it hard to write incorrect code.
+            throwIfNotAFilter(f.isFilterable, listKey, 'isFilterable');
+            throwIfNotAFilter(f.isOrderable, listKey, 'isOrderable');
+
+            const _isEnabled = {
+              read,
+              update: omit !== true && !omit?.includes('update'),
+              create: omit !== true && !omit?.includes('create'),
+              // Filter and orderBy can be defaulted at the list level, otherwise they
+              // default to `false` if no value was set at the list level.
+              filter:
+                read && (f.isFilterable ?? intermediateLists[listKey].graphql.isEnabled.filter),
+              orderBy:
+                read && (f.isOrderable ?? intermediateLists[listKey].graphql.isEnabled.orderBy),
+            };
+            const field = {
+              ...f,
+              access: parseFieldAccessControl(f.access),
+              hooks: f.hooks ?? {},
+              graphql: { cacheHint: f.graphql?.cacheHint, isEnabled: _isEnabled },
+              input: { ...f.input },
+            };
+
+            return [fieldKey, field];
+          })
+        ),
+        ...intermediateLists[listKey],
+        ...getNamesFromList(listKey, list),
+        hooks: list.hooks,
+        access: parseListAccessControl(list.access),
+        dbMap: list.db?.map,
+        types: listGraphqlTypes[listKey].types,
+      },
+    ])
+  );
+}
+
+function getListGraphqlTypes(
+  listsConfig: KeystoneConfig['lists'],
+  lists: Record<string, InitialisedList>,
+  intermediateLists: Record<string, { graphql: { isEnabled: IsEnabled } }>
+): Record<string, ListGraphQLTypes> {
+  const graphQLTypes: Record<string, ListGraphQLTypes> = {};
+
   for (const [listKey, listConfig] of Object.entries(listsConfig)) {
     const names = getGqlNames({
       listKey,
       pluralGraphQLName: getNamesFromList(listKey, listConfig).pluralGraphQLName,
     });
 
-    let output = graphql.object<BaseItem>()({
+    const output = graphql.object<BaseItem>()({
       name: names.outputTypeName,
       fields: () => {
         const { fields } = lists[listKey];
@@ -152,7 +215,8 @@ export function initialiseLists(config: KeystoneConfig): Record<string, Initiali
               if (
                 !field.output ||
                 !field.graphql.isEnabled.read ||
-                (field.dbField.kind === 'relation' && !isEnabled[field.dbField.list].query)
+                (field.dbField.kind === 'relation' &&
+                  !intermediateLists[field.dbField.list].graphql.isEnabled.query)
               ) {
                 return [];
               }
@@ -274,15 +338,15 @@ export function initialiseLists(config: KeystoneConfig): Record<string, Initiali
       skip: graphql.arg({ type: graphql.nonNull(graphql.Int), defaultValue: 0 }),
     };
 
-    const _isEnabled = isEnabled[listKey];
+    const isEnabled = intermediateLists[listKey].graphql.isEnabled;
     let relateToManyForCreate, relateToManyForUpdate, relateToOneForCreate, relateToOneForUpdate;
-    if (_isEnabled.type) {
+    if (isEnabled.type) {
       relateToManyForCreate = graphql.inputObject({
         name: names.relateToManyForCreateInputName,
         fields: () => {
           return {
             // Create via a relationship is only supported if this list allows create
-            ...(_isEnabled.create && {
+            ...(isEnabled.create && {
               create: graphql.arg({ type: graphql.list(graphql.nonNull(create)) }),
             }),
             connect: graphql.arg({ type: graphql.list(graphql.nonNull(uniqueWhere)) }),
@@ -299,7 +363,7 @@ export function initialiseLists(config: KeystoneConfig): Record<string, Initiali
             disconnect: graphql.arg({ type: graphql.list(graphql.nonNull(uniqueWhere)) }),
             set: graphql.arg({ type: graphql.list(graphql.nonNull(uniqueWhere)) }),
             // Create via a relationship is only supported if this list allows create
-            ...(_isEnabled.create && {
+            ...(isEnabled.create && {
               create: graphql.arg({ type: graphql.list(graphql.nonNull(create)) }),
             }),
             connect: graphql.arg({ type: graphql.list(graphql.nonNull(uniqueWhere)) }),
@@ -312,7 +376,7 @@ export function initialiseLists(config: KeystoneConfig): Record<string, Initiali
         fields: () => {
           return {
             // Create via a relationship is only supported if this list allows create
-            ...(_isEnabled.create && { create: graphql.arg({ type: create }) }),
+            ...(isEnabled.create && { create: graphql.arg({ type: create }) }),
             connect: graphql.arg({ type: uniqueWhere }),
           };
         },
@@ -323,14 +387,15 @@ export function initialiseLists(config: KeystoneConfig): Record<string, Initiali
         fields: () => {
           return {
             // Create via a relationship is only supported if this list allows create
-            ...(_isEnabled.create && { create: graphql.arg({ type: create }) }),
+            ...(isEnabled.create && { create: graphql.arg({ type: create }) }),
             connect: graphql.arg({ type: uniqueWhere }),
             disconnect: graphql.arg({ type: graphql.Boolean }),
           };
         },
       });
     }
-    listInfos[listKey] = {
+
+    graphQLTypes[listKey] = {
       types: {
         output,
         uniqueWhere,
@@ -358,115 +423,97 @@ export function initialiseLists(config: KeystoneConfig): Record<string, Initiali
     };
   }
 
-  const listsWithInitialisedFields = Object.fromEntries(
-    Object.entries(listsConfig).map(([listKey, list]) => [
-      listKey,
-      {
-        fields: Object.fromEntries(
-          Object.entries(list.fields).map(([fieldKey, fieldFunc]) => {
-            if (typeof fieldFunc !== 'function') {
-              throw new Error(`The field at ${listKey}.${fieldKey} does not provide a function`);
-            }
-            const f = fieldFunc({
-              fieldKey,
-              listKey,
-              lists: listInfos,
-              provider,
-              getStorage: storage => config.storage?.[storage],
-            });
+  return graphQLTypes;
+}
 
-            const omit = f.graphql?.omit;
-            const read = omit !== true && !omit?.includes('read');
+/**
+ * 1. Get the `isEnabled` config object from the listConfig - the returned object will be modified later
+ * 2. Instantiate `lists` object - it is done here as the object will be added to the listGraphqlTypes
+ * 3. Get graphqlTypes
+ * 4. Initialise fields - field functions are called
+ * 5. Handle relationships - ensure correct linking between two sides of all relationships (including one-sided relationships)
+ * 6.
+ */
+export function initialiseLists(config: KeystoneConfig): Record<string, InitialisedList> {
+  const listsConfig = config.lists;
 
-            // We explicity check for boolean values here to ensure the dev hasn't made a mistake
-            // when defining these values. We avoid duck-typing here as this is security related
-            // and we want to make it hard to write incorrect code.
-            if (!['boolean', 'function', 'undefined'].includes(typeof f.isFilterable)) {
-              throw new Error(
-                `Configuration option '${listKey}.${fieldKey}.isFilterable' must be either a boolean value or a function. Recieved '${typeof f.isFilterable}'.`
-              );
-            }
-            if (!['boolean', 'function', 'undefined'].includes(typeof f.isOrderable)) {
-              throw new Error(
-                `Configuration option '${listKey}.${fieldKey}.isOrderable' must be either a boolean value or a function. Recieved '${typeof f.isOrderable}'.`
-              );
-            }
+  let intermediateLists;
 
-            const _isEnabled = {
-              read,
-              update: omit !== true && !omit?.includes('update'),
-              create: omit !== true && !omit?.includes('create'),
-              // Filter and orderBy can be defaulted at the list level, otherwise they
-              // default to `false` if no value was set at the list level.
-              filter: read && (f.isFilterable ?? isEnabled[listKey].filter),
-              orderBy: read && (f.isOrderable ?? isEnabled[listKey].orderBy),
-            };
-            const field = {
-              ...f,
-              graphql: { ...f.graphql, isEnabled: _isEnabled },
-              input: { ...f.input },
-            };
-
-            return [fieldKey, field];
-          })
-        ),
-        ...getNamesFromList(listKey, list),
-        hooks: list.hooks,
-        access: list.access,
-        dbMap: list.db?.map,
-      },
+  intermediateLists = Object.fromEntries(
+    Object.entries(getIsEnabled(listsConfig)).map(([key, isEnabled]) => [
+      key,
+      { graphql: { isEnabled } },
     ])
   );
 
-  const listsWithResolvedDBFields = resolveRelationships(listsWithInitialisedFields);
-
-  const listsWithInitialisedFieldsAndResolvedDbFields = Object.fromEntries(
-    Object.entries(listsWithInitialisedFields).map(([listKey, list]) => {
-      let hasAnEnabledCreateField = false;
-      let hasAnEnabledUpdateField = false;
-      const fields = Object.fromEntries(
-        Object.entries(list.fields).map(([fieldKey, field]) => {
-          if (field.input?.create?.arg && field.graphql.isEnabled.create) {
-            hasAnEnabledCreateField = true;
-          }
-          if (field.input?.update && field.graphql.isEnabled.update) {
-            hasAnEnabledUpdateField = true;
-          }
-          const access = parseFieldAccessControl(field.access);
-          const dbField = listsWithResolvedDBFields[listKey].resolvedDbFields[fieldKey];
-          return [
-            fieldKey,
-            { ...field, access, dbField, hooks: field.hooks ?? {}, graphql: field.graphql },
-          ];
-        })
+  /**
+   * Lists is instantiated here so that it can be passed into the `getListGraphqlTypes` function
+   * This function attaches this list object to the various graphql functions
+   *
+   * The object will be populated at the end of this function, and the reference will be maintained
+   */
+  const listsRef: Record<string, InitialisedList> = {};
+  /** Block statements to contain variables only being used within them */
+  {
+    const listGraphqlTypes = getListGraphqlTypes(listsConfig, listsRef, intermediateLists);
+    intermediateLists = getListsWithInitialisedFields(config, listGraphqlTypes, intermediateLists);
+  }
+  {
+    const resolvedDBFieldsForLists = resolveRelationships(intermediateLists);
+    intermediateLists = Object.fromEntries(
+      Object.entries(intermediateLists).map(([listKey, blah]) => [
+        listKey,
+        { ...blah, resolvedDbFields: resolvedDBFieldsForLists[listKey] },
+      ])
+    );
+  }
+
+  intermediateLists = Object.fromEntries(
+    Object.entries(intermediateLists).map(([listKey, list]) => {
+      const fields: Record<string, InitialisedField> = Object.fromEntries(
+        Object.entries(list.fields).map(([fieldKey, field]) => [
+          fieldKey,
+          { ...field, dbField: list.resolvedDbFields[fieldKey] },
+        ])
       );
-      const access = parseListAccessControl(list.access);
-      // You can't have a graphQL type with no fields, so
-      // if they're all disabled, we have to disable the whole operation.
-      if (!hasAnEnabledCreateField) {
-        isEnabled[listKey].create = false;
-      }
-      if (!hasAnEnabledUpdateField) {
-        isEnabled[listKey].update = false;
-      }
-      return [listKey, { ...list, access, fields, graphql: { isEnabled: isEnabled[listKey] } }];
+      return [listKey, { ...list, fields }];
     })
   );
 
-  for (const [listKey, { fields }] of Object.entries(
-    listsWithInitialisedFieldsAndResolvedDbFields
-  )) {
-    assertFieldsValid({ listKey, fields });
+  for (const list of Object.values(intermediateLists)) {
+    let hasAnEnabledCreateField = false;
+    let hasAnEnabledUpdateField = false;
+
+    for (const field of Object.values(list.fields)) {
+      if (field.input?.create?.arg && field.graphql.isEnabled.create) {
+        hasAnEnabledCreateField = true;
+      }
+      if (field.input?.update && field.graphql.isEnabled.update) {
+        hasAnEnabledUpdateField = true;
+      }
+    }
+    // You can't have a graphQL type with no fields, so
+    // if they're all disabled, we have to disable the whole operation.
+    if (!hasAnEnabledCreateField) {
+      list.graphql.isEnabled.create = false;
+    }
+    if (!hasAnEnabledUpdateField) {
+      list.graphql.isEnabled.update = false;
+    }
   }
 
-  const lists: Record<string, InitialisedList> = {};
+  /*
+    Error checking
+    */
+  for (const [listKey, { fields }] of Object.entries(intermediateLists)) {
+    assertFieldsValid({ listKey, fields });
+  }
 
-  for (const [listKey, list] of Object.entries(listsWithInitialisedFieldsAndResolvedDbFields)) {
-    lists[listKey] = {
-      ...list,
-      ...listInfos[listKey],
-      ...listsWithResolvedDBFields[listKey],
-      hooks: list.hooks || {},
+  for (const [listKey, intermediateList] of Object.entries(intermediateLists)) {
+    listsRef[listKey] = {
+      ...intermediateList,
+      /** These properties weren't related to any of the above actions but need to be here */
+      hooks: intermediateList.hooks || {},
       cacheHint: (() => {
         const cacheHint = listsConfig[listKey].graphql?.cacheHint;
         if (cacheHint === undefined) {
@@ -476,9 +523,10 @@ export function initialiseLists(config: KeystoneConfig): Record<string, Initiali
       })(),
       maxResults: listsConfig[listKey].graphql?.queryLimits?.maxResults ?? Infinity,
       listKey,
-      lists,
+      /** Add self-reference */
+      lists: listsRef,
     };
   }
 
-  return lists;
+  return listsRef;
 }
diff --git a/packages/fields-document/src/DocumentEditor/component-blocks/document-features-normalization.test.tsx b/packages/fields-document/src/DocumentEditor/component-blocks/document-features-normalization.test.tsx
index dc31ef848..1764f6667 100644
--- a/packages/fields-document/src/DocumentEditor/component-blocks/document-features-normalization.test.tsx
+++ b/packages/fields-document/src/DocumentEditor/component-blocks/document-features-normalization.test.tsx
@@ -9,11 +9,15 @@ import { ChildField } from './api';
 
 const cases: Record<
   string,
-  { schema: ChildField; children: Node | Node[]; expectedNormalized?: Node }
+  { schema: ChildField; children: Node | Node[] } & (
+    | { kind: 'allowed' }
+    | { kind: 'not-allowed'; expectedNormalized: Node }
+  )
 > = {
   'mark where it should not exist in inline': {
     schema: fields.child({ kind: 'inline', placeholder: '' }),
     children: <text bold>this should not be bold</text>,
+    kind: 'not-allowed',
     expectedNormalized: <text>this should not be bold</text>,
   },
   'mark where it should not exist in block': {
@@ -23,6 +27,7 @@ const cases: Record<
         <text bold>this should not be bold</text>
       </paragraph>
     ),
+    kind: 'not-allowed',
     expectedNormalized: (
       <paragraph>
         <text>this should not be bold</text>
@@ -32,6 +37,7 @@ const cases: Record<
   'mark where it is is allowed in inline': {
     schema: fields.child({ kind: 'inline', placeholder: '', formatting: 'inherit' }),
     children: <text bold>this should be bold</text>,
+    kind: 'allowed',
   },
   'code block where it is not allowed in a block': {
     schema: fields.child({ kind: 'block', placeholder: '' }),
@@ -40,6 +46,7 @@ const cases: Record<
         <text>this should not be in a code block</text>
       </code>
     ),
+    kind: 'not-allowed',
     expectedNormalized: (
       <paragraph>
         <text>this should not be in a code block</text>
@@ -53,6 +60,7 @@ const cases: Record<
         <text>this should not be in a code block</text>
       </code>
     ),
+    kind: 'allowed',
   },
   'links allowed': {
     schema: fields.child({ kind: 'block', placeholder: '', links: 'inherit' }),
@@ -65,6 +73,7 @@ const cases: Record<
         <text> stuff</text>
       </paragraph>
     ),
+    kind: 'allowed',
   },
   'links not allowed': {
     schema: fields.child({ kind: 'block', placeholder: '' }),
@@ -82,6 +91,7 @@ const cases: Record<
         <text>some text not in a link (https://example.com) stuff</text>
       </paragraph>
     ),
+    kind: 'not-allowed',
   },
   'links allowed in inline': {
     schema: fields.child({ kind: 'inline', placeholder: '', links: 'inherit' }),
@@ -92,6 +102,7 @@ const cases: Record<
       </link>,
       <text> stuff</text>,
     ],
+    kind: 'allowed',
   },
   'links not allowed in inline': {
     schema: fields.child({ kind: 'inline', placeholder: '' }),
@@ -103,6 +114,7 @@ const cases: Record<
       <text> stuff</text>,
     ],
     expectedNormalized: <text>some text not in a link (https://example.com) stuff</text>,
+    kind: 'not-allowed',
   },
   'relationship allowed': {
     schema: fields.child({ kind: 'block', placeholder: '', relationships: 'inherit' }),
@@ -122,6 +134,7 @@ const cases: Record<
         <text> stuff</text>
       </paragraph>
     ),
+    kind: 'allowed',
   },
   'relationship not allowed': {
     schema: fields.child({ kind: 'block', placeholder: '' }),
@@ -146,6 +159,7 @@ const cases: Record<
         <text>some text Someone (Mention:5f6a9d7ec229fe1621532769) stuff</text>
       </paragraph>
     ),
+    kind: 'not-allowed',
   },
   'alignment allowed': {
     schema: fields.child({ kind: 'block', placeholder: '', formatting: { alignment: 'inherit' } }),
@@ -154,6 +168,7 @@ const cases: Record<
         <text>some text </text>
       </paragraph>
     ),
+    kind: 'allowed',
   },
   'alignment not allowed': {
     schema: fields.child({ kind: 'block', placeholder: '' }),
@@ -167,6 +182,7 @@ const cases: Record<
         <text>some text </text>
       </paragraph>
     ),
+    kind: 'not-allowed',
   },
   'divider allowed': {
     schema: fields.child({ kind: 'block', placeholder: '', dividers: 'inherit' }),
@@ -178,6 +194,7 @@ const cases: Record<
         <text />
       </divider>,
     ],
+    kind: 'allowed',
   },
   'divider not allowed': {
     schema: fields.child({ kind: 'block', placeholder: '' }),
@@ -194,6 +211,8 @@ const cases: Record<
         <text>some text </text>
       </paragraph>
     ),
+
+    kind: 'not-allowed',
   },
   'soft breaks allowed': {
     schema: fields.child({ kind: 'block', placeholder: '', formatting: { softBreaks: 'inherit' } }),
@@ -202,6 +221,7 @@ const cases: Record<
         <text>some{'\n'} text </text>
       </paragraph>
     ),
+    kind: 'allowed',
   },
   'soft breaks not allowed': {
     schema: fields.child({ kind: 'block', placeholder: '' }),
@@ -218,6 +238,7 @@ const cases: Record<
         <text>some text s</text>
       </paragraph>
     ),
+    kind: 'not-allowed',
   },
 };
 
@@ -229,7 +250,7 @@ function makeEditorWithChildField(
   const Prop = `component-${childField.options.kind}-prop` as const;
   return makeEditor(
     <editor>
-      <component-block component={'comp'} props={{ child: null }}>
+      <component-block component={'comp'} props={{}}>
         <Prop propPath={['child']}>{children}</Prop>
       </component-block>
       <paragraph>
@@ -259,13 +280,13 @@ Object.keys(cases).forEach(key => {
     let editor = makeEditorWithChildField(
       testCase.schema,
       testCase.children,
-      testCase.expectedNormalized === undefined ? 'disallow-non-normalized' : 'normalize'
+      testCase.kind === 'allowed' ? 'disallow-non-normalized' : 'normalize'
     );
-    if (testCase.expectedNormalized !== undefined) {
+    if (testCase.kind === 'not-allowed') {
       expect(editor).toEqualEditor(
         makeEditor(
           <editor>
-            <component-block component={'comp'} props={{ child: null }}>
+            <component-block component={'comp'} props={{}}>
               <Prop propPath={['child']}>{testCase.expectedNormalized}</Prop>
             </component-block>
             <paragraph>
@@ -291,11 +312,7 @@ test('mark disabled in inline prop', () => {
     <editor>
       <component-block
         component="comp"
-        props={
-          Object {
-            "child": null,
-          }
-        }
+        props={Object {}}
       >
         <component-inline-prop
           propPath={
@@ -332,11 +349,7 @@ test('mark enabled in inline prop', () => {
     <editor>
       <component-block
         component="comp"
-        props={
-          Object {
-            "child": null,
-          }
-        }
+        props={Object {}}
       >
         <component-inline-prop
           propPath={
@@ -377,11 +390,7 @@ test('mark disabled in block prop', () => {
     <editor>
       <component-block
         component="comp"
-        props={
-          Object {
-            "child": null,
-          }
-        }
+        props={Object {}}
       >
         <component-block-prop
           propPath={
@@ -422,11 +431,7 @@ test('mark enabled in block prop', () => {
     <editor>
       <component-block
         component="comp"
-        props={
-          Object {
-            "child": null,
-          }
-        }
+        props={Object {}}
       >
         <component-block-prop
           propPath={
@@ -469,11 +474,7 @@ test('heading disabled in block prop', () => {
     <editor>
       <component-block
         component="comp"
-        props={
-          Object {
-            "child": null,
-          }
-        }
+        props={Object {}}
       >
         <component-block-prop
           propPath={
@@ -514,11 +515,7 @@ test('heading enabled in block prop', () => {
     <editor>
       <component-block
         component="comp"
-        props={
-          Object {
-            "child": null,
-          }
-        }
+        props={Object {}}
       >
         <component-block-prop
           propPath={
diff --git a/packages/fields-document/src/DocumentEditor/component-blocks/insert-break-and-delete.test.tsx b/packages/fields-document/src/DocumentEditor/component-blocks/insert-break-and-delete.test.tsx
index c20cb408d..796eae0b3 100644
--- a/packages/fields-document/src/DocumentEditor/component-blocks/insert-break-and-delete.test.tsx
+++ b/packages/fields-document/src/DocumentEditor/component-blocks/insert-break-and-delete.test.tsx
@@ -46,10 +46,7 @@ const componentBlocks = {
 test('delete backward at start', () => {
   let editor = makeEditor(
     <editor>
-      <component-block
-        component="withChildElements"
-        props={{ prop: '', block: null, inline: null }}
-      >
+      <component-block component="withChildElements" props={{ prop: '' }}>
         <component-block-prop propPath={['block']}>
           <paragraph>
             <text>
@@ -94,10 +91,7 @@ test('delete backward at start', () => {
 test('insert break in last (inline) child prop', () => {
   let editor = makeEditor(
     <editor>
-      <component-block
-        component="withChildElements"
-        props={{ prop: '', block: null, inline: null }}
-      >
+      <component-block component="withChildElements" props={{ prop: '' }}>
         <component-block-prop propPath={['block']}>
           <paragraph>
             <text>some text</text>
@@ -123,8 +117,6 @@ test('insert break in last (inline) child prop', () => {
         component="withChildElements"
         props={
           Object {
-            "block": null,
-            "inline": null,
             "prop": "",
           }
         }
@@ -172,10 +164,7 @@ test('insert break in last (inline) child prop', () => {
 test('insert break in first (block) child prop in empty paragraph', () => {
   let editor = makeEditor(
     <editor>
-      <component-block
-        component="withChildElements"
-        props={{ prop: '', block: null, inline: null }}
-      >
+      <component-block component="withChildElements" props={{ prop: '' }}>
         <component-block-prop propPath={['block']}>
           <paragraph>
             <text>some text</text>
@@ -203,8 +192,6 @@ test('insert break in first (block) child prop in empty paragraph', () => {
         component="withChildElements"
         props={
           Object {
-            "block": null,
-            "inline": null,
             "prop": "",
           }
         }
@@ -247,10 +234,7 @@ test('insert break in first (block) child prop in empty paragraph', () => {
 test('insert break in last (block) child prop in empty paragraph', () => {
   let editor = makeEditor(
     <editor>
-      <component-block
-        component="withChildElementsBlockLast"
-        props={{ prop: '', block: null, inline: null }}
-      >
+      <component-block component="withChildElementsBlockLast" props={{ prop: '' }}>
         <component-inline-prop propPath={['inline']}>
           <text>some more text</text>
         </component-inline-prop>
@@ -278,8 +262,6 @@ test('insert break in last (block) child prop in empty paragraph', () => {
         component="withChildElementsBlockLast"
         props={
           Object {
-            "block": null,
-            "inline": null,
             "prop": "",
           }
         }
@@ -326,10 +308,7 @@ test('insert break in last (block) child prop in empty paragraph', () => {
 test('insert break in first (inline) child prop', () => {
   let editor = makeEditor(
     <editor>
-      <component-block
-        component="withChildElementsBlockLast"
-        props={{ prop: '', block: null, inline: null }}
-      >
+      <component-block component="withChildElementsBlockLast" props={{ prop: '' }}>
         <component-inline-prop propPath={['inline']}>
           <text>
             some more
@@ -355,8 +334,6 @@ test('insert break in first (inline) child prop', () => {
         component="withChildElementsBlockLast"
         props={
           Object {
-            "block": null,
-            "inline": null,
             "prop": "",
           }
         }
diff --git a/packages/fields-document/src/DocumentEditor/component-blocks/insertion-and-preview-props.test.tsx b/packages/fields-document/src/DocumentEditor/component-blocks/insertion-and-preview-props.test.tsx
index 159e041a2..4de3974e5 100644
--- a/packages/fields-document/src/DocumentEditor/component-blocks/insertion-and-preview-props.test.tsx
+++ b/packages/fields-document/src/DocumentEditor/component-blocks/insertion-and-preview-props.test.tsx
@@ -191,7 +191,6 @@ const makeEditorWithComplexComponentBlock = () =>
         component="complex"
         props={{
           object: {
-            block: null,
             conditional: {
               discriminant: false,
               value: null,
@@ -202,7 +201,6 @@ const makeEditorWithComplexComponentBlock = () =>
               discriminant: 'a',
               value: '',
             },
-            inline: null,
             many: [],
           },
         }}
@@ -313,7 +311,6 @@ test('preview props conditional change', () => {
         props={
           Object {
             "object": Object {
-              "block": null,
               "conditional": Object {
                 "discriminant": true,
                 "value": null,
@@ -322,7 +319,6 @@ test('preview props conditional change', () => {
                 "discriminant": "a",
                 "value": "",
               },
-              "inline": null,
               "many": Array [],
               "prop": "",
               "select": "a",
diff --git a/packages/fields-document/src/DocumentEditor/component-blocks/normalization.test.tsx b/packages/fields-document/src/DocumentEditor/component-blocks/normalization.test.tsx
index 285558006..7618c57ae 100644
--- a/packages/fields-document/src/DocumentEditor/component-blocks/normalization.test.tsx
+++ b/packages/fields-document/src/DocumentEditor/component-blocks/normalization.test.tsx
@@ -260,10 +260,7 @@ test('extra component props are removed', () => {
       <paragraph>
         <text />
       </paragraph>
-      <component-block
-        component="withChildElements"
-        props={{ prop: '', block: null, inline: null }}
-      >
+      <component-block component="withChildElements" props={{ prop: '' }}>
         <component-block-prop propPath={['block']}>
           <paragraph>
             <text>
@@ -300,8 +297,6 @@ test('extra component props are removed', () => {
         component="withChildElements"
         props={
           Object {
-            "block": null,
-            "inline": null,
             "prop": "",
           }
         }
@@ -343,7 +338,7 @@ test('extra component props are removed', () => {
 test('missing component props are added', () => {
   let editor = makeEditor(
     <editor>
-      <component-block component="withChildElements" props={{ prop: '', block: null }}>
+      <component-block component="withChildElements" props={{ prop: '' }}>
         <component-block-prop propPath={['block']}>
           <paragraph>
             <text>
@@ -364,8 +359,6 @@ test('missing component props are added', () => {
         component="withChildElements"
         props={
           Object {
-            "block": null,
-            "inline": null,
             "prop": "",
           }
         }
@@ -430,8 +423,6 @@ test('prop with wrong type for a given prop path', () => {
         component="withChildElements"
         props={
           Object {
-            "block": null,
-            "inline": null,
             "prop": "",
           }
         }
@@ -474,10 +465,7 @@ test('prop with wrong type for a given prop path', () => {
 test('props in wrong order', () => {
   let editor = makeEditor(
     <editor>
-      <component-block
-        component="withLotsOfChildElements"
-        props={{ last: null, block: null, inline: null }}
-      >
+      <component-block component="withLotsOfChildElements" props={{}}>
         <component-block-prop propPath={['last']}>
           <paragraph>
             <text />
@@ -502,13 +490,7 @@ test('props in wrong order', () => {
     <editor>
       <component-block
         component="withLotsOfChildElements"
-        props={
-          Object {
-            "block": null,
-            "inline": null,
-            "last": null,
-          }
-        }
+        props={Object {}}
       >
         <component-block-prop
           propPath={
@@ -560,7 +542,7 @@ test('props in wrong order', () => {
 test('toggling to heading when in an inline prop', () => {
   const editor = makeEditor(
     <editor>
-      <component-block component="inline" props={{ child: null, other: null }}>
+      <component-block component="inline" props={{}}>
         <component-inline-prop propPath={['child']}>
           <text>
             some
@@ -596,12 +578,7 @@ test('toggling to heading when in an inline prop', () => {
     <editor>
       <component-block
         component="inline"
-        props={
-          Object {
-            "child": null,
-            "other": null,
-          }
-        }
+        props={Object {}}
       >
         <component-inline-prop
           propPath={
@@ -914,52 +891,3 @@ test('child field in array field deleteBackward in middle', () => {
     </editor>
   `);
 });
-
-test('normalization adds missing fields on object fields', () => {
-  const editor = makeEditor(
-    <editor>
-      <component-block component="basic" props={{ a: '' }}>
-        <component-inline-prop>
-          <text />
-        </component-inline-prop>
-      </component-block>
-      <paragraph>
-        <text />
-      </paragraph>
-    </editor>,
-    {
-      normalization: 'normalize',
-      componentBlocks: {
-        basic: component({
-          preview: () => null,
-          label: 'Basic',
-          schema: { a: fields.text({ label: 'A' }), b: fields.checkbox({ label: 'B' }) },
-        }),
-      },
-    }
-  );
-  expect(editor).toMatchInlineSnapshot(`
-    <editor>
-      <component-block
-        component="basic"
-        props={
-          Object {
-            "a": "",
-            "b": false,
-          }
-        }
-      >
-        <component-inline-prop>
-          <text>
-            
-          </text>
-        </component-inline-prop>
-      </component-block>
-      <paragraph>
-        <text>
-          
-        </text>
-      </paragraph>
-    </editor>
-  `);
-});
diff --git a/packages/fields-document/src/DocumentEditor/component-blocks/with-component-blocks.tsx b/packages/fields-document/src/DocumentEditor/component-blocks/with-component-blocks.tsx
index 626ce4942..1c9ae7423 100644
--- a/packages/fields-document/src/DocumentEditor/component-blocks/with-component-blocks.tsx
+++ b/packages/fields-document/src/DocumentEditor/component-blocks/with-component-blocks.tsx
@@ -311,197 +311,194 @@ export function withComponentBlocks(
 
   editor.normalizeNode = entry => {
     const [node, path] = entry;
-    if (
-      node.type === 'component-inline-prop' &&
-      !node.propPath &&
-      (node.children.length !== 1 || !Text.isText(node.children[0]) || node.children[0].text !== '')
-    ) {
-      Transforms.removeNodes(editor, {
-        at: path,
-      });
-      return;
-    }
-
-    if (node.type === 'component-block') {
-      const componentBlock = blockComponents[node.component];
-      if (componentBlock) {
-        const rootSchema = { kind: 'object' as const, fields: componentBlock.schema };
-
-        const updatedProps = addMissingFields(node.props, rootSchema) as Record<string, unknown>;
-        if (updatedProps !== node.props) {
-          Transforms.setNodes(editor, { props: updatedProps }, { at: path });
-          return;
-        }
+    if (Element.isElement(node) || Editor.isEditor(node)) {
+      if (
+        node.type === 'component-inline-prop' &&
+        !node.propPath &&
+        (node.children.length !== 1 ||
+          !Text.isText(node.children[0]) ||
+          node.children[0].text !== '')
+      ) {
+        Transforms.removeNodes(editor, {
+          at: path,
+        });
+        return;
+      }
 
-        for (const [propPath, arrayField] of findArrayFieldsWithSingleChildField(
-          rootSchema,
-          node.props
-        )) {
-          if (
-            node.children.length === 1 &&
-            node.children[0].type === 'component-inline-prop' &&
-            node.children[0].propPath === undefined
-          ) {
-            break;
-          }
-          const nodesWithin: [
-            number,
-            Element & { type: 'component-block-prop' | 'component-inline-prop' }
-          ][] = [];
-          for (const [idx, childNode] of node.children.entries()) {
+      if (Element.isElement(node) && node.type === 'component-block') {
+        const componentBlock = blockComponents[node.component];
+        if (componentBlock) {
+          const rootSchema = { kind: 'object' as const, fields: componentBlock.schema };
+          for (const [propPath, arrayField] of findArrayFieldsWithSingleChildField(
+            rootSchema,
+            node.props
+          )) {
             if (
-              (childNode.type === 'component-block-prop' ||
-                childNode.type === 'component-inline-prop') &&
-              childNode.propPath !== undefined
+              node.children.length === 1 &&
+              node.children[0].type === 'component-inline-prop' &&
+              node.children[0].propPath === undefined
             ) {
-              const subPath = childNode.propPath.concat();
-              while (subPath.length) {
-                if (typeof subPath.pop() === 'number') break;
-              }
+              break;
+            }
+            const nodesWithin: [
+              number,
+              Element & { type: 'component-block-prop' | 'component-inline-prop' }
+            ][] = [];
+            for (const [idx, childNode] of node.children.entries()) {
+              if (
+                (childNode.type === 'component-block-prop' ||
+                  childNode.type === 'component-inline-prop') &&
+                childNode.propPath !== undefined
+              ) {
+                const subPath = childNode.propPath.concat();
+                while (subPath.length) {
+                  if (typeof subPath.pop() === 'number') break;
+                }
 
-              if (areArraysEqual(propPath, subPath)) {
-                nodesWithin.push([idx, childNode]);
+                if (areArraysEqual(propPath, subPath)) {
+                  nodesWithin.push([idx, childNode]);
+                }
               }
             }
-          }
-          const arrVal = getValueAtPropPath(node.props, propPath) as unknown[];
-          const prevKeys = getKeysForArrayValue(arrVal);
-          const prevKeysSet = new Set(prevKeys);
-          const alreadyUsedIndicies = new Set<number>();
-          const newVal: unknown[] = [];
-          const newKeys: string[] = [];
-          const getNewKey = () => {
-            let key = getNewArrayElementKey();
-            while (prevKeysSet.has(key)) {
-              key = getNewArrayElementKey();
+            const arrVal = getValueAtPropPath(node.props, propPath) as unknown[];
+            const prevKeys = getKeysForArrayValue(arrVal);
+            const prevKeysSet = new Set(prevKeys);
+            const alreadyUsedIndicies = new Set<number>();
+            const newVal: unknown[] = [];
+            const newKeys: string[] = [];
+            const getNewKey = () => {
+              let key = getNewArrayElementKey();
+              while (prevKeysSet.has(key)) {
+                key = getNewArrayElementKey();
+              }
+              return key;
+            };
+            for (const [, node] of nodesWithin) {
+              const idxFromValue = node.propPath![propPath.length];
+              assert(typeof idxFromValue === 'number');
+              if (
+                arrVal.length <= idxFromValue ||
+                (alreadyUsedIndicies.has(idxFromValue) && isEmptyChildFieldNode(node))
+              ) {
+                newVal.push(getInitialPropsValue(arrayField.element));
+                newKeys.push(getNewKey());
+              } else {
+                alreadyUsedIndicies.add(idxFromValue);
+                newVal.push(arrVal[idxFromValue]);
+                newKeys.push(
+                  alreadyUsedIndicies.has(idxFromValue) ? getNewKey() : prevKeys[idxFromValue]
+                );
+              }
             }
-            return key;
-          };
-          for (const [, node] of nodesWithin) {
-            const idxFromValue = node.propPath![propPath.length];
-            assert(typeof idxFromValue === 'number');
-            if (
-              arrVal.length <= idxFromValue ||
-              (alreadyUsedIndicies.has(idxFromValue) && isEmptyChildFieldNode(node))
-            ) {
-              newVal.push(getInitialPropsValue(arrayField.element));
-              newKeys.push(getNewKey());
-            } else {
-              alreadyUsedIndicies.add(idxFromValue);
-              newVal.push(arrVal[idxFromValue]);
-              newKeys.push(
-                alreadyUsedIndicies.has(idxFromValue) ? getNewKey() : prevKeys[idxFromValue]
+            setKeysForArrayValue(newVal, newKeys);
+            if (!areArraysEqual(arrVal, newVal)) {
+              const transformedProps = replaceValueAtPropPath(
+                rootSchema,
+                node.props,
+                newVal,
+                propPath
               );
-            }
-          }
-          setKeysForArrayValue(newVal, newKeys);
-          if (!areArraysEqual(arrVal, newVal)) {
-            const transformedProps = replaceValueAtPropPath(
-              rootSchema,
-              node.props,
-              newVal,
-              propPath
-            );
-            Transforms.setNodes(
-              editor,
-              { props: transformedProps as Record<string, unknown> },
-              { at: path }
-            );
-            for (const [idx, [idxInChildrenOfBlock, nodeWithin]] of nodesWithin.entries()) {
-              const newPropPath = [...nodeWithin.propPath!];
-              newPropPath[propPath.length] = idx;
               Transforms.setNodes(
                 editor,
-                { propPath: newPropPath },
-                { at: [...path, idxInChildrenOfBlock] }
+                { props: transformedProps as Record<string, unknown> },
+                { at: path }
               );
+              for (const [idx, [idxInChildrenOfBlock, nodeWithin]] of nodesWithin.entries()) {
+                const newPropPath = [...nodeWithin.propPath!];
+                newPropPath[propPath.length] = idx;
+                Transforms.setNodes(
+                  editor,
+                  { propPath: newPropPath },
+                  { at: [...path, idxInChildrenOfBlock] }
+                );
+              }
+              return;
             }
-            return;
           }
-        }
-
-        const missingKeys = new Map(
-          findChildPropPaths(node.props, componentBlock.schema).map(x => [
-            JSON.stringify(x.path) as string | undefined,
-            x.options.kind,
-          ])
-        );
 
-        node.children.forEach(node => {
-          assert(node.type === 'component-block-prop' || node.type === 'component-inline-prop');
-          missingKeys.delete(JSON.stringify(node.propPath));
-        });
-        if (missingKeys.size) {
-          Transforms.insertNodes(
-            editor,
-            [...missingKeys].map(([prop, kind]) => ({
-              type: `component-${kind}-prop` as const,
-              propPath: prop ? JSON.parse(prop) : prop,
-              children: [{ text: '' }],
-            })),
-            { at: [...path, node.children.length] }
+          const missingKeys = new Map(
+            findChildPropPaths(node.props, componentBlock.schema).map(x => [
+              JSON.stringify(x.path) as string | undefined,
+              x.options.kind,
+            ])
           );
-          return;
-        }
 
-        const foundProps = new Set<string>();
-
-        const stringifiedInlinePropPaths: Record<
-          string,
-          { options: ChildField['options']; index: number } | undefined
-        > = {};
-        findChildPropPaths(node.props, blockComponents[node.component]!.schema).forEach(
-          (x, index) => {
-            stringifiedInlinePropPaths[JSON.stringify(x.path)] = { options: x.options, index };
+          node.children.forEach(node => {
+            assert(node.type === 'component-block-prop' || node.type === 'component-inline-prop');
+            missingKeys.delete(JSON.stringify(node.propPath));
+          });
+          if (missingKeys.size) {
+            Transforms.insertNodes(
+              editor,
+              [...missingKeys].map(([prop, kind]) => ({
+                type: `component-${kind}-prop` as const,
+                propPath: prop ? JSON.parse(prop) : prop,
+                children: [{ text: '' }],
+              })),
+              { at: [...path, node.children.length] }
+            );
+            return;
           }
-        );
 
-        for (const [index, childNode] of node.children.entries()) {
-          if (
-            // children that are not these will be handled by
-            // the generic allowedChildren normalization
-            childNode.type !== 'component-inline-prop' &&
-            childNode.type !== 'component-block-prop'
-          ) {
-            continue;
-          }
+          const foundProps = new Set<string>();
 
-          const childPath = [...path, index];
-          const stringifiedPropPath = JSON.stringify(childNode.propPath);
-          if (stringifiedInlinePropPaths[stringifiedPropPath] === undefined) {
-            Transforms.removeNodes(editor, { at: childPath });
-            return;
-          }
+          const stringifiedInlinePropPaths: Record<
+            string,
+            { options: ChildField['options']; index: number } | undefined
+          > = {};
+          findChildPropPaths(node.props, blockComponents[node.component]!.schema).forEach(
+            (x, index) => {
+              stringifiedInlinePropPaths[JSON.stringify(x.path)] = { options: x.options, index };
+            }
+          );
 
-          if (foundProps.has(stringifiedPropPath)) {
-            Transforms.removeNodes(editor, { at: childPath });
-            return;
-          }
+          for (const [index, childNode] of node.children.entries()) {
+            if (
+              // children that are not these will be handled by
+              // the generic allowedChildren normalization
+              childNode.type !== 'component-inline-prop' &&
+              childNode.type !== 'component-block-prop'
+            ) {
+              continue;
+            }
 
-          foundProps.add(stringifiedPropPath);
-          const propInfo = stringifiedInlinePropPaths[stringifiedPropPath]!;
-          const expectedIndex = propInfo.index;
-          if (index !== expectedIndex) {
-            Transforms.moveNodes(editor, { at: childPath, to: [...path, expectedIndex] });
-            return;
-          }
+            const childPath = [...path, index];
+            const stringifiedPropPath = JSON.stringify(childNode.propPath);
+            if (stringifiedInlinePropPaths[stringifiedPropPath] === undefined) {
+              Transforms.removeNodes(editor, { at: childPath });
+              return;
+            }
 
-          const expectedChildNodeType = `component-${propInfo.options.kind}-prop` as const;
-          if (childNode.type !== expectedChildNodeType) {
-            Transforms.setNodes(editor, { type: expectedChildNodeType }, { at: childPath });
-            return;
-          }
+            if (foundProps.has(stringifiedPropPath)) {
+              Transforms.removeNodes(editor, { at: childPath });
+              return;
+            }
 
-          const documentFeatures = memoizedGetDocumentFeaturesForChildField(propInfo.options);
-          if (
-            normalizeNodeWithinComponentProp(
-              [childNode, childPath],
-              editor,
-              documentFeatures,
-              relationships
-            )
-          ) {
-            return;
+            foundProps.add(stringifiedPropPath);
+            const propInfo = stringifiedInlinePropPaths[stringifiedPropPath]!;
+            const expectedIndex = propInfo.index;
+            if (index !== expectedIndex) {
+              Transforms.moveNodes(editor, { at: childPath, to: [...path, expectedIndex] });
+              return;
+            }
+
+            const expectedChildNodeType = `component-${propInfo.options.kind}-prop` as const;
+            if (childNode.type !== expectedChildNodeType) {
+              Transforms.setNodes(editor, { type: expectedChildNodeType }, { at: childPath });
+              return;
+            }
+
+            const documentFeatures = memoizedGetDocumentFeaturesForChildField(propInfo.options);
+            if (
+              normalizeNodeWithinComponentProp(
+                [childNode, childPath],
+                editor,
+                documentFeatures,
+                relationships
+              )
+            ) {
+              return;
+            }
           }
         }
       }
@@ -512,52 +509,3 @@ export function withComponentBlocks(
 
   return editor;
 }
-
-// the only thing that this will fix is a new field being added to an object field, nothing else.
-function addMissingFields(value: unknown, schema: ComponentSchema): unknown {
-  if (schema.kind === 'child' || schema.kind === 'form' || schema.kind === 'relationship') {
-    return value;
-  }
-  if (schema.kind === 'conditional') {
-    const conditionalValue = value as { discriminant: string | boolean; value: unknown };
-    const updatedInnerValue = addMissingFields(
-      conditionalValue.value,
-      schema.values[conditionalValue.discriminant.toString()]
-    );
-    if (updatedInnerValue === conditionalValue.value) {
-      return value;
-    }
-    return { discriminant: conditionalValue.value, value: updatedInnerValue };
-  }
-  if (schema.kind === 'array') {
-    const arrValue = value as unknown[];
-    const newArrValue = arrValue.map(x => addMissingFields(x, schema.element));
-    if (areArraysEqual(arrValue, newArrValue)) {
-      return value;
-    }
-    return newArrValue;
-  }
-  if (schema.kind === 'object') {
-    const objectValue = value as Record<string, unknown>;
-    let hasChanged = false;
-    const newObjectValue: Record<string, unknown> = {};
-    for (const [key, innerSchema] of Object.entries(schema.fields)) {
-      const innerValue = objectValue[key];
-      if (innerValue === undefined) {
-        hasChanged = true;
-        newObjectValue[key] = getInitialPropsValue(innerSchema);
-        continue;
-      }
-      const newInnerValue = addMissingFields(innerValue as Record<string, unknown>, innerSchema);
-      if (newInnerValue !== innerValue) {
-        hasChanged = true;
-      }
-      newObjectValue[key] = newInnerValue;
-    }
-    if (hasChanged) {
-      return newObjectValue;
-    }
-    return value;
-  }
-  assertNever(schema);
-}
diff --git a/packages/fields-document/src/DocumentEditor/insert-menu.test.tsx b/packages/fields-document/src/DocumentEditor/insert-menu.test.tsx
index ca025be38..140bbab7d 100644
--- a/packages/fields-document/src/DocumentEditor/insert-menu.test.tsx
+++ b/packages/fields-document/src/DocumentEditor/insert-menu.test.tsx
@@ -373,7 +373,8 @@ test('insertMenu thing typing', () => {
       <paragraph>
         <text />
       </paragraph>
-    </editor>
+    </editor>,
+    { normalization: 'normalize' }
   );
   [...'/thing'].forEach(char => {
     editor.insertText(char);
diff --git a/packages/fields-document/src/DocumentEditor/markdown-link-shortcut.test.tsx b/packages/fields-document/src/DocumentEditor/markdown-link-shortcut.test.tsx
index 6dafeb7e1..74783a399 100644
--- a/packages/fields-document/src/DocumentEditor/markdown-link-shortcut.test.tsx
+++ b/packages/fields-document/src/DocumentEditor/markdown-link-shortcut.test.tsx
@@ -249,7 +249,7 @@ test("link shortcut doesn't do anything when links are disabled globally in the
 test("link shortcut doesn't do anything when inside of a component block with links disabled", () => {
   let editor = makeEditor(
     <editor>
-      <component-block component="comp" props={{ child: null }}>
+      <component-block component="comp" props={{}}>
         <component-inline-prop propPath={['child']}>
           <text>
             [content](https://keystonejs.com
@@ -276,11 +276,7 @@ test("link shortcut doesn't do anything when inside of a component block with li
     <editor>
       <component-block
         component="comp"
-        props={
-          Object {
-            "child": null,
-          }
-        }
+        props={Object {}}
       >
         <component-inline-prop
           propPath={
@@ -306,7 +302,7 @@ test("link shortcut doesn't do anything when inside of a component block with li
 test('link shortcut works when inside of a component block with links option inherited', () => {
   let editor = makeEditor(
     <editor>
-      <component-block component="comp" props={{ child: null }}>
+      <component-block component="comp" props={{}}>
         <component-inline-prop propPath={['child']}>
           <text>
             [content](https://keystonejs.com
@@ -333,11 +329,7 @@ test('link shortcut works when inside of a component block with links option inh
     <editor>
       <component-block
         component="comp"
-        props={
-          Object {
-            "child": null,
-          }
-        }
+        props={Object {}}
       >
         <component-inline-prop
           propPath={
diff --git a/packages/fields-document/src/DocumentEditor/pasting/index.ts b/packages/fields-document/src/DocumentEditor/pasting/index.ts
index e5e22b500..cdb8f26cf 100644
--- a/packages/fields-document/src/DocumentEditor/pasting/index.ts
+++ b/packages/fields-document/src/DocumentEditor/pasting/index.ts
@@ -63,7 +63,8 @@ export function withPasting(editor: Editor): Editor {
       }
     }
 
-    const html = data.getData('text/html');
+    let html = data.getData('text/html');
+
     if (html) {
       const fragment = deserializeHTML(html);
       insertFragmentButDifferent(editor, fragment);
diff --git a/packages/fields-document/src/DocumentEditor/tests/utils.tsx b/packages/fields-document/src/DocumentEditor/tests/utils.tsx
index 2c5fb9e08..8fe41d82c 100644
--- a/packages/fields-document/src/DocumentEditor/tests/utils.tsx
+++ b/packages/fields-document/src/DocumentEditor/tests/utils.tsx
@@ -236,24 +236,22 @@ export const makeEditor = (
   if (editor.marks || (marks && Object.keys(marks).length)) {
     expect(marks).toEqual(editor.marks);
   }
-  // we need to make one of our editors because toEqualEditor expects the __config stuff to exist
-  // and if it fails, the snapshot serializer will be called to diff them which also expects __config
-  const makeEditorForComparison = (node: Node) =>
-    makeEditor(node, {
-      componentBlocks,
-      documentFeatures,
-      isShiftPressedRef: { current: false },
-      normalization: 'skip',
-      relationships,
-      skipRenderingDOM: true,
-    });
-  if (normalization === 'normalize') {
-    Editor.normalize(editor, { force: true });
-    expect(editor).not.toEqual(makeEditorForComparison(node));
-  }
-  if (normalization === 'disallow-non-normalized') {
+  if (normalization !== 'skip') {
     Editor.normalize(editor, { force: true });
-    expect(makeEditorForComparison(node)).toEqualEditor(editor);
+    if (normalization === 'disallow-non-normalized') {
+      expect(
+        // we need to make one of our editors because toEqualEditor expects the __config stuff to exist
+        // and if it fails, the snapshot serializer will be called to diff them which also expects __config
+        makeEditor(node, {
+          componentBlocks,
+          documentFeatures,
+          isShiftPressedRef,
+          normalization: 'skip',
+          relationships,
+          skipRenderingDOM,
+        })
+      ).toEqualEditor(editor);
+    }
   }
 
   if (skipRenderingDOM !== true) {
diff --git a/packages/fields-document/src/relationship-data.tsx b/packages/fields-document/src/relationship-data.tsx
index e4355d2b4..ea257fa10 100644
--- a/packages/fields-document/src/relationship-data.tsx
+++ b/packages/fields-document/src/relationship-data.tsx
@@ -167,14 +167,7 @@ export async function addRelationshipDataToComponentProps(
         await Promise.all(
           Object.keys(schema.fields).map(async key => [
             key,
-            // if val[key] === undefined, we know a new field was added to the schema
-            // but there is old data in the database that doesn't have the new field
-            // we're intentionally not just magically adding it because we may want to
-            // have a more optimised strategy of hydrating relationships so we don't
-            // want to add something unrelated that requires the current "traverse everything" strategy
-            val[key] === undefined
-              ? undefined
-              : await addRelationshipDataToComponentProps(schema.fields[key], val[key], fetchData),
+            await addRelationshipDataToComponentProps(schema.fields[key], val[key], fetchData),
           ])
         )
       );
diff --git a/packages/fields-document/src/views.tsx b/packages/fields-document/src/views.tsx
index b3d64edc8..4ddb2e6e0 100644
--- a/packages/fields-document/src/views.tsx
+++ b/packages/fields-document/src/views.tsx
@@ -3,7 +3,7 @@
 
 import { jsx } from '@keystone-ui/core';
 import { FieldContainer, FieldDescription, FieldLabel } from '@keystone-ui/fields';
-import { Descendant, Editor, Node, Text } from 'slate';
+import { Descendant, Node, Text } from 'slate';
 import { DocumentRenderer } from '@keystone-6/document-renderer';
 
 import {
@@ -15,7 +15,7 @@ import {
 } from '@keystone-6/core/types';
 import weakMemoize from '@emotion/weak-memoize';
 import { CellContainer, CellLink } from '@keystone-6/core/admin-ui/components';
-import { createDocumentEditor, DocumentEditor } from './DocumentEditor';
+import { DocumentEditor } from './DocumentEditor';
 import { ComponentBlock } from './component-blocks';
 import { Relationships } from './DocumentEditor/relationship';
 import { clientSideValidateProp } from './DocumentEditor/component-blocks/utils';
@@ -179,20 +179,7 @@ export const controller = (
     relationships: config.fieldMeta.relationships,
     defaultValue: [{ type: 'paragraph', children: [{ text: '' }] }],
     deserialize: data => {
-      const documentFromServer = data[config.path]?.document;
-      if (!documentFromServer) {
-        return [{ type: 'paragraph', children: [{ text: '' }] }];
-      }
-      // make a temporary editor to normalize the document
-      const editor = createDocumentEditor(
-        config.fieldMeta.documentFeatures,
-        componentBlocks,
-        config.customViews.componentBlocks,
-        { current: false }
-      );
-      editor.children = documentFromServer;
-      Editor.normalize(editor, { force: true });
-      return editor.children;
+      return data[config.path]?.document || [{ type: 'paragraph', children: [{ text: '' }] }];
     },
     serialize: value => ({
       [config.path]: value,
diff --git a/tests/sandbox/component-blocks.tsx b/tests/sandbox/component-blocks.tsx
index bee437dcb..80ceac3c3 100644
--- a/tests/sandbox/component-blocks.tsx
+++ b/tests/sandbox/component-blocks.tsx
@@ -563,18 +563,4 @@ export const componentBlocks = {
     },
     chromeless: true,
   }),
-  addingFieldsLater: component({
-    preview: () => null,
-    label: 'Adding Fields Later',
-    schema: {
-      someText: fields.text({ label: 'Some text' }),
-      // try
-      // 1. creating a document with this component blocks
-      // 2. uncommenting the lines below
-      // 3. view the document again and see if the fields are there
-      // someObject: fields.object({
-      //   someTextAddedLater: fields.text({ label: 'Some text added later' }),
-      // }),
-    },
-  }),
 };
