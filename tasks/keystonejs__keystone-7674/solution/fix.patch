diff --git a/.changeset/fifty-kids-pay.md b/.changeset/fifty-kids-pay.md
deleted file mode 100644
index a42c525cb..000000000
--- a/.changeset/fifty-kids-pay.md
+++ /dev/null
@@ -1,5 +0,0 @@
----
-'@keystone-6/core': patch
----
-
-Refactor the types-for-list file to add some extra clarity
diff --git a/.changeset/six-poems-appear.md b/.changeset/six-poems-appear.md
index ea8f08f3d..6c1c4ff9c 100644
--- a/.changeset/six-poems-appear.md
+++ b/.changeset/six-poems-appear.md
@@ -2,4 +2,4 @@
 '@keystone-6/core': minor
 ---
 
-Adds the ability to set ambiguous plurals - like `Firmware` or `Shrimp` - as list names without receiving an error. This builds on the existing `graphql.plural` configuration by adding the configuration options of `ui.label`, `ui.singular`, `ui.plural` and `ui.path` to change the auto-generated names of lists used in the Admin UI
+Added support for changing the auto-generated names of lists used in the Admin UI with `ui.label`, `ui.singular`, `ui.plural` and `ui.path`
diff --git a/.changeset/yellow-houses-doubt.md b/.changeset/yellow-houses-doubt.md
new file mode 100644
index 000000000..bb2106344
--- /dev/null
+++ b/.changeset/yellow-houses-doubt.md
@@ -0,0 +1,5 @@
+---
+'@keystone-6/fields-document': patch
+---
+
+When new fields are added to an object field in a component block, the GraphQL will no longer error when returning data where some fields are missing in the saved data and the Admin UI will add the missing fields when a item is opened. Note that the missing fields won't be automatically added when fetched from the GraphQL, you will still have to handle the field being missing when consuming the data from the GraphQL API.
diff --git a/packages/core/src/lib/core/prisma-schema.ts b/packages/core/src/lib/core/prisma-schema.ts
index 5d4bce22e..d5dfd9b7d 100644
--- a/packages/core/src/lib/core/prisma-schema.ts
+++ b/packages/core/src/lib/core/prisma-schema.ts
@@ -1,5 +1,5 @@
 import { ScalarDBField, ScalarDBFieldDefault, DatabaseProvider } from '../../types';
-import { ResolvedDBField } from './resolve-relationships';
+import { ResolvedDBField, ListsWithResolvedRelations } from './resolve-relationships';
 import { InitialisedList } from './types-for-lists';
 import { getDBFieldKeyForFieldOnMultiField } from './utils';
 
@@ -54,7 +54,7 @@ function printField(
   fieldPath: string,
   field: Exclude<ResolvedDBField, { kind: 'none' }>,
   datasourceName: string,
-  lists: Record<string, InitialisedList>
+  lists: ListsWithResolvedRelations
 ): string {
   if (field.kind === 'scalar') {
     const nativeType = printNativeType(field.nativeType, datasourceName);
@@ -112,7 +112,7 @@ function printField(
   return assertNever(field);
 }
 
-function collectEnums(lists: Record<string, InitialisedList>) {
+function collectEnums(lists: ListsWithResolvedRelations) {
   const enums: Record<string, { values: readonly string[]; firstDefinedByRef: string }> = {};
   for (const [listKey, { resolvedDbFields }] of Object.entries(lists)) {
     for (const [fieldPath, field] of Object.entries(resolvedDbFields)) {
diff --git a/packages/core/src/lib/core/resolve-relationships.ts b/packages/core/src/lib/core/resolve-relationships.ts
index 34c2c8c8b..3ad694935 100644
--- a/packages/core/src/lib/core/resolve-relationships.ts
+++ b/packages/core/src/lib/core/resolve-relationships.ts
@@ -16,7 +16,10 @@ export type ResolvedRelationDBField =
       foreignIdField: { kind: 'none' } | { kind: 'owned' | 'owned-unique'; map: string };
     });
 
-export type ListsWithResolvedRelations = Record<string, FieldsWithResolvedRelations>;
+export type ListsWithResolvedRelations = Record<
+  string,
+  { resolvedDbFields: FieldsWithResolvedRelations }
+>;
 
 export type ResolvedDBField =
   | ResolvedRelationDBField
@@ -285,7 +288,7 @@ export function resolveRelationships(
       );
       // then we add the opposites to one-sided relations
       Object.assign(resolvedDbFields, outOfOrderDbFields);
-      return [listKey, resolvedDbFields];
+      return [listKey, { resolvedDbFields }];
     })
   );
 }
diff --git a/packages/core/src/lib/core/types-for-lists.ts b/packages/core/src/lib/core/types-for-lists.ts
index 999590eb3..c8b93f0a5 100644
--- a/packages/core/src/lib/core/types-for-lists.ts
+++ b/packages/core/src/lib/core/types-for-lists.ts
@@ -38,7 +38,7 @@ export type InitialisedField = Omit<NextFieldType, 'dbField' | 'access' | 'graph
       filter: boolean | ((args: FilterOrderArgs<BaseListTypeInfo>) => MaybePromise<boolean>);
       orderBy: boolean | ((args: FilterOrderArgs<BaseListTypeInfo>) => MaybePromise<boolean>);
     };
-    cacheHint: CacheHint | undefined;
+    cacheHint?: CacheHint | undefined;
   };
 };
 
@@ -57,30 +57,33 @@ export type InitialisedList = {
   lists: Record<string, InitialisedList>;
   dbMap: string | undefined;
   graphql: {
-    isEnabled: IsEnabled;
-  };
-};
+    isEnabled: {
+      type: boolean;
+      query: boolean;
 
-type IsEnabled = {
-  type: boolean;
-  query: boolean;
-  create: boolean;
-  update: boolean;
-  delete: boolean;
-  filter: boolean | ((args: FilterOrderArgs<BaseListTypeInfo>) => MaybePromise<boolean>);
-  orderBy: boolean | ((args: FilterOrderArgs<BaseListTypeInfo>) => MaybePromise<boolean>);
+      create: boolean;
+      update: boolean;
+      delete: boolean;
+    };
+  };
 };
 
-function throwIfNotAFilter(x: unknown, listKey: string, fieldKey: string) {
-  if (['boolean', 'undefined', 'function'].includes(typeof x)) return;
-
-  throw new Error(
-    `Configuration option '${listKey}.${fieldKey}' must be either a boolean value or a function. Received '${x}'.`
-  );
-}
-
-function getIsEnabled(listsConfig: KeystoneConfig['lists']) {
-  const isEnabled: Record<string, IsEnabled> = {};
+export function initialiseLists(config: KeystoneConfig): Record<string, InitialisedList> {
+  const listsConfig = config.lists;
+  const { provider } = config.db;
+  const listInfos: Record<string, ListGraphQLTypes> = {};
+  const isEnabled: Record<
+    string,
+    {
+      type: boolean;
+      query: boolean;
+      create: boolean;
+      update: boolean;
+      delete: boolean;
+      filter: boolean | ((args: FilterOrderArgs<BaseListTypeInfo>) => MaybePromise<boolean>);
+      orderBy: boolean | ((args: FilterOrderArgs<BaseListTypeInfo>) => MaybePromise<boolean>);
+    }
+  > = {};
 
   for (const [listKey, listConfig] of Object.entries(listsConfig)) {
     const omit = listConfig.graphql?.omit;
@@ -89,8 +92,16 @@ function getIsEnabled(listsConfig: KeystoneConfig['lists']) {
       // We explicity check for boolean/function values here to ensure the dev hasn't made a mistake
       // when defining these values. We avoid duck-typing here as this is security related
       // and we want to make it hard to write incorrect code.
-      throwIfNotAFilter(defaultIsFilterable, listKey, 'defaultIsFilterable');
-      throwIfNotAFilter(defaultIsOrderable, listKey, 'defaultIsOrderable');
+      if (!['boolean', 'undefined', 'function'].includes(typeof defaultIsFilterable)) {
+        throw new Error(
+          `Configuration option '${listKey}.defaultIsFilterable' must be either a boolean value or a function. Recieved '${typeof defaultIsFilterable}'.`
+        );
+      }
+      if (!['boolean', 'undefined', 'function'].includes(typeof defaultIsOrderable)) {
+        throw new Error(
+          `Configuration option '${listKey}.defaultIsOrderable' must be either a boolean value or a function. Recieved '${typeof defaultIsOrderable}'.`
+        );
+      }
     }
     if (omit === true) {
       isEnabled[listKey] = {
@@ -125,87 +136,13 @@ function getIsEnabled(listsConfig: KeystoneConfig['lists']) {
     }
   }
 
-  return isEnabled;
-}
-
-function getListsWithInitialisedFields(
-  { storage: configStorage, lists: listsConfig, db: { provider } }: KeystoneConfig,
-  listGraphqlTypes: Record<string, ListGraphQLTypes>,
-  intermediateLists: Record<string, { graphql: { isEnabled: IsEnabled } }>
-) {
-  return Object.fromEntries(
-    Object.entries(listsConfig).map(([listKey, list]) => [
-      listKey,
-      {
-        fields: Object.fromEntries(
-          Object.entries(list.fields).map(([fieldKey, fieldFunc]) => {
-            if (typeof fieldFunc !== 'function') {
-              throw new Error(`The field at ${listKey}.${fieldKey} does not provide a function`);
-            }
-            const f = fieldFunc({
-              fieldKey,
-              listKey,
-              lists: listGraphqlTypes,
-              provider,
-              getStorage: storage => configStorage?.[storage],
-            });
-
-            const omit = f.graphql?.omit;
-            const read = omit !== true && !omit?.includes('read');
-
-            // We explicity check for boolean values here to ensure the dev hasn't made a mistake
-            // when defining these values. We avoid duck-typing here as this is security related
-            // and we want to make it hard to write incorrect code.
-            throwIfNotAFilter(f.isFilterable, listKey, 'isFilterable');
-            throwIfNotAFilter(f.isOrderable, listKey, 'isOrderable');
-
-            const _isEnabled = {
-              read,
-              update: omit !== true && !omit?.includes('update'),
-              create: omit !== true && !omit?.includes('create'),
-              // Filter and orderBy can be defaulted at the list level, otherwise they
-              // default to `false` if no value was set at the list level.
-              filter:
-                read && (f.isFilterable ?? intermediateLists[listKey].graphql.isEnabled.filter),
-              orderBy:
-                read && (f.isOrderable ?? intermediateLists[listKey].graphql.isEnabled.orderBy),
-            };
-            const field = {
-              ...f,
-              access: parseFieldAccessControl(f.access),
-              hooks: f.hooks ?? {},
-              graphql: { cacheHint: f.graphql?.cacheHint, isEnabled: _isEnabled },
-              input: { ...f.input },
-            };
-
-            return [fieldKey, field];
-          })
-        ),
-        ...intermediateLists[listKey],
-        ...getNamesFromList(listKey, list),
-        hooks: list.hooks,
-        access: parseListAccessControl(list.access),
-        dbMap: list.db?.map,
-        types: listGraphqlTypes[listKey].types,
-      },
-    ])
-  );
-}
-
-function getListGraphqlTypes(
-  listsConfig: KeystoneConfig['lists'],
-  lists: Record<string, InitialisedList>,
-  intermediateLists: Record<string, { graphql: { isEnabled: IsEnabled } }>
-): Record<string, ListGraphQLTypes> {
-  const graphQLTypes: Record<string, ListGraphQLTypes> = {};
-
   for (const [listKey, listConfig] of Object.entries(listsConfig)) {
     const names = getGqlNames({
       listKey,
       pluralGraphQLName: getNamesFromList(listKey, listConfig).pluralGraphQLName,
     });
 
-    const output = graphql.object<BaseItem>()({
+    let output = graphql.object<BaseItem>()({
       name: names.outputTypeName,
       fields: () => {
         const { fields } = lists[listKey];
@@ -215,8 +152,7 @@ function getListGraphqlTypes(
               if (
                 !field.output ||
                 !field.graphql.isEnabled.read ||
-                (field.dbField.kind === 'relation' &&
-                  !intermediateLists[field.dbField.list].graphql.isEnabled.query)
+                (field.dbField.kind === 'relation' && !isEnabled[field.dbField.list].query)
               ) {
                 return [];
               }
@@ -338,15 +274,15 @@ function getListGraphqlTypes(
       skip: graphql.arg({ type: graphql.nonNull(graphql.Int), defaultValue: 0 }),
     };
 
-    const isEnabled = intermediateLists[listKey].graphql.isEnabled;
+    const _isEnabled = isEnabled[listKey];
     let relateToManyForCreate, relateToManyForUpdate, relateToOneForCreate, relateToOneForUpdate;
-    if (isEnabled.type) {
+    if (_isEnabled.type) {
       relateToManyForCreate = graphql.inputObject({
         name: names.relateToManyForCreateInputName,
         fields: () => {
           return {
             // Create via a relationship is only supported if this list allows create
-            ...(isEnabled.create && {
+            ...(_isEnabled.create && {
               create: graphql.arg({ type: graphql.list(graphql.nonNull(create)) }),
             }),
             connect: graphql.arg({ type: graphql.list(graphql.nonNull(uniqueWhere)) }),
@@ -363,7 +299,7 @@ function getListGraphqlTypes(
             disconnect: graphql.arg({ type: graphql.list(graphql.nonNull(uniqueWhere)) }),
             set: graphql.arg({ type: graphql.list(graphql.nonNull(uniqueWhere)) }),
             // Create via a relationship is only supported if this list allows create
-            ...(isEnabled.create && {
+            ...(_isEnabled.create && {
               create: graphql.arg({ type: graphql.list(graphql.nonNull(create)) }),
             }),
             connect: graphql.arg({ type: graphql.list(graphql.nonNull(uniqueWhere)) }),
@@ -376,7 +312,7 @@ function getListGraphqlTypes(
         fields: () => {
           return {
             // Create via a relationship is only supported if this list allows create
-            ...(isEnabled.create && { create: graphql.arg({ type: create }) }),
+            ...(_isEnabled.create && { create: graphql.arg({ type: create }) }),
             connect: graphql.arg({ type: uniqueWhere }),
           };
         },
@@ -387,15 +323,14 @@ function getListGraphqlTypes(
         fields: () => {
           return {
             // Create via a relationship is only supported if this list allows create
-            ...(isEnabled.create && { create: graphql.arg({ type: create }) }),
+            ...(_isEnabled.create && { create: graphql.arg({ type: create }) }),
             connect: graphql.arg({ type: uniqueWhere }),
             disconnect: graphql.arg({ type: graphql.Boolean }),
           };
         },
       });
     }
-
-    graphQLTypes[listKey] = {
+    listInfos[listKey] = {
       types: {
         output,
         uniqueWhere,
@@ -423,97 +358,115 @@ function getListGraphqlTypes(
     };
   }
 
-  return graphQLTypes;
-}
+  const listsWithInitialisedFields = Object.fromEntries(
+    Object.entries(listsConfig).map(([listKey, list]) => [
+      listKey,
+      {
+        fields: Object.fromEntries(
+          Object.entries(list.fields).map(([fieldKey, fieldFunc]) => {
+            if (typeof fieldFunc !== 'function') {
+              throw new Error(`The field at ${listKey}.${fieldKey} does not provide a function`);
+            }
+            const f = fieldFunc({
+              fieldKey,
+              listKey,
+              lists: listInfos,
+              provider,
+              getStorage: storage => config.storage?.[storage],
+            });
 
-/**
- * 1. Get the `isEnabled` config object from the listConfig - the returned object will be modified later
- * 2. Instantiate `lists` object - it is done here as the object will be added to the listGraphqlTypes
- * 3. Get graphqlTypes
- * 4. Initialise fields - field functions are called
- * 5. Handle relationships - ensure correct linking between two sides of all relationships (including one-sided relationships)
- * 6.
- */
-export function initialiseLists(config: KeystoneConfig): Record<string, InitialisedList> {
-  const listsConfig = config.lists;
+            const omit = f.graphql?.omit;
+            const read = omit !== true && !omit?.includes('read');
 
-  let intermediateLists;
+            // We explicity check for boolean values here to ensure the dev hasn't made a mistake
+            // when defining these values. We avoid duck-typing here as this is security related
+            // and we want to make it hard to write incorrect code.
+            if (!['boolean', 'function', 'undefined'].includes(typeof f.isFilterable)) {
+              throw new Error(
+                `Configuration option '${listKey}.${fieldKey}.isFilterable' must be either a boolean value or a function. Recieved '${typeof f.isFilterable}'.`
+              );
+            }
+            if (!['boolean', 'function', 'undefined'].includes(typeof f.isOrderable)) {
+              throw new Error(
+                `Configuration option '${listKey}.${fieldKey}.isOrderable' must be either a boolean value or a function. Recieved '${typeof f.isOrderable}'.`
+              );
+            }
 
-  intermediateLists = Object.fromEntries(
-    Object.entries(getIsEnabled(listsConfig)).map(([key, isEnabled]) => [
-      key,
-      { graphql: { isEnabled } },
+            const _isEnabled = {
+              read,
+              update: omit !== true && !omit?.includes('update'),
+              create: omit !== true && !omit?.includes('create'),
+              // Filter and orderBy can be defaulted at the list level, otherwise they
+              // default to `false` if no value was set at the list level.
+              filter: read && (f.isFilterable ?? isEnabled[listKey].filter),
+              orderBy: read && (f.isOrderable ?? isEnabled[listKey].orderBy),
+            };
+            const field = {
+              ...f,
+              graphql: { ...f.graphql, isEnabled: _isEnabled },
+              input: { ...f.input },
+            };
+
+            return [fieldKey, field];
+          })
+        ),
+        ...getNamesFromList(listKey, list),
+        hooks: list.hooks,
+        access: list.access,
+        dbMap: list.db?.map,
+      },
     ])
   );
 
-  /**
-   * Lists is instantiated here so that it can be passed into the `getListGraphqlTypes` function
-   * This function attaches this list object to the various graphql functions
-   *
-   * The object will be populated at the end of this function, and the reference will be maintained
-   */
-  const listsRef: Record<string, InitialisedList> = {};
-  /** Block statements to contain variables only being used within them */
-  {
-    const listGraphqlTypes = getListGraphqlTypes(listsConfig, listsRef, intermediateLists);
-    intermediateLists = getListsWithInitialisedFields(config, listGraphqlTypes, intermediateLists);
-  }
-  {
-    const resolvedDBFieldsForLists = resolveRelationships(intermediateLists);
-    intermediateLists = Object.fromEntries(
-      Object.entries(intermediateLists).map(([listKey, blah]) => [
-        listKey,
-        { ...blah, resolvedDbFields: resolvedDBFieldsForLists[listKey] },
-      ])
-    );
-  }
-
-  intermediateLists = Object.fromEntries(
-    Object.entries(intermediateLists).map(([listKey, list]) => {
-      const fields: Record<string, InitialisedField> = Object.fromEntries(
-        Object.entries(list.fields).map(([fieldKey, field]) => [
-          fieldKey,
-          { ...field, dbField: list.resolvedDbFields[fieldKey] },
-        ])
+  const listsWithResolvedDBFields = resolveRelationships(listsWithInitialisedFields);
+
+  const listsWithInitialisedFieldsAndResolvedDbFields = Object.fromEntries(
+    Object.entries(listsWithInitialisedFields).map(([listKey, list]) => {
+      let hasAnEnabledCreateField = false;
+      let hasAnEnabledUpdateField = false;
+      const fields = Object.fromEntries(
+        Object.entries(list.fields).map(([fieldKey, field]) => {
+          if (field.input?.create?.arg && field.graphql.isEnabled.create) {
+            hasAnEnabledCreateField = true;
+          }
+          if (field.input?.update && field.graphql.isEnabled.update) {
+            hasAnEnabledUpdateField = true;
+          }
+          const access = parseFieldAccessControl(field.access);
+          const dbField = listsWithResolvedDBFields[listKey].resolvedDbFields[fieldKey];
+          return [
+            fieldKey,
+            { ...field, access, dbField, hooks: field.hooks ?? {}, graphql: field.graphql },
+          ];
+        })
       );
-      return [listKey, { ...list, fields }];
-    })
-  );
-
-  for (const list of Object.values(intermediateLists)) {
-    let hasAnEnabledCreateField = false;
-    let hasAnEnabledUpdateField = false;
-
-    for (const field of Object.values(list.fields)) {
-      if (field.input?.create?.arg && field.graphql.isEnabled.create) {
-        hasAnEnabledCreateField = true;
+      const access = parseListAccessControl(list.access);
+      // You can't have a graphQL type with no fields, so
+      // if they're all disabled, we have to disable the whole operation.
+      if (!hasAnEnabledCreateField) {
+        isEnabled[listKey].create = false;
       }
-      if (field.input?.update && field.graphql.isEnabled.update) {
-        hasAnEnabledUpdateField = true;
+      if (!hasAnEnabledUpdateField) {
+        isEnabled[listKey].update = false;
       }
-    }
-    // You can't have a graphQL type with no fields, so
-    // if they're all disabled, we have to disable the whole operation.
-    if (!hasAnEnabledCreateField) {
-      list.graphql.isEnabled.create = false;
-    }
-    if (!hasAnEnabledUpdateField) {
-      list.graphql.isEnabled.update = false;
-    }
-  }
+      return [listKey, { ...list, access, fields, graphql: { isEnabled: isEnabled[listKey] } }];
+    })
+  );
 
-  /*
-    Error checking
-    */
-  for (const [listKey, { fields }] of Object.entries(intermediateLists)) {
+  for (const [listKey, { fields }] of Object.entries(
+    listsWithInitialisedFieldsAndResolvedDbFields
+  )) {
     assertFieldsValid({ listKey, fields });
   }
 
-  for (const [listKey, intermediateList] of Object.entries(intermediateLists)) {
-    listsRef[listKey] = {
-      ...intermediateList,
-      /** These properties weren't related to any of the above actions but need to be here */
-      hooks: intermediateList.hooks || {},
+  const lists: Record<string, InitialisedList> = {};
+
+  for (const [listKey, list] of Object.entries(listsWithInitialisedFieldsAndResolvedDbFields)) {
+    lists[listKey] = {
+      ...list,
+      ...listInfos[listKey],
+      ...listsWithResolvedDBFields[listKey],
+      hooks: list.hooks || {},
       cacheHint: (() => {
         const cacheHint = listsConfig[listKey].graphql?.cacheHint;
         if (cacheHint === undefined) {
@@ -523,10 +476,9 @@ export function initialiseLists(config: KeystoneConfig): Record<string, Initiali
       })(),
       maxResults: listsConfig[listKey].graphql?.queryLimits?.maxResults ?? Infinity,
       listKey,
-      /** Add self-reference */
-      lists: listsRef,
+      lists,
     };
   }
 
-  return listsRef;
+  return lists;
 }
diff --git a/packages/fields-document/src/DocumentEditor/component-blocks/with-component-blocks.tsx b/packages/fields-document/src/DocumentEditor/component-blocks/with-component-blocks.tsx
index 1c9ae7423..626ce4942 100644
--- a/packages/fields-document/src/DocumentEditor/component-blocks/with-component-blocks.tsx
+++ b/packages/fields-document/src/DocumentEditor/component-blocks/with-component-blocks.tsx
@@ -311,194 +311,197 @@ export function withComponentBlocks(
 
   editor.normalizeNode = entry => {
     const [node, path] = entry;
-    if (Element.isElement(node) || Editor.isEditor(node)) {
-      if (
-        node.type === 'component-inline-prop' &&
-        !node.propPath &&
-        (node.children.length !== 1 ||
-          !Text.isText(node.children[0]) ||
-          node.children[0].text !== '')
-      ) {
-        Transforms.removeNodes(editor, {
-          at: path,
-        });
-        return;
-      }
+    if (
+      node.type === 'component-inline-prop' &&
+      !node.propPath &&
+      (node.children.length !== 1 || !Text.isText(node.children[0]) || node.children[0].text !== '')
+    ) {
+      Transforms.removeNodes(editor, {
+        at: path,
+      });
+      return;
+    }
+
+    if (node.type === 'component-block') {
+      const componentBlock = blockComponents[node.component];
+      if (componentBlock) {
+        const rootSchema = { kind: 'object' as const, fields: componentBlock.schema };
+
+        const updatedProps = addMissingFields(node.props, rootSchema) as Record<string, unknown>;
+        if (updatedProps !== node.props) {
+          Transforms.setNodes(editor, { props: updatedProps }, { at: path });
+          return;
+        }
 
-      if (Element.isElement(node) && node.type === 'component-block') {
-        const componentBlock = blockComponents[node.component];
-        if (componentBlock) {
-          const rootSchema = { kind: 'object' as const, fields: componentBlock.schema };
-          for (const [propPath, arrayField] of findArrayFieldsWithSingleChildField(
-            rootSchema,
-            node.props
-          )) {
+        for (const [propPath, arrayField] of findArrayFieldsWithSingleChildField(
+          rootSchema,
+          node.props
+        )) {
+          if (
+            node.children.length === 1 &&
+            node.children[0].type === 'component-inline-prop' &&
+            node.children[0].propPath === undefined
+          ) {
+            break;
+          }
+          const nodesWithin: [
+            number,
+            Element & { type: 'component-block-prop' | 'component-inline-prop' }
+          ][] = [];
+          for (const [idx, childNode] of node.children.entries()) {
             if (
-              node.children.length === 1 &&
-              node.children[0].type === 'component-inline-prop' &&
-              node.children[0].propPath === undefined
+              (childNode.type === 'component-block-prop' ||
+                childNode.type === 'component-inline-prop') &&
+              childNode.propPath !== undefined
             ) {
-              break;
-            }
-            const nodesWithin: [
-              number,
-              Element & { type: 'component-block-prop' | 'component-inline-prop' }
-            ][] = [];
-            for (const [idx, childNode] of node.children.entries()) {
-              if (
-                (childNode.type === 'component-block-prop' ||
-                  childNode.type === 'component-inline-prop') &&
-                childNode.propPath !== undefined
-              ) {
-                const subPath = childNode.propPath.concat();
-                while (subPath.length) {
-                  if (typeof subPath.pop() === 'number') break;
-                }
+              const subPath = childNode.propPath.concat();
+              while (subPath.length) {
+                if (typeof subPath.pop() === 'number') break;
+              }
 
-                if (areArraysEqual(propPath, subPath)) {
-                  nodesWithin.push([idx, childNode]);
-                }
+              if (areArraysEqual(propPath, subPath)) {
+                nodesWithin.push([idx, childNode]);
               }
             }
-            const arrVal = getValueAtPropPath(node.props, propPath) as unknown[];
-            const prevKeys = getKeysForArrayValue(arrVal);
-            const prevKeysSet = new Set(prevKeys);
-            const alreadyUsedIndicies = new Set<number>();
-            const newVal: unknown[] = [];
-            const newKeys: string[] = [];
-            const getNewKey = () => {
-              let key = getNewArrayElementKey();
-              while (prevKeysSet.has(key)) {
-                key = getNewArrayElementKey();
-              }
-              return key;
-            };
-            for (const [, node] of nodesWithin) {
-              const idxFromValue = node.propPath![propPath.length];
-              assert(typeof idxFromValue === 'number');
-              if (
-                arrVal.length <= idxFromValue ||
-                (alreadyUsedIndicies.has(idxFromValue) && isEmptyChildFieldNode(node))
-              ) {
-                newVal.push(getInitialPropsValue(arrayField.element));
-                newKeys.push(getNewKey());
-              } else {
-                alreadyUsedIndicies.add(idxFromValue);
-                newVal.push(arrVal[idxFromValue]);
-                newKeys.push(
-                  alreadyUsedIndicies.has(idxFromValue) ? getNewKey() : prevKeys[idxFromValue]
-                );
-              }
+          }
+          const arrVal = getValueAtPropPath(node.props, propPath) as unknown[];
+          const prevKeys = getKeysForArrayValue(arrVal);
+          const prevKeysSet = new Set(prevKeys);
+          const alreadyUsedIndicies = new Set<number>();
+          const newVal: unknown[] = [];
+          const newKeys: string[] = [];
+          const getNewKey = () => {
+            let key = getNewArrayElementKey();
+            while (prevKeysSet.has(key)) {
+              key = getNewArrayElementKey();
             }
-            setKeysForArrayValue(newVal, newKeys);
-            if (!areArraysEqual(arrVal, newVal)) {
-              const transformedProps = replaceValueAtPropPath(
-                rootSchema,
-                node.props,
-                newVal,
-                propPath
-              );
-              Transforms.setNodes(
-                editor,
-                { props: transformedProps as Record<string, unknown> },
-                { at: path }
+            return key;
+          };
+          for (const [, node] of nodesWithin) {
+            const idxFromValue = node.propPath![propPath.length];
+            assert(typeof idxFromValue === 'number');
+            if (
+              arrVal.length <= idxFromValue ||
+              (alreadyUsedIndicies.has(idxFromValue) && isEmptyChildFieldNode(node))
+            ) {
+              newVal.push(getInitialPropsValue(arrayField.element));
+              newKeys.push(getNewKey());
+            } else {
+              alreadyUsedIndicies.add(idxFromValue);
+              newVal.push(arrVal[idxFromValue]);
+              newKeys.push(
+                alreadyUsedIndicies.has(idxFromValue) ? getNewKey() : prevKeys[idxFromValue]
               );
-              for (const [idx, [idxInChildrenOfBlock, nodeWithin]] of nodesWithin.entries()) {
-                const newPropPath = [...nodeWithin.propPath!];
-                newPropPath[propPath.length] = idx;
-                Transforms.setNodes(
-                  editor,
-                  { propPath: newPropPath },
-                  { at: [...path, idxInChildrenOfBlock] }
-                );
-              }
-              return;
             }
           }
-
-          const missingKeys = new Map(
-            findChildPropPaths(node.props, componentBlock.schema).map(x => [
-              JSON.stringify(x.path) as string | undefined,
-              x.options.kind,
-            ])
-          );
-
-          node.children.forEach(node => {
-            assert(node.type === 'component-block-prop' || node.type === 'component-inline-prop');
-            missingKeys.delete(JSON.stringify(node.propPath));
-          });
-          if (missingKeys.size) {
-            Transforms.insertNodes(
+          setKeysForArrayValue(newVal, newKeys);
+          if (!areArraysEqual(arrVal, newVal)) {
+            const transformedProps = replaceValueAtPropPath(
+              rootSchema,
+              node.props,
+              newVal,
+              propPath
+            );
+            Transforms.setNodes(
               editor,
-              [...missingKeys].map(([prop, kind]) => ({
-                type: `component-${kind}-prop` as const,
-                propPath: prop ? JSON.parse(prop) : prop,
-                children: [{ text: '' }],
-              })),
-              { at: [...path, node.children.length] }
+              { props: transformedProps as Record<string, unknown> },
+              { at: path }
             );
+            for (const [idx, [idxInChildrenOfBlock, nodeWithin]] of nodesWithin.entries()) {
+              const newPropPath = [...nodeWithin.propPath!];
+              newPropPath[propPath.length] = idx;
+              Transforms.setNodes(
+                editor,
+                { propPath: newPropPath },
+                { at: [...path, idxInChildrenOfBlock] }
+              );
+            }
             return;
           }
+        }
 
-          const foundProps = new Set<string>();
+        const missingKeys = new Map(
+          findChildPropPaths(node.props, componentBlock.schema).map(x => [
+            JSON.stringify(x.path) as string | undefined,
+            x.options.kind,
+          ])
+        );
 
-          const stringifiedInlinePropPaths: Record<
-            string,
-            { options: ChildField['options']; index: number } | undefined
-          > = {};
-          findChildPropPaths(node.props, blockComponents[node.component]!.schema).forEach(
-            (x, index) => {
-              stringifiedInlinePropPaths[JSON.stringify(x.path)] = { options: x.options, index };
-            }
+        node.children.forEach(node => {
+          assert(node.type === 'component-block-prop' || node.type === 'component-inline-prop');
+          missingKeys.delete(JSON.stringify(node.propPath));
+        });
+        if (missingKeys.size) {
+          Transforms.insertNodes(
+            editor,
+            [...missingKeys].map(([prop, kind]) => ({
+              type: `component-${kind}-prop` as const,
+              propPath: prop ? JSON.parse(prop) : prop,
+              children: [{ text: '' }],
+            })),
+            { at: [...path, node.children.length] }
           );
+          return;
+        }
 
-          for (const [index, childNode] of node.children.entries()) {
-            if (
-              // children that are not these will be handled by
-              // the generic allowedChildren normalization
-              childNode.type !== 'component-inline-prop' &&
-              childNode.type !== 'component-block-prop'
-            ) {
-              continue;
-            }
+        const foundProps = new Set<string>();
 
-            const childPath = [...path, index];
-            const stringifiedPropPath = JSON.stringify(childNode.propPath);
-            if (stringifiedInlinePropPaths[stringifiedPropPath] === undefined) {
-              Transforms.removeNodes(editor, { at: childPath });
-              return;
-            }
+        const stringifiedInlinePropPaths: Record<
+          string,
+          { options: ChildField['options']; index: number } | undefined
+        > = {};
+        findChildPropPaths(node.props, blockComponents[node.component]!.schema).forEach(
+          (x, index) => {
+            stringifiedInlinePropPaths[JSON.stringify(x.path)] = { options: x.options, index };
+          }
+        );
 
-            if (foundProps.has(stringifiedPropPath)) {
-              Transforms.removeNodes(editor, { at: childPath });
-              return;
-            }
+        for (const [index, childNode] of node.children.entries()) {
+          if (
+            // children that are not these will be handled by
+            // the generic allowedChildren normalization
+            childNode.type !== 'component-inline-prop' &&
+            childNode.type !== 'component-block-prop'
+          ) {
+            continue;
+          }
 
-            foundProps.add(stringifiedPropPath);
-            const propInfo = stringifiedInlinePropPaths[stringifiedPropPath]!;
-            const expectedIndex = propInfo.index;
-            if (index !== expectedIndex) {
-              Transforms.moveNodes(editor, { at: childPath, to: [...path, expectedIndex] });
-              return;
-            }
+          const childPath = [...path, index];
+          const stringifiedPropPath = JSON.stringify(childNode.propPath);
+          if (stringifiedInlinePropPaths[stringifiedPropPath] === undefined) {
+            Transforms.removeNodes(editor, { at: childPath });
+            return;
+          }
 
-            const expectedChildNodeType = `component-${propInfo.options.kind}-prop` as const;
-            if (childNode.type !== expectedChildNodeType) {
-              Transforms.setNodes(editor, { type: expectedChildNodeType }, { at: childPath });
-              return;
-            }
+          if (foundProps.has(stringifiedPropPath)) {
+            Transforms.removeNodes(editor, { at: childPath });
+            return;
+          }
 
-            const documentFeatures = memoizedGetDocumentFeaturesForChildField(propInfo.options);
-            if (
-              normalizeNodeWithinComponentProp(
-                [childNode, childPath],
-                editor,
-                documentFeatures,
-                relationships
-              )
-            ) {
-              return;
-            }
+          foundProps.add(stringifiedPropPath);
+          const propInfo = stringifiedInlinePropPaths[stringifiedPropPath]!;
+          const expectedIndex = propInfo.index;
+          if (index !== expectedIndex) {
+            Transforms.moveNodes(editor, { at: childPath, to: [...path, expectedIndex] });
+            return;
+          }
+
+          const expectedChildNodeType = `component-${propInfo.options.kind}-prop` as const;
+          if (childNode.type !== expectedChildNodeType) {
+            Transforms.setNodes(editor, { type: expectedChildNodeType }, { at: childPath });
+            return;
+          }
+
+          const documentFeatures = memoizedGetDocumentFeaturesForChildField(propInfo.options);
+          if (
+            normalizeNodeWithinComponentProp(
+              [childNode, childPath],
+              editor,
+              documentFeatures,
+              relationships
+            )
+          ) {
+            return;
           }
         }
       }
@@ -509,3 +512,52 @@ export function withComponentBlocks(
 
   return editor;
 }
+
+// the only thing that this will fix is a new field being added to an object field, nothing else.
+function addMissingFields(value: unknown, schema: ComponentSchema): unknown {
+  if (schema.kind === 'child' || schema.kind === 'form' || schema.kind === 'relationship') {
+    return value;
+  }
+  if (schema.kind === 'conditional') {
+    const conditionalValue = value as { discriminant: string | boolean; value: unknown };
+    const updatedInnerValue = addMissingFields(
+      conditionalValue.value,
+      schema.values[conditionalValue.discriminant.toString()]
+    );
+    if (updatedInnerValue === conditionalValue.value) {
+      return value;
+    }
+    return { discriminant: conditionalValue.value, value: updatedInnerValue };
+  }
+  if (schema.kind === 'array') {
+    const arrValue = value as unknown[];
+    const newArrValue = arrValue.map(x => addMissingFields(x, schema.element));
+    if (areArraysEqual(arrValue, newArrValue)) {
+      return value;
+    }
+    return newArrValue;
+  }
+  if (schema.kind === 'object') {
+    const objectValue = value as Record<string, unknown>;
+    let hasChanged = false;
+    const newObjectValue: Record<string, unknown> = {};
+    for (const [key, innerSchema] of Object.entries(schema.fields)) {
+      const innerValue = objectValue[key];
+      if (innerValue === undefined) {
+        hasChanged = true;
+        newObjectValue[key] = getInitialPropsValue(innerSchema);
+        continue;
+      }
+      const newInnerValue = addMissingFields(innerValue as Record<string, unknown>, innerSchema);
+      if (newInnerValue !== innerValue) {
+        hasChanged = true;
+      }
+      newObjectValue[key] = newInnerValue;
+    }
+    if (hasChanged) {
+      return newObjectValue;
+    }
+    return value;
+  }
+  assertNever(schema);
+}
diff --git a/packages/fields-document/src/DocumentEditor/pasting/index.ts b/packages/fields-document/src/DocumentEditor/pasting/index.ts
index cdb8f26cf..e5e22b500 100644
--- a/packages/fields-document/src/DocumentEditor/pasting/index.ts
+++ b/packages/fields-document/src/DocumentEditor/pasting/index.ts
@@ -63,8 +63,7 @@ export function withPasting(editor: Editor): Editor {
       }
     }
 
-    let html = data.getData('text/html');
-
+    const html = data.getData('text/html');
     if (html) {
       const fragment = deserializeHTML(html);
       insertFragmentButDifferent(editor, fragment);
diff --git a/packages/fields-document/src/relationship-data.tsx b/packages/fields-document/src/relationship-data.tsx
index ea257fa10..e4355d2b4 100644
--- a/packages/fields-document/src/relationship-data.tsx
+++ b/packages/fields-document/src/relationship-data.tsx
@@ -167,7 +167,14 @@ export async function addRelationshipDataToComponentProps(
         await Promise.all(
           Object.keys(schema.fields).map(async key => [
             key,
-            await addRelationshipDataToComponentProps(schema.fields[key], val[key], fetchData),
+            // if val[key] === undefined, we know a new field was added to the schema
+            // but there is old data in the database that doesn't have the new field
+            // we're intentionally not just magically adding it because we may want to
+            // have a more optimised strategy of hydrating relationships so we don't
+            // want to add something unrelated that requires the current "traverse everything" strategy
+            val[key] === undefined
+              ? undefined
+              : await addRelationshipDataToComponentProps(schema.fields[key], val[key], fetchData),
           ])
         )
       );
diff --git a/packages/fields-document/src/views.tsx b/packages/fields-document/src/views.tsx
index 4ddb2e6e0..b3d64edc8 100644
--- a/packages/fields-document/src/views.tsx
+++ b/packages/fields-document/src/views.tsx
@@ -3,7 +3,7 @@
 
 import { jsx } from '@keystone-ui/core';
 import { FieldContainer, FieldDescription, FieldLabel } from '@keystone-ui/fields';
-import { Descendant, Node, Text } from 'slate';
+import { Descendant, Editor, Node, Text } from 'slate';
 import { DocumentRenderer } from '@keystone-6/document-renderer';
 
 import {
@@ -15,7 +15,7 @@ import {
 } from '@keystone-6/core/types';
 import weakMemoize from '@emotion/weak-memoize';
 import { CellContainer, CellLink } from '@keystone-6/core/admin-ui/components';
-import { DocumentEditor } from './DocumentEditor';
+import { createDocumentEditor, DocumentEditor } from './DocumentEditor';
 import { ComponentBlock } from './component-blocks';
 import { Relationships } from './DocumentEditor/relationship';
 import { clientSideValidateProp } from './DocumentEditor/component-blocks/utils';
@@ -179,7 +179,20 @@ export const controller = (
     relationships: config.fieldMeta.relationships,
     defaultValue: [{ type: 'paragraph', children: [{ text: '' }] }],
     deserialize: data => {
-      return data[config.path]?.document || [{ type: 'paragraph', children: [{ text: '' }] }];
+      const documentFromServer = data[config.path]?.document;
+      if (!documentFromServer) {
+        return [{ type: 'paragraph', children: [{ text: '' }] }];
+      }
+      // make a temporary editor to normalize the document
+      const editor = createDocumentEditor(
+        config.fieldMeta.documentFeatures,
+        componentBlocks,
+        config.customViews.componentBlocks,
+        { current: false }
+      );
+      editor.children = documentFromServer;
+      Editor.normalize(editor, { force: true });
+      return editor.children;
     },
     serialize: value => ({
       [config.path]: value,
