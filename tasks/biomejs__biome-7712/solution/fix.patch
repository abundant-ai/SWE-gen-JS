diff --git a/.changeset/bright-insects-ring.md b/.changeset/bright-insects-ring.md
new file mode 100644
index 0000000000..6e17e68f4b
--- /dev/null
+++ b/.changeset/bright-insects-ring.md
@@ -0,0 +1,13 @@
+---
+"@biomejs/biome": patch
+---
+
+Added new rule [`useVueDefineMacrosOrder`](https://biomejs.dev/linter/rules/use-vue-define-macros-order) which allows enforcing specific order for Vue compiler macros.
+
+In this example, the rule will suggest moving `defineProps` before `defineEmits`:
+```vue
+<script lang="ts" setup>
+const emit = defineEmits(['update'])
+const props = defineProps<{ name: string }>()
+</script>
+```
diff --git a/crates/biome_cli/src/execute/migrate/eslint_any_rule_to_biome.rs b/crates/biome_cli/src/execute/migrate/eslint_any_rule_to_biome.rs
index 8a2aa6239c..d0098d5941 100644
--- a/crates/biome_cli/src/execute/migrate/eslint_any_rule_to_biome.rs
+++ b/crates/biome_cli/src/execute/migrate/eslint_any_rule_to_biome.rs
@@ -2873,6 +2873,18 @@ pub(crate) fn migrate_eslint_any_rule(
                 .get_or_insert(Default::default());
             rule.set_level(rule.level().max(rule_severity.into()));
         }
+        "vue/define-macros-order" => {
+            if !options.include_nursery {
+                results.add(eslint_name, eslint_to_biome::RuleMigrationResult::Nursery);
+                return false;
+            }
+            let group = rules.nursery.get_or_insert_with(Default::default);
+            let rule = group
+                .unwrap_group_as_mut()
+                .use_vue_define_macros_order
+                .get_or_insert(Default::default());
+            rule.set_level(rule.level().max(rule_severity.into()));
+        }
         "vue/multi-word-component-names" => {
             if !options.include_inspired {
                 results.add(eslint_name, eslint_to_biome::RuleMigrationResult::Inspired);
diff --git a/crates/biome_configuration/src/analyzer/linter/rules.rs b/crates/biome_configuration/src/analyzer/linter/rules.rs
index 417ebb834b..8e0ea86a27 100644
--- a/crates/biome_configuration/src/analyzer/linter/rules.rs
+++ b/crates/biome_configuration/src/analyzer/linter/rules.rs
@@ -448,6 +448,7 @@ pub enum RuleName {
     UseValidForDirection,
     UseValidLang,
     UseValidTypeof,
+    UseVueDefineMacrosOrder,
     UseVueMultiWordComponentNames,
     UseWhile,
     UseYield,
@@ -818,6 +819,7 @@ impl RuleName {
             Self::UseValidForDirection => "useValidForDirection",
             Self::UseValidLang => "useValidLang",
             Self::UseValidTypeof => "useValidTypeof",
+            Self::UseVueDefineMacrosOrder => "useVueDefineMacrosOrder",
             Self::UseVueMultiWordComponentNames => "useVueMultiWordComponentNames",
             Self::UseWhile => "useWhile",
             Self::UseYield => "useYield",
@@ -1184,6 +1186,7 @@ impl RuleName {
             Self::UseValidForDirection => RuleGroup::Correctness,
             Self::UseValidLang => RuleGroup::A11y,
             Self::UseValidTypeof => RuleGroup::Correctness,
+            Self::UseVueDefineMacrosOrder => RuleGroup::Nursery,
             Self::UseVueMultiWordComponentNames => RuleGroup::Nursery,
             Self::UseWhile => RuleGroup::Complexity,
             Self::UseYield => RuleGroup::Correctness,
@@ -1559,6 +1562,7 @@ impl std::str::FromStr for RuleName {
             "useValidForDirection" => Ok(Self::UseValidForDirection),
             "useValidLang" => Ok(Self::UseValidLang),
             "useValidTypeof" => Ok(Self::UseValidTypeof),
+            "useVueDefineMacrosOrder" => Ok(Self::UseVueDefineMacrosOrder),
             "useVueMultiWordComponentNames" => Ok(Self::UseVueMultiWordComponentNames),
             "useWhile" => Ok(Self::UseWhile),
             "useYield" => Ok(Self::UseYield),
@@ -4646,7 +4650,7 @@ impl From<GroupPlainConfiguration> for Correctness {
 #[cfg_attr(feature = "schema", derive(JsonSchema))]
 #[serde(rename_all = "camelCase", default, deny_unknown_fields)]
 #[doc = r" A list of rules that belong to this group"]
-pub struct Nursery { # [doc = r" Enables the recommended rules for this group"] # [serde (skip_serializing_if = "Option::is_none")] pub recommended : Option < bool > , # [doc = "Restrict imports of deprecated exports."] # [serde (skip_serializing_if = "Option::is_none")] pub no_deprecated_imports : Option < RuleConfiguration < biome_rule_options :: no_deprecated_imports :: NoDeprecatedImportsOptions >> , # [doc = "Prevent the listing of duplicate dependencies. The rule supports the following dependency groups: \"bundledDependencies\", \"bundleDependencies\", \"dependencies\", \"devDependencies\", \"overrides\", \"optionalDependencies\", and \"peerDependencies\"."] # [serde (skip_serializing_if = "Option::is_none")] pub no_duplicate_dependencies : Option < RuleConfiguration < biome_rule_options :: no_duplicate_dependencies :: NoDuplicateDependenciesOptions >> , # [doc = "Disallow empty sources."] # [serde (skip_serializing_if = "Option::is_none")] pub no_empty_source : Option < RuleConfiguration < biome_rule_options :: no_empty_source :: NoEmptySourceOptions >> , # [doc = "Require Promise-like statements to be handled appropriately."] # [serde (skip_serializing_if = "Option::is_none")] pub no_floating_promises : Option < RuleFixConfiguration < biome_rule_options :: no_floating_promises :: NoFloatingPromisesOptions >> , # [doc = "Prevent import cycles."] # [serde (skip_serializing_if = "Option::is_none")] pub no_import_cycles : Option < RuleConfiguration < biome_rule_options :: no_import_cycles :: NoImportCyclesOptions >> , # [doc = "Disallow string literals inside JSX elements."] # [serde (skip_serializing_if = "Option::is_none")] pub no_jsx_literals : Option < RuleConfiguration < biome_rule_options :: no_jsx_literals :: NoJsxLiteralsOptions >> , # [doc = "Disallow Promises to be used in places where they are almost certainly a mistake."] # [serde (skip_serializing_if = "Option::is_none")] pub no_misused_promises : Option < RuleFixConfiguration < biome_rule_options :: no_misused_promises :: NoMisusedPromisesOptions >> , # [doc = "Prevent client components from being async functions."] # [serde (skip_serializing_if = "Option::is_none")] pub no_next_async_client_component : Option < RuleConfiguration < biome_rule_options :: no_next_async_client_component :: NoNextAsyncClientComponentOptions >> , # [doc = "Disallow non-null assertions after optional chaining expressions."] # [serde (skip_serializing_if = "Option::is_none")] pub no_non_null_asserted_optional_chain : Option < RuleConfiguration < biome_rule_options :: no_non_null_asserted_optional_chain :: NoNonNullAssertedOptionalChainOptions >> , # [doc = "Disallow useVisibleTask$() functions in Qwik components."] # [serde (skip_serializing_if = "Option::is_none")] pub no_qwik_use_visible_task : Option < RuleConfiguration < biome_rule_options :: no_qwik_use_visible_task :: NoQwikUseVisibleTaskOptions >> , # [doc = "Replaces usages of forwardRef with passing ref as a prop."] # [serde (skip_serializing_if = "Option::is_none")] pub no_react_forward_ref : Option < RuleFixConfiguration < biome_rule_options :: no_react_forward_ref :: NoReactForwardRefOptions >> , # [doc = "Disallow usage of sensitive data such as API keys and tokens."] # [serde (skip_serializing_if = "Option::is_none")] pub no_secrets : Option < RuleConfiguration < biome_rule_options :: no_secrets :: NoSecretsOptions >> , # [doc = "Disallow variable declarations from shadowing variables declared in the outer scope."] # [serde (skip_serializing_if = "Option::is_none")] pub no_shadow : Option < RuleConfiguration < biome_rule_options :: no_shadow :: NoShadowOptions >> , # [doc = "Disallow unnecessary type-based conditions that can be statically determined as redundant."] # [serde (skip_serializing_if = "Option::is_none")] pub no_unnecessary_conditions : Option < RuleConfiguration < biome_rule_options :: no_unnecessary_conditions :: NoUnnecessaryConditionsOptions >> , # [doc = "Warn when importing non-existing exports."] # [serde (skip_serializing_if = "Option::is_none")] pub no_unresolved_imports : Option < RuleConfiguration < biome_rule_options :: no_unresolved_imports :: NoUnresolvedImportsOptions >> , # [doc = "Disallow expression statements that are neither a function call nor an assignment."] # [serde (skip_serializing_if = "Option::is_none")] pub no_unused_expressions : Option < RuleConfiguration < biome_rule_options :: no_unused_expressions :: NoUnusedExpressionsOptions >> , # [doc = "Disallow unused catch bindings."] # [serde (skip_serializing_if = "Option::is_none")] pub no_useless_catch_binding : Option < RuleFixConfiguration < biome_rule_options :: no_useless_catch_binding :: NoUselessCatchBindingOptions >> , # [doc = "Disallow the use of useless undefined."] # [serde (skip_serializing_if = "Option::is_none")] pub no_useless_undefined : Option < RuleFixConfiguration < biome_rule_options :: no_useless_undefined :: NoUselessUndefinedOptions >> , # [doc = "Enforce that Vue component data options are declared as functions."] # [serde (skip_serializing_if = "Option::is_none")] pub no_vue_data_object_declaration : Option < RuleFixConfiguration < biome_rule_options :: no_vue_data_object_declaration :: NoVueDataObjectDeclarationOptions >> , # [doc = "Disallow duplicate keys in Vue component data, methods, computed properties, and other options."] # [serde (skip_serializing_if = "Option::is_none")] pub no_vue_duplicate_keys : Option < RuleConfiguration < biome_rule_options :: no_vue_duplicate_keys :: NoVueDuplicateKeysOptions >> , # [doc = "Disallow reserved keys in Vue component data and computed properties."] # [serde (skip_serializing_if = "Option::is_none")] pub no_vue_reserved_keys : Option < RuleConfiguration < biome_rule_options :: no_vue_reserved_keys :: NoVueReservedKeysOptions >> , # [doc = "Disallow reserved names to be used as props."] # [serde (skip_serializing_if = "Option::is_none")] pub no_vue_reserved_props : Option < RuleConfiguration < biome_rule_options :: no_vue_reserved_props :: NoVueReservedPropsOptions >> , # [doc = "Enforces href attribute for \\<a> elements."] # [serde (skip_serializing_if = "Option::is_none")] pub use_anchor_href : Option < RuleConfiguration < biome_rule_options :: use_anchor_href :: UseAnchorHrefOptions >> , # [doc = "Enforce consistent arrow function bodies."] # [serde (skip_serializing_if = "Option::is_none")] pub use_consistent_arrow_return : Option < RuleFixConfiguration < biome_rule_options :: use_consistent_arrow_return :: UseConsistentArrowReturnOptions >> , # [doc = "Enforce type definitions to consistently use either interface or type."] # [serde (skip_serializing_if = "Option::is_none")] pub use_consistent_type_definitions : Option < RuleFixConfiguration < biome_rule_options :: use_consistent_type_definitions :: UseConsistentTypeDefinitionsOptions >> , # [doc = "Require the @deprecated directive to specify a deletion date."] # [serde (skip_serializing_if = "Option::is_none")] pub use_deprecated_date : Option < RuleConfiguration < biome_rule_options :: use_deprecated_date :: UseDeprecatedDateOptions >> , # [doc = "Require switch-case statements to be exhaustive."] # [serde (skip_serializing_if = "Option::is_none")] pub use_exhaustive_switch_cases : Option < RuleFixConfiguration < biome_rule_options :: use_exhaustive_switch_cases :: UseExhaustiveSwitchCasesOptions >> , # [doc = "Enforce types in functions, methods, variables, and parameters."] # [serde (skip_serializing_if = "Option::is_none")] pub use_explicit_type : Option < RuleConfiguration < biome_rule_options :: use_explicit_type :: UseExplicitTypeOptions >> , # [doc = "Enforces that \\<img> elements have both width and height attributes."] # [serde (skip_serializing_if = "Option::is_none")] pub use_image_size : Option < RuleConfiguration < biome_rule_options :: use_image_size :: UseImageSizeOptions >> , # [doc = "Enforce a maximum number of parameters in function definitions."] # [serde (skip_serializing_if = "Option::is_none")] pub use_max_params : Option < RuleConfiguration < biome_rule_options :: use_max_params :: UseMaxParamsOptions >> , # [doc = "Prefer using the class prop as a classlist over the classnames helper."] # [serde (skip_serializing_if = "Option::is_none")] pub use_qwik_classlist : Option < RuleConfiguration < biome_rule_options :: use_qwik_classlist :: UseQwikClasslistOptions >> , # [doc = "Disallow use* hooks outside of component$ or other use* hooks in Qwik applications."] # [serde (skip_serializing_if = "Option::is_none")] pub use_qwik_method_usage : Option < RuleConfiguration < biome_rule_options :: use_qwik_method_usage :: UseQwikMethodUsageOptions >> , # [doc = "Disallow unserializable expressions in Qwik dollar ($) scopes."] # [serde (skip_serializing_if = "Option::is_none")] pub use_qwik_valid_lexical_scope : Option < RuleConfiguration < biome_rule_options :: use_qwik_valid_lexical_scope :: UseQwikValidLexicalScopeOptions >> , # [doc = "Enforce that components are defined as functions and never as classes."] # [serde (skip_serializing_if = "Option::is_none")] pub use_react_function_components : Option < RuleConfiguration < biome_rule_options :: use_react_function_components :: UseReactFunctionComponentsOptions >> , # [doc = "Enforce the sorting of CSS utility classes."] # [serde (skip_serializing_if = "Option::is_none")] pub use_sorted_classes : Option < RuleFixConfiguration < biome_rule_options :: use_sorted_classes :: UseSortedClassesOptions >> , # [doc = "Enforce multi-word component names in Vue components."] # [serde (skip_serializing_if = "Option::is_none")] pub use_vue_multi_word_component_names : Option < RuleConfiguration < biome_rule_options :: use_vue_multi_word_component_names :: UseVueMultiWordComponentNamesOptions >> }
+pub struct Nursery { # [doc = r" Enables the recommended rules for this group"] # [serde (skip_serializing_if = "Option::is_none")] pub recommended : Option < bool > , # [doc = "Restrict imports of deprecated exports."] # [serde (skip_serializing_if = "Option::is_none")] pub no_deprecated_imports : Option < RuleConfiguration < biome_rule_options :: no_deprecated_imports :: NoDeprecatedImportsOptions >> , # [doc = "Prevent the listing of duplicate dependencies. The rule supports the following dependency groups: \"bundledDependencies\", \"bundleDependencies\", \"dependencies\", \"devDependencies\", \"overrides\", \"optionalDependencies\", and \"peerDependencies\"."] # [serde (skip_serializing_if = "Option::is_none")] pub no_duplicate_dependencies : Option < RuleConfiguration < biome_rule_options :: no_duplicate_dependencies :: NoDuplicateDependenciesOptions >> , # [doc = "Disallow empty sources."] # [serde (skip_serializing_if = "Option::is_none")] pub no_empty_source : Option < RuleConfiguration < biome_rule_options :: no_empty_source :: NoEmptySourceOptions >> , # [doc = "Require Promise-like statements to be handled appropriately."] # [serde (skip_serializing_if = "Option::is_none")] pub no_floating_promises : Option < RuleFixConfiguration < biome_rule_options :: no_floating_promises :: NoFloatingPromisesOptions >> , # [doc = "Prevent import cycles."] # [serde (skip_serializing_if = "Option::is_none")] pub no_import_cycles : Option < RuleConfiguration < biome_rule_options :: no_import_cycles :: NoImportCyclesOptions >> , # [doc = "Disallow string literals inside JSX elements."] # [serde (skip_serializing_if = "Option::is_none")] pub no_jsx_literals : Option < RuleConfiguration < biome_rule_options :: no_jsx_literals :: NoJsxLiteralsOptions >> , # [doc = "Disallow Promises to be used in places where they are almost certainly a mistake."] # [serde (skip_serializing_if = "Option::is_none")] pub no_misused_promises : Option < RuleFixConfiguration < biome_rule_options :: no_misused_promises :: NoMisusedPromisesOptions >> , # [doc = "Prevent client components from being async functions."] # [serde (skip_serializing_if = "Option::is_none")] pub no_next_async_client_component : Option < RuleConfiguration < biome_rule_options :: no_next_async_client_component :: NoNextAsyncClientComponentOptions >> , # [doc = "Disallow non-null assertions after optional chaining expressions."] # [serde (skip_serializing_if = "Option::is_none")] pub no_non_null_asserted_optional_chain : Option < RuleConfiguration < biome_rule_options :: no_non_null_asserted_optional_chain :: NoNonNullAssertedOptionalChainOptions >> , # [doc = "Disallow useVisibleTask$() functions in Qwik components."] # [serde (skip_serializing_if = "Option::is_none")] pub no_qwik_use_visible_task : Option < RuleConfiguration < biome_rule_options :: no_qwik_use_visible_task :: NoQwikUseVisibleTaskOptions >> , # [doc = "Replaces usages of forwardRef with passing ref as a prop."] # [serde (skip_serializing_if = "Option::is_none")] pub no_react_forward_ref : Option < RuleFixConfiguration < biome_rule_options :: no_react_forward_ref :: NoReactForwardRefOptions >> , # [doc = "Disallow usage of sensitive data such as API keys and tokens."] # [serde (skip_serializing_if = "Option::is_none")] pub no_secrets : Option < RuleConfiguration < biome_rule_options :: no_secrets :: NoSecretsOptions >> , # [doc = "Disallow variable declarations from shadowing variables declared in the outer scope."] # [serde (skip_serializing_if = "Option::is_none")] pub no_shadow : Option < RuleConfiguration < biome_rule_options :: no_shadow :: NoShadowOptions >> , # [doc = "Disallow unnecessary type-based conditions that can be statically determined as redundant."] # [serde (skip_serializing_if = "Option::is_none")] pub no_unnecessary_conditions : Option < RuleConfiguration < biome_rule_options :: no_unnecessary_conditions :: NoUnnecessaryConditionsOptions >> , # [doc = "Warn when importing non-existing exports."] # [serde (skip_serializing_if = "Option::is_none")] pub no_unresolved_imports : Option < RuleConfiguration < biome_rule_options :: no_unresolved_imports :: NoUnresolvedImportsOptions >> , # [doc = "Disallow expression statements that are neither a function call nor an assignment."] # [serde (skip_serializing_if = "Option::is_none")] pub no_unused_expressions : Option < RuleConfiguration < biome_rule_options :: no_unused_expressions :: NoUnusedExpressionsOptions >> , # [doc = "Disallow unused catch bindings."] # [serde (skip_serializing_if = "Option::is_none")] pub no_useless_catch_binding : Option < RuleFixConfiguration < biome_rule_options :: no_useless_catch_binding :: NoUselessCatchBindingOptions >> , # [doc = "Disallow the use of useless undefined."] # [serde (skip_serializing_if = "Option::is_none")] pub no_useless_undefined : Option < RuleFixConfiguration < biome_rule_options :: no_useless_undefined :: NoUselessUndefinedOptions >> , # [doc = "Enforce that Vue component data options are declared as functions."] # [serde (skip_serializing_if = "Option::is_none")] pub no_vue_data_object_declaration : Option < RuleFixConfiguration < biome_rule_options :: no_vue_data_object_declaration :: NoVueDataObjectDeclarationOptions >> , # [doc = "Disallow duplicate keys in Vue component data, methods, computed properties, and other options."] # [serde (skip_serializing_if = "Option::is_none")] pub no_vue_duplicate_keys : Option < RuleConfiguration < biome_rule_options :: no_vue_duplicate_keys :: NoVueDuplicateKeysOptions >> , # [doc = "Disallow reserved keys in Vue component data and computed properties."] # [serde (skip_serializing_if = "Option::is_none")] pub no_vue_reserved_keys : Option < RuleConfiguration < biome_rule_options :: no_vue_reserved_keys :: NoVueReservedKeysOptions >> , # [doc = "Disallow reserved names to be used as props."] # [serde (skip_serializing_if = "Option::is_none")] pub no_vue_reserved_props : Option < RuleConfiguration < biome_rule_options :: no_vue_reserved_props :: NoVueReservedPropsOptions >> , # [doc = "Enforces href attribute for \\<a> elements."] # [serde (skip_serializing_if = "Option::is_none")] pub use_anchor_href : Option < RuleConfiguration < biome_rule_options :: use_anchor_href :: UseAnchorHrefOptions >> , # [doc = "Enforce consistent arrow function bodies."] # [serde (skip_serializing_if = "Option::is_none")] pub use_consistent_arrow_return : Option < RuleFixConfiguration < biome_rule_options :: use_consistent_arrow_return :: UseConsistentArrowReturnOptions >> , # [doc = "Enforce type definitions to consistently use either interface or type."] # [serde (skip_serializing_if = "Option::is_none")] pub use_consistent_type_definitions : Option < RuleFixConfiguration < biome_rule_options :: use_consistent_type_definitions :: UseConsistentTypeDefinitionsOptions >> , # [doc = "Require the @deprecated directive to specify a deletion date."] # [serde (skip_serializing_if = "Option::is_none")] pub use_deprecated_date : Option < RuleConfiguration < biome_rule_options :: use_deprecated_date :: UseDeprecatedDateOptions >> , # [doc = "Require switch-case statements to be exhaustive."] # [serde (skip_serializing_if = "Option::is_none")] pub use_exhaustive_switch_cases : Option < RuleFixConfiguration < biome_rule_options :: use_exhaustive_switch_cases :: UseExhaustiveSwitchCasesOptions >> , # [doc = "Enforce types in functions, methods, variables, and parameters."] # [serde (skip_serializing_if = "Option::is_none")] pub use_explicit_type : Option < RuleConfiguration < biome_rule_options :: use_explicit_type :: UseExplicitTypeOptions >> , # [doc = "Enforces that \\<img> elements have both width and height attributes."] # [serde (skip_serializing_if = "Option::is_none")] pub use_image_size : Option < RuleConfiguration < biome_rule_options :: use_image_size :: UseImageSizeOptions >> , # [doc = "Enforce a maximum number of parameters in function definitions."] # [serde (skip_serializing_if = "Option::is_none")] pub use_max_params : Option < RuleConfiguration < biome_rule_options :: use_max_params :: UseMaxParamsOptions >> , # [doc = "Prefer using the class prop as a classlist over the classnames helper."] # [serde (skip_serializing_if = "Option::is_none")] pub use_qwik_classlist : Option < RuleConfiguration < biome_rule_options :: use_qwik_classlist :: UseQwikClasslistOptions >> , # [doc = "Disallow use* hooks outside of component$ or other use* hooks in Qwik applications."] # [serde (skip_serializing_if = "Option::is_none")] pub use_qwik_method_usage : Option < RuleConfiguration < biome_rule_options :: use_qwik_method_usage :: UseQwikMethodUsageOptions >> , # [doc = "Disallow unserializable expressions in Qwik dollar ($) scopes."] # [serde (skip_serializing_if = "Option::is_none")] pub use_qwik_valid_lexical_scope : Option < RuleConfiguration < biome_rule_options :: use_qwik_valid_lexical_scope :: UseQwikValidLexicalScopeOptions >> , # [doc = "Enforce that components are defined as functions and never as classes."] # [serde (skip_serializing_if = "Option::is_none")] pub use_react_function_components : Option < RuleConfiguration < biome_rule_options :: use_react_function_components :: UseReactFunctionComponentsOptions >> , # [doc = "Enforce the sorting of CSS utility classes."] # [serde (skip_serializing_if = "Option::is_none")] pub use_sorted_classes : Option < RuleFixConfiguration < biome_rule_options :: use_sorted_classes :: UseSortedClassesOptions >> , # [doc = "Enforce specific order of Vue compiler macros."] # [serde (skip_serializing_if = "Option::is_none")] pub use_vue_define_macros_order : Option < RuleFixConfiguration < biome_rule_options :: use_vue_define_macros_order :: UseVueDefineMacrosOrderOptions >> , # [doc = "Enforce multi-word component names in Vue components."] # [serde (skip_serializing_if = "Option::is_none")] pub use_vue_multi_word_component_names : Option < RuleConfiguration < biome_rule_options :: use_vue_multi_word_component_names :: UseVueMultiWordComponentNamesOptions >> }
 impl Nursery {
     const GROUP_NAME: &'static str = "nursery";
     pub(crate) const GROUP_RULES: &'static [&'static str] = &[
@@ -4685,6 +4689,7 @@ impl Nursery {
         "useQwikValidLexicalScope",
         "useReactFunctionComponents",
         "useSortedClasses",
+        "useVueDefineMacrosOrder",
         "useVueMultiWordComponentNames",
     ];
     const RECOMMENDED_RULES_AS_FILTERS: &'static [RuleFilter<'static>] =
@@ -4726,6 +4731,7 @@ impl Nursery {
         RuleFilter::Rule(Self::GROUP_NAME, Self::GROUP_RULES[33]),
         RuleFilter::Rule(Self::GROUP_NAME, Self::GROUP_RULES[34]),
         RuleFilter::Rule(Self::GROUP_NAME, Self::GROUP_RULES[35]),
+        RuleFilter::Rule(Self::GROUP_NAME, Self::GROUP_RULES[36]),
     ];
 }
 impl RuleGroupExt for Nursery {
@@ -4912,11 +4918,16 @@ impl RuleGroupExt for Nursery {
         {
             index_set.insert(RuleFilter::Rule(Self::GROUP_NAME, Self::GROUP_RULES[34]));
         }
-        if let Some(rule) = self.use_vue_multi_word_component_names.as_ref()
+        if let Some(rule) = self.use_vue_define_macros_order.as_ref()
             && rule.is_enabled()
         {
             index_set.insert(RuleFilter::Rule(Self::GROUP_NAME, Self::GROUP_RULES[35]));
         }
+        if let Some(rule) = self.use_vue_multi_word_component_names.as_ref()
+            && rule.is_enabled()
+        {
+            index_set.insert(RuleFilter::Rule(Self::GROUP_NAME, Self::GROUP_RULES[36]));
+        }
         index_set
     }
     fn get_disabled_rules(&self) -> FxHashSet<RuleFilter<'static>> {
@@ -5096,11 +5107,16 @@ impl RuleGroupExt for Nursery {
         {
             index_set.insert(RuleFilter::Rule(Self::GROUP_NAME, Self::GROUP_RULES[34]));
         }
-        if let Some(rule) = self.use_vue_multi_word_component_names.as_ref()
+        if let Some(rule) = self.use_vue_define_macros_order.as_ref()
             && rule.is_disabled()
         {
             index_set.insert(RuleFilter::Rule(Self::GROUP_NAME, Self::GROUP_RULES[35]));
         }
+        if let Some(rule) = self.use_vue_multi_word_component_names.as_ref()
+            && rule.is_disabled()
+        {
+            index_set.insert(RuleFilter::Rule(Self::GROUP_NAME, Self::GROUP_RULES[36]));
+        }
         index_set
     }
     #[doc = r" Checks if, given a rule name, matches one of the rules contained in this category"]
@@ -5271,6 +5287,10 @@ impl RuleGroupExt for Nursery {
                 .use_sorted_classes
                 .as_ref()
                 .map(|conf| (conf.level(), conf.get_options())),
+            "useVueDefineMacrosOrder" => self
+                .use_vue_define_macros_order
+                .as_ref()
+                .map(|conf| (conf.level(), conf.get_options())),
             "useVueMultiWordComponentNames" => self
                 .use_vue_multi_word_component_names
                 .as_ref()
@@ -5318,6 +5338,7 @@ impl From<GroupPlainConfiguration> for Nursery {
             use_qwik_valid_lexical_scope: Some(value.into()),
             use_react_function_components: Some(value.into()),
             use_sorted_classes: Some(value.into()),
+            use_vue_define_macros_order: Some(value.into()),
             use_vue_multi_word_component_names: Some(value.into()),
         }
     }
diff --git a/crates/biome_diagnostics_categories/src/categories.rs b/crates/biome_diagnostics_categories/src/categories.rs
index 6f96b6c343..c03434670c 100644
--- a/crates/biome_diagnostics_categories/src/categories.rs
+++ b/crates/biome_diagnostics_categories/src/categories.rs
@@ -206,6 +206,7 @@ define_categories! {
     "lint/nursery/useQwikValidLexicalScope": "https://biomejs.dev/linter/rules/use-qwik-valid-lexical-scope",
     "lint/nursery/useReactFunctionComponents": "https://biomejs.dev/linter/rules/use-react-function-components",
     "lint/nursery/useSortedClasses": "https://biomejs.dev/linter/rules/use-sorted-classes",
+    "lint/nursery/useVueDefineMacrosOrder": "https://biomejs.dev/linter/rules/use-vue-define-macros-order",
     "lint/nursery/useVueMultiWordComponentNames": "https://biomejs.dev/linter/rules/use-vue-multi-word-component-names",
     "lint/performance/noAccumulatingSpread": "https://biomejs.dev/linter/rules/no-accumulating-spread",
     "lint/performance/noAwaitInLoops": "https://biomejs.dev/linter/rules/no-await-in-loops",
diff --git a/crates/biome_js_analyze/src/lint/nursery.rs b/crates/biome_js_analyze/src/lint/nursery.rs
index 59670fe874..3b02a97f41 100644
--- a/crates/biome_js_analyze/src/lint/nursery.rs
+++ b/crates/biome_js_analyze/src/lint/nursery.rs
@@ -36,5 +36,6 @@ pub mod use_qwik_method_usage;
 pub mod use_qwik_valid_lexical_scope;
 pub mod use_react_function_components;
 pub mod use_sorted_classes;
+pub mod use_vue_define_macros_order;
 pub mod use_vue_multi_word_component_names;
-declare_lint_group! { pub Nursery { name : "nursery" , rules : [self :: no_deprecated_imports :: NoDeprecatedImports , self :: no_empty_source :: NoEmptySource , self :: no_floating_promises :: NoFloatingPromises , self :: no_import_cycles :: NoImportCycles , self :: no_jsx_literals :: NoJsxLiterals , self :: no_misused_promises :: NoMisusedPromises , self :: no_next_async_client_component :: NoNextAsyncClientComponent , self :: no_non_null_asserted_optional_chain :: NoNonNullAssertedOptionalChain , self :: no_qwik_use_visible_task :: NoQwikUseVisibleTask , self :: no_react_forward_ref :: NoReactForwardRef , self :: no_secrets :: NoSecrets , self :: no_shadow :: NoShadow , self :: no_unnecessary_conditions :: NoUnnecessaryConditions , self :: no_unresolved_imports :: NoUnresolvedImports , self :: no_unused_expressions :: NoUnusedExpressions , self :: no_useless_catch_binding :: NoUselessCatchBinding , self :: no_useless_undefined :: NoUselessUndefined , self :: no_vue_data_object_declaration :: NoVueDataObjectDeclaration , self :: no_vue_duplicate_keys :: NoVueDuplicateKeys , self :: no_vue_reserved_keys :: NoVueReservedKeys , self :: no_vue_reserved_props :: NoVueReservedProps , self :: use_anchor_href :: UseAnchorHref , self :: use_consistent_arrow_return :: UseConsistentArrowReturn , self :: use_consistent_type_definitions :: UseConsistentTypeDefinitions , self :: use_exhaustive_switch_cases :: UseExhaustiveSwitchCases , self :: use_explicit_type :: UseExplicitType , self :: use_image_size :: UseImageSize , self :: use_max_params :: UseMaxParams , self :: use_qwik_classlist :: UseQwikClasslist , self :: use_qwik_method_usage :: UseQwikMethodUsage , self :: use_qwik_valid_lexical_scope :: UseQwikValidLexicalScope , self :: use_react_function_components :: UseReactFunctionComponents , self :: use_sorted_classes :: UseSortedClasses , self :: use_vue_multi_word_component_names :: UseVueMultiWordComponentNames ,] } }
+declare_lint_group! { pub Nursery { name : "nursery" , rules : [self :: no_deprecated_imports :: NoDeprecatedImports , self :: no_empty_source :: NoEmptySource , self :: no_floating_promises :: NoFloatingPromises , self :: no_import_cycles :: NoImportCycles , self :: no_jsx_literals :: NoJsxLiterals , self :: no_misused_promises :: NoMisusedPromises , self :: no_next_async_client_component :: NoNextAsyncClientComponent , self :: no_non_null_asserted_optional_chain :: NoNonNullAssertedOptionalChain , self :: no_qwik_use_visible_task :: NoQwikUseVisibleTask , self :: no_react_forward_ref :: NoReactForwardRef , self :: no_secrets :: NoSecrets , self :: no_shadow :: NoShadow , self :: no_unnecessary_conditions :: NoUnnecessaryConditions , self :: no_unresolved_imports :: NoUnresolvedImports , self :: no_unused_expressions :: NoUnusedExpressions , self :: no_useless_catch_binding :: NoUselessCatchBinding , self :: no_useless_undefined :: NoUselessUndefined , self :: no_vue_data_object_declaration :: NoVueDataObjectDeclaration , self :: no_vue_duplicate_keys :: NoVueDuplicateKeys , self :: no_vue_reserved_keys :: NoVueReservedKeys , self :: no_vue_reserved_props :: NoVueReservedProps , self :: use_anchor_href :: UseAnchorHref , self :: use_consistent_arrow_return :: UseConsistentArrowReturn , self :: use_consistent_type_definitions :: UseConsistentTypeDefinitions , self :: use_exhaustive_switch_cases :: UseExhaustiveSwitchCases , self :: use_explicit_type :: UseExplicitType , self :: use_image_size :: UseImageSize , self :: use_max_params :: UseMaxParams , self :: use_qwik_classlist :: UseQwikClasslist , self :: use_qwik_method_usage :: UseQwikMethodUsage , self :: use_qwik_valid_lexical_scope :: UseQwikValidLexicalScope , self :: use_react_function_components :: UseReactFunctionComponents , self :: use_sorted_classes :: UseSortedClasses , self :: use_vue_define_macros_order :: UseVueDefineMacrosOrder , self :: use_vue_multi_word_component_names :: UseVueMultiWordComponentNames ,] } }
diff --git a/crates/biome_js_analyze/src/lint/nursery/use_vue_define_macros_order.rs b/crates/biome_js_analyze/src/lint/nursery/use_vue_define_macros_order.rs
new file mode 100644
index 0000000000..08d04e8f63
--- /dev/null
+++ b/crates/biome_js_analyze/src/lint/nursery/use_vue_define_macros_order.rs
@@ -0,0 +1,361 @@
+use std::collections::HashMap;
+
+use biome_analyze::{
+    Ast, FixKind, Rule, RuleDiagnostic, RuleDomain, RuleSource, context::RuleContext,
+    declare_lint_rule,
+};
+use biome_console::markup;
+use biome_js_factory::make::{self, js_module_item_list};
+use biome_js_syntax::{
+    AnyJsExpression, AnyJsModuleItem, JsModuleItemList, JsSyntaxKind, JsVariableDeclarator,
+    JsVariableDeclaratorList, T,
+};
+use biome_rowan::{AstNode, BatchMutationExt, TextRange, TokenText, TriviaPieceKind};
+use biome_rule_options::use_vue_define_macros_order::UseVueDefineMacrosOrderOptions;
+
+use crate::JsRuleAction;
+
+declare_lint_rule! {
+    /// Enforce specific order of Vue compiler macros.
+    ///
+    /// This rule ensures consistent ordering of Vue's Composition API compiler macros in `<script setup>` blocks.
+    /// Enforcing a consistent order improves code readability and maintainability by establishing a predictable structure.
+    ///
+    /// These macros must also appear before any other statements (except imports, type declarations, and debugger statements).
+    ///
+    /// ## Examples
+    ///
+    /// ### Invalid
+    ///
+    /// ```vue,expect_diagnostic
+    /// <script lang="ts" setup>
+    /// const emit = defineEmits(['update'])
+    /// const props = defineProps<{ name: string }>()
+    /// </script>
+    /// ```
+    ///
+    /// ```vue,expect_diagnostic
+    /// <script lang="ts" setup>
+    /// import { ref } from 'vue'
+    ///
+    /// const count = ref(0)
+    /// const props = defineProps<{ name: string }>()
+    /// </script>
+    /// ```
+    ///
+    /// ### Valid
+    ///
+    /// ```vue
+    /// <script lang="ts" setup>
+    /// const props = defineProps<{ name: string }>()
+    /// const emit = defineEmits(['update'])
+    /// </script>
+    /// ```
+    ///
+    /// ```vue
+    /// <script lang="ts" setup>
+    /// import { ref } from 'vue'
+    ///
+    /// const model = defineModel()
+    /// const props = defineProps<{ name: string }>()
+    /// const emit = defineEmits(['update'])
+    ///
+    /// const count = ref(0)
+    /// </script>
+    /// ```
+    ///
+    /// ```vue
+    /// <script lang="ts" setup>
+    /// import { ref } from 'vue'
+    ///
+    /// interface Props {
+    ///   value: string
+    /// }
+    ///
+    /// const props = defineProps<Props>()
+    /// const emit = defineEmits(['update'])
+    /// </script>
+    /// ```
+    ///
+    /// ## Options
+    ///
+    /// ### `order`
+    ///
+    /// Allows specifying the order in which the Vue compiler macros should appear.
+    ///
+    /// **Default:** `["defineModel", "defineProps", "defineEmits"]`
+    ///
+    /// This is not limited to built-in macros, for example unplug-vue-router [definePage](https://uvr.esm.is/guide/extending-routes.html#definepage)
+    /// can be listed here as well.
+    ///
+    /// ```json,options
+    /// {
+    ///   "options": {
+    ///     "order": ["definePage", "defineProps", "defineEmits", "defineModel"]
+    ///   }
+    /// }
+    /// ```
+    ///
+    pub UseVueDefineMacrosOrder {
+        version: "next",
+        name: "useVueDefineMacrosOrder",
+        language: "js",
+        sources: &[RuleSource::EslintVueJs("define-macros-order").same()],
+        recommended: false,
+        domains: &[RuleDomain::Vue],
+        fix_kind: FixKind::Unsafe,
+    }
+}
+
+impl Rule for UseVueDefineMacrosOrder {
+    type Query = Ast<JsModuleItemList>;
+    type State = MacroOrderIssue;
+    type Signals = Option<Self::State>;
+    type Options = UseVueDefineMacrosOrderOptions;
+
+    fn run(ctx: &RuleContext<Self>) -> Self::Signals {
+        // TODO: Need to run this only on <script setup> blocks.
+        let path = ctx.file_path();
+        if path.extension() != Some("vue") {
+            return None;
+        }
+
+        let order = &ctx.options().order;
+        let order_map: HashMap<&str, usize> = order
+            .iter()
+            .enumerate()
+            .map(|(idx, s)| (s.as_ref(), idx))
+            .collect();
+
+        struct FoundMacro {
+            order_index: usize,
+            fixable_statement_index: Option<usize>,
+            range: TextRange,
+            has_out_of_order_content_prior: bool,
+        }
+
+        let mut non_macro_found = false;
+        let mut skippable_top_statements_end_index = 0;
+        let mut found_macro: Option<FoundMacro> = None;
+
+        for (index, statement) in ctx.query().into_iter().enumerate() {
+            if is_skippable_before_macro(&statement) {
+                if found_macro.is_none() && !non_macro_found {
+                    skippable_top_statements_end_index = index + 1;
+                }
+
+                continue;
+            }
+
+            if let Some(name) = get_name_from_call_expr(&statement)
+                && let Some(&order_index) = order_map.get(name.as_ref())
+            {
+                match &found_macro {
+                    None => {
+                        found_macro = Some(FoundMacro {
+                            order_index,
+                            fixable_statement_index: Some(index),
+                            range: statement.range(),
+                            has_out_of_order_content_prior: non_macro_found,
+                        });
+                    }
+                    Some(c) if order_index < c.order_index => {
+                        found_macro = Some(FoundMacro {
+                            order_index,
+                            fixable_statement_index: Some(index),
+                            range: statement.range(),
+                            has_out_of_order_content_prior: true,
+                        });
+                    }
+                    _ => {
+                        // Same/higher order, do nothing
+                    }
+                }
+            } else if let Some(declarators) = get_declarators_from_statement(&statement) {
+                // If there are multiple declarators, fixing is not trivial, so we won't suggest it.
+                let fixable_statement_index = if (&declarators).into_iter().count() == 1 {
+                    Some(index)
+                } else {
+                    None
+                };
+
+                for declarator in declarators {
+                    let Some(declarator) = declarator.ok() else {
+                        non_macro_found = true;
+                        continue;
+                    };
+
+                    if let Some(name) = get_name_from_declarator(&declarator)
+                        && let Some(&order_index) = order_map.get(name.as_ref())
+                    {
+                        let range = declarator.range();
+                        match &found_macro {
+                            None => {
+                                found_macro = Some(FoundMacro {
+                                    order_index,
+                                    fixable_statement_index,
+                                    range,
+                                    has_out_of_order_content_prior: non_macro_found,
+                                });
+                            }
+                            Some(c) => {
+                                let has_out_of_order_content_prior = if order_index < c.order_index
+                                {
+                                    true
+                                } else {
+                                    c.has_out_of_order_content_prior || non_macro_found
+                                };
+
+                                found_macro = Some(FoundMacro {
+                                    order_index,
+                                    fixable_statement_index,
+                                    range,
+                                    has_out_of_order_content_prior,
+                                });
+                            }
+                        }
+                    } else {
+                        non_macro_found = true;
+                    }
+                }
+            } else {
+                non_macro_found = true;
+            }
+        }
+
+        if let Some(vue_macro) = found_macro
+            && vue_macro.has_out_of_order_content_prior
+        {
+            return Some(MacroOrderIssue {
+                range: vue_macro.range,
+                name: order[vue_macro.order_index].clone(),
+                move_from_to: vue_macro
+                    .fixable_statement_index
+                    .map(|index| (index, skippable_top_statements_end_index)),
+            });
+        }
+
+        None
+    }
+
+    fn diagnostic(ctx: &RuleContext<Self>, state: &Self::State) -> Option<RuleDiagnostic> {
+        let order = &ctx.options().order;
+
+        let pretty_order = order
+            .iter()
+            .map(|s| s.as_ref())
+            .collect::<Vec<&str>>()
+            .join(", ");
+
+        Some(
+            RuleDiagnostic::new(
+                rule_category!(),
+                state.range,
+                markup! {
+                    <Emphasis>{state.name}</Emphasis>" macro is out of order."
+                },
+            )
+            .note(markup! {
+                "Macros defined in <script setup> should be ordered as follows: "<Emphasis>{pretty_order}</Emphasis>
+            })
+            // and before skippable content
+            .note(markup! {
+                "and be placed before any non-macro statements, except for type declarations, imports, exports or debugger statements."
+            }),
+        )
+    }
+
+    fn action(ctx: &RuleContext<Self>, state: &Self::State) -> Option<JsRuleAction> {
+        let (from, to) = state.move_from_to?;
+
+        let root = ctx.query();
+        let mut mutation = root.clone().begin();
+
+        let mut statements: Vec<AnyJsModuleItem> = root.into_iter().collect();
+        let statement = statements.remove(from);
+
+        // Need to add newline after the moved statement, because it may not have one.
+        let trailing_trivia = make::token(T![;])
+            .with_trailing_trivia([(TriviaPieceKind::Newline, "\n")])
+            .trailing_trivia()
+            .pieces();
+
+        let statement = statement.with_trailing_trivia_pieces(trailing_trivia)?;
+        statements.insert(to, statement);
+
+        let new_modules_list = js_module_item_list(statements);
+        mutation.replace_node(root.clone(), new_modules_list);
+
+        Some(JsRuleAction::new(
+            ctx.metadata().action_category(ctx.category(), ctx.group()),
+            ctx.metadata().applicability(),
+            markup! { "Reorder macro "<Emphasis>{state.name}</Emphasis>"." }.to_owned(),
+            mutation,
+        ))
+    }
+}
+
+pub struct MacroOrderIssue {
+    range: TextRange,
+    name: Box<str>,
+    move_from_to: Option<(usize, usize)>,
+}
+
+fn get_name_from_call_expr(item: &AnyJsModuleItem) -> Option<TokenText> {
+    let statement = item.as_any_js_statement()?;
+    let expr_statement = statement.as_js_expression_statement()?;
+    let expr = expr_statement.expression().ok()?;
+
+    get_possible_macro_name(&expr)
+}
+
+fn get_name_from_declarator(declarator: &JsVariableDeclarator) -> Option<TokenText> {
+    let initializer = declarator.initializer()?;
+    let expr = initializer.expression().ok()?;
+    let name = get_possible_macro_name(&expr)?;
+
+    Some(name)
+}
+
+fn get_declarators_from_statement(item: &AnyJsModuleItem) -> Option<JsVariableDeclaratorList> {
+    let statement = item.as_any_js_statement()?;
+    let statement = statement.as_js_variable_statement()?;
+    let declaration = statement.declaration().ok()?;
+
+    Some(declaration.declarators())
+}
+
+fn get_possible_macro_name(expr: &AnyJsExpression) -> Option<TokenText> {
+    let callee = expr.as_js_call_expression()?.callee().ok()?;
+    let name = callee.get_callee_object_name()?.token_text_trimmed();
+
+    if name == "withDefaults" {
+        let args = expr.as_js_call_expression()?.arguments().ok()?;
+        let first_arg = args.args().into_iter().next()?.ok()?;
+        let first_arg_expr = first_arg.as_any_js_expression()?;
+        let inner_name = get_possible_macro_name(first_arg_expr)?;
+
+        if inner_name == "defineProps" {
+            return Some(inner_name);
+        } else {
+            return None;
+        }
+    }
+
+    Some(name)
+}
+
+/// What can appear before the macro without causing a violation.
+fn is_skippable_before_macro(item: &AnyJsModuleItem) -> bool {
+    matches!(
+        item.syntax().kind(),
+        JsSyntaxKind::TS_TYPE_ALIAS_DECLARATION
+            | JsSyntaxKind::TS_INTERFACE_DECLARATION
+            | JsSyntaxKind::TS_MODULE_DECLARATION
+            | JsSyntaxKind::JS_DEBUGGER_STATEMENT
+            | JsSyntaxKind::JS_EMPTY_STATEMENT
+            | JsSyntaxKind::JS_IMPORT
+            | JsSyntaxKind::JS_EXPORT_NAMED_CLAUSE
+            | JsSyntaxKind::JS_EXPORT
+    )
+}
diff --git a/crates/biome_rule_options/src/lib.rs b/crates/biome_rule_options/src/lib.rs
index 1d92577ec1..1ee3f97c62 100644
--- a/crates/biome_rule_options/src/lib.rs
+++ b/crates/biome_rule_options/src/lib.rs
@@ -365,6 +365,7 @@ pub mod use_valid_autocomplete;
 pub mod use_valid_for_direction;
 pub mod use_valid_lang;
 pub mod use_valid_typeof;
+pub mod use_vue_define_macros_order;
 pub mod use_vue_multi_word_component_names;
 pub mod use_while;
 pub mod use_yield;
diff --git a/crates/biome_rule_options/src/use_vue_define_macros_order.rs b/crates/biome_rule_options/src/use_vue_define_macros_order.rs
new file mode 100644
index 0000000000..59d794937d
--- /dev/null
+++ b/crates/biome_rule_options/src/use_vue_define_macros_order.rs
@@ -0,0 +1,23 @@
+use biome_deserialize_macros::Deserializable;
+use serde::{Deserialize, Serialize};
+#[derive(Clone, Debug, Deserialize, Deserializable, Eq, PartialEq, Serialize)]
+#[cfg_attr(feature = "schema", derive(schemars::JsonSchema))]
+#[serde(rename_all = "camelCase", deny_unknown_fields, default)]
+pub struct UseVueDefineMacrosOrderOptions {
+    /// The order of the Vue define macros.
+    #[serde(default)]
+    pub order: Box<[Box<str>]>,
+}
+
+impl Default for UseVueDefineMacrosOrderOptions {
+    fn default() -> Self {
+        Self {
+            order: vec![
+                "defineModel".into(),
+                "defineProps".into(),
+                "defineEmits".into(),
+            ]
+            .into_boxed_slice(),
+        }
+    }
+}
diff --git a/packages/@biomejs/backend-jsonrpc/src/workspace.ts b/packages/@biomejs/backend-jsonrpc/src/workspace.ts
index eeda915040..3682c077cf 100644
--- a/packages/@biomejs/backend-jsonrpc/src/workspace.ts
+++ b/packages/@biomejs/backend-jsonrpc/src/workspace.ts
@@ -1769,6 +1769,10 @@ export interface Nursery {
 	 * Enforce the sorting of CSS utility classes.
 	 */
 	useSortedClasses?: RuleFixConfiguration_for_UseSortedClassesOptions;
+	/**
+	 * Enforce specific order of Vue compiler macros.
+	 */
+	useVueDefineMacrosOrder?: RuleFixConfiguration_for_UseVueDefineMacrosOrderOptions;
 	/**
 	 * Enforce multi-word component names in Vue components.
 	 */
@@ -3115,6 +3119,9 @@ export type RuleConfiguration_for_UseReactFunctionComponentsOptions =
 export type RuleFixConfiguration_for_UseSortedClassesOptions =
 	| RulePlainConfiguration
 	| RuleWithFixOptions_for_UseSortedClassesOptions;
+export type RuleFixConfiguration_for_UseVueDefineMacrosOrderOptions =
+	| RulePlainConfiguration
+	| RuleWithFixOptions_for_UseVueDefineMacrosOrderOptions;
 export type RuleConfiguration_for_UseVueMultiWordComponentNamesOptions =
 	| RulePlainConfiguration
 	| RuleWithOptions_for_UseVueMultiWordComponentNamesOptions;
@@ -5793,6 +5800,20 @@ export interface RuleWithFixOptions_for_UseSortedClassesOptions {
 	 */
 	options: UseSortedClassesOptions;
 }
+export interface RuleWithFixOptions_for_UseVueDefineMacrosOrderOptions {
+	/**
+	 * The kind of the code actions emitted by the rule
+	 */
+	fix?: FixKind;
+	/**
+	 * The severity of the emitted diagnostics by the rule
+	 */
+	level: RulePlainConfiguration;
+	/**
+	 * Rule's options
+	 */
+	options: UseVueDefineMacrosOrderOptions;
+}
 export interface RuleWithOptions_for_UseVueMultiWordComponentNamesOptions {
 	/**
 	 * The severity of the emitted diagnostics by the rule
@@ -8296,6 +8317,12 @@ export interface UseSortedClassesOptions {
 	 */
 	functions?: string[];
 }
+export interface UseVueDefineMacrosOrderOptions {
+	/**
+	 * The order of the Vue define macros.
+	 */
+	order?: string[];
+}
 export interface UseVueMultiWordComponentNamesOptions {
 	/**
 	 * Component names to ignore (allowed to be single-word).
@@ -9027,6 +9054,7 @@ export type Category =
 	| "lint/nursery/useQwikValidLexicalScope"
 	| "lint/nursery/useReactFunctionComponents"
 	| "lint/nursery/useSortedClasses"
+	| "lint/nursery/useVueDefineMacrosOrder"
 	| "lint/nursery/useVueMultiWordComponentNames"
 	| "lint/performance/noAccumulatingSpread"
 	| "lint/performance/noAwaitInLoops"
diff --git a/packages/@biomejs/biome/configuration_schema.json b/packages/@biomejs/biome/configuration_schema.json
index 3e4332ca54..8fb85bc10e 100644
--- a/packages/@biomejs/biome/configuration_schema.json
+++ b/packages/@biomejs/biome/configuration_schema.json
@@ -5259,6 +5259,13 @@
 						{ "type": "null" }
 					]
 				},
+				"useVueDefineMacrosOrder": {
+					"description": "Enforce specific order of Vue compiler macros.",
+					"anyOf": [
+						{ "$ref": "#/definitions/UseVueDefineMacrosOrderConfiguration" },
+						{ "type": "null" }
+					]
+				},
 				"useVueMultiWordComponentNames": {
 					"description": "Enforce multi-word component names in Vue components.",
 					"anyOf": [
@@ -12013,6 +12020,25 @@
 			},
 			"additionalProperties": false
 		},
+		"RuleWithUseVueDefineMacrosOrderOptions": {
+			"type": "object",
+			"required": ["level"],
+			"properties": {
+				"fix": {
+					"description": "The kind of the code actions emitted by the rule",
+					"anyOf": [{ "$ref": "#/definitions/FixKind" }, { "type": "null" }]
+				},
+				"level": {
+					"description": "The severity of the emitted diagnostics by the rule",
+					"allOf": [{ "$ref": "#/definitions/RulePlainConfiguration" }]
+				},
+				"options": {
+					"description": "Rule's options",
+					"allOf": [{ "$ref": "#/definitions/UseVueDefineMacrosOrderOptions" }]
+				}
+			},
+			"additionalProperties": false
+		},
 		"RuleWithUseVueMultiWordComponentNamesOptions": {
 			"type": "object",
 			"required": ["level"],
@@ -14950,6 +14976,24 @@
 			"type": "object",
 			"additionalProperties": false
 		},
+		"UseVueDefineMacrosOrderConfiguration": {
+			"anyOf": [
+				{ "$ref": "#/definitions/RulePlainConfiguration" },
+				{ "$ref": "#/definitions/RuleWithUseVueDefineMacrosOrderOptions" }
+			]
+		},
+		"UseVueDefineMacrosOrderOptions": {
+			"type": "object",
+			"properties": {
+				"order": {
+					"description": "The order of the Vue define macros.",
+					"default": [],
+					"type": "array",
+					"items": { "type": "string" }
+				}
+			},
+			"additionalProperties": false
+		},
 		"UseVueMultiWordComponentNamesConfiguration": {
 			"anyOf": [
 				{ "$ref": "#/definitions/RulePlainConfiguration" },
