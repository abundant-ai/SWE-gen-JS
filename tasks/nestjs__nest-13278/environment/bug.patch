diff --git a/.circleci/install-wrk.sh b/.circleci/install-wrk.sh
index 31f910edd..e78e13622 100755
--- a/.circleci/install-wrk.sh
+++ b/.circleci/install-wrk.sh
@@ -6,8 +6,8 @@ cd "$(dirname "$0")"
 
 cd /tmp/
 sudo apt-get install build-essential libssl-dev git -y
-git clone https://github.com/wg/wrk.git wrk
+git clone --depth=1 https://github.com/wg/wrk.git wrk
 cd wrk
 sudo make
 # move the executable to somewhere in your PATH, ex:
-sudo cp wrk /usr/local/bin
\ No newline at end of file
+sudo cp wrk /usr/local/bin
diff --git a/Readme.md b/Readme.md
index 2d4fc75db..4cac0d5ea 100644
--- a/Readme.md
+++ b/Readme.md
@@ -94,7 +94,7 @@ Nest is an MIT-licensed open source project. It can grow thanks to the sponsors
 <td><a href="https://www.mercedes-benz.com/" target="_blank"><img src="https://nestjs.com/img/logos/mercedes-logo.png" width="100" valign="middle" /></a></td>
 <td><a href="https://www.dinii.jp/" target="_blank"><img src="https://nestjs.com/img/logos/dinii-logo.png" width="65" valign="middle" /></a></td>
 <td><a href="https://bloodycase.com/?promocode=NEST" target="_blank"><img src="https://nestjs.com/img/logos/bloodycase-logo.png" width="65" valign="middle" /></a></td>
-<td><a href="https://handsontable.com/docs/react-data-grid/?utm_source=NestJS_GH&utm_medium=sponsorship&utm_campaign=library_sponsorship_2024" target="_blank"><img src="https://nestjs.com/img/logos/handsontable-logo.svg" width="150" valign="middle" /></a></td>
+<td><a href="https://handsontable.com/docs/react-data-grid/?utm_source=NestJS_GH&utm_medium=sponsorship&utm_campaign=library_sponsorship_2024" target="_blank"><img src="https://nestjs.com/img/logos/handsontable-dark-logo.svg#2" width="150" valign="middle" /></a></td>
 <td align="center" valign="middle"><a href="https://www.itflashcards.com/" target="_blank"><img src="https://nestjs.com/img/logos/it_flashcards-logo.png" width="170" valign="middle" /></a></td>
 <td align="center" valign="middle"><a href="https://arcjet.com/?ref=nestjs" target="_blank"><img src="https://nestjs.com/img/logos/arcjet-logo.svg" width="170" valign="middle" /></a></td>
 </tr>
diff --git a/integration/hooks/e2e/on-module-destroy.spec.ts b/integration/hooks/e2e/on-module-destroy.spec.ts
index d34c15f01..52468cebe 100644
--- a/integration/hooks/e2e/on-module-destroy.spec.ts
+++ b/integration/hooks/e2e/on-module-destroy.spec.ts
@@ -43,10 +43,7 @@ describe('OnModuleDestroy', () => {
   it('should sort modules by distance (topological sort) - DESC order', async () => {
     @Injectable()
     class BB implements OnModuleDestroy {
-      public field: string;
-      async onModuleDestroy() {
-        this.field = 'b-field';
-      }
+      onModuleDestroy = Sinon.spy();
     }
 
     @Module({
@@ -57,13 +54,10 @@ describe('OnModuleDestroy', () => {
 
     @Injectable()
     class AA implements OnModuleDestroy {
-      public field: string;
       constructor(private bb: BB) {}
-
-      async onModuleDestroy() {
-        this.field = this.bb.field + '_a-field';
-      }
+      onModuleDestroy = Sinon.spy();
     }
+
     @Module({
       imports: [B],
       providers: [AA],
@@ -78,7 +72,8 @@ describe('OnModuleDestroy', () => {
     await app.init();
     await app.close();
 
-    const instance = module.get(AA);
-    expect(instance.field).to.equal('b-field_a-field');
+    const aa = module.get(AA);
+    const bb = module.get(BB);
+    Sinon.assert.callOrder(aa.onModuleDestroy, bb.onModuleDestroy);
   });
 });
diff --git a/integration/hooks/e2e/on-module-init.spec.ts b/integration/hooks/e2e/on-module-init.spec.ts
index 462e26919..d35a22d69 100644
--- a/integration/hooks/e2e/on-module-init.spec.ts
+++ b/integration/hooks/e2e/on-module-init.spec.ts
@@ -39,11 +39,39 @@ describe('OnModuleInit', () => {
   });
 
   it('should sort modules by distance (topological sort) - DESC order', async () => {
+    @Injectable()
+    class CC implements OnModuleInit {
+      public field: string;
+
+      async onModuleInit() {
+        this.field = 'c-field';
+      }
+    }
+
+    @Module({})
+    class C {
+      static forRoot() {
+        return {
+          module: C,
+          global: true,
+          providers: [
+            {
+              provide: CC,
+              useValue: new CC(),
+            },
+          ],
+          exports: [CC],
+        };
+      }
+    }
+
     @Injectable()
     class BB implements OnModuleInit {
       public field: string;
+      constructor(private cc: CC) {}
+
       async onModuleInit() {
-        this.field = 'b-field';
+        this.field = this.cc.field + '_b-field';
       }
     }
 
@@ -68,14 +96,19 @@ describe('OnModuleInit', () => {
     })
     class A {}
 
+    @Module({
+      imports: [A, C.forRoot()],
+    })
+    class AppModule {}
+
     const module = await Test.createTestingModule({
-      imports: [A],
+      imports: [AppModule],
     }).compile();
 
     const app = module.createNestApplication();
     await app.init();
 
     const instance = module.get(AA);
-    expect(instance.field).to.equal('b-field_a-field');
+    expect(instance.field).to.equal('c-field_b-field_a-field');
   });
 });
diff --git a/integration/microservices/e2e/sum-rpc-async.spec.ts b/integration/microservices/e2e/sum-rpc-async.spec.ts
new file mode 100644
index 000000000..45ed1e5cc
--- /dev/null
+++ b/integration/microservices/e2e/sum-rpc-async.spec.ts
@@ -0,0 +1,98 @@
+import {
+  Controller,
+  INestMicroservice,
+  Injectable,
+  Module,
+} from '@nestjs/common';
+import {
+  AsyncOptions,
+  ClientTCP,
+  ClientsModule,
+  MessagePattern,
+  MicroserviceOptions,
+  Payload,
+  TcpClientOptions,
+  Transport,
+} from '@nestjs/microservices';
+import { expect } from 'chai';
+import { NestFactory } from '@nestjs/core';
+
+let port: number;
+
+do {
+  port = Math.round(Math.random() * 10000);
+} while (port < 1000);
+
+@Injectable()
+class RpcOptionsProvider {
+  getOptions(): TcpClientOptions {
+    return {
+      transport: Transport.TCP,
+      options: {
+        port,
+        host: '0.0.0.0',
+      },
+    };
+  }
+}
+
+@Controller()
+class RpcController {
+  @MessagePattern({ cmd: 'sum' })
+  sumPayload(@Payload() payload: number[]) {
+    return payload.reduce((a, b) => a + b, 0);
+  }
+}
+
+@Module({
+  imports: [
+    ClientsModule.register([
+      {
+        name: 'RPC_CLIENT',
+        transport: Transport.TCP,
+        options: {
+          port,
+          host: '0.0.0.0',
+        },
+      },
+    ]),
+  ],
+  controllers: [RpcController],
+  providers: [RpcOptionsProvider],
+})
+class RpcModule {}
+
+describe('RPC Async transport', () => {
+  let app: INestMicroservice;
+  let client: ClientTCP;
+
+  beforeEach(async () => {
+    app = await NestFactory.createMicroservice<
+      AsyncOptions<MicroserviceOptions>
+    >(RpcModule, {
+      logger: false,
+      inject: [RpcOptionsProvider],
+      useFactory: (optionsProvider: RpcOptionsProvider) =>
+        optionsProvider.getOptions(),
+    });
+
+    await app.listen();
+    client = app.get('RPC_CLIENT', { strict: false });
+  });
+
+  it(`/POST`, done => {
+    let retData = 0;
+    client.send({ cmd: 'sum' }, [1, 2, 3, 4, 5]).subscribe({
+      next: val => (retData += val),
+      error: done,
+      complete: () => {
+        expect(retData).to.eq(15);
+        done();
+      },
+    });
+  });
+
+  afterEach(async () => {
+    await app.close();
+  });
+});
diff --git a/integration/websockets/e2e/ws-gateway.spec.ts b/integration/websockets/e2e/ws-gateway.spec.ts
index e76165059..94f56d7e9 100644
--- a/integration/websockets/e2e/ws-gateway.spec.ts
+++ b/integration/websockets/e2e/ws-gateway.spec.ts
@@ -218,6 +218,61 @@ describe('WebSocketGateway (WsAdapter)', () => {
     );
   });
 
+  it('should set messageParser by using setMessageParser method', async () => {
+    const testingModule = await Test.createTestingModule({
+      providers: [ApplicationGateway],
+    }).compile();
+    app = testingModule.createNestApplication();
+
+    const wsAdapter = new WsAdapter(app);
+    wsAdapter.setMessageParser(data => {
+      const [event, payload] = JSON.parse(data.toString());
+      return { event, data: payload };
+    });
+    app.useWebSocketAdapter(wsAdapter);
+    await app.listen(3000);
+
+    ws = new WebSocket('ws://localhost:8080');
+    await new Promise(resolve => ws.on('open', resolve));
+
+    ws.send(JSON.stringify(['push', { test: 'test' }]));
+    await new Promise<void>(resolve =>
+      ws.on('message', data => {
+        expect(JSON.parse(data).data.test).to.be.eql('test');
+        ws.close();
+        resolve();
+      }),
+    );
+  });
+
+  it('should set messageParser by using constructor options', async () => {
+    const testingModule = await Test.createTestingModule({
+      providers: [ApplicationGateway],
+    }).compile();
+    app = testingModule.createNestApplication();
+
+    const wsAdapter = new WsAdapter(app, {
+      messageParser: data => {
+        const [event, payload] = JSON.parse(data.toString());
+        return { event, data: payload };
+      },
+    });
+    app.useWebSocketAdapter(wsAdapter);
+    await app.listen(3000);
+
+    ws = new WebSocket('ws://localhost:8080');
+    await new Promise(resolve => ws.on('open', resolve));
+
+    ws.send(JSON.stringify(['push', { test: 'test' }]));
+    await new Promise<void>(resolve =>
+      ws.on('message', data => {
+        expect(JSON.parse(data).data.test).to.be.eql('test');
+        ws.close();
+        resolve();
+      }),
+    );
+  });
+
   afterEach(async function () {
     await app.close();
   });
diff --git a/lerna.json b/lerna.json
index 08b7f09fb..8684e23cd 100644
--- a/lerna.json
+++ b/lerna.json
@@ -3,5 +3,5 @@
   "packages": [
     "packages/*"
   ],
-  "version": "10.4.6"
+  "version": "10.4.7"
 }
diff --git a/packages/common/decorators/core/inject.decorator.ts b/packages/common/decorators/core/inject.decorator.ts
index d06593dbe..c632f423f 100644
--- a/packages/common/decorators/core/inject.decorator.ts
+++ b/packages/common/decorators/core/inject.decorator.ts
@@ -3,6 +3,7 @@ import {
   PROPERTY_DEPS_METADATA,
   SELF_DECLARED_DEPS_METADATA,
 } from '../../constants';
+import { ForwardReference, InjectionToken } from '../../interfaces';
 import { isUndefined } from '../../utils/shared.utils';
 
 /**
@@ -34,8 +35,8 @@ import { isUndefined } from '../../utils/shared.utils';
  *
  * @publicApi
  */
-export function Inject<T = any>(
-  token?: T,
+export function Inject(
+  token?: InjectionToken | ForwardReference,
 ): PropertyDecorator & ParameterDecorator {
   const injectCallHasArguments = arguments.length > 0;
 
diff --git a/packages/common/decorators/http/create-route-param-metadata.decorator.ts b/packages/common/decorators/http/create-route-param-metadata.decorator.ts
index a2cc6c021..245998d74 100644
--- a/packages/common/decorators/http/create-route-param-metadata.decorator.ts
+++ b/packages/common/decorators/http/create-route-param-metadata.decorator.ts
@@ -16,12 +16,8 @@ export type ParamDecoratorEnhancer = ParameterDecorator;
  *
  * @publicApi
  */
-export function createParamDecorator<
-  FactoryData = any,
-  FactoryInput = any,
-  FactoryOutput = any,
->(
-  factory: CustomParamFactory<FactoryData, FactoryInput, FactoryOutput>,
+export function createParamDecorator<FactoryData = any, FactoryOutput = any>(
+  factory: CustomParamFactory<FactoryData, FactoryOutput>,
   enhancers: ParamDecoratorEnhancer[] = [],
 ): (
   ...dataOrPipes: (Type<PipeTransform> | PipeTransform | FactoryData)[]
diff --git a/packages/common/decorators/http/request-mapping.decorator.ts b/packages/common/decorators/http/request-mapping.decorator.ts
index e707883cf..2b3506efc 100644
--- a/packages/common/decorators/http/request-mapping.decorator.ts
+++ b/packages/common/decorators/http/request-mapping.decorator.ts
@@ -118,66 +118,3 @@ export const All = createMappingDecorator(RequestMethod.ALL);
  * @publicApi
  */
 export const Search = createMappingDecorator(RequestMethod.SEARCH);
-
-/**
- * Route handler (method) Decorator. Routes Webdav PROPFIND requests to the specified path.
- *
- * @see [Routing](https://docs.nestjs.com/controllers#routing)
- *
- * @publicApi
- */
-export const Propfind = createMappingDecorator(RequestMethod.PROPFIND);
-
-/**
- * Route handler (method) Decorator. Routes Webdav PROPPATCH requests to the specified path.
- *
- * @see [Routing](https://docs.nestjs.com/controllers#routing)
- *
- * @publicApi
- */
-export const Proppatch = createMappingDecorator(RequestMethod.PROPPATCH);
-
-/**
- * Route handler (method) Decorator. Routes Webdav MKCOL requests to the specified path.
- *
- * @see [Routing](https://docs.nestjs.com/controllers#routing)
- *
- * @publicApi
- */
-export const Mkcol = createMappingDecorator(RequestMethod.MKCOL);
-
-/**
- * Route handler (method) Decorator. Routes Webdav COPY requests to the specified path.
- *
- * @see [Routing](https://docs.nestjs.com/controllers#routing)
- *
- * @publicApi
- */
-export const Copy = createMappingDecorator(RequestMethod.COPY);
-
-/**
- * Route handler (method) Decorator. Routes Webdav MOVE requests to the specified path.
- *
- * @see [Routing](https://docs.nestjs.com/controllers#routing)
- *
- * @publicApi
- */
-export const Move = createMappingDecorator(RequestMethod.MOVE);
-
-/**
- * Route handler (method) Decorator. Routes Webdav LOCK requests to the specified path.
- *
- * @see [Routing](https://docs.nestjs.com/controllers#routing)
- *
- * @publicApi
- */
-export const Lock = createMappingDecorator(RequestMethod.LOCK);
-
-/**
- * Route handler (method) Decorator. Routes Webdav UNLOCK requests to the specified path.
- *
- * @see [Routing](https://docs.nestjs.com/controllers#routing)
- *
- * @publicApi
- */
-export const Unlock = createMappingDecorator(RequestMethod.UNLOCK);
diff --git a/packages/common/enums/http-status.enum.ts b/packages/common/enums/http-status.enum.ts
index 8d6da4526..326001344 100644
--- a/packages/common/enums/http-status.enum.ts
+++ b/packages/common/enums/http-status.enum.ts
@@ -13,9 +13,6 @@ export enum HttpStatus {
   NO_CONTENT = 204,
   RESET_CONTENT = 205,
   PARTIAL_CONTENT = 206,
-  MULTI_STATUS = 207,
-  ALREADY_REPORTED = 208,
-  CONTENT_DIFFERENT = 210,
   AMBIGUOUS = 300,
   MOVED_PERMANENTLY = 301,
   FOUND = 302,
@@ -44,17 +41,13 @@ export enum HttpStatus {
   I_AM_A_TEAPOT = 418,
   MISDIRECTED = 421,
   UNPROCESSABLE_ENTITY = 422,
-  LOCKED = 423,
   FAILED_DEPENDENCY = 424,
   PRECONDITION_REQUIRED = 428,
   TOO_MANY_REQUESTS = 429,
-  UNRECOVERABLE_ERROR = 456,
   INTERNAL_SERVER_ERROR = 500,
   NOT_IMPLEMENTED = 501,
   BAD_GATEWAY = 502,
   SERVICE_UNAVAILABLE = 503,
   GATEWAY_TIMEOUT = 504,
   HTTP_VERSION_NOT_SUPPORTED = 505,
-  INSUFFICIENT_STORAGE = 507,
-  LOOP_DETECTED = 508,
 }
diff --git a/packages/common/enums/request-method.enum.ts b/packages/common/enums/request-method.enum.ts
index 9bd12a98c..e28455633 100644
--- a/packages/common/enums/request-method.enum.ts
+++ b/packages/common/enums/request-method.enum.ts
@@ -8,11 +8,4 @@ export enum RequestMethod {
   OPTIONS,
   HEAD,
   SEARCH,
-  PROPFIND,
-  PROPPATCH,
-  MKCOL,
-  COPY,
-  MOVE,
-  LOCK,
-  UNLOCK,
 }
diff --git a/packages/common/exceptions/http.exception.ts b/packages/common/exceptions/http.exception.ts
index 111a1f72a..143df233e 100644
--- a/packages/common/exceptions/http.exception.ts
+++ b/packages/common/exceptions/http.exception.ts
@@ -2,7 +2,7 @@ import {
   HttpExceptionBody,
   HttpExceptionBodyMessage,
 } from '../interfaces/http/http-exception-body.interface';
-import { isObject, isString } from '../utils/shared.utils';
+import { isNumber, isObject, isString } from '../utils/shared.utils';
 
 export interface HttpExceptionOptions {
   /** original cause of the error */
@@ -115,17 +115,14 @@ export class HttpException extends Error {
     message: HttpExceptionBodyMessage,
     statusCode: number,
   ): HttpExceptionBody;
-
   public static createBody(
     message: HttpExceptionBodyMessage,
     error: string,
     statusCode: number,
   ): HttpExceptionBody;
-
   public static createBody<Body extends Record<string, unknown>>(
     custom: Body,
   ): Body;
-
   public static createBody<Body extends Record<string, unknown>>(
     arg0: null | HttpExceptionBodyMessage | Body,
     arg1?: HttpExceptionBodyMessage | string,
@@ -138,7 +135,7 @@ export class HttpException extends Error {
       };
     }
 
-    if (isString(arg0) || Array.isArray(arg0)) {
+    if (isString(arg0) || Array.isArray(arg0) || isNumber(arg0)) {
       return {
         message: arg0,
         error: arg1 as string,
diff --git a/packages/common/file-stream/streamable-file.ts b/packages/common/file-stream/streamable-file.ts
index c41dbb388..6323ca065 100644
--- a/packages/common/file-stream/streamable-file.ts
+++ b/packages/common/file-stream/streamable-file.ts
@@ -1,9 +1,9 @@
 import { Readable } from 'stream';
 import { types } from 'util';
 import { HttpStatus } from '../enums';
+import { Logger } from '../services';
 import { isFunction } from '../utils/shared.utils';
 import { StreamableFileOptions, StreamableHandlerResponse } from './interfaces';
-import { Logger } from '../services';
 
 /**
  * @see [Streaming files](https://docs.nestjs.com/techniques/streaming-files)
@@ -31,7 +31,7 @@ export class StreamableFile {
   };
 
   protected logError: (err: Error) => void = (err: Error) => {
-    this.logger.error(err.message, err.stack);
+    this.logger.error(err);
   };
 
   constructor(buffer: Uint8Array, options?: StreamableFileOptions);
diff --git a/packages/common/interfaces/external/transformer-package.interface.ts b/packages/common/interfaces/external/transformer-package.interface.ts
index cd08a0552..f13c5fa2e 100644
--- a/packages/common/interfaces/external/transformer-package.interface.ts
+++ b/packages/common/interfaces/external/transformer-package.interface.ts
@@ -2,7 +2,7 @@ import { Type } from '../type.interface';
 import { ClassTransformOptions } from './class-transform-options.interface';
 
 export interface TransformerPackage {
-  plainToClass<T>(
+  plainToInstance<T>(
     cls: Type<T>,
     plain: unknown,
     options?: ClassTransformOptions,
diff --git a/packages/common/interfaces/features/custom-route-param-factory.interface.ts b/packages/common/interfaces/features/custom-route-param-factory.interface.ts
index e022b6669..c63b4b857 100644
--- a/packages/common/interfaces/features/custom-route-param-factory.interface.ts
+++ b/packages/common/interfaces/features/custom-route-param-factory.interface.ts
@@ -1,7 +1,9 @@
+import { ExecutionContext } from './execution-context.interface';
+
 /**
  * @publicApi
  */
-export type CustomParamFactory<TData = any, TInput = any, TOutput = any> = (
+export type CustomParamFactory<TData = any, TOutput = any> = (
   data: TData,
-  input: TInput,
+  context: ExecutionContext,
 ) => TOutput;
diff --git a/packages/common/interfaces/http/http-exception-body.interface.ts b/packages/common/interfaces/http/http-exception-body.interface.ts
index e0b923e5e..b9f4732d6 100644
--- a/packages/common/interfaces/http/http-exception-body.interface.ts
+++ b/packages/common/interfaces/http/http-exception-body.interface.ts
@@ -1,4 +1,4 @@
-export type HttpExceptionBodyMessage = string | string[];
+export type HttpExceptionBodyMessage = string | string[] | number;
 
 export interface HttpExceptionBody {
   message: HttpExceptionBodyMessage;
diff --git a/packages/common/interfaces/http/http-server.interface.ts b/packages/common/interfaces/http/http-server.interface.ts
index 91494021e..28e8278b0 100644
--- a/packages/common/interfaces/http/http-server.interface.ts
+++ b/packages/common/interfaces/http/http-server.interface.ts
@@ -47,20 +47,6 @@ export interface HttpServer<
   put(path: string, handler: RequestHandler<TRequest, TResponse>): any;
   patch(handler: RequestHandler<TRequest, TResponse>): any;
   patch(path: string, handler: RequestHandler<TRequest, TResponse>): any;
-  propfind?(handler: RequestHandler<TRequest, TResponse>): any;
-  propfind?(path: string, handler: RequestHandler<TRequest, TResponse>): any;
-  proppatch?(handler: RequestHandler<TRequest, TResponse>): any;
-  proppatch?(path: string, handler: RequestHandler<TRequest, TResponse>): any;
-  mkcol?(handler: RequestHandler<TRequest, TResponse>): any;
-  mkcol?(path: string, handler: RequestHandler<TRequest, TResponse>): any;
-  copy?(handler: RequestHandler<TRequest, TResponse>): any;
-  copy?(path: string, handler: RequestHandler<TRequest, TResponse>): any;
-  move?(handler: RequestHandler<TRequest, TResponse>): any;
-  move?(path: string, handler: RequestHandler<TRequest, TResponse>): any;
-  lock?(handler: RequestHandler<TRequest, TResponse>): any;
-  lock?(path: string, handler: RequestHandler<TRequest, TResponse>): any;
-  unlock?(handler: RequestHandler<TRequest, TResponse>): any;
-  unlock?(path: string, handler: RequestHandler<TRequest, TResponse>): any;
   all(path: string, handler: RequestHandler<TRequest, TResponse>): any;
   all(handler: RequestHandler<TRequest, TResponse>): any;
   options(handler: RequestHandler<TRequest, TResponse>): any;
diff --git a/packages/common/interfaces/modules/module-metadata.interface.ts b/packages/common/interfaces/modules/module-metadata.interface.ts
index 9d6699cba..2baa7d84f 100644
--- a/packages/common/interfaces/modules/module-metadata.interface.ts
+++ b/packages/common/interfaces/modules/module-metadata.interface.ts
@@ -35,7 +35,6 @@ export interface ModuleMetadata {
    */
   exports?: Array<
     | DynamicModule
-    | Promise<DynamicModule>
     | string
     | symbol
     | Provider
diff --git a/packages/common/interfaces/nest-application-context-options.interface.ts b/packages/common/interfaces/nest-application-context-options.interface.ts
index d5204b55d..db661d953 100644
--- a/packages/common/interfaces/nest-application-context-options.interface.ts
+++ b/packages/common/interfaces/nest-application-context-options.interface.ts
@@ -44,4 +44,13 @@ export class NestApplicationContextOptions {
    * @default false
    */
   snapshot?: boolean;
+
+  /**
+   * Determines what algorithm use to generate module ids.
+   * When set to `deep-hash`, the module id is generated based on the serialized module definition.
+   * When set to `reference`, each module obtains a unique id based on its reference.
+   *
+   * @default 'reference'
+   */
+  moduleIdGeneratorAlgorithm?: 'deep-hash' | 'reference';
 }
diff --git a/packages/common/interfaces/nest-application-context.interface.ts b/packages/common/interfaces/nest-application-context.interface.ts
index 554fa1d1b..3a8fe4396 100644
--- a/packages/common/interfaces/nest-application-context.interface.ts
+++ b/packages/common/interfaces/nest-application-context.interface.ts
@@ -1,8 +1,11 @@
 import { ShutdownSignal } from '../enums/shutdown-signal.enum';
 import { LoggerService, LogLevel } from '../services/logger.service';
 import { DynamicModule } from './modules';
+import { NestApplicationContextOptions } from './nest-application-context-options.interface';
 import { Type } from './type.interface';
 
+export type SelectOptions = Pick<NestApplicationContextOptions, 'abortOnError'>;
+
 export interface GetOrResolveOptions {
   /**
    * If enabled, lookup will only be performed in the host module.
@@ -27,7 +30,10 @@ export interface INestApplicationContext {
    * Allows navigating through the modules tree, for example, to pull out a specific instance from the selected module.
    * @returns {INestApplicationContext}
    */
-  select<T>(module: Type<T> | DynamicModule): INestApplicationContext;
+  select<T>(
+    module: Type<T> | DynamicModule,
+    options?: SelectOptions,
+  ): INestApplicationContext;
 
   /**
    * Retrieves an instance of either injectable or controller, otherwise, throws exception.
diff --git a/packages/common/package.json b/packages/common/package.json
index 256526534..490aca2f2 100644
--- a/packages/common/package.json
+++ b/packages/common/package.json
@@ -1,6 +1,6 @@
 {
   "name": "@nestjs/common",
-  "version": "10.4.6",
+  "version": "10.4.7",
   "description": "Nest - modern, fast, powerful node.js web framework (@common)",
   "author": "Kamil Mysliwiec",
   "homepage": "https://nestjs.com",
diff --git a/packages/common/pipes/index.ts b/packages/common/pipes/index.ts
index ebbc55f27..f416b9467 100644
--- a/packages/common/pipes/index.ts
+++ b/packages/common/pipes/index.ts
@@ -1,9 +1,10 @@
 export * from './default-value.pipe';
+export * from './file';
 export * from './parse-array.pipe';
 export * from './parse-bool.pipe';
-export * from './parse-int.pipe';
-export * from './parse-float.pipe';
+export * from './parse-date.pipe';
 export * from './parse-enum.pipe';
+export * from './parse-float.pipe';
+export * from './parse-int.pipe';
 export * from './parse-uuid.pipe';
 export * from './validation.pipe';
-export * from './file';
diff --git a/packages/common/pipes/parse-array.pipe.ts b/packages/common/pipes/parse-array.pipe.ts
index a46acc8fd..3887dfe23 100644
--- a/packages/common/pipes/parse-array.pipe.ts
+++ b/packages/common/pipes/parse-array.pipe.ts
@@ -7,7 +7,7 @@ import {
   PipeTransform,
 } from '../interfaces/features/pipe-transform.interface';
 import { HttpErrorByCode } from '../utils/http-error-by-code.util';
-import { isNil, isUndefined, isString } from '../utils/shared.utils';
+import { isNil, isString, isUndefined } from '../utils/shared.utils';
 import { ValidationPipe, ValidationPipeOptions } from './validation.pipe';
 
 const VALIDATION_ERROR_MESSAGE = 'Validation failed (parsable array expected)';
@@ -21,9 +21,26 @@ export interface ParseArrayOptions
     ValidationPipeOptions,
     'transform' | 'validateCustomDecorators' | 'exceptionFactory'
   > {
+  /**
+   * Type for items to be converted into
+   */
   items?: Type<unknown>;
+  /**
+   * Items separator to split string by
+   * @default ','
+   */
   separator?: string;
+  /**
+   * If true, the pipe will return null or undefined if the value is not provided
+   * @default false
+   */
   optional?: boolean;
+  /**
+   * A factory function that returns an exception object to be thrown
+   * if validation fails.
+   * @param error Error message or object
+   * @returns The exception object
+   */
   exceptionFactory?: (error: any) => any;
 }
 
diff --git a/packages/common/pipes/parse-bool.pipe.ts b/packages/common/pipes/parse-bool.pipe.ts
index ed1fbe553..16296f058 100644
--- a/packages/common/pipes/parse-bool.pipe.ts
+++ b/packages/common/pipes/parse-bool.pipe.ts
@@ -15,8 +15,21 @@ import { isNil } from '../utils/shared.utils';
  * @publicApi
  */
 export interface ParseBoolPipeOptions {
+  /**
+   * The HTTP status code to be used in the response when the validation fails.
+   */
   errorHttpStatusCode?: ErrorHttpStatusCode;
+  /**
+   * A factory function that returns an exception object to be thrown
+   * if validation fails.
+   * @param error Error message
+   * @returns The exception object
+   */
   exceptionFactory?: (error: string) => any;
+  /**
+   * If true, the pipe will return null or undefined if the value is not provided
+   * @default false
+   */
   optional?: boolean;
 }
 
diff --git a/packages/common/pipes/parse-date.pipe.ts b/packages/common/pipes/parse-date.pipe.ts
new file mode 100644
index 000000000..4980882a4
--- /dev/null
+++ b/packages/common/pipes/parse-date.pipe.ts
@@ -0,0 +1,74 @@
+import { Injectable } from '../decorators/core/injectable.decorator';
+import { HttpStatus } from '../enums/http-status.enum';
+import { PipeTransform } from '../interfaces/features/pipe-transform.interface';
+import {
+  ErrorHttpStatusCode,
+  HttpErrorByCode,
+} from '../utils/http-error-by-code.util';
+import { isNil } from '../utils/shared.utils';
+
+export interface ParseDatePipeOptions {
+  /**
+   * If true, the pipe will return null or undefined if the value is not provided
+   * @default false
+   */
+  optional?: boolean;
+  /**
+   * Default value for the date
+   */
+  default?: () => Date;
+  /**
+   * The HTTP status code to be used in the response when the validation fails.
+   */
+  errorHttpStatusCode?: ErrorHttpStatusCode;
+  /**
+   * A factory function that returns an exception object to be thrown
+   * if validation fails.
+   * @param error Error message
+   * @returns The exception object
+   */
+  exceptionFactory?: (error: string) => any;
+}
+
+@Injectable()
+export class ParseDatePipe
+  implements PipeTransform<string | number | undefined | null>
+{
+  protected exceptionFactory: (error: string) => any;
+
+  constructor(private readonly options: ParseDatePipeOptions = {}) {
+    const { exceptionFactory, errorHttpStatusCode = HttpStatus.BAD_REQUEST } =
+      options;
+
+    this.exceptionFactory =
+      exceptionFactory ||
+      (error => new HttpErrorByCode[errorHttpStatusCode](error));
+  }
+
+  /**
+   * Method that accesses and performs optional transformation on argument for
+   * in-flight requests.
+   *
+   * @param value currently processed route argument
+   * @param metadata contains metadata about the currently processed route argument
+   */
+  transform(value: string | number | undefined | null): Date {
+    if (this.options.optional && isNil(value)) {
+      return this.options.default
+        ? this.options.default()
+        : (value as undefined | null);
+    }
+
+    if (!value) {
+      throw this.exceptionFactory('Validation failed (no Date provided)');
+    }
+
+    const transformedValue = new Date(value);
+
+    if (isNaN(transformedValue.getTime())) {
+      throw this.exceptionFactory('Validation failed (invalid date format)');
+    }
+
+    return transformedValue;
+  }
+}
diff --git a/packages/common/pipes/parse-enum.pipe.ts b/packages/common/pipes/parse-enum.pipe.ts
index 4d98a96ad..0bccd8b29 100644
--- a/packages/common/pipes/parse-enum.pipe.ts
+++ b/packages/common/pipes/parse-enum.pipe.ts
@@ -11,8 +11,21 @@ import { isNil } from '../utils/shared.utils';
  * @publicApi
  */
 export interface ParseEnumPipeOptions {
+  /**
+   * If true, the pipe will return null or undefined if the value is not provided
+   * @default false
+   */
   optional?: boolean;
+  /**
+   * The HTTP status code to be used in the response when the validation fails.
+   */
   errorHttpStatusCode?: ErrorHttpStatusCode;
+  /**
+   * A factory function that returns an exception object to be thrown
+   * if validation fails.
+   * @param error Error message
+   * @returns The exception object
+   */
   exceptionFactory?: (error: string) => any;
 }
 
diff --git a/packages/common/pipes/parse-float.pipe.ts b/packages/common/pipes/parse-float.pipe.ts
index a9b25e4d7..04f5e97e2 100644
--- a/packages/common/pipes/parse-float.pipe.ts
+++ b/packages/common/pipes/parse-float.pipe.ts
@@ -11,8 +11,21 @@ import { isNil } from '../utils/shared.utils';
  * @publicApi
  */
 export interface ParseFloatPipeOptions {
+  /**
+   * The HTTP status code to be used in the response when the validation fails.
+   */
   errorHttpStatusCode?: ErrorHttpStatusCode;
+  /**
+   * A factory function that returns an exception object to be thrown
+   * if validation fails.
+   * @param error Error message
+   * @returns The exception object
+   */
   exceptionFactory?: (error: string) => any;
+  /**
+   * If true, the pipe will return null or undefined if the value is not provided
+   * @default false
+   */
   optional?: boolean;
 }
 
diff --git a/packages/common/pipes/parse-int.pipe.ts b/packages/common/pipes/parse-int.pipe.ts
index a36473efe..d74aa0205 100644
--- a/packages/common/pipes/parse-int.pipe.ts
+++ b/packages/common/pipes/parse-int.pipe.ts
@@ -15,8 +15,21 @@ import { isNil } from '../utils/shared.utils';
  * @publicApi
  */
 export interface ParseIntPipeOptions {
+  /**
+   * The HTTP status code to be used in the response when the validation fails.
+   */
   errorHttpStatusCode?: ErrorHttpStatusCode;
+  /**
+   * A factory function that returns an exception object to be thrown
+   * if validation fails.
+   * @param error Error message
+   * @returns The exception object
+   */
   exceptionFactory?: (error: string) => any;
+  /**
+   * If true, the pipe will return null or undefined if the value is not provided
+   * @default false
+   */
   optional?: boolean;
 }
 
diff --git a/packages/common/pipes/parse-uuid.pipe.ts b/packages/common/pipes/parse-uuid.pipe.ts
index 6b33ac6fc..3c13c6b51 100644
--- a/packages/common/pipes/parse-uuid.pipe.ts
+++ b/packages/common/pipes/parse-uuid.pipe.ts
@@ -15,9 +15,25 @@ import { isNil, isString } from '../utils/shared.utils';
  * @publicApi
  */
 export interface ParseUUIDPipeOptions {
+  /**
+   * UUID version to validate
+   */
   version?: '3' | '4' | '5' | '7';
+  /**
+   * The HTTP status code to be used in the response when the validation fails.
+   */
   errorHttpStatusCode?: ErrorHttpStatusCode;
+  /**
+   * A factory function that returns an exception object to be thrown
+   * if validation fails.
+   * @param error Error message
+   * @returns The exception object
+   */
   exceptionFactory?: (errors: string) => any;
+  /**
+   * If true, the pipe will return null or undefined if the value is not provided
+   * @default false
+   */
   optional?: boolean;
 }
 
diff --git a/packages/common/pipes/validation.pipe.ts b/packages/common/pipes/validation.pipe.ts
index 6ee05a4ad..951f73f43 100644
--- a/packages/common/pipes/validation.pipe.ts
+++ b/packages/common/pipes/validation.pipe.ts
@@ -121,7 +121,7 @@ export class ValidationPipe implements PipeTransform<any> {
     const isNil = value !== originalValue;
     const isPrimitive = this.isPrimitive(value);
     this.stripProtoKeys(value);
-    let entity = classTransformer.plainToClass(
+    let entity = classTransformer.plainToInstance(
       metatype,
       value,
       this.transformOptions,
@@ -203,6 +203,12 @@ export class ValidationPipe implements PipeTransform<any> {
       return value === true || value === 'true';
     }
     if (metatype === Number) {
+      if (isUndefined(value)) {
+        // This is a workaround to deal with optional numeric values since
+        // optional numerics shouldn't be parsed to a valid number when
+        // they were not defined
+        return undefined;
+      }
       return +value;
     }
     return value;
diff --git a/packages/common/serializer/class-serializer.interceptor.ts b/packages/common/serializer/class-serializer.interceptor.ts
index 3773fddc0..795147d95 100644
--- a/packages/common/serializer/class-serializer.interceptor.ts
+++ b/packages/common/serializer/class-serializer.interceptor.ts
@@ -94,7 +94,11 @@ export class ClassSerializerInterceptor implements NestInterceptor {
     if (plainOrClass instanceof options.type) {
       return classTransformer.classToPlain(plainOrClass, options);
     }
-    const instance = classTransformer.plainToClass(options.type, plainOrClass);
+    const instance = classTransformer.plainToInstance(
+      options.type,
+      plainOrClass,
+      options,
+    );
     return classTransformer.classToPlain(instance, options);
   }
 
diff --git a/packages/common/services/console-logger.service.ts b/packages/common/services/console-logger.service.ts
index a6da2a419..79c967f17 100644
--- a/packages/common/services/console-logger.service.ts
+++ b/packages/common/services/console-logger.service.ts
@@ -1,3 +1,4 @@
+import { inspect, InspectOptions } from 'util';
 import { Injectable, Optional } from '../decorators/core';
 import { clc, yellow } from '../utils/cli-colors.util';
 import {
@@ -9,6 +10,8 @@ import {
 import { LoggerService, LogLevel } from './logger.service';
 import { isLogLevelEnabled } from './utils';
 
+const DEFAULT_DEPTH = 5;
+
 export interface ConsoleLoggerOptions {
   /**
    * Enabled log levels.
@@ -16,8 +19,73 @@ export interface ConsoleLoggerOptions {
   logLevels?: LogLevel[];
   /**
    * If enabled, will print timestamp (time difference) between current and previous log message.
+   * Note: This option is not used when `json` is enabled.
    */
   timestamp?: boolean;
+  /**
+   * A prefix to be used for each log message.
+   * Note: This option is not used when `json` is enabled.
+   */
+  prefix?: string;
+  /**
+   * If enabled, will print the log message in JSON format.
+   */
+  json?: boolean;
+  /**
+   * If enabled, will print the log message in color.
+   * Default true if json is disabled, false otherwise
+   */
+  colors?: boolean;
+  /**
+   * The context of the logger.
+   */
+  context?: string;
+  /**
+   * If enabled, will print the log message in a single line, even if it is an object with multiple properties.
+   * If set to a number, the most n inner elements are united on a single line as long as all properties fit into breakLength. Short array elements are also grouped together.
+   * Default true when `json` is enabled, false otherwise.
+   */
+  compact?: boolean | number;
+  /**
+   * Specifies the maximum number of Array, TypedArray, Map, Set, WeakMap, and WeakSet elements to include when formatting.
+   * Set to null or Infinity to show all elements. Set to 0 or negative to show no elements.
+   * Ignored when `json` is enabled, colors are disabled, and `compact` is set to true as it produces a parseable JSON output.
+   * @default 100
+   */
+  maxArrayLength?: number;
+  /**
+   * Specifies the maximum number of characters to include when formatting.
+   * Set to null or Infinity to show all elements. Set to 0 or negative to show no characters.
+   * Ignored when `json` is enabled, colors are disabled, and `compact` is set to true as it produces a parseable JSON output.
+   * @default 10000.
+   */
+  maxStringLength?: number;
+  /**
+   * If enabled, will sort keys while formatting objects.
+   * Can also be a custom sorting function.
+   * Ignored when `json` is enabled, colors are disabled, and `compact` is set to true as it produces a parseable JSON output.
+   * @default false
+   */
+  sorted?: boolean | ((a: string, b: string) => number);
+  /**
+   * Specifies the number of times to recurse while formatting object. T
+   * This is useful for inspecting large objects. To recurse up to the maximum call stack size pass Infinity or null.
+   * Ignored when `json` is enabled, colors are disabled, and `compact` is set to true as it produces a parseable JSON output.
+   * @default 5
+   */
+  depth?: number;
+  /**
+   * If true, object's non-enumerable symbols and properties are included in the formatted result.
+   * WeakMap and WeakSet entries are also included as well as user defined prototype properties
+   * @default false
+   */
+  showHidden?: boolean;
+  /**
+   * The length at which input values are split across multiple lines. Set to Infinity to format the input as a single line (in combination with "compact" set to true).
+   * Default Infinity when "compact" is true, 80 otherwise.
+   * Ignored when `json` is enabled, colors are disabled, and `compact` is set to true as it produces a parseable JSON output.
+   */
+  breakLength?: number;
 }
 
 const DEFAULT_LOG_LEVELS: LogLevel[] = [
@@ -40,22 +108,54 @@ const dateTimeFormatter = new Intl.DateTimeFormat(undefined, {
 
 @Injectable()
 export class ConsoleLogger implements LoggerService {
-  private static lastTimestampAt?: number;
-  private originalContext?: string;
+  /**
+   * The options of the logger.
+   */
+  protected options: ConsoleLoggerOptions;
+  /**
+   * The context of the logger (can be set manually or automatically inferred).
+   */
+  protected context?: string;
+  /**
+   * The original context of the logger (set in the constructor).
+   */
+  protected originalContext?: string;
+  /**
+   * The options used for the "inspect" method.
+   */
+  protected inspectOptions: InspectOptions;
+  /**
+   * The last timestamp at which the log message was printed.
+   */
+  protected static lastTimestampAt?: number;
 
   constructor();
   constructor(context: string);
+  constructor(options: ConsoleLoggerOptions);
   constructor(context: string, options: ConsoleLoggerOptions);
   constructor(
     @Optional()
-    protected context?: string,
+    contextOrOptions?: string | ConsoleLoggerOptions,
     @Optional()
-    protected options: ConsoleLoggerOptions = {},
+    options?: ConsoleLoggerOptions,
   ) {
-    if (!options.logLevels) {
-      options.logLevels = DEFAULT_LOG_LEVELS;
-    }
+    // eslint-disable-next-line prefer-const
+    let [context, opts] = isString(contextOrOptions)
+      ? [contextOrOptions, options]
+      : !!options
+        ? [undefined, options]
+        : [contextOrOptions?.context, contextOrOptions];
+
+    opts = opts ?? {};
+    opts.logLevels ??= DEFAULT_LOG_LEVELS;
+    opts.colors ??= opts.colors ?? (opts.json ? false : true);
+    opts.prefix ??= 'Nest';
+
+    this.options = opts;
+    this.inspectOptions = this.getInspectOptions();
+
     if (context) {
+      this.context = context;
       this.originalContext = context;
     }
   }
@@ -91,7 +191,7 @@ export class ConsoleLogger implements LoggerService {
     const { messages, context, stack } =
       this.getContextAndStackAndMessagesToPrint([message, ...optionalParams]);
 
-    this.printMessages(messages, context, 'error', 'stderr');
+    this.printMessages(messages, context, 'error', 'stderr', stack);
     this.printStackTrace(stack);
   }
 
@@ -203,8 +303,18 @@ export class ConsoleLogger implements LoggerService {
     context = '',
     logLevel: LogLevel = 'log',
     writeStreamType?: 'stdout' | 'stderr',
+    errorStack?: unknown,
   ) {
     messages.forEach(message => {
+      if (this.options.json) {
+        this.printAsJson(message, {
+          context,
+          logLevel,
+          writeStreamType,
+          errorStack,
+        });
+        return;
+      }
       const pidMessage = this.formatPid(process.pid);
       const contextMessage = this.formatContext(context);
       const timestampDiff = this.updateAndGetTimestampDiff();
@@ -222,12 +332,57 @@ export class ConsoleLogger implements LoggerService {
     });
   }
 
+  protected printAsJson(
+    message: unknown,
+    options: {
+      context: string;
+      logLevel: LogLevel;
+      writeStreamType?: 'stdout' | 'stderr';
+      errorStack?: unknown;
+    },
+  ) {
+    type JsonLogObject = {
+      level: LogLevel;
+      pid: number;
+      timestamp: number;
+      message: unknown;
+      context?: string;
+      stack?: unknown;
+    };
+
+    const logObject: JsonLogObject = {
+      level: options.logLevel,
+      pid: process.pid,
+      timestamp: Date.now(),
+      message,
+    };
+
+    if (options.context) {
+      logObject.context = options.context;
+    }
+
+    if (options.errorStack) {
+      logObject.stack = options.errorStack;
+    }
+
+    const formattedMessage =
+      !this.options.colors && this.inspectOptions.compact === true
+        ? JSON.stringify(logObject, this.stringifyReplacer)
+        : inspect(logObject, this.inspectOptions);
+    process[options.writeStreamType ?? 'stdout'].write(`${formattedMessage}\n`);
+  }
+
   protected formatPid(pid: number) {
-    return `[Nest] ${pid}  - `;
+    return `[${this.options.prefix}] ${pid}  - `;
   }
 
   protected formatContext(context: string): string {
-    return context ? yellow(`[${context}] `) : '';
+    if (!context) {
+      return '';
+    }
+
+    context = `[${context}] `;
+    return this.options.colors ? yellow(context) : context;
   }
 
   protected formatMessage(
@@ -256,23 +411,30 @@ export class ConsoleLogger implements LoggerService {
       return this.stringifyMessage(message(), logLevel);
     }
 
-    return isPlainObject(message) || Array.isArray(message)
-      ? `${this.colorize('Object:', logLevel)}\n${JSON.stringify(
-          message,
-          (key, value) =>
-            typeof value === 'bigint' ? value.toString() : value,
-          2,
-        )}\n`
-      : this.colorize(message as string, logLevel);
+    if (typeof message === 'string') {
+      return this.colorize(message, logLevel);
+    }
+
+    const outputText = inspect(message, this.inspectOptions);
+    if (isPlainObject(message)) {
+      return `Object(${Object.keys(message).length}) ${outputText}`;
+    }
+    if (Array.isArray(message)) {
+      return `Array(${message.length}) ${outputText}`;
+    }
+    return outputText;
   }
 
   protected colorize(message: string, logLevel: LogLevel) {
+    if (!this.options.colors || this.options.json) {
+      return message;
+    }
     const color = this.getColorByLogLevel(logLevel);
     return color(message);
   }
 
   protected printStackTrace(stack: string) {
-    if (!stack) {
+    if (!stack || this.options.json) {
       return;
     }
     process.stderr.write(`${stack}\n`);
@@ -289,7 +451,58 @@ export class ConsoleLogger implements LoggerService {
   }
 
   protected formatTimestampDiff(timestampDiff: number) {
-    return yellow(` +${timestampDiff}ms`);
+    const formattedDiff = ` +${timestampDiff}ms`;
+    return this.options.colors ? yellow(formattedDiff) : formattedDiff;
+  }
+
+  protected getInspectOptions() {
+    let breakLength = this.options.breakLength;
+    if (typeof breakLength === 'undefined') {
+      breakLength = this.options.colors
+        ? this.options.compact
+          ? Infinity
+          : undefined
+        : this.options.compact === false
+          ? undefined
+          : Infinity; // default breakLength to Infinity if inline is not set and colors is false
+    }
+
+    const inspectOptions: InspectOptions = {
+      depth: this.options.depth ?? DEFAULT_DEPTH,
+      sorted: this.options.sorted,
+      showHidden: this.options.showHidden,
+      compact: this.options.compact ?? (this.options.json ? true : false),
+      colors: this.options.colors,
+      breakLength,
+    };
+
+    if (this.options.maxArrayLength) {
+      inspectOptions.maxArrayLength = this.options.maxArrayLength;
+    }
+    if (this.options.maxStringLength) {
+      inspectOptions.maxStringLength = this.options.maxStringLength;
+    }
+
+    return inspectOptions;
+  }
+
+  protected stringifyReplacer(key: string, value: unknown) {
+    // Mimic util.inspect behavior for JSON logger with compact on and colors off
+    if (typeof value === 'bigint') {
+      return value.toString();
+    }
+    if (typeof value === 'symbol') {
+      return value.toString();
+    }
+
+    if (
+      value instanceof Map ||
+      value instanceof Set ||
+      value instanceof Error
+    ) {
+      return `${inspect(value, this.inspectOptions)}`;
+    }
+    return value;
   }
 
   private getContextAndMessagesToPrint(args: unknown[]) {
diff --git a/packages/common/test/decorators/route-params.decorator.spec.ts b/packages/common/test/decorators/route-params.decorator.spec.ts
index da3a85a9a..3c4eabf5c 100644
--- a/packages/common/test/decorators/route-params.decorator.spec.ts
+++ b/packages/common/test/decorators/route-params.decorator.spec.ts
@@ -1,22 +1,7 @@
 import { expect } from 'chai';
 import { Body, HostParam, Param, Query, Search } from '../../decorators';
 import { RequestMethod } from '../../enums/request-method.enum';
-import {
-  All,
-  Delete,
-  Get,
-  ParseIntPipe,
-  Patch,
-  Post,
-  Put,
-  Propfind,
-  Proppatch,
-  Mkcol,
-  Move,
-  Copy,
-  Lock,
-  Unlock,
-} from '../../index';
+import { All, Delete, Get, ParseIntPipe, Patch, Post, Put } from '../../index';
 import { ROUTE_ARGS_METADATA } from '../../constants';
 import { RouteParamtypes } from '../../enums/route-paramtypes.enum';
 
@@ -430,409 +415,3 @@ describe('Inheritance', () => {
     expect(methodUsingArray).to.be.eql(requestPropsUsingArray.method);
   });
 });
-
-describe('@PropFind', () => {
-  const requestPath = 'test';
-  const requestProps = {
-    path: requestPath,
-    method: RequestMethod.PROPFIND,
-  };
-
-  const requestPathUsingArray = ['foo', 'bar'];
-  const requestPropsUsingArray = {
-    path: requestPathUsingArray,
-    method: RequestMethod.PROPFIND,
-  };
-
-  it('should enhance class with expected request metadata', () => {
-    class Test {
-      @Propfind(requestPath)
-      public static test() {}
-
-      @Propfind(requestPathUsingArray)
-      public static testUsingArray() {}
-    }
-
-    const path = Reflect.getMetadata('path', Test.test);
-    const method = Reflect.getMetadata('method', Test.test);
-    const pathUsingArray = Reflect.getMetadata('path', Test.testUsingArray);
-    const methodUsingArray = Reflect.getMetadata('method', Test.testUsingArray);
-
-    expect(path).to.be.eql(requestPath);
-    expect(method).to.be.eql(requestProps.method);
-    expect(pathUsingArray).to.be.eql(requestPathUsingArray);
-    expect(methodUsingArray).to.be.eql(requestPropsUsingArray.method);
-  });
-
-  it('should set path on "/" by default', () => {
-    class Test {
-      @Propfind()
-      public static test(
-        @Query() query,
-        @Param() params,
-        @HostParam() hostParams,
-      ) {}
-
-      @Propfind([])
-      public static testUsingArray(
-        @Query() query,
-        @Param() params,
-        @HostParam() hostParams,
-      ) {}
-    }
-
-    const path = Reflect.getMetadata('path', Test.test);
-    const pathUsingArray = Reflect.getMetadata('path', Test.testUsingArray);
-
-    expect(path).to.be.eql('/');
-    expect(pathUsingArray).to.be.eql('/');
-  });
-});
-
-describe('@PropPatch', () => {
-  const requestPath = 'test';
-  const requestProps = {
-    path: requestPath,
-    method: RequestMethod.PROPPATCH,
-  };
-
-  const requestPathUsingArray = ['foo', 'bar'];
-  const requestPropsUsingArray = {
-    path: requestPathUsingArray,
-    method: RequestMethod.PROPPATCH,
-  };
-
-  it('should enhance class with expected request metadata', () => {
-    class Test {
-      @Proppatch(requestPath)
-      public static test() {}
-
-      @Proppatch(requestPathUsingArray)
-      public static testUsingArray() {}
-    }
-
-    const path = Reflect.getMetadata('path', Test.test);
-    const method = Reflect.getMetadata('method', Test.test);
-    const pathUsingArray = Reflect.getMetadata('path', Test.testUsingArray);
-    const methodUsingArray = Reflect.getMetadata('method', Test.testUsingArray);
-
-    expect(path).to.be.eql(requestPath);
-    expect(method).to.be.eql(requestProps.method);
-    expect(pathUsingArray).to.be.eql(requestPathUsingArray);
-    expect(methodUsingArray).to.be.eql(requestPropsUsingArray.method);
-  });
-
-  it('should set path on "/" by default', () => {
-    class Test {
-      @Proppatch()
-      public static test(
-        @Query() query,
-        @Param() params,
-        @HostParam() hostParams,
-      ) {}
-
-      @Proppatch([])
-      public static testUsingArray(
-        @Query() query,
-        @Param() params,
-        @HostParam() hostParams,
-      ) {}
-    }
-
-    const path = Reflect.getMetadata('path', Test.test);
-    const pathUsingArray = Reflect.getMetadata('path', Test.testUsingArray);
-
-    expect(path).to.be.eql('/');
-    expect(pathUsingArray).to.be.eql('/');
-  });
-});
-
-describe('@MkCol', () => {
-  const requestPath = 'test';
-  const requestProps = {
-    path: requestPath,
-    method: RequestMethod.MKCOL,
-  };
-
-  const requestPathUsingArray = ['foo', 'bar'];
-  const requestPropsUsingArray = {
-    path: requestPathUsingArray,
-    method: RequestMethod.MKCOL,
-  };
-
-  it('should enhance class with expected request metadata', () => {
-    class Test {
-      @Mkcol(requestPath)
-      public static test() {}
-
-      @Mkcol(requestPathUsingArray)
-      public static testUsingArray() {}
-    }
-
-    const path = Reflect.getMetadata('path', Test.test);
-    const method = Reflect.getMetadata('method', Test.test);
-    const pathUsingArray = Reflect.getMetadata('path', Test.testUsingArray);
-    const methodUsingArray = Reflect.getMetadata('method', Test.testUsingArray);
-
-    expect(path).to.be.eql(requestPath);
-    expect(method).to.be.eql(requestProps.method);
-    expect(pathUsingArray).to.be.eql(requestPathUsingArray);
-    expect(methodUsingArray).to.be.eql(requestPropsUsingArray.method);
-  });
-
-  it('should set path on "/" by default', () => {
-    class Test {
-      @Mkcol()
-      public static test(
-        @Query() query,
-        @Param() params,
-        @HostParam() hostParams,
-      ) {}
-
-      @Mkcol([])
-      public static testUsingArray(
-        @Query() query,
-        @Param() params,
-        @HostParam() hostParams,
-      ) {}
-    }
-
-    const path = Reflect.getMetadata('path', Test.test);
-    const pathUsingArray = Reflect.getMetadata('path', Test.testUsingArray);
-
-    expect(path).to.be.eql('/');
-    expect(pathUsingArray).to.be.eql('/');
-  });
-});
-
-describe('@Copy', () => {
-  const requestPath = 'test';
-  const requestProps = {
-    path: requestPath,
-    method: RequestMethod.COPY,
-  };
-
-  const requestPathUsingArray = ['foo', 'bar'];
-  const requestPropsUsingArray = {
-    path: requestPathUsingArray,
-    method: RequestMethod.COPY,
-  };
-
-  it('should enhance class with expected request metadata', () => {
-    class Test {
-      @Copy(requestPath)
-      public static test() {}
-
-      @Copy(requestPathUsingArray)
-      public static testUsingArray() {}
-    }
-
-    const path = Reflect.getMetadata('path', Test.test);
-    const method = Reflect.getMetadata('method', Test.test);
-    const pathUsingArray = Reflect.getMetadata('path', Test.testUsingArray);
-    const methodUsingArray = Reflect.getMetadata('method', Test.testUsingArray);
-
-    expect(path).to.be.eql(requestPath);
-    expect(method).to.be.eql(requestProps.method);
-    expect(pathUsingArray).to.be.eql(requestPathUsingArray);
-    expect(methodUsingArray).to.be.eql(requestPropsUsingArray.method);
-  });
-
-  it('should set path on "/" by default', () => {
-    class Test {
-      @Copy()
-      public static test(
-        @Query() query,
-        @Param() params,
-        @HostParam() hostParams,
-      ) {}
-
-      @Copy([])
-      public static testUsingArray(
-        @Query() query,
-        @Param() params,
-        @HostParam() hostParams,
-      ) {}
-    }
-
-    const path = Reflect.getMetadata('path', Test.test);
-    const pathUsingArray = Reflect.getMetadata('path', Test.testUsingArray);
-
-    expect(path).to.be.eql('/');
-    expect(pathUsingArray).to.be.eql('/');
-  });
-});
-
-describe('@Move', () => {
-  const requestPath = 'test';
-  const requestProps = {
-    path: requestPath,
-    method: RequestMethod.MOVE,
-  };
-
-  const requestPathUsingArray = ['foo', 'bar'];
-  const requestPropsUsingArray = {
-    path: requestPathUsingArray,
-    method: RequestMethod.MOVE,
-  };
-
-  it('should enhance class with expected request metadata', () => {
-    class Test {
-      @Move(requestPath)
-      public static test() {}
-
-      @Move(requestPathUsingArray)
-      public static testUsingArray() {}
-    }
-
-    const path = Reflect.getMetadata('path', Test.test);
-    const method = Reflect.getMetadata('method', Test.test);
-    const pathUsingArray = Reflect.getMetadata('path', Test.testUsingArray);
-    const methodUsingArray = Reflect.getMetadata('method', Test.testUsingArray);
-
-    expect(path).to.be.eql(requestPath);
-    expect(method).to.be.eql(requestProps.method);
-    expect(pathUsingArray).to.be.eql(requestPathUsingArray);
-    expect(methodUsingArray).to.be.eql(requestPropsUsingArray.method);
-  });
-
-  it('should set path on "/" by default', () => {
-    class Test {
-      @Move()
-      public static test(
-        @Query() query,
-        @Param() params,
-        @HostParam() hostParams,
-      ) {}
-
-      @Move([])
-      public static testUsingArray(
-        @Query() query,
-        @Param() params,
-        @HostParam() hostParams,
-      ) {}
-    }
-
-    const path = Reflect.getMetadata('path', Test.test);
-    const pathUsingArray = Reflect.getMetadata('path', Test.testUsingArray);
-
-    expect(path).to.be.eql('/');
-    expect(pathUsingArray).to.be.eql('/');
-  });
-});
-
-describe('@Lock', () => {
-  const requestPath = 'test';
-  const requestProps = {
-    path: requestPath,
-    method: RequestMethod.LOCK,
-  };
-
-  const requestPathUsingArray = ['foo', 'bar'];
-  const requestPropsUsingArray = {
-    path: requestPathUsingArray,
-    method: RequestMethod.LOCK,
-  };
-
-  it('should enhance class with expected request metadata', () => {
-    class Test {
-      @Lock(requestPath)
-      public static test() {}
-
-      @Lock(requestPathUsingArray)
-      public static testUsingArray() {}
-    }
-
-    const path = Reflect.getMetadata('path', Test.test);
-    const method = Reflect.getMetadata('method', Test.test);
-    const pathUsingArray = Reflect.getMetadata('path', Test.testUsingArray);
-    const methodUsingArray = Reflect.getMetadata('method', Test.testUsingArray);
-
-    expect(path).to.be.eql(requestPath);
-    expect(method).to.be.eql(requestProps.method);
-    expect(pathUsingArray).to.be.eql(requestPathUsingArray);
-    expect(methodUsingArray).to.be.eql(requestPropsUsingArray.method);
-  });
-
-  it('should set path on "/" by default', () => {
-    class Test {
-      @Lock()
-      public static test(
-        @Query() query,
-        @Param() params,
-        @HostParam() hostParams,
-      ) {}
-
-      @Lock([])
-      public static testUsingArray(
-        @Query() query,
-        @Param() params,
-        @HostParam() hostParams,
-      ) {}
-    }
-
-    const path = Reflect.getMetadata('path', Test.test);
-    const pathUsingArray = Reflect.getMetadata('path', Test.testUsingArray);
-
-    expect(path).to.be.eql('/');
-    expect(pathUsingArray).to.be.eql('/');
-  });
-});
-
-describe('@Unlock', () => {
-  const requestPath = 'test';
-  const requestProps = {
-    path: requestPath,
-    method: RequestMethod.UNLOCK,
-  };
-
-  const requestPathUsingArray = ['foo', 'bar'];
-  const requestPropsUsingArray = {
-    path: requestPathUsingArray,
-    method: RequestMethod.UNLOCK,
-  };
-
-  it('should enhance class with expected request metadata', () => {
-    class Test {
-      @Unlock(requestPath)
-      public static test() {}
-
-      @Unlock(requestPathUsingArray)
-      public static testUsingArray() {}
-    }
-
-    const path = Reflect.getMetadata('path', Test.test);
-    const method = Reflect.getMetadata('method', Test.test);
-    const pathUsingArray = Reflect.getMetadata('path', Test.testUsingArray);
-    const methodUsingArray = Reflect.getMetadata('method', Test.testUsingArray);
-
-    expect(path).to.be.eql(requestPath);
-    expect(method).to.be.eql(requestProps.method);
-    expect(pathUsingArray).to.be.eql(requestPathUsingArray);
-    expect(methodUsingArray).to.be.eql(requestPropsUsingArray.method);
-  });
-
-  it('should set path on "/" by default', () => {
-    class Test {
-      @Unlock()
-      public static test(
-        @Query() query,
-        @Param() params,
-        @HostParam() hostParams,
-      ) {}
-
-      @Unlock([])
-      public static testUsingArray(
-        @Query() query,
-        @Param() params,
-        @HostParam() hostParams,
-      ) {}
-    }
-
-    const path = Reflect.getMetadata('path', Test.test);
-    const pathUsingArray = Reflect.getMetadata('path', Test.testUsingArray);
-
-    expect(path).to.be.eql('/');
-    expect(pathUsingArray).to.be.eql('/');
-  });
-});
diff --git a/packages/common/test/pipes/parse-date.pipe.spec.ts b/packages/common/test/pipes/parse-date.pipe.spec.ts
new file mode 100644
index 000000000..867e26f3f
--- /dev/null
+++ b/packages/common/test/pipes/parse-date.pipe.spec.ts
@@ -0,0 +1,71 @@
+import { expect } from 'chai';
+import { BadRequestException } from '../../exceptions';
+import { ParseDatePipe } from '../../pipes/parse-date.pipe';
+
+describe('ParseDatePipe', () => {
+  let target: ParseDatePipe;
+
+  beforeEach(() => {
+    target = new ParseDatePipe();
+  });
+
+  describe('transform', () => {
+    describe('when validation passes', () => {
+      it('should return a valid date object', () => {
+        const date = new Date().toISOString();
+
+        const transformedDate = target.transform(date);
+        expect(transformedDate).to.be.instanceOf(Date);
+        expect(transformedDate.toISOString()).to.equal(date);
+
+        const asNumber = transformedDate.getTime();
+        const transformedNumber = target.transform(asNumber);
+        expect(transformedNumber).to.be.instanceOf(Date);
+        expect(transformedNumber.getTime()).to.equal(asNumber);
+      });
+
+      it('should not throw an error if the value is undefined/null and optional is true', () => {
+        const target = new ParseDatePipe({ optional: true });
+        const value = target.transform(undefined);
+        expect(value).to.equal(undefined);
+      });
+    });
+    describe('when default value is provided', () => {
+      it('should return the default value if the value is undefined/null', () => {
+        const defaultValue = new Date();
+        const target = new ParseDatePipe({
+          optional: true,
+          default: () => defaultValue,
+        });
+        const value = target.transform(undefined);
+        expect(value).to.equal(defaultValue);
+      });
+    });
+    describe('when validation fails', () => {
+      it('should throw an error', () => {
+        try {
+          target.transform('123abc');
+          expect.fail();
+        } catch (error) {
+          expect(error).to.be.instanceOf(BadRequestException);
+          expect(error.message).to.equal(
+            'Validation failed (invalid date format)',
+          );
+        }
+      });
+    });
+    describe('when empty value', () => {
+      it('should throw an error', () => {
+        try {
+          target.transform('');
+          expect.fail();
+        } catch (error) {
+          expect(error).to.be.instanceOf(BadRequestException);
+          expect(error.message).to.equal(
+            'Validation failed (no Date provided)',
+          );
+        }
+      });
+    });
+  });
+});
diff --git a/packages/common/test/pipes/validation.pipe.spec.ts b/packages/common/test/pipes/validation.pipe.spec.ts
index 43b819c58..128658035 100644
--- a/packages/common/test/pipes/validation.pipe.spec.ts
+++ b/packages/common/test/pipes/validation.pipe.spec.ts
@@ -205,6 +205,18 @@ describe('ValidationPipe', () => {
             }),
           ).to.be.equal(+value);
         });
+        it('should parse undefined to undefined', async () => {
+          target = new ValidationPipe({ transform: true });
+          const value = undefined;
+
+          expect(
+            await target.transform(value, {
+              metatype: Number,
+              data: 'test',
+              type: 'query',
+            }),
+          ).to.be.undefined;
+        });
       });
       describe('when input is a path parameter (number)', () => {
         it('should parse to number', async () => {
@@ -219,6 +231,18 @@ describe('ValidationPipe', () => {
             }),
           ).to.be.equal(+value);
         });
+        it('should parse undefined to undefined', async () => {
+          target = new ValidationPipe({ transform: true });
+          const value = undefined;
+
+          expect(
+            await target.transform(value, {
+              metatype: Number,
+              data: 'test',
+              type: 'param',
+            }),
+          ).to.be.undefined;
+        });
       });
       describe('when input is a query parameter (boolean)', () => {
         it('should parse the string "true" to the boolean true', async () => {
diff --git a/packages/common/test/services/logger.service.spec.ts b/packages/common/test/services/logger.service.spec.ts
index e3a61464d..7dd45379a 100644
--- a/packages/common/test/services/logger.service.spec.ts
+++ b/packages/common/test/services/logger.service.spec.ts
@@ -125,9 +125,12 @@ describe('Logger', () => {
         Logger.error(error);
 
         expect(processStderrWriteSpy.calledOnce).to.be.true;
-        expect(processStderrWriteSpy.firstCall.firstArg).to.include(`Object:`);
+
+        expect(processStderrWriteSpy.firstCall.firstArg).to.include(
+          `Object(${Object.keys(error).length})`,
+        );
         expect(processStderrWriteSpy.firstCall.firstArg).to.include(
-          `{\n  "randomError": true\n}`,
+          `randomError: \x1b[33mtrue`,
         );
       });
 
@@ -181,6 +184,153 @@ describe('Logger', () => {
         expect(processStderrWriteSpy.thirdCall.firstArg).to.equal(stack + '\n');
       });
     });
+
+    describe('when the default logger is used and json mode is enabled', () => {
+      const logger = new ConsoleLogger({ json: true });
+
+      let processStdoutWriteSpy: sinon.SinonSpy;
+      let processStderrWriteSpy: sinon.SinonSpy;
+
+      beforeEach(() => {
+        processStdoutWriteSpy = sinon.spy(process.stdout, 'write');
+        processStderrWriteSpy = sinon.spy(process.stderr, 'write');
+      });
+
+      afterEach(() => {
+        processStdoutWriteSpy.restore();
+        processStderrWriteSpy.restore();
+      });
+
+      it('should print error with stack as JSON to the console', () => {
+        const errorMessage = 'error message';
+        const error = new Error(errorMessage);
+
+        logger.error(error.message, error.stack);
+
+        const json = JSON.parse(processStderrWriteSpy.firstCall?.firstArg);
+
+        expect(json.pid).to.equal(process.pid);
+        expect(json.level).to.equal('error');
+        expect(json.message).to.equal(errorMessage);
+      });
+      it('should log out to stdout as JSON', () => {
+        const message = 'message 1';
+
+        logger.log(message);
+
+        const json = JSON.parse(processStdoutWriteSpy.firstCall?.firstArg);
+
+        expect(json.pid).to.equal(process.pid);
+        expect(json.level).to.equal('log');
+        expect(json.message).to.equal(message);
+      });
+      it('should log out an error to stderr as JSON', () => {
+        const message = 'message 1';
+
+        logger.error(message);
+
+        const json = JSON.parse(processStderrWriteSpy.firstCall?.firstArg);
+
+        expect(json.pid).to.equal(process.pid);
+        expect(json.level).to.equal('error');
+        expect(json.message).to.equal(message);
+      });
+      it('should log Map object', () => {
+        const map = new Map([
+          ['key1', 'value1'],
+          ['key2', 'value2'],
+        ]);
+
+        logger.log(map);
+
+        const json = JSON.parse(processStdoutWriteSpy.firstCall?.firstArg);
+
+        expect(json.pid).to.equal(process.pid);
+        expect(json.level).to.equal('log');
+        expect(json.message).to.equal(
+          `Map(2) { 'key1' => 'value1', 'key2' => 'value2' }`,
+        );
+      });
+      it('should log Set object', () => {
+        const set = new Set(['value1', 'value2']);
+
+        logger.log(set);
+
+        const json = JSON.parse(processStdoutWriteSpy.firstCall?.firstArg);
+
+        expect(json.pid).to.equal(process.pid);
+        expect(json.level).to.equal('log');
+        expect(json.message).to.equal(`Set(2) { 'value1', 'value2' }`);
+      });
+      it('should log bigint', () => {
+        const bigInt = BigInt(9007199254740991);
+
+        logger.log(bigInt);
+
+        const json = JSON.parse(processStdoutWriteSpy.firstCall?.firstArg);
+
+        expect(json.pid).to.equal(process.pid);
+        expect(json.level).to.equal('log');
+        expect(json.message).to.equal('9007199254740991');
+      });
+      it('should log symbol', () => {
+        const symbol = Symbol('test');
+
+        logger.log(symbol);
+
+        const json = JSON.parse(processStdoutWriteSpy.firstCall?.firstArg);
+
+        expect(json.pid).to.equal(process.pid);
+        expect(json.level).to.equal('log');
+        expect(json.message).to.equal('Symbol(test)');
+      });
+    });
+
+    describe('when the default logger is used, json mode is enabled and compact is false (utils.inspect)', () => {
+      const logger = new ConsoleLogger({ json: true, compact: false });
+
+      let processStdoutWriteSpy: sinon.SinonSpy;
+      let processStderrWriteSpy: sinon.SinonSpy;
+
+      beforeEach(() => {
+        processStdoutWriteSpy = sinon.spy(process.stdout, 'write');
+        processStderrWriteSpy = sinon.spy(process.stderr, 'write');
+      });
+
+      afterEach(() => {
+        processStdoutWriteSpy.restore();
+        processStderrWriteSpy.restore();
+      });
+
+      it('should log out to stdout as JSON (utils.inspect)', () => {
+        const message = 'message 1';
+
+        logger.log(message);
+
+        const json = convertInspectToJSON(
+          processStdoutWriteSpy.firstCall?.firstArg,
+        );
+
+        expect(json.pid).to.equal(process.pid);
+        expect(json.level).to.equal('log');
+        expect(json.message).to.equal(message);
+      });
+
+      it('should log out an error to stderr as JSON (utils.inspect)', () => {
+        const message = 'message 1';
+
+        logger.error(message);
+
+        const json = convertInspectToJSON(
+          processStderrWriteSpy.firstCall?.firstArg,
+        );
+
+        expect(json.pid).to.equal(process.pid);
+        expect(json.level).to.equal('error');
+        expect(json.message).to.equal(message);
+      });
+    });
+
     describe('when logging is disabled', () => {
       let processStdoutWriteSpy: sinon.SinonSpy;
       let previousLoggerRef: LoggerService;
@@ -568,6 +718,7 @@ describe('Logger', () => {
         expect(processStdoutWriteSpy.called).to.be.false;
       });
     });
+
     describe('when custom logger is being used', () => {
       class CustomLogger implements LoggerService {
         log(message: any, context?: string) {}
@@ -723,7 +874,7 @@ describe('Logger', () => {
         }
       }
 
-      const consoleLogger = new CustomConsoleLogger();
+      const consoleLogger = new CustomConsoleLogger({ colors: false });
       const consoleLoggerSpy = sinon.spy(
         consoleLogger,
         'stringifyMessage' as keyof ConsoleLogger,
@@ -739,30 +890,40 @@ describe('Logger', () => {
 
       expect(consoleLoggerSpy.getCall(0).returnValue).to.equal('str1');
       expect(consoleLoggerSpy.getCall(1).returnValue).to.equal(
-        `Object:
-{
-  "key": "str2"
-}
-`,
+        `Object(1) {
+  key: 'str2'
+}`,
       );
       expect(consoleLoggerSpy.getCall(2).returnValue).to.equal(
-        `Object:
-[
-  "str3"
-]
-`,
+        `Array(1) [
+  'str3'
+]`,
       );
       expect(consoleLoggerSpy.getCall(3).returnValue).to.equal(
-        `Object:
-[
+        `Array(1) [
   {
-    "key": "str4"
+    key: 'str4'
   }
-]
-`,
+]`,
       );
-      expect(consoleLoggerSpy.getCall(4).returnValue).to.equal(null);
-      expect(consoleLoggerSpy.getCall(5).returnValue).to.equal(1);
+      expect(consoleLoggerSpy.getCall(4).returnValue).to.equal('null');
+      expect(consoleLoggerSpy.getCall(5).returnValue).to.equal('1');
     });
   });
 });
+
+function convertInspectToJSON(inspectOutput: string) {
+  const jsonLikeString = inspectOutput
+    .replace(/'([^']+)'/g, '"$1"') // single-quoted strings
+    .replace(/([a-zA-Z0-9_]+):/g, '"$1":') // unquoted object keys
+    .replace(/\bundefined\b/g, 'null')
+    .replace(/\[Function(: [^\]]+)?\]/g, '"[Function]"')
+    .replace(/\[Circular\]/g, '"[Circular]"');
+
+  try {
+    return JSON.parse(jsonLikeString);
+  } catch (error) {
+    console.error('Error parsing the modified inspect output:', error);
+    throw error;
+  }
+}
diff --git a/packages/core/adapters/http-adapter.ts b/packages/core/adapters/http-adapter.ts
index 106e447ca..6e079fe55 100644
--- a/packages/core/adapters/http-adapter.ts
+++ b/packages/core/adapters/http-adapter.ts
@@ -62,48 +62,6 @@ export abstract class AbstractHttpAdapter<
     return this.instance.patch(...args);
   }
 
-  public propfind(handler: RequestHandler);
-  public propfind(path: any, handler: RequestHandler);
-  public propfind(...args: any[]) {
-    return this.instance.propfind(...args);
-  }
-
-  public proppatch(handler: RequestHandler);
-  public proppatch(path: any, handler: RequestHandler);
-  public proppatch(...args: any[]) {
-    return this.instance.proppatch(...args);
-  }
-
-  public mkcol(handler: RequestHandler);
-  public mkcol(path: any, handler: RequestHandler);
-  public mkcol(...args: any[]) {
-    return this.instance.mkcol(...args);
-  }
-
-  public copy(handler: RequestHandler);
-  public copy(path: any, handler: RequestHandler);
-  public copy(...args: any[]) {
-    return this.instance.copy(...args);
-  }
-
-  public move(handler: RequestHandler);
-  public move(path: any, handler: RequestHandler);
-  public move(...args: any[]) {
-    return this.instance.move(...args);
-  }
-
-  public lock(handler: RequestHandler);
-  public lock(path: any, handler: RequestHandler);
-  public lock(...args: any[]) {
-    return this.instance.lock(...args);
-  }
-
-  public unlock(handler: RequestHandler);
-  public unlock(path: any, handler: RequestHandler);
-  public unlock(...args: any[]) {
-    return this.instance.unlock(...args);
-  }
-
   public all(handler: RequestHandler);
   public all(path: any, handler: RequestHandler);
   public all(...args: any[]) {
diff --git a/packages/core/errors/exception-handler.ts b/packages/core/errors/exception-handler.ts
index 3b1c47c00..e34358bf2 100644
--- a/packages/core/errors/exception-handler.ts
+++ b/packages/core/errors/exception-handler.ts
@@ -1,14 +1,9 @@
-import { RuntimeException } from './exceptions/runtime.exception';
 import { Logger } from '@nestjs/common/services/logger.service';
 
 export class ExceptionHandler {
   private static readonly logger = new Logger(ExceptionHandler.name);
 
-  public handle(exception: RuntimeException | Error) {
-    if (!(exception instanceof RuntimeException)) {
-      ExceptionHandler.logger.error(exception.message, exception.stack);
-      return;
-    }
-    ExceptionHandler.logger.error(exception.what(), exception.stack);
+  public handle(exception: Error) {
+    ExceptionHandler.logger.error(exception);
   }
 }
diff --git a/packages/core/exceptions/base-exception-filter.ts b/packages/core/exceptions/base-exception-filter.ts
index bc3784501..12735f136 100644
--- a/packages/core/exceptions/base-exception-filter.ts
+++ b/packages/core/exceptions/base-exception-filter.ts
@@ -68,12 +68,6 @@ export class BaseExceptionFilter<T = any> implements ExceptionFilter<T> {
       applicationRef.end(response);
     }
 
-    if (this.isExceptionObject(exception)) {
-      return BaseExceptionFilter.logger.error(
-        exception.message,
-        exception.stack,
-      );
-    }
     return BaseExceptionFilter.logger.error(exception);
   }
 
diff --git a/packages/core/exceptions/external-exception-filter.ts b/packages/core/exceptions/external-exception-filter.ts
index 9c6b2563b..076b6a970 100644
--- a/packages/core/exceptions/external-exception-filter.ts
+++ b/packages/core/exceptions/external-exception-filter.ts
@@ -5,7 +5,7 @@ export class ExternalExceptionFilter<T = any, R = any> {
 
   catch(exception: T, host: ArgumentsHost): R | Promise<R> {
     if (exception instanceof Error && !(exception instanceof HttpException)) {
-      ExternalExceptionFilter.logger.error(exception.message, exception.stack);
+      ExternalExceptionFilter.logger.error(exception);
     }
     throw exception;
   }
diff --git a/packages/core/helpers/router-method-factory.ts b/packages/core/helpers/router-method-factory.ts
index 6051303d6..ff31c57e1 100644
--- a/packages/core/helpers/router-method-factory.ts
+++ b/packages/core/helpers/router-method-factory.ts
@@ -11,13 +11,6 @@ const REQUEST_METHOD_MAP = {
   [RequestMethod.OPTIONS]: 'options',
   [RequestMethod.HEAD]: 'head',
   [RequestMethod.SEARCH]: 'search',
-  [RequestMethod.PROPFIND]: 'propfind',
-  [RequestMethod.PROPPATCH]: 'proppatch',
-  [RequestMethod.MKCOL]: 'mkcol',
-  [RequestMethod.COPY]: 'copy',
-  [RequestMethod.MOVE]: 'move',
-  [RequestMethod.LOCK]: 'lock',
-  [RequestMethod.UNLOCK]: 'unlock',
 } as const satisfies Record<RequestMethod, keyof HttpServer>;
 
 export class RouterMethodFactory {
diff --git a/packages/core/injector/compiler.ts b/packages/core/injector/compiler.ts
index 353e27581..075d97bc3 100644
--- a/packages/core/injector/compiler.ts
+++ b/packages/core/injector/compiler.ts
@@ -3,7 +3,7 @@ import {
   ForwardReference,
   Type,
 } from '@nestjs/common/interfaces';
-import { ModuleTokenFactory } from './module-token-factory';
+import { ModuleOpaqueKeyFactory } from './opaque-key-factory/interfaces/module-opaque-key-factory.interface';
 
 export interface ModuleFactory {
   type: Type<any>;
@@ -12,36 +12,59 @@ export interface ModuleFactory {
 }
 
 export class ModuleCompiler {
-  constructor(private readonly moduleTokenFactory = new ModuleTokenFactory()) {}
+  constructor(
+    private readonly _moduleOpaqueKeyFactory: ModuleOpaqueKeyFactory,
+  ) {}
+
+  get moduleOpaqueKeyFactory(): ModuleOpaqueKeyFactory {
+    return this._moduleOpaqueKeyFactory;
+  }
 
   public async compile(
-    metatype: Type<any> | DynamicModule | Promise<DynamicModule>,
+    moduleClsOrDynamic:
+      | Type
+      | DynamicModule
+      | ForwardReference
+      | Promise<DynamicModule>,
   ): Promise<ModuleFactory> {
-    const { type, dynamicMetadata } = this.extractMetadata(await metatype);
-    const token = this.moduleTokenFactory.create(type, dynamicMetadata);
+    moduleClsOrDynamic = await moduleClsOrDynamic;
+
+    const { type, dynamicMetadata } = this.extractMetadata(moduleClsOrDynamic);
+    const token = dynamicMetadata
+      ? this._moduleOpaqueKeyFactory.createForDynamic(
+          type,
+          dynamicMetadata,
+          moduleClsOrDynamic as DynamicModule | ForwardReference,
+        )
+      : this._moduleOpaqueKeyFactory.createForStatic(
+          type,
+          moduleClsOrDynamic as Type,
+        );
+
     return { type, dynamicMetadata, token };
   }
 
   public extractMetadata(
-    metatype: Type<any> | ForwardReference | DynamicModule,
+    moduleClsOrDynamic: Type | ForwardReference | DynamicModule,
   ): {
-    type: Type<any>;
-    dynamicMetadata?: Partial<DynamicModule> | undefined;
+    type: Type;
+    dynamicMetadata: Omit<DynamicModule, 'module'> | undefined;
   } {
-    if (!this.isDynamicModule(metatype)) {
+    if (!this.isDynamicModule(moduleClsOrDynamic)) {
       return {
-        type: (metatype as ForwardReference)?.forwardRef
-          ? (metatype as ForwardReference).forwardRef()
-          : metatype,
+        type: (moduleClsOrDynamic as ForwardReference)?.forwardRef
+          ? (moduleClsOrDynamic as ForwardReference).forwardRef()
+          : moduleClsOrDynamic,
+        dynamicMetadata: undefined,
       };
     }
-    const { module: type, ...dynamicMetadata } = metatype;
+    const { module: type, ...dynamicMetadata } = moduleClsOrDynamic;
     return { type, dynamicMetadata };
   }
 
   public isDynamicModule(
-    module: Type<any> | DynamicModule | ForwardReference,
-  ): module is DynamicModule {
-    return !!(module as DynamicModule).module;
+    moduleClsOrDynamic: Type | DynamicModule | ForwardReference,
+  ): moduleClsOrDynamic is DynamicModule {
+    return !!(moduleClsOrDynamic as DynamicModule).module;
   }
 }
diff --git a/packages/core/injector/container.ts b/packages/core/injector/container.ts
index 9fbbcbd8b..f2237ea6a 100644
--- a/packages/core/injector/container.ts
+++ b/packages/core/injector/container.ts
@@ -4,6 +4,7 @@ import {
   GLOBAL_MODULE_METADATA,
 } from '@nestjs/common/constants';
 import { Injectable, Type } from '@nestjs/common/interfaces';
+import { NestApplicationContextOptions } from '@nestjs/common/interfaces/nest-application-context-options.interface';
 import { ApplicationConfig } from '../application-config';
 import { DiscoverableMetaHostCollection } from '../discovery/discoverable-meta-host-collection';
 import {
@@ -19,16 +20,16 @@ import { ContextId } from './instance-wrapper';
 import { InternalCoreModule } from './internal-core-module/internal-core-module';
 import { InternalProvidersStorage } from './internal-providers-storage';
 import { Module } from './module';
-import { ModuleTokenFactory } from './module-token-factory';
 import { ModulesContainer } from './modules-container';
+import { ByReferenceModuleOpaqueKeyFactory } from './opaque-key-factory/by-reference-module-opaque-key-factory';
+import { DeepHashedModuleOpaqueKeyFactory } from './opaque-key-factory/deep-hashed-module-opaque-key-factory';
+import { ModuleOpaqueKeyFactory } from './opaque-key-factory/interfaces/module-opaque-key-factory.interface';
 
 type ModuleMetatype = Type<any> | DynamicModule | Promise<DynamicModule>;
 type ModuleScope = Type<any>[];
 
 export class NestContainer {
   private readonly globalModules = new Set<Module>();
-  private readonly moduleTokenFactory = new ModuleTokenFactory();
-  private readonly moduleCompiler = new ModuleCompiler(this.moduleTokenFactory);
   private readonly modules = new ModulesContainer();
   private readonly dynamicModulesMetadata = new Map<
     string,
@@ -36,11 +37,27 @@ export class NestContainer {
   >();
   private readonly internalProvidersStorage = new InternalProvidersStorage();
   private readonly _serializedGraph = new SerializedGraph();
+  private moduleCompiler: ModuleCompiler;
   private internalCoreModule: Module;
 
   constructor(
-    private readonly _applicationConfig: ApplicationConfig = undefined,
-  ) {}
+    private readonly _applicationConfig:
+      | ApplicationConfig
+      | undefined = undefined,
+    private readonly _contextOptions:
+      | NestApplicationContextOptions
+      | undefined = undefined,
+  ) {
+    const moduleOpaqueKeyFactory =
+      this._contextOptions?.moduleIdGeneratorAlgorithm === 'deep-hash'
+        ? new DeepHashedModuleOpaqueKeyFactory()
+        : new ByReferenceModuleOpaqueKeyFactory({
+            keyGenerationStrategy: this._contextOptions?.snapshot
+              ? 'shallow'
+              : 'random',
+          });
+    this.moduleCompiler = new ModuleCompiler(moduleOpaqueKeyFactory);
+  }
 
   get serializedGraph(): SerializedGraph {
     return this._serializedGraph;
@@ -321,8 +338,8 @@ export class NestContainer {
     this.modules[InternalCoreModule.name] = moduleRef;
   }
 
-  public getModuleTokenFactory(): ModuleTokenFactory {
-    return this.moduleTokenFactory;
+  public getModuleTokenFactory(): ModuleOpaqueKeyFactory {
+    return this.moduleCompiler.moduleOpaqueKeyFactory;
   }
 
   public registerRequestProvider<T = any>(request: T, contextId: ContextId) {
diff --git a/packages/core/injector/module.ts b/packages/core/injector/module.ts
index 634377544..807e20499 100644
--- a/packages/core/injector/module.ts
+++ b/packages/core/injector/module.ts
@@ -653,7 +653,12 @@ export class Module {
 
   private generateUuid(): string {
     const prefix = 'M_';
-    const key = this.name?.toString() ?? this.token?.toString();
+    const key = this.token
+      ? this.token.includes(':')
+        ? this.token.split(':')[1]
+        : this.token
+      : this.name;
+
     return key ? UuidFactory.get(`${prefix}_${key}`) : randomStringGenerator();
   }
 }
diff --git a/packages/core/injector/opaque-key-factory/by-reference-module-opaque-key-factory.ts b/packages/core/injector/opaque-key-factory/by-reference-module-opaque-key-factory.ts
new file mode 100644
index 000000000..a5721fb32
--- /dev/null
+++ b/packages/core/injector/opaque-key-factory/by-reference-module-opaque-key-factory.ts
@@ -0,0 +1,63 @@
+import { DynamicModule } from '@nestjs/common/interfaces/modules/dynamic-module.interface';
+import { ForwardReference } from '@nestjs/common/interfaces/modules/forward-reference.interface';
+import { Type } from '@nestjs/common/interfaces/type.interface';
+import { randomStringGenerator } from '@nestjs/common/utils/random-string-generator.util';
+import { createHash } from 'crypto';
+import { ModuleOpaqueKeyFactory } from './interfaces/module-opaque-key-factory.interface';
+
+const K_MODULE_ID = Symbol('K_MODULE_ID');
+
+export class ByReferenceModuleOpaqueKeyFactory
+  implements ModuleOpaqueKeyFactory
+{
+  private readonly keyGenerationStrategy: 'random' | 'shallow';
+
+  constructor(options?: { keyGenerationStrategy: 'random' | 'shallow' }) {
+    this.keyGenerationStrategy = options?.keyGenerationStrategy ?? 'random';
+  }
+
+  public createForStatic(
+    moduleCls: Type,
+    originalRef: Type | ForwardReference = moduleCls,
+  ): string {
+    return this.getOrCreateModuleId(moduleCls, undefined, originalRef);
+  }
+
+  public createForDynamic(
+    moduleCls: Type<unknown>,
+    dynamicMetadata: Omit<DynamicModule, 'module'>,
+    originalRef: DynamicModule | ForwardReference,
+  ): string {
+    return this.getOrCreateModuleId(moduleCls, dynamicMetadata, originalRef);
+  }
+
+  private getOrCreateModuleId(
+    moduleCls: Type<unknown>,
+    dynamicMetadata: Partial<DynamicModule> | undefined,
+    originalRef: Type | DynamicModule | ForwardReference,
+  ): string {
+    if (originalRef[K_MODULE_ID]) {
+      return originalRef[K_MODULE_ID];
+    }
+
+    let moduleId: string;
+    if (this.keyGenerationStrategy === 'random') {
+      moduleId = this.generateRandomString();
+    } else {
+      moduleId = dynamicMetadata
+        ? `${this.generateRandomString()}:${this.hashString(moduleCls.name + JSON.stringify(dynamicMetadata))}`
+        : `${this.generateRandomString()}:${this.hashString(moduleCls.toString())}`;
+    }
+
+    originalRef[K_MODULE_ID] = moduleId;
+    return moduleId;
+  }
+
+  private hashString(value: string): string {
+    return createHash('sha256').update(value).digest('hex');
+  }
+
+  private generateRandomString(): string {
+    return randomStringGenerator();
+  }
+}
diff --git a/packages/core/injector/module-token-factory.ts b/packages/core/injector/opaque-key-factory/deep-hashed-module-opaque-key-factory.ts
similarity index 72%
rename from packages/core/injector/module-token-factory.ts
rename to packages/core/injector/opaque-key-factory/deep-hashed-module-opaque-key-factory.ts
index 6fbebe4e7..d5ac6dc50 100644
--- a/packages/core/injector/module-token-factory.ts
+++ b/packages/core/injector/opaque-key-factory/deep-hashed-module-opaque-key-factory.ts
@@ -1,34 +1,48 @@
-import { DynamicModule, Logger } from '@nestjs/common';
+import { DynamicModule } from '@nestjs/common/interfaces/modules/dynamic-module.interface';
 import { Type } from '@nestjs/common/interfaces/type.interface';
+import { Logger } from '@nestjs/common/services/logger.service';
 import { randomStringGenerator } from '@nestjs/common/utils/random-string-generator.util';
 import { isFunction, isSymbol } from '@nestjs/common/utils/shared.utils';
 import { createHash } from 'crypto';
 import stringify from 'fast-safe-stringify';
-import { performance } from 'perf_hooks';
+import { ModuleOpaqueKeyFactory } from './interfaces/module-opaque-key-factory.interface';
 
 const CLASS_STR = 'class ';
 const CLASS_STR_LEN = CLASS_STR.length;
 
-export class ModuleTokenFactory {
-  private readonly moduleTokenCache = new Map<string, string>();
+export class DeepHashedModuleOpaqueKeyFactory
+  implements ModuleOpaqueKeyFactory
+{
   private readonly moduleIdsCache = new WeakMap<Type<unknown>, string>();
-  private readonly logger = new Logger(ModuleTokenFactory.name, {
+  private readonly moduleTokenCache = new Map<string, string>();
+  private readonly logger = new Logger(DeepHashedModuleOpaqueKeyFactory.name, {
     timestamp: true,
   });
 
-  public create(
-    metatype: Type<unknown>,
-    dynamicModuleMetadata?: Partial<DynamicModule> | undefined,
-  ): string {
-    const moduleId = this.getModuleId(metatype);
+  public createForStatic(moduleCls: Type): string {
+    const moduleId = this.getModuleId(moduleCls);
+    const moduleName = this.getModuleName(moduleCls);
 
-    if (!dynamicModuleMetadata) {
-      return this.getStaticModuleToken(moduleId, this.getModuleName(metatype));
+    const key = `${moduleId}_${moduleName}`;
+    if (this.moduleTokenCache.has(key)) {
+      return this.moduleTokenCache.get(key);
     }
+
+    const hash = this.hashString(key);
+    this.moduleTokenCache.set(key, hash);
+    return hash;
+  }
+
+  public createForDynamic(
+    moduleCls: Type<unknown>,
+    dynamicMetadata: Omit<DynamicModule, 'module'>,
+  ): string {
+    const moduleId = this.getModuleId(moduleCls);
+    const moduleName = this.getModuleName(moduleCls);
     const opaqueToken = {
       id: moduleId,
-      module: this.getModuleName(metatype),
-      dynamic: dynamicModuleMetadata,
+      module: moduleName,
+      dynamic: dynamicMetadata,
     };
     const start = performance.now();
     const opaqueTokenString = this.getStringifiedOpaqueToken(opaqueToken);
@@ -37,24 +51,13 @@ export class ModuleTokenFactory {
     if (timeSpentInMs > 10) {
       const formattedTimeSpent = timeSpentInMs.toFixed(2);
       this.logger.warn(
-        `The module "${opaqueToken.module}" is taking ${formattedTimeSpent}ms to serialize, this may be caused by larger objects statically assigned to the module. More details: https://github.com/nestjs/nest/issues/12738`,
+        `The module "${opaqueToken.module}" is taking ${formattedTimeSpent}ms to serialize, this may be caused by larger objects statically assigned to the module. Consider changing the "moduleIdGeneratorAlgorithm" option to "reference" to improve the performance.`,
       );
     }
 
     return this.hashString(opaqueTokenString);
   }
 
-  public getStaticModuleToken(moduleId: string, moduleName: string): string {
-    const key = `${moduleId}_${moduleName}`;
-    if (this.moduleTokenCache.has(key)) {
-      return this.moduleTokenCache.get(key);
-    }
-
-    const hash = this.hashString(key);
-    this.moduleTokenCache.set(key, hash);
-    return hash;
-  }
-
   public getStringifiedOpaqueToken(opaqueToken: object | undefined): string {
     // Uses safeStringify instead of JSON.stringify to support circular dynamic modules
     // The replacer function is also required in order to obtain real class names
diff --git a/packages/core/injector/opaque-key-factory/interfaces/module-opaque-key-factory.interface.ts b/packages/core/injector/opaque-key-factory/interfaces/module-opaque-key-factory.interface.ts
new file mode 100644
index 000000000..1b58a5fff
--- /dev/null
+++ b/packages/core/injector/opaque-key-factory/interfaces/module-opaque-key-factory.interface.ts
@@ -0,0 +1,26 @@
+import { DynamicModule } from '@nestjs/common/interfaces/modules/dynamic-module.interface';
+import { ForwardReference } from '@nestjs/common/interfaces/modules/forward-reference.interface';
+import { Type } from '@nestjs/common/interfaces/type.interface';
+
+export interface ModuleOpaqueKeyFactory {
+  /**
+   * Creates a unique opaque key for the given static module.
+   * @param moduleCls A static module class.
+   * @param originalRef Original object reference. In most cases, it's the same as `moduleCls`.
+   */
+  createForStatic(
+    moduleCls: Type,
+    originalRef: Type | ForwardReference,
+  ): string;
+  /**
+   * Creates a unique opaque key for the given dynamic module.
+   * @param moduleCls  A dynamic module class reference.
+   * @param dynamicMetadata Dynamic module metadata.
+   * @param originalRef Original object reference.
+   */
+  createForDynamic(
+    moduleCls: Type<unknown>,
+    dynamicMetadata: Omit<DynamicModule, 'module'>,
+    originalRef: DynamicModule | ForwardReference,
+  ): string;
+}
diff --git a/packages/core/nest-application-context.ts b/packages/core/nest-application-context.ts
index eacd82ec2..63543231c 100644
--- a/packages/core/nest-application-context.ts
+++ b/packages/core/nest-application-context.ts
@@ -9,6 +9,7 @@ import {
   Abstract,
   DynamicModule,
   GetOrResolveOptions,
+  SelectOptions,
   Type,
 } from '@nestjs/common/interfaces';
 import { NestApplicationContextOptions } from '@nestjs/common/interfaces/nest-application-context-options.interface';
@@ -50,7 +51,7 @@ export class NestApplicationContext<
 
   private shouldFlushLogsOnOverride = false;
   private readonly activeShutdownSignals = new Array<string>();
-  private readonly moduleCompiler = new ModuleCompiler();
+  private readonly moduleCompiler: ModuleCompiler;
   private shutdownCleanupRef?: (...args: unknown[]) => unknown;
   private _instanceLinksHost: InstanceLinksHost;
   private _moduleRefsForHooksByDistance?: Array<Module>;
@@ -70,6 +71,7 @@ export class NestApplicationContext<
   ) {
     super();
     this.injector = new Injector();
+    this.moduleCompiler = container.getModuleCompiler();
 
     if (this.appOptions.preview) {
       this.printInPreviewModeWarning();
@@ -87,6 +89,7 @@ export class NestApplicationContext<
    */
   public select<T>(
     moduleType: Type<T> | DynamicModule,
+    selectOptions?: SelectOptions,
   ): INestApplicationContext {
     const modulesContainer = this.container.getModules();
     const contextModuleCtor = this.contextModule.metatype;
@@ -95,15 +98,30 @@ export class NestApplicationContext<
     const moduleTokenFactory = this.container.getModuleTokenFactory();
     const { type, dynamicMetadata } =
       this.moduleCompiler.extractMetadata(moduleType);
-    const token = moduleTokenFactory.create(type, dynamicMetadata);
+    const token = dynamicMetadata
+      ? moduleTokenFactory.createForDynamic(
+          type,
+          dynamicMetadata,
+          moduleType as DynamicModule,
+        )
+      : moduleTokenFactory.createForStatic(type, moduleType as Type);
 
     const selectedModule = modulesContainer.get(token);
     if (!selectedModule) {
       throw new UnknownModuleException(type.name);
     }
+
+    const options =
+      typeof selectOptions?.abortOnError !== 'undefined'
+        ? {
+            ...this.appOptions,
+            ...selectOptions,
+          }
+        : this.appOptions;
+
     return new NestApplicationContext(
       this.container,
-      this.appOptions,
+      options,
       selectedModule,
       scope,
     );
@@ -384,7 +402,10 @@ export class NestApplicationContext<
    * modules and its children.
    */
   protected async callDestroyHook(): Promise<void> {
-    const modulesSortedByDistance = this.getModulesToTriggerHooksOn();
+    const modulesSortedByDistance = [
+      ...this.getModulesToTriggerHooksOn(),
+    ].reverse();
+
     for (const module of modulesSortedByDistance) {
       await callModuleDestroyHook(module);
     }
diff --git a/packages/core/nest-factory.ts b/packages/core/nest-factory.ts
index b40ce37ba..f3cb93bcd 100644
--- a/packages/core/nest-factory.ts
+++ b/packages/core/nest-factory.ts
@@ -3,6 +3,9 @@ import {
   INestApplication,
   INestApplicationContext,
   INestMicroservice,
+  DynamicModule,
+  ForwardReference,
+  Type,
 } from '@nestjs/common';
 import { NestMicroserviceOptions } from '@nestjs/common/interfaces/microservices/nest-microservice-options.interface';
 import { NestApplicationContextOptions } from '@nestjs/common/interfaces/nest-application-context-options.interface';
@@ -27,6 +30,12 @@ import { NestApplication } from './nest-application';
 import { NestApplicationContext } from './nest-application-context';
 import { DependenciesScanner } from './scanner';
 
+type IEntryNestModule =
+  | Type<any>
+  | DynamicModule
+  | ForwardReference
+  | Promise<IEntryNestModule>;
+
 /**
  * @publicApi
  */
@@ -47,7 +56,7 @@ export class NestFactoryStatic {
    * contains a reference to the NestApplication instance.
    */
   public async create<T extends INestApplication = INestApplication>(
-    module: any,
+    module: IEntryNestModule,
     options?: NestApplicationOptions,
   ): Promise<T>;
   /**
@@ -62,12 +71,12 @@ export class NestFactoryStatic {
    * contains a reference to the NestApplication instance.
    */
   public async create<T extends INestApplication = INestApplication>(
-    module: any,
+    module: IEntryNestModule,
     httpAdapter: AbstractHttpAdapter,
     options?: NestApplicationOptions,
   ): Promise<T>;
   public async create<T extends INestApplication = INestApplication>(
-    moduleCls: any,
+    moduleCls: IEntryNestModule,
     serverOrOptions?: AbstractHttpAdapter | NestApplicationOptions,
     options?: NestApplicationOptions,
   ): Promise<T> {
@@ -112,7 +121,7 @@ export class NestFactoryStatic {
    * contains a reference to the NestMicroservice instance.
    */
   public async createMicroservice<T extends object>(
-    moduleCls: any,
+    moduleCls: IEntryNestModule,
     options?: NestMicroserviceOptions & T,
   ): Promise<INestMicroservice> {
     const { NestMicroservice } = loadPackage(
@@ -154,7 +163,7 @@ export class NestFactoryStatic {
    * contains a reference to the NestApplicationContext instance.
    */
   public async createApplicationContext(
-    moduleCls: any,
+    moduleCls: IEntryNestModule,
     options?: NestApplicationContextOptions,
   ): Promise<INestApplicationContext> {
     const applicationConfig = new ApplicationConfig();
diff --git a/packages/core/package.json b/packages/core/package.json
index 55dd9ec14..1fbfd815a 100644
--- a/packages/core/package.json
+++ b/packages/core/package.json
@@ -1,6 +1,6 @@
 {
   "name": "@nestjs/core",
-  "version": "10.4.6",
+  "version": "10.4.7",
   "description": "Nest - modern, fast, powerful node.js web framework (@core)",
   "author": "Kamil Mysliwiec",
   "license": "MIT",
@@ -36,7 +36,7 @@
     "uid": "2.0.2"
   },
   "devDependencies": {
-    "@nestjs/common": "10.4.6"
+    "@nestjs/common": "10.4.7"
   },
   "peerDependencies": {
     "@nestjs/common": "^10.0.0",
diff --git a/packages/core/scanner.ts b/packages/core/scanner.ts
index 8f334992e..ac46a1813 100644
--- a/packages/core/scanner.ts
+++ b/packages/core/scanner.ts
@@ -92,10 +92,10 @@ export class DependenciesScanner {
       overrides: options?.overrides,
     });
     await this.scanModulesForDependencies();
-    this.calculateModulesDistance();
-
     this.addScopedEnhancersMetadata();
     this.container.bindGlobalScope();
+
+    this.calculateModulesDistance();
   }
 
   public async scanForModules({
@@ -389,12 +389,12 @@ export class DependenciesScanner {
     // Skip "InternalCoreModule" from calculating distance
     modulesGenerator.next();
 
-    const modulesStack = [];
-    const calculateDistance = (moduleRef: Module, distance = 1) => {
-      if (!moduleRef || modulesStack.includes(moduleRef)) {
+    const calculateDistance = (moduleRef: Module, distance = 1, modulesStack = []) => {
+      const localModulesStack = [...modulesStack];
+      if (!moduleRef || localModulesStack.includes(moduleRef)) {
         return;
       }
-      modulesStack.push(moduleRef);
+      localModulesStack.push(moduleRef);
 
       const moduleImports = moduleRef.imports;
       moduleImports.forEach(importedModuleRef => {
@@ -402,7 +402,7 @@ export class DependenciesScanner {
           if (distance > importedModuleRef.distance) {
             importedModuleRef.distance = distance;
           }
-          calculateDistance(importedModuleRef, distance + 1);
+          calculateDistance(importedModuleRef, distance + 1, localModulesStack);
         }
       });
     };
diff --git a/packages/core/services/reflector.service.ts b/packages/core/services/reflector.service.ts
index 8de84dd73..badd406f6 100644
--- a/packages/core/services/reflector.service.ts
+++ b/packages/core/services/reflector.service.ts
@@ -127,14 +127,10 @@ export class Reflector {
    * @param targets context (decorated objects) to retrieve metadata from
    *
    */
-  public getAll<T extends ReflectableDecorator<any>>(
-    decorator: T,
+  public getAll<TParam = any, TTransformed = TParam>(
+    decorator: ReflectableDecorator<TParam, TTransformed>,
     targets: (Type<any> | Function)[],
-  ): T extends ReflectableDecorator<infer R>
-    ? R extends Array<any>
-      ? R
-      : R[]
-    : unknown;
+  ): TTransformed extends Array<any> ? TTransformed : TTransformed[];
   /**
    * Retrieve metadata for a specified key for a specified set of targets.
    *
@@ -169,10 +165,14 @@ export class Reflector {
    * @param targets context (decorated objects) to retrieve metadata from
    *
    */
-  public getAllAndMerge<T extends ReflectableDecorator<any>>(
-    decorator: T,
+  public getAllAndMerge<TParam = any, TTransformed = TParam>(
+    decorator: ReflectableDecorator<TParam, TTransformed>,
     targets: (Type<any> | Function)[],
-  ): T extends ReflectableDecorator<infer R> ? R : unknown;
+  ): TTransformed extends Array<any>
+    ? TTransformed
+    : TTransformed extends object
+      ? TTransformed
+      : TTransformed[];
   /**
    * Retrieve metadata for a specified key for a specified set of targets and merge results.
    *
@@ -203,6 +203,13 @@ export class Reflector {
     if (isEmpty(metadataCollection)) {
       return metadataCollection as TResult;
     }
+    if (metadataCollection.length === 1) {
+      const value = metadataCollection[0];
+      if (isObject(value)) {
+        return value as TResult;
+      }
+      return metadataCollection as TResult;
+    }
     return metadataCollection.reduce((a, b) => {
       if (Array.isArray(a)) {
         return a.concat(b);
@@ -224,10 +231,10 @@ export class Reflector {
    * @param targets context (decorated objects) to retrieve metadata from
    *
    */
-  public getAllAndOverride<T extends ReflectableDecorator<any>>(
-    decorator: T,
+  public getAllAndOverride<TParam = any, TTransformed = TParam>(
+    decorator: ReflectableDecorator<TParam, TTransformed>,
     targets: (Type<any> | Function)[],
-  ): T extends ReflectableDecorator<infer R> ? R : unknown;
+  ): TTransformed;
   /**
    * Retrieve metadata for a specified key for a specified set of targets and return a first not undefined value.
    *
diff --git a/packages/core/test/errors/test/exception-handler.spec.ts b/packages/core/test/errors/test/exception-handler.spec.ts
index ca3703a13..3fda223a9 100644
--- a/packages/core/test/errors/test/exception-handler.spec.ts
+++ b/packages/core/test/errors/test/exception-handler.spec.ts
@@ -1,8 +1,7 @@
-import * as sinon from 'sinon';
 import { expect } from 'chai';
+import * as sinon from 'sinon';
 import { ExceptionHandler } from '../../../errors/exception-handler';
 import { RuntimeException } from '../../../errors/exceptions/runtime.exception';
-import { InvalidMiddlewareException } from '../../../errors/exceptions/invalid-middleware.exception';
 
 describe('ExceptionHandler', () => {
   let instance: ExceptionHandler;
@@ -10,7 +9,7 @@ describe('ExceptionHandler', () => {
     instance = new ExceptionHandler();
   });
   describe('handle', () => {
-    let logger;
+    let logger: { error: Function };
     let errorSpy: sinon.SinonSpy;
     beforeEach(() => {
       logger = {
@@ -19,16 +18,10 @@ describe('ExceptionHandler', () => {
       (ExceptionHandler as any).logger = logger;
       errorSpy = sinon.spy(logger, 'error');
     });
-    it('when exception is instanceof RuntimeException', () => {
+    it('should call the logger.error method with the thrown exception passed as an argument', () => {
       const exception = new RuntimeException('msg');
       instance.handle(exception);
-      expect(errorSpy.calledWith(exception.message, exception.stack)).to.be
-        .true;
-    });
-    it('when exception is not instanceof RuntimeException', () => {
-      const exception = new InvalidMiddlewareException('msg');
-      instance.handle(exception);
-      expect(errorSpy.calledWith(exception.what(), exception.stack)).to.be.true;
+      expect(errorSpy.calledWith(exception)).to.be.true;
     });
   });
 });
diff --git a/packages/core/test/helpers/router-method-factory.spec.ts b/packages/core/test/helpers/router-method-factory.spec.ts
index 6b3edfad5..4f904519f 100644
--- a/packages/core/test/helpers/router-method-factory.spec.ts
+++ b/packages/core/test/helpers/router-method-factory.spec.ts
@@ -14,13 +14,6 @@ describe('RouterMethodFactory', () => {
     patch: () => {},
     options: () => {},
     head: () => {},
-    propfind: () => {},
-    proppatch: () => {},
-    mkcol: () => {},
-    copy: () => {},
-    move: () => {},
-    lock: () => {},
-    unlock: () => {},
     all: () => {},
   };
   beforeEach(() => {
@@ -36,17 +29,6 @@ describe('RouterMethodFactory', () => {
     expect(factory.get(target, RequestMethod.PATCH)).to.equal(target.patch);
     expect(factory.get(target, RequestMethod.OPTIONS)).to.equal(target.options);
     expect(factory.get(target, RequestMethod.HEAD)).to.equal(target.head);
-    expect(factory.get(target, RequestMethod.PROPFIND)).to.equal(
-      target.propfind,
-    );
-    expect(factory.get(target, RequestMethod.PROPPATCH)).to.equal(
-      target.proppatch,
-    );
-    expect(factory.get(target, RequestMethod.MKCOL)).to.equal(target.mkcol);
-    expect(factory.get(target, RequestMethod.COPY)).to.equal(target.copy);
-    expect(factory.get(target, RequestMethod.MOVE)).to.equal(target.move);
-    expect(factory.get(target, RequestMethod.LOCK)).to.equal(target.lock);
-    expect(factory.get(target, RequestMethod.UNLOCK)).to.equal(target.unlock);
     expect(factory.get(target, -1 as any)).to.equal(target.use);
   });
 });
diff --git a/packages/core/test/injector/compiler.spec.ts b/packages/core/test/injector/compiler.spec.ts
index c4cb35b20..2929c49e1 100644
--- a/packages/core/test/injector/compiler.spec.ts
+++ b/packages/core/test/injector/compiler.spec.ts
@@ -1,28 +1,30 @@
 import { expect } from 'chai';
 import { ModuleCompiler } from '../../injector/compiler';
+import { ByReferenceModuleOpaqueKeyFactory } from '../../injector/opaque-key-factory/by-reference-module-opaque-key-factory';
 
 describe('ModuleCompiler', () => {
   let compiler: ModuleCompiler;
   beforeEach(() => {
-    compiler = new ModuleCompiler();
+    compiler = new ModuleCompiler(new ByReferenceModuleOpaqueKeyFactory());
   });
 
   describe('extractMetadata', () => {
     describe('when module is a dynamic module', () => {
-      it('should return object with "type" and "dynamicMetadata" property', async () => {
+      it('should return object with "type" and "dynamicMetadata" property', () => {
         const obj = { module: 'test', providers: [] };
         const { module, ...dynamicMetadata } = obj;
-        expect(await compiler.extractMetadata(obj as any)).to.be.deep.equal({
+        expect(compiler.extractMetadata(obj as any)).to.be.deep.equal({
           type: module,
           dynamicMetadata,
         });
       });
     });
     describe('when module is a not dynamic module', () => {
-      it('should return object with "type" property', async () => {
+      it('should return object with "type" property', () => {
         const type = 'test';
-        expect(await compiler.extractMetadata(type as any)).to.be.deep.equal({
+        expect(compiler.extractMetadata(type as any)).to.be.deep.equal({
           type,
+          dynamicMetadata: undefined,
         });
       });
     });
diff --git a/packages/core/test/injector/container.spec.ts b/packages/core/test/injector/container.spec.ts
index e9916a4aa..05bd47821 100644
--- a/packages/core/test/injector/container.spec.ts
+++ b/packages/core/test/injector/container.spec.ts
@@ -9,6 +9,7 @@ import { NoopHttpAdapter } from '../utils/noop-adapter.spec';
 
 describe('NestContainer', () => {
   let container: NestContainer;
+  let untypedContainer: any;
 
   @Module({})
   class TestModule {}
@@ -19,6 +20,7 @@ describe('NestContainer', () => {
 
   beforeEach(() => {
     container = new NestContainer();
+    untypedContainer = container as any;
   });
 
   it('should "addProvider" throw "UnknownModuleException" when module is not stored in collection', () => {
@@ -53,7 +55,7 @@ describe('NestContainer', () => {
 
   describe('clear', () => {
     it('should call `clear` on modules collection', () => {
-      const clearSpy = sinon.spy((container as any).modules, 'clear');
+      const clearSpy = sinon.spy(untypedContainer.modules, 'clear');
       container.clear();
       expect(clearSpy.called).to.be.true;
     });
@@ -63,7 +65,7 @@ describe('NestContainer', () => {
     it('should not add module if already exists in collection', async () => {
       const modules = new Map();
       const setSpy = sinon.spy(modules, 'set');
-      (container as any).modules = modules;
+      untypedContainer.modules = modules;
 
       await container.addModule(TestModule as any, []);
       await container.addModule(TestModule as any, []);
@@ -89,7 +91,7 @@ describe('NestContainer', () => {
 
       const modules = new Map();
       const setSpy = sinon.spy(modules, 'set');
-      (container as any).modules = modules;
+      untypedContainer.modules = modules;
 
       await container.addModule(TestModule as any, []);
       await container.replaceModule(
@@ -174,7 +176,7 @@ describe('NestContainer', () => {
     beforeEach(() => {
       token = 'token';
       collection = new Map();
-      (container as any).dynamicModulesMetadata = collection;
+      untypedContainer.dynamicModulesMetadata = collection;
     });
     describe('when dynamic metadata exists', () => {
       it('should add to the dynamic metadata collection', () => {
@@ -215,7 +217,7 @@ describe('NestContainer', () => {
   describe('get applicationConfig', () => {
     it('should return ApplicationConfig instance', () => {
       expect(container.applicationConfig).to.be.eql(
-        (container as any)._applicationConfig,
+        untypedContainer._applicationConfig,
       );
     });
   });
@@ -225,7 +227,7 @@ describe('NestContainer', () => {
       const httpAdapter = new NoopHttpAdapter({});
       container.setHttpAdapter(httpAdapter);
 
-      const internalStorage = (container as any).internalProvidersStorage;
+      const internalStorage = untypedContainer.internalProvidersStorage;
       expect(internalStorage.httpAdapter).to.be.eql(httpAdapter);
     });
   });
@@ -244,7 +246,7 @@ describe('NestContainer', () => {
     it('should register core module ref', () => {
       const ref = {} as any;
       container.registerCoreModuleRef(ref);
-      expect((container as any).internalCoreModule).to.be.eql(ref);
+      expect(untypedContainer.internalCoreModule).to.be.eql(ref);
     });
   });
 });
diff --git a/packages/core/test/injector/module.spec.ts b/packages/core/test/injector/module.spec.ts
index 26202cf45..53d3acc9f 100644
--- a/packages/core/test/injector/module.spec.ts
+++ b/packages/core/test/injector/module.spec.ts
@@ -11,7 +11,8 @@ import { InstanceWrapper } from '../../injector/instance-wrapper';
 import { Module } from '../../injector/module';
 
 describe('Module', () => {
-  let module: Module;
+  let moduleRef: Module;
+  let untypedModuleRef: any;
   let container: NestContainer;
 
   @ModuleDecorator({})
@@ -22,23 +23,24 @@ describe('Module', () => {
 
   beforeEach(() => {
     container = new NestContainer();
-    module = new Module(TestModule, container);
+    moduleRef = new Module(TestModule, container);
+    untypedModuleRef = moduleRef as any;
   });
 
   it('should add controller', () => {
     const collection = new Map();
     const setSpy = sinon.spy(collection, 'set');
-    (module as any)._controllers = collection;
+    untypedModuleRef._controllers = collection;
 
     @Controller({ scope: Scope.REQUEST, durable: true })
     class Test {}
 
-    module.addController(Test);
+    moduleRef.addController(Test);
     expect(
       setSpy.calledWith(
         Test,
         new InstanceWrapper({
-          host: module,
+          host: moduleRef,
           token: Test,
           name: 'Test',
           scope: Scope.REQUEST,
@@ -54,14 +56,14 @@ describe('Module', () => {
   it('should add injectable', () => {
     const collection = new Map();
     const setSpy = sinon.spy(collection, 'set');
-    (module as any)._injectables = collection;
+    untypedModuleRef._injectables = collection;
 
-    module.addInjectable(TestProvider, 'interceptor', TestModule);
+    moduleRef.addInjectable(TestProvider, 'interceptor', TestModule);
     expect(
       setSpy.calledWith(
         TestProvider,
         new InstanceWrapper({
-          host: module,
+          host: moduleRef,
           name: 'TestProvider',
           token: TestProvider,
           scope: undefined,
@@ -77,9 +79,9 @@ describe('Module', () => {
 
   describe('when injectable is custom provided', () => {
     it('should call `addCustomProvider`', () => {
-      const addCustomProviderSpy = sinon.spy(module, 'addCustomProvider');
+      const addCustomProviderSpy = sinon.spy(moduleRef, 'addCustomProvider');
 
-      module.addInjectable({ provide: 'test' } as any, 'guard');
+      moduleRef.addInjectable({ provide: 'test' } as any, 'guard');
       expect(addCustomProviderSpy.called).to.be.true;
     });
   });
@@ -87,14 +89,14 @@ describe('Module', () => {
   it('should add provider', () => {
     const collection = new Map();
     const setSpy = sinon.spy(collection, 'set');
-    (module as any)._providers = collection;
+    untypedModuleRef._providers = collection;
 
-    module.addProvider(TestProvider);
+    moduleRef.addProvider(TestProvider);
     expect(
       setSpy.calledWith(
         TestProvider,
         new InstanceWrapper({
-          host: module,
+          host: moduleRef,
           name: 'TestProvider',
           token: TestProvider,
           scope: undefined,
@@ -109,81 +111,81 @@ describe('Module', () => {
 
   it('should call "addCustomProvider" when "provide" property exists', () => {
     const addCustomProvider = sinon.spy();
-    module.addCustomProvider = addCustomProvider;
+    moduleRef.addCustomProvider = addCustomProvider;
 
     const provider = { provide: 'test', useValue: 'test' };
 
-    module.addProvider(provider as any);
+    moduleRef.addProvider(provider as any);
     expect((addCustomProvider as sinon.SinonSpy).called).to.be.true;
   });
 
   it('should call "addCustomClass" when "useClass" property exists', () => {
     const addCustomClass = sinon.spy();
-    module.addCustomClass = addCustomClass;
+    moduleRef.addCustomClass = addCustomClass;
 
     const provider = { provide: 'test', useClass: () => null };
 
-    module.addCustomProvider(provider as any, new Map());
+    moduleRef.addCustomProvider(provider as any, new Map());
     expect((addCustomClass as sinon.SinonSpy).called).to.be.true;
   });
 
   it('should call "addCustomValue" when "useValue" property exists', () => {
     const addCustomValue = sinon.spy();
-    module.addCustomValue = addCustomValue;
+    moduleRef.addCustomValue = addCustomValue;
 
     const provider = { provide: 'test', useValue: () => null };
 
-    module.addCustomProvider(provider as any, new Map());
+    moduleRef.addCustomProvider(provider as any, new Map());
     expect((addCustomValue as sinon.SinonSpy).called).to.be.true;
   });
 
   it('should call "addCustomValue" when "useValue" property exists but its value is `undefined`', () => {
     const addCustomValue = sinon.spy();
-    module.addCustomValue = addCustomValue;
+    moduleRef.addCustomValue = addCustomValue;
 
     const provider = { provide: 'test', useValue: undefined };
 
-    module.addCustomProvider(provider as any, new Map());
+    moduleRef.addCustomProvider(provider as any, new Map());
     expect((addCustomValue as sinon.SinonSpy).called).to.be.true;
   });
 
   it('should call "addCustomFactory" when "useFactory" property exists', () => {
     const addCustomFactory = sinon.spy();
-    module.addCustomFactory = addCustomFactory;
+    moduleRef.addCustomFactory = addCustomFactory;
 
     const provider = { provide: 'test', useFactory: () => null };
 
-    module.addCustomProvider(provider as any, new Map());
+    moduleRef.addCustomProvider(provider as any, new Map());
     expect((addCustomFactory as sinon.SinonSpy).called).to.be.true;
   });
 
   it('should call "addCustomUseExisting" when "useExisting" property exists', () => {
     const addCustomUseExisting = sinon.spy();
-    module.addCustomUseExisting = addCustomUseExisting;
+    moduleRef.addCustomUseExisting = addCustomUseExisting;
 
     const provider = { provide: 'test', useExisting: () => null };
 
-    module.addCustomUseExisting(provider as any, new Map());
+    moduleRef.addCustomUseExisting(provider as any, new Map());
     expect((addCustomUseExisting as sinon.SinonSpy).called).to.be.true;
   });
 
   describe('addCustomClass', () => {
     const type = { name: 'TypeTest' };
     const provider = { provide: type, useClass: type, durable: true };
-    let setSpy;
+    let setSpy: sinon.SinonSpy;
 
     beforeEach(() => {
       const collection = new Map();
       setSpy = sinon.spy(collection, 'set');
-      (module as any)._providers = collection;
+      untypedModuleRef._providers = collection;
     });
     it('should store provider', () => {
-      module.addCustomClass(provider as any, (module as any)._providers);
+      moduleRef.addCustomClass(provider as any, untypedModuleRef._providers);
       expect(
         setSpy.calledWith(
           provider.provide,
           new InstanceWrapper({
-            host: module,
+            host: moduleRef,
             token: type as any,
             name: provider.provide.name,
             scope: undefined,
@@ -199,23 +201,23 @@ describe('Module', () => {
   });
 
   describe('addCustomValue', () => {
-    let setSpy;
+    let setSpy: sinon.SinonSpy;
     const value = () => ({});
     const provider = { provide: value, useValue: value };
 
     beforeEach(() => {
       const collection = new Map();
       setSpy = sinon.spy(collection, 'set');
-      (module as any)._providers = collection;
+      untypedModuleRef._providers = collection;
     });
 
     it('should store provider', () => {
-      module.addCustomValue(provider as any, (module as any)._providers);
+      moduleRef.addCustomValue(provider as any, untypedModuleRef._providers);
       expect(
         setSpy.calledWith(
           provider.provide,
           new InstanceWrapper({
-            host: module,
+            host: moduleRef,
             token: provider.provide,
             name: provider.provide.name,
             scope: Scope.DEFAULT,
@@ -235,20 +237,20 @@ describe('Module', () => {
     const inject = [1, 2, 3];
     const provider = { provide: type, useFactory: type, inject, durable: true };
 
-    let setSpy;
+    let setSpy: sinon.SinonSpy;
     beforeEach(() => {
       const collection = new Map();
       setSpy = sinon.spy(collection, 'set');
-      (module as any)._providers = collection;
+      untypedModuleRef._providers = collection;
     });
     it('should store provider', () => {
-      module.addCustomFactory(provider as any, (module as any)._providers);
+      moduleRef.addCustomFactory(provider as any, untypedModuleRef._providers);
 
       expect(
         setSpy.calledWith(
           provider.provide,
           new InstanceWrapper({
-            host: module,
+            host: moduleRef,
             token: provider.provide as any,
             name: provider.provide.name,
             scope: undefined,
@@ -268,15 +270,18 @@ describe('Module', () => {
     const type = { name: 'TypeTest' };
     const provider = { provide: type, useExisting: type };
 
-    let setSpy;
+    let setSpy: sinon.SinonSpy;
     beforeEach(() => {
       const collection = new Map();
       setSpy = sinon.spy(collection, 'set');
-      (module as any)._providers = collection;
+      untypedModuleRef._providers = collection;
     });
     it('should store provider', () => {
-      module.addCustomUseExisting(provider as any, (module as any)._providers);
-      const factoryFn = (module as any)._providers.get(
+      moduleRef.addCustomUseExisting(
+        provider as any,
+        untypedModuleRef._providers,
+      );
+      const factoryFn = untypedModuleRef._providers.get(
         provider.provide,
       ).metatype;
 
@@ -285,7 +290,7 @@ describe('Module', () => {
         setSpy.calledWith(
           token,
           new InstanceWrapper({
-            host: module,
+            host: moduleRef,
             token,
             name: provider.provide.name,
             metatype: factoryFn,
@@ -304,41 +309,41 @@ describe('Module', () => {
   describe('when get instance', () => {
     describe('when metatype does not exists in providers collection', () => {
       beforeEach(() => {
-        sinon.stub((module as any)._providers, 'has').returns(false);
+        sinon.stub(untypedModuleRef._providers, 'has').returns(false);
       });
       it('should throw RuntimeException', () => {
-        expect(() => module.instance).to.throws(RuntimeException);
+        expect(() => moduleRef.instance).to.throws(RuntimeException);
       });
     });
     describe('when metatype exists in providers collection', () => {
       it('should return null', () => {
-        expect(module.instance).to.be.eql(null);
+        expect(moduleRef.instance).to.be.eql(null);
       });
     });
   });
 
   describe('when exported provider is custom provided', () => {
     beforeEach(() => {
-      sinon.stub(module, 'validateExportedProvider').callsFake(o => o);
+      sinon.stub(moduleRef, 'validateExportedProvider').callsFake(o => o);
     });
     it('should call `addCustomExportedProvider`', () => {
       const addCustomExportedProviderSpy = sinon.spy(
-        module,
+        moduleRef,
         'addCustomExportedProvider',
       );
 
-      module.addExportedProvider({ provide: 'test' } as any);
+      moduleRef.addExportedProvider({ provide: 'test' } as any);
       expect(addCustomExportedProviderSpy.called).to.be.true;
     });
     it('should support symbols', () => {
       const addCustomExportedProviderSpy = sinon.spy(
-        module,
+        moduleRef,
         'addCustomExportedProvider',
       );
       const symb = Symbol('test');
-      module.addExportedProvider({ provide: symb } as any);
+      moduleRef.addExportedProvider({ provide: symb } as any);
       expect(addCustomExportedProviderSpy.called).to.be.true;
-      expect((module as any)._exports.has(symb)).to.be.true;
+      expect(untypedModuleRef._exports.has(symb)).to.be.true;
     });
   });
 
@@ -348,10 +353,10 @@ describe('Module', () => {
         const wrapper = {
           mergeWith: sinon.spy(),
         };
-        sinon.stub(module, 'hasProvider').callsFake(() => true);
-        sinon.stub(module.providers, 'get').callsFake(() => wrapper as any);
+        sinon.stub(moduleRef, 'hasProvider').callsFake(() => true);
+        sinon.stub(moduleRef.providers, 'get').callsFake(() => wrapper as any);
 
-        module.replace(null, { isProvider: true });
+        moduleRef.replace(null, { isProvider: true });
         expect(wrapper.mergeWith.called).to.be.true;
       });
     });
@@ -361,10 +366,12 @@ describe('Module', () => {
           mergeWith: sinon.spy(),
           isProvider: true,
         };
-        sinon.stub(module, 'hasInjectable').callsFake(() => true);
-        sinon.stub(module.injectables, 'get').callsFake(() => wrapper as any);
+        sinon.stub(moduleRef, 'hasInjectable').callsFake(() => true);
+        sinon
+          .stub(moduleRef.injectables, 'get')
+          .callsFake(() => wrapper as any);
 
-        module.replace(null, {});
+        moduleRef.replace(null, {});
         expect(wrapper.mergeWith.called).to.be.true;
       });
     });
@@ -373,61 +380,63 @@ describe('Module', () => {
   describe('imports', () => {
     it('should return relatedModules', () => {
       const test = ['test'];
-      (module as any)._imports = test;
+      untypedModuleRef._imports = test;
 
-      expect(module.imports).to.be.eql(test);
+      expect(moduleRef.imports).to.be.eql(test);
     });
   });
 
   describe('injectables', () => {
     it('should return injectables', () => {
       const test = ['test'];
-      (module as any)._injectables = test;
-      expect(module.injectables).to.be.eql(test);
+      untypedModuleRef._injectables = test;
+      expect(moduleRef.injectables).to.be.eql(test);
     });
   });
 
   describe('controllers', () => {
     it('should return controllers', () => {
       const test = ['test'];
-      (module as any)._controllers = test;
+      untypedModuleRef._controllers = test;
 
-      expect(module.controllers).to.be.eql(test);
+      expect(moduleRef.controllers).to.be.eql(test);
     });
   });
 
   describe('exports', () => {
     it('should return exports', () => {
       const test = ['test'];
-      (module as any)._exports = test;
+      untypedModuleRef._exports = test;
 
-      expect(module.exports).to.be.eql(test);
+      expect(moduleRef.exports).to.be.eql(test);
     });
   });
 
   describe('providers', () => {
     it('should return providers', () => {
       const test = ['test'];
-      (module as any)._providers = test;
+      untypedModuleRef._providers = test;
 
-      expect(module.providers).to.be.eql(test);
+      expect(moduleRef.providers).to.be.eql(test);
     });
   });
 
   describe('createModuleReferenceType', () => {
-    let moduleRef: any;
+    let customModuleRef: any;
 
     beforeEach(() => {
-      const Class = module.createModuleReferenceType();
-      moduleRef = new Class();
+      const Class = moduleRef.createModuleReferenceType();
+      customModuleRef = new Class();
     });
 
     it('should return metatype with "get" method', () => {
-      expect(!!moduleRef.get).to.be.true;
+      expect(!!customModuleRef.get).to.be.true;
     });
     describe('get', () => {
       it('should throw exception if not exists', () => {
-        expect(() => moduleRef.get('fail')).to.throws(UnknownElementException);
+        expect(() => customModuleRef.get('fail')).to.throws(
+          UnknownElementException,
+        );
       });
     });
   });
@@ -436,22 +445,22 @@ describe('Module', () => {
 
     describe('when unit exists in provider collection', () => {
       it('should behave as identity', () => {
-        (module as any)._providers = new Map([[token, true]]);
-        expect(module.validateExportedProvider(token)).to.be.eql(token);
+        untypedModuleRef._providers = new Map([[token, true]]);
+        expect(moduleRef.validateExportedProvider(token)).to.be.eql(token);
       });
     });
     describe('when unit exists in related modules collection', () => {
       it('should behave as identity', () => {
         class Random {}
-        (module as any)._imports = new Set([
+        untypedModuleRef._imports = new Set([
           new Module(Random, new NestContainer()),
         ]);
-        expect(module.validateExportedProvider(Random)).to.be.eql(Random);
+        expect(moduleRef.validateExportedProvider(Random)).to.be.eql(Random);
       });
     });
     describe('when unit does not exist in both provider and related modules collections', () => {
       it('should throw UnknownExportException', () => {
-        expect(() => module.validateExportedProvider(token)).to.throws(
+        expect(() => moduleRef.validateExportedProvider(token)).to.throws(
           UnknownExportException,
         );
       });
@@ -462,13 +471,13 @@ describe('Module', () => {
     describe('when module has provider', () => {
       it('should return true', () => {
         const token = 'test';
-        module.providers.set(token, new InstanceWrapper());
-        expect(module.hasProvider(token)).to.be.true;
+        moduleRef.providers.set(token, new InstanceWrapper());
+        expect(moduleRef.hasProvider(token)).to.be.true;
       });
     });
     describe('otherwise', () => {
       it('should return false', () => {
-        expect(module.hasProvider('_')).to.be.false;
+        expect(moduleRef.hasProvider('_')).to.be.false;
       });
     });
   });
@@ -477,33 +486,33 @@ describe('Module', () => {
     describe('when module has injectable', () => {
       it('should return true', () => {
         const token = 'test';
-        module.injectables.set(token, new InstanceWrapper());
-        expect(module.hasInjectable(token)).to.be.true;
+        moduleRef.injectables.set(token, new InstanceWrapper());
+        expect(moduleRef.hasInjectable(token)).to.be.true;
       });
     });
     describe('otherwise', () => {
       it('should return false', () => {
-        expect(module.hasInjectable('_')).to.be.false;
+        expect(moduleRef.hasInjectable('_')).to.be.false;
       });
     });
   });
 
   describe('getter "id"', () => {
     it('should return module id', () => {
-      expect(module.id).to.be.equal(module['_id']);
+      expect(moduleRef.id).to.be.equal(moduleRef['_id']);
     });
   });
 
   describe('getProviderByKey', () => {
     describe('when does not exist', () => {
       it('should return undefined', () => {
-        expect(module.getProviderByKey('test')).to.be.undefined;
+        expect(moduleRef.getProviderByKey('test')).to.be.undefined;
       });
     });
     describe('otherwise', () => {
       it('should return instance wrapper', () => {
-        module.addProvider(TestProvider);
-        expect(module.getProviderByKey(TestProvider)).to.not.be.undefined;
+        moduleRef.addProvider(TestProvider);
+        expect(moduleRef.getProviderByKey(TestProvider)).to.not.be.undefined;
       });
     });
   });
diff --git a/packages/core/test/injector/opaque-key-factory/by-reference-module-opaque-key-factory.spec.ts b/packages/core/test/injector/opaque-key-factory/by-reference-module-opaque-key-factory.spec.ts
new file mode 100644
index 000000000..2d9db42eb
--- /dev/null
+++ b/packages/core/test/injector/opaque-key-factory/by-reference-module-opaque-key-factory.spec.ts
@@ -0,0 +1,111 @@
+import { expect } from 'chai';
+import * as sinon from 'sinon';
+import { ByReferenceModuleOpaqueKeyFactory } from '../../../injector/opaque-key-factory/by-reference-module-opaque-key-factory';
+
+describe('ByReferenceModuleOpaqueKeyFactory', () => {
+  const moduleId = 'constId';
+  let factory: ByReferenceModuleOpaqueKeyFactory;
+
+  describe('when generating algorithm is random', () => {
+    beforeEach(() => {
+      factory = new ByReferenceModuleOpaqueKeyFactory();
+      sinon.stub(factory as any, 'generateRandomString').returns(moduleId);
+    });
+
+    describe('createForStatic', () => {
+      class Module {}
+
+      it('should return expected token', () => {
+        const type = Module;
+        const token1 = factory.createForStatic(type);
+        const token2 = factory.createForStatic(type);
+        expect(token1).to.be.deep.eq(token2);
+      });
+    });
+
+    describe('createForDynamic', () => {
+      class Module {}
+
+      it('should include dynamic metadata', () => {
+        const dynamicModule = {
+          module: Module,
+          providers: [
+            {
+              provide: 'test',
+              useValue: 'test',
+            },
+          ],
+        };
+        const token1 = factory.createForDynamic(
+          dynamicModule.module,
+          {
+            providers: dynamicModule.providers,
+          },
+          dynamicModule,
+        );
+        const token2 = factory.createForDynamic(
+          dynamicModule.module,
+          {
+            providers: dynamicModule.providers,
+          },
+          dynamicModule,
+        );
+
+        expect(token1).to.be.deep.eq(token2);
+      });
+    });
+  });
+  describe('when generating algorithm is shallow', () => {
+    beforeEach(() => {
+      factory = new ByReferenceModuleOpaqueKeyFactory({
+        keyGenerationStrategy: 'shallow',
+      });
+      sinon.stub(factory as any, 'generateRandomString').returns(moduleId);
+    });
+
+    describe('createForStatic', () => {
+      class Module {}
+
+      it('should return expected token', () => {
+        const type = Module;
+        const token1 = factory.createForStatic(type);
+        const token2 = factory.createForStatic(type);
+
+        expect(token1).to.be.deep.eq(token2);
+      });
+    });
+
+    describe('createForDynamic', () => {
+      class Module {}
+
+      it('should include dynamic metadata', () => {
+        const dynamicModule = {
+          module: Module,
+          providers: [
+            {
+              provide: 'test',
+              useValue: 'test',
+            },
+          ],
+        };
+
+        const token1 = factory.createForDynamic(
+          dynamicModule.module,
+          {
+            providers: dynamicModule.providers,
+          },
+          dynamicModule,
+        );
+        const token2 = factory.createForDynamic(
+          dynamicModule.module,
+          {
+            providers: dynamicModule.providers,
+          },
+          dynamicModule,
+        );
+
+        expect(token1).to.be.deep.eq(token2);
+      });
+    });
+  });
+});
diff --git a/packages/core/test/injector/module-token-factory.spec.ts b/packages/core/test/injector/opaque-key-factory/deep-hashed-module-opaque-key-factory.spec.ts
similarity index 81%
rename from packages/core/test/injector/module-token-factory.spec.ts
rename to packages/core/test/injector/opaque-key-factory/deep-hashed-module-opaque-key-factory.spec.ts
index 22bda3e37..28d05a6cb 100644
--- a/packages/core/test/injector/module-token-factory.spec.ts
+++ b/packages/core/test/injector/opaque-key-factory/deep-hashed-module-opaque-key-factory.spec.ts
@@ -1,41 +1,48 @@
 import { expect } from 'chai';
 import * as sinon from 'sinon';
-import { ModuleTokenFactory } from '../../injector/module-token-factory';
+import { DeepHashedModuleOpaqueKeyFactory } from '../../../injector/opaque-key-factory/deep-hashed-module-opaque-key-factory';
 
-describe('ModuleTokenFactory', () => {
+describe('DeepHashedModuleOpaqueKeyFactory', () => {
   const moduleId = 'constId';
-  let factory: ModuleTokenFactory;
+  let factory: DeepHashedModuleOpaqueKeyFactory;
 
   beforeEach(() => {
-    factory = new ModuleTokenFactory();
+    factory = new DeepHashedModuleOpaqueKeyFactory();
     sinon.stub(factory, 'getModuleId').returns(moduleId);
   });
-  describe('create', () => {
+  describe('createForStatic', () => {
     class Module {}
+
     it('should return expected token', () => {
       const type = Module;
-      const token1 = factory.create(type, undefined);
-      const token2 = factory.create(type, undefined);
+      const token1 = factory.createForStatic(type);
+      const token2 = factory.createForStatic(type);
       expect(token1).to.be.deep.eq(token2);
     });
+  });
+  describe('createForDynamic', () => {
+    class Module {}
+
     it('should include dynamic metadata', () => {
       const type = Module;
-      const token1 = factory.create(type, {
+      const token1 = factory.createForDynamic(type, {
         providers: [{}],
       } as any);
-      const token2 = factory.create(type, {
+      const token2 = factory.createForDynamic(type, {
         providers: [{}],
       } as any);
 
       expect(token1).to.be.deep.eq(token2);
     });
   });
+
   describe('getModuleName', () => {
     it('should map module metatype to name', () => {
       const metatype = () => {};
       expect(factory.getModuleName(metatype as any)).to.be.eql(metatype.name);
     });
   });
+
   describe('getStringifiedOpaqueToken', () => {
     describe('when metadata exists', () => {
       it('should return hash', () => {
@@ -80,6 +87,7 @@ describe('ModuleTokenFactory', () => {
         );
       });
     });
+
     describe('when metadata does not exist', () => {
       it('should return empty string', () => {
         expect(factory.getStringifiedOpaqueToken(undefined)).to.be.eql('');
diff --git a/packages/core/test/router/route-params-factory.spec.ts b/packages/core/test/router/route-params-factory.spec.ts
index be4075abf..3768dc9ab 100644
--- a/packages/core/test/router/route-params-factory.spec.ts
+++ b/packages/core/test/router/route-params-factory.spec.ts
@@ -4,9 +4,13 @@ import { RouteParamsFactory } from '../../router/route-params-factory';
 
 describe('RouteParamsFactory', () => {
   let factory: RouteParamsFactory;
+  let untypedFactory: any;
+
   beforeEach(() => {
     factory = new RouteParamsFactory();
+    untypedFactory = factory as any;
   });
+
   describe('exchangeKeyForValue', () => {
     const res = {};
     const next = () => ({});
@@ -37,14 +41,14 @@ describe('RouteParamsFactory', () => {
       describe(`RouteParamtypes.NEXT`, () => {
         it('should return next object', () => {
           expect(
-            (factory as any).exchangeKeyForValue(RouteParamtypes.NEXT, ...args),
+            untypedFactory.exchangeKeyForValue(RouteParamtypes.NEXT, ...args),
           ).to.be.eql(next);
         });
       });
       describe(`RouteParamtypes.RESPONSE`, () => {
         it('should return response object', () => {
           expect(
-            (factory as any).exchangeKeyForValue(
+            untypedFactory.exchangeKeyForValue(
               RouteParamtypes.RESPONSE,
               ...args,
             ),
@@ -54,7 +58,7 @@ describe('RouteParamsFactory', () => {
       describe(`RouteParamtypes.REQUEST`, () => {
         it('should return request object', () => {
           expect(
-            (factory as any).exchangeKeyForValue(
+            untypedFactory.exchangeKeyForValue(
               RouteParamtypes.REQUEST,
               ...args,
             ),
@@ -64,14 +68,14 @@ describe('RouteParamsFactory', () => {
       describe(`RouteParamtypes.BODY`, () => {
         it('should return body object', () => {
           expect(
-            (factory as any).exchangeKeyForValue(RouteParamtypes.BODY, ...args),
+            untypedFactory.exchangeKeyForValue(RouteParamtypes.BODY, ...args),
           ).to.be.eql(req.body);
         });
       });
       describe(`RouteParamtypes.RAW_BODY`, () => {
         it('should return rawBody buffer', () => {
           expect(
-            (factory as any).exchangeKeyForValue(
+            untypedFactory.exchangeKeyForValue(
               RouteParamtypes.RAW_BODY,
               ...args,
             ),
@@ -81,7 +85,7 @@ describe('RouteParamsFactory', () => {
       describe(`RouteParamtypes.HEADERS`, () => {
         it('should return headers object', () => {
           expect(
-            (factory as any).exchangeKeyForValue(
+            untypedFactory.exchangeKeyForValue(
               RouteParamtypes.HEADERS,
               ...args,
             ),
@@ -91,14 +95,14 @@ describe('RouteParamsFactory', () => {
       describe(`RouteParamtypes.IP`, () => {
         it('should return ip property', () => {
           expect(
-            (factory as any).exchangeKeyForValue(RouteParamtypes.IP, ...args),
+            untypedFactory.exchangeKeyForValue(RouteParamtypes.IP, ...args),
           ).to.be.equal(req.ip);
         });
       });
       describe(`RouteParamtypes.SESSION`, () => {
         it('should return session object', () => {
           expect(
-            (factory as any).exchangeKeyForValue(
+            untypedFactory.exchangeKeyForValue(
               RouteParamtypes.SESSION,
               ...args,
             ),
@@ -108,50 +112,41 @@ describe('RouteParamsFactory', () => {
       describe(`RouteParamtypes.QUERY`, () => {
         it('should return query object', () => {
           expect(
-            (factory as any).exchangeKeyForValue(
-              RouteParamtypes.QUERY,
-              ...args,
-            ),
+            untypedFactory.exchangeKeyForValue(RouteParamtypes.QUERY, ...args),
           ).to.be.eql(req.query);
         });
       });
       describe(`RouteParamtypes.PARAM`, () => {
         it('should return params object', () => {
           expect(
-            (factory as any).exchangeKeyForValue(
-              RouteParamtypes.PARAM,
-              ...args,
-            ),
+            untypedFactory.exchangeKeyForValue(RouteParamtypes.PARAM, ...args),
           ).to.be.eql(req.params);
         });
       });
       describe(`RouteParamtypes.HOST`, () => {
         it('should return hosts object', () => {
           expect(
-            (factory as any).exchangeKeyForValue(RouteParamtypes.HOST, ...args),
+            untypedFactory.exchangeKeyForValue(RouteParamtypes.HOST, ...args),
           ).to.be.eql(req.hosts);
         });
       });
       describe(`RouteParamtypes.FILE`, () => {
         it('should return file object', () => {
           expect(
-            (factory as any).exchangeKeyForValue(RouteParamtypes.FILE, ...args),
+            untypedFactory.exchangeKeyForValue(RouteParamtypes.FILE, ...args),
           ).to.be.eql(req.file);
         });
       });
       describe(`RouteParamtypes.FILES`, () => {
         it('should return files object', () => {
           expect(
-            (factory as any).exchangeKeyForValue(
-              RouteParamtypes.FILES,
-              ...args,
-            ),
+            untypedFactory.exchangeKeyForValue(RouteParamtypes.FILES, ...args),
           ).to.be.eql(req.files);
         });
       });
       describe('not available', () => {
         it('should return null', () => {
-          expect((factory as any).exchangeKeyForValue(-1, ...args)).to.be.eql(
+          expect(untypedFactory.exchangeKeyForValue(-1, ...args)).to.be.eql(
             null,
           );
         });
diff --git a/packages/core/test/router/routes-resolver.spec.ts b/packages/core/test/router/routes-resolver.spec.ts
index 9819f4aae..a4a1cc866 100644
--- a/packages/core/test/router/routes-resolver.spec.ts
+++ b/packages/core/test/router/routes-resolver.spec.ts
@@ -52,6 +52,7 @@ describe('RoutesResolver', () => {
 
   let router: any;
   let routesResolver: RoutesResolver;
+  let untypedRoutesResolver: any;
   let container: NestContainer;
   let modules: Map<string, any>;
   let applicationRef: any;
@@ -82,6 +83,7 @@ describe('RoutesResolver', () => {
       new Injector(),
       new GraphInspector(container),
     );
+    untypedRoutesResolver = routesResolver as any;
   });
 
   describe('registerRouters', () => {
@@ -95,14 +97,14 @@ describe('RoutesResolver', () => {
 
       const appInstance = new NoopHttpAdapter(router);
       const exploreSpy = sinon.spy(
-        (routesResolver as any).routerExplorer,
+        untypedRoutesResolver.routerExplorer,
         'explore',
       );
       const moduleName = '';
       modules.set(moduleName, {});
 
       sinon
-        .stub((routesResolver as any).routerExplorer, 'extractRouterPath')
+        .stub(untypedRoutesResolver.routerExplorer, 'extractRouterPath')
         .callsFake(() => ['']);
       routesResolver.registerRouters(routes, moduleName, '', '', appInstance);
 
@@ -137,14 +139,14 @@ describe('RoutesResolver', () => {
 
       const appInstance = new NoopHttpAdapter(router);
       const exploreSpy = sinon.spy(
-        (routesResolver as any).routerExplorer,
+        untypedRoutesResolver.routerExplorer,
         'explore',
       );
       const moduleName = '';
       modules.set(moduleName, {});
 
       sinon
-        .stub((routesResolver as any).routerExplorer, 'extractRouterPath')
+        .stub(untypedRoutesResolver.routerExplorer, 'extractRouterPath')
         .callsFake(() => ['']);
       routesResolver.registerRouters(routes, moduleName, '', '', appInstance);
 
@@ -181,6 +183,7 @@ describe('RoutesResolver', () => {
         new Injector(),
         new GraphInspector(container),
       );
+      untypedRoutesResolver = routesResolver as any;
 
       const routes = new Map();
       const routeWrapper = new InstanceWrapper({
@@ -191,14 +194,14 @@ describe('RoutesResolver', () => {
 
       const appInstance = new NoopHttpAdapter(router);
       const exploreSpy = sinon.spy(
-        (routesResolver as any).routerExplorer,
+        untypedRoutesResolver.routerExplorer,
         'explore',
       );
       const moduleName = '';
       modules.set(moduleName, {});
 
       sinon
-        .stub((routesResolver as any).routerExplorer, 'extractRouterPath')
+        .stub(untypedRoutesResolver.routerExplorer, 'extractRouterPath')
         .callsFake(() => ['']);
       routesResolver.registerRouters(routes, moduleName, '', '', appInstance);
 
diff --git a/packages/core/test/scanner.spec.ts b/packages/core/test/scanner.spec.ts
index c7cae333b..94f137aa3 100644
--- a/packages/core/test/scanner.spec.ts
+++ b/packages/core/test/scanner.spec.ts
@@ -56,6 +56,7 @@ describe('DependenciesScanner', () => {
   class InvalidModule {}
 
   let scanner: DependenciesScanner;
+  let untypedScanner: any;
   let mockContainer: sinon.SinonMock;
   let container: NestContainer;
   let graphInspector: GraphInspector;
@@ -71,6 +72,7 @@ describe('DependenciesScanner', () => {
       graphInspector,
       new ApplicationConfig(),
     );
+    untypedScanner = scanner as any;
     sinon.stub(scanner, 'registerCoreModule').callsFake(async () => {});
   });
 
@@ -86,7 +88,7 @@ describe('DependenciesScanner', () => {
       .expects('replaceModule')
       .never();
 
-    await scanner.scan(TestModule as any);
+    await scanner.scan(TestModule);
     expectationCountAddModule.verify();
     expectationCountReplaceModule.verify();
   });
@@ -95,20 +97,20 @@ describe('DependenciesScanner', () => {
     const expectation = mockContainer.expects('addProvider').twice();
     const stub = sinon.stub(scanner, 'insertExportedProvider');
 
-    await scanner.scan(TestModule as any);
+    await scanner.scan(TestModule);
     expectation.verify();
     stub.restore();
   });
 
   it('should "insertController" call twice (2 components) container method "addController"', async () => {
     const expectation = mockContainer.expects('addController').twice();
-    await scanner.scan(TestModule as any);
+    await scanner.scan(TestModule);
     expectation.verify();
   });
 
   it('should "insertExportedProvider" call once (1 component) container method "addExportedProvider"', async () => {
     const expectation = mockContainer.expects('addExportedProvider').once();
-    await scanner.scan(TestModule as any);
+    await scanner.scan(TestModule);
     expectation.verify();
   });
 
@@ -176,7 +178,7 @@ describe('DependenciesScanner', () => {
         .expects('addModule')
         .once();
 
-      await scanner.scan(OverrideTestModule as any, {
+      await scanner.scan(OverrideTestModule, {
         overrides: modulesToOverride,
       });
 
@@ -188,13 +190,13 @@ describe('DependenciesScanner', () => {
     it('should "insertProvider" call once container method "addProvider"', async () => {
       const expectation = mockContainer.expects('addProvider').once();
 
-      await scanner.scan(OverrideTestModule as any);
+      await scanner.scan(OverrideTestModule);
       expectation.verify();
     });
 
     it('should "insertController" call twice (2 components) container method "addController"', async () => {
       const expectation = mockContainer.expects('addController').twice();
-      await scanner.scan(OverrideTestModule as any);
+      await scanner.scan(OverrideTestModule);
       expectation.verify();
     });
 
@@ -230,7 +232,7 @@ describe('DependenciesScanner', () => {
       })
       class OverrideForwardRefTestModule {}
 
-      await scanner.scan(OverrideForwardRefTestModule as any, {
+      await scanner.scan(OverrideForwardRefTestModule, {
         overrides: [
           {
             moduleToReplace: Overwritten,
@@ -290,7 +292,7 @@ describe('DependenciesScanner', () => {
 
     beforeEach(() => {
       addInjectableStub = sinon
-        .stub((scanner as any).container, 'addInjectable')
+        .stub(untypedScanner.container, 'addInjectable')
         .callsFake(() => instanceWrapper);
       insertEnhancerMetadataCacheStub = sinon
         .stub(graphInspector, 'insertEnhancerMetadataCache')
@@ -427,7 +429,7 @@ describe('DependenciesScanner', () => {
       const module = { forwardRef: sinon.stub().returns({}) };
 
       sinon.stub(container, 'addImport').returns({} as any);
-      await scanner.insertImport(module as any, [] as any, 'test');
+      await scanner.insertImport(module, [] as any, 'test');
       expect(module.forwardRef.called).to.be.true;
     });
     describe('when "related" is nil', () => {
@@ -477,7 +479,7 @@ describe('DependenciesScanner', () => {
         it('should push new object to "applicationProvidersApplyMap" array', () => {
           mockContainer.expects('addProvider').callsFake(() => false);
           scanner.insertProvider(provider, token);
-          const applyMap = (scanner as any).applicationProvidersApplyMap;
+          const applyMap = untypedScanner.applicationProvidersApplyMap;
 
           expect(applyMap).to.have.length(1);
           expect(applyMap[0].moduleKey).to.be.eql(token);
@@ -514,15 +516,11 @@ describe('DependenciesScanner', () => {
           expectation.verify();
         });
         it('should not push new object to "applicationProvidersApplyMap" array', () => {
-          expect((scanner as any).applicationProvidersApplyMap).to.have.length(
-            0,
-          );
+          expect(untypedScanner.applicationProvidersApplyMap).to.have.length(0);
 
           mockContainer.expects('addProvider').callsFake(() => false);
           scanner.insertProvider(component, token);
-          expect((scanner as any).applicationProvidersApplyMap).to.have.length(
-            0,
-          );
+          expect(untypedScanner.applicationProvidersApplyMap).to.have.length(0);
         });
       });
     });
@@ -534,7 +532,7 @@ describe('DependenciesScanner', () => {
         providerKey: 'providerToken',
         type: APP_GUARD,
       };
-      (scanner as any).applicationProvidersApplyMap = [provider];
+      untypedScanner.applicationProvidersApplyMap = [provider];
 
       const expectedInstance = {};
       const instanceWrapper = {
@@ -569,7 +567,7 @@ describe('DependenciesScanner', () => {
         type: APP_GUARD,
         scope: Scope.REQUEST,
       };
-      (scanner as any).applicationProvidersApplyMap = [provider];
+      untypedScanner.applicationProvidersApplyMap = [provider];
 
       const expectedInstanceWrapper = new InstanceWrapper();
       mockContainer.expects('getModules').callsFake(() => ({
@@ -606,7 +604,7 @@ describe('DependenciesScanner', () => {
     };
 
     it('should add enhancers metadata to every controller and every entry provider', () => {
-      (scanner as any).applicationProvidersApplyMap = [provider];
+      untypedScanner.applicationProvidersApplyMap = [provider];
 
       const instance = new InstanceWrapper({ name: 'test' });
       const controllers = new Map();
@@ -651,7 +649,7 @@ describe('DependenciesScanner', () => {
     describe(`when token is ${APP_INTERCEPTOR}`, () => {
       it('call "addGlobalInterceptor"', () => {
         const addSpy = sinon.spy(
-          (scanner as any).applicationConfig,
+          untypedScanner.applicationConfig,
           'addGlobalInterceptor',
         );
         scanner.getApplyProvidersMap()[APP_INTERCEPTOR](null);
@@ -661,7 +659,7 @@ describe('DependenciesScanner', () => {
     describe(`when token is ${APP_GUARD}`, () => {
       it('call "addGlobalGuard"', () => {
         const addSpy = sinon.spy(
-          (scanner as any).applicationConfig,
+          untypedScanner.applicationConfig,
           'addGlobalGuard',
         );
         scanner.getApplyProvidersMap()[APP_GUARD](null);
@@ -671,7 +669,7 @@ describe('DependenciesScanner', () => {
     describe(`when token is ${APP_PIPE}`, () => {
       it('call "addGlobalPipe"', () => {
         const addSpy = sinon.spy(
-          (scanner as any).applicationConfig,
+          untypedScanner.applicationConfig,
           'addGlobalPipe',
         );
         scanner.getApplyProvidersMap()[APP_PIPE](null);
@@ -681,7 +679,7 @@ describe('DependenciesScanner', () => {
     describe(`when token is ${APP_FILTER}`, () => {
       it('call "addGlobalFilter"', () => {
         const addSpy = sinon.spy(
-          (scanner as any).applicationConfig,
+          untypedScanner.applicationConfig,
           'addGlobalFilter',
         );
         scanner.getApplyProvidersMap()[APP_FILTER](null);
@@ -693,7 +691,7 @@ describe('DependenciesScanner', () => {
     describe(`when token is ${APP_INTERCEPTOR}`, () => {
       it('call "addGlobalRequestInterceptor"', () => {
         const addSpy = sinon.spy(
-          (scanner as any).applicationConfig,
+          untypedScanner.applicationConfig,
           'addGlobalRequestInterceptor',
         );
         scanner.getApplyRequestProvidersMap()[APP_INTERCEPTOR](null);
@@ -703,7 +701,7 @@ describe('DependenciesScanner', () => {
     describe(`when token is ${APP_GUARD}`, () => {
       it('call "addGlobalRequestGuard"', () => {
         const addSpy = sinon.spy(
-          (scanner as any).applicationConfig,
+          untypedScanner.applicationConfig,
           'addGlobalRequestGuard',
         );
         scanner.getApplyRequestProvidersMap()[APP_GUARD](null);
@@ -713,7 +711,7 @@ describe('DependenciesScanner', () => {
     describe(`when token is ${APP_PIPE}`, () => {
       it('call "addGlobalRequestPipe"', () => {
         const addSpy = sinon.spy(
-          (scanner as any).applicationConfig,
+          untypedScanner.applicationConfig,
           'addGlobalRequestPipe',
         );
         scanner.getApplyRequestProvidersMap()[APP_PIPE](null);
@@ -723,7 +721,7 @@ describe('DependenciesScanner', () => {
     describe(`when token is ${APP_FILTER}`, () => {
       it('call "addGlobalRequestFilter"', () => {
         const addSpy = sinon.spy(
-          (scanner as any).applicationConfig,
+          untypedScanner.applicationConfig,
           'addGlobalRequestFilter',
         );
         scanner.getApplyRequestProvidersMap()[APP_FILTER](null);
diff --git a/packages/core/test/services/reflector.service.spec.ts b/packages/core/test/services/reflector.service.spec.ts
index 237375ad3..000c931ad 100644
--- a/packages/core/test/services/reflector.service.spec.ts
+++ b/packages/core/test/services/reflector.service.spec.ts
@@ -5,48 +5,63 @@ const transformDecorator = Reflector.createDecorator<string[], number>({
   transform: value => value.length,
 });
 
+type TestObject = {
+  only1?: string;
+  only2?: string;
+  both: string;
+};
+
 describe('Reflector', () => {
+  const key = 'key';
   let reflector: Reflector;
 
-  class Test {}
-
   @transformDecorator(['a', 'b', 'c'])
   class TestTransform {}
+  class Test {}
+  class Test1 {}
+  class Test2 {}
 
   beforeEach(() => {
+    Reflect.deleteMetadata(key, Test1);
+    Reflect.deleteMetadata(key, Test2);
     reflector = new Reflector();
   });
 
   describe('get', () => {
     it('should reflect metadata by key', () => {
-      const key = 'key';
       const value = 'value';
-      Reflect.defineMetadata(key, value, Test);
-      expect(reflector.get(key, Test)).to.eql(value);
+      Reflect.defineMetadata(key, value, Test1);
+      expect(reflector.get(key, Test1)).to.eql(value);
     });
 
     it('should reflect metadata by decorator', () => {
       const decorator = Reflector.createDecorator<string>();
       const value = 'value';
-      Reflect.defineMetadata(decorator.KEY, value, Test);
+      Reflect.defineMetadata(decorator.KEY, value, Test1);
 
-      let reflectedValue = reflector.get(decorator, Test);
+      // string
+      let reflectedValue = reflector.get(decorator, Test1);
       expect(reflectedValue).to.eql(value);
 
       // @ts-expect-error 'value' is not assignable to parameter of type 'string'
       reflectedValue = true;
+
+      reflectedValue satisfies string;
     });
 
     it('should reflect metadata by decorator (custom key)', () => {
       const decorator = Reflector.createDecorator<string[]>({ key: 'custom' });
       const value = ['value'];
-      Reflect.defineMetadata('custom', value, Test);
+      Reflect.defineMetadata('custom', value, Test1);
 
-      let reflectedValue = reflector.get(decorator, Test);
+      // string[]
+      let reflectedValue = reflector.get(decorator, Test1);
       expect(reflectedValue).to.eql(value);
 
       // @ts-expect-error 'value' is not assignable to parameter of type 'string[]'
       reflectedValue = true;
+
+      reflectedValue satisfies string[];
     });
 
     it('should reflect metadata by decorator (with transform option)', () => {
@@ -55,6 +70,8 @@ describe('Reflector', () => {
 
       // @ts-expect-error 'value' is not assignable to type 'number'
       reflectedValue = [];
+
+      reflectedValue satisfies number;
     });
 
     it('should require transform option when second generic type is provided', () => {
@@ -64,53 +81,121 @@ describe('Reflector', () => {
   });
 
   describe('getAll', () => {
-    it('should reflect metadata of all targets', () => {
-      const key = 'key';
-      const value = 'value';
-      Reflect.defineMetadata(key, value, Test);
-      expect(reflector.getAll(key, [Test])).to.eql([value]);
+    it('should reflect metadata of all targets by key', () => {
+      const value1 = 'value1';
+      const value2 = 'value2';
+      Reflect.defineMetadata(key, value1, Test1);
+      Reflect.defineMetadata(key, value2, Test2);
+      expect(reflector.getAll(key, [Test1, Test2])).to.eql([value1, value2]);
+    });
+    it('should reflect metadata of all targets by decorator', () => {
+      const decorator = Reflector.createDecorator<string>();
+      const value1 = 'value1';
+      const value2 = 'value2';
+      Reflect.defineMetadata(decorator.KEY, value1, Test1);
+      Reflect.defineMetadata(decorator.KEY, value2, Test2);
+
+      // string[]
+      const reflectedValue = reflector.getAll(decorator, [Test1, Test2]);
+      expect(reflectedValue).to.eql([value1, value2]);
+
+      reflectedValue satisfies string[];
     });
   });
 
   describe('getAllAndMerge', () => {
     it('should return an empty array when there are no targets', () => {
-      const key = 'key';
       expect(reflector.getAllAndMerge(key, [])).to.be.empty;
     });
     it('should reflect metadata of all targets and concat arrays', () => {
-      const key = 'key';
+      const decorator = Reflector.createDecorator<string[]>();
       const value = 'value';
-      Reflect.defineMetadata(key, [value], Test);
-      expect(reflector.getAllAndMerge(key, [Test, Test])).to.eql([
-        value,
-        value,
+      Reflect.defineMetadata(decorator.KEY, [value], Test1);
+
+      // string[]
+      const reflectedValue = reflector.getAllAndMerge(decorator, [
+        Test1,
+        Test1,
+      ]);
+      expect(reflectedValue).to.eql([value, value]);
+
+      reflectedValue satisfies string[];
+    });
+    it('should reflect metadata of all targets and concat boolean arrays', () => {
+      const decorator = Reflector.createDecorator<boolean>();
+      const value = true;
+      Reflect.defineMetadata(decorator.KEY, [value], Test1);
+
+      // string[]
+      const reflectedValue = reflector.getAllAndMerge(decorator, [
+        Test1,
+        Test1,
       ]);
+      expect(reflectedValue).to.eql([value, value]);
+
+      reflectedValue satisfies boolean[];
     });
     it('should reflect metadata of all targets and create an array', () => {
-      const key = 'key';
+      const decorator = Reflector.createDecorator<string>();
       const value = 'value';
-      Reflect.defineMetadata(key, value, Test);
-      expect(reflector.getAllAndMerge(key, [Test, Test])).to.eql([
-        value,
-        value,
+      Reflect.defineMetadata(decorator.KEY, value, Test1);
+
+      // string[]
+      const reflectedValue = reflector.getAllAndMerge(decorator, [
+        Test1,
+        Test1,
       ]);
+      expect(reflectedValue).to.eql([value, value]);
+
+      reflectedValue satisfies string[];
     });
-    it('should reflect metadata of all targets and merge an object', () => {
-      const key = 'key';
-      const value = { test: 'test' };
-      Reflect.defineMetadata(key, value, Test);
-      expect(reflector.getAllAndMerge(key, [Test, Test])).to.eql({
-        ...value,
+    it('should reflect metadata of all targets and merge objects', () => {
+      const decorator = Reflector.createDecorator<TestObject>();
+      const value1: TestObject = { only1: 'test1', both: 'overriden' };
+      const value2: TestObject = { only2: 'test2', both: 'test' };
+      Reflect.defineMetadata(decorator.KEY, value1, Test1);
+      Reflect.defineMetadata(decorator.KEY, value2, Test2);
+
+      // TestObject
+      const reflectedValue = reflector.getAllAndMerge(decorator, [
+        Test1,
+        Test2,
+      ]);
+      expect(reflectedValue).to.eql({
+        ...value1,
+        ...value2,
       });
+
+      reflectedValue satisfies TestObject;
+    });
+    it('should reflect metadata of all targets and create an array from a single value', () => {
+      const value = 'value';
+      Reflect.defineMetadata(key, value, Test1);
+
+      const result = reflector.getAllAndMerge(key, [Test1, Test2]);
+      expect(result).to.eql([value]);
+
+      result satisfies string[];
+    });
+    it('should reflect metadata of all targets and return a single array unmodified', () => {
+      const value = ['value'];
+      Reflect.defineMetadata(key, value, Test1);
+      expect(reflector.getAllAndMerge(key, [Test1, Test2])).to.eql(value);
+    });
+    it('should reflect metadata of all targets and return a single object unmodified', () => {
+      const value = { test: 'value' };
+      Reflect.defineMetadata(key, value, Test1);
+      expect(reflector.getAllAndMerge(key, [Test1, Test2])).to.eql(value);
     });
   });
 
   describe('getAllAndOverride', () => {
     it('should reflect metadata of all targets and return a first not undefined value', () => {
-      const key = 'key';
-      const value = 'value';
-      Reflect.defineMetadata(key, value, Test);
-      expect(reflector.getAllAndOverride(key, [Test, Test])).to.eql(value);
+      const value1 = 'value1';
+      const value2 = 'value2';
+      Reflect.defineMetadata(key, value1, Test1);
+      Reflect.defineMetadata(key, value2, Test2);
+      expect(reflector.getAllAndOverride(key, [Test1, Test2])).to.eql(value1);
     });
   });
 });
diff --git a/packages/microservices/client/client-rmq.ts b/packages/microservices/client/client-rmq.ts
index 5c8824f57..653e6f432 100644
--- a/packages/microservices/client/client-rmq.ts
+++ b/packages/microservices/client/client-rmq.ts
@@ -192,6 +192,15 @@ export class ClientRMQ extends ClientProxy {
     if (!this.noAssert) {
       await channel.assertQueue(this.queue, this.queueOptions);
     }
+
+    if (this.options.exchange && this.options.routingKey) {
+      await channel.bindQueue(
+        this.queue,
+        this.options.exchange,
+        this.options.routingKey,
+      );
+    }
+
     await channel.prefetch(prefetchCount, isGlobalPrefetchCount);
     await this.consumeChannel(channel);
     resolve();
diff --git a/packages/microservices/constants.ts b/packages/microservices/constants.ts
index c358776dd..35b6af94e 100644
--- a/packages/microservices/constants.ts
+++ b/packages/microservices/constants.ts
@@ -33,7 +33,7 @@ export const PARAM_ARGS_METADATA = ROUTE_ARGS_METADATA;
 export const REQUEST_PATTERN_METADATA = 'microservices:request_pattern';
 export const REPLY_PATTERN_METADATA = 'microservices:reply_pattern';
 
-export const RQM_DEFAULT_QUEUE = 'default';
+export const RQM_DEFAULT_QUEUE = '';
 export const RQM_DEFAULT_PREFETCH_COUNT = 0;
 export const RQM_DEFAULT_IS_GLOBAL_PREFETCH_COUNT = false;
 export const RQM_DEFAULT_QUEUE_OPTIONS = {};
@@ -71,3 +71,5 @@ export const EADDRINUSE = 'EADDRINUSE';
 
 export const CONNECTION_FAILED_MESSAGE =
   'Connection to transport failed. Trying to reconnect...';
+
+export const NATS_DEFAULT_GRACE_PERIOD = 10000;
diff --git a/packages/microservices/errors/max-packet-length-exceeded.exception.ts b/packages/microservices/errors/max-packet-length-exceeded.exception.ts
new file mode 100644
index 000000000..5d2ccd3c7
--- /dev/null
+++ b/packages/microservices/errors/max-packet-length-exceeded.exception.ts
@@ -0,0 +1,8 @@
+/**
+ * @publicApi
+ */
+export class MaxPacketLengthExceededException extends Error {
+  constructor(length: number) {
+    super(`The packet length (${length}) exceeds the maximum allowed length`);
+  }
+}
diff --git a/packages/microservices/exceptions/base-rpc-exception-filter.ts b/packages/microservices/exceptions/base-rpc-exception-filter.ts
index 837330fac..849bc9ac2 100644
--- a/packages/microservices/exceptions/base-rpc-exception-filter.ts
+++ b/packages/microservices/exceptions/base-rpc-exception-filter.ts
@@ -26,11 +26,8 @@ export class BaseRpcExceptionFilter<T = any, R = any>
   public handleUnknownError(exception: T, status: string) {
     const errorMessage = MESSAGES.UNKNOWN_EXCEPTION_MESSAGE;
 
-    const loggerArgs = this.isError(exception)
-      ? [exception.message, exception.stack]
-      : [exception];
     const logger = BaseRpcExceptionFilter.logger;
-    logger.error.apply(logger, loggerArgs as any);
+    logger.error.apply(logger, [exception]);
 
     return _throw(() => ({ status, message: errorMessage }));
   }
diff --git a/packages/microservices/external/nats-client.interface.ts b/packages/microservices/external/nats-client.interface.ts
index 637883a42..931f1233c 100644
--- a/packages/microservices/external/nats-client.interface.ts
+++ b/packages/microservices/external/nats-client.interface.ts
@@ -50,7 +50,7 @@ interface Sub<T> extends AsyncIterable<T> {
   getMax(): number | undefined;
 }
 
-declare type Subscription = Sub<NatsMsg>;
+export declare type Subscription = Sub<NatsMsg>;
 
 declare enum Events {
   Disconnect = 'disconnect',
diff --git a/packages/microservices/helpers/json-socket.ts b/packages/microservices/helpers/json-socket.ts
index 5d017f9b5..574d5f267 100644
--- a/packages/microservices/helpers/json-socket.ts
+++ b/packages/microservices/helpers/json-socket.ts
@@ -1,8 +1,11 @@
 import { Buffer } from 'buffer';
 import { StringDecoder } from 'string_decoder';
 import { CorruptedPacketLengthException } from '../errors/corrupted-packet-length.exception';
+import { MaxPacketLengthExceededException } from '../errors/max-packet-length-exceeded.exception';
 import { TcpSocket } from './tcp-socket';
 
+const MAX_BUFFER_SIZE = (512 * 1024 * 1024) / 4; // 512 MBs in characters with 4 bytes per character (32-bit)
+
 export class JsonSocket extends TcpSocket {
   private contentLength: number | null = null;
   private buffer = '';
@@ -20,7 +23,12 @@ export class JsonSocket extends TcpSocket {
       : dataRaw;
     this.buffer += data;
 
-    if (this.contentLength == null) {
+    if (this.buffer.length > MAX_BUFFER_SIZE) {
+      this.buffer = '';
+      throw new MaxPacketLengthExceededException(this.buffer.length);
+    }
+
+    if (this.contentLength === null) {
       const i = this.buffer.indexOf(this.delimiter);
       /**
        * Check if the buffer has the delimiter (#),
diff --git a/packages/microservices/interfaces/microservice-configuration.interface.ts b/packages/microservices/interfaces/microservice-configuration.interface.ts
index b5850e1b2..55539f1cf 100644
--- a/packages/microservices/interfaces/microservice-configuration.interface.ts
+++ b/packages/microservices/interfaces/microservice-configuration.interface.ts
@@ -1,4 +1,4 @@
-import { Type } from '@nestjs/common';
+import { FactoryProvider, InjectionToken, Type } from '@nestjs/common';
 import { ConnectionOptions } from 'tls';
 import { Transport } from '../enums/transport.enum';
 import { ChannelOptions } from '../external/grpc-options.interface';
@@ -32,6 +32,16 @@ export type MicroserviceOptions =
   | KafkaOptions
   | CustomStrategy;
 
+export type AsyncMicroserviceOptions = {
+  inject: InjectionToken[];
+  useFactory: (...args: any[]) => MicroserviceOptions;
+};
+
+export type AsyncOptions<T extends object> = {
+  inject: InjectionToken[];
+  useFactory: (...args: any[]) => T;
+};
+
 /**
  * @publicApi
  */
@@ -193,6 +203,8 @@ export interface NatsOptions {
     token?: string;
     yieldTime?: number;
     tokenHandler?: any;
+    gracefulShutdown?: boolean;
+    gracePeriod?: number;
     [key: string]: any;
   };
 }
@@ -209,6 +221,8 @@ export interface RmqOptions {
     isGlobalPrefetchCount?: boolean;
     queueOptions?: AmqplibQueueOptions;
     socketOptions?: AmqpConnectionManagerSocketOptions;
+    exchange?: string;
+    routingKey?: string;
     noAck?: boolean;
     consumerTag?: string;
     serializer?: Serializer;
diff --git a/packages/microservices/listener-metadata-explorer.ts b/packages/microservices/listener-metadata-explorer.ts
index faa98b71b..721c23670 100644
--- a/packages/microservices/listener-metadata-explorer.ts
+++ b/packages/microservices/listener-metadata-explorer.ts
@@ -39,25 +39,36 @@ export class ListenerMetadataExplorer {
     const instancePrototype = Object.getPrototypeOf(instance);
     return this.metadataScanner
       .getAllMethodNames(instancePrototype)
-      .map(method => this.exploreMethodMetadata(instancePrototype, method))
+      .map(method =>
+        this.exploreMethodMetadata(instance, instancePrototype, method),
+      )
       .filter(metadata => metadata);
   }
 
   public exploreMethodMetadata(
+    instance: Controller,
     instancePrototype: object,
     methodKey: string,
   ): EventOrMessageListenerDefinition {
-    const targetCallback = instancePrototype[methodKey];
+    const prototypeCallback = instancePrototype[methodKey];
     const handlerType = Reflect.getMetadata(
       PATTERN_HANDLER_METADATA,
-      targetCallback,
+      prototypeCallback,
     );
     if (isUndefined(handlerType)) {
       return;
     }
-    const patterns = Reflect.getMetadata(PATTERN_METADATA, targetCallback);
-    const transport = Reflect.getMetadata(TRANSPORT_METADATA, targetCallback);
-    const extras = Reflect.getMetadata(PATTERN_EXTRAS_METADATA, targetCallback);
+    const patterns = Reflect.getMetadata(PATTERN_METADATA, prototypeCallback);
+    const transport = Reflect.getMetadata(
+      TRANSPORT_METADATA,
+      prototypeCallback,
+    );
+    const extras = Reflect.getMetadata(
+      PATTERN_EXTRAS_METADATA,
+      prototypeCallback,
+    );
+
+    const targetCallback = instance[methodKey];
     return {
       methodKey,
       targetCallback,
diff --git a/packages/microservices/nest-microservice.ts b/packages/microservices/nest-microservice.ts
index 7b0930e69..fd9c7aee6 100644
--- a/packages/microservices/nest-microservice.ts
+++ b/packages/microservices/nest-microservice.ts
@@ -17,7 +17,10 @@ import { GraphInspector } from '@nestjs/core/inspector/graph-inspector';
 import { NestApplicationContext } from '@nestjs/core/nest-application-context';
 import { Transport } from './enums/transport.enum';
 import { CustomTransportStrategy } from './interfaces/custom-transport-strategy.interface';
-import { MicroserviceOptions } from './interfaces/microservice-configuration.interface';
+import {
+  AsyncMicroserviceOptions,
+  MicroserviceOptions,
+} from './interfaces/microservice-configuration.interface';
 import { MicroservicesModule } from './microservices-module';
 import { Server } from './server/server';
 import { ServerFactory } from './server/server-factory';
@@ -43,7 +46,8 @@ export class NestMicroservice
 
   constructor(
     container: NestContainer,
-    config: NestMicroserviceOptions & MicroserviceOptions = {},
+    config: NestMicroserviceOptions &
+      (MicroserviceOptions | AsyncMicroserviceOptions) = {},
     private readonly graphInspector: GraphInspector,
     private readonly applicationConfig: ApplicationConfig,
   ) {
@@ -60,12 +64,22 @@ export class NestMicroservice
     this.selectContextModule();
   }
 
-  public createServer(config: NestMicroserviceOptions & MicroserviceOptions) {
+  public createServer(
+    config: NestMicroserviceOptions &
+      (MicroserviceOptions | AsyncMicroserviceOptions),
+  ) {
     try {
-      this.microserviceConfig = {
-        transport: Transport.TCP,
-        ...config,
-      } as any;
+      if ('useFactory' in config) {
+        const args = config.inject?.map(token =>
+          this.get(token, { strict: false }),
+        );
+        this.microserviceConfig = config.useFactory(...args);
+      } else {
+        this.microserviceConfig = {
+          transport: Transport.TCP,
+          ...config,
+        } as any;
+      }
       const { strategy } = config as any;
       this.server = strategy
         ? strategy
diff --git a/packages/microservices/package.json b/packages/microservices/package.json
index 4b903ef82..4201b5261 100644
--- a/packages/microservices/package.json
+++ b/packages/microservices/package.json
@@ -1,6 +1,6 @@
 {
   "name": "@nestjs/microservices",
-  "version": "10.4.6",
+  "version": "10.4.7",
   "description": "Nest - modern, fast, powerful node.js web framework (@microservices)",
   "author": "Kamil Mysliwiec",
   "license": "MIT",
@@ -22,8 +22,8 @@
     "tslib": "2.7.0"
   },
   "devDependencies": {
-    "@nestjs/common": "10.4.6",
-    "@nestjs/core": "10.4.6"
+    "@nestjs/common": "10.4.7",
+    "@nestjs/core": "10.4.7"
   },
   "peerDependencies": {
     "@grpc/grpc-js": "*",
diff --git a/packages/microservices/server/server-grpc.ts b/packages/microservices/server/server-grpc.ts
index f27e0e721..c503e4805 100644
--- a/packages/microservices/server/server-grpc.ts
+++ b/packages/microservices/server/server-grpc.ts
@@ -84,7 +84,6 @@ export class ServerGrpc extends Server implements CustomTransportStrategy {
 
   public async start(callback?: () => void) {
     await this.bindEvents();
-    this.grpcClient.start();
     callback();
   }
 
@@ -597,7 +596,7 @@ export class ServerGrpc extends Server implements CustomTransportStrategy {
   private async createServices(grpcPkg: any, packageName: string) {
     if (!grpcPkg) {
       const invalidPackageError = new InvalidGrpcPackageException(packageName);
-      this.logger.error(invalidPackageError.message, invalidPackageError.stack);
+      this.logger.error(invalidPackageError);
       throw invalidPackageError;
     }
 
diff --git a/packages/microservices/server/server-nats.ts b/packages/microservices/server/server-nats.ts
index e9c376b12..a62b6c8d1 100644
--- a/packages/microservices/server/server-nats.ts
+++ b/packages/microservices/server/server-nats.ts
@@ -1,9 +1,17 @@
 import { isUndefined, isObject } from '@nestjs/common/utils/shared.utils';
-import { NATS_DEFAULT_URL, NO_MESSAGE_HANDLER } from '../constants';
+import {
+  NATS_DEFAULT_GRACE_PERIOD,
+  NATS_DEFAULT_URL,
+  NO_MESSAGE_HANDLER,
+} from '../constants';
 import { NatsContext } from '../ctx-host/nats.context';
 import { NatsRequestJSONDeserializer } from '../deserializers/nats-request-json.deserializer';
 import { Transport } from '../enums';
-import { Client, NatsMsg } from '../external/nats-client.interface';
+import {
+  Client,
+  NatsMsg,
+  Subscription,
+} from '../external/nats-client.interface';
 import { CustomTransportStrategy } from '../interfaces';
 import { NatsOptions } from '../interfaces/microservice-configuration.interface';
 import { IncomingRequest } from '../interfaces/packet.interface';
@@ -21,6 +29,10 @@ export class ServerNats extends Server implements CustomTransportStrategy {
 
   private natsClient: Client;
 
+  private readonly subscriptions: Subscription[] = [];
+
+  private readonly gracePeriod: number;
+
   constructor(private readonly options: NatsOptions['options']) {
     super();
 
@@ -28,6 +40,10 @@ export class ServerNats extends Server implements CustomTransportStrategy {
       require('nats'),
     );
 
+    this.gracePeriod =
+      this.getOptionsProp(this.options, 'gracePeriod') ||
+      NATS_DEFAULT_GRACE_PERIOD;
+
     this.initializeSerializer(options);
     this.initializeDeserializer(options);
   }
@@ -60,12 +76,30 @@ export class ServerNats extends Server implements CustomTransportStrategy {
       });
 
     const registeredPatterns = [...this.messageHandlers.keys()];
-    registeredPatterns.forEach(channel => subscribe(channel));
+    for (const channel of registeredPatterns) {
+      const sub = subscribe(channel);
+      this.subscriptions.push(sub);
+    }
+  }
+
+  private async waitForGracePeriod() {
+    await new Promise<void>(res => {
+      setTimeout(() => {
+        res();
+      }, this.gracePeriod);
+    });
   }
 
   public async close() {
-    await this.natsClient?.close();
-    this.natsClient = null;
+    if (this.natsClient) {
+      const graceful = this.getOptionsProp(this.options, 'gracefulShutdown');
+      if (graceful) {
+        this.subscriptions.forEach(sub => sub.unsubscribe());
+        await this.waitForGracePeriod();
+      }
+      await this.natsClient?.close();
+      this.natsClient = null;
+    }
   }
 
   public createNatsClient(): Promise<Client> {
diff --git a/packages/microservices/server/server-rmq.ts b/packages/microservices/server/server-rmq.ts
index c0ea0bd8f..9d011a673 100644
--- a/packages/microservices/server/server-rmq.ts
+++ b/packages/microservices/server/server-rmq.ts
@@ -153,6 +153,18 @@ export class ServerRMQ extends Server implements CustomTransportStrategy {
     if (!this.noAssert) {
       await channel.assertQueue(this.queue, this.queueOptions);
     }
+
+    if (this.options.exchange && this.options.routingKey) {
+      await channel.assertExchange(this.options.exchange, 'topic', {
+        durable: true,
+      });
+      await channel.bindQueue(
+        this.queue,
+        this.options.exchange,
+        this.options.routingKey,
+      );
+    }
+
     await channel.prefetch(this.prefetchCount, this.isGlobalPrefetchCount);
     channel.consume(
       this.queue,
diff --git a/packages/microservices/server/server-tcp.ts b/packages/microservices/server/server-tcp.ts
index b76a21c11..af9271b76 100644
--- a/packages/microservices/server/server-tcp.ts
+++ b/packages/microservices/server/server-tcp.ts
@@ -43,10 +43,10 @@ export class ServerTCP extends Server implements CustomTransportStrategy {
 
   constructor(private readonly options: TcpOptions['options']) {
     super();
-    this.port = this.getOptionsProp(options, 'port') || TCP_DEFAULT_PORT;
-    this.host = this.getOptionsProp(options, 'host') || TCP_DEFAULT_HOST;
+    this.port = this.getOptionsProp(options, 'port', TCP_DEFAULT_PORT);
+    this.host = this.getOptionsProp(options, 'host', TCP_DEFAULT_HOST);
     this.socketClass =
-      this.getOptionsProp(options, 'socketClass') || JsonSocket;
+      this.getOptionsProp(options, 'socketClass', JsonSocket);
     this.tlsOptions = this.getOptionsProp(options, 'tlsOptions');
 
     this.init();
diff --git a/packages/microservices/test/client/client-grpc.spec.ts b/packages/microservices/test/client/client-grpc.spec.ts
index a6fb314be..2b17ec880 100644
--- a/packages/microservices/test/client/client-grpc.spec.ts
+++ b/packages/microservices/test/client/client-grpc.spec.ts
@@ -22,6 +22,7 @@ class GrpcService {
 
 describe('ClientGrpcProxy', () => {
   let client: ClientGrpcProxy;
+  let untypedClient: any;
   let clientMulti: ClientGrpcProxy;
 
   beforeEach(() => {
@@ -29,6 +30,7 @@ describe('ClientGrpcProxy', () => {
       protoPath: join(__dirname, './test.proto'),
       package: 'test',
     });
+    untypedClient = client as any;
 
     clientMulti = new ClientGrpcProxy({
       protoPath: ['test.proto', 'test2.proto'],
@@ -42,7 +44,7 @@ describe('ClientGrpcProxy', () => {
   describe('getService', () => {
     describe('when "grpcClient[name]" is nil', () => {
       it('should throw "InvalidGrpcServiceException"', () => {
-        (client as any).grpcClient = {};
+        untypedClient.grpcClient = {};
         expect(() => client.getService('test')).to.throw(
           InvalidGrpcServiceException,
         );
@@ -62,7 +64,7 @@ describe('ClientGrpcProxy', () => {
     });
     describe('when "grpcClient[name]" is not nil', () => {
       it('should create grpcService', () => {
-        (client as any).grpcClients[0] = {
+        untypedClient.grpcClients[0] = {
           test: GrpcService,
         };
         expect(() => client.getService('test')).to.not.throw(
@@ -430,7 +432,7 @@ describe('ClientGrpcProxy', () => {
     describe('when package does not exist', () => {
       it('should throw "InvalidGrpcPackageException"', () => {
         sinon.stub(client, 'lookupPackage').callsFake(() => null);
-        (client as any).logger = new NoopLogger();
+        untypedClient.logger = new NoopLogger();
 
         try {
           client.createClients();
@@ -451,7 +453,7 @@ describe('ClientGrpcProxy', () => {
         getPackageDefinitionStub.callsFake(() => {
           throw new Error();
         });
-        (client as any).logger = new NoopLogger();
+        untypedClient.logger = new NoopLogger();
         expect(() => client.loadProto()).to.throws(
           InvalidProtoDefinitionException,
         );
@@ -462,13 +464,13 @@ describe('ClientGrpcProxy', () => {
   describe('close', () => {
     it('should call "close" method', () => {
       const grpcClient = { close: sinon.spy() };
-      (client as any).clients.set('test', grpcClient);
-      (client as any).grpcClients[0] = {};
+      untypedClient.clients.set('test', grpcClient);
+      untypedClient.grpcClients[0] = {};
 
       client.close();
       expect(grpcClient.close.called).to.be.true;
-      expect((client as any).clients.size).to.be.eq(0);
-      expect((client as any).grpcClients.length).to.be.eq(0);
+      expect(untypedClient.clients.size).to.be.eq(0);
+      expect(untypedClient.grpcClients.length).to.be.eq(0);
     });
   });
 
diff --git a/packages/microservices/test/client/client-kafka.spec.ts b/packages/microservices/test/client/client-kafka.spec.ts
index c6c030ee6..50a4e37e6 100644
--- a/packages/microservices/test/client/client-kafka.spec.ts
+++ b/packages/microservices/test/client/client-kafka.spec.ts
@@ -149,6 +149,7 @@ describe('ClientKafka', () => {
   };
 
   let client: ClientKafka;
+  let untypedClient: any;
   let callback: sinon.SinonSpy;
   let connect: sinon.SinonSpy;
   let subscribe: sinon.SinonSpy;
@@ -162,6 +163,8 @@ describe('ClientKafka', () => {
 
   beforeEach(() => {
     client = new ClientKafka({});
+    untypedClient = client as any;
+
     callback = sinon.spy();
     connect = sinon.spy();
     subscribe = sinon.spy();
@@ -250,17 +253,17 @@ describe('ClientKafka', () => {
     const consumer = { disconnect: sinon.stub().resolves() };
     const producer = { disconnect: sinon.stub().resolves() };
     beforeEach(() => {
-      (client as any).consumer = consumer;
-      (client as any).producer = producer;
+      untypedClient.consumer = consumer;
+      untypedClient.producer = producer;
     });
     it('should close server', async () => {
       await client.close();
 
       expect(consumer.disconnect.calledOnce).to.be.true;
       expect(producer.disconnect.calledOnce).to.be.true;
-      expect((client as any).consumer).to.be.null;
-      expect((client as any).producer).to.be.null;
-      expect((client as any).client).to.be.null;
+      expect(untypedClient.consumer).to.be.null;
+      expect(untypedClient.producer).to.be.null;
+      expect(untypedClient.client).to.be.null;
     });
   });
 
@@ -298,7 +301,7 @@ describe('ClientKafka', () => {
       });
 
       it('should expect the connection to be reused', async () => {
-        (client as any).initialized = Promise.resolve({});
+        untypedClient.initialized = Promise.resolve({});
 
         await client.connect();
 
@@ -345,7 +348,7 @@ describe('ClientKafka', () => {
       });
 
       it('should expect the connection to be reused', async () => {
-        (client as any).initialized = Promise.resolve({});
+        untypedClient.initialized = Promise.resolve({});
 
         await client.connect();
 
@@ -427,8 +430,8 @@ describe('ClientKafka', () => {
 
   describe('bindTopics', () => {
     it('should bind topics from response patterns', async () => {
-      (client as any).responsePatterns = [replyTopic];
-      (client as any).consumer = kafkaClient.consumer();
+      untypedClient.responsePatterns = [replyTopic];
+      untypedClient.consumer = kafkaClient.consumer();
 
       await client.bindTopics();
 
@@ -442,10 +445,10 @@ describe('ClientKafka', () => {
     });
 
     it('should bind topics from response patterns with options', async () => {
-      (client as any).responsePatterns = [replyTopic];
-      (client as any).consumer = kafkaClient.consumer();
-      (client as any).options.subscribe = {};
-      (client as any).options.subscribe.fromBeginning = true;
+      untypedClient.responsePatterns = [replyTopic];
+      untypedClient.consumer = kafkaClient.consumer();
+      untypedClient.options.subscribe = {};
+      untypedClient.options.subscribe.fromBeginning = true;
 
       await client.bindTopics();
 
@@ -660,7 +663,7 @@ describe('ClientKafka', () => {
         client as any,
         'getReplyTopicPartition',
       );
-      routingMapSetSpy = sinon.spy((client as any).routingMap, 'set');
+      routingMapSetSpy = sinon.spy(untypedClient.routingMap, 'set');
       sendSpy = sinon.spy(() => Promise.resolve());
 
       // stub
diff --git a/packages/microservices/test/client/client-mqtt.spec.ts b/packages/microservices/test/client/client-mqtt.spec.ts
index cab94c152..ef1768d66 100644
--- a/packages/microservices/test/client/client-mqtt.spec.ts
+++ b/packages/microservices/test/client/client-mqtt.spec.ts
@@ -9,6 +9,7 @@ import { MqttRecord } from '../../record-builders';
 describe('ClientMqtt', () => {
   const test = 'test';
   let client: ClientMqtt = new ClientMqtt({});
+  let untypedClient = client as any;
 
   describe('getRequestPattern', () => {
     it(`should leave pattern as it is`, () => {
@@ -36,6 +37,8 @@ describe('ClientMqtt', () => {
     const id = '1';
     beforeEach(() => {
       client = new ClientMqtt({});
+      untypedClient = client as any;
+
       msg = { pattern, data: 'data' };
       subscribeSpy = sinon.spy((name, fn) => fn());
       publishSpy = sinon.spy();
@@ -51,7 +54,7 @@ describe('ClientMqtt', () => {
         publish: publishSpy,
         addListener: () => ({}),
       };
-      (client as any).mqttClient = mqttClient;
+      untypedClient.mqttClient = mqttClient;
       connectSpy = sinon.stub(client, 'connect');
       assignStub = sinon
         .stub(client, 'assignPacketId' as any)
@@ -132,7 +135,7 @@ describe('ClientMqtt', () => {
       });
       it('should combine packet and static headers', async () => {
         const staticHeaders = { 'client-id': 'some-client-id' };
-        (client as any).options.userProperties = staticHeaders;
+        untypedClient.options.userProperties = staticHeaders;
 
         const requestHeaders = { '1': '123' };
         msg.data = new MqttRecord('data', {
@@ -147,7 +150,7 @@ describe('ClientMqtt', () => {
       });
       it('should prefer packet headers over static headers', async () => {
         const staticHeaders = { 'client-id': 'some-client-id' };
-        (client as any).options.headers = staticHeaders;
+        untypedClient.options.headers = staticHeaders;
 
         const requestHeaders = { 'client-id': 'override-client-id' };
         msg.data = new MqttRecord('data', {
@@ -231,14 +234,14 @@ describe('ClientMqtt', () => {
     let endSpy: sinon.SinonSpy;
     beforeEach(() => {
       endSpy = sinon.spy();
-      (client as any).mqttClient = { end: endSpy };
+      untypedClient.mqttClient = { end: endSpy };
     });
     it('should close "pub" when it is not null', () => {
       client.close();
       expect(endSpy.called).to.be.true;
     });
     it('should not close "pub" when it is null', () => {
-      (client as any).mqttClient = null;
+      untypedClient.mqttClient = null;
       client.close();
       expect(endSpy.called).to.be.false;
     });
@@ -332,12 +335,14 @@ describe('ClientMqtt', () => {
 
     beforeEach(() => {
       client = new ClientMqtt({});
+      untypedClient = client as any;
+
       msg = { pattern: 'pattern', data: 'data' };
       publishStub = sinon.stub();
       mqttClient = {
         publish: publishStub,
       };
-      (client as any).mqttClient = mqttClient;
+      untypedClient.mqttClient = mqttClient;
     });
 
     it('should publish packet', async () => {
@@ -373,7 +378,7 @@ describe('ClientMqtt', () => {
       it('should combine packet and static headers', async () => {
         publishStub.callsFake((a, b, c, d) => d());
         const staticHeaders = { 'client-id': 'some-client-id' };
-        (client as any).options.userProperties = staticHeaders;
+        untypedClient.options.userProperties = staticHeaders;
 
         const requestHeaders = { '1': '123' };
         msg.data = new MqttRecord('data', {
@@ -391,7 +396,7 @@ describe('ClientMqtt', () => {
       it('should prefer packet headers over static headers', async () => {
         publishStub.callsFake((a, b, c, d) => d());
         const staticHeaders = { 'client-id': 'some-client-id' };
-        (client as any).options.headers = staticHeaders;
+        untypedClient.options.headers = staticHeaders;
 
         const requestHeaders = { 'client-id': 'override-client-id' };
         msg.data = new MqttRecord('data', {
diff --git a/packages/microservices/test/client/client-nats.spec.ts b/packages/microservices/test/client/client-nats.spec.ts
index d9f93bc21..aa14af84e 100644
--- a/packages/microservices/test/client/client-nats.spec.ts
+++ b/packages/microservices/test/client/client-nats.spec.ts
@@ -7,6 +7,7 @@ import { NatsRecord } from '../../record-builders';
 
 describe('ClientNats', () => {
   let client: ClientNats;
+  let untypedClient: any;
 
   describe('publish', () => {
     let msg: ReadPacket;
@@ -24,6 +25,8 @@ describe('ClientNats', () => {
 
     beforeEach(() => {
       client = new ClientNats({});
+      untypedClient = client as any;
+
       msg = { pattern, data: 'data' };
       unsubscribeSpy = sinon.spy();
       subscription = {
@@ -39,14 +42,14 @@ describe('ClientNats', () => {
         addListener: () => ({}),
         publish: publishSpy,
       };
-      (client as any).natsClient = natsClient;
+      untypedClient.natsClient = natsClient;
 
       connectSpy = sinon.stub(client, 'connect').callsFake(async () => {
-        (client as any).natsClient = natsClient;
+        untypedClient.natsClient = natsClient;
       });
       createClient = sinon
         .stub(client, 'createClient')
-        .callsFake(() => client as any);
+        .callsFake(() => untypedClient);
     });
     afterEach(() => {
       connectSpy.restore();
@@ -117,7 +120,7 @@ describe('ClientNats', () => {
       });
       it('should combine packet and static headers', () => {
         const staticHeaders = { 'client-id': 'some-client-id' };
-        (client as any).options.headers = staticHeaders;
+        untypedClient.options.headers = staticHeaders;
 
         const requestHeaders = createHeaders();
         requestHeaders.set('1', '123');
@@ -132,7 +135,7 @@ describe('ClientNats', () => {
 
       it('should prefer packet headers over static headers', () => {
         const staticHeaders = { 'client-id': 'some-client-id' };
-        (client as any).options.headers = staticHeaders;
+        untypedClient.options.headers = staticHeaders;
 
         const requestHeaders = createHeaders();
         requestHeaders.set('client-id', 'override-client-id');
@@ -223,11 +226,12 @@ describe('ClientNats', () => {
   });
   describe('close', () => {
     let natsClose: sinon.SinonSpy;
-    let natsClient;
+    let natsClient: any;
+
     beforeEach(() => {
       natsClose = sinon.spy();
       natsClient = { close: natsClose };
-      (client as any).natsClient = natsClient;
+      untypedClient.natsClient = natsClient;
     });
     it('should close "natsClient" when it is not null', () => {
       client.close();
@@ -288,7 +292,7 @@ describe('ClientNats', () => {
     });
 
     it('should log "disconnect" and "error" statuses as "errors"', async () => {
-      const logErrorSpy = sinon.spy((client as any).logger, 'error');
+      const logErrorSpy = sinon.spy(untypedClient.logger, 'error');
       const clientMock = {
         status: sinon.stub().returns({
           async *[Symbol.asyncIterator]() {
@@ -309,7 +313,7 @@ describe('ClientNats', () => {
       );
     });
     it('should log other statuses as "logs"', async () => {
-      const logSpy = sinon.spy((client as any).logger, 'log');
+      const logSpy = sinon.spy(untypedClient.logger, 'log');
       const clientMock = {
         status: sinon.stub().returns({
           async *[Symbol.asyncIterator]() {
@@ -334,6 +338,8 @@ describe('ClientNats', () => {
 
     beforeEach(() => {
       client = new ClientNats({});
+      untypedClient = client as any;
+
       msg = { pattern: 'pattern', data: 'data' };
       subscribeStub = sinon
         .stub()
@@ -342,7 +348,7 @@ describe('ClientNats', () => {
         publish: sinon.spy(),
         subscribe: subscribeStub,
       };
-      (client as any).natsClient = natsClient;
+      untypedClient.natsClient = natsClient;
     });
 
     it('should publish packet', async () => {
@@ -379,7 +385,7 @@ describe('ClientNats', () => {
 
       it('should combine packet and static headers', () => {
         const staticHeaders = { 'client-id': 'some-client-id' };
-        (client as any).options.headers = staticHeaders;
+        untypedClient.options.headers = staticHeaders;
 
         const requestHeaders = createHeaders();
         requestHeaders.set('1', '123');
@@ -396,7 +402,7 @@ describe('ClientNats', () => {
 
       it('should prefer packet headers over static headers', () => {
         const staticHeaders = { 'client-id': 'some-client-id' };
-        (client as any).options.headers = staticHeaders;
+        untypedClient.options.headers = staticHeaders;
 
         const requestHeaders = createHeaders();
         requestHeaders.set('client-id', 'override-client-id');
diff --git a/packages/microservices/test/client/client-redis.spec.ts b/packages/microservices/test/client/client-redis.spec.ts
index 6cae9da85..a34117673 100644
--- a/packages/microservices/test/client/client-redis.spec.ts
+++ b/packages/microservices/test/client/client-redis.spec.ts
@@ -6,6 +6,7 @@ import { ERROR_EVENT } from '../../constants';
 describe('ClientRedis', () => {
   const test = 'test';
   const client = new ClientRedis({});
+  const untypedClient = client as any;
 
   describe('getRequestPattern', () => {
     it(`should leave pattern as it is`, () => {
@@ -28,8 +29,8 @@ describe('ClientRedis', () => {
       removeListenerSpy: sinon.SinonSpy,
       unsubscribeSpy: sinon.SinonSpy,
       connectSpy: sinon.SinonSpy,
-      sub,
-      pub;
+      sub: Record<string, Function>,
+      pub: Record<string, Function>;
 
     beforeEach(() => {
       subscribeSpy = sinon.spy((name, fn) => fn());
@@ -46,8 +47,8 @@ describe('ClientRedis', () => {
         addListener: () => ({}),
       };
       pub = { publish: publishSpy };
-      (client as any).subClient = sub;
-      (client as any).pubClient = pub;
+      untypedClient.subClient = sub;
+      untypedClient.pubClient = pub;
       connectSpy = sinon.spy(client, 'connect');
     });
     afterEach(() => {
@@ -189,15 +190,15 @@ describe('ClientRedis', () => {
       subClose = sinon.spy();
       pub = { quit: pubClose };
       sub = { quit: subClose };
-      (client as any).pubClient = pub;
-      (client as any).subClient = sub;
+      untypedClient.pubClient = pub;
+      untypedClient.subClient = sub;
     });
     it('should close "pub" when it is not null', () => {
       client.close();
       expect(pubClose.called).to.be.true;
     });
     it('should not close "pub" when it is null', () => {
-      (client as any).pubClient = null;
+      untypedClient.pubClient = null;
       client.close();
       expect(pubClose.called).to.be.false;
     });
@@ -206,7 +207,7 @@ describe('ClientRedis', () => {
       expect(subClose.called).to.be.true;
     });
     it('should not close "sub" when it is null', () => {
-      (client as any).subClient = null;
+      untypedClient.subClient = null;
       client.close();
       expect(subClose.called).to.be.false;
     });
@@ -262,37 +263,37 @@ describe('ClientRedis', () => {
   describe('createRetryStrategy', () => {
     describe('when is terminated', () => {
       it('should return undefined', () => {
-        (client as any).isExplicitlyTerminated = true;
+        untypedClient.isExplicitlyTerminated = true;
         const result = client.createRetryStrategy(0);
         expect(result).to.be.undefined;
       });
     });
     describe('when "retryAttempts" does not exist', () => {
       it('should return undefined', () => {
-        (client as any).isExplicitlyTerminated = false;
-        (client as any).options.options = {};
-        (client as any).options.options.retryAttempts = undefined;
+        untypedClient.isExplicitlyTerminated = false;
+        untypedClient.options.options = {};
+        untypedClient.options.options.retryAttempts = undefined;
         const result = client.createRetryStrategy(1);
         expect(result).to.be.undefined;
       });
     });
     describe('when "attempts" count is max', () => {
       it('should return undefined', () => {
-        (client as any).isExplicitlyTerminated = false;
-        (client as any).options.options = {};
-        (client as any).options.options.retryAttempts = 3;
+        untypedClient.isExplicitlyTerminated = false;
+        untypedClient.options.options = {};
+        untypedClient.options.options.retryAttempts = 3;
         const result = client.createRetryStrategy(4);
         expect(result).to.be.undefined;
       });
     });
     describe('otherwise', () => {
       it('should return delay (ms)', () => {
-        (client as any).options = {};
-        (client as any).isExplicitlyTerminated = false;
-        (client as any).options.retryAttempts = 3;
-        (client as any).options.retryDelay = 3;
+        untypedClient.options = {};
+        untypedClient.isExplicitlyTerminated = false;
+        untypedClient.options.retryAttempts = 3;
+        untypedClient.options.retryDelay = 3;
         const result = client.createRetryStrategy(2);
-        expect(result).to.be.eql((client as any).options.retryDelay);
+        expect(result).to.be.eql(untypedClient.options.retryDelay);
       });
     });
   });
@@ -305,7 +306,7 @@ describe('ClientRedis', () => {
       pubClient = {
         publish: publishStub,
       };
-      (client as any).pubClient = pubClient;
+      untypedClient.pubClient = pubClient;
     });
 
     it('should publish packet', async () => {
diff --git a/packages/microservices/test/client/client-rmq.spec.ts b/packages/microservices/test/client/client-rmq.spec.ts
index b9083e1fa..12b0209ce 100644
--- a/packages/microservices/test/client/client-rmq.spec.ts
+++ b/packages/microservices/test/client/client-rmq.spec.ts
@@ -10,6 +10,7 @@ describe('ClientRMQ', function () {
   this.retries(10);
 
   let client: ClientRMQ;
+  let untypedClient: any;
 
   describe('constructor', () => {
     it(`should fallback to queueOptions.noAssert when 'noAssert' is undefined`, () => {
@@ -31,6 +32,8 @@ describe('ClientRMQ', function () {
 
     beforeEach(async () => {
       client = new ClientRMQ({});
+      untypedClient = client as any;
+
       createClientStub = sinon.stub(client, 'createClient').callsFake(() => ({
         addListener: () => ({}),
         removeListener: () => ({}),
@@ -137,7 +140,7 @@ describe('ClientRMQ', function () {
     beforeEach(() => {
       client['queue'] = queue;
       client['queueOptions'] = queueOptions;
-      (client as any)['options'] = { isGlobalPrefetchCount, prefetchCount };
+      untypedClient['options'] = { isGlobalPrefetchCount, prefetchCount };
 
       channel = {
         assertQueue: sinon.spy(() => ({})),
@@ -198,6 +201,8 @@ describe('ClientRMQ', function () {
 
     beforeEach(() => {
       client = new ClientRMQ({});
+      untypedClient = client as any;
+
       msg = { pattern, data: 'data' };
       connectSpy = sinon.spy(client, 'connect');
       eventSpy = sinon.spy();
@@ -268,7 +273,7 @@ describe('ClientRMQ', function () {
 
       it('should combine packet and static headers', () => {
         const staticHeaders = { 'client-id': 'some-client-id' };
-        (client as any).options.headers = staticHeaders;
+        untypedClient.options.headers = staticHeaders;
 
         const requestHeaders = { '1': '123' };
         msg.data = new RmqRecord('data', { headers: requestHeaders });
@@ -283,7 +288,7 @@ describe('ClientRMQ', function () {
 
       it('should prefer packet headers over static headers', () => {
         const staticHeaders = { 'client-id': 'some-client-id' };
-        (client as any).options.headers = staticHeaders;
+        untypedClient.options.headers = staticHeaders;
 
         const requestHeaders = { 'client-id': 'override-client-id' };
         msg.data = new RmqRecord('data', { headers: requestHeaders });
@@ -370,8 +375,8 @@ describe('ClientRMQ', function () {
     beforeEach(() => {
       channelCloseSpy = sinon.spy();
       clientCloseSpy = sinon.spy();
-      (client as any).channel = { close: channelCloseSpy };
-      (client as any).client = { close: clientCloseSpy };
+      untypedClient.channel = { close: channelCloseSpy };
+      untypedClient.client = { close: clientCloseSpy };
     });
 
     it('should close channel when it is not null', () => {
@@ -390,12 +395,14 @@ describe('ClientRMQ', function () {
 
     beforeEach(() => {
       client = new ClientRMQ({});
+      untypedClient = client as any;
+
       msg = { pattern: 'pattern', data: 'data' };
       sendToQueueStub = sinon.stub();
       channel = {
         sendToQueue: sendToQueueStub,
       };
-      (client as any).channel = channel;
+      untypedClient.channel = channel;
     });
 
     it('should publish packet', async () => {
@@ -432,7 +439,7 @@ describe('ClientRMQ', function () {
       it('should combine packet and static headers', async () => {
         sendToQueueStub.callsFake((a, b, c, d) => d());
         const staticHeaders = { 'client-id': 'some-client-id' };
-        (client as any).options.headers = staticHeaders;
+        untypedClient.options.headers = staticHeaders;
 
         const requestHeaders = { '1': '123' };
         msg.data = new RmqRecord('data', { headers: requestHeaders });
@@ -447,7 +454,7 @@ describe('ClientRMQ', function () {
       it('should prefer packet headers over static headers', async () => {
         sendToQueueStub.callsFake((a, b, c, d) => d());
         const staticHeaders = { 'client-id': 'some-client-id' };
-        (client as any).options.headers = staticHeaders;
+        untypedClient.options.headers = staticHeaders;
 
         const requestHeaders = { 'client-id': 'override-client-id' };
         msg.data = new RmqRecord('data', { headers: requestHeaders });
diff --git a/packages/microservices/test/client/client-tcp.spec.ts b/packages/microservices/test/client/client-tcp.spec.ts
index b1b7941bb..2f4f4247c 100644
--- a/packages/microservices/test/client/client-tcp.spec.ts
+++ b/packages/microservices/test/client/client-tcp.spec.ts
@@ -7,11 +7,14 @@ import { ERROR_EVENT } from '../../constants';
 
 describe('ClientTCP', () => {
   let client: ClientTCP;
-  let socket;
+  let untypedClient: any;
+  let socket: any;
   let createSocketStub: sinon.SinonStub;
 
   beforeEach(() => {
     client = new ClientTCP({});
+    untypedClient = client as any;
+
     const onFakeCallback = (event, callback) =>
       event !== 'error' && event !== 'close' && callback({});
 
@@ -163,22 +166,22 @@ describe('ClientTCP', () => {
       routingMap = new Map<string, Function>();
       callback = sinon.spy();
       routingMap.set('some id', callback);
-      (client as any).socket = socket;
-      (client as any).isConnected = true;
-      (client as any).routingMap = routingMap;
+      untypedClient.socket = socket;
+      untypedClient.isConnected = true;
+      untypedClient.routingMap = routingMap;
       client.close();
     });
     it('should end() socket', () => {
       expect(socket.end.called).to.be.true;
     });
     it('should set "isConnected" to false', () => {
-      expect((client as any).isConnected).to.be.false;
+      expect(untypedClient.isConnected).to.be.false;
     });
     it('should set "socket" to null', () => {
-      expect((client as any).socket).to.be.null;
+      expect(untypedClient.socket).to.be.null;
     });
     it('should clear out the routing map', () => {
-      expect((client as any).routingMap.size).to.be.eq(0);
+      expect(untypedClient.routingMap.size).to.be.eq(0);
     });
     it('should call callbacks', () => {
       expect(
@@ -207,7 +210,7 @@ describe('ClientTCP', () => {
       internalSocket = {
         sendMessage: sendMessageStub,
       };
-      (client as any).socket = internalSocket;
+      untypedClient.socket = internalSocket;
     });
 
     it('should publish packet', async () => {
diff --git a/packages/microservices/test/listeners-metadata-explorer.spec.ts b/packages/microservices/test/listeners-metadata-explorer.spec.ts
index 18ccdc2f7..b4c5c10e2 100644
--- a/packages/microservices/test/listeners-metadata-explorer.spec.ts
+++ b/packages/microservices/test/listeners-metadata-explorer.spec.ts
@@ -71,6 +71,7 @@ describe('ListenerMetadataExplorer', () => {
     });
     it(`should return undefined when "handlerType" metadata is undefined`, () => {
       const metadata = instance.exploreMethodMetadata(
+        test,
         Object.getPrototypeOf(test),
         'noPattern',
       );
@@ -80,6 +81,7 @@ describe('ListenerMetadataExplorer', () => {
     describe('@MessagePattern', () => {
       it(`should return pattern properties when "handlerType" metadata is not undefined`, () => {
         const metadata = instance.exploreMethodMetadata(
+          test,
           Object.getPrototypeOf(test),
           'testMessage',
         );
@@ -96,6 +98,7 @@ describe('ListenerMetadataExplorer', () => {
       });
       it(`should return multiple patterns when more than one is declared`, () => {
         const metadata = instance.exploreMethodMetadata(
+          test,
           Object.getPrototypeOf(test),
           'testMultipleMessage',
         );
@@ -116,6 +119,7 @@ describe('ListenerMetadataExplorer', () => {
     describe('@EventPattern', () => {
       it(`should return pattern properties when "handlerType" metadata is not undefined`, () => {
         const metadata = instance.exploreMethodMetadata(
+          test,
           Object.getPrototypeOf(test),
           'testEvent',
         );
@@ -132,6 +136,7 @@ describe('ListenerMetadataExplorer', () => {
       });
       it(`should return multiple patterns when more than one is declared`, () => {
         const metadata = instance.exploreMethodMetadata(
+          test,
           Object.getPrototypeOf(test),
           'testMultipleEvent',
         );
diff --git a/packages/microservices/test/server/server-grpc.spec.ts b/packages/microservices/test/server/server-grpc.spec.ts
index af683a237..3c57ccbd3 100644
--- a/packages/microservices/test/server/server-grpc.spec.ts
+++ b/packages/microservices/test/server/server-grpc.spec.ts
@@ -18,13 +18,15 @@ class NoopLogger extends Logger {
 
 describe('ServerGrpc', () => {
   let server: ServerGrpc;
+  let untypedServer: any;
   let serverMulti: ServerGrpc;
 
   beforeEach(() => {
     server = new ServerGrpc({
       protoPath: join(__dirname, './test.proto'),
       package: 'test',
-    } as any);
+    });
+    untypedServer = server as any;
 
     serverMulti = new ServerGrpc({
       protoPath: ['test.proto', 'test2.proto'],
@@ -51,13 +53,6 @@ describe('ServerGrpc', () => {
       await server.close();
       expect(bindEventsStub.called).to.be.true;
     });
-    it('should call "client.start"', async () => {
-      const client = { start: sinon.spy() };
-      sinon.stub(server, 'createClient').callsFake(async () => client);
-
-      await server.listen(callback);
-      expect(client.start.called).to.be.true;
-    });
     it('should call callback', async () => {
       await server.listen(callback);
       await server.close();
@@ -95,12 +90,6 @@ describe('ServerGrpc', () => {
       await serverMulti.close();
       expect(bindEventsStub.called).to.be.true;
     });
-    it('should call "client.start"', async () => {
-      const client = { start: sinon.spy() };
-      sinon.stub(serverMulti, 'createClient').callsFake(async () => client);
-      await serverMulti.listen(callback);
-      expect(client.start.called).to.be.true;
-    });
     it('should call callback', async () => {
       await serverMulti.listen(callback);
       await serverMulti.close();
@@ -115,7 +104,7 @@ describe('ServerGrpc', () => {
     describe('when package does not exist', () => {
       it('should throw "InvalidGrpcPackageException"', async () => {
         sinon.stub(server, 'lookupPackage').callsFake(() => null);
-        (server as any).logger = new NoopLogger();
+        untypedServer.logger = new NoopLogger();
         try {
           await server.bindEvents();
         } catch (err) {
@@ -140,10 +129,10 @@ describe('ServerGrpc', () => {
           test2: { service: true },
         }));
         sinon.stub(server, 'getServiceNames').callsFake(() => serviceNames);
-        (server as any).grpcClient = { addService: sinon.spy() };
+        untypedServer.grpcClient = { addService: sinon.spy() };
 
         await server.bindEvents();
-        expect((server as any).grpcClient.addService.calledTwice).to.be.true;
+        expect(untypedServer.grpcClient.addService.calledTwice).to.be.true;
       });
     });
   });
@@ -227,7 +216,7 @@ describe('ServerGrpc', () => {
       const spy = sinon
         .stub(server, 'createServiceMethod')
         .callsFake(() => ({}) as any);
-      (server as any).messageHandlers = handlers;
+      untypedServer.messageHandlers = handlers;
       await server.createService(
         {
           prototype: { test: true, test2: true },
@@ -249,7 +238,7 @@ describe('ServerGrpc', () => {
           .returns('test2');
 
         sinon.stub(server, 'createServiceMethod').callsFake(() => ({}) as any);
-        (server as any).messageHandlers = handlers;
+        untypedServer.messageHandlers = handlers;
         await server.createService(
           {
             prototype: {
@@ -286,7 +275,7 @@ describe('ServerGrpc', () => {
           .returns('test2');
 
         sinon.stub(server, 'createServiceMethod').callsFake(() => ({}) as any);
-        (server as any).messageHandlers = handlers;
+        untypedServer.messageHandlers = handlers;
         await server.createService(
           {
             prototype: {
@@ -317,7 +306,7 @@ describe('ServerGrpc', () => {
       );
       const handlers = new Map([[testPattern, () => ({})]]);
       console.log(handlers.entries());
-      (server as any).messageHandlers = handlers;
+      untypedServer.messageHandlers = handlers;
 
       expect(
         server.getMessageHandler(
@@ -335,7 +324,7 @@ describe('ServerGrpc', () => {
         GrpcMethodStreamingType.NO_STREAMING,
       );
       const handlers = new Map([[testPattern, () => ({})]]);
-      (server as any).messageHandlers = handlers;
+      untypedServer.messageHandlers = handlers;
 
       expect(
         server.getMessageHandler(
@@ -356,7 +345,7 @@ describe('ServerGrpc', () => {
         GrpcMethodStreamingType.NO_STREAMING,
       );
       const handlers = new Map([[testPattern, () => ({})]]);
-      (server as any).messageHandlers = handlers;
+      untypedServer.messageHandlers = handlers;
 
       expect(
         server.getMessageHandler(
@@ -868,7 +857,7 @@ describe('ServerGrpc', () => {
         getPackageDefinitionStub.callsFake(() => {
           throw new Error();
         });
-        (server as any).logger = new NoopLogger();
+        untypedServer.logger = new NoopLogger();
         expect(() => server.loadProto()).to.throws(
           InvalidProtoDefinitionException,
         );
@@ -883,7 +872,7 @@ describe('ServerGrpc', () => {
         forceShutdown: sinon.spy(),
         tryShutdown: sinon.stub().yields(),
       };
-      (server as any).grpcClient = grpcClient;
+      untypedServer.grpcClient = grpcClient;
       await server.close();
       expect(grpcClient.forceShutdown.called).to.be.true;
       expect(grpcClient.tryShutdown.called).to.be.false;
@@ -894,8 +883,8 @@ describe('ServerGrpc', () => {
         forceShutdown: sinon.spy(),
         tryShutdown: sinon.stub().yields(),
       };
-      (server as any).grpcClient = grpcClient;
-      (server as any).options.gracefulShutdown = false;
+      untypedServer.grpcClient = grpcClient;
+      untypedServer.options.gracefulShutdown = false;
       await server.close();
       expect(grpcClient.forceShutdown.called).to.be.true;
       expect(grpcClient.tryShutdown.called).to.be.false;
@@ -906,8 +895,8 @@ describe('ServerGrpc', () => {
         forceShutdown: sinon.spy(),
         tryShutdown: sinon.stub().yields(),
       };
-      (server as any).grpcClient = grpcClient;
-      (server as any).options.gracefulShutdown = true;
+      untypedServer.grpcClient = grpcClient;
+      untypedServer.options.gracefulShutdown = true;
       await server.close();
       expect(grpcClient.forceShutdown.called).to.be.false;
       expect(grpcClient.tryShutdown.called).to.be.true;
@@ -986,7 +975,7 @@ describe('ServerGrpc', () => {
       sinon.stub(server as any, 'messageHandlers').value({ set() {} });
 
       const messageHandlersSetSpy = sinon.spy(
-        (server as any).messageHandlers,
+        untypedServer.messageHandlers,
         'set',
       );
       server.addHandler(pattern, callback as any);
diff --git a/packages/microservices/test/server/server-kafka.spec.ts b/packages/microservices/test/server/server-kafka.spec.ts
index 5255b4310..f517b0eba 100644
--- a/packages/microservices/test/server/server-kafka.spec.ts
+++ b/packages/microservices/test/server/server-kafka.spec.ts
@@ -8,6 +8,7 @@ import {
   KafkaMessage,
 } from '../../external/kafka.interface';
 import { ServerKafka } from '../../server';
+import { objectToMap } from './utils/object-to-map';
 
 class NoopLogger extends Logger {
   log(message: any, context?: string): void {}
@@ -16,9 +17,6 @@ class NoopLogger extends Logger {
 }
 
 describe('ServerKafka', () => {
-  const objectToMap = obj =>
-    new Map(Object.keys(obj).map(i => [i, obj[i]]) as any);
-
   const topic = 'test.topic';
   const replyTopic = 'test.topic.reply';
   const replyPartition = '0';
@@ -84,6 +82,7 @@ describe('ServerKafka', () => {
   };
 
   let server: ServerKafka;
+  let untypedServer: any;
   let callback: sinon.SinonSpy;
   let bindEventsStub: sinon.SinonStub;
   let connect: sinon.SinonSpy;
@@ -92,10 +91,12 @@ describe('ServerKafka', () => {
   let send: sinon.SinonSpy;
   let consumerStub: sinon.SinonStub;
   let producerStub: sinon.SinonStub;
-  let client;
+  let client: any;
 
   beforeEach(() => {
     server = new ServerKafka({});
+    untypedServer = server as any;
+
     callback = sinon.spy();
     connect = sinon.spy();
     subscribe = sinon.spy();
@@ -152,40 +153,40 @@ describe('ServerKafka', () => {
     const consumer = { disconnect: sinon.spy() };
     const producer = { disconnect: sinon.spy() };
     beforeEach(() => {
-      (server as any).consumer = consumer;
-      (server as any).producer = producer;
+      untypedServer.consumer = consumer;
+      untypedServer.producer = producer;
     });
     it('should close server', async () => {
       await server.close();
 
       expect(consumer.disconnect.calledOnce).to.be.true;
       expect(producer.disconnect.calledOnce).to.be.true;
-      expect((server as any).consumer).to.be.null;
-      expect((server as any).producer).to.be.null;
-      expect((server as any).client).to.be.null;
+      expect(untypedServer.consumer).to.be.null;
+      expect(untypedServer.producer).to.be.null;
+      expect(untypedServer.client).to.be.null;
     });
   });
 
   describe('bindEvents', () => {
     it('should not call subscribe nor run on consumer when there are no messageHandlers', async () => {
-      (server as any).logger = new NoopLogger();
+      untypedServer.logger = new NoopLogger();
       await server.listen(callback);
-      await server.bindEvents((server as any).consumer);
+      await server.bindEvents(untypedServer.consumer);
       expect(subscribe.called).to.be.false;
       expect(run.called).to.be.true;
       expect(connect.called).to.be.true;
     });
     it('should call subscribe and run on consumer when there are messageHandlers', async () => {
-      (server as any).logger = new NoopLogger();
+      untypedServer.logger = new NoopLogger();
       await server.listen(callback);
 
       const pattern = 'test';
       const handler = sinon.spy();
-      (server as any).messageHandlers = objectToMap({
+      untypedServer.messageHandlers = objectToMap({
         [pattern]: handler,
       });
 
-      await server.bindEvents((server as any).consumer);
+      await server.bindEvents(untypedServer.consumer);
 
       expect(subscribe.called).to.be.true;
       expect(
@@ -198,18 +199,18 @@ describe('ServerKafka', () => {
       expect(connect.called).to.be.true;
     });
     it('should call subscribe with options and run on consumer when there are messageHandlers', async () => {
-      (server as any).logger = new NoopLogger();
-      (server as any).options.subscribe = {};
-      (server as any).options.subscribe.fromBeginning = true;
+      untypedServer.logger = new NoopLogger();
+      untypedServer.options.subscribe = {};
+      untypedServer.options.subscribe.fromBeginning = true;
       await server.listen(callback);
 
       const pattern = 'test';
       const handler = sinon.spy();
-      (server as any).messageHandlers = objectToMap({
+      untypedServer.messageHandlers = objectToMap({
         [pattern]: handler,
       });
 
-      await server.bindEvents((server as any).consumer);
+      await server.bindEvents(untypedServer.consumer);
 
       expect(subscribe.called).to.be.true;
       expect(
@@ -337,7 +338,7 @@ describe('ServerKafka', () => {
     it('should call "handleEvent" if correlation identifier and reply topic are present but the handler is of type eventHandler', async () => {
       const handler = sinon.spy();
       (handler as any).isEventHandler = true;
-      (server as any).messageHandlers = objectToMap({
+      untypedServer.messageHandlers = objectToMap({
         [topic]: handler,
       });
       const handleEventSpy = sinon.spy(server, 'handleEvent');
@@ -348,7 +349,7 @@ describe('ServerKafka', () => {
     it('should NOT call "handleEvent" if correlation identifier and reply topic are present but the handler is not of type eventHandler', async () => {
       const handler = sinon.spy();
       (handler as any).isEventHandler = false;
-      (server as any).messageHandlers = objectToMap({
+      untypedServer.messageHandlers = objectToMap({
         [topic]: handler,
       });
       const handleEventSpy = sinon.spy(server, 'handleEvent');
@@ -368,7 +369,7 @@ describe('ServerKafka', () => {
 
     it(`should call handler with expected arguments`, async () => {
       const handler = sinon.spy();
-      (server as any).messageHandlers = objectToMap({
+      untypedServer.messageHandlers = objectToMap({
         [topic]: handler,
       });
 
diff --git a/packages/microservices/test/server/server-mqtt.spec.ts b/packages/microservices/test/server/server-mqtt.spec.ts
index 8e63a0162..4634d0066 100644
--- a/packages/microservices/test/server/server-mqtt.spec.ts
+++ b/packages/microservices/test/server/server-mqtt.spec.ts
@@ -3,15 +3,15 @@ import * as sinon from 'sinon';
 import { NO_MESSAGE_HANDLER } from '../../constants';
 import { BaseRpcContext } from '../../ctx-host/base-rpc.context';
 import { ServerMqtt } from '../../server/server-mqtt';
+import { objectToMap } from './utils/object-to-map';
 
 describe('ServerMqtt', () => {
   let server: ServerMqtt;
-
-  const objectToMap = obj =>
-    new Map(Object.keys(obj).map(key => [key, obj[key]]) as any);
+  let untypedServer: any;
 
   beforeEach(() => {
     server = new ServerMqtt({});
+    untypedServer = server as any;
   });
   describe('listen', () => {
     let onSpy: sinon.SinonSpy;
@@ -53,7 +53,7 @@ describe('ServerMqtt', () => {
   describe('close', () => {
     const mqttClient = { end: sinon.spy() };
     beforeEach(() => {
-      (server as any).mqttClient = mqttClient;
+      untypedServer.mqttClient = mqttClient;
     });
     it('should end mqttClient', () => {
       server.close();
@@ -74,7 +74,7 @@ describe('ServerMqtt', () => {
     it('should subscribe to each pattern', () => {
       const pattern = 'test';
       const handler = sinon.spy();
-      (server as any).messageHandlers = objectToMap({
+      untypedServer.messageHandlers = objectToMap({
         [pattern]: handler,
       });
       server.bindEvents(mqttClient);
@@ -84,7 +84,7 @@ describe('ServerMqtt', () => {
   describe('getMessageHandler', () => {
     it(`should return function`, () => {
       expect(
-        typeof server.getMessageHandler((server as any).mqttClient),
+        typeof server.getMessageHandler(untypedServer.mqttClient),
       ).to.be.eql('function');
     });
     describe('handler', () => {
@@ -92,7 +92,7 @@ describe('ServerMqtt', () => {
         const handleMessageStub = sinon
           .stub(server, 'handleMessage')
           .callsFake(() => null);
-        (await server.getMessageHandler((server as any).mqttClient))(null);
+        (await server.getMessageHandler(untypedServer.mqttClient))(null);
         expect(handleMessageStub.called).to.be.true;
       });
     });
@@ -133,7 +133,7 @@ describe('ServerMqtt', () => {
     });
     it(`should call handler with expected arguments`, async () => {
       const handler = sinon.spy();
-      (server as any).messageHandlers = objectToMap({
+      untypedServer.messageHandlers = objectToMap({
         [channel]: handler,
       });
 
@@ -204,7 +204,7 @@ describe('ServerMqtt', () => {
 
     it('should call handler with expected arguments', () => {
       const handler = sinon.spy();
-      (server as any).messageHandlers = objectToMap({
+      untypedServer.messageHandlers = objectToMap({
         [channel]: handler,
       });
 
diff --git a/packages/microservices/test/server/server-nats.spec.ts b/packages/microservices/test/server/server-nats.spec.ts
index 1b9839903..586b9ed5b 100644
--- a/packages/microservices/test/server/server-nats.spec.ts
+++ b/packages/microservices/test/server/server-nats.spec.ts
@@ -6,15 +6,15 @@ import { NatsContext } from '../../ctx-host';
 import { BaseRpcContext } from '../../ctx-host/base-rpc.context';
 import { NatsMsg } from '../../external/nats-client.interface';
 import { ServerNats } from '../../server/server-nats';
+import { objectToMap } from './utils/object-to-map';
 
 describe('ServerNats', () => {
   let server: ServerNats;
-
-  const objectToMap = obj =>
-    new Map(Object.keys(obj).map(key => [key, obj[key]]) as any);
+  let untypedServer: any;
 
   beforeEach(() => {
     server = new ServerNats({});
+    untypedServer = server as any;
   });
   describe('listen', () => {
     let client: any;
@@ -39,15 +39,66 @@ describe('ServerNats', () => {
   describe('close', () => {
     const natsClient = { close: sinon.spy() };
     beforeEach(() => {
-      (server as any).natsClient = natsClient;
+      untypedServer.natsClient = natsClient;
     });
-    it('should close natsClient', () => {
-      server.close();
+    it('should close natsClient', async () => {
+      await server.close();
       expect(natsClient.close.called).to.be.true;
     });
+
+    describe('when "gracefulShutdown" is true', () => {
+      const waitForGracePeriod = sinon.spy();
+      const subscriptions = [
+        { unsubscribe: sinon.spy() },
+        { unsubscribe: sinon.spy() },
+      ];
+      beforeEach(() => {
+        (server as any).subscriptions = subscriptions;
+        (server as any).waitForGracePeriod = waitForGracePeriod;
+        (server as any).options.gracefulShutdown = true;
+      });
+
+      it('should unsubscribe all subscriptions', async () => {
+        await server.close();
+        for (const subscription of subscriptions) {
+          expect(subscription.unsubscribe.calledOnce).to.be.true;
+        }
+      });
+
+      it('should call "waitForGracePeriod"', async () => {
+        await server.close();
+        expect(waitForGracePeriod.called).to.be.true;
+      });
+    });
+
+    describe('when "gracefulShutdown" is false', () => {
+      const waitForGracePeriod = sinon.spy();
+      const subscriptions = [
+        { unsubscribe: sinon.spy() },
+        { unsubscribe: sinon.spy() },
+      ];
+      beforeEach(() => {
+        (server as any).subscriptions = subscriptions;
+        (server as any).waitForGracePeriod = waitForGracePeriod;
+        (server as any).options.gracefulShutdown = false;
+      });
+      it('should not unsubscribe all subscriptions', async () => {
+        await server.close();
+        for (const subscription of subscriptions) {
+          expect(subscription.unsubscribe.called).to.be.false;
+        }
+      });
+
+      it('should not call "waitForGracePeriod"', async () => {
+        await server.close();
+        expect(waitForGracePeriod.called).to.be.false;
+      });
+    });
   });
   describe('bindEvents', () => {
     let onSpy: sinon.SinonSpy, subscribeSpy: sinon.SinonSpy, natsClient;
+    const pattern = 'test';
+    const messageHandler = sinon.spy();
 
     beforeEach(() => {
       onSpy = sinon.spy();
@@ -56,16 +107,19 @@ describe('ServerNats', () => {
         on: onSpy,
         subscribe: subscribeSpy,
       };
+      untypedServer.messageHandlers = objectToMap({
+        [pattern]: messageHandler
+      });
     });
     it('should subscribe to each acknowledge patterns', () => {
-      const pattern = 'test';
-      const handler = sinon.spy();
-      (server as any).messageHandlers = objectToMap({
-        [pattern]: handler,
-      });
       server.bindEvents(natsClient);
       expect(subscribeSpy.calledWith(pattern)).to.be.true;
     });
+
+    it('should fill the subscriptions array properly', () => {
+      server.bindEvents(natsClient);
+      expect(server['subscriptions'].length).to.be.equals(1);
+    });
   });
   describe('getMessageHandler', () => {
     it(`should return function`, () => {
@@ -127,7 +181,7 @@ describe('ServerNats', () => {
     });
     it(`should call handler with expected arguments`, async () => {
       const handler = sinon.spy();
-      (server as any).messageHandlers = objectToMap({
+      untypedServer.messageHandlers = objectToMap({
         [channel]: handler,
       });
 
@@ -200,7 +254,7 @@ describe('ServerNats', () => {
 
     it('should call handler with expected arguments', () => {
       const handler = sinon.spy();
-      (server as any).messageHandlers = objectToMap({
+      untypedServer.messageHandlers = objectToMap({
         [channel]: handler,
       });
 
@@ -224,7 +278,7 @@ describe('ServerNats', () => {
     });
 
     it('should log "disconnect" and "error" statuses as "errors"', async () => {
-      const logErrorSpy = sinon.spy((server as any).logger, 'error');
+      const logErrorSpy = sinon.spy(untypedServer.logger, 'error');
       const serverMock = {
         status: sinon.stub().returns({
           async *[Symbol.asyncIterator]() {
@@ -245,7 +299,7 @@ describe('ServerNats', () => {
       );
     });
     it('should log other statuses as "logs"', async () => {
-      const logSpy = sinon.spy((server as any).logger, 'log');
+      const logSpy = sinon.spy(untypedServer.logger, 'log');
       const serverMock = {
         status: sinon.stub().returns({
           async *[Symbol.asyncIterator]() {
diff --git a/packages/microservices/test/server/server-redis.spec.ts b/packages/microservices/test/server/server-redis.spec.ts
index dc2373c91..15645fd28 100644
--- a/packages/microservices/test/server/server-redis.spec.ts
+++ b/packages/microservices/test/server/server-redis.spec.ts
@@ -3,15 +3,15 @@ import * as sinon from 'sinon';
 import { NO_MESSAGE_HANDLER } from '../../constants';
 import { BaseRpcContext } from '../../ctx-host/base-rpc.context';
 import { ServerRedis } from '../../server/server-redis';
+import { objectToMap } from './utils/object-to-map';
 
 describe('ServerRedis', () => {
   let server: ServerRedis;
-
-  const objectToMap = obj =>
-    new Map(Object.keys(obj).map(key => [key, obj[key]]) as any);
+  let untypedServer: any;
 
   beforeEach(() => {
     server = new ServerRedis({});
+    untypedServer = server as any;
   });
   describe('listen', () => {
     let onSpy: sinon.SinonSpy;
@@ -56,8 +56,8 @@ describe('ServerRedis', () => {
     const pub = { quit: sinon.spy() };
     const sub = { quit: sinon.spy() };
     beforeEach(() => {
-      (server as any).pubClient = pub;
-      (server as any).subClient = sub;
+      untypedServer.pubClient = pub;
+      untypedServer.subClient = sub;
     });
     it('should close pub & sub server', () => {
       server.close();
@@ -86,8 +86,8 @@ describe('ServerRedis', () => {
       expect(onSpy.getCall(0).args[0]).to.be.equal('message');
     });
     it('should bind "pmessage" event to handler if wildcards are enabled', () => {
-      (server as any).options = {};
-      (server as any).options.wildcards = true;
+      untypedServer.options = {};
+      untypedServer.options.wildcards = true;
 
       server.bindEvents(psub, null);
       expect(onSpy.getCall(0).args[0]).to.be.equal('pmessage');
@@ -96,7 +96,7 @@ describe('ServerRedis', () => {
     it('should "subscribe" to each pattern if wildcards are disabled', () => {
       const pattern = 'test';
       const handler = sinon.spy();
-      (server as any).messageHandlers = objectToMap({
+      untypedServer.messageHandlers = objectToMap({
         [pattern]: handler,
       });
       server.bindEvents(sub, null);
@@ -104,12 +104,12 @@ describe('ServerRedis', () => {
     });
 
     it('should "psubscribe" to each pattern if wildcards are enabled', () => {
-      (server as any).options = {};
-      (server as any).options.wildcards = true;
+      untypedServer.options = {};
+      untypedServer.options.wildcards = true;
 
       const pattern = 'test';
       const handler = sinon.spy();
-      (server as any).messageHandlers = objectToMap({
+      untypedServer.messageHandlers = objectToMap({
         [pattern]: handler,
       });
       server.bindEvents(psub, null);
@@ -157,7 +157,7 @@ describe('ServerRedis', () => {
     });
     it(`should call handler with expected arguments`, async () => {
       const handler = sinon.spy();
-      (server as any).messageHandlers = objectToMap({
+      untypedServer.messageHandlers = objectToMap({
         [channel]: handler,
       });
       sinon.stub(server, 'parseMessage').callsFake(() => ({ id, data }) as any);
@@ -233,35 +233,35 @@ describe('ServerRedis', () => {
   describe('createRetryStrategy', () => {
     describe('when is terminated', () => {
       it('should return undefined', () => {
-        (server as any).isExplicitlyTerminated = true;
+        untypedServer.isExplicitlyTerminated = true;
         const result = server.createRetryStrategy(0);
         expect(result).to.be.undefined;
       });
     });
     describe('when "retryAttempts" does not exist', () => {
       it('should return undefined', () => {
-        (server as any).options.options = {};
-        (server as any).options.options.retryAttempts = undefined;
+        untypedServer.options.options = {};
+        untypedServer.options.options.retryAttempts = undefined;
 
         expect(server.createRetryStrategy(4)).to.be.undefined;
       });
     });
     describe('when "attempts" count is max', () => {
       it('should return undefined', () => {
-        (server as any).options.options = {};
-        (server as any).options.options.retryAttempts = 3;
+        untypedServer.options.options = {};
+        untypedServer.options.options.retryAttempts = 3;
 
         expect(server.createRetryStrategy(4)).to.be.undefined;
       });
     });
     describe('otherwise', () => {
       it('should return delay (ms)', () => {
-        (server as any).options = {};
-        (server as any).isExplicitlyTerminated = false;
-        (server as any).options.retryAttempts = 3;
-        (server as any).options.retryDelay = 3;
+        untypedServer.options = {};
+        untypedServer.isExplicitlyTerminated = false;
+        untypedServer.options.retryAttempts = 3;
+        untypedServer.options.retryDelay = 3;
         const result = server.createRetryStrategy(2);
-        expect(result).to.be.eql((server as any).options.retryDelay);
+        expect(result).to.be.eql(untypedServer.options.retryDelay);
       });
     });
   });
@@ -271,7 +271,7 @@ describe('ServerRedis', () => {
 
     it('should call handler with expected arguments', () => {
       const handler = sinon.spy();
-      (server as any).messageHandlers = objectToMap({
+      untypedServer.messageHandlers = objectToMap({
         [channel]: handler,
       });
 
diff --git a/packages/microservices/test/server/server-rmq.spec.ts b/packages/microservices/test/server/server-rmq.spec.ts
index 365acd7a6..3e0f51d8c 100644
--- a/packages/microservices/test/server/server-rmq.spec.ts
+++ b/packages/microservices/test/server/server-rmq.spec.ts
@@ -1,18 +1,17 @@
 import { assert, expect } from 'chai';
 import * as sinon from 'sinon';
 import { NO_MESSAGE_HANDLER } from '../../constants';
-import { BaseRpcContext } from '../../ctx-host/base-rpc.context';
-import { ServerRMQ } from '../../server/server-rmq';
 import { RmqContext } from '../../ctx-host';
+import { ServerRMQ } from '../../server/server-rmq';
+import { objectToMap } from './utils/object-to-map';
 
 describe('ServerRMQ', () => {
   let server: ServerRMQ;
-
-  const objectToMap = obj =>
-    new Map(Object.keys(obj).map(key => [key, obj[key]]) as any);
+  let untypedServer: any;
 
   beforeEach(() => {
     server = new ServerRMQ({});
+    untypedServer = server as any;
   });
 
   describe('constructor', () => {
@@ -88,8 +87,8 @@ describe('ServerRMQ', () => {
     const rmqChannel = { close: sinon.spy() };
 
     beforeEach(() => {
-      (server as any).server = rmqServer;
-      (server as any).channel = rmqChannel;
+      untypedServer.server = rmqServer;
+      untypedServer.channel = rmqChannel;
     });
     it('should close server', () => {
       server.close();
@@ -122,7 +121,7 @@ describe('ServerRMQ', () => {
 
     beforeEach(() => {
       sendMessageStub = sinon.stub(server, 'sendMessage').callsFake(() => ({}));
-      (server as any).channel = channel;
+      untypedServer.channel = channel;
     });
     afterEach(() => {
       channel.nack.resetHistory();
@@ -144,7 +143,7 @@ describe('ServerRMQ', () => {
     });
     it('should call handler if exists in handlers object', async () => {
       const handler = sinon.spy();
-      (server as any).messageHandlers = objectToMap({
+      untypedServer.messageHandlers = objectToMap({
         [pattern]: handler as any,
       });
       await server.handleMessage(msg, '');
@@ -158,7 +157,7 @@ describe('ServerRMQ', () => {
         properties: { correlationId: 1 },
       };
       const handler = sinon.spy();
-      (server as any).messageHandlers = objectToMap({
+      untypedServer.messageHandlers = objectToMap({
         [pattern]: handler as any,
       });
 
@@ -167,7 +166,7 @@ describe('ServerRMQ', () => {
       });
     });
     it('should negative acknowledge if message does not exists in handlers object and noAck option is false', async () => {
-      (server as any).noAck = false;
+      untypedServer.noAck = false;
       await server.handleMessage(msg, '');
       expect(channel.nack.calledWith(msg, false, false)).to.be.true;
       expect(
@@ -199,10 +198,10 @@ describe('ServerRMQ', () => {
     let channel: any = {};
 
     beforeEach(() => {
-      (server as any)['queue'] = queue;
-      (server as any)['queueOptions'] = queueOptions;
-      (server as any)['isGlobalPrefetchCount'] = isGlobalPrefetchCount;
-      (server as any)['prefetchCount'] = prefetchCount;
+      untypedServer['queue'] = queue;
+      untypedServer['queueOptions'] = queueOptions;
+      untypedServer['isGlobalPrefetchCount'] = isGlobalPrefetchCount;
+      untypedServer['prefetchCount'] = prefetchCount;
 
       channel = {
         assertQueue: sinon.spy(() => ({})),
@@ -270,7 +269,7 @@ describe('ServerRMQ', () => {
 
     it('should call handler with expected arguments', () => {
       const handler = sinon.spy();
-      (server as any).messageHandlers = objectToMap({
+      untypedServer.messageHandlers = objectToMap({
         [channel]: handler,
       });
 
@@ -285,10 +284,10 @@ describe('ServerRMQ', () => {
     it('should negative acknowledge without retrying if key does not exists in handlers object and noAck option is false', () => {
       const nack = sinon.spy();
       const message = { pattern: 'no-exists', data };
-      (server as any).channel = {
+      untypedServer.channel = {
         nack,
       };
-      (server as any).noAck = false;
+      untypedServer.noAck = false;
       server.handleEvent(channel, message, new RmqContext([message, '', '']));
 
       expect(nack.calledWith(message, false, false)).to.be.true;
@@ -297,10 +296,10 @@ describe('ServerRMQ', () => {
     it('should not negative acknowledge if key does not exists in handlers object but noAck option is true', () => {
       const nack = sinon.spy();
       const message = { pattern: 'no-exists', data };
-      (server as any).channel = {
+      untypedServer.channel = {
         nack,
       };
-      (server as any).noAck = true;
+      untypedServer.noAck = true;
       server.handleEvent(channel, message, new RmqContext([message, '', '']));
 
       expect(nack.calledWith(message, false, false)).not.to.be.true;
diff --git a/packages/microservices/test/server/server-tcp.spec.ts b/packages/microservices/test/server/server-tcp.spec.ts
index 01d01de9c..72f0df73c 100644
--- a/packages/microservices/test/server/server-tcp.spec.ts
+++ b/packages/microservices/test/server/server-tcp.spec.ts
@@ -3,19 +3,20 @@ import * as sinon from 'sinon';
 import { NO_MESSAGE_HANDLER } from '../../constants';
 import { BaseRpcContext } from '../../ctx-host/base-rpc.context';
 import { ServerTCP } from '../../server/server-tcp';
+import { objectToMap } from './utils/object-to-map';
 
 describe('ServerTCP', () => {
   let server: ServerTCP;
-
-  const objectToMap = obj =>
-    new Map(Object.keys(obj).map(key => [key, obj[key]]) as any);
+  let untypedServer: any;
 
   beforeEach(() => {
     server = new ServerTCP({});
+    untypedServer = server as any;
   });
 
   describe('bindHandler', () => {
     const socket = { on: sinon.spy() };
+
     beforeEach(() => {
       sinon.stub(server, 'getSocketInstance' as any).callsFake(() => socket);
     });
@@ -27,7 +28,7 @@ describe('ServerTCP', () => {
   describe('close', () => {
     const tcpServer = { close: sinon.spy() };
     beforeEach(() => {
-      (server as any).server = tcpServer;
+      untypedServer.server = tcpServer;
     });
     it('should close server', () => {
       server.close();
@@ -37,15 +38,15 @@ describe('ServerTCP', () => {
   describe('listen', () => {
     const serverMock = { listen: sinon.spy(), once: sinon.spy() };
     beforeEach(() => {
-      (server as any).server = serverMock;
+      untypedServer.server = serverMock;
     });
     it('should call native listen method with expected arguments', () => {
       const callback = () => {};
       server.listen(callback);
       expect(
         serverMock.listen.calledWith(
-          (server as any).port,
-          (server as any).host,
+          untypedServer.port,
+          untypedServer.host,
           callback,
         ),
       ).to.be.true;
@@ -75,7 +76,7 @@ describe('ServerTCP', () => {
     });
     it('should call handler if exists in handlers object', async () => {
       const handler = sinon.spy();
-      (server as any).messageHandlers = objectToMap({
+      untypedServer.messageHandlers = objectToMap({
         [msg.pattern]: handler as any,
       });
       await server.handleMessage(socket, msg);
@@ -85,33 +86,33 @@ describe('ServerTCP', () => {
   describe('handleClose', () => {
     describe('when is terminated', () => {
       it('should return undefined', () => {
-        (server as any).isExplicitlyTerminated = true;
+        untypedServer.isExplicitlyTerminated = true;
         const result = server.handleClose();
         expect(result).to.be.undefined;
       });
     });
     describe('when "retryAttempts" does not exist', () => {
       it('should return undefined', () => {
-        (server as any).options.retryAttempts = undefined;
+        untypedServer.options.retryAttempts = undefined;
         const result = server.handleClose();
         expect(result).to.be.undefined;
       });
     });
     describe('when "retryAttemptsCount" count is max', () => {
       it('should return undefined', () => {
-        (server as any).options.retryAttempts = 3;
-        (server as any).retryAttemptsCount = 3;
+        untypedServer.options.retryAttempts = 3;
+        untypedServer.retryAttemptsCount = 3;
         const result = server.handleClose();
         expect(result).to.be.undefined;
       });
     });
     describe('otherwise', () => {
       it('should return delay (ms)', () => {
-        (server as any).options = {};
-        (server as any).isExplicitlyTerminated = false;
-        (server as any).options.retryAttempts = 3;
-        (server as any).retryAttemptsCount = 2;
-        (server as any).options.retryDelay = 3;
+        untypedServer.options = {};
+        untypedServer.isExplicitlyTerminated = false;
+        untypedServer.options.retryAttempts = 3;
+        untypedServer.retryAttemptsCount = 2;
+        untypedServer.options.retryDelay = 3;
         const result = server.handleClose();
         expect(result).to.be.not.undefined;
       });
@@ -124,7 +125,7 @@ describe('ServerTCP', () => {
 
     it('should call handler with expected arguments', () => {
       const handler = sinon.spy();
-      (server as any).messageHandlers = objectToMap({
+      untypedServer.messageHandlers = objectToMap({
         [channel]: handler,
       });
 
diff --git a/packages/microservices/test/server/server.spec.ts b/packages/microservices/test/server/server.spec.ts
index ae62ca108..865d0e96e 100644
--- a/packages/microservices/test/server/server.spec.ts
+++ b/packages/microservices/test/server/server.spec.ts
@@ -1,5 +1,5 @@
 import { expect } from 'chai';
-import { lastValueFrom, Observable, of, throwError as _throw } from 'rxjs';
+import { throwError as _throw, lastValueFrom, Observable, of } from 'rxjs';
 import * as sinon from 'sinon';
 import { Server } from '../../server/server';
 
@@ -10,6 +10,7 @@ class TestServer extends Server {
 
 describe('Server', () => {
   const server = new TestServer();
+  const untypedServer = server as any;
   const sandbox = sinon.createSandbox();
   const callback = () => {},
     pattern = { test: 'test pattern' };
@@ -26,7 +27,7 @@ describe('Server', () => {
         .value({ set() {}, has() {} });
 
       const messageHandlersSetSpy = sinon.spy(
-        (server as any).messageHandlers,
+        untypedServer.messageHandlers,
         'set',
       );
       const normalizePatternStub = sinon
@@ -49,7 +50,7 @@ describe('Server', () => {
           const nextHandler: any = () => null;
 
           headHandler.next = nextHandler;
-          (server as any)['messageHandlers'] = new Map([
+          untypedServer['messageHandlers'] = new Map([
             [handlerRoute, headHandler],
           ]);
           const normalizePatternStub = sinon
@@ -80,7 +81,7 @@ describe('Server', () => {
       it(`should call 'transformPatternToRoute' with 'string' argument`, () => {
         const inputServerPattern = 'hello';
         const transformedServerPattern = inputServerPattern;
-        (server as any).getRouteFromPattern(inputServerPattern);
+        untypedServer.getRouteFromPattern(inputServerPattern);
 
         expect(normalizePatternStub.args[0][0]).to.be.equal(
           transformedServerPattern,
@@ -95,7 +96,7 @@ describe('Server', () => {
           controller: 'app',
           use: 'getHello',
         };
-        (server as any).getRouteFromPattern(inputServerPattern);
+        untypedServer.getRouteFromPattern(inputServerPattern);
 
         expect(normalizePatternStub.args[0][0]).to.be.deep.equal(
           transformedServerPattern,
@@ -203,12 +204,9 @@ describe('Server', () => {
         .stub(server as any, 'messageHandlers')
         .value({ get() {}, has() {} });
       messageHandlersGetSpy = sinon
-        .stub((server as any).messageHandlers, 'get')
+        .stub(untypedServer.messageHandlers, 'get')
         .returns(callback);
-      messageHandlersHasSpy = sinon.stub(
-        (server as any).messageHandlers,
-        'has',
-      );
+      messageHandlersHasSpy = sinon.stub(untypedServer.messageHandlers, 'has');
 
       sandbox.stub(server as any, 'getRouteFromPattern').returns(handlerRoute);
     });
diff --git a/packages/microservices/test/server/utils/object-to-map.ts b/packages/microservices/test/server/utils/object-to-map.ts
new file mode 100644
index 000000000..a6a383f60
--- /dev/null
+++ b/packages/microservices/test/server/utils/object-to-map.ts
@@ -0,0 +1,2 @@
+export const objectToMap = (obj: Record<string, any>) =>
+  new Map(Object.keys(obj).map(key => [key, obj[key]]) as any);
diff --git a/packages/platform-express/multer/multer/multer.utils.ts b/packages/platform-express/multer/multer/multer.utils.ts
index 9df215832..62c1a7f10 100644
--- a/packages/platform-express/multer/multer/multer.utils.ts
+++ b/packages/platform-express/multer/multer/multer.utils.ts
@@ -5,7 +5,11 @@ import {
 } from '@nestjs/common';
 import { multerExceptions, busboyExceptions } from './multer.constants';
 
-export function transformException(error: Error | undefined) {
+// Multer may add in a 'field' property to the error
+// https://github.com/expressjs/multer/blob/aa42bea6ac7d0cb8fcb279b15a7278cda805dc63/lib/multer-error.js#L19
+export function transformException(
+  error: (Error & { field?: string }) | undefined,
+) {
   if (!error || error instanceof HttpException) {
     return error;
   }
@@ -19,6 +23,9 @@ export function transformException(error: Error | undefined) {
     case multerExceptions.LIMIT_UNEXPECTED_FILE:
     case multerExceptions.LIMIT_PART_COUNT:
     case multerExceptions.MISSING_FIELD_NAME:
+      if (error.field) {
+        return new BadRequestException(`${error.message} - ${error.field}`);
+      }
       return new BadRequestException(error.message);
     case busboyExceptions.MULTIPART_BOUNDARY_NOT_FOUND:
       return new BadRequestException(error.message);
diff --git a/packages/platform-express/package.json b/packages/platform-express/package.json
index f9dde2036..aec483b08 100644
--- a/packages/platform-express/package.json
+++ b/packages/platform-express/package.json
@@ -1,6 +1,6 @@
 {
   "name": "@nestjs/platform-express",
-  "version": "10.4.6",
+  "version": "10.4.7",
   "description": "Nest - modern, fast, powerful node.js web framework (@platform-express)",
   "author": "Kamil Mysliwiec",
   "license": "MIT",
@@ -25,8 +25,8 @@
     "tslib": "2.7.0"
   },
   "devDependencies": {
-    "@nestjs/common": "10.4.6",
-    "@nestjs/core": "10.4.6"
+    "@nestjs/common": "10.4.7",
+    "@nestjs/core": "10.4.7"
   },
   "peerDependencies": {
     "@nestjs/common": "^10.0.0",
diff --git a/packages/platform-express/test/multer/multer/multer.utils.spec.ts b/packages/platform-express/test/multer/multer/multer.utils.spec.ts
index f3745b936..e6462e409 100644
--- a/packages/platform-express/test/multer/multer/multer.utils.spec.ts
+++ b/packages/platform-express/test/multer/multer/multer.utils.spec.ts
@@ -57,5 +57,16 @@ describe('transformException', () => {
         );
       });
     });
+    describe(`and has a 'field' property`, () => {
+      it('should return the field propery appended to the error message', () => {
+        const err = {
+          message: multerExceptions.LIMIT_UNEXPECTED_FILE,
+          field: 'foo',
+        };
+        expect(transformException(err as any).message).to.equal(
+          `${multerExceptions.LIMIT_UNEXPECTED_FILE} - foo`,
+        );
+      });
+    });
   });
 });
diff --git a/packages/platform-fastify/adapters/fastify-adapter.ts b/packages/platform-fastify/adapters/fastify-adapter.ts
index 5345f3e3c..619c21b0c 100644
--- a/packages/platform-fastify/adapters/fastify-adapter.ts
+++ b/packages/platform-fastify/adapters/fastify-adapter.ts
@@ -320,34 +320,6 @@ export class FastifyAdapter<
     return this.injectRouteOptions('SEARCH', ...args);
   }
 
-  public propfind(...args: any[]) {
-    return this.injectRouteOptions('PROPFIND', ...args);
-  }
-
-  public proppatch(...args: any[]) {
-    return this.injectRouteOptions('PROPPATCH', ...args);
-  }
-
-  public mkcol(...args: any[]) {
-    return this.injectRouteOptions('MKCOL', ...args);
-  }
-
-  public copy(...args: any[]) {
-    return this.injectRouteOptions('COPY', ...args);
-  }
-
-  public move(...args: any[]) {
-    return this.injectRouteOptions('MOVE', ...args);
-  }
-
-  public lock(...args: any[]) {
-    return this.injectRouteOptions('LOCK', ...args);
-  }
-
-  public unlock(...args: any[]) {
-    return this.injectRouteOptions('UNLOCK', ...args);
-  }
-
   public applyVersionFilter(
     handler: Function,
     version: VersionValue,
diff --git a/packages/platform-fastify/interfaces/external/fastify-static-options.interface.ts b/packages/platform-fastify/interfaces/external/fastify-static-options.interface.ts
index 6414a9ed9..e4a434a35 100644
--- a/packages/platform-fastify/interfaces/external/fastify-static-options.interface.ts
+++ b/packages/platform-fastify/interfaces/external/fastify-static-options.interface.ts
@@ -3,9 +3,16 @@
  * @see https://github.com/fastify/fastify-static/blob/master/types/index.d.ts
  * @publicApi
  */
-import { RouteOptions, FastifyRequest } from 'fastify';
+import { RouteOptions, FastifyRequest, FastifyReply } from 'fastify';
 import { Stats } from 'fs';
 
+interface SetHeadersResponse {
+  getHeader: FastifyReply['getHeader'];
+  setHeader: FastifyReply['header'];
+  readonly filename: string;
+  statusCode: number;
+}
+
 interface ExtendedInformation {
   fileCount: number;
   totalFileCount: number;
@@ -33,13 +40,22 @@ interface ListRender {
 }
 
 interface ListOptions {
-  format: 'json' | 'html';
   names: string[];
-  render: ListRender;
   extendedFolderInfo?: boolean;
   jsonFormat?: 'names' | 'extended';
 }
 
+export interface ListOptionsJsonFormat extends ListOptions {
+  format: 'json';
+  // Required when the URL parameter `format=html` exists
+  render?: ListRender;
+}
+
+export interface ListOptionsHtmlFormat extends ListOptions {
+  format: 'html';
+  render: ListRender;
+}
+
 // Passed on to `send`
 interface SendOptions {
   acceptRanges?: boolean;
@@ -55,16 +71,16 @@ interface SendOptions {
 }
 
 export interface FastifyStaticOptions extends SendOptions {
-  root: string | string[];
+  root: string | string[] | URL | URL[];
   prefix?: string;
   prefixAvoidTrailingSlash?: boolean;
   serve?: boolean;
   decorateReply?: boolean;
   schemaHide?: boolean;
-  setHeaders?: (...args: any[]) => void;
+  setHeaders?: (res: SetHeadersResponse, path: string, stat: Stats) => void;
   redirect?: boolean;
   wildcard?: boolean;
-  list?: boolean | ListOptions;
+  list?: boolean | ListOptionsJsonFormat | ListOptionsHtmlFormat;
   allowedPath?: (
     pathName: string,
     root: string,
diff --git a/packages/platform-fastify/interfaces/external/fastify-view-options.interface.ts b/packages/platform-fastify/interfaces/external/fastify-view-options.interface.ts
index 1956ccd1f..7c1959aea 100644
--- a/packages/platform-fastify/interfaces/external/fastify-view-options.interface.ts
+++ b/packages/platform-fastify/interfaces/external/fastify-view-options.interface.ts
@@ -27,4 +27,5 @@ export interface FastifyViewOptions {
   root?: string;
   viewExt?: string;
   propertyName?: string;
+  asyncProperyName?: string;
 }
diff --git a/packages/platform-fastify/interfaces/nest-fastify-application.interface.ts b/packages/platform-fastify/interfaces/nest-fastify-application.interface.ts
index 4ce780d0a..97fd813a2 100644
--- a/packages/platform-fastify/interfaces/nest-fastify-application.interface.ts
+++ b/packages/platform-fastify/interfaces/nest-fastify-application.interface.ts
@@ -1,4 +1,4 @@
-import { INestApplication, HttpServer } from '@nestjs/common';
+import { HttpServer, INestApplication } from '@nestjs/common';
 import {
   FastifyBodyParser,
   FastifyInstance,
@@ -7,14 +7,14 @@ import {
   FastifyPluginCallback,
   FastifyPluginOptions,
   FastifyRegisterOptions,
-  FastifyRequest,
   FastifyReply,
+  FastifyRequest,
   RawServerBase,
   RawServerDefault,
 } from 'fastify';
 import {
-  Chain as LightMyRequestChain,
   InjectOptions,
+  Chain as LightMyRequestChain,
   Response as LightMyRequestResponse,
 } from 'light-my-request';
 import { FastifyStaticOptions, FastifyViewOptions } from './external';
@@ -98,33 +98,19 @@ export interface NestFastifyApplication<
     opts: FastifyListenOptions,
     callback?: (err: Error | null, address: string) => void,
   ): Promise<TServer>;
-  listen(
-    opts?: FastifyListenOptions,
-  ): Promise<TServer>;
+  listen(opts?: FastifyListenOptions): Promise<TServer>;
   listen(
     callback?: (err: Error | null, address: string) => void,
   ): Promise<TServer>;
-  /**
-   * @deprecated Variadic listen method is deprecated. Please use `.listen(optionsObject, callback)` instead. The variadic signature will be removed in `fastify@5`
-   * @see https://github.com/fastify/fastify/pull/3712
-   */
   listen(
     port: number | string,
     callback?: (err: Error | null, address: string) => void,
   ): Promise<TServer>;
-  /**
-   * @deprecated Variadic listen method is deprecated. Please use `.listen(optionsObject, callback)` instead. The variadic signature will be removed in `fastify@5`
-   * @see https://github.com/fastify/fastify/pull/3712
-   */
   listen(
     port: number | string,
     address: string,
     callback?: (err: Error | null, address: string) => void,
   ): Promise<TServer>;
-  /**
-   * @deprecated Variadic listen method is deprecated. Please use `.listen(optionsObject, callback)` instead. The variadic signature will be removed in `fastify@5`
-   * @see https://github.com/fastify/fastify/pull/3712
-   */
   listen(
     port: number | string,
     address: string,
diff --git a/packages/platform-fastify/package.json b/packages/platform-fastify/package.json
index 17e9c191c..0102f3774 100644
--- a/packages/platform-fastify/package.json
+++ b/packages/platform-fastify/package.json
@@ -1,6 +1,6 @@
 {
   "name": "@nestjs/platform-fastify",
-  "version": "10.4.6",
+  "version": "10.4.7",
   "description": "Nest - modern, fast, powerful node.js web framework (@platform-fastify)",
   "author": "Kamil Mysliwiec",
   "license": "MIT",
@@ -18,17 +18,17 @@
     "access": "public"
   },
   "dependencies": {
-    "@fastify/cors": "9.0.1",
-    "@fastify/formbody": "7.4.0",
-    "@fastify/middie": "8.3.3",
-    "fastify": "4.28.1",
-    "light-my-request": "6.1.0",
+    "@fastify/cors": "10.0.1",
+    "@fastify/formbody": "8.0.1",
+    "@fastify/middie": "9.0.2",
+    "fastify": "5.1.0",
+    "light-my-request": "6.3.0",
     "path-to-regexp": "3.3.0",
     "tslib": "2.7.0"
   },
   "peerDependencies": {
-    "@fastify/static": "^6.0.0 || ^7.0.0",
-    "@fastify/view": "^7.0.0 || ^8.0.0",
+    "@fastify/static": "^6.0.0 || ^7.0.0 || ^8.0.0",
+    "@fastify/view": "^7.0.0 || ^8.0.0 || ^9.0.0 || ^10.0.0",
     "@nestjs/common": "^10.0.0",
     "@nestjs/core": "^10.0.0"
   },
diff --git a/packages/platform-socket.io/package.json b/packages/platform-socket.io/package.json
index 2c262ecfc..d1965e083 100644
--- a/packages/platform-socket.io/package.json
+++ b/packages/platform-socket.io/package.json
@@ -1,6 +1,6 @@
 {
   "name": "@nestjs/platform-socket.io",
-  "version": "10.4.6",
+  "version": "10.4.7",
   "description": "Nest - modern, fast, powerful node.js web framework (@platform-socket.io)",
   "author": "Kamil Mysliwiec",
   "license": "MIT",
diff --git a/packages/platform-ws/adapters/ws-adapter.ts b/packages/platform-ws/adapters/ws-adapter.ts
index a1fff0230..f2fbcd4d3 100644
--- a/packages/platform-ws/adapters/ws-adapter.ts
+++ b/packages/platform-ws/adapters/ws-adapter.ts
@@ -25,6 +25,11 @@ type HttpServerRegistryKey = number;
 type HttpServerRegistryEntry = any;
 type WsServerRegistryKey = number;
 type WsServerRegistryEntry = any[];
+type WsData = string | Buffer | ArrayBuffer | Buffer[];
+type WsMessageParser = (data: WsData) => { event: string; data: any } | void;
+type WsAdapterOptions = {
+  messageParser?: WsMessageParser;
+};
 
 const UNDERLYING_HTTP_SERVER_PORT = 0;
 
@@ -41,10 +46,20 @@ export class WsAdapter extends AbstractWsAdapter {
     WsServerRegistryKey,
     WsServerRegistryEntry
   >();
+  protected messageParser: WsMessageParser = data => {
+    return JSON.parse(data.toString());
+  };
 
-  constructor(appOrHttpServer?: INestApplicationContext | any) {
+  constructor(
+    appOrHttpServer?: INestApplicationContext | any,
+    options?: WsAdapterOptions,
+  ) {
     super(appOrHttpServer);
     wsPackage = loadPackage('ws', 'WsAdapter', () => require('ws'));
+
+    if (options?.messageParser) {
+      this.messageParser = options.messageParser;
+    }
   }
 
   public create(
@@ -138,7 +153,10 @@ export class WsAdapter extends AbstractWsAdapter {
     transform: (data: any) => Observable<any>,
   ): Observable<any> {
     try {
-      const message = JSON.parse(buffer.data);
+      const message = this.messageParser(buffer.data);
+      if (!message) {
+        return EMPTY;
+      }
       const messageHandler = handlersMap.get(message.event);
       const { callback } = messageHandler;
       return transform(callback(message.data, message.event));
@@ -179,6 +197,10 @@ export class WsAdapter extends AbstractWsAdapter {
     this.wsServersRegistry.clear();
   }
 
+  public setMessageParser(parser: WsMessageParser) {
+    this.messageParser = parser;
+  }
+
   protected ensureHttpServerExists(
     port: number,
     httpServer = http.createServer(),
diff --git a/packages/platform-ws/package.json b/packages/platform-ws/package.json
index 5fbb19832..625c60bca 100644
--- a/packages/platform-ws/package.json
+++ b/packages/platform-ws/package.json
@@ -1,6 +1,6 @@
 {
   "name": "@nestjs/platform-ws",
-  "version": "10.4.6",
+  "version": "10.4.7",
   "description": "Nest - modern, fast, powerful node.js web framework (@platform-ws)",
   "author": "Kamil Mysliwiec",
   "license": "MIT",
diff --git a/packages/testing/package.json b/packages/testing/package.json
index c6ad7aeb2..38fcfad74 100644
--- a/packages/testing/package.json
+++ b/packages/testing/package.json
@@ -1,6 +1,6 @@
 {
   "name": "@nestjs/testing",
-  "version": "10.4.6",
+  "version": "10.4.7",
   "description": "Nest - modern, fast, powerful node.js web framework (@testing)",
   "author": "Kamil Mysliwiec",
   "license": "MIT",
diff --git a/packages/websockets/exceptions/base-ws-exception-filter.ts b/packages/websockets/exceptions/base-ws-exception-filter.ts
index bcc48b0a6..6f1b74dee 100644
--- a/packages/websockets/exceptions/base-ws-exception-filter.ts
+++ b/packages/websockets/exceptions/base-ws-exception-filter.ts
@@ -46,12 +46,6 @@ export class BaseWsExceptionFilter<TError = any>
       message: MESSAGES.UNKNOWN_EXCEPTION_MESSAGE,
     });
 
-    if (this.isExceptionObject(exception)) {
-      return BaseWsExceptionFilter.logger.error(
-        exception.message,
-        exception.stack,
-      );
-    }
     return BaseWsExceptionFilter.logger.error(exception);
   }
 
diff --git a/packages/websockets/package.json b/packages/websockets/package.json
index c6043ac8f..a153209b1 100644
--- a/packages/websockets/package.json
+++ b/packages/websockets/package.json
@@ -1,6 +1,6 @@
 {
   "name": "@nestjs/websockets",
-  "version": "10.4.6",
+  "version": "10.4.7",
   "description": "Nest - modern, fast, powerful node.js web framework (@websockets)",
   "author": "Kamil Mysliwiec",
   "license": "MIT",
@@ -18,8 +18,8 @@
     "tslib": "2.7.0"
   },
   "devDependencies": {
-    "@nestjs/common": "10.4.6",
-    "@nestjs/core": "10.4.6"
+    "@nestjs/common": "10.4.7",
+    "@nestjs/core": "10.4.7"
   },
   "peerDependencies": {
     "@nestjs/common": "^10.0.0",
diff --git a/packages/websockets/test/web-sockets-controller.spec.ts b/packages/websockets/test/web-sockets-controller.spec.ts
index 86c85d6b8..03d48b0f3 100644
--- a/packages/websockets/test/web-sockets-controller.spec.ts
+++ b/packages/websockets/test/web-sockets-controller.spec.ts
@@ -33,6 +33,7 @@ class NoopAdapter extends AbstractWsAdapter {
 
 describe('WebSocketsController', () => {
   let instance: WebSocketsController;
+  let untypedInstance: any;
   let provider: SocketServerProvider,
     graphInspector: GraphInspector,
     config: ApplicationConfig,
@@ -58,6 +59,7 @@ describe('WebSocketsController', () => {
       contextCreator as any,
       graphInspector,
     );
+    untypedInstance = instance as any;
   });
   describe('connectGatewayToServer', () => {
     let subscribeToServerEvents: sinon.SinonSpy;
@@ -70,7 +72,7 @@ describe('WebSocketsController', () => {
 
     beforeEach(() => {
       subscribeToServerEvents = sinon.spy();
-      (instance as any).subscribeToServerEvents = subscribeToServerEvents;
+      untypedInstance.subscribeToServerEvents = subscribeToServerEvents;
     });
     it('should throw "InvalidSocketPortException" when port is not a number', () => {
       Reflect.defineMetadata(PORT_METADATA, 'test', InvalidGateway);
@@ -126,7 +128,7 @@ describe('WebSocketsController', () => {
       gateway = new Test();
       explorer = new GatewayMetadataExplorer(new MetadataScanner());
       mockExplorer = sinon.mock(explorer);
-      (instance as any).metadataExplorer = explorer;
+      untypedInstance.metadataExplorer = explorer;
 
       handlers = [
         {
@@ -264,32 +266,32 @@ describe('WebSocketsController', () => {
         disconnect: {},
         connection: {},
       };
-      (instance as any).subscribeInitEvent = subscribeInitEvent;
-      (instance as any).getConnectionHandler = getConnectionHandler;
-      (instance as any).subscribeConnectionEvent = subscribeConnectionEvent;
-      (instance as any).subscribeDisconnectEvent = subscribeDisconnectEvent;
+      untypedInstance.subscribeInitEvent = subscribeInitEvent;
+      untypedInstance.getConnectionHandler = getConnectionHandler;
+      untypedInstance.subscribeConnectionEvent = subscribeConnectionEvent;
+      untypedInstance.subscribeDisconnectEvent = subscribeDisconnectEvent;
     });
 
     it('should call "subscribeConnectionEvent" with expected arguments', () => {
-      instance.subscribeEvents(gateway, handlers, server as any);
+      instance.subscribeEvents(gateway, handlers, server);
       expect(subscribeConnectionEvent.calledWith(gateway, server.connection)).to
         .be.true;
     });
     it('should call "subscribeDisconnectEvent" with expected arguments', () => {
-      instance.subscribeEvents(gateway, handlers, server as any);
+      instance.subscribeEvents(gateway, handlers, server);
       expect(subscribeDisconnectEvent.calledWith(gateway, server.disconnect)).to
         .be.true;
     });
     it('should call "subscribeInitEvent" with expected arguments', () => {
-      instance.subscribeEvents(gateway, handlers, server as any);
+      instance.subscribeEvents(gateway, handlers, server);
       expect(subscribeInitEvent.calledWith(gateway, server.init)).to.be.true;
     });
     it('should bind connection handler to server', () => {
-      instance.subscribeEvents(gateway, handlers, server as any);
+      instance.subscribeEvents(gateway, handlers, server);
       expect(onSpy.calledWith('connection', getConnectionHandler())).to.be.true;
     });
     it('should call "getConnectionHandler" with expected arguments', () => {
-      instance.subscribeEvents(gateway, handlers, server as any);
+      instance.subscribeEvents(gateway, handlers, server);
       expect(
         getConnectionHandler.calledWith(
           instance,
@@ -327,9 +329,9 @@ describe('WebSocketsController', () => {
       client = {
         on: onSpy,
       };
-      (instance as any).subscribeDisconnectEvent = subscribeDisconnectEvent;
-      (instance as any).subscribeConnectionEvent = subscribeConnectionEvent;
-      (instance as any).subscribeMessages = subscribeMessages;
+      untypedInstance.subscribeDisconnectEvent = subscribeDisconnectEvent;
+      untypedInstance.subscribeConnectionEvent = subscribeConnectionEvent;
+      untypedInstance.subscribeMessages = subscribeMessages;
 
       fn = instance.getConnectionHandler(
         instance,
@@ -359,7 +361,7 @@ describe('WebSocketsController', () => {
   });
   describe('subscribeInitEvent', () => {
     const gateway = new Test();
-    let event, subscribe: sinon.SinonSpy;
+    let event: any, subscribe: sinon.SinonSpy;
 
     beforeEach(() => {
       subscribe = sinon.spy();
diff --git a/sample/01-cats-app/src/common/pipes/validation.pipe.ts b/sample/01-cats-app/src/common/pipes/validation.pipe.ts
index 9df091a88..1a79ae214 100644
--- a/sample/01-cats-app/src/common/pipes/validation.pipe.ts
+++ b/sample/01-cats-app/src/common/pipes/validation.pipe.ts
@@ -5,7 +5,7 @@ import {
   PipeTransform,
   Type,
 } from '@nestjs/common';
-import { plainToClass } from 'class-transformer';
+import { plainToInstance } from 'class-transformer';
 import { validate } from 'class-validator';
 
 @Injectable()
@@ -15,7 +15,7 @@ export class ValidationPipe implements PipeTransform<any> {
     if (!metatype || !this.toValidate(metatype)) {
       return value;
     }
-    const object = plainToClass(metatype, value);
+    const object = plainToInstance(metatype, value);
     const errors = await validate(object);
     if (errors.length > 0) {
       throw new BadRequestException('Validation failed');
diff --git a/sample/10-fastify/src/common/pipes/validation.pipe.ts b/sample/10-fastify/src/common/pipes/validation.pipe.ts
index 9df091a88..1a79ae214 100644
--- a/sample/10-fastify/src/common/pipes/validation.pipe.ts
+++ b/sample/10-fastify/src/common/pipes/validation.pipe.ts
@@ -5,7 +5,7 @@ import {
   PipeTransform,
   Type,
 } from '@nestjs/common';
-import { plainToClass } from 'class-transformer';
+import { plainToInstance } from 'class-transformer';
 import { validate } from 'class-validator';
 
 @Injectable()
@@ -15,7 +15,7 @@ export class ValidationPipe implements PipeTransform<any> {
     if (!metatype || !this.toValidate(metatype)) {
       return value;
     }
-    const object = plainToClass(metatype, value);
+    const object = plainToInstance(metatype, value);
     const errors = await validate(object);
     if (errors.length > 0) {
       throw new BadRequestException('Validation failed');
