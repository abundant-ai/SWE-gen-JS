diff --git a/.npmrc b/.npmrc
index e72930ead..4c2f52b3b 100644
--- a/.npmrc
+++ b/.npmrc
@@ -1,3 +1,2 @@
-registry=https://registry.npmjs.org
 auto-install-peers=true
 strict-peer-dependencies=false
diff --git a/cypress/helpers/util.ts b/cypress/helpers/util.ts
index aed5d7973..c656f638d 100644
--- a/cypress/helpers/util.ts
+++ b/cypress/helpers/util.ts
@@ -10,7 +10,7 @@ interface CypressConfig {
 type CypressMermaidConfig = MermaidConfig & CypressConfig;
 
 interface CodeObject {
-  code: string | string[];
+  code: string;
   mermaid: CypressMermaidConfig;
 }
 
@@ -25,7 +25,7 @@ const batchId: string =
     : Cypress.env('CYPRESS_COMMIT') || Date.now().toString());
 
 export const mermaidUrl = (
-  graphStr: string | string[],
+  graphStr: string,
   options: CypressMermaidConfig,
   api: boolean
 ): string => {
@@ -82,7 +82,7 @@ export const urlSnapshotTest = (
 };
 
 export const renderGraph = (
-  graphStr: string | string[],
+  graphStr: string,
   options: CypressMermaidConfig = {},
   api = false
 ): void => {
diff --git a/cypress/integration/rendering/sequencediagram.spec.js b/cypress/integration/rendering/sequencediagram.spec.js
index 27e03da9c..765913824 100644
--- a/cypress/integration/rendering/sequencediagram.spec.js
+++ b/cypress/integration/rendering/sequencediagram.spec.js
@@ -930,36 +930,4 @@ context('Sequence diagram', () => {
       });
     });
   });
-  context('render after error', () => {
-    it('should render diagram after fixing destroy participant error', () => {
-      cy.on('uncaught:exception', (err) => {
-        return false;
-      });
-
-      renderGraph([
-        `sequenceDiagram
-    Alice->>Bob: Hello Bob, how are you ?
-    Bob->>Alice: Fine, thank you. And you?
-    create participant Carl
-    Alice->>Carl: Hi Carl!
-    create actor D as Donald
-    Carl->>D: Hi!
-    destroy Carl
-    Alice-xCarl: We are too many
-    destroy Bo
-    Bob->>Alice: I agree`,
-        `sequenceDiagram
-    Alice->>Bob: Hello Bob, how are you ?
-    Bob->>Alice: Fine, thank you. And you?
-    create participant Carl
-    Alice->>Carl: Hi Carl!
-    create actor D as Donald
-    Carl->>D: Hi!
-    destroy Carl
-    Alice-xCarl: We are too many
-    destroy Bob
-    Bob->>Alice: I agree`,
-      ]);
-    });
-  });
 });
diff --git a/docs/syntax/sequenceDiagram.md b/docs/syntax/sequenceDiagram.md
index 2dff973e4..fbfa59d13 100644
--- a/docs/syntax/sequenceDiagram.md
+++ b/docs/syntax/sequenceDiagram.md
@@ -131,14 +131,6 @@ sequenceDiagram
     Bob->>Alice: I agree
 ```
 
-#### Unfixable actor/participant creation/deletion error
-
-If an error of the following type occurs when creating or deleting an actor/participant:
-
-> The destroyed participant **participant-name** does not have an associated destroying message after its declaration. Please check the sequence diagram.
-
-And fixing diagram code does not get rid of this error and rendering of all other diagrams results in the same error, then you need to update the mermaid version to (v\<MERMAID_RELEASE_VERSION>+).
-
 ### Grouping / Box
 
 The actor(s) can be grouped in vertical boxes. You can define a color (if not, it will be transparent) and/or a descriptive label using the following notation:
diff --git a/packages/mermaid/src/diagrams/sequence/sequenceDb.js b/packages/mermaid/src/diagrams/sequence/sequenceDb.js
index ea2c74284..717cc8c09 100644
--- a/packages/mermaid/src/diagrams/sequence/sequenceDb.js
+++ b/packages/mermaid/src/diagrams/sequence/sequenceDb.js
@@ -2,60 +2,57 @@ import { getConfig } from '../../diagram-api/diagramAPI.js';
 import { log } from '../../logger.js';
 import { sanitizeText } from '../common/common.js';
 import {
-  clear as commonClear,
-  getAccDescription,
+  setAccTitle,
   getAccTitle,
+  setDiagramTitle,
   getDiagramTitle,
+  getAccDescription,
   setAccDescription,
-  setAccTitle,
-  setDiagramTitle,
+  clear as commonClear,
 } from '../common/commonDb.js';
-import { ImperativeState } from '../../utils/imperativeState.js';
-
-const state = new ImperativeState(() => ({
-  prevActor: undefined,
-  actors: {},
-  createdActors: {},
-  destroyedActors: {},
-  boxes: [],
-  messages: [],
-  notes: [],
-  sequenceNumbersEnabled: false,
-  wrapEnabled: undefined,
-  currentBox: undefined,
-  lastCreated: undefined,
-  lastDestroyed: undefined,
-}));
+
+let prevActor = undefined;
+let actors = {};
+let createdActors = {};
+let destroyedActors = {};
+let boxes = [];
+let messages = [];
+const notes = [];
+let sequenceNumbersEnabled = false;
+let wrapEnabled;
+let currentBox = undefined;
+let lastCreated = undefined;
+let lastDestroyed = undefined;
 
 export const addBox = function (data) {
-  state.records.boxes.push({
+  boxes.push({
     name: data.text,
     wrap: (data.wrap === undefined && autoWrap()) || !!data.wrap,
     fill: data.color,
     actorKeys: [],
   });
-  state.records.currentBox = state.records.boxes.slice(-1)[0];
+  currentBox = boxes.slice(-1)[0];
 };
 
 export const addActor = function (id, name, description, type) {
-  let assignedBox = state.records.currentBox;
-  const old = state.records.actors[id];
+  let assignedBox = currentBox;
+  const old = actors[id];
   if (old) {
     // If already set and trying to set to a new one throw error
-    if (state.records.currentBox && old.box && state.records.currentBox !== old.box) {
+    if (currentBox && old.box && currentBox !== old.box) {
       throw new Error(
         'A same participant should only be defined in one Box: ' +
           old.name +
           " can't be in '" +
           old.box.name +
           "' and in '" +
-          state.records.currentBox.name +
+          currentBox.name +
           "' at the same time."
       );
     }
 
     // Don't change the box if already
-    assignedBox = old.box ? old.box : state.records.currentBox;
+    assignedBox = old.box ? old.box : currentBox;
     old.box = assignedBox;
 
     // Don't allow description nulling
@@ -72,42 +69,36 @@ export const addActor = function (id, name, description, type) {
     description = { text: name, wrap: null, type };
   }
 
-  state.records.actors[id] = {
+  actors[id] = {
     box: assignedBox,
     name: name,
     description: description.text,
     wrap: (description.wrap === undefined && autoWrap()) || !!description.wrap,
-    prevActor: state.records.prevActor,
+    prevActor: prevActor,
     links: {},
     properties: {},
     actorCnt: null,
     rectData: null,
     type: type || 'participant',
   };
-  if (state.records.prevActor && state.records.actors[state.records.prevActor]) {
-    state.records.actors[state.records.prevActor].nextActor = id;
+  if (prevActor && actors[prevActor]) {
+    actors[prevActor].nextActor = id;
   }
 
-  if (state.records.currentBox) {
-    state.records.currentBox.actorKeys.push(id);
+  if (currentBox) {
+    currentBox.actorKeys.push(id);
   }
-  state.records.prevActor = id;
+  prevActor = id;
 };
 
 const activationCount = (part) => {
   let i;
   let count = 0;
-  for (i = 0; i < state.records.messages.length; i++) {
-    if (
-      state.records.messages[i].type === LINETYPE.ACTIVE_START &&
-      state.records.messages[i].from.actor === part
-    ) {
+  for (i = 0; i < messages.length; i++) {
+    if (messages[i].type === LINETYPE.ACTIVE_START && messages[i].from.actor === part) {
       count++;
     }
-    if (
-      state.records.messages[i].type === LINETYPE.ACTIVE_END &&
-      state.records.messages[i].from.actor === part
-    ) {
+    if (messages[i].type === LINETYPE.ACTIVE_END && messages[i].from.actor === part) {
       count--;
     }
   }
@@ -115,7 +106,7 @@ const activationCount = (part) => {
 };
 
 export const addMessage = function (idFrom, idTo, message, answer) {
-  state.records.messages.push({
+  messages.push({
     from: idFrom,
     to: idTo,
     message: message.text,
@@ -146,7 +137,7 @@ export const addSignal = function (
       throw error;
     }
   }
-  state.records.messages.push({
+  messages.push({
     from: idFrom,
     to: idTo,
     message: message.text,
@@ -158,58 +149,63 @@ export const addSignal = function (
 };
 
 export const hasAtLeastOneBox = function () {
-  return state.records.boxes.length > 0;
+  return boxes.length > 0;
 };
 
 export const hasAtLeastOneBoxWithTitle = function () {
-  return state.records.boxes.some((b) => b.name);
+  return boxes.some((b) => b.name);
 };
 
 export const getMessages = function () {
-  return state.records.messages;
+  return messages;
 };
 
 export const getBoxes = function () {
-  return state.records.boxes;
+  return boxes;
 };
 export const getActors = function () {
-  return state.records.actors;
+  return actors;
 };
 export const getCreatedActors = function () {
-  return state.records.createdActors;
+  return createdActors;
 };
 export const getDestroyedActors = function () {
-  return state.records.destroyedActors;
+  return destroyedActors;
 };
 export const getActor = function (id) {
-  return state.records.actors[id];
+  return actors[id];
 };
 export const getActorKeys = function () {
-  return Object.keys(state.records.actors);
+  return Object.keys(actors);
 };
 export const enableSequenceNumbers = function () {
-  state.records.sequenceNumbersEnabled = true;
+  sequenceNumbersEnabled = true;
 };
 export const disableSequenceNumbers = function () {
-  state.records.sequenceNumbersEnabled = false;
+  sequenceNumbersEnabled = false;
 };
-export const showSequenceNumbers = () => state.records.sequenceNumbersEnabled;
+export const showSequenceNumbers = () => sequenceNumbersEnabled;
 
 export const setWrap = function (wrapSetting) {
-  state.records.wrapEnabled = wrapSetting;
+  wrapEnabled = wrapSetting;
 };
 
 export const autoWrap = () => {
   // if setWrap has been called, use that value, otherwise use the value from the config
   // TODO: refactor, always use the config value let setWrap update the config value
-  if (state.records.wrapEnabled !== undefined) {
-    return state.records.wrapEnabled;
+  if (wrapEnabled !== undefined) {
+    return wrapEnabled;
   }
   return getConfig().sequence.wrap;
 };
 
 export const clear = function () {
-  state.reset();
+  actors = {};
+  createdActors = {};
+  destroyedActors = {};
+  boxes = [];
+  messages = [];
+  sequenceNumbersEnabled = false;
   commonClear();
 };
 
@@ -251,7 +247,7 @@ export const parseBoxData = function (str) {
     }
   }
 
-  return {
+  const boxData = {
     color: color,
     text:
       title !== undefined
@@ -266,6 +262,7 @@ export const parseBoxData = function (str) {
           : undefined
         : undefined,
   };
+  return boxData;
 };
 
 export const LINETYPE = {
@@ -324,8 +321,8 @@ export const addNote = function (actor, placement, message) {
   // eslint-disable-next-line unicorn/prefer-spread
   const actors = [].concat(actor, actor);
 
-  state.records.notes.push(note);
-  state.records.messages.push({
+  notes.push(note);
+  messages.push({
     from: actors[0],
     to: actors[1],
     message: message.text,
@@ -417,7 +414,7 @@ function insertProperties(actor, properties) {
  *
  */
 function boxEnd() {
-  state.records.currentBox = undefined;
+  currentBox = undefined;
 }
 
 export const addDetails = function (actorId, text) {
@@ -471,7 +468,7 @@ export const apply = function (param) {
   } else {
     switch (param.type) {
       case 'sequenceIndex':
-        state.records.messages.push({
+        messages.push({
           from: undefined,
           to: undefined,
           message: {
@@ -487,18 +484,18 @@ export const apply = function (param) {
         addActor(param.actor, param.actor, param.description, param.draw);
         break;
       case 'createParticipant':
-        if (state.records.actors[param.actor]) {
+        if (actors[param.actor]) {
           throw new Error(
             "It is not possible to have actors with the same id, even if one is destroyed before the next is created. Use 'AS' aliases to simulate the behavior"
           );
         }
-        state.records.lastCreated = param.actor;
+        lastCreated = param.actor;
         addActor(param.actor, param.actor, param.description, param.draw);
-        state.records.createdActors[param.actor] = state.records.messages.length;
+        createdActors[param.actor] = messages.length;
         break;
       case 'destroyParticipant':
-        state.records.lastDestroyed = param.actor;
-        state.records.destroyedActors[param.actor] = state.records.messages.length;
+        lastDestroyed = param.actor;
+        destroyedActors[param.actor] = messages.length;
         break;
       case 'activeStart':
         addSignal(param.actor, undefined, undefined, param.signalType);
@@ -522,28 +519,25 @@ export const apply = function (param) {
         addDetails(param.actor, param.text);
         break;
       case 'addMessage':
-        if (state.records.lastCreated) {
-          if (param.to !== state.records.lastCreated) {
+        if (lastCreated) {
+          if (param.to !== lastCreated) {
             throw new Error(
               'The created participant ' +
-                state.records.lastCreated +
+                lastCreated +
                 ' does not have an associated creating message after its declaration. Please check the sequence diagram.'
             );
           } else {
-            state.records.lastCreated = undefined;
+            lastCreated = undefined;
           }
-        } else if (state.records.lastDestroyed) {
-          if (
-            param.to !== state.records.lastDestroyed &&
-            param.from !== state.records.lastDestroyed
-          ) {
+        } else if (lastDestroyed) {
+          if (param.to !== lastDestroyed && param.from !== lastDestroyed) {
             throw new Error(
               'The destroyed participant ' +
-                state.records.lastDestroyed +
+                lastDestroyed +
                 ' does not have an associated destroying message after its declaration. Please check the sequence diagram.'
             );
           } else {
-            state.records.lastDestroyed = undefined;
+            lastDestroyed = undefined;
           }
         }
         addSignal(param.from, param.to, param.msg, param.signalType, param.activate);
diff --git a/packages/mermaid/src/docs/syntax/sequenceDiagram.md b/packages/mermaid/src/docs/syntax/sequenceDiagram.md
index e7df5d8c9..cdcdaffeb 100644
--- a/packages/mermaid/src/docs/syntax/sequenceDiagram.md
+++ b/packages/mermaid/src/docs/syntax/sequenceDiagram.md
@@ -83,14 +83,6 @@ sequenceDiagram
     Bob->>Alice: I agree
 ```
 
-#### Unfixable actor/participant creation/deletion error
-
-If an error of the following type occurs when creating or deleting an actor/participant:
-
-> The destroyed participant **participant-name** does not have an associated destroying message after its declaration. Please check the sequence diagram.
-
-And fixing diagram code does not get rid of this error and rendering of all other diagrams results in the same error, then you need to update the mermaid version to (v<MERMAID_RELEASE_VERSION>+).
-
 ### Grouping / Box
 
 The actor(s) can be grouped in vertical boxes. You can define a color (if not, it will be transparent) and/or a descriptive label using the following notation:
diff --git a/packages/mermaid/src/utils/imperativeState.spec.ts b/packages/mermaid/src/utils/imperativeState.spec.ts
deleted file mode 100644
index e7f9ea9ad..000000000
--- a/packages/mermaid/src/utils/imperativeState.spec.ts
+++ /dev/null
@@ -1,60 +0,0 @@
-import { ImperativeState } from './imperativeState.js';
-
-describe('createImperativeState', () => {
-  it('should create state with values from initializer', () => {
-    const baz = {
-      flag: false,
-    };
-
-    const state = new ImperativeState(() => ({
-      foo: undefined as number | undefined,
-      bar: [] as string[],
-      baz,
-    }));
-
-    expect(state.records.foo).toBeUndefined();
-    expect(state.records.bar).toEqual([]);
-    expect(state.records.baz).toBe(baz);
-  });
-
-  it('should update records', () => {
-    const state = new ImperativeState(() => ({
-      foo: undefined as number | undefined,
-      bar: [] as string[],
-      baz: {
-        flag: false,
-      },
-    }));
-
-    state.records.foo = 5;
-    state.records.bar = ['hello'];
-    state.records.baz.flag = true;
-
-    expect(state.records.foo).toEqual(5);
-    expect(state.records.bar).toEqual(['hello']);
-    expect(state.records.baz).toEqual({
-      flag: true,
-    });
-  });
-
-  it('should reset records', () => {
-    const state = new ImperativeState(() => ({
-      foo: undefined as number | undefined,
-      bar: [] as string[],
-      baz: {
-        flag: false,
-      },
-    }));
-
-    state.records.foo = 5;
-    state.records.bar = ['hello'];
-    state.records.baz.flag = true;
-    state.reset();
-
-    expect(state.records.foo).toBeUndefined();
-    expect(state.records.bar).toEqual([]);
-    expect(state.records.baz).toEqual({
-      flag: false,
-    });
-  });
-});
diff --git a/packages/mermaid/src/utils/imperativeState.ts b/packages/mermaid/src/utils/imperativeState.ts
deleted file mode 100644
index dcadeee1f..000000000
--- a/packages/mermaid/src/utils/imperativeState.ts
+++ /dev/null
@@ -1,37 +0,0 @@
-/**
- * Resettable state storage.
- * @example
- * ```
- * const state = new ImperativeState(() => {
- *   foo: undefined as string | undefined,
- *   bar: [] as number[],
- *   baz: 1 as number | undefined,
- * });
- *
- * state.records.foo = "hi";
- * console.log(state.records.foo); // prints "hi";
- * state.reset();
- * console.log(state.records.foo); // prints "default";
- *
- * // typeof state.records:
- * // {
- * //   foo: string | undefined, // actual: undefined
- * //   bar: number[],           // actual: []
- * //   baz: number | undefined, // actual: 1
- * // }
- * ```
- */
-export class ImperativeState<S extends Record<string, unknown>> {
-  public records: S;
-
-  /**
-   * @param init - Function that creates the default state.
-   */
-  constructor(private init: () => S) {
-    this.records = this.init();
-  }
-
-  reset() {
-    this.records = this.init();
-  }
-}
