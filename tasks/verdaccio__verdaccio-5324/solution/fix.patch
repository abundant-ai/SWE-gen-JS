diff --git a/.changeset/gold-parents-shave.md b/.changeset/gold-parents-shave.md
new file mode 100644
index 000000000..22b1a67ca
--- /dev/null
+++ b/.changeset/gold-parents-shave.md
@@ -0,0 +1,7 @@
+---
+'@verdaccio/core': minor
+'@verdaccio/node-api': minor
+'@verdaccio/config': minor
+---
+
+feat: getListenAddress getConfigParsed methods
diff --git a/packages/config/src/address.ts b/packages/config/src/address.ts
new file mode 100644
index 000000000..8f0a400c2
--- /dev/null
+++ b/packages/config/src/address.ts
@@ -0,0 +1,136 @@
+import createDebug from 'debug';
+
+import { DEFAULT_DOMAIN, DEFAULT_PORT, DEFAULT_PROTOCOL } from '@verdaccio/core';
+import { Logger } from '@verdaccio/types';
+
+const debug = createDebug('verdaccio:config:address');
+
+export interface ListenAddress {
+  proto: string;
+  host?: string;
+  port?: string;
+  path?: string;
+}
+
+/**
+ * Parse an internet address
+ * Allow:
+ - https:localhost:1234        - protocol + host + port
+ - localhost:1234              - host + port
+ - 1234                        - port
+ - http::1234                  - protocol + port
+ - https://localhost:443/      - full url + https
+ - http://[::1]:443/           - ipv6
+ - unix:/tmp/http.sock         - unix sockets
+ - https://unix:/tmp/http.sock - unix sockets (https)
+ * @param {*} urlAddress the internet address definition
+ * @return {Object|Null} literal object that represent the address parsed
+ */
+export function parseAddress(urlAddress: string): ListenAddress | null {
+  //
+  // TODO: refactor it to something more reasonable?
+  //
+  //        protocol :  //      (  host  )|(    ipv6     ):  port  /
+  const urlPattern = /^((https?):(\/\/)?)?((([^\/:]*)|\[([^\[\]]+)\]):)?(\d+)\/?$/.exec(urlAddress);
+
+  if (urlPattern) {
+    return {
+      proto: urlPattern[2] || DEFAULT_PROTOCOL,
+      host: urlPattern[6] || urlPattern[7] || DEFAULT_DOMAIN,
+      port: urlPattern[8] || DEFAULT_PORT,
+    };
+  }
+
+  const unixPattern = /^(?:(https?):\/\/)?unix:(\/.*)$/.exec(urlAddress);
+  if (!unixPattern) {
+    // if we cannot match the unix pattern, we return null
+    // this is to avoid returning a wrong object
+    return null;
+  }
+
+  return {
+    host: unixPattern[2],
+    proto: unixPattern[1] || 'unix',
+    path: unixPattern[2],
+  };
+}
+
+function addrToString(a: ListenAddress): string {
+  return a.proto === 'unix' ? `unix:${a.host}` : `${a.proto}://${a.host}:${a.port}`;
+}
+
+/**
+ * Retrieve all addresses defined in the config file.
+ * Verdaccio is able to listen multiple ports
+ * @param {String} argListen
+ * @param {String} configListen
+ * eg:
+ *  listen:
+ - localhost:5555
+ - localhost:5557
+ @return {Array}
+ */
+export function getListenAddress(listen: (string | void)[], logger: Logger): ListenAddress {
+  debug('getListenAddress called with %o', listen);
+
+  if (!listen) {
+    debug('No listen address provided, using default');
+    return { proto: DEFAULT_PROTOCOL, host: DEFAULT_DOMAIN, port: DEFAULT_PORT };
+  }
+
+  if (Array.isArray(listen)) {
+    const filteredListen = listen.filter((item) => typeof item === 'string');
+
+    if (filteredListen.length === 0) {
+      throw new Error('Listen addresses array cannot be empty');
+    }
+
+    const invalid: string[] = [];
+
+    for (const raw of filteredListen) {
+      const candidate = parseAddress(raw as string);
+      if (candidate) {
+        debug('valid listen address found: %o', candidate);
+
+        invalid.forEach((bad) =>
+          logger.warn(
+            { addr: bad },
+            'invalid address - @{addr}, we expect a port (e.g. "4873"), ' +
+              'host:port (e.g. "localhost:4873"), full url ' +
+              '(e.g. "http://localhost:4873/") or unix:/path/socket'
+          )
+        );
+
+        if (listen.length > 1) {
+          logger.warn(
+            `Multiple listen addresses are not supported, using the first valid one ${addrToString(
+              candidate
+            )}`
+          );
+        }
+        return candidate;
+      }
+      invalid.push(raw as string);
+    }
+
+    invalid.forEach((bad) =>
+      logger.warn(
+        { addr: bad },
+        'invalid address - @{addr}, we expect a port (e.g. "4873"), ' +
+          'host:port (e.g. "localhost:4873"), full url ' +
+          '(e.g. "http://localhost:4873/") or unix:/path/socket'
+      )
+    );
+    throw new Error('No valid listen addresses found in configuration array');
+  }
+
+  const single = parseAddress(listen);
+  if (!single) {
+    throw new Error(
+      `Invalid address - ${listen}, we expect a port (e.g. "4873"), ` +
+        `host:port (e.g. "localhost:4873"), full url ` +
+        `(e.g. "http://localhost:4873/") or unix:/path/socket`
+    );
+  }
+  return single;
+}
diff --git a/packages/config/src/conf/index.ts b/packages/config/src/conf/index.ts
index a04a386df..2e64d0315 100644
--- a/packages/config/src/conf/index.ts
+++ b/packages/config/src/conf/index.ts
@@ -2,7 +2,7 @@ import { join } from 'node:path';
 
 import { parseConfigFile } from '../parse';
 
-export function getDefaultConfig(fileName = 'default.yaml') {
+export function getDefaultConfig(fileName: string = 'default.yaml') {
   const file = join(__dirname, `./${fileName}`);
   return parseConfigFile(file);
 }
diff --git a/packages/config/src/index.ts b/packages/config/src/index.ts
index 730e4910e..c05b476e0 100644
--- a/packages/config/src/index.ts
+++ b/packages/config/src/index.ts
@@ -3,10 +3,11 @@ export * from './config-path';
 export * from './token';
 export * from './config-utils';
 export * from './package-access';
-export { fromJStoYAML, parseConfigFile } from './parse';
+export { fromJStoYAML, parseConfigFile, getConfigParsed } from './parse';
 export * from './uplinks';
 export * from './security';
 export * from './agent';
 export * from './user';
 export { default as ConfigBuilder } from './builder';
 export { getDefaultConfig } from './conf';
+export * from './address';
diff --git a/packages/config/src/parse.ts b/packages/config/src/parse.ts
index abb7a40d3..2396752a9 100644
--- a/packages/config/src/parse.ts
+++ b/packages/config/src/parse.ts
@@ -2,10 +2,12 @@ import buildDebug from 'debug';
 import YAML from 'js-yaml';
 import { isObject } from 'lodash';
 import fs from 'node:fs';
+import path from 'node:path';
 
-import { APP_ERROR } from '@verdaccio/core';
+import { API_ERROR, APP_ERROR } from '@verdaccio/core';
 import { ConfigYaml } from '@verdaccio/types';
 
+import { findConfigFile } from './config-path';
 import { fileExists } from './config-utils';
 
 const debug = buildDebug('verdaccio:config:parse');
@@ -61,3 +63,48 @@ export function fromJStoYAML(config: Partial<ConfigYaml>): string | null {
     throw new Error(`config is not a valid object`);
   }
 }
+
+/**
+ * Parses and returns a configuration object of type `ConfigYaml`.
+ *
+ * If a string or `undefined` is provided, it is interpreted as a path to a config file
+ * (or uses a default location). The config file is then loaded and parsed.
+ * If an object is provided, it is assumed to be a pre-parsed configuration.
+ * Backward compability: ensures the returned configuration object has a `self_path` property set,
+ * either to the config file path or to a property within the object.
+ *
+ * @param {string | ConfigYaml} [config] - Optional. A path to the configuration file (string),
+ *                                         a pre-parsed config object, or `undefined`.
+ * @returns {ConfigYaml} The parsed configuration object with a guaranteed `self_path` property.
+ * @throws {Error} If the provided config is neither a string, undefined, nor an object.
+ */
+export function getConfigParsed(config?: string | ConfigYaml): ConfigYaml {
+  debug('getConfigParsed called with config: %o', typeof config);
+  let configurationParsed: ConfigYaml;
+  if (config === undefined || typeof config === 'string') {
+    debug('using default configuration');
+    const configPathLocation = findConfigFile(config);
+    configurationParsed = parseConfigFile(configPathLocation);
+    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
+    // @ts-expect-error
+    if (!configurationParsed.self_path) {
+      debug('self_path not defined, using config path location');
+      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
+      // @ts-expect-error
+      configurationParsed.self_path = path.resolve(configPathLocation);
+    }
+  } else if (typeof config === 'object' && config !== null) {
+    configurationParsed = config;
+    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
+    // @ts-expect-error
+    if (!configurationParsed.self_path) {
+      debug('self_path not defined, using config path location');
+      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
+      // @ts-expect-error
+      configurationParsed.self_path = configurationParsed.configPath;
+    }
+  } else {
+    throw new Error(API_ERROR.CONFIG_BAD_FORMAT);
+  }
+  return configurationParsed;
+}
diff --git a/packages/core/core/src/constants.ts b/packages/core/core/src/constants.ts
index 033b22785..bc4c63ca2 100644
--- a/packages/core/core/src/constants.ts
+++ b/packages/core/core/src/constants.ts
@@ -163,3 +163,7 @@ export const PLUGIN_CATEGORY = {
   FILTER: 'filter',
   THEME: 'theme',
 };
+
+export const DEFAULT_PORT = '4873';
+export const DEFAULT_PROTOCOL = 'http';
+export const DEFAULT_DOMAIN = 'localhost';
diff --git a/packages/core/core/src/index.ts b/packages/core/core/src/index.ts
index 4818bf0f9..4919d4ddc 100644
--- a/packages/core/core/src/index.ts
+++ b/packages/core/core/src/index.ts
@@ -31,6 +31,9 @@ export {
   PLUGIN_PREFIX,
   PLUGIN_UI_PREFIX,
   HtpasswdHashAlgorithm,
+  DEFAULT_DOMAIN,
+  DEFAULT_PORT,
+  DEFAULT_PROTOCOL,
 } from './constants';
 export {
   authUtils,
diff --git a/packages/node-api/src/cli-utils.ts b/packages/node-api/src/cli-utils.ts
deleted file mode 100644
index 56a2f1740..000000000
--- a/packages/node-api/src/cli-utils.ts
+++ /dev/null
@@ -1,84 +0,0 @@
-import { warningUtils } from '@verdaccio/core';
-
-export const DEFAULT_PORT = '4873';
-export const DEFAULT_PROTOCOL = 'http';
-export const DEFAULT_DOMAIN = 'localhost';
-/**
- * Parse an internet address
- * Allow:
- - https:localhost:1234        - protocol + host + port
- - localhost:1234              - host + port
- - 1234                        - port
- - http::1234                  - protocol + port
- - https://localhost:443/      - full url + https
- - http://[::1]:443/           - ipv6
- - unix:/tmp/http.sock         - unix sockets
- - https://unix:/tmp/http.sock - unix sockets (https)
- * @param {*} urlAddress the internet address definition
- * @return {Object|Null} literal object that represent the address parsed
- */
-export function parseAddress(urlAddress: any): any {
-  //
-  // TODO: refactor it to something more reasonable?
-  //
-  //        protocol :  //      (  host  )|(    ipv6     ):  port  /
-  let urlPattern = /^((https?):(\/\/)?)?((([^\/:]*)|\[([^\[\]]+)\]):)?(\d+)\/?$/.exec(urlAddress);
-
-  if (urlPattern) {
-    return {
-      proto: urlPattern[2] || DEFAULT_PROTOCOL,
-      host: urlPattern[6] || urlPattern[7] || DEFAULT_DOMAIN,
-      port: urlPattern[8] || DEFAULT_PORT,
-    };
-  }
-
-  urlPattern = /^((https?):(\/\/)?)?unix:(.*)$/.exec(urlAddress);
-
-  if (urlPattern) {
-    return {
-      proto: urlPattern[2] || DEFAULT_PROTOCOL,
-      path: urlPattern[4],
-    };
-  }
-
-  return null;
-}
-
-/**
- * Retrieve all addresses defined in the config file.
- * Verdaccio is able to listen multiple ports
- * @param {String} argListen
- * @param {String} configListen
- * eg:
- *  listen:
- - localhost:5555
- - localhost:5557
- @return {Array}
- */
-export function getListListenAddresses(argListen: string | void, configListen: any): any {
-  // command line || config file || default
-  let addresses;
-  if (argListen) {
-    addresses = [argListen];
-  } else if (Array.isArray(configListen)) {
-    addresses = configListen;
-    process.emitWarning('multiple addresses will be deprecated in the next major, only use one');
-  } else if (configListen) {
-    addresses = [configListen];
-  } else {
-    addresses = [DEFAULT_PORT];
-  }
-  addresses = addresses
-    .map(function (addr): string {
-      const parsedAddr = parseAddress(addr);
-
-      if (!parsedAddr) {
-        warningUtils.emit(warningUtils.Codes.VERWAR004, addr);
-      }
-
-      return parsedAddr;
-    })
-    .filter(Boolean);
-
-  return addresses;
-}
diff --git a/packages/node-api/src/server.ts b/packages/node-api/src/server.ts
index 641f71b0b..2241e855e 100644
--- a/packages/node-api/src/server.ts
+++ b/packages/node-api/src/server.ts
@@ -7,14 +7,13 @@ import http from 'node:http';
 import https from 'node:https';
 import url from 'node:url';
 
-import { findConfigFile, parseConfigFile } from '@verdaccio/config';
-import { API_ERROR } from '@verdaccio/core';
-import { setup } from '@verdaccio/logger';
+import { getConfigParsed, getListenAddress } from '@verdaccio/config';
+import { DEFAULT_PORT } from '@verdaccio/core';
+import { logger, setup } from '@verdaccio/logger';
 import expressServer from '@verdaccio/server';
 import fastifyServer from '@verdaccio/server-fastify';
 import { ConfigYaml, HttpsConfKeyCert, HttpsConfPfx } from '@verdaccio/types';
 
-import { getListListenAddresses } from './cli-utils';
 import { displayExperimentsInfoBox } from './experiments';
 
 const debug = buildDebug('verdaccio:node-api');
@@ -121,9 +120,9 @@ export async function initServer(
   pkgName: string
 ): Promise<void> {
   return new Promise(async (resolve, reject) => {
-    // FIXME: get only the first match, the multiple address will be removed
-    const [addr] = getListListenAddresses(port, config.listen);
     const logger = setup(config?.log as any);
+    const combined: string | undefined | any[] = [port, config?.listen, DEFAULT_PORT];
+    const addr = getListenAddress(combined, logger);
     displayExperimentsInfoBox(config.flags);
 
     let app;
@@ -198,20 +197,12 @@ export async function initServer(
  * @param config
  */
 export async function runServer(config?: string | ConfigYaml): Promise<any> {
-  let configurationParsed: ConfigYaml;
-  if (config === undefined || typeof config === 'string') {
-    const configPathLocation = findConfigFile(config);
-    configurationParsed = parseConfigFile(configPathLocation);
-  } else if (_.isObject(config)) {
-    configurationParsed = config;
-  } else {
-    throw new Error(API_ERROR.CONFIG_BAD_FORMAT);
-  }
-
+  const configurationParsed = getConfigParsed(config);
   setup(configurationParsed.log as any);
   displayExperimentsInfoBox(configurationParsed.flags);
   // FIXME: get only the first match, the multiple address will be removed
-  const [addr] = getListListenAddresses(undefined, configurationParsed.listen);
+  const combined: string | undefined | any[] = [configurationParsed?.listen, DEFAULT_PORT];
+  const addr = getListenAddress(combined, logger);
   const app = await expressServer(configurationParsed);
   return createServerFactory(configurationParsed, addr, app);
 }
