diff --git a/.changeset/small-seas-laugh.md b/.changeset/small-seas-laugh.md
new file mode 100644
index 0000000000..2846ef08a7
--- /dev/null
+++ b/.changeset/small-seas-laugh.md
@@ -0,0 +1,5 @@
+---
+"@biomejs/biome": minor
+---
+
+Added the rule [`noRedundantAlt`](https://biomejs.dev/linter/rules/no-redundant-alt/) to HTML. The rule enforces that the `img` element `alt` attribute does not contain the words “image”, “picture”, or “photo”.
diff --git a/crates/biome_html_analyze/src/lint/a11y.rs b/crates/biome_html_analyze/src/lint/a11y.rs
index bf58bab83f..73946eb0f7 100644
--- a/crates/biome_html_analyze/src/lint/a11y.rs
+++ b/crates/biome_html_analyze/src/lint/a11y.rs
@@ -8,6 +8,7 @@ pub mod no_autofocus;
 pub mod no_distracting_elements;
 pub mod no_header_scope;
 pub mod no_positive_tabindex;
+pub mod no_redundant_alt;
 pub mod no_svg_without_title;
 pub mod use_alt_text;
 pub mod use_aria_props_for_role;
@@ -15,4 +16,4 @@ pub mod use_button_type;
 pub mod use_html_lang;
 pub mod use_iframe_title;
 pub mod use_valid_aria_role;
-declare_lint_group! { pub A11y { name : "a11y" , rules : [self :: no_access_key :: NoAccessKey , self :: no_autofocus :: NoAutofocus , self :: no_distracting_elements :: NoDistractingElements , self :: no_header_scope :: NoHeaderScope , self :: no_positive_tabindex :: NoPositiveTabindex , self :: no_svg_without_title :: NoSvgWithoutTitle , self :: use_alt_text :: UseAltText , self :: use_aria_props_for_role :: UseAriaPropsForRole , self :: use_button_type :: UseButtonType , self :: use_html_lang :: UseHtmlLang , self :: use_iframe_title :: UseIframeTitle , self :: use_valid_aria_role :: UseValidAriaRole ,] } }
+declare_lint_group! { pub A11y { name : "a11y" , rules : [self :: no_access_key :: NoAccessKey , self :: no_autofocus :: NoAutofocus , self :: no_distracting_elements :: NoDistractingElements , self :: no_header_scope :: NoHeaderScope , self :: no_positive_tabindex :: NoPositiveTabindex , self :: no_redundant_alt :: NoRedundantAlt , self :: no_svg_without_title :: NoSvgWithoutTitle , self :: use_alt_text :: UseAltText , self :: use_aria_props_for_role :: UseAriaPropsForRole , self :: use_button_type :: UseButtonType , self :: use_html_lang :: UseHtmlLang , self :: use_iframe_title :: UseIframeTitle , self :: use_valid_aria_role :: UseValidAriaRole ,] } }
diff --git a/crates/biome_html_analyze/src/lint/a11y/no_redundant_alt.rs b/crates/biome_html_analyze/src/lint/a11y/no_redundant_alt.rs
new file mode 100644
index 0000000000..3815042f47
--- /dev/null
+++ b/crates/biome_html_analyze/src/lint/a11y/no_redundant_alt.rs
@@ -0,0 +1,121 @@
+use biome_analyze::{
+    Ast, Rule, RuleDiagnostic, RuleSource, context::RuleContext, declare_lint_rule,
+};
+use biome_console::markup;
+use biome_diagnostics::Severity;
+use biome_html_syntax::element_ext::AnyHtmlTagElement;
+use biome_html_syntax::{AnyHtmlAttributeInitializer, HtmlFileSource};
+use biome_rowan::AstNode;
+use biome_rule_options::is_redundant_alt;
+use biome_rule_options::no_redundant_alt::NoRedundantAltOptions;
+
+declare_lint_rule! {
+    /// Enforce `img` alt prop does not contain the word "image", "picture", or "photo".
+    ///
+    /// The rule will first check if `aria-hidden` is truthy to determine whether to enforce the rule. If the image is
+    /// hidden, then the rule will always succeed.
+    ///
+    /// ## Examples
+    ///
+    /// ### Invalid
+    ///
+    /// ```html,expect_diagnostic
+    /// <img src="src" alt="photo content" />;
+    /// ```
+    ///
+    /// ```html,expect_diagnostic
+    /// <img alt="picture of cool person" aria-hidden="false" />;
+    /// ```
+    ///
+    /// ### Valid
+    ///
+    /// ```html
+    /// <>
+    /// 	<img src="src" alt="alt" />
+    /// 	<img src="bar" aria-hidden alt="Picture of me taking a photo of an image" />
+    /// </>
+    /// ```
+    ///
+    pub NoRedundantAlt {
+        version: "next",
+        name: "noRedundantAlt",
+        language: "html",
+        sources: &[RuleSource::EslintJsxA11y("img-redundant-alt").same()],
+        recommended: true,
+        severity: Severity::Error,
+    }
+}
+
+impl Rule for NoRedundantAlt {
+    type Query = Ast<AnyHtmlTagElement>;
+    type State = AnyHtmlAttributeInitializer;
+    type Signals = Option<Self::State>;
+    type Options = NoRedundantAltOptions;
+
+    fn run(ctx: &RuleContext<Self>) -> Self::Signals {
+        let node = ctx.query();
+        let file_source = ctx.source_type::<HtmlFileSource>();
+
+        let name = node.name().ok()?.value_token().ok()?;
+        if (file_source.is_html() && !name.text_trimmed().eq_ignore_ascii_case("img"))
+            || (!file_source.is_html() && name.text_trimmed() != "img")
+        {
+            return None;
+        }
+
+        let aria_hidden_attribute = node.find_attribute_by_name("aria-hidden");
+        if let Some(aria_hidden) = aria_hidden_attribute {
+            let is_false = match aria_hidden.initializer()?.value().ok()? {
+                AnyHtmlAttributeInitializer::HtmlSingleTextExpression(aria_hidden) => {
+                    aria_hidden
+                        .expression()
+                        .ok()?
+                        .html_literal_token()
+                        .ok()?
+                        .text_trimmed()
+                        == "false"
+                }
+                AnyHtmlAttributeInitializer::HtmlString(aria_hidden) => {
+                    aria_hidden.inner_string_text().ok()?.text() == "false"
+                }
+            };
+
+            if !is_false {
+                return None;
+            }
+        }
+
+        let alt = node
+            .find_attribute_by_name("alt")?
+            .initializer()?
+            .value()
+            .ok()?;
+
+        match alt {
+            AnyHtmlAttributeInitializer::HtmlSingleTextExpression(ref expression) => {
+                let value = expression.expression().ok()?.html_literal_token().ok()?;
+
+                is_redundant_alt(value.text_trimmed()).then_some(alt)
+            }
+            AnyHtmlAttributeInitializer::HtmlString(ref value) => {
+                let inner_string_text = value.inner_string_text().ok()?;
+                is_redundant_alt(inner_string_text.text()).then_some(alt)
+            }
+        }
+    }
+
+    fn diagnostic(_ctx: &RuleContext<Self>, state: &Self::State) -> Option<RuleDiagnostic> {
+        Some(
+            RuleDiagnostic::new(
+                rule_category!(),
+                state.range(),
+                markup! {
+                    "Avoid the words \"image\", \"picture\", or \"photo\" in " <Emphasis>"img"</Emphasis>" element alt text."
+                },
+            )
+            .note(markup! {
+                "Screen readers announce img elements as \"images\", so it is not necessary to redeclare this in alternative text."
+            }),
+        )
+    }
+}
diff --git a/crates/biome_html_syntax/src/element_ext.rs b/crates/biome_html_syntax/src/element_ext.rs
index 7edc02fd23..444d0c9bac 100644
--- a/crates/biome_html_syntax/src/element_ext.rs
+++ b/crates/biome_html_syntax/src/element_ext.rs
@@ -219,6 +219,10 @@ impl HtmlElement {
     pub fn is_sass_lang(&self) -> bool {
         self.is_style_tag() && self.has_attribute("lang", "scss")
     }
+
+    pub fn name(&self) -> SyntaxResult<HtmlTagName> {
+        self.opening_element()?.name()
+    }
 }
 
 impl HtmlTagName {
diff --git a/crates/biome_js_analyze/src/lint/a11y/no_redundant_alt.rs b/crates/biome_js_analyze/src/lint/a11y/no_redundant_alt.rs
index 2b6dfcfb49..b8f3d9d222 100644
--- a/crates/biome_js_analyze/src/lint/a11y/no_redundant_alt.rs
+++ b/crates/biome_js_analyze/src/lint/a11y/no_redundant_alt.rs
@@ -7,8 +7,8 @@ use biome_js_syntax::{
     AnyJsExpression, AnyJsLiteralExpression, AnyJsTemplateElement, AnyJsxAttributeValue,
 };
 use biome_rowan::AstNode;
+use biome_rule_options::is_redundant_alt;
 use biome_rule_options::no_redundant_alt::NoRedundantAltOptions;
-use biome_string_case::StrLikeExtension;
 
 declare_lint_rule! {
     /// Enforce `img` alt prop does not contain the word "image", "picture", or "photo".
@@ -142,12 +142,3 @@ impl Rule for NoRedundantAlt {
         )
     }
 }
-
-const REDUNDANT_WORDS: [&str; 3] = ["image", "photo", "picture"];
-
-fn is_redundant_alt(alt: &str) -> bool {
-    REDUNDANT_WORDS.into_iter().any(|word| {
-        alt.split_whitespace()
-            .any(|x| x.to_ascii_lowercase_cow() == word)
-    })
-}
diff --git a/crates/biome_rule_options/src/no_redundant_alt.rs b/crates/biome_rule_options/src/no_redundant_alt.rs
index ddd508af5c..1f0c7de5dd 100644
--- a/crates/biome_rule_options/src/no_redundant_alt.rs
+++ b/crates/biome_rule_options/src/no_redundant_alt.rs
@@ -1,5 +1,6 @@
 use biome_deserialize_macros::{Deserializable, Merge};
 use serde::{Deserialize, Serialize};
+
 #[derive(Default, Clone, Debug, Deserialize, Deserializable, Merge, Eq, PartialEq, Serialize)]
 #[cfg_attr(feature = "schema", derive(schemars::JsonSchema))]
 #[serde(rename_all = "camelCase", deny_unknown_fields, default)]
diff --git a/crates/biome_rule_options/src/shared/mod.rs b/crates/biome_rule_options/src/shared/mod.rs
index a9965fbb48..9817d15c60 100644
--- a/crates/biome_rule_options/src/shared/mod.rs
+++ b/crates/biome_rule_options/src/shared/mod.rs
@@ -1,2 +1,13 @@
+use biome_string_case::StrLikeExtension;
+
 pub mod restricted_regex;
 pub mod sort_order;
+
+const REDUNDANT_WORDS: [&str; 3] = ["image", "photo", "picture"];
+
+pub fn is_redundant_alt(alt: &str) -> bool {
+    REDUNDANT_WORDS.into_iter().any(|word| {
+        alt.split_whitespace()
+            .any(|x| x.to_ascii_lowercase_cow() == word)
+    })
+}
