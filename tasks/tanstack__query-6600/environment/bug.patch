diff --git a/docs/config.json b/docs/config.json
index c31703b2e..636f1046c 100644
--- a/docs/config.json
+++ b/docs/config.json
@@ -445,10 +445,6 @@
               "label": "onlineManager",
               "to": "react/reference/onlineManager"
             },
-            {
-              "label": "notifyManager",
-              "to": "react/reference/notifyManager"
-            },
             {
               "label": "hydration",
               "to": "react/reference/hydration"
@@ -758,10 +754,6 @@
               "label": "focusManager",
               "to": "vue/reference/focusManager"
             },
-            {
-              "label": "notifyManager",
-              "to": "vue/reference/notifyManager"
-            },
             {
               "label": "onlineManager",
               "to": "vue/reference/onlineManager"
diff --git a/docs/react/reference/notifyManager.md b/docs/react/reference/notifyManager.md
deleted file mode 100644
index db23abf6e..000000000
--- a/docs/react/reference/notifyManager.md
+++ /dev/null
@@ -1,93 +0,0 @@
----
-id: NotifyManager
-title: NotifyManager
----
-
-The `notifyManager` handles scheduling and batching callbacks in Tanstack Query.
-
-It exposes the following methods:
-
-- [batch](#notifymanagerbatch)
-- [batchCalls](#notifymanagerbatchcalls)
-- [schedule](#notifymanagerschedule)
-- [setNotifyFunction](#notifymanagersetnotifyfunction)
-- [setBatchNotifyFunction](#notifymanagersetbatchnotifyfunction)
-- [setScheduler](#notifymanagersetscheduler)
-
-## `notifyManager.batch`
-
-`batch` can be used to batch all updates scheduled inside the passed callback.
-This is mainly used internally to optimize queryClient updating.
-
-```ts
-function batch<T>(callback: () => T): T
-```
-
-## `notifyManager.batchCalls`
-
-`batchCalls` is a higher-order function that takes a callback and wraps it.
-All calls to the wrapped function schedule the callback to be run on the next batch.
-
-```ts
-type BatchCallsCallback<T extends Array<unknown>> = (...args: T) => void
-
-function batchCalls<T extends Array<unknown>>(
-  callback: BatchCallsCallback<T>,
-): BatchCallsCallback<T>
-```
-
-## `notifyManager.schedule`
-
-`schedule` schedules a function to be run on the next batch. By default, the batch is run
-with a setTimeout, but this can be configured.
-
-```ts
-function schedule(callback: () => void): void
-```
-
-## `notifyManager.setNotifyFunction`
-
-`setNotifyFunction` overrides the notify function. This function is passed the
-callback when it should be executed. The default notifyFunction just calls it.
-
-This can be used to for example wrap notifications with `React.act` while running tests:
-
-```ts
-import { notifyManager } from '@tanstack/react-query'
-import { act } from 'react-dom/test-utils'
-
-notifyManager.setNotifyFunction(act)
-```
-
-## `notifyManager.setBatchNotifyFunction`
-
-`setBatchNotifyFunction` sets the function to use for batched updates
-
-If your framework supports a custom batching function, you can let TanStack Query know about it by calling notifyManager.setBatchNotifyFunction.
-
-For example, this is how the batch function is set in solid-query:
-
-```ts
-import { notifyManager } from '@tanstack/query-core'
-import { batch } from 'solid-js'
-
-notifyManager.setBatchNotifyFunction(batch)
-```
-
-## `notifyManager.setScheduler`
-
-`setScheduler` configures a custom callback that should schedules when the next
-batch runs. The default behaviour is `setTimeout(callback, 0)`.
-
-```ts
-import { notifyManager } from '@tanstack/react-query'
-
-// Schedule batches in the next microtask
-notifyManager.setScheduler(queueMicrotask)
-
-// Schedule batches before the next frame is rendered
-notifyManager.setScheduler(requestAnimationFrame)
-
-// Schedule batches some time in the future
-notifyManager.setScheduler((cb) => setTimeout(cb, 10))
-```
diff --git a/docs/vue/reference/notifyManager.md b/docs/vue/reference/notifyManager.md
deleted file mode 100644
index 2eac053cc..000000000
--- a/docs/vue/reference/notifyManager.md
+++ /dev/null
@@ -1,6 +0,0 @@
----
-id: NotifyManager
-title: NotifyManager
-ref: docs/react/reference/notifyManager.md
-replace: { '@tanstack/react-query': '@tanstack/vue-query' }
----
diff --git a/examples/solid/solid-start-streaming/src/app.tsx b/examples/solid/solid-start-streaming/src/app.tsx
index 2c4e4c191..e751b5431 100644
--- a/examples/solid/solid-start-streaming/src/app.tsx
+++ b/examples/solid/solid-start-streaming/src/app.tsx
@@ -31,7 +31,6 @@ export default function App() {
             <a href="/with-error">With Error</a>
             <a href="/hydration">Hydration</a>
             <a href="/prefetch">Prefetch</a>
-            <a href="/batch-methods">Batching Methods</a>
             <Suspense>{props.children}</Suspense>
           </MetaProvider>
         )}
diff --git a/examples/solid/solid-start-streaming/src/components/query-boundary.tsx b/examples/solid/solid-start-streaming/src/components/query-boundary.tsx
index c68a50c04..95ee9c3d3 100644
--- a/examples/solid/solid-start-streaming/src/components/query-boundary.tsx
+++ b/examples/solid/solid-start-streaming/src/components/query-boundary.tsx
@@ -2,7 +2,7 @@
 
 import type { CreateQueryResult } from '@tanstack/solid-query'
 import type { JSX } from 'solid-js'
-import { Match, Suspense, Switch, children } from 'solid-js'
+import { Match, Suspense, Switch } from 'solid-js'
 
 export interface QueryBoundaryProps<T = unknown> {
   query: CreateQueryResult<T, Error>
diff --git a/examples/solid/solid-start-streaming/src/routes/batch-methods.tsx b/examples/solid/solid-start-streaming/src/routes/batch-methods.tsx
deleted file mode 100644
index 9c11ed996..000000000
--- a/examples/solid/solid-start-streaming/src/routes/batch-methods.tsx
+++ /dev/null
@@ -1,76 +0,0 @@
-import { createQuery, notifyManager } from '@tanstack/solid-query'
-import { createSignal } from 'solid-js'
-import { QueryBoundary } from '~/components/query-boundary'
-
-function sleep(milliseconds: number) {
-  return new Promise((res) => setTimeout(res, milliseconds))
-}
-
-function spin(milliseconds: number) {
-  const start = performance.now()
-  while (performance.now() - start <= milliseconds) {
-    // do nothing
-  }
-}
-
-async function sayHello(name: string) {
-  console.info('[api] sayHello.start')
-
-  await sleep(500)
-
-  // make the layout shift more obvious, it doesn't always happen
-  console.time('[api] sayHello.spin')
-  spin(20)
-  console.timeEnd('[api] sayHello.spin')
-
-  console.info('[api] sayHello.end')
-  return `Hello ${name}`
-}
-
-export default function BatchMethods() {
-  const [count, setCount] = createSignal(0)
-
-  const hello = createQuery(() => ({
-    queryKey: ['hello', count()] as const,
-    queryFn: ({ queryKey: [_, count] }) => sayHello(`solid ${count}`),
-  }))
-
-  return (
-    <div>
-      <select
-        value="timer"
-        ref={(el) => (el.value = 'timer')} // browser caches form input
-        onInput={(e) => {
-          const type = e.currentTarget.value
-          if (type === 'raf') notifyManager.setScheduler(requestAnimationFrame)
-          if (type === 'tick') notifyManager.setScheduler(queueMicrotask)
-          if (type === 'timer')
-            notifyManager.setScheduler((cb) => setTimeout(cb, 0))
-        }}
-      >
-        <option value="raf">requestAnimationFrame</option>
-        <option value="timer">setTimeout</option>
-        <option value="tick">queueMicrotick</option>
-      </select>
-      <button class="increment" onClick={() => setCount((x) => x + 1)}>
-        Clicks: {count()}
-      </button>
-      <p>
-        <QueryBoundary loadingFallback={'Loading...'} query={hello}>
-          {(data) => <div style={{ 'background-color': 'aqua' }}>{data}</div>}
-        </QueryBoundary>
-      </p>
-      <div style={{ 'background-color': 'red' }}>
-        Something below to demonstrate layout shift
-      </div>
-      <p>
-        Due to the way solidjs handles updates, sometimes the updating of a
-        query results in DOM modifications triggering a rerender twice. This is
-        perceived as a glitch in the layout of the webpage that usually lasts
-        for one frame. By using another batching strategy in the browser,
-        instead of the default setTimeout one, we can mitigate this issue. Try
-        out requestAnimationFrame or queueMicrotick.
-      </p>
-    </div>
-  )
-}
diff --git a/packages/query-core/src/notifyManager.ts b/packages/query-core/src/notifyManager.ts
index ad80a8472..71aa4ec90 100644
--- a/packages/query-core/src/notifyManager.ts
+++ b/packages/query-core/src/notifyManager.ts
@@ -1,3 +1,5 @@
+import { scheduleMicrotask } from './utils'
+
 // TYPES
 
 type NotifyCallback = () => void
@@ -8,8 +10,6 @@ type BatchNotifyFunction = (callback: () => void) => void
 
 type BatchCallsCallback<T extends Array<unknown>> = (...args: T) => void
 
-type ScheduleFunction = (callback: () => void) => void
-
 export function createNotifyManager() {
   let queue: Array<NotifyCallback> = []
   let transactions = 0
@@ -19,11 +19,6 @@ export function createNotifyManager() {
   let batchNotifyFn: BatchNotifyFunction = (callback: () => void) => {
     callback()
   }
-  let scheduleFn: ScheduleFunction = (cb) => setTimeout(cb, 0)
-
-  const setScheduler = (fn: ScheduleFunction) => {
-    scheduleFn = fn
-  }
 
   const batch = <T>(callback: () => T): T => {
     let result
@@ -43,7 +38,7 @@ export function createNotifyManager() {
     if (transactions) {
       queue.push(callback)
     } else {
-      scheduleFn(() => {
+      scheduleMicrotask(() => {
         notifyFn(callback)
       })
     }
@@ -66,7 +61,7 @@ export function createNotifyManager() {
     const originalQueue = queue
     queue = []
     if (originalQueue.length) {
-      scheduleFn(() => {
+      scheduleMicrotask(() => {
         batchNotifyFn(() => {
           originalQueue.forEach((callback) => {
             notifyFn(callback)
@@ -98,7 +93,6 @@ export function createNotifyManager() {
     schedule,
     setNotifyFunction,
     setBatchNotifyFunction,
-    setScheduler,
   } as const
 }
 
diff --git a/packages/query-core/src/tests/notifyManager.test.tsx b/packages/query-core/src/tests/notifyManager.test.tsx
index 01fb299b2..1265f1cfd 100644
--- a/packages/query-core/src/tests/notifyManager.test.tsx
+++ b/packages/query-core/src/tests/notifyManager.test.tsx
@@ -31,24 +31,6 @@ describe('notifyManager', () => {
     expect(callbackScheduleSpy).toHaveBeenCalledTimes(1)
   })
 
-  it('should use a custom scheduler when configured', async () => {
-    const customCallback = vi.fn((cb) => queueMicrotask(cb))
-
-    const notifyManagerTest = createNotifyManager()
-    const notifySpy = vi.fn()
-    notifyManagerTest.setScheduler(customCallback)
-    notifyManagerTest.setNotifyFunction(notifySpy)
-
-    notifyManagerTest.batch(() => notifyManagerTest.schedule(vi.fn))
-
-    expect(customCallback).toHaveBeenCalledOnce()
-
-    // wait until the microtask has run
-    await new Promise<void>((res) => queueMicrotask(res))
-
-    expect(notifySpy).toHaveBeenCalledTimes(1)
-  })
-
   it('should notify if error is thrown', async () => {
     const notifyManagerTest = createNotifyManager()
     const notifySpy = vi.fn()
@@ -62,7 +44,7 @@ describe('notifyManager', () => {
       })
     } catch {}
 
-    // needed for setTimeout to kick in
+    // needed for scheduleMicroTask to kick in
     await sleep(1)
 
     expect(notifySpy).toHaveBeenCalledTimes(1)
diff --git a/packages/query-core/src/tests/utils.test.tsx b/packages/query-core/src/tests/utils.test.tsx
index c426eca45..1832442b4 100644
--- a/packages/query-core/src/tests/utils.test.tsx
+++ b/packages/query-core/src/tests/utils.test.tsx
@@ -1,4 +1,4 @@
-import { describe, expect, it } from 'vitest'
+import { describe, expect, it, vi } from 'vitest'
 import {
   addToEnd,
   addToStart,
@@ -7,6 +7,8 @@ import {
   matchMutation,
   partialMatchKey,
   replaceEqualDeep,
+  scheduleMicrotask,
+  sleep,
 } from '../utils'
 import { Mutation } from '../mutation'
 import { createQueryClient } from './utils'
@@ -340,6 +342,17 @@ describe('core/utils', () => {
     })
   })
 
+  describe('scheduleMicrotask', () => {
+    it('should defer execution of callback', async () => {
+      const callback = vi.fn()
+
+      scheduleMicrotask(callback)
+      expect(callback).not.toHaveBeenCalled()
+      await sleep(0)
+      expect(callback).toHaveBeenCalledTimes(1)
+    })
+  })
+
   describe('addToEnd', () => {
     it('should add item to the end of the array', () => {
       const items = [1, 2, 3]
diff --git a/packages/query-core/src/utils.ts b/packages/query-core/src/utils.ts
index d50f52599..8f96b1576 100644
--- a/packages/query-core/src/utils.ts
+++ b/packages/query-core/src/utils.ts
@@ -303,6 +303,14 @@ export function sleep(ms: number): Promise<void> {
   })
 }
 
+/**
+ * Schedules a microtask.
+ * This can be useful to schedule state updates after rendering.
+ */
+export function scheduleMicrotask(callback: () => void) {
+  sleep(0).then(callback)
+}
+
 export function replaceData<
   TData,
   TOptions extends QueryOptions<any, any, any, any>,
