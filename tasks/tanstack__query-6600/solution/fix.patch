diff --git a/docs/config.json b/docs/config.json
index 636f1046c..c31703b2e 100644
--- a/docs/config.json
+++ b/docs/config.json
@@ -445,6 +445,10 @@
               "label": "onlineManager",
               "to": "react/reference/onlineManager"
             },
+            {
+              "label": "notifyManager",
+              "to": "react/reference/notifyManager"
+            },
             {
               "label": "hydration",
               "to": "react/reference/hydration"
@@ -754,6 +758,10 @@
               "label": "focusManager",
               "to": "vue/reference/focusManager"
             },
+            {
+              "label": "notifyManager",
+              "to": "vue/reference/notifyManager"
+            },
             {
               "label": "onlineManager",
               "to": "vue/reference/onlineManager"
diff --git a/docs/react/reference/notifyManager.md b/docs/react/reference/notifyManager.md
new file mode 100644
index 000000000..db23abf6e
--- /dev/null
+++ b/docs/react/reference/notifyManager.md
@@ -0,0 +1,93 @@
+---
+id: NotifyManager
+title: NotifyManager
+---
+
+The `notifyManager` handles scheduling and batching callbacks in Tanstack Query.
+
+It exposes the following methods:
+
+- [batch](#notifymanagerbatch)
+- [batchCalls](#notifymanagerbatchcalls)
+- [schedule](#notifymanagerschedule)
+- [setNotifyFunction](#notifymanagersetnotifyfunction)
+- [setBatchNotifyFunction](#notifymanagersetbatchnotifyfunction)
+- [setScheduler](#notifymanagersetscheduler)
+
+## `notifyManager.batch`
+
+`batch` can be used to batch all updates scheduled inside the passed callback.
+This is mainly used internally to optimize queryClient updating.
+
+```ts
+function batch<T>(callback: () => T): T
+```
+
+## `notifyManager.batchCalls`
+
+`batchCalls` is a higher-order function that takes a callback and wraps it.
+All calls to the wrapped function schedule the callback to be run on the next batch.
+
+```ts
+type BatchCallsCallback<T extends Array<unknown>> = (...args: T) => void
+
+function batchCalls<T extends Array<unknown>>(
+  callback: BatchCallsCallback<T>,
+): BatchCallsCallback<T>
+```
+
+## `notifyManager.schedule`
+
+`schedule` schedules a function to be run on the next batch. By default, the batch is run
+with a setTimeout, but this can be configured.
+
+```ts
+function schedule(callback: () => void): void
+```
+
+## `notifyManager.setNotifyFunction`
+
+`setNotifyFunction` overrides the notify function. This function is passed the
+callback when it should be executed. The default notifyFunction just calls it.
+
+This can be used to for example wrap notifications with `React.act` while running tests:
+
+```ts
+import { notifyManager } from '@tanstack/react-query'
+import { act } from 'react-dom/test-utils'
+
+notifyManager.setNotifyFunction(act)
+```
+
+## `notifyManager.setBatchNotifyFunction`
+
+`setBatchNotifyFunction` sets the function to use for batched updates
+
+If your framework supports a custom batching function, you can let TanStack Query know about it by calling notifyManager.setBatchNotifyFunction.
+
+For example, this is how the batch function is set in solid-query:
+
+```ts
+import { notifyManager } from '@tanstack/query-core'
+import { batch } from 'solid-js'
+
+notifyManager.setBatchNotifyFunction(batch)
+```
+
+## `notifyManager.setScheduler`
+
+`setScheduler` configures a custom callback that should schedules when the next
+batch runs. The default behaviour is `setTimeout(callback, 0)`.
+
+```ts
+import { notifyManager } from '@tanstack/react-query'
+
+// Schedule batches in the next microtask
+notifyManager.setScheduler(queueMicrotask)
+
+// Schedule batches before the next frame is rendered
+notifyManager.setScheduler(requestAnimationFrame)
+
+// Schedule batches some time in the future
+notifyManager.setScheduler((cb) => setTimeout(cb, 10))
+```
diff --git a/docs/vue/reference/notifyManager.md b/docs/vue/reference/notifyManager.md
new file mode 100644
index 000000000..2eac053cc
--- /dev/null
+++ b/docs/vue/reference/notifyManager.md
@@ -0,0 +1,6 @@
+---
+id: NotifyManager
+title: NotifyManager
+ref: docs/react/reference/notifyManager.md
+replace: { '@tanstack/react-query': '@tanstack/vue-query' }
+---
diff --git a/examples/solid/solid-start-streaming/src/app.tsx b/examples/solid/solid-start-streaming/src/app.tsx
index e751b5431..2c4e4c191 100644
--- a/examples/solid/solid-start-streaming/src/app.tsx
+++ b/examples/solid/solid-start-streaming/src/app.tsx
@@ -31,6 +31,7 @@ export default function App() {
             <a href="/with-error">With Error</a>
             <a href="/hydration">Hydration</a>
             <a href="/prefetch">Prefetch</a>
+            <a href="/batch-methods">Batching Methods</a>
             <Suspense>{props.children}</Suspense>
           </MetaProvider>
         )}
diff --git a/examples/solid/solid-start-streaming/src/components/query-boundary.tsx b/examples/solid/solid-start-streaming/src/components/query-boundary.tsx
index 95ee9c3d3..c68a50c04 100644
--- a/examples/solid/solid-start-streaming/src/components/query-boundary.tsx
+++ b/examples/solid/solid-start-streaming/src/components/query-boundary.tsx
@@ -2,7 +2,7 @@
 
 import type { CreateQueryResult } from '@tanstack/solid-query'
 import type { JSX } from 'solid-js'
-import { Match, Suspense, Switch } from 'solid-js'
+import { Match, Suspense, Switch, children } from 'solid-js'
 
 export interface QueryBoundaryProps<T = unknown> {
   query: CreateQueryResult<T, Error>
diff --git a/examples/solid/solid-start-streaming/src/routes/batch-methods.tsx b/examples/solid/solid-start-streaming/src/routes/batch-methods.tsx
new file mode 100644
index 000000000..9c11ed996
--- /dev/null
+++ b/examples/solid/solid-start-streaming/src/routes/batch-methods.tsx
@@ -0,0 +1,76 @@
+import { createQuery, notifyManager } from '@tanstack/solid-query'
+import { createSignal } from 'solid-js'
+import { QueryBoundary } from '~/components/query-boundary'
+
+function sleep(milliseconds: number) {
+  return new Promise((res) => setTimeout(res, milliseconds))
+}
+
+function spin(milliseconds: number) {
+  const start = performance.now()
+  while (performance.now() - start <= milliseconds) {
+    // do nothing
+  }
+}
+
+async function sayHello(name: string) {
+  console.info('[api] sayHello.start')
+
+  await sleep(500)
+
+  // make the layout shift more obvious, it doesn't always happen
+  console.time('[api] sayHello.spin')
+  spin(20)
+  console.timeEnd('[api] sayHello.spin')
+
+  console.info('[api] sayHello.end')
+  return `Hello ${name}`
+}
+
+export default function BatchMethods() {
+  const [count, setCount] = createSignal(0)
+
+  const hello = createQuery(() => ({
+    queryKey: ['hello', count()] as const,
+    queryFn: ({ queryKey: [_, count] }) => sayHello(`solid ${count}`),
+  }))
+
+  return (
+    <div>
+      <select
+        value="timer"
+        ref={(el) => (el.value = 'timer')} // browser caches form input
+        onInput={(e) => {
+          const type = e.currentTarget.value
+          if (type === 'raf') notifyManager.setScheduler(requestAnimationFrame)
+          if (type === 'tick') notifyManager.setScheduler(queueMicrotask)
+          if (type === 'timer')
+            notifyManager.setScheduler((cb) => setTimeout(cb, 0))
+        }}
+      >
+        <option value="raf">requestAnimationFrame</option>
+        <option value="timer">setTimeout</option>
+        <option value="tick">queueMicrotick</option>
+      </select>
+      <button class="increment" onClick={() => setCount((x) => x + 1)}>
+        Clicks: {count()}
+      </button>
+      <p>
+        <QueryBoundary loadingFallback={'Loading...'} query={hello}>
+          {(data) => <div style={{ 'background-color': 'aqua' }}>{data}</div>}
+        </QueryBoundary>
+      </p>
+      <div style={{ 'background-color': 'red' }}>
+        Something below to demonstrate layout shift
+      </div>
+      <p>
+        Due to the way solidjs handles updates, sometimes the updating of a
+        query results in DOM modifications triggering a rerender twice. This is
+        perceived as a glitch in the layout of the webpage that usually lasts
+        for one frame. By using another batching strategy in the browser,
+        instead of the default setTimeout one, we can mitigate this issue. Try
+        out requestAnimationFrame or queueMicrotick.
+      </p>
+    </div>
+  )
+}
diff --git a/packages/query-core/src/notifyManager.ts b/packages/query-core/src/notifyManager.ts
index 71aa4ec90..ad80a8472 100644
--- a/packages/query-core/src/notifyManager.ts
+++ b/packages/query-core/src/notifyManager.ts
@@ -1,5 +1,3 @@
-import { scheduleMicrotask } from './utils'
-
 // TYPES
 
 type NotifyCallback = () => void
@@ -10,6 +8,8 @@ type BatchNotifyFunction = (callback: () => void) => void
 
 type BatchCallsCallback<T extends Array<unknown>> = (...args: T) => void
 
+type ScheduleFunction = (callback: () => void) => void
+
 export function createNotifyManager() {
   let queue: Array<NotifyCallback> = []
   let transactions = 0
@@ -19,6 +19,11 @@ export function createNotifyManager() {
   let batchNotifyFn: BatchNotifyFunction = (callback: () => void) => {
     callback()
   }
+  let scheduleFn: ScheduleFunction = (cb) => setTimeout(cb, 0)
+
+  const setScheduler = (fn: ScheduleFunction) => {
+    scheduleFn = fn
+  }
 
   const batch = <T>(callback: () => T): T => {
     let result
@@ -38,7 +43,7 @@ export function createNotifyManager() {
     if (transactions) {
       queue.push(callback)
     } else {
-      scheduleMicrotask(() => {
+      scheduleFn(() => {
         notifyFn(callback)
       })
     }
@@ -61,7 +66,7 @@ export function createNotifyManager() {
     const originalQueue = queue
     queue = []
     if (originalQueue.length) {
-      scheduleMicrotask(() => {
+      scheduleFn(() => {
         batchNotifyFn(() => {
           originalQueue.forEach((callback) => {
             notifyFn(callback)
@@ -93,6 +98,7 @@ export function createNotifyManager() {
     schedule,
     setNotifyFunction,
     setBatchNotifyFunction,
+    setScheduler,
   } as const
 }
 
diff --git a/packages/query-core/src/utils.ts b/packages/query-core/src/utils.ts
index 8f96b1576..d50f52599 100644
--- a/packages/query-core/src/utils.ts
+++ b/packages/query-core/src/utils.ts
@@ -303,14 +303,6 @@ export function sleep(ms: number): Promise<void> {
   })
 }
 
-/**
- * Schedules a microtask.
- * This can be useful to schedule state updates after rendering.
- */
-export function scheduleMicrotask(callback: () => void) {
-  sleep(0).then(callback)
-}
-
 export function replaceData<
   TData,
   TOptions extends QueryOptions<any, any, any, any>,
