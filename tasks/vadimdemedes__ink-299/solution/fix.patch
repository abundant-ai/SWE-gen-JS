diff --git a/examples/jest/summary.js b/examples/jest/summary.js
index ed61707..c589da0 100644
--- a/examples/jest/summary.js
+++ b/examples/jest/summary.js
@@ -1,7 +1,7 @@
 'use strict';
 const React = require('react');
 const PropTypes = require('prop-types');
-const {Box, Color} = require('../..');
+const {Box, Text, Color} = require('../..');
 
 const Summary = ({isFinished, passed, failed, time}) => (
 	<Box flexDirection="column" marginTop={1}>
@@ -19,7 +19,7 @@ const Summary = ({isFinished, passed, failed, time}) => (
 					{passed} passed,{' '}
 				</Color>
 			)}
-			{passed + failed} total
+			<Text>{passed + failed} total</Text>
 		</Box>
 
 		<Box>
@@ -27,7 +27,7 @@ const Summary = ({isFinished, passed, failed, time}) => (
 				<Color bold>Time:</Color>
 			</Box>
 
-			{time}
+			<Text>{time}</Text>
 		</Box>
 
 		{isFinished && (
diff --git a/examples/use-input/use-input.js b/examples/use-input/use-input.js
index 61d0e47..d00701e 100644
--- a/examples/use-input/use-input.js
+++ b/examples/use-input/use-input.js
@@ -1,7 +1,7 @@
 'use strict';
 const {useState, useContext} = require('react');
 const React = require('react');
-const {render, useInput, Box, AppContext} = require('../..');
+const {render, useInput, Box, Text, AppContext} = require('../..');
 
 const Robot = () => {
 	const {exit} = useContext(AppContext);
@@ -32,9 +32,9 @@ const Robot = () => {
 
 	return (
 		<Box flexDirection="column">
-			<Box>Use arrow keys to move the face. Press “q” to exit.</Box>
+			<Text>Use arrow keys to move the face. Press “q” to exit.</Text>
 			<Box height={12} paddingLeft={x} paddingTop={y}>
-				^_^
+				<Text>^_^</Text>
 			</Box>
 		</Box>
 	);
diff --git a/readme.md b/readme.md
index 0c1cda5..5c34ab8 100644
--- a/readme.md
+++ b/readme.md
@@ -112,9 +112,9 @@ Don't forget to import `React` into every file that contains JSX:
 
 ```jsx
 import React from 'react';
-import {render, Box} from 'ink';
+import {render, Text} from 'ink';
 
-const Demo = () => <Box>Hello World</Box>;
+const Demo = () => <Text>Hello World</Text>;
 
 render(<Demo />);
 ```
@@ -234,9 +234,80 @@ Ink uses [Yoga](https://github.com/facebook/yoga) - a Flexbox layout engine to b
 It's important to remember that each element is a Flexbox container.
 Think of it as if each `<div>` in the browser had `display: flex`.
 See `<Box>` built-in component below for documentation on how to use Flexbox layouts in Ink.
+Note that all text must be wrapped in a `<Text>` component.
 
 ### Built-in Components
 
+#### `<Text>`
+
+This component can display text, and change its style to make it bold, underline, italic or strikethrough.
+
+```jsx
+import {Text} from 'ink';
+
+const Example = () => (
+	<>
+		<Text bold>I am bold</Text>
+		<Text italic>I am italic</Text>
+		<Text underline>I am underline</Text>
+		<Text strikethrough>I am strikethrough</Text>
+	</>
+);
+```
+
+##### bold
+
+Type: `boolean`\
+Default: `false`
+
+##### italic
+
+Type: `boolean`\
+Default: `false`
+
+##### underline
+
+Type: `boolean`\
+Default: `false`
+
+##### strikethrough
+
+Type: `boolean`\
+Default: `false`
+
+##### wrap
+
+Type: `string`\
+Values: `wrap` `truncate` `truncate-start` `truncate-middle` `truncate-end`\
+Default: `wrap`
+
+This property tells Ink to wrap or truncate text if its width is larger than container.
+If `wrap` is passed (by default), Ink will wrap text and split it into multiple lines.
+If `truncate-*` is passed, Ink will truncate text instead, which will result in one line of text with the rest cut off.
+
+```jsx
+<Box width={7}>
+	<Text>Hello World</Text>
+</Box>
+//=> 'Hello\nWorld'
+
+// `truncate` is an alias to `truncate-end`
+<Box width={7}>
+	<Text wrap="truncate">Hello World</Text>
+</Box>
+//=> 'Hello…'
+
+<Box width={7}>
+	<Text wrap="truncate-middle">Hello World</Text>
+</Box>
+//=> 'He…ld'
+
+<Box width={7}>
+	<Text wrap="truncate-start">Hello World</Text>
+</Box>
+//=> '…World'
+```
+
 #### `<Box>`
 
 `<Box>` it's an essential Ink component to build your layout. It's like a `<div style="display: flex">` in a browser.
@@ -256,13 +327,20 @@ Type: `number`, `string`
 Width of the element in spaces. You can also set it in percent, which will calculate the width based on the width of parent element.
 
 ```jsx
-<Box width={4}>X</Box> //=> 'X   '
+<Box width={4}>
+	<Text>X</Text>
+</Box>
+//=> 'X   '
 ```
 
 ```jsx
 <Box width={10}>
-	<Box width="50%">X</Box>Y
-</Box> //=> 'X    Y'
+	<Box width="50%">
+		<Text>X</Text>
+	</Box>
+	<Text>Y</Text>
+</Box>
+//=> 'X    Y'
 ```
 
 ###### height
@@ -272,13 +350,20 @@ Type: `number`, `string`
 Height of the element in lines (rows). You can also set it in percent, which will calculate the height based on the height of parent element.
 
 ```jsx
-<Box height={4}>X</Box> //=> 'X\n\n\n'
+<Box height={4}>
+	<Text>X</Text>
+</Box>
+//=> 'X\n\n\n'
 ```
 
 ```jsx
 <Box height={6} flexDirection="column">
-	<Box height="50%">X</Box>Y
-</Box> //=> 'X\n\n\nY\n\n'
+	<Box height="50%">
+		<Text>X</Text>
+	</Box>
+	<Text>Y</Text>
+</Box>
+//=> 'X\n\n\nY\n\n'
 ```
 
 ###### minWidth
@@ -293,33 +378,6 @@ Type: `number`
 
 Sets a minimum height of the element. Percentages aren't supported yet, see https://github.com/facebook/yoga/issues/872.
 
-##### Wrapping
-
-###### textWrap
-
-Type: `string`<br>
-Values: `wrap` `truncate` `truncate-start` `truncate-middle` `truncate-end`<br>
-Default: `wrap`
-
-This property tells Ink to wrap or truncate text content of `<Box>` if its width is larger than container.
-If `wrap` is passed (by default), Ink will wrap text and split it into multiple lines.
-If `truncate-*` is passed, Ink will truncate text instead, which will result in one line of text with the rest cut off.
-
-```jsx
-<Box>Hello World</Box>
-//=> 'Hello\nWorld'
-
-// `truncate` is an alias to `truncate-end`
-<Box textWrap="truncate">Hello World</Box>
-//=> 'Hello…'
-
-<Box textWrap="truncate-middle">Hello World</Box>
-//=> 'He…ld'
-
-<Box textWrap="truncate-start">Hello World</Box>
-//=> '…World'
-```
-
 ##### Padding
 
 ###### paddingTop
@@ -425,8 +483,10 @@ See [flex-grow](https://css-tricks.com/almanac/properties/f/flex-grow/).
 
 ```jsx
 <Box>
-	Label:
-	<Box flexGrow={1}>Fills all remaining space</Box>
+	<Text>Label:</Text>
+	<Box flexGrow={1}>
+		<Text>Fills all remaining space</Text>
+	</Box>
 </Box>
 ```
 
@@ -440,9 +500,11 @@ See [flex-shrink](https://css-tricks.com/almanac/properties/f/flex-shrink/).
 ```jsx
 <Box width={20}>
 	<Box flexShrink={2} width={10}>
-		Will be 1/4
+		<Text>Will be 1/4</Text>
+	</Box>
+	<Box width={10}>
+		<Text>Will be 3/4</Text>
 	</Box>
-	<Box width={10}>Will be 3/4</Box>
 </Box>
 ```
 
@@ -454,14 +516,22 @@ See [flex-basis](https://css-tricks.com/almanac/properties/f/flex-basis/).
 
 ```jsx
 <Box width={6}>
-	<Box flexBasis={3}>X</Box>Y
-</Box> //=> 'X  Y'
+	<Box flexBasis={3}>
+		<Text>X</Text>
+	</Box>
+	<Text>Y</Text>
+</Box>
+//=> 'X  Y'
 ```
 
 ```jsx
 <Box width={6}>
-	<Box flexBasis="50%">X</Box>Y
-</Box> //=> 'X  Y'
+	<Box flexBasis="50%">
+		<Text>X</Text>
+	</Box>
+	<Text>Y</Text>
+</Box>
+//=> 'X  Y'
 ```
 
 ###### flexDirection
@@ -473,27 +543,31 @@ See [flex-direction](https://css-tricks.com/almanac/properties/f/flex-direction/
 
 ```jsx
 <Box>
-	<Box marginRight={1}>X</Box>
-	<Box>Y</Box>
+	<Box marginRight={1}>
+		<Text>X</Text>
+	</Box>
+	<Text>Y</Text>
 </Box>
 // X Y
 
 <Box flexDirection="row-reverse">
-	<Box>X</Box>
-	<Box marginRight={1}>Y</Box>
+	<Text>X</Text>
+	<Box marginRight={1}>
+		<Text>Y</Text>
+	</Box>
 </Box>
 // Y X
 
 <Box flexDirection="column">
-	<Box>X</Box>
-	<Box>Y</Box>
+	<Text>X</Text>
+	<Text>Y</Text>
 </Box>
 // X
 // Y
 
 <Box flexDirection="column-reverse">
-	<Box>X</Box>
-	<Box>Y</Box>
+	<Text>X</Text>
+	<Text>Y</Text>
 </Box>
 // Y
 // X
@@ -508,24 +582,48 @@ See [align-items](https://css-tricks.com/almanac/properties/f/align-items/).
 
 ```jsx
 <Box alignItems="flex-start">
-	<Box marginRight={1}>X</Box>
-	<Box>{`A\nB\nC`}</Box>
+	<Box marginRight={1}>
+		<Text>X</Text>
+	</Box>
+	<Text>
+		A
+		<Newline/>
+		B
+		<Newline/>
+		C
+	</Text>
 </Box>
 // X A
 //   B
 //   C
 
 <Box alignItems="center">
-	<Box marginRight={1}>X</Box>
-	<Box>{`A\nB\nC`}</Box>
+	<Box marginRight={1}>
+		<Text>X</Text>
+	</Box>
+	<Text>
+		A
+		<Newline/>
+		B
+		<Newline/>
+		C
+	</Text>
 </Box>
 //   A
 // X B
 //   C
 
 <Box alignItems="flex-end">
-	<Box marginRight={1}>X</Box>
-	<Box>{`A\nB\nC`}</Box>
+	<Box marginRight={1}>
+		<Text>X</Text>
+	</Box>
+	<Text>
+		A
+		<Newline/>
+		B
+		<Newline/>
+		C
+	</Text>
 </Box>
 //   A
 //   B
@@ -542,21 +640,27 @@ See [align-self](https://css-tricks.com/almanac/properties/f/align-self/).
 
 ```jsx
 <Box height={3}>
-	<Box alignSelf="flex-start">X</Box>
+	<Box alignSelf="flex-start">
+		<Text>X</Text>
+	</Box>
 </Box>
 // X
 //
 //
 
 <Box height={3}>
-	<Box alignSelf="center">X</Box>
+	<Box alignSelf="center">
+		<Text>X</Text>
+	</Box>
 </Box>
 //
 // X
 //
 
 <Box height={3}>
-	<Box alignSelf="flex-end">X</Box>
+	<Box alignSelf="flex-end">
+		<Text>X</Text>
+	</Box>
 </Box>
 //
 //
@@ -572,29 +676,29 @@ See [justify-content](https://css-tricks.com/almanac/properties/f/justify-conten
 
 ```jsx
 <Box justifyContent="flex-start">
-	<Box>X</Box>
+	<Text>X</Text>
 </Box>
 // [X      ]
 
 <Box justifyContent="center">
-	<Box>X</Box>
+	<Text>X</Text>
 </Box>
 // [   X   ]
 
 <Box justifyContent="flex-end">
-	<Box>X</Box>
+	<Text>X</Text>
 </Box>
 // [      X]
 
 <Box justifyContent="space-between">
-	<Box>X</Box>
-	<Box>Y</Box>
+	<Text>X</Text>
+	<Text>Y</Text>
 </Box>
 // [X      Y]
 
 <Box justifyContent="space-around">
-	<Box>X</Box>
-	<Box>Y</Box>
+	<Text>X</Text>
+	<Text>Y</Text>
 </Box>
 // [  X   Y  ]
 ```
@@ -634,48 +738,10 @@ Usage:
 </Color>
 ```
 
-#### `<Text>`
-
-This component can change the style of the text, make it bold, underline, italic or strikethrough.
-
-Import:
-
-```js
-import {Text} from 'ink';
-```
-
-##### bold
-
-Type: `boolean`<br>
-Default: `false`
-
-##### italic
-
-Type: `boolean`<br>
-Default: `false`
-
-##### underline
-
-Type: `boolean`<br>
-Default: `false`
-
-##### strikethrough
-
-Type: `boolean`<br>
-Default: `false`
-
-Usage:
-
-```jsx
-<Text bold>I am bold</Text>
-<Text italic>I am italic</Text>
-<Text underline>I am underline</Text>
-<Text strikethrough>I am strikethrough</Text>
-```
-
 #### `<Newline>`
 
 Adds a newline (`\n`) character.
+Must be used within `<Text>` or `<Color>` components.
 
 ##### count
 
@@ -687,14 +753,14 @@ Number of newlines to insert.
 Usage:
 
 ```jsx
-import {Box, Color, Newline} from 'ink';
+import {Text, Color, Newline} from 'ink';
 
 const Example = () => (
-	<Box>
+	<Text>
 		<Color green>Hello</Color>
 		<Newline />
 		<Color red>World</Color>
-	</Box>
+	</Text>
 );
 ```
 
@@ -713,13 +779,13 @@ It's useful as a shortcut for filling all the available spaces between elements.
 For example, using `<Spacer>` in a `<Box>` with default flex direction (`row`) will position "Left" on the left side and will push "Right" to the right side.
 
 ```jsx
-import {Box, Spacer} from 'ink';
+import {Box, Text, Spacer} from 'ink';
 
 const Example = () => (
 	<Box>
-		Left
+		<Text>Left</Text>
 		<Spacer />
-		Right
+		<Text>Right</Text>
 	</Box>
 );
 ```
@@ -728,13 +794,13 @@ In a vertical flex direction (`column`), it will position "Top" to the top of th
 Note, that container needs to be tall to enough to see this in effect.
 
 ```jsx
-import {Box, Spacer} from 'ink';
+import {Box, Text, Spacer} from 'ink';
 
 const Example = () => (
 	<Box flexDirection="column" height={10}>
-		Top
+		<Text>Top</Text>
 		<Spacer />
-		Bottom
+		<Text>Bottom</Text>
 	</Box>
 );
 ```
@@ -806,7 +872,11 @@ Note that `key` must be assigned to the root component.
 		// This function is called for every item in ['a', 'b', 'c']
 		// `item` is 'a', 'b', 'c'
 		// `index` is 0, 1, 2
-		return <Box key={index}>Item: {item}</Box>;
+		return (
+			<Box key={index}>
+				<Text>Item: {item}</Text>
+			</Box>
+		);
 	}}
 </Static>
 ```
diff --git a/src/components/Box.tsx b/src/components/Box.tsx
index da955a0..ef8d49c 100644
--- a/src/components/Box.tsx
+++ b/src/components/Box.tsx
@@ -3,9 +3,10 @@ import React, {PureComponent} from 'react';
 import type {ReactNode} from 'react';
 import PropTypes from 'prop-types';
 import type {YogaNode} from 'yoga-layout-prebuilt';
+import type {Except} from 'type-fest';
 import type {Styles} from '../styles';
 
-export type Props = Styles & {
+export type Props = Except<Styles, 'textWrap'> & {
 	margin?: number;
 	marginX?: number;
 	marginY?: number;
@@ -63,13 +64,6 @@ export default class Box extends PureComponent<Props> {
 			'space-between',
 			'space-around'
 		]),
-		textWrap: PropTypes.oneOf([
-			'wrap',
-			'truncate',
-			'truncate-start',
-			'truncate-middle',
-			'truncate-end'
-		]),
 		unstable__transformChildren: PropTypes.func,
 		children: PropTypes.node
 	};
diff --git a/src/components/Text.tsx b/src/components/Text.tsx
index 1d443f1..0044855 100644
--- a/src/components/Text.tsx
+++ b/src/components/Text.tsx
@@ -2,25 +2,27 @@ import React, {memo} from 'react';
 import type {FC, ReactNode} from 'react';
 import PropTypes from 'prop-types';
 import chalk from 'chalk';
-import Transform from './Transform';
+import type {Styles} from '../styles';
 
 export interface Props {
 	readonly bold?: boolean;
 	readonly italic?: boolean;
 	readonly underline?: boolean;
 	readonly strikethrough?: boolean;
+	readonly wrap?: Styles['textWrap'];
 	readonly unstable__transformChildren?: (children: ReactNode) => ReactNode;
 	readonly children: ReactNode;
 }
 
 /**
- * This component can change the style of the text, make it bold, underline, italic or strikethrough.
+ * This component can display text, and change its style to make it bold, underline, italic or strikethrough.
  */
 const Text: FC<Props> = ({
 	bold,
 	italic,
 	underline,
 	strikethrough,
+	wrap,
 	children,
 	unstable__transformChildren
 }) => {
@@ -48,7 +50,16 @@ const Text: FC<Props> = ({
 		return children;
 	};
 
-	return <Transform transform={transform}>{children}</Transform>;
+	return (
+		<span
+			// @ts-ignore
+			style={{flexGrow: 0, flexShrink: 1, flexDirection: 'row', textWrap: wrap}}
+			// @ts-ignore
+			internal_transform={transform}
+		>
+			{children}
+		</span>
+	);
 };
 
 Text.displayName = 'Text';
@@ -59,6 +70,13 @@ Text.propTypes = {
 	italic: PropTypes.bool,
 	underline: PropTypes.bool,
 	strikethrough: PropTypes.bool,
+	wrap: PropTypes.oneOf([
+		'wrap',
+		'truncate',
+		'truncate-start',
+		'truncate-middle',
+		'truncate-end'
+	]),
 	children: PropTypes.node.isRequired,
 	unstable__transformChildren: PropTypes.func
 };
@@ -69,6 +87,7 @@ Text.defaultProps = {
 	italic: false,
 	underline: false,
 	strikethrough: false,
+	wrap: 'wrap',
 	unstable__transformChildren: undefined
 };
 
diff --git a/src/dom.ts b/src/dom.ts
index fcdf9d1..3e886bf 100644
--- a/src/dom.ts
+++ b/src/dom.ts
@@ -1,7 +1,9 @@
 import Yoga from 'yoga-layout-prebuilt';
+import type {YogaNode} from 'yoga-layout-prebuilt';
 import measureText from './measure-text';
 import applyStyles from './styles';
 import wrapText from './wrap-text';
+import squashTextNodes from './squash-text-nodes';
 import type {OutputTransformer} from './render-node-to-output';
 import type {Styles} from './styles';
 
@@ -14,7 +16,15 @@ interface InkNode {
 
 export const TEXT_NAME = '#text';
 export type TextName = '#text';
-export type ElementNames = 'root' | 'div' | 'span' | 'ROOT' | 'DIV' | 'SPAN';
+export type ElementNames =
+	| 'root'
+	| 'div'
+	| 'span'
+	| 'virtual-span'
+	| 'ROOT'
+	| 'DIV'
+	| 'SPAN'
+	| 'VIRTUAL-SPAN';
 export type NodeNames = ElementNames | TextName;
 
 export type DOMElement = {
@@ -22,7 +32,6 @@ export type DOMElement = {
 	attributes: {
 		[key: string]: DOMNodeAttribute;
 	};
-	textContent?: string;
 	childNodes: DOMNode[];
 	internal_transform?: OutputTransformer;
 
@@ -48,14 +57,22 @@ export type DOMNode<T = {nodeName: NodeNames}> = T extends {
 
 export type DOMNodeAttribute = boolean | string | number;
 
-export const createNode = (nodeName: ElementNames): DOMElement => ({
-	nodeName: nodeName.toUpperCase() as ElementNames,
-	style: {},
-	attributes: {},
-	childNodes: [],
-	parentNode: null,
-	yogaNode: Yoga.Node.create()
-});
+export const createNode = (nodeName: ElementNames): DOMElement => {
+	const node: DOMElement = {
+		nodeName: nodeName.toUpperCase() as ElementNames,
+		style: {},
+		attributes: {},
+		childNodes: [],
+		parentNode: null,
+		yogaNode: nodeName === 'virtual-span' ? undefined : Yoga.Node.create()
+	};
+
+	if (nodeName === 'span') {
+		node.yogaNode?.setMeasureFunc(measureTextNode.bind(null, node));
+	}
+
+	return node;
+};
 
 export const appendChildNode = (
 	node: DOMElement,
@@ -143,21 +160,23 @@ export const createTextNode = (text: string): TextNode => {
 	const node: TextNode = {
 		nodeName: '#text',
 		nodeValue: text,
-		yogaNode: Yoga.Node.create(),
+		yogaNode: undefined,
 		parentNode: null,
 		style: {}
 	};
 
-	setTextContent(node, text);
+	setTextNodeValue(node, text);
 
 	return node;
 };
 
 const measureTextNode = function (
 	node: DOMNode,
-	text: string,
 	width: number
 ): {width: number; height: number} {
+	const text =
+		node.nodeName === '#text' ? node.nodeValue : squashTextNodes(node);
+
 	const dimensions = measureText(text);
 
 	// Text fits into container, no need to wrap
@@ -165,22 +184,34 @@ const measureTextNode = function (
 		return dimensions;
 	}
 
-	const wrapType = node.parentNode?.style?.textWrap ?? 'wrap';
-	const wrappedText = wrapText(text, width, wrapType);
+	// This is happening when <Box> is shrinking child nodes and Yoga asks
+	// if we can fit this text node in a <1px space, so we just tell Yoga "no"
+	if (dimensions.width >= 1 && width > 0 && width < 1) {
+		return dimensions;
+	}
+
+	const textWrap = node.style?.textWrap ?? 'wrap';
+	const wrappedText = wrapText(text, width, textWrap);
 
 	return measureText(wrappedText);
 };
 
-export const setTextContent = (node: DOMNode, text: string): void => {
+const findParentYogaNode = (node?: DOMNode): YogaNode | undefined => {
+	if (!node || !node.parentNode) {
+		return undefined;
+	}
+
+	return node.yogaNode ?? findParentYogaNode(node.parentNode);
+};
+
+export const setTextNodeValue = (node: TextNode, text: string): void => {
 	if (typeof text !== 'string') {
 		text = String(text);
 	}
 
-	if (node.nodeName === '#text') {
-		node.nodeValue = text;
-	} else {
-		node.textContent = text;
-	}
+	node.nodeValue = text;
 
-	node.yogaNode?.setMeasureFunc(measureTextNode.bind(null, node, text));
+	// Mark parent Yoga node as dirty to measure text dimensions again
+	const parentYogaNode = findParentYogaNode(node);
+	parentYogaNode?.markDirty();
 };
diff --git a/src/reconciler.ts b/src/reconciler.ts
index e3f28f0..d5a8839 100644
--- a/src/reconciler.ts
+++ b/src/reconciler.ts
@@ -10,7 +10,7 @@ import {
 	insertBeforeNode,
 	removeChildNode,
 	setStyle,
-	setTextContent,
+	setTextNodeValue,
 	createNode,
 	setAttribute
 } from './dom';
@@ -26,16 +26,18 @@ import type {OutputTransformer} from './render-node-to-output';
 // eslint-disable-next-line import/no-unassigned-import
 import './devtools';
 
-const cleanupYogaNode = (node: Yoga.YogaNode): void => {
-	node.unsetMeasureFunc();
+const cleanupYogaNode = (node?: Yoga.YogaNode): void => {
+	node?.unsetMeasureFunc();
 };
 
-const NO_CONTEXT = true;
-
 interface Props {
 	[key: string]: unknown;
 }
 
+interface HostContext {
+	isInsideText: boolean;
+}
+
 export default createReconciler<
 	ElementNames,
 	Props,
@@ -44,7 +46,7 @@ export default createReconciler<
 	DOMNode,
 	unknown,
 	unknown,
-	unknown,
+	HostContext,
 	Props,
 	unknown,
 	unknown,
@@ -54,7 +56,9 @@ export default createReconciler<
 	schedulePassiveEffects,
 	cancelPassiveEffects,
 	now: Date.now,
-	getRootHostContext: () => NO_CONTEXT,
+	getRootHostContext: () => ({
+		isInsideText: false
+	}),
 	prepareForCommit: () => {},
 	resetAfterCommit: rootNode => {
 		// Since renders are throttled at the instance level and <Static> component children
@@ -73,29 +77,28 @@ export default createReconciler<
 			rootNode.onRender();
 		}
 	},
-	getChildHostContext: () => NO_CONTEXT,
-	shouldSetTextContent: (_type, props) => {
-		return (
-			typeof props.children === 'string' || typeof props.children === 'number'
-		);
+	getChildHostContext: (parentHostContext, type) => {
+		const previousIsInsideText = parentHostContext.isInsideText;
+		const isInsideText = type === 'span' || type === 'virtual-span';
+
+		if (previousIsInsideText === isInsideText) {
+			return parentHostContext;
+		}
+
+		return {isInsideText};
 	},
-	createInstance: (type, newProps) => {
+	shouldSetTextContent: () => false,
+	createInstance: (originalType, newProps, _root, hostContext) => {
+		const type =
+			originalType === 'span' && hostContext.isInsideText
+				? 'virtual-span'
+				: originalType;
+
 		const node = createNode(type);
 
 		for (const [key, value] of Object.entries(newProps)) {
 			if (key === 'children') {
-				if (typeof value === 'string' || typeof value === 'number') {
-					if (type === 'div') {
-						// Text node must be wrapped in another node, so that text can be aligned within container
-						const textNode = createNode('div');
-						setTextContent(textNode, String(value));
-						appendChildNode(node, textNode);
-					}
-
-					if (type === 'span') {
-						setTextContent(node, String(value));
-					}
-				}
+				continue;
 			} else if (key === 'style') {
 				setStyle(node, value as Styles);
 			} else if (key === 'internal_transform') {
@@ -109,24 +112,21 @@ export default createReconciler<
 
 		return node;
 	},
-	createTextInstance: createTextNode,
-	resetTextContent: node => {
-		if (node.textContent) {
-			node.textContent = '';
+	createTextInstance: (text, _root, hostContext) => {
+		if (!hostContext.isInsideText) {
+			throw new Error(
+				`Text string "${text}" must be rendered inside <Text> component`
+			);
 		}
 
-		if (node.childNodes.length > 0) {
-			for (const childNode of node.childNodes) {
-				removeChildNode(node, childNode);
-				cleanupYogaNode(childNode.yogaNode!);
-			}
-		}
+		return createTextNode(text);
 	},
+	resetTextContent: () => {},
 	hideTextInstance: (node: TextNode): void => {
-		node.nodeValue = '';
+		setTextNodeValue(node, '');
 	},
 	unhideTextInstance: (node: TextNode, text: string): void => {
-		node.nodeValue = text;
+		setTextNodeValue(node, text);
 	},
 	getPublicInstance: instance => instance,
 	hideInstance: (node: DOMElement): void => {
@@ -154,7 +154,7 @@ export default createReconciler<
 	insertInContainerBefore: insertBeforeNode,
 	removeChildFromContainer: (node, removeNode) => {
 		removeChildNode(node, removeNode);
-		cleanupYogaNode(removeNode.yogaNode!);
+		cleanupYogaNode(removeNode.yogaNode);
 	},
 	prepareUpdate: (node, _type, oldProps, newProps, rootNode) => {
 		if (node.internal_static) {
@@ -197,26 +197,10 @@ export default createReconciler<
 
 		return updatePayload;
 	},
-	commitUpdate: (node, updatePayload, type) => {
+	commitUpdate: (node, updatePayload) => {
 		for (const [key, value] of Object.entries(updatePayload)) {
 			if (key === 'children') {
-				if (typeof value === 'string' || typeof value === 'number') {
-					if (type === 'div') {
-						// Text node must be wrapped in another node, so that text can be aligned within container
-						// If there's no such node, a new one must be created
-						if (node.childNodes.length === 0) {
-							const textNode = createNode('div');
-							setTextContent(textNode, String(value));
-							appendChildNode(node, textNode);
-						} else {
-							setTextContent(node.childNodes[0], String(value));
-						}
-					}
-
-					if (type === 'span') {
-						setTextContent(node, String(value));
-					}
-				}
+				continue;
 			} else if (key === 'style') {
 				setStyle(node, value as Styles);
 			} else if (key === 'internal_transform') {
@@ -229,10 +213,10 @@ export default createReconciler<
 		}
 	},
 	commitTextUpdate: (node, _oldText, newText) => {
-		setTextContent(node, newText);
+		setTextNodeValue(node as TextNode, newText);
 	},
 	removeChild: (node, removeNode) => {
 		removeChildNode(node, removeNode);
-		cleanupYogaNode(removeNode.yogaNode!);
+		cleanupYogaNode(removeNode.yogaNode);
 	}
 });
diff --git a/src/render-node-to-output.ts b/src/render-node-to-output.ts
index 8e108aa..9c50a47 100644
--- a/src/render-node-to-output.ts
+++ b/src/render-node-to-output.ts
@@ -3,60 +3,10 @@ import widestLine from 'widest-line';
 import indentString from 'indent-string';
 import wrapText from './wrap-text';
 import getMaxWidth from './get-max-width';
-import type {DOMNode, DOMElement} from './dom';
+import squashTextNodes from './squash-text-nodes';
+import type {DOMElement} from './dom';
 import Output from './output';
 
-const isAllTextNodes = (node: DOMNode): boolean => {
-	if (node.nodeName === '#text') {
-		return true;
-	}
-
-	if (node.nodeName === 'SPAN') {
-		if (node.textContent) {
-			return true;
-		}
-
-		if (Array.isArray(node.childNodes)) {
-			return node.childNodes.every(isAllTextNodes);
-		}
-	}
-
-	return false;
-};
-
-// Squashing text nodes allows to combine multiple text nodes into one and write
-// to `Output` instance only once. For example, <Text>hello{' '}world</Text>
-// is actually 3 text nodes, which would result 3 writes to `Output`.
-//
-// Also, this is necessary for libraries like ink-link (https://github.com/sindresorhus/ink-link),
-// which need to wrap all children at once, instead of wrapping 3 text nodes separately.
-const squashTextNodes = (node: DOMElement): string => {
-	let text = '';
-	if (node.childNodes.length > 0) {
-		for (const childNode of node.childNodes) {
-			let nodeText = '';
-
-			if (childNode.nodeName === '#text') {
-				nodeText = childNode.nodeValue;
-			} else {
-				if (childNode.nodeName === 'SPAN') {
-					nodeText = childNode.textContent ?? squashTextNodes(childNode);
-				}
-
-				// Since these text nodes are being concatenated, `Output` instance won't be able to
-				// apply children transform, so we have to do it manually here for each text node
-				if (typeof childNode.internal_transform === 'function') {
-					nodeText = childNode.internal_transform(nodeText);
-				}
-			}
-
-			text += nodeText;
-		}
-	}
-
-	return text;
-};
-
 // If parent container is `<Box>`, text nodes will be treated as separate nodes in
 // the tree and will have their own coordinates in the layout.
 // To ensure text nodes are aligned correctly, take X and Y of the first text node
@@ -79,7 +29,7 @@ export type OutputTransformer = (s: string) => string;
 
 // After nodes are laid out, render each to output object, which later gets rendered to terminal
 const renderNodeToOutput = (
-	node: DOMNode,
+	node: DOMElement,
 	output: Output,
 	options: {
 		offsetX?: number;
@@ -114,63 +64,38 @@ const renderNodeToOutput = (
 		// See Output class for logic that applies transformers
 		let newTransformers = transformers;
 
-		// Text nodes
-		if (node.nodeName === '#text') {
-			output.write(x, y, node.nodeValue, {transformers: newTransformers});
-			return;
-		}
-
 		if (typeof node.internal_transform === 'function') {
 			newTransformers = [node.internal_transform, ...transformers];
 		}
 
-		// Nodes with only text inside
-		if (node.textContent) {
-			let text = node.textContent;
+		if (node.nodeName === 'SPAN') {
+			let text = squashTextNodes(node);
 
-			// Since text nodes are always wrapped in an additional node, parent node
-			// is where we should look for attributes
-			if (node.parentNode) {
+			if (text.length > 0) {
 				const currentWidth = widestLine(text);
-				const maxWidth = node.parentNode.yogaNode
-					? getMaxWidth(node.parentNode.yogaNode)
-					: 0;
+				const maxWidth = getMaxWidth(yogaNode);
 
 				if (currentWidth > maxWidth) {
-					const wrapType = node.parentNode.style.textWrap ?? 'wrap';
-					text = wrapText(text, maxWidth, wrapType);
+					const textWrap = node.style.textWrap ?? 'wrap';
+					text = wrapText(text, maxWidth, textWrap);
 				}
-			}
-
-			output.write(x, y, text, {transformers: newTransformers});
-			return;
-		}
 
-		const isFlexDirectionRow = node.style.flexDirection === 'row';
-
-		if (isFlexDirectionRow && node.childNodes.every(isAllTextNodes)) {
-			let text = squashTextNodes(node);
-			const currentWidth = widestLine(text);
-			const maxWidth = getMaxWidth(yogaNode);
-
-			if (currentWidth > maxWidth) {
-				const wrapType = node.style.textWrap ?? 'wrap';
-				text = wrapText(text, maxWidth, wrapType);
+				text = applyPaddingToText(node, text);
+				output.write(x, y, text, {transformers: newTransformers});
 			}
 
-			text = applyPaddingToText(node, text);
-			output.write(x, y, text, {transformers: newTransformers});
 			return;
 		}
 
-		// Nodes that have other nodes as children
-		for (const childNode of node.childNodes) {
-			renderNodeToOutput(childNode, output, {
-				offsetX: x,
-				offsetY: y,
-				transformers: newTransformers,
-				skipStaticElements
-			});
+		if (node.nodeName === 'ROOT' || node.nodeName === 'DIV') {
+			for (const childNode of node.childNodes) {
+				renderNodeToOutput(childNode as DOMElement, output, {
+					offsetX: x,
+					offsetY: y,
+					transformers: newTransformers,
+					skipStaticElements
+				});
+			}
 		}
 	}
 };
diff --git a/src/squash-text-nodes.ts b/src/squash-text-nodes.ts
new file mode 100644
index 0000000..4e757ad
--- /dev/null
+++ b/src/squash-text-nodes.ts
@@ -0,0 +1,43 @@
+import type {DOMElement} from './dom';
+
+// Squashing text nodes allows to combine multiple text nodes into one and write
+// to `Output` instance only once. For example, <Text>hello{' '}world</Text>
+// is actually 3 text nodes, which would result 3 writes to `Output`.
+//
+// Also, this is necessary for libraries like ink-link (https://github.com/sindresorhus/ink-link),
+// which need to wrap all children at once, instead of wrapping 3 text nodes separately.
+const squashTextNodes = (node: DOMElement): string => {
+	let text = '';
+
+	if (node.childNodes.length > 0) {
+		for (const childNode of node.childNodes) {
+			let nodeText = '';
+
+			if (childNode.nodeName === '#text') {
+				nodeText = childNode.nodeValue;
+			} else {
+				if (
+					childNode.nodeName === 'SPAN' ||
+					childNode.nodeName === 'VIRTUAL-SPAN'
+				) {
+					nodeText = squashTextNodes(childNode);
+				}
+
+				// Since these text nodes are being concatenated, `Output` instance won't be able to
+				// apply children transform, so we have to do it manually here for each text node
+				if (
+					nodeText.length > 0 &&
+					typeof childNode.internal_transform === 'function'
+				) {
+					nodeText = childNode.internal_transform(nodeText);
+				}
+			}
+
+			text += nodeText;
+		}
+	}
+
+	return text;
+};
+
+export default squashTextNodes;
