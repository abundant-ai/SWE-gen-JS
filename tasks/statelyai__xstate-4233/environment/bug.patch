diff --git a/.changeset/grumpy-planes-protect.md b/.changeset/grumpy-planes-protect.md
deleted file mode 100644
index 6ae97f2c29..0000000000
--- a/.changeset/grumpy-planes-protect.md
+++ /dev/null
@@ -1,20 +0,0 @@
----
-'@xstate/graph': major
----
-
-Remove `getMachineShortestPaths` and `getMachineSimplePaths`
-
-```diff
-import {
-- getMachineShortestPaths,
-+ getShortestPaths,
-- getMachineSimplePaths,
-+ getSimplePaths
-} from '@xstate/graph';
-
--const paths = getMachineShortestPaths(machine);
-+const paths = getShortestPaths(machine);
-
--const paths = getMachineSimplePaths(machine);
-+const paths = getSimplePaths(machine);
-```
diff --git a/packages/xstate-graph/src/adjacency.ts b/packages/xstate-graph/src/adjacency.ts
index 0c9df7e5d6..93744f46b5 100644
--- a/packages/xstate-graph/src/adjacency.ts
+++ b/packages/xstate-graph/src/adjacency.ts
@@ -20,7 +20,7 @@ export function getAdjacencyMap<
     traversalLimit: limit,
     fromState: customFromState,
     stopCondition
-  } = resolveTraversalOptions(logic, options);
+  } = resolveTraversalOptions(options);
   const actorContext = { self: {} } as any; // TODO: figure out the simulation API
   const fromState =
     customFromState ?? logic.getInitialState(actorContext, undefined);
diff --git a/packages/xstate-graph/src/graph.ts b/packages/xstate-graph/src/graph.ts
index 7cf5e4cc99..304b89880e 100644
--- a/packages/xstate-graph/src/graph.ts
+++ b/packages/xstate-graph/src/graph.ts
@@ -5,9 +5,7 @@ import {
   StateFrom,
   EventFrom,
   StateMachine,
-  AnyActorLogic,
-  SnapshotFrom,
-  EventFromLogic
+  AnyActorLogic
 } from 'xstate';
 import type {
   SerializedEvent,
@@ -171,30 +169,13 @@ export interface AdjacencyMap<TState, TEvent> {
   [key: SerializedState]: AdjacencyValue<TState, TEvent>;
 }
 
-function isMachineLogic(logic: AnyActorLogic): logic is AnyStateMachine {
-  return 'getStateNodeById' in logic;
-}
-
-export function resolveTraversalOptions<
-  TLogic extends AnyActorLogic,
-  TState extends SnapshotFrom<TLogic>,
-  TEvent extends EventFromLogic<TLogic>
->(
-  logic: AnyActorLogic,
+export function resolveTraversalOptions<TState, TEvent extends EventObject>(
   traversalOptions?: TraversalOptions<TState, TEvent>,
   defaultOptions?: TraversalOptions<TState, TEvent>
 ): TraversalConfig<TState, TEvent> {
-  const resolvedDefaultOptions =
-    defaultOptions ??
-    (isMachineLogic(logic)
-      ? (createDefaultMachineOptions(
-          logic,
-          traversalOptions as any
-        ) as TraversalOptions<TState, TEvent>)
-      : undefined);
   const serializeState =
     traversalOptions?.serializeState ??
-    resolvedDefaultOptions?.serializeState ??
+    defaultOptions?.serializeState ??
     ((state) => JSON.stringify(state));
   const traversalConfig: TraversalConfig<TState, TEvent> = {
     serializeState,
@@ -207,7 +188,7 @@ export function resolveTraversalOptions<
     // Traversal should not continue past the `toState` predicate
     // since the target state has already been reached at that point
     stopCondition: traversalOptions?.toState,
-    ...resolvedDefaultOptions,
+    ...defaultOptions,
     ...traversalOptions
   };
 
diff --git a/packages/xstate-graph/src/index.ts b/packages/xstate-graph/src/index.ts
index f5d387004d..be3e353603 100644
--- a/packages/xstate-graph/src/index.ts
+++ b/packages/xstate-graph/src/index.ts
@@ -6,8 +6,8 @@ export {
   toDirectedGraph,
   joinPaths
 } from './graph.ts';
-export { getSimplePaths } from './simplePaths.ts';
-export { getShortestPaths } from './shortestPaths.ts';
+export { getMachineSimplePaths, getSimplePaths } from './simplePaths.ts';
+export { getShortestPaths, getMachineShortestPaths } from './shortestPaths.ts';
 export { getPathsFromEvents } from './pathFromEvents.ts';
 export { getAdjacencyMap } from './adjacency.ts';
 
diff --git a/packages/xstate-graph/src/pathFromEvents.ts b/packages/xstate-graph/src/pathFromEvents.ts
index f81117f300..5cb37f1995 100644
--- a/packages/xstate-graph/src/pathFromEvents.ts
+++ b/packages/xstate-graph/src/pathFromEvents.ts
@@ -28,8 +28,7 @@ export function getPathsFromEvents<
   events: TEvent[],
   options?: TraversalOptions<TInternalState, TEvent>
 ): Array<StatePath<TInternalState, TEvent>> {
-  const resolvedOptions = resolveTraversalOptions(
-    logic,
+  const resolvedOptions = resolveTraversalOptions<TInternalState, TEvent>(
     {
       events,
       ...options
diff --git a/packages/xstate-graph/src/shortestPaths.ts b/packages/xstate-graph/src/shortestPaths.ts
index ee671ebf52..6264878e6f 100644
--- a/packages/xstate-graph/src/shortestPaths.ts
+++ b/packages/xstate-graph/src/shortestPaths.ts
@@ -3,10 +3,7 @@ import {
   AnyStateMachine,
   StateFrom,
   EventFrom,
-  ActorLogic,
-  AnyActorLogic,
-  SnapshotFrom,
-  EventFromLogic
+  ActorLogic
 } from 'xstate';
 import {
   SerializedEvent,
@@ -18,15 +15,11 @@ import {
 import { resolveTraversalOptions, createDefaultMachineOptions } from './graph';
 import { getAdjacencyMap } from './adjacency';
 
-export function getShortestPaths<
-  TLogic extends AnyActorLogic,
-  TState extends SnapshotFrom<TLogic>,
-  TEvent extends EventFromLogic<TLogic>
->(
-  logic: TLogic,
+export function getShortestPaths<TState, TEvent extends EventObject>(
+  logic: ActorLogic<TEvent, TState>,
   options?: TraversalOptions<TState, TEvent>
 ): Array<StatePath<TState, TEvent>> {
-  const resolvedOptions = resolveTraversalOptions(logic, options);
+  const resolvedOptions = resolveTraversalOptions(options);
   const serializeState = resolvedOptions.serializeState as (
     ...args: Parameters<typeof resolvedOptions.serializeState>
   ) => SerializedState;
@@ -138,3 +131,15 @@ export function getShortestPaths<
 
   return paths;
 }
+
+export function getMachineShortestPaths<TMachine extends AnyStateMachine>(
+  machine: TMachine,
+  options?: TraversalOptions<StateFrom<TMachine>, EventFrom<TMachine>>
+): Array<StatePath<StateFrom<TMachine>, EventFrom<TMachine>>> {
+  const resolvedOptions = resolveTraversalOptions(
+    options,
+    createDefaultMachineOptions(machine, options)
+  );
+
+  return getShortestPaths(machine as any, resolvedOptions);
+}
diff --git a/packages/xstate-graph/src/simplePaths.ts b/packages/xstate-graph/src/simplePaths.ts
index 8f1f6fa815..d9155f7b4e 100644
--- a/packages/xstate-graph/src/simplePaths.ts
+++ b/packages/xstate-graph/src/simplePaths.ts
@@ -3,10 +3,7 @@ import {
   AnyStateMachine,
   StateFrom,
   EventFrom,
-  ActorLogic,
-  AnyActorLogic,
-  EventFromLogic,
-  SnapshotFrom
+  ActorLogic
 } from 'xstate';
 import {
   SerializedEvent,
@@ -18,15 +15,23 @@ import {
 import { resolveTraversalOptions, createDefaultMachineOptions } from './graph';
 import { getAdjacencyMap } from './adjacency';
 
-export function getSimplePaths<
-  TLogic extends AnyActorLogic,
-  TState extends SnapshotFrom<TLogic>,
-  TEvent extends EventFromLogic<TLogic>
->(
-  logic: TLogic,
-  options?: TraversalOptions<TState, TEvent>
+export function getMachineSimplePaths<TMachine extends AnyStateMachine>(
+  machine: TMachine,
+  options?: TraversalOptions<StateFrom<TMachine>, EventFrom<TMachine>>
+): Array<StatePath<StateFrom<TMachine>, EventFrom<TMachine>>> {
+  const resolvedOptions = resolveTraversalOptions(
+    options,
+    createDefaultMachineOptions(machine)
+  );
+
+  return getSimplePaths(machine as any, resolvedOptions);
+}
+
+export function getSimplePaths<TState, TEvent extends EventObject>(
+  logic: ActorLogic<TEvent, TState>,
+  options: TraversalOptions<TState, TEvent>
 ): Array<StatePath<TState, TEvent>> {
-  const resolvedOptions = resolveTraversalOptions(logic, options);
+  const resolvedOptions = resolveTraversalOptions(options);
   const actorContext = { self: {} } as any; // TODO: figure out the simulation API
   const fromState =
     resolvedOptions.fromState ?? logic.getInitialState(actorContext, undefined);
diff --git a/packages/xstate-graph/test/graph.test.ts b/packages/xstate-graph/test/graph.test.ts
index b1fe767047..bc77ab3647 100644
--- a/packages/xstate-graph/test/graph.test.ts
+++ b/packages/xstate-graph/test/graph.test.ts
@@ -10,10 +10,12 @@ import {
 import {
   getStateNodes,
   getPathsFromEvents,
-  getShortestPaths,
+  getMachineSimplePaths,
+  getMachineShortestPaths,
   toDirectedGraph,
   StatePath,
   joinPaths,
+  getShortestPaths,
   getSimplePaths
 } from '../src';
 
@@ -187,20 +189,20 @@ describe('@xstate/graph', () => {
 
   describe('getShortestPaths()', () => {
     it('should return a mapping of shortest paths to all states', () => {
-      const paths = getShortestPaths(lightMachine);
+      const paths = getMachineShortestPaths(lightMachine);
 
       expect(getPathsSnapshot(paths)).toMatchSnapshot('shortest paths');
     });
 
     it('should return a mapping of shortest paths to all states (parallel)', () => {
-      const paths = getShortestPaths(parallelMachine);
+      const paths = getMachineShortestPaths(parallelMachine);
       expect(getPathsSnapshot(paths)).toMatchSnapshot(
         'shortest paths parallel'
       );
     });
 
     it('the initial state should have a zero-length path', () => {
-      const shortestPaths = getShortestPaths(lightMachine);
+      const shortestPaths = getMachineShortestPaths(lightMachine);
 
       expect(
         shortestPaths.find((path) =>
@@ -214,7 +216,7 @@ describe('@xstate/graph', () => {
     });
 
     xit('should not throw when a condition is present', () => {
-      expect(() => getShortestPaths(condMachine)).not.toThrow();
+      expect(() => getMachineShortestPaths(condMachine)).not.toThrow();
     });
 
     it.skip('should represent conditional paths based on context', () => {
@@ -247,7 +249,7 @@ describe('@xstate/graph', () => {
         }
       });
 
-      const paths = getShortestPaths(machine, {
+      const paths = getMachineShortestPaths(machine, {
         events: [
           {
             type: 'EVENT',
@@ -267,7 +269,7 @@ describe('@xstate/graph', () => {
 
   describe('getSimplePaths()', () => {
     it('should return a mapping of arrays of simple paths to all states', () => {
-      const paths = getSimplePaths(lightMachine);
+      const paths = getMachineSimplePaths(lightMachine);
 
       // Multiple different ways to get to flashing (from any other state)
       expect(paths.map((path) => path.state.value)).toMatchInlineSnapshot(`
@@ -313,7 +315,7 @@ describe('@xstate/graph', () => {
     });
 
     it('should return a mapping of simple paths to all states (parallel)', () => {
-      const paths = getSimplePaths(parallelMachine);
+      const paths = getMachineSimplePaths(parallelMachine);
 
       expect(paths.map((p) => p.state.value)).toMatchInlineSnapshot(`
         [
@@ -347,7 +349,7 @@ describe('@xstate/graph', () => {
         }
       });
 
-      const paths = getSimplePaths(machine);
+      const paths = getMachineSimplePaths(machine);
 
       expect(paths.map((p) => p.state.value)).toMatchInlineSnapshot(`
         [
@@ -363,7 +365,7 @@ describe('@xstate/graph', () => {
 
     it('should return a single empty path for the initial state', () => {
       expect(
-        getSimplePaths(lightMachine).find((p) =>
+        getMachineSimplePaths(lightMachine).find((p) =>
           p.state.matches(
             lightMachine.getInitialState(
               {} as any // TODO: figure out the simulation API
@@ -372,7 +374,7 @@ describe('@xstate/graph', () => {
         )
       ).toBeDefined();
       expect(
-        getSimplePaths(lightMachine).find((p) =>
+        getMachineSimplePaths(lightMachine).find((p) =>
           p.state.matches(
             lightMachine.getInitialState(
               {} as any // TODO: figure out the simulation API
@@ -381,7 +383,7 @@ describe('@xstate/graph', () => {
         )!.steps
       ).toHaveLength(0);
       expect(
-        getSimplePaths(equivMachine).find((p) =>
+        getMachineSimplePaths(equivMachine).find((p) =>
           p.state.matches(
             equivMachine.getInitialState(
               {} as any // TODO: figure out the simulation API
@@ -390,7 +392,7 @@ describe('@xstate/graph', () => {
         )!
       ).toBeDefined();
       expect(
-        getSimplePaths(equivMachine).find((p) =>
+        getMachineSimplePaths(equivMachine).find((p) =>
           p.state.matches(
             equivMachine.getInitialState(
               {} as any // TODO: figure out the simulation API
@@ -432,7 +434,7 @@ describe('@xstate/graph', () => {
         }
       });
 
-      const paths = getSimplePaths(countMachine, {
+      const paths = getMachineSimplePaths(countMachine, {
         events: [{ type: 'INC', value: 1 } as const]
       });
 
@@ -584,7 +586,7 @@ describe('filtering', () => {
       }
     });
 
-    const sp = getShortestPaths(machine, {
+    const sp = getMachineShortestPaths(machine, {
       events: [{ type: 'INC' }],
       filter: (s) => s.context.count < 5
     });
@@ -627,7 +629,7 @@ it('should provide previous state for serializeState()', () => {
     }
   });
 
-  const shortestPaths = getShortestPaths(machine, {
+  const shortestPaths = getMachineShortestPaths(machine, {
     serializeState: (state, event, prevState) => {
       return `${JSON.stringify(state.value)} via ${event?.type}${
         prevState ? ` via ${JSON.stringify(prevState.value)}` : ''
@@ -645,7 +647,7 @@ it('should provide previous state for serializeState()', () => {
   ).toEqual([0, 3]);
 });
 
-it.each([getShortestPaths, getSimplePaths])(
+it.each([getMachineShortestPaths, getMachineSimplePaths])(
   'from-state can be specified',
   (pathGetter) => {
     const machine = createMachine({
diff --git a/packages/xstate-graph/test/shortestPaths.test.ts b/packages/xstate-graph/test/shortestPaths.test.ts
index e12b944110..bb51d450db 100644
--- a/packages/xstate-graph/test/shortestPaths.test.ts
+++ b/packages/xstate-graph/test/shortestPaths.test.ts
@@ -1,8 +1,8 @@
 import { assign, createMachine } from 'xstate';
 import { joinPaths } from '../src/graph';
-import { getShortestPaths } from '../src/shortestPaths';
+import { getMachineShortestPaths } from '../src/shortestPaths';
 
-describe('getShortestPaths', () => {
+describe('getMachineShortestPaths', () => {
   it('finds the shortest paths to a state without continuing traversal from that state', () => {
     const m = createMachine<{ count: number }>({
       initial: 'a',
@@ -38,7 +38,7 @@ describe('getShortestPaths', () => {
       }
     });
 
-    const p = getShortestPaths(m, {
+    const p = getMachineShortestPaths(m, {
       toState: (state) => state.matches('c')
     });
 
@@ -74,11 +74,11 @@ describe('getShortestPaths', () => {
       }
     });
 
-    const pathsToB = getShortestPaths(m, {
+    const pathsToB = getMachineShortestPaths(m, {
       toState: (state) => state.matches('b')
     });
     const paths = pathsToB.flatMap((path) => {
-      const pathsToY = getShortestPaths(m, {
+      const pathsToY = getMachineShortestPaths(m, {
         fromState: path.state,
         toState: (state) => state.matches('y')
       });
@@ -118,7 +118,7 @@ describe('getShortestPaths', () => {
       }
     });
 
-    const shortestPaths = getShortestPaths(machine, {
+    const shortestPaths = getMachineShortestPaths(machine, {
       events: [
         {
           type: 'todo.add',
diff --git a/packages/xstate-graph/test/types.test.ts b/packages/xstate-graph/test/types.test.ts
index b4251bc31b..24da503647 100644
--- a/packages/xstate-graph/test/types.test.ts
+++ b/packages/xstate-graph/test/types.test.ts
@@ -1,5 +1,5 @@
 import { createMachine } from 'xstate';
-import { getShortestPaths } from '../src/index.ts';
+import { getMachineShortestPaths } from '../src/index.ts';
 
 describe('types', () => {
   it('`getEvents` should be allowed to return a mutable array', () => {
@@ -9,7 +9,7 @@ describe('types', () => {
       }
     });
 
-    getShortestPaths(machine, {
+    getMachineShortestPaths(machine, {
       events: [
         {
           type: 'FOO'
@@ -25,7 +25,7 @@ describe('types', () => {
       }
     });
 
-    getShortestPaths(machine, {
+    getMachineShortestPaths(machine, {
       events: [
         {
           type: 'FOO'
@@ -41,7 +41,7 @@ describe('types', () => {
       }
     });
 
-    getShortestPaths(machine, {
+    getMachineShortestPaths(machine, {
       events: [
         {
           type: 'FOO',
@@ -58,7 +58,7 @@ describe('types', () => {
       }
     });
 
-    getShortestPaths(machine, {
+    getMachineShortestPaths(machine, {
       events: [{ type: 'FOO', value: 100 }]
     });
   });
@@ -72,7 +72,7 @@ describe('types', () => {
 
     const events = [{ type: 'FOO', value: 100 }] as const;
 
-    getShortestPaths(machine, {
+    getMachineShortestPaths(machine, {
       events
     });
   });
@@ -84,7 +84,7 @@ describe('types', () => {
       }
     });
 
-    getShortestPaths(machine, {
+    getMachineShortestPaths(machine, {
       events: () => [{ type: 'FOO', value: 100 }] as const
     });
   });
@@ -94,7 +94,7 @@ describe('types', () => {
       types: { events: {} as { type: 'FOO'; value: number } }
     });
 
-    getShortestPaths(machine, {
+    getMachineShortestPaths(machine, {
       events: [
         {
           // @ts-expect-error
@@ -112,7 +112,7 @@ describe('types', () => {
       }
     });
 
-    getShortestPaths(machine, {
+    getMachineShortestPaths(machine, {
       events: [
         {
           type: 'FOO',
@@ -126,7 +126,7 @@ describe('types', () => {
   it('`serializeEvent` should be allowed to return plain string', () => {
     const machine = createMachine({});
 
-    getShortestPaths(machine, {
+    getMachineShortestPaths(machine, {
       serializeEvent: () => ''
     });
   });
@@ -134,7 +134,7 @@ describe('types', () => {
   it('`serializeState` should be allowed to return plain string', () => {
     const machine = createMachine({});
 
-    getShortestPaths(machine, {
+    getMachineShortestPaths(machine, {
       serializeState: () => ''
     });
   });
