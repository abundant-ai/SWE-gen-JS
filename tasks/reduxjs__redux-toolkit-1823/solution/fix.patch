diff --git a/packages/action-listener-middleware/src/exceptions.ts b/packages/action-listener-middleware/src/exceptions.ts
new file mode 100644
index 00000000..a4f904b4
--- /dev/null
+++ b/packages/action-listener-middleware/src/exceptions.ts
@@ -0,0 +1,8 @@
+export class TaskAbortError implements Error {
+  name: string
+  message: string
+  constructor(public reason?: string) {
+    this.name = 'TaskAbortError'
+    this.message = `task cancelled` + (reason != null ? `: "${reason}"` : '')
+  }
+}
diff --git a/packages/action-listener-middleware/src/index.ts b/packages/action-listener-middleware/src/index.ts
index 7c26d48d..586c404c 100644
--- a/packages/action-listener-middleware/src/index.ts
+++ b/packages/action-listener-middleware/src/index.ts
@@ -4,6 +4,7 @@ import type {
   AnyAction,
   Action,
   ThunkDispatch,
+  MiddlewareAPI,
 } from '@reduxjs/toolkit'
 import { createAction, nanoid } from '@reduxjs/toolkit'
 
@@ -28,17 +29,19 @@ import type {
   WithMiddlewareType,
   TakePattern,
   ListenerErrorInfo,
+  ForkedTaskExecutor,
+  ForkedTask,
 } from './types'
-
+import { assertFunction } from './utils'
+import { TaskAbortError } from './exceptions'
 import {
-  Job,
-  SupervisorJob,
-  JobHandle,
-  JobCancellationReason,
-  JobCancellationException,
-} from './job'
-import { Outcome } from './outcome'
-
+  runTask,
+  promisifyAbortSignal,
+  validateActive,
+  createPause,
+  createDelay,
+} from './task'
+export { TaskAbortError } from './exceptions'
 export type {
   ActionListener,
   ActionListenerMiddleware,
@@ -51,87 +54,101 @@ export type {
   TypedAddListener,
   TypedAddListenerAction,
   Unsubscribe,
+  ForkedTaskExecutor,
+  ForkedTask,
+  ForkedTaskAPI,
+  AsyncTaskExecutor,
+  SyncTaskExecutor,
+  TaskCancelled,
+  TaskRejected,
+  TaskResolved,
+  TaskResult,
 } from './types'
 
-function assertFunction(
-  func: unknown,
-  expected: string
-): asserts func is (...args: unknown[]) => unknown {
-  if (typeof func !== 'function') {
-    throw new TypeError(`${expected} is not a function`)
-  }
-}
-
 const defaultWhen: MiddlewarePhase = 'afterReducer'
 const actualMiddlewarePhases = ['beforeReducer', 'afterReducer'] as const
 
-function createTakePattern<S>(
+const createFork = (parentAbortSignal: AbortSignal) => {
+  return <T>(taskExecutor: ForkedTaskExecutor<T>): ForkedTask<T> => {
+    assertFunction(taskExecutor, 'taskExecutor')
+    const childAbortController = new AbortController()
+    const cancel = () => {
+      childAbortController.abort()
+    }
+
+    const result = runTask<T>(async (): Promise<T> => {
+      validateActive(parentAbortSignal)
+      validateActive(childAbortController.signal)
+      const result = (await taskExecutor({
+        pause: createPause(childAbortController.signal),
+        delay: createDelay(childAbortController.signal),
+        signal: childAbortController.signal,
+      })) as T
+      validateActive(parentAbortSignal)
+      validateActive(childAbortController.signal)
+      return result
+    }, cancel)
+
+    return {
+      result,
+      cancel,
+    }
+  }
+}
+
+const createTakePattern = <S>(
   addListener: AddListenerOverloads<Unsubscribe, S, Dispatch<AnyAction>>,
-  parentJob: Job<any>
-): TakePattern<S> {
+  signal: AbortSignal
+): TakePattern<S> => {
   /**
    * A function that takes an ActionListenerPredicate and an optional timeout,
    * and resolves when either the predicate returns `true` based on an action
    * state combination or when the timeout expires.
    * If the parent listener is canceled while waiting, this will throw a
-   * JobCancellationException.
+   * TaskAbortError.
    */
-  async function take<P extends AnyActionListenerPredicate<S>>(
+  const take = async <P extends AnyActionListenerPredicate<S>>(
     predicate: P,
     timeout: number | undefined
-  ) {
+  ) => {
+    validateActive(signal)
+
     // Placeholder unsubscribe function until the listener is added
     let unsubscribe: Unsubscribe = () => {}
 
-    // We'll add an additional nested Job representing this function.
-    // TODO This is really a duplicate of the other job inside the middleware.
-    // This behavior requires some additional nesting:
-    // We're going to create a `Promise` representing the result of the listener,
-    // but then wrap that in an `Outcome` for consistent error handling.
-    let job: Job<[AnyAction, S, S]> = parentJob.launch(async (job) =>
-      Outcome.wrap(
-        new Promise<[AnyAction, S, S]>((resolve) => {
-          // Inside the Promise, we synchronously add the listener.
-          unsubscribe = addListener({
-            predicate: predicate as any,
-            listener: (action, listenerApi): void => {
-              // One-shot listener that cleans up as soon as the predicate passes
-              listenerApi.unsubscribe()
-              // Resolve the promise with the same arguments the predicate saw
-              resolve([
-                action,
-                listenerApi.getState(),
-                listenerApi.getOriginalState(),
-              ])
-            },
-            parentJob,
-          })
-        })
+    const tuplePromise = new Promise<[AnyAction, S, S]>((resolve) => {
+      // Inside the Promise, we synchronously add the listener.
+      unsubscribe = addListener({
+        predicate: predicate as any,
+        listener: (action, listenerApi): void => {
+          // One-shot listener that cleans up as soon as the predicate passes
+          listenerApi.unsubscribe()
+          // Resolve the promise with the same arguments the predicate saw
+          resolve([
+            action,
+            listenerApi.getState(),
+            listenerApi.getOriginalState(),
+          ])
+        },
+      })
+    })
+
+    const promises: (Promise<null> | Promise<[AnyAction, S, S]>)[] = [
+      promisifyAbortSignal(signal),
+      tuplePromise,
+    ]
+
+    if (timeout != null) {
+      promises.push(
+        new Promise<null>((resolve) => setTimeout(resolve, timeout, null))
       )
-    )
-
-    let result: Outcome<[AnyAction, S, S]>
+    }
 
     try {
-      // Run the job and use the timeout if given
-      result = await (timeout !== undefined
-        ? job.runWithTimeout(timeout)
-        : job.run())
-
-      if (result.isOk()) {
-        // Resolve the actual `take` promise with the action+states
-        return result.value
-      } else {
-        if (
-          result.error instanceof JobCancellationException &&
-          result.error.reason === JobCancellationReason.JobCancelled
-        ) {
-          // The `take` job itself was canceled due to timeout.
-          return null
-        }
-        // The parent was canceled - reject this promise with that error
-        throw result.error
-      }
+      const output = await Promise.race(promises)
+
+      validateActive(signal)
+      return output
     } finally {
       // Always clean up the listener
       unsubscribe()
@@ -171,10 +188,10 @@ export const createListenerEntry: TypedCreateListenerEntry<unknown> = (
     listener: options.listener,
     type,
     predicate,
+    pendingSet: new Set<AbortController>(),
     unsubscribe: () => {
       throw new Error('Unsubscribe not initialized')
     },
-    parentJob: new SupervisorJob(),
   }
 
   return entry
@@ -281,9 +298,9 @@ export function createActionListenerMiddleware<
     return entry.unsubscribe
   }
 
-  function findListenerEntry(
+  const findListenerEntry = (
     comparator: (entry: ListenerEntry) => boolean
-  ): ListenerEntry | undefined {
+  ): ListenerEntry | undefined => {
     for (const entry of listenerMap.values()) {
       if (comparator(entry)) {
         return entry
@@ -334,6 +351,64 @@ export function createActionListenerMiddleware<
     return true
   }
 
+  const notifyListener = async (
+    entry: ListenerEntry<unknown, Dispatch<AnyAction>>,
+    action: AnyAction,
+    api: MiddlewareAPI,
+    getOriginalState: () => S,
+    currentPhase: MiddlewarePhase
+  ) => {
+    const internalTaskController = new AbortController()
+    const take = createTakePattern(addListener, internalTaskController.signal)
+    const condition: ConditionFunction<S> = (predicate, timeout) => {
+      return take(predicate, timeout).then(Boolean)
+    }
+    const delay = createDelay(internalTaskController.signal)
+    const fork = createFork(internalTaskController.signal)
+    const pause: (val: Promise<any>) => Promise<any> = createPause(
+      internalTaskController.signal
+    )
+    try {
+      entry.pendingSet.add(internalTaskController)
+      await Promise.resolve(
+        entry.listener(action, {
+          ...api,
+          getOriginalState,
+          condition,
+          take,
+          delay,
+          pause,
+          currentPhase,
+          extra,
+          signal: internalTaskController.signal,
+          fork,
+          unsubscribe: entry.unsubscribe,
+          subscribe: () => {
+            listenerMap.set(entry.id, entry)
+          },
+          cancelPrevious: () => {
+            entry.pendingSet.forEach((controller, _, set) => {
+              if (controller !== internalTaskController) {
+                controller.abort()
+                set.delete(controller)
+              }
+            })
+          },
+        })
+      )
+    } catch (listenerError) {
+      if (!(listenerError instanceof TaskAbortError)) {
+        safelyNotifyError(onError, listenerError, {
+          raisedBy: 'listener',
+          phase: currentPhase,
+        })
+      }
+    } finally {
+      internalTaskController.abort() // Notify that the task has completed
+      entry.pendingSet.delete(internalTaskController)
+    }
+  }
+
   const middleware: Middleware<
     {
       (action: Action<'actionListenerMiddleware/add'>): Unsubscribe
@@ -390,47 +465,7 @@ export function createActionListenerMiddleware<
           continue
         }
 
-        entry.parentJob.launchAndRun(async (jobHandle) => {
-          const take = createTakePattern(addListener, jobHandle as Job<any>)
-          const condition: ConditionFunction<S> = (predicate, timeout) => {
-            return take(predicate, timeout).then(Boolean)
-          }
-
-          const result = await Outcome.try(async () =>
-            entry.listener(action, {
-              ...api,
-              getOriginalState,
-              condition,
-              take,
-              currentPhase,
-              extra,
-              unsubscribe: entry.unsubscribe,
-              subscribe: () => {
-                listenerMap.set(entry.id, entry)
-              },
-              job: jobHandle,
-              cancelPrevious: () => {
-                entry.parentJob.cancelChildren(
-                  new JobCancellationException(
-                    JobCancellationReason.JobCancelled
-                  ),
-                  [jobHandle]
-                )
-              },
-            })
-          )
-          if (
-            result.isError() &&
-            !(result.error instanceof JobCancellationException)
-          ) {
-            safelyNotifyError(onError, result.error, {
-              raisedBy: 'listener',
-              phase: currentPhase,
-            })
-          }
-
-          return Outcome.ok(1)
-        })
+        notifyListener(entry, action, api, getOriginalState, currentPhase)
       }
       if (currentPhase === 'beforeReducer') {
         result = next(action)
diff --git a/packages/action-listener-middleware/src/job.ts b/packages/action-listener-middleware/src/job.ts
deleted file mode 100644
index 6e82c22a..00000000
--- a/packages/action-listener-middleware/src/job.ts
+++ /dev/null
@@ -1,324 +0,0 @@
-// Source: https://github.com/ethossoftworks/job-ts
-
-import { Outcome } from './outcome'
-import type { Error as OutcomeError } from './outcome'
-
-/**
- * The block of work a [Job] executes. The [job] parameter is a handle of the job's instance to allow
- * launching of new jobs or pausing the job.
- */
-export type JobFunc<T> = (job: JobHandle) => Promise<Outcome<T>>
-
-/**
- * A handle for the current job used in [JobFunc]. This interface is equivalent to [Job]'s interface with the exception
- * of [run] and [runWithTimeout] to prevent recursive running of the [Job] inside its [JobFunc].
- */
-export interface JobHandle {
-  isActive: boolean
-  isCompleted: boolean
-  isCancelled: boolean
-  childCount: number
-  ensureActive(): void
-  launch<R>(func: JobFunc<R>): Job<R>
-  launchAndRun<R>(func: JobFunc<R>): Promise<Outcome<R>>
-  pause<R>(func: Promise<R>): Promise<R>
-  delay(milliseconds: number): Promise<void>
-  cancel(reason?: JobCancellationException): void
-  cancelChildren(
-    reason?: JobCancellationException,
-    skipChildren?: JobHandle[]
-  ): void
-}
-
-/**
- * Thrown when a job or its parent is cancelled or if a job is run more than once.
- */
-export class JobCancellationException implements Error {
-  reason: JobCancellationReason
-  name: string
-  message: string
-  constructor(reason: JobCancellationReason) {
-    this.name = 'JobCancellationException'
-    this.reason = reason
-    this.message = `${this.reason}`
-  }
-}
-
-/**
- * The reason a job was cancelled.
- *
- * [ParentJobCancelled]: The parent job was cancelled
- * [ParentJobCompleted]: The parent job completed
- * [JobCancelled]: The current job was cancelled
- * [JobCompleted]: The current job was already completed. This only happens if the same job is run more than once.
- */
-export enum JobCancellationReason {
-  ParentJobCancelled = 'ParentJobCancelled',
-  ParentJobCompleted = 'ParentJobCompleted',
-  JobCancelled = 'JobCancelled',
-  JobCompleted = 'JobCompleted',
-}
-
-/**
- * A cancellable unit of work with optional cancellation hierarchy.
- *
- * Cancellation is cooperative, meaning the user has to define pause/suspension points in the task via the [pause] or
- * [ensureActive] methods or by checking [isActive].
- *
- * Cancelling a parent Job will cancel all children Jobs launched with the job defined as its parent. All children must
- * also cooperatively check for cancellation.
- *
- * A parent job will not wait for any children jobs unless explicitly awaited on in the provided [JobFunc]. In this
- * instance, if the parent completes before its child has completed, the parent will be marked as completed and the
- * children will be cancelled at the next pause point.
- *
- * If an exception is thrown during a JobFunc, the job will cancel itself and its children and then rethrow the
- * exception to be handled by the user.
- *
- * Running a job more than once will result in a [JobCancellationException].
- *
- * Note: When adding a try/catch mechanism inside of a [JobFunc], make sure to rethrow any [JobCancellationException]
- * exceptions, otherwise job cancellation will not work as intended.
- *
- * Example:
- * ```
- const job = Job(async (job) => {
- *     // This creates a pause point. If the job is cancelled while this operation is running,
- *     // the job will immediately return [Error] with a [JobCancellationException] as its result.
- *     const result = await job.pause(someLongRunningTask());
- *
- *     if (result.error != null) {
- *         return Outcome.error("Problem");
- *     }
- *     return Outcome.ok("All good!");
- * });
- *
- * const jobResult = await job.run();
- * ```
- */
-export class Job<T> implements JobHandle {
-  private _parent: Job<any> | undefined
-  private _children: Job<any>[] = []
-  private _func: JobFunc<T>
-  private _cancelResolver: (value: Outcome<T>) => void = () => {}
-  private _isCancelled = false
-  private _isCompleted = false
-
-  private _cancelPromise: Promise<Outcome<T>> = new Promise<Outcome<T>>(
-    (resolve) => (this._cancelResolver = resolve)
-  )
-
-  constructor(func: JobFunc<T>, options?: { parent?: Job<any> }) {
-    this._func = func
-    this._parent = options?.parent
-    this._parent?._addChild(this)
-  }
-
-  /**
-   * Returns true if the given outcome was cancelled
-   */
-  static isCancelled = (
-    outcome: Outcome<unknown>
-  ): outcome is OutcomeError<JobCancellationException> =>
-    outcome.isError() && outcome.error instanceof JobCancellationException
-
-  /**
-   * Returns true if both the parent job (if one exists) and the current job are both active. A job is active at
-   * creation and remains active until it has completed or been cancelled.
-   */
-  get isActive(): boolean {
-    return (
-      !this._isCompleted &&
-      !this._isCancelled &&
-      (this._parent?.isActive ?? true)
-    )
-  }
-
-  /**
-   * Returns true if the job was completed successfully
-   */
-  get isCompleted(): boolean {
-    return !this.isActive && !this.isCancelled
-  }
-
-  /**
-   * Returns true if the job was cancelled for any reason, either by explicit invocation of cancel or because its
-   * parent was cancelled. This does not imply that the job has fully completed because it may still be finishing
-   * whatever it was doing and waiting for its children to complete.
-   */
-  get isCancelled(): boolean {
-    return this._isCancelled || !(this._parent?.isCancelled ?? true)
-  }
-
-  /**
-   * Checks if the parent job and current job are active and throws [JobCancellationException] if either are inactive.
-   *
-   * Note: This should only be used inside of a [JobFunc].
-   */
-  ensureActive() {
-    if (this._isCompleted)
-      throw new JobCancellationException(JobCancellationReason.JobCompleted)
-    if (this._isCancelled)
-      throw new JobCancellationException(JobCancellationReason.JobCancelled)
-
-    // Check parent
-    if (this._parent === undefined) return
-    if (!this._parent.isActive) {
-      if (this._parent.isCompleted)
-        throw new JobCancellationException(
-          JobCancellationReason.ParentJobCompleted
-        )
-      throw new JobCancellationException(
-        JobCancellationReason.ParentJobCancelled
-      )
-    }
-  }
-
-  /**
-   * The current number of active children jobs.
-   */
-  get childCount(): number {
-    return this._children.length
-  }
-
-  /**
-   * Creates and returns a new job with the current job as the parent.
-   */
-  launch<R>(func: JobFunc<R>): Job<R> {
-    return new Job(func, { parent: this })
-  }
-
-  /**
-   * Creates a new job with the current job as the parent and executes it returning its result.
-   *
-   * Note: This should only be used inside of a [JobFunc].
-   */
-  launchAndRun<R>(func: JobFunc<R>): Promise<Outcome<R>> {
-    return this.launch(func).run()
-  }
-
-  /**
-   * Execute the job and return its result.
-   *
-   * [run] handles all [JobCancellationException] and will return an [Error] if a cancellation occurs.
-   */
-  async run(): Promise<Outcome<T>> {
-    try {
-      this.ensureActive()
-      const result = this._validateResult(
-        await Promise.race([this._func(this), this._cancelPromise])
-      )
-      this.ensureActive()
-      this._isCompleted = true
-      return result
-    } catch (e) {
-      if (e instanceof JobCancellationException) {
-        return Outcome.error(e)
-      } else {
-        this.cancel(
-          new JobCancellationException(JobCancellationReason.JobCancelled)
-        )
-        throw e
-      }
-    } finally {
-      this._parent?._removeChild(this)
-    }
-  }
-
-  /**
-   * Executes the job and cancels the job if it takes longer than the timeout to complete/cancel.
-   */
-  async runWithTimeout(milliseconds: number): Promise<Outcome<T>> {
-    setTimeout(() => this.cancel(), milliseconds)
-    return this.run()
-  }
-
-  private _validateResult(result: Outcome<T>): Outcome<T> {
-    if (result.isError() && result.error instanceof JobCancellationException)
-      throw result.error
-    return result
-  }
-
-  /**
-   * Await a given [func] and ensures the job is active before and after [func] execution. This effectively
-   * creates a pause/suspend point for the job and prevents returning a result or performing an action on a result
-   * if the job has been completed/cancelled.
-   *
-   * Note: This should only be used inside of a [JobFunc].
-   */
-  async pause<R>(func: Promise<R>): Promise<R> {
-    this.ensureActive()
-    const result = await Promise.race([func, this._cancelPromise])
-    this.ensureActive()
-    return result as R
-  }
-
-  /**
-   * Delays a job for the specified amount of time and checks for cancellation before and after the delay.
-   */
-  async delay(milliseconds: number): Promise<void> {
-    return await this.pause(
-      new Promise((resolve) => setTimeout(resolve, milliseconds))
-    )
-  }
-
-  /**
-   * Cancels the current job and all children jobs.
-   */
-  cancel(reason?: JobCancellationException) {
-    this._parent?._removeChild(this)
-    this.cancelChildren(
-      new JobCancellationException(JobCancellationReason.ParentJobCancelled)
-    )
-
-    if (this._isCancelled || this._isCompleted) return
-    this._isCancelled = true
-    this._cancelResolver(
-      Outcome.error(
-        reason ??
-          new JobCancellationException(JobCancellationReason.JobCancelled)
-      )
-    )
-  }
-
-  /**
-   * Cancels all children jobs without cancelling the current job.
-   */
-  cancelChildren(
-    reason?: JobCancellationException,
-    skipChildren: JobHandle[] = []
-  ) {
-    const childrenCopy = [...this._children]
-    const skipSet = new Set(skipChildren)
-    const remainingChildren: typeof this._children = []
-    childrenCopy.forEach((job) => {
-      if (skipSet.has(job)) {
-        remainingChildren.push(job)
-      } else {
-        job.cancel(
-          reason ??
-            new JobCancellationException(JobCancellationReason.JobCancelled)
-        )
-      }
-    })
-    this._children = remainingChildren
-  }
-
-  private _addChild(child: Job<any>) {
-    if (this.isActive) this._children.push(child)
-  }
-
-  private _removeChild(child: Job<any>) {
-    this._children.splice(this._children.indexOf(child), 1)
-  }
-}
-
-/**
- * A helper extension of [Job] that never completes until it is cancelled. This effectively provides a long-running
- * context to launch children jobs in.
- */
-export class SupervisorJob extends Job<void> {
-  constructor(parent?: Job<any>) {
-    super(() => new Promise<Outcome<void>>(() => {}), { parent: parent })
-  }
-}
diff --git a/packages/action-listener-middleware/src/outcome.ts b/packages/action-listener-middleware/src/outcome.ts
deleted file mode 100644
index d2e017a0..00000000
--- a/packages/action-listener-middleware/src/outcome.ts
+++ /dev/null
@@ -1,58 +0,0 @@
-// Source: https://github.com/ethossoftworks/outcome-ts
-
-const outcomeSymbol = Symbol()
-
-export class Ok<T> {
-  private outcomeSymbol = outcomeSymbol
-
-  constructor(public value: T) {}
-
-  isError(): this is Error<T> {
-    return false
-  }
-
-  isOk(): this is Ok<T> {
-    return true
-  }
-}
-
-export class Error<E = unknown> {
-  private outcomeSymbol = outcomeSymbol
-
-  constructor(public error: E) {}
-
-  isError(): this is Error {
-    return true
-  }
-
-  isOk(): this is Ok<any> {
-    return false
-  }
-}
-
-export const Outcome = {
-  ok: <T>(value: T) => new Ok(value),
-  error: <E>(error: E) => new Error(error),
-
-  wrap: async <T>(promise: Promise<T>): Promise<Outcome<T>> => {
-    try {
-      return new Ok(await promise)
-    } catch (e) {
-      return new Error(e)
-    }
-  },
-
-  try: async <T>(block: () => Promise<T>): Promise<Outcome<T>> => {
-    try {
-      return new Ok(await block())
-    } catch (e) {
-      return new Error(e)
-    }
-  },
-
-  isOutcome: (other: any): other is Outcome<any> => {
-    return other !== undefined && other.outcomeSymbol === outcomeSymbol
-  },
-}
-
-export type Outcome<T, E = unknown> = Ok<T> | Error<E>
diff --git a/packages/action-listener-middleware/src/task.ts b/packages/action-listener-middleware/src/task.ts
new file mode 100644
index 00000000..efa1e12e
--- /dev/null
+++ b/packages/action-listener-middleware/src/task.ts
@@ -0,0 +1,96 @@
+import { TaskAbortError } from './exceptions'
+import type { TaskResult } from './types'
+import { noop } from './utils'
+
+/**
+ * Synchronously raises {@link TaskAbortError} if the task tied to the input `signal` has been cancelled.
+ * @param signal
+ * @param reason
+ * @see {TaskAbortError}
+ */
+export const validateActive = (signal: AbortSignal, reason?: string): void => {
+  if (signal.aborted) {
+    throw new TaskAbortError(reason)
+  }
+}
+
+/**
+ * Returns a promise that will reject {@link TaskAbortError} if the task is cancelled.
+ * @param signal
+ * @returns
+ */
+export const promisifyAbortSignal = (
+  signal: AbortSignal,
+  reason?: string
+): Promise<never> => {
+  const promise = new Promise<never>((_, reject) => {
+    const notifyRejection = () => reject(new TaskAbortError(reason))
+
+    if (signal.aborted) {
+      notifyRejection()
+    } else {
+      signal.addEventListener('abort', notifyRejection, { once: true })
+    }
+  })
+
+  // We do not want 'unhandledRejection' warnings or crashes caused by cancelled tasks
+  promise.catch(noop)
+
+  return promise
+}
+
+/**
+ * Runs a task and returns promise that resolves to {@link TaskResult}.
+ *
+ * Second argument is an optional `cleanUp` function that always runs after task.
+ * @returns
+ */
+export const runTask = async <T>(
+  task: () => Promise<T>,
+  cleanUp?: () => void
+): Promise<TaskResult<T>> => {
+  try {
+    await Promise.resolve()
+    const value = await task()
+    return {
+      status: 'ok',
+      value,
+    }
+  } catch (error: any) {
+    return {
+      status: error instanceof TaskAbortError ? 'cancelled' : 'rejected',
+      error,
+    }
+  } finally {
+    cleanUp?.()
+  }
+}
+
+/**
+ * Given an input `AbortSignal` and a promise returns another promise that resolves
+ * as soon the input promise is provided or rejects as soon as
+ * `AbortSignal.abort` is `true`.
+ * @param signal
+ * @returns
+ */
+export const createPause = <T>(signal: AbortSignal) => {
+  return async (promise: Promise<T>): Promise<T> => {
+    validateActive(signal)
+    const result = await Promise.race([promisifyAbortSignal(signal), promise])
+    validateActive(signal)
+    return result
+  }
+}
+
+/**
+ * Given an input `AbortSignal` and `timeoutMs` returns a promise that resolves
+ * after `timeoutMs` or rejects as soon as `AbortSignal.abort` is `true`.
+ * @param signal
+ * @returns
+ */
+export const createDelay = (signal: AbortSignal) => {
+  const pause = createPause<void>(signal)
+  return (timeoutMs: number): Promise<void> => {
+    return pause(new Promise<void>((resolve) => setTimeout(resolve, timeoutMs)))
+  }
+}
diff --git a/packages/action-listener-middleware/src/types.ts b/packages/action-listener-middleware/src/types.ts
index dfe62c20..c854cf5d 100644
--- a/packages/action-listener-middleware/src/types.ts
+++ b/packages/action-listener-middleware/src/types.ts
@@ -7,8 +7,7 @@ import type {
   Action,
   ThunkDispatch,
 } from '@reduxjs/toolkit'
-
-import type { JobHandle, Job } from './job'
+import type { TaskAbortError } from './exceptions'
 
 /**
  * Types copied from RTK
@@ -28,7 +27,6 @@ export interface TypedActionCreator<Type extends string> {
 /**
  * Action Listener Options types
  */
-
 export type MiddlewarePhase = 'beforeReducer' | 'afterReducer'
 
 export type When = MiddlewarePhase | 'both' | undefined
@@ -63,6 +61,65 @@ export interface HasMatchFunction<T> {
   match: MatchFunction<T>
 }
 
+export interface ForkedTaskAPI {
+  /**
+   * Returns a promise that resolves when `waitFor` resolves or
+   * rejects if the task has been cancelled or completed.
+   */
+  pause<W>(waitFor: Promise<W>): Promise<W>
+  /**
+   * Returns a promise resolves after `timeoutMs` or
+   * rejects if the task has been cancelled or is completed.
+   * @param timeoutMs
+   */
+  delay(timeoutMs: number): Promise<void>
+  /**
+   * An abort signal whose `aborted` property is set to `true`
+   * if the task execution is either aborted or completed.
+   * @see https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal
+   */
+  signal: AbortSignal
+}
+
+export interface AsyncTaskExecutor<T> {
+  (forkApi: ForkedTaskAPI): Promise<T>
+}
+
+export interface SyncTaskExecutor<T> {
+  (forkApi: ForkedTaskAPI): T
+}
+
+export type ForkedTaskExecutor<T> = AsyncTaskExecutor<T> | SyncTaskExecutor<T>
+
+export type TaskResolved<T> = {
+  readonly status: 'ok'
+  readonly value: T
+}
+
+export type TaskRejected = {
+  readonly status: 'rejected'
+  readonly error: unknown
+}
+
+export type TaskCancelled = {
+  readonly status: 'cancelled'
+  readonly error: TaskAbortError
+}
+
+export type TaskResult<Value> =
+  | TaskResolved<Value>
+  | TaskRejected
+  | TaskCancelled
+
+export interface ForkedTask<T> {
+  result: Promise<TaskResult<T>>
+  /**
+   * Cancel task if it is in progress or not yet started,
+   * it is noop otherwise.
+   */
+  cancel(): void
+}
+
 /**
  * @alpha
  */
@@ -74,7 +131,28 @@ export interface ActionListenerMiddlewareAPI<S, D extends Dispatch<AnyAction>>
   condition: ConditionFunction<S>
   take: TakePattern<S>
   cancelPrevious: () => void
-  job: JobHandle
+  /**
+   * An abort signal whose `aborted` property is set to `true`
+   * if the listener execution is either aborted or completed.
+   * @see https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal
+   */
+  signal: AbortSignal
+  /**
+   * Returns a promise resolves after `timeoutMs` or
+   * rejects if the listener has been cancelled or is completed.
+   */
+  delay(timeoutMs: number): Promise<void>
+  /**
+   * Queues in the next microtask the execution of a task.
+   * @param executor
+   */
+  fork<T>(executor: ForkedTaskExecutor<T>): ForkedTask<T>
+  /**
+   * Returns a promise that resolves when `waitFor` resolves or
+   * rejects if the listener has been cancelled or is completed.
+   * @param promise
+   */
+  pause<M>(promise: Promise<M>): Promise<M>
   currentPhase: MiddlewarePhase
   // TODO Figure out how to pass this through the other types correctly
   extra: unknown
@@ -100,7 +178,6 @@ export interface ActionListenerOptions {
    * Defaults to 'before'.
    */
   when?: When
-  parentJob?: JobHandle
 }
 
 export interface CreateListenerMiddlewareOptions<ExtraArgument = unknown> {
@@ -285,9 +362,9 @@ export type ListenerEntry<
   when: When
   listener: ActionListener<any, S, D>
   unsubscribe: () => void
+  pendingSet: Set<AbortController>
   type?: string
   predicate: ListenerPredicate<AnyAction, S>
-  parentJob: JobHandle
 }
 
 const declaredMiddlewareType: unique symbol = undefined as any
diff --git a/packages/action-listener-middleware/src/utils.ts b/packages/action-listener-middleware/src/utils.ts
new file mode 100644
index 00000000..631ad078
--- /dev/null
+++ b/packages/action-listener-middleware/src/utils.ts
@@ -0,0 +1,13 @@
+export const assertFunction: (
+  func: unknown,
+  expected: string
+) => asserts func is (...args: unknown[]) => unknown = (
+  func: unknown,
+  expected: string
+) => {
+  if (typeof func !== 'function') {
+    throw new TypeError(`${expected} is not a function`)
+  }
+}
+
+export const noop = () => {}
