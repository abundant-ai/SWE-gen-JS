diff --git a/.changeset/css-parse-modules-flag.md b/.changeset/css-parse-modules-flag.md
deleted file mode 100644
index 4b49960439..0000000000
--- a/.changeset/css-parse-modules-flag.md
+++ /dev/null
@@ -1,14 +0,0 @@
----
-"@biomejs/biome": minor
----
-
-Added `--css-parse-css-modules` CLI flag to control whether CSS Modules syntax is enabled.
-
-You can now enable or disable CSS Modules parsing directly from the command line:
-
-```shell
-biome check --css-parse-css-modules=true file.module.css
-biome format --css-parse-css-modules=true file.module.css
-biome lint --css-parse-css-modules=true file.module.css
-biome ci --css-parse-css-modules=true file.module.css
-```
diff --git a/.changeset/css-parse-tailwind-flag.md b/.changeset/css-parse-tailwind-flag.md
deleted file mode 100644
index b2464c9049..0000000000
--- a/.changeset/css-parse-tailwind-flag.md
+++ /dev/null
@@ -1,14 +0,0 @@
----
-"@biomejs/biome": minor
----
-
-Added `--css-parse-tailwind-directives` CLI flag to control whether Tailwind CSS 4.0 directives and functions are enabled.
-
-You can now enable or disable Tailwind CSS 4.0 directive parsing directly from the command line:
-
-```shell
-biome check --css-parse-tailwind-directives=true file.css
-biome format --css-parse-tailwind-directives=true file.css
-biome lint --css-parse-tailwind-directives=true file.css
-biome ci --css-parse-tailwind-directives=true file.css
-```
diff --git a/.changeset/eager-suns-smoke.md b/.changeset/eager-suns-smoke.md
deleted file mode 100644
index 76dabb768b..0000000000
--- a/.changeset/eager-suns-smoke.md
+++ /dev/null
@@ -1,5 +0,0 @@
----
-"@biomejs/biome": patch
----
-
-Fixed an issue where the JUnit reporter returned a zero-based location. Now the location returned is one-based.
diff --git a/.changeset/gentle-pots-hunt.md b/.changeset/gentle-pots-hunt.md
deleted file mode 100644
index d8582ffb6f..0000000000
--- a/.changeset/gentle-pots-hunt.md
+++ /dev/null
@@ -1,64 +0,0 @@
----
-"@biomejs/biome": minor
----
-
-Added a new reporter named `rdjson`. This reporter prints diagnostics following the [RDJSON format](https://deepwiki.com/reviewdog/reviewdog/3.2-reviewdog-diagnostic-format):
-
-The following command:
-
-```shell
-biome check --reporter=rdjson
-```
-
-Will emit diagnostics in the following format:
-
-```json
-{
-  "source": {
-    "name": "Biome",
-    "url": "https://biomejs.dev"
-  },
-  "diagnostics": [
-    {
-      "code": {
-        "url": "https://biomejs.dev/linter/rules/no-unused-imports",
-        "value": "lint/correctness/noUnusedImports"
-      },
-      "location": {
-        "path": "index.ts",
-        "range": {
-          "end": {
-            "column": 11,
-            "line": 0
-          },
-          "start": {
-            "column": 7,
-            "line": 0
-          }
-        }
-      },
-      "message": "This import is unused."
-    },
-    {
-      "code": {
-        "url": "https://biomejs.dev/linter/rules/no-unused-imports",
-        "value": "lint/correctness/noUnusedImports"
-      },
-      "location": {
-        "path": "index.ts",
-        "range": {
-          "end": {
-            "column": 10,
-            "line": 1
-          },
-          "start": {
-            "column": 9,
-            "line": 1
-          }
-        }
-      },
-      "message": "Several of these imports are unused."
-    }
-  ]
-}
-```
diff --git a/.changeset/icy-views-lick.md b/.changeset/icy-views-lick.md
deleted file mode 100644
index 17839a23bd..0000000000
--- a/.changeset/icy-views-lick.md
+++ /dev/null
@@ -1,14 +0,0 @@
----
-"@biomejs/biome": minor
----
-
-The `formatWithErrors` option can now be set via CLI using the `--format-with-errors` flag.
-
-This flag was previously only available in the configuration file. It allows formatting to proceed on files with syntax errors, which is useful during development when you want to auto-format code while fixing syntax issues.
-
-#### Example
-
-```shell
-biome format --format-with-errors=true --write file.js
-```
-
diff --git a/.changeset/json-parse-comments-flag.md b/.changeset/json-parse-comments-flag.md
deleted file mode 100644
index d2f3bf4860..0000000000
--- a/.changeset/json-parse-comments-flag.md
+++ /dev/null
@@ -1,14 +0,0 @@
----
-"@biomejs/biome": minor
----
-
-Added `--json-parse-allow-comments` CLI flag to control whether comments are allowed in JSON files.
-
-You can now enable or disable comment parsing in JSON files directly from the command line:
-
-```shell
-biome check --json-parse-allow-comments=true file.json
-biome format --json-parse-allow-comments=true file.json
-biome lint --json-parse-allow-comments=true file.json
-biome ci --json-parse-allow-comments=true file.json
-```
diff --git a/.changeset/json-parse-trailing-commas-flag.md b/.changeset/json-parse-trailing-commas-flag.md
deleted file mode 100644
index 1135b8771e..0000000000
--- a/.changeset/json-parse-trailing-commas-flag.md
+++ /dev/null
@@ -1,14 +0,0 @@
----
-"@biomejs/biome": minor
----
-
-Added `--json-parse-allow-trailing-commas` CLI flag to control whether trailing commas are allowed in JSON files.
-
-You can now enable or disable trailing comma parsing in JSON files directly from the command line:
-
-```shell
-biome check --json-parse-allow-trailing-commas=true file.json
-biome format --json-parse-allow-trailing-commas=true file.json
-biome lint --json-parse-allow-trailing-commas=true file.json
-biome ci --json-parse-allow-trailing-commas=true file.json
-```
diff --git a/.changeset/light-women-live.md b/.changeset/light-women-live.md
deleted file mode 100644
index 7020170676..0000000000
--- a/.changeset/light-women-live.md
+++ /dev/null
@@ -1,39 +0,0 @@
----
-"@biomejs/biome": minor
----
-
-Added the new `checkstyle` reporter. When `--reporter=checkstyle` is passed to the CLI, Biome will emit diagnostics for [Checkstyle format](https://checkstyle.org/):
-
-```xml
-<?xml version="1.0" encoding="utf-8"?>
-<checkstyle version="4.3">
-  <file name="index.ts">
-    <error line="1" column="8" severity="warning" message="This import is unused." source="lint/correctness/noUnusedImports" />
-    <error line="2" column="10" severity="warning" message="Several of these imports are unused." source="lint/correctness/noUnusedImports" />
-    <error line="8" column="5" severity="warning" message="This variable f is unused." source="lint/correctness/noUnusedVariables" />
-    <error line="9" column="7" severity="warning" message="This variable f is unused." source="lint/correctness/noUnusedVariables" />
-    <error line="1" column="1" severity="error" message="The imports and exports are not sorted." source="assist/source/organizeImports" />
-    <error line="4" column="3" severity="error" message="Using == may be unsafe if you are relying on type coercion." source="lint/suspicious/noDoubleEquals" />
-    <error line="6" column="1" severity="error" message="This is an unexpected use of the debugger statement." source="lint/suspicious/noDebugger" />
-    <error line="8" column="5" severity="error" message="This variable implicitly has the any type." source="lint/suspicious/noImplicitAnyLet" />
-    <error line="9" column="7" severity="error" message="This variable implicitly has the any type." source="lint/suspicious/noImplicitAnyLet" />
-    <error line="2" column="10" severity="error" message="Shouldn&apos;t redeclare &apos;z&apos;. Consider to delete it or rename it." source="lint/suspicious/noRedeclare" />
-    <error line="9" column="7" severity="error" message="Shouldn&apos;t redeclare &apos;f&apos;. Consider to delete it or rename it." source="lint/suspicious/noRedeclare" />
-    <error line="0" column="0" severity="error" message="Formatter would have printed the following content:" source="format" />
-  </file>
-  <file name="main.ts">
-    <error line="1" column="8" severity="warning" message="This import is unused." source="lint/correctness/noUnusedImports" />
-    <error line="2" column="10" severity="warning" message="Several of these imports are unused." source="lint/correctness/noUnusedImports" />
-    <error line="8" column="5" severity="warning" message="This variable f is unused." source="lint/correctness/noUnusedVariables" />
-    <error line="9" column="7" severity="warning" message="This variable f is unused." source="lint/correctness/noUnusedVariables" />
-    <error line="1" column="1" severity="error" message="The imports and exports are not sorted." source="assist/source/organizeImports" />
-    <error line="4" column="3" severity="error" message="Using == may be unsafe if you are relying on type coercion." source="lint/suspicious/noDoubleEquals" />
-    <error line="6" column="1" severity="error" message="This is an unexpected use of the debugger statement." source="lint/suspicious/noDebugger" />
-    <error line="8" column="5" severity="error" message="This variable implicitly has the any type." source="lint/suspicious/noImplicitAnyLet" />
-    <error line="9" column="7" severity="error" message="This variable implicitly has the any type." source="lint/suspicious/noImplicitAnyLet" />
-    <error line="2" column="10" severity="error" message="Shouldn&apos;t redeclare &apos;z&apos;. Consider to delete it or rename it." source="lint/suspicious/noRedeclare" />
-    <error line="9" column="7" severity="error" message="Shouldn&apos;t redeclare &apos;f&apos;. Consider to delete it or rename it." source="lint/suspicious/noRedeclare" />
-    <error line="0" column="0" severity="error" message="Formatter would have printed the following content:" source="format" />
-  </file>
-</checkstyle>
-```
diff --git a/.changeset/stupid-groups-grow.md b/.changeset/stupid-groups-grow.md
new file mode 100644
index 0000000000..1a33f29217
--- /dev/null
+++ b/.changeset/stupid-groups-grow.md
@@ -0,0 +1,9 @@
+---
+"@biomejs/biome": minor
+---
+
+Added linting and assist support for `.html` files, with addition of two new configurations:
+- `html.linter.enabled`
+- `html.assist.enabled`
+
+The HTML linter, in this release, only contains the rule `noHeaderScope`. More rules will be released in the upcoming releases.
diff --git a/.changeset/upset-impalas-grab.md b/.changeset/upset-impalas-grab.md
new file mode 100644
index 0000000000..7a27e22c92
--- /dev/null
+++ b/.changeset/upset-impalas-grab.md
@@ -0,0 +1,12 @@
+---
+"@biomejs/biome": minor
+---
+
+Added **experimental** full support for HTML, Vue, Svelte and Astro files. In this release, the HTML parser
+has been enhanced, and it's now able to parse `.vue`, `.svelte` and `.astro` files.
+
+This means that now Biome is able to lint and format the JavaScript (TypeScript), HTML and CSS code that is contained in these files.
+
+Now that the main architecture is stable and working, in the upcoming patches and minors we will also fix possible inaccuracies and edge cases coming from existing lint rules, such as `noUnusedVariables` inside `<script>` blocks or frontmatter.
+
+The support is considered experimental because there might be cases that aren't fine-parsed yet, hence causing possible inaccuracies when it comes to formatting and linting.
diff --git a/.changeset/wise-forks-hide.md b/.changeset/wise-forks-hide.md
new file mode 100644
index 0000000000..a2a197e520
--- /dev/null
+++ b/.changeset/wise-forks-hide.md
@@ -0,0 +1,18 @@
+---
+"@biomejs/biome": minor
+---
+
+Added a new option called `html.interpolation`. This option enables the parsing of text expressions (or interpolation) in HTML files.
+
+The following `file.html` will be correctly formatted:
+
+```html
+<!-- file.html -->
+<div>
+  Hello {{ name }}!
+  <p>Your balance is: {{ account.balance }}</p>
+  <button>{{ isLoading ? "Loading..." : "Submit" }}</button>
+</div>
+```
+
+To note that `html.interpolation` only parses text expressions that are delimited by double curly braces (`{{ }}`). The content of expressions is parsed as normal text.
diff --git a/crates/biome_cli/src/cli_options.rs b/crates/biome_cli/src/cli_options.rs
index 79ad1001d0..f898e0260f 100644
--- a/crates/biome_cli/src/cli_options.rs
+++ b/crates/biome_cli/src/cli_options.rs
@@ -56,7 +56,7 @@ pub struct CliOptions {
     /// Allows to change how diagnostics and summary are reported.
     #[bpaf(
         long("reporter"),
-        argument("json|json-pretty|github|junit|summary|gitlab|checkstyle|rdjson"),
+        argument("json|json-pretty|github|junit|summary|gitlab"),
         fallback(CliReporter::default())
     )]
     pub reporter: CliReporter,
@@ -154,14 +154,10 @@ pub enum CliReporter {
     GitHub,
     /// Diagnostics and summary are printed in JUnit format
     Junit,
-    /// Reports diagnostics grouped by category and number of hits. Reports formatter diagnostics grouped by file.
+    /// Reports linter diagnostics grouped by category and number of hits. Reports formatter diagnostics grouped by file.
     Summary,
-    /// Reports diagnostics using the [GitLab Code Quality report](https://docs.gitlab.com/ee/ci/testing/code_quality.html#implement-a-custom-tool).
+    /// Reports linter diagnostics using the [GitLab Code Quality report](https://docs.gitlab.com/ee/ci/testing/code_quality.html#implement-a-custom-tool).
     GitLab,
-    /// Reports diagnostics in Checkstyle XML format
-    Checkstyle,
-    /// Reports diagnostics using the [Reviewdog JSON format](https://deepwiki.com/reviewdog/reviewdog/3.2-reviewdog-diagnostic-format)
-    RdJson,
 }
 
 impl CliReporter {
@@ -181,8 +177,6 @@ impl FromStr for CliReporter {
             "github" => Ok(Self::GitHub),
             "junit" => Ok(Self::Junit),
             "gitlab" => Ok(Self::GitLab),
-            "checkstyle" => Ok(Self::Checkstyle),
-            "rdjson" => Ok(Self::RdJson),
             _ => Err(format!(
                 "value {s:?} is not valid for the --reporter argument"
             )),
@@ -200,8 +194,6 @@ impl Display for CliReporter {
             Self::GitHub => f.write_str("github"),
             Self::Junit => f.write_str("junit"),
             Self::GitLab => f.write_str("gitlab"),
-            Self::Checkstyle => f.write_str("checkstyle"),
-            Self::RdJson => f.write_str("rdjson"),
         }
     }
 }
diff --git a/crates/biome_cli/src/commands/check.rs b/crates/biome_cli/src/commands/check.rs
index 0b485256ca..56e4e0c565 100644
--- a/crates/biome_cli/src/commands/check.rs
+++ b/crates/biome_cli/src/commands/check.rs
@@ -4,9 +4,7 @@ use crate::commands::{CommandRunner, get_files_to_process_with_cli_options};
 use crate::{CliDiagnostic, Execution, TraversalMode};
 use biome_configuration::analyzer::LinterEnabled;
 use biome_configuration::analyzer::assist::{AssistConfiguration, AssistEnabled};
-use biome_configuration::css::CssParserConfiguration;
-use biome_configuration::formatter::{FormatWithErrorsEnabled, FormatterEnabled};
-use biome_configuration::json::JsonParserConfiguration;
+use biome_configuration::formatter::FormatterEnabled;
 use biome_configuration::{Configuration, FormatterConfiguration, LinterConfiguration};
 use biome_console::Console;
 use biome_deserialize::Merge;
@@ -28,9 +26,6 @@ pub(crate) struct CheckCommandPayload {
     pub(crate) staged: bool,
     pub(crate) changed: bool,
     pub(crate) since: Option<String>,
-    pub(crate) format_with_errors: Option<FormatWithErrorsEnabled>,
-    pub(crate) json_parser: Option<JsonParserConfiguration>,
-    pub(crate) css_parser: Option<CssParserConfiguration>,
 }
 
 impl LoadEditorConfig for CheckCommandPayload {
@@ -66,9 +61,6 @@ impl CommandRunner for CheckCommandPayload {
         if self.formatter_enabled.is_some() {
             formatter.enabled = self.formatter_enabled;
         }
-        if self.format_with_errors.is_some() {
-            formatter.format_with_errors = self.format_with_errors;
-        }
 
         let linter = configuration
             .linter
@@ -86,16 +78,6 @@ impl CommandRunner for CheckCommandPayload {
             assist.enabled = self.assist_enabled;
         }
 
-        let css = configuration.css.get_or_insert_with(Default::default);
-        if self.css_parser.is_some() {
-            css.parser.merge_with(self.css_parser.clone());
-        }
-
-        let json = configuration.json.get_or_insert_with(Default::default);
-        if self.json_parser.is_some() {
-            json.parser.merge_with(self.json_parser.clone())
-        }
-
         if let Some(mut conf) = self.configuration.clone() {
             if let Some(linter) = conf.linter.as_mut() {
                 // Don't overwrite rules from the CLI configuration.
diff --git a/crates/biome_cli/src/commands/ci.rs b/crates/biome_cli/src/commands/ci.rs
index 41110d46a7..5a791068a7 100644
--- a/crates/biome_cli/src/commands/ci.rs
+++ b/crates/biome_cli/src/commands/ci.rs
@@ -4,12 +4,8 @@ use crate::commands::{CommandRunner, LoadEditorConfig};
 use crate::{CliDiagnostic, Execution};
 use biome_configuration::analyzer::LinterEnabled;
 use biome_configuration::analyzer::assist::{AssistConfiguration, AssistEnabled};
-use biome_configuration::css::CssParserConfiguration;
-use biome_configuration::formatter::{FormatWithErrorsEnabled, FormatterEnabled};
-use biome_configuration::json::JsonParserConfiguration;
-use biome_configuration::{
-    Configuration, CssConfiguration, FormatterConfiguration, JsonConfiguration, LinterConfiguration,
-};
+use biome_configuration::formatter::FormatterEnabled;
+use biome_configuration::{Configuration, FormatterConfiguration, LinterConfiguration};
 use biome_console::Console;
 use biome_deserialize::Merge;
 use biome_fs::FileSystem;
@@ -26,9 +22,6 @@ pub(crate) struct CiCommandPayload {
     pub(crate) configuration: Option<Configuration>,
     pub(crate) changed: bool,
     pub(crate) since: Option<String>,
-    pub(crate) format_with_errors: Option<FormatWithErrorsEnabled>,
-    pub(crate) json_parser: Option<JsonParserConfiguration>,
-    pub(crate) css_parser: Option<CssParserConfiguration>,
 }
 
 impl LoadEditorConfig for CiCommandPayload {
@@ -63,7 +56,6 @@ impl CommandRunner for CiCommandPayload {
 
         if self.formatter_enabled.is_some() {
             formatter.enabled = self.formatter_enabled;
-            formatter.format_with_errors = self.format_with_errors;
         }
 
         let linter = configuration
@@ -74,20 +66,6 @@ impl CommandRunner for CiCommandPayload {
             linter.enabled = self.linter_enabled;
         }
 
-        let json = configuration
-            .json
-            .get_or_insert_with(JsonConfiguration::default);
-        if self.json_parser.is_some() {
-            json.parser.clone_from(&self.json_parser)
-        }
-
-        let css = configuration
-            .css
-            .get_or_insert_with(CssConfiguration::default);
-        if self.css_parser.is_some() {
-            css.parser.clone_from(&self.css_parser);
-        }
-
         let assist = configuration
             .assist
             .get_or_insert_with(AssistConfiguration::default);
diff --git a/crates/biome_cli/src/commands/format.rs b/crates/biome_cli/src/commands/format.rs
index 51578096a9..1ecebbb692 100644
--- a/crates/biome_cli/src/commands/format.rs
+++ b/crates/biome_cli/src/commands/format.rs
@@ -1,11 +1,11 @@
 use crate::cli_options::CliOptions;
 use crate::commands::{CommandRunner, LoadEditorConfig, get_files_to_process_with_cli_options};
 use crate::{CliDiagnostic, Execution, TraversalMode};
-use biome_configuration::css::{CssFormatterConfiguration, CssParserConfiguration};
+use biome_configuration::css::CssFormatterConfiguration;
 use biome_configuration::graphql::GraphqlFormatterConfiguration;
 use biome_configuration::html::HtmlFormatterConfiguration;
 use biome_configuration::javascript::JsFormatterConfiguration;
-use biome_configuration::json::{JsonFormatterConfiguration, JsonParserConfiguration};
+use biome_configuration::json::JsonFormatterConfiguration;
 use biome_configuration::vcs::VcsConfiguration;
 use biome_configuration::{Configuration, FilesConfiguration, FormatterConfiguration};
 use biome_console::Console;
@@ -31,8 +31,6 @@ pub(crate) struct FormatCommandPayload {
     pub(crate) staged: bool,
     pub(crate) changed: bool,
     pub(crate) since: Option<String>,
-    pub(crate) json_parser: Option<JsonParserConfiguration>,
-    pub(crate) css_parser: Option<CssParserConfiguration>,
 }
 
 impl LoadEditorConfig for FormatCommandPayload {
@@ -75,15 +73,10 @@ impl CommandRunner for FormatCommandPayload {
 
             formatter.enabled = Some(true.into());
         }
-        let css = configuration.css.get_or_insert_with(Default::default);
         if self.css_formatter.is_some() {
+            let css = configuration.css.get_or_insert_with(Default::default);
             css.formatter.merge_with(self.css_formatter.clone());
         }
-
-        if self.css_parser.is_some() {
-            css.parser.merge_with(self.css_parser.clone());
-        }
-
         if self.graphql_formatter.is_some() {
             let graphql = configuration.graphql.get_or_insert_with(Default::default);
             graphql.formatter.merge_with(self.graphql_formatter.clone());
@@ -101,14 +94,10 @@ impl CommandRunner for FormatCommandPayload {
                 .formatter
                 .merge_with(self.javascript_formatter.clone());
         }
-        let json = configuration.json.get_or_insert_with(Default::default);
-
         if self.json_formatter.is_some() {
+            let json = configuration.json.get_or_insert_with(Default::default);
             json.formatter.merge_with(self.json_formatter.clone());
         }
-        if self.json_parser.is_some() {
-            json.parser.merge_with(self.json_parser.clone())
-        }
 
         configuration
             .files
diff --git a/crates/biome_cli/src/commands/lint.rs b/crates/biome_cli/src/commands/lint.rs
index 2526326eeb..1992421aae 100644
--- a/crates/biome_cli/src/commands/lint.rs
+++ b/crates/biome_cli/src/commands/lint.rs
@@ -3,10 +3,10 @@ use crate::cli_options::CliOptions;
 use crate::commands::{CommandRunner, get_files_to_process_with_cli_options};
 use crate::{CliDiagnostic, Execution, TraversalMode};
 use biome_configuration::analyzer::AnalyzerSelector;
-use biome_configuration::css::{CssLinterConfiguration, CssParserConfiguration};
+use biome_configuration::css::CssLinterConfiguration;
 use biome_configuration::graphql::GraphqlLinterConfiguration;
 use biome_configuration::javascript::JsLinterConfiguration;
-use biome_configuration::json::{JsonLinterConfiguration, JsonParserConfiguration};
+use biome_configuration::json::JsonLinterConfiguration;
 use biome_configuration::vcs::VcsConfiguration;
 use biome_configuration::{Configuration, FilesConfiguration, LinterConfiguration};
 use biome_console::Console;
@@ -36,8 +36,6 @@ pub(crate) struct LintCommandPayload {
     pub(crate) json_linter: Option<JsonLinterConfiguration>,
     pub(crate) css_linter: Option<CssLinterConfiguration>,
     pub(crate) graphql_linter: Option<GraphqlLinterConfiguration>,
-    pub(crate) json_parser: Option<JsonParserConfiguration>,
-    pub(crate) css_parser: Option<CssParserConfiguration>,
 }
 
 impl CommandRunner for LintCommandPayload {
@@ -73,13 +71,10 @@ impl CommandRunner for LintCommandPayload {
             ..Default::default()
         });
 
-        let css = fs_configuration.css.get_or_insert_with(Default::default);
         if self.css_linter.is_some() {
+            let css = fs_configuration.css.get_or_insert_with(Default::default);
             css.linter.merge_with(self.css_linter.clone());
         }
-        if self.css_parser.is_some() {
-            css.parser.merge_with(self.css_parser.clone());
-        }
 
         if self.graphql_linter.is_some() {
             let graphql = fs_configuration
@@ -93,13 +88,10 @@ impl CommandRunner for LintCommandPayload {
                 .get_or_insert_with(Default::default);
             javascript.linter.merge_with(self.javascript_linter.clone());
         }
-        let json = fs_configuration.json.get_or_insert_with(Default::default);
         if self.json_linter.is_some() {
+            let json = fs_configuration.json.get_or_insert_with(Default::default);
             json.linter.merge_with(self.json_linter.clone());
         }
-        if self.json_parser.is_some() {
-            json.parser.merge_with(self.json_parser.clone());
-        }
 
         Ok(fs_configuration)
     }
diff --git a/crates/biome_cli/src/commands/mod.rs b/crates/biome_cli/src/commands/mod.rs
index 9ebad78f51..083c3f3e3f 100644
--- a/crates/biome_cli/src/commands/mod.rs
+++ b/crates/biome_cli/src/commands/mod.rs
@@ -9,31 +9,21 @@ use crate::{
 };
 use biome_configuration::analyzer::assist::AssistEnabled;
 use biome_configuration::analyzer::{AnalyzerSelector, LinterEnabled};
-use biome_configuration::css::{
-    CssFormatterConfiguration, CssLinterConfiguration, CssParserConfiguration,
-};
-use biome_configuration::formatter::{FormatWithErrorsEnabled, FormatterEnabled};
+use biome_configuration::css::{CssFormatterConfiguration, CssLinterConfiguration};
+use biome_configuration::formatter::FormatterEnabled;
 use biome_configuration::graphql::{GraphqlFormatterConfiguration, GraphqlLinterConfiguration};
 use biome_configuration::html::{HtmlFormatterConfiguration, html_formatter_configuration};
 use biome_configuration::javascript::{JsFormatterConfiguration, JsLinterConfiguration};
-use biome_configuration::json::{
-    JsonFormatterConfiguration, JsonLinterConfiguration, JsonParserConfiguration,
-};
+use biome_configuration::json::{JsonFormatterConfiguration, JsonLinterConfiguration};
 use biome_configuration::vcs::VcsConfiguration;
 use biome_configuration::{BiomeDiagnostic, Configuration};
 use biome_configuration::{
     FilesConfiguration, FormatterConfiguration, LinterConfiguration, configuration,
-    css::{css_formatter_configuration, css_linter_configuration, css_parser_configuration},
-    files_configuration, formatter_configuration,
-    graphql::graphql_formatter_configuration,
-    graphql::graphql_linter_configuration,
-    javascript::js_formatter_configuration,
-    javascript::js_linter_configuration,
-    json::json_formatter_configuration,
-    json::json_linter_configuration,
-    json::json_parser_configuration,
-    linter_configuration,
-    vcs::vcs_configuration,
+    css::css_formatter_configuration, css::css_linter_configuration, files_configuration,
+    formatter_configuration, graphql::graphql_formatter_configuration,
+    graphql::graphql_linter_configuration, javascript::js_formatter_configuration,
+    javascript::js_linter_configuration, json::json_formatter_configuration,
+    json::json_linter_configuration, linter_configuration, vcs::vcs_configuration,
 };
 use biome_console::{Console, ConsoleExt, markup};
 use biome_deserialize::Merge;
@@ -156,17 +146,6 @@ pub enum BiomeCommand {
         #[bpaf(long("enforce-assist"), argument("true|false"), fallback(true))]
         enforce_assist: bool,
 
-        /// Whether formatting should be allowed to proceed if a given file
-        /// has syntax errors
-        #[bpaf(long("format-with-errors"), argument("true|false"))]
-        format_with_errors: Option<FormatWithErrorsEnabled>,
-
-        #[bpaf(external(json_parser_configuration), optional, hide_usage)]
-        json_parser: Option<JsonParserConfiguration>,
-
-        #[bpaf(external(css_parser_configuration), optional, hide_usage, hide)]
-        css_parser: Option<CssParserConfiguration>,
-
         #[bpaf(external(configuration), hide_usage, optional)]
         configuration: Option<Configuration>,
         #[bpaf(external, hide_usage)]
@@ -230,12 +209,6 @@ pub enum BiomeCommand {
         #[bpaf(long("reason"), argument("STRING"))]
         suppression_reason: Option<String>,
 
-        #[bpaf(external(json_parser_configuration), optional, hide_usage)]
-        json_parser: Option<JsonParserConfiguration>,
-
-        #[bpaf(external(css_parser_configuration), optional, hide_usage, hide)]
-        css_parser: Option<CssParserConfiguration>,
-
         #[bpaf(external(linter_configuration), hide_usage, optional)]
         linter_configuration: Option<LinterConfiguration>,
 
@@ -321,18 +294,12 @@ pub enum BiomeCommand {
         #[bpaf(external(json_formatter_configuration), optional, hide_usage)]
         json_formatter: Option<JsonFormatterConfiguration>,
 
-        #[bpaf(external(json_parser_configuration), optional, hide_usage)]
-        json_parser: Option<JsonParserConfiguration>,
-
-        #[bpaf(external(css_parser_configuration), optional, hide_usage, hide)]
-        css_parser: Option<CssParserConfiguration>,
+        #[bpaf(external(css_formatter_configuration), optional, hide_usage, hide)]
+        css_formatter: Option<CssFormatterConfiguration>,
 
         #[bpaf(external(graphql_formatter_configuration), optional, hide_usage, hide)]
         graphql_formatter: Option<GraphqlFormatterConfiguration>,
 
-        #[bpaf(external(css_formatter_configuration), optional, hide_usage, hide)]
-        css_formatter: Option<CssFormatterConfiguration>,
-
         #[bpaf(external(html_formatter_configuration), optional, hide_usage, hide)]
         html_formatter: Option<HtmlFormatterConfiguration>,
 
@@ -398,17 +365,6 @@ pub enum BiomeCommand {
         #[bpaf(long("assist-enabled"), argument("true|false"), optional)]
         assist_enabled: Option<AssistEnabled>,
 
-        /// Whether formatting should be allowed to proceed if a given file
-        /// has syntax errors
-        #[bpaf(long("format-with-errors"), argument("true|false"))]
-        format_with_errors: Option<FormatWithErrorsEnabled>,
-
-        #[bpaf(external(json_parser_configuration), optional, hide_usage)]
-        json_parser: Option<JsonParserConfiguration>,
-
-        #[bpaf(external(css_parser_configuration), optional, hide_usage, hide)]
-        css_parser: Option<CssParserConfiguration>,
-
         /// Allows enforcing assist, and make the CLI fail if some actions aren't applied. Defaults to `true`.
         #[bpaf(long("enforce-assist"), argument("true|false"), fallback(true))]
         enforce_assist: bool,
diff --git a/crates/biome_cli/src/execute/mod.rs b/crates/biome_cli/src/execute/mod.rs
index 16c3c1ca05..1a58281e68 100644
--- a/crates/biome_cli/src/execute/mod.rs
+++ b/crates/biome_cli/src/execute/mod.rs
@@ -9,12 +9,10 @@ use crate::commands::MigrateSubCommand;
 use crate::diagnostics::ReportDiagnostic;
 use crate::execute::migrate::MigratePayload;
 use crate::execute::traverse::{TraverseResult, traverse};
-use crate::reporter::checkstyle::CheckstyleReporter;
 use crate::reporter::github::{GithubReporter, GithubReporterVisitor};
 use crate::reporter::gitlab::{GitLabReporter, GitLabReporterVisitor};
 use crate::reporter::json::{JsonReporter, JsonReporterVisitor};
 use crate::reporter::junit::{JunitReporter, JunitReporterVisitor};
-use crate::reporter::rdjson::{RdJsonReporter, RdJsonReporterVisitor};
 use crate::reporter::summary::{SummaryReporter, SummaryReporterVisitor};
 use crate::reporter::terminal::{ConsoleReporter, ConsoleReporterVisitor};
 use crate::{
@@ -248,10 +246,6 @@ pub enum ReportMode {
     Junit,
     /// Reports information in the [GitLab Code Quality](https://docs.gitlab.com/ee/ci/testing/code_quality.html#implement-a-custom-tool) format.
     GitLab,
-    /// Reports diagnostics in [Checkstyle XML format](https://checkstyle.org/).
-    Checkstyle,
-    /// Reports information in [reviewdog JSON format](https://deepwiki.com/reviewdog/reviewdog/3.2-reviewdog-diagnostic-format)
-    RdJson,
 }
 
 impl Default for ReportMode {
@@ -274,8 +268,6 @@ impl From<CliReporter> for ReportMode {
             CliReporter::GitHub => Self::GitHub,
             CliReporter::Junit => Self::Junit,
             CliReporter::GitLab => Self::GitLab {},
-            CliReporter::Checkstyle => Self::Checkstyle,
-            CliReporter::RdJson => Self::RdJson,
         }
     }
 }
@@ -711,26 +703,6 @@ pub fn execute_mode(
             };
             reporter.write(&mut JunitReporterVisitor::new(console))?;
         }
-        ReportMode::Checkstyle => {
-            let reporter = CheckstyleReporter {
-                summary,
-                diagnostics_payload,
-                execution: execution.clone(),
-                verbose: cli_options.verbose,
-                working_directory: fs.working_directory().clone(),
-            };
-            reporter
-                .write(&mut crate::reporter::checkstyle::CheckstyleReporterVisitor::new(console))?;
-        }
-        ReportMode::RdJson => {
-            let reporter = RdJsonReporter {
-                diagnostics_payload,
-                execution: execution.clone(),
-                verbose: cli_options.verbose,
-                working_directory: fs.working_directory().clone(),
-            };
-            reporter.write(&mut RdJsonReporterVisitor(console))?;
-        }
     }
 
     // Processing emitted error diagnostics, exit with a non-zero code
diff --git a/crates/biome_cli/src/execute/process_file.rs b/crates/biome_cli/src/execute/process_file.rs
index 019cf01c29..978d3c6465 100644
--- a/crates/biome_cli/src/execute/process_file.rs
+++ b/crates/biome_cli/src/execute/process_file.rs
@@ -197,14 +197,15 @@ pub(crate) fn process_file(ctx: &TraversalOptions, biome_path: &BiomePath) -> Fi
                 suppress,
                 suppression_reason.as_deref(),
                 categories.build(),
+                &file_features,
             )
         }
         TraversalMode::Format { .. } => {
             // the unsupported case should be handled already at this point
-            format(shared_context, biome_path.clone())
+            format(shared_context, biome_path.clone(), &file_features)
         }
         TraversalMode::Check { .. } | TraversalMode::CI { .. } => {
-            check_file(shared_context, biome_path.clone(), file_features)
+            check_file(shared_context, biome_path.clone(), &file_features)
         }
         TraversalMode::Migrate { .. } => {
             unreachable!("The migration should not be called for this file")
diff --git a/crates/biome_cli/src/execute/process_file/check.rs b/crates/biome_cli/src/execute/process_file/check.rs
index aef9c788c1..ff69d8162b 100644
--- a/crates/biome_cli/src/execute/process_file/check.rs
+++ b/crates/biome_cli/src/execute/process_file/check.rs
@@ -11,7 +11,7 @@ use biome_service::workspace::FeaturesSupported;
 pub(crate) fn check_file<'ctx>(
     ctx: &'ctx SharedTraversalOptions<'ctx, '_>,
     path: BiomePath,
-    file_features: FeaturesSupported,
+    file_features: &FeaturesSupported,
 ) -> FileResult {
     let mut has_failures = false;
     let mut workspace_file = WorkspaceFile::new(ctx, path)?;
@@ -34,8 +34,14 @@ pub(crate) fn check_file<'ctx>(
         categories = categories.with_assist();
     }
 
-    let analyzer_result =
-        analyze_with_guard(ctx, &mut workspace_file, false, None, categories.build());
+    let analyzer_result = analyze_with_guard(
+        ctx,
+        &mut workspace_file,
+        false,
+        None,
+        categories.build(),
+        file_features,
+    );
 
     let mut changed = false;
     // To reduce duplication of the same error on format and lint_and_assist
@@ -67,7 +73,7 @@ pub(crate) fn check_file<'ctx>(
         if ctx.execution.should_skip_parse_errors() && skipped_parse_error {
             // Parse errors are already skipped during the analyze phase, so no need to do it here.
         } else {
-            let format_result = format_with_guard(ctx, &mut workspace_file);
+            let format_result = format_with_guard(ctx, &mut workspace_file, file_features);
             match format_result {
                 Ok(status) => {
                     if status.is_changed() {
diff --git a/crates/biome_cli/src/execute/process_file/format.rs b/crates/biome_cli/src/execute/process_file/format.rs
index ce324721d3..c24f5aaf92 100644
--- a/crates/biome_cli/src/execute/process_file/format.rs
+++ b/crates/biome_cli/src/execute/process_file/format.rs
@@ -7,13 +7,17 @@ use biome_analyze::RuleCategoriesBuilder;
 use biome_diagnostics::{Diagnostic, DiagnosticExt, Error, Severity, category};
 use biome_fs::{BiomePath, TraversalContext};
 use biome_service::diagnostics::FileTooLarge;
-use biome_service::file_handlers::{AstroFileHandler, SvelteFileHandler, VueFileHandler};
+use biome_service::file_handlers::astro::AstroFileHandler;
+use biome_service::file_handlers::svelte::SvelteFileHandler;
+use biome_service::file_handlers::vue::VueFileHandler;
+use biome_service::workspace::FeaturesSupported;
 use tracing::{debug, instrument};
 
 #[instrument(name = "cli_format", level = "debug", skip(ctx, path))]
 pub(crate) fn format<'ctx>(
     ctx: &'ctx SharedTraversalOptions<'ctx, '_>,
     path: BiomePath,
+    features_supported: &FeaturesSupported,
 ) -> FileResult {
     let mut workspace_file = WorkspaceFile::new(ctx, path)?;
     let result = workspace_file.guard().check_file_size()?;
@@ -25,7 +29,7 @@ pub(crate) fn format<'ctx>(
         );
         Ok(FileStatus::Ignored)
     } else {
-        format_with_guard(ctx, &mut workspace_file)
+        format_with_guard(ctx, &mut workspace_file, features_supported)
     }
 }
 
@@ -33,6 +37,7 @@ pub(crate) fn format<'ctx>(
 pub(crate) fn format_with_guard<'ctx>(
     ctx: &'ctx SharedTraversalOptions<'ctx, '_>,
     workspace_file: &mut WorkspaceFile,
+    features_supported: &FeaturesSupported,
 ) -> FileResult {
     let diagnostics_result = workspace_file
         .guard()
@@ -87,27 +92,29 @@ pub(crate) fn format_with_guard<'ctx>(
 
     let mut output = printed.into_code();
 
-    match workspace_file.as_extension() {
-        Some("astro") => {
-            if output.is_empty() {
-                return Ok(FileStatus::Unchanged);
+    if !features_supported.supports_full_html_support() {
+        match workspace_file.as_extension() {
+            Some("astro") => {
+                if output.is_empty() {
+                    return Ok(FileStatus::Unchanged);
+                }
+                output = AstroFileHandler::output(input.as_str(), output.as_str());
             }
-            output = AstroFileHandler::output(input.as_str(), output.as_str());
-        }
-        Some("vue") => {
-            if output.is_empty() {
-                return Ok(FileStatus::Unchanged);
+            Some("vue") => {
+                if output.is_empty() {
+                    return Ok(FileStatus::Unchanged);
+                }
+                output = VueFileHandler::output(input.as_str(), output.as_str());
             }
-            output = VueFileHandler::output(input.as_str(), output.as_str());
-        }
 
-        Some("svelte") => {
-            if output.is_empty() {
-                return Ok(FileStatus::Unchanged);
+            Some("svelte") => {
+                if output.is_empty() {
+                    return Ok(FileStatus::Unchanged);
+                }
+                output = SvelteFileHandler::output(input.as_str(), output.as_str());
             }
-            output = SvelteFileHandler::output(input.as_str(), output.as_str());
+            _ => {}
         }
-        _ => {}
     }
 
     debug!("Format output is different from input: {}", output != input);
diff --git a/crates/biome_cli/src/execute/process_file/lint_and_assist.rs b/crates/biome_cli/src/execute/process_file/lint_and_assist.rs
index a025e4fcbe..21aacf6213 100644
--- a/crates/biome_cli/src/execute/process_file/lint_and_assist.rs
+++ b/crates/biome_cli/src/execute/process_file/lint_and_assist.rs
@@ -7,7 +7,10 @@ use biome_diagnostics::{Diagnostic, DiagnosticExt, Error, Severity, category};
 use biome_fs::{BiomePath, TraversalContext};
 use biome_rowan::TextSize;
 use biome_service::diagnostics::FileTooLarge;
-use biome_service::file_handlers::{AstroFileHandler, SvelteFileHandler, VueFileHandler};
+use biome_service::file_handlers::astro::AstroFileHandler;
+use biome_service::file_handlers::svelte::SvelteFileHandler;
+use biome_service::file_handlers::vue::VueFileHandler;
+use biome_service::workspace::FeaturesSupported;
 use tracing::{info, instrument};
 
 /// Lints a single file and returns a [FileResult]
@@ -18,6 +21,7 @@ pub(crate) fn lint_and_assist<'ctx>(
     suppress: bool,
     suppression_reason: Option<&str>,
     categories: RuleCategories,
+    features_supported: &FeaturesSupported,
 ) -> FileResult {
     let mut workspace_file = WorkspaceFile::new(ctx, path)?;
     let result = workspace_file.guard().check_file_size()?;
@@ -35,6 +39,7 @@ pub(crate) fn lint_and_assist<'ctx>(
             suppress,
             suppression_reason,
             categories,
+            features_supported,
         )
     }
 }
@@ -47,6 +52,7 @@ pub(crate) fn analyze_with_guard<'ctx>(
     suppress: bool,
     suppression_reason: Option<&str>,
     categories: RuleCategories,
+    features_supported: &FeaturesSupported,
 ) -> FileResult {
     let mut input = workspace_file.input()?;
     let mut changed = false;
@@ -91,17 +97,19 @@ pub(crate) fn analyze_with_guard<'ctx>(
 
         let mut output = fix_result.code;
 
-        match workspace_file.as_extension() {
-            Some("astro") => {
-                output = AstroFileHandler::output(input.as_str(), output.as_str());
+        if !features_supported.supports_full_html_support() {
+            match workspace_file.as_extension() {
+                Some("astro") => {
+                    output = AstroFileHandler::output(input.as_str(), output.as_str());
+                }
+                Some("vue") => {
+                    output = VueFileHandler::output(input.as_str(), output.as_str());
+                }
+                Some("svelte") => {
+                    output = SvelteFileHandler::output(input.as_str(), output.as_str());
+                }
+                _ => {}
             }
-            Some("vue") => {
-                output = VueFileHandler::output(input.as_str(), output.as_str());
-            }
-            Some("svelte") => {
-                output = SvelteFileHandler::output(input.as_str(), output.as_str());
-            }
-            _ => {}
         }
         if output != input {
             changed = true;
@@ -130,11 +138,15 @@ pub(crate) fn analyze_with_guard<'ctx>(
         && pull_diagnostics_result.skipped_diagnostics == 0;
 
     if !no_diagnostics {
-        let offset = match workspace_file.as_extension() {
-            Some("vue") => VueFileHandler::start(input.as_str()),
-            Some("astro") => AstroFileHandler::start(input.as_str()),
-            Some("svelte") => SvelteFileHandler::start(input.as_str()),
-            _ => None,
+        let offset = if features_supported.supports_full_html_support() {
+            None
+        } else {
+            match workspace_file.as_extension() {
+                Some("vue") => VueFileHandler::start(input.as_str()),
+                Some("astro") => AstroFileHandler::start(input.as_str()),
+                Some("svelte") => SvelteFileHandler::start(input.as_str()),
+                _ => None,
+            }
         };
 
         ctx.push_message(Message::Diagnostics {
diff --git a/crates/biome_cli/src/execute/process_file/search.rs b/crates/biome_cli/src/execute/process_file/search.rs
index d28078d8ba..65122f3c77 100644
--- a/crates/biome_cli/src/execute/process_file/search.rs
+++ b/crates/biome_cli/src/execute/process_file/search.rs
@@ -35,7 +35,7 @@ pub(crate) fn search_with_guard<'ctx>(
 ) -> FileResult {
     let _ = tracing::info_span!("Search ", path =? workspace_file.path).entered();
 
-    let file_source = DocumentFileSource::from_path(workspace_file.path.as_path());
+    let file_source = DocumentFileSource::from_path(workspace_file.path.as_path(), false);
     let pattern_language = match &_ctx.execution.traversal_mode {
         TraversalMode::Search {
             language: Some(pattern_language),
diff --git a/crates/biome_cli/src/execute/std_in.rs b/crates/biome_cli/src/execute/std_in.rs
index 1420358c88..6972f7750e 100644
--- a/crates/biome_cli/src/execute/std_in.rs
+++ b/crates/biome_cli/src/execute/std_in.rs
@@ -78,11 +78,15 @@ pub(crate) fn run<'a>(
             })?;
 
             let code = printed.into_code();
-            let output = match biome_path.extension() {
-                Some("astro") => AstroFileHandler::output(content, code.as_str()),
-                Some("vue") => VueFileHandler::output(content, code.as_str()),
-                Some("svelte") => SvelteFileHandler::output(content, code.as_str()),
-                _ => code,
+            let output = if !file_features.supports_full_html_support() {
+                match biome_path.extension() {
+                    Some("astro") => AstroFileHandler::output(content, code.as_str()),
+                    Some("vue") => VueFileHandler::output(content, code.as_str()),
+                    Some("svelte") => SvelteFileHandler::output(content, code.as_str()),
+                    _ => code,
+                }
+            } else {
+                code
             };
             console.append(markup! {
                 {output}
@@ -174,11 +178,15 @@ pub(crate) fn run<'a>(
                 rule_categories: rule_categories.build(),
             })?;
             let code = fix_file_result.code;
-            let output = match biome_path.extension() {
-                Some("astro") => AstroFileHandler::output(&new_content, code.as_str()),
-                Some("vue") => VueFileHandler::output(&new_content, code.as_str()),
-                Some("svelte") => SvelteFileHandler::output(&new_content, code.as_str()),
-                _ => code,
+            let output = if !file_features.supports_full_html_support() {
+                match biome_path.extension() {
+                    Some("astro") => AstroFileHandler::output(&new_content, code.as_str()),
+                    Some("vue") => VueFileHandler::output(&new_content, code.as_str()),
+                    Some("svelte") => SvelteFileHandler::output(&new_content, code.as_str()),
+                    _ => code,
+                }
+            } else {
+                code
             };
             if output != new_content {
                 version += 1;
@@ -198,11 +206,15 @@ pub(crate) fn run<'a>(
                 path: biome_path.clone(),
             })?;
             let code = printed.into_code();
-            let output = match biome_path.extension() {
-                Some("astro") => AstroFileHandler::output(&new_content, code.as_str()),
-                Some("vue") => VueFileHandler::output(&new_content, code.as_str()),
-                Some("svelte") => SvelteFileHandler::output(&new_content, code.as_str()),
-                _ => code,
+            let output = if !file_features.supports_full_html_support() {
+                match biome_path.extension() {
+                    Some("astro") => AstroFileHandler::output(&new_content, code.as_str()),
+                    Some("vue") => VueFileHandler::output(&new_content, code.as_str()),
+                    Some("svelte") => SvelteFileHandler::output(&new_content, code.as_str()),
+                    _ => code,
+                }
+            } else {
+                code
             };
             if (mode.is_safe_fixes_enabled() || mode.is_safe_and_unsafe_fixes_enabled())
                 && output != new_content
diff --git a/crates/biome_cli/src/lib.rs b/crates/biome_cli/src/lib.rs
index 393b0bc432..a1edd8296e 100644
--- a/crates/biome_cli/src/lib.rs
+++ b/crates/biome_cli/src/lib.rs
@@ -91,9 +91,6 @@ impl<'app> CliSession<'app> {
                 staged,
                 changed,
                 since,
-                format_with_errors,
-                json_parser,
-                css_parser,
             } => run_command(
                 self,
                 &cli_options,
@@ -111,9 +108,6 @@ impl<'app> CliSession<'app> {
                     staged,
                     changed,
                     since,
-                    format_with_errors,
-                    json_parser,
-                    css_parser,
                 },
             ),
             BiomeCommand::Lint {
@@ -137,8 +131,6 @@ impl<'app> CliSession<'app> {
                 javascript_linter,
                 json_linter,
                 graphql_linter,
-                css_parser,
-                json_parser,
             } => run_command(
                 self,
                 &cli_options,
@@ -162,8 +154,6 @@ impl<'app> CliSession<'app> {
                     javascript_linter,
                     json_linter,
                     graphql_linter,
-                    css_parser,
-                    json_parser,
                 },
             ),
             BiomeCommand::Ci {
@@ -176,9 +166,6 @@ impl<'app> CliSession<'app> {
                 cli_options,
                 changed,
                 since,
-                format_with_errors,
-                css_parser,
-                json_parser,
                 ..
             } => run_command(
                 self,
@@ -192,9 +179,6 @@ impl<'app> CliSession<'app> {
                     paths,
                     changed,
                     since,
-                    format_with_errors,
-                    css_parser,
-                    json_parser,
                 },
             ),
             BiomeCommand::Format {
@@ -214,8 +198,6 @@ impl<'app> CliSession<'app> {
                 staged,
                 changed,
                 since,
-                css_parser,
-                json_parser,
             } => run_command(
                 self,
                 &cli_options,
@@ -235,8 +217,6 @@ impl<'app> CliSession<'app> {
                     staged,
                     changed,
                     since,
-                    css_parser,
-                    json_parser,
                 },
             ),
             BiomeCommand::Explain { doc } => commands::explain::explain(self, doc),
diff --git a/crates/biome_cli/src/reporter/checkstyle.rs b/crates/biome_cli/src/reporter/checkstyle.rs
deleted file mode 100644
index 87c23a5a54..0000000000
--- a/crates/biome_cli/src/reporter/checkstyle.rs
+++ /dev/null
@@ -1,124 +0,0 @@
-use crate::{DiagnosticsPayload, Execution, Reporter, ReporterVisitor, TraversalSummary};
-use biome_console::{Console, ConsoleExt, markup};
-use biome_diagnostics::display::SourceFile;
-use biome_diagnostics::{Error, PrintDescription, Resource, Severity};
-use camino::{Utf8Path, Utf8PathBuf};
-use std::collections::BTreeMap;
-use std::io::{self, Write};
-
-pub struct CheckstyleReporter {
-    pub summary: TraversalSummary,
-    pub diagnostics_payload: DiagnosticsPayload,
-    pub execution: Execution,
-    pub verbose: bool,
-    pub(crate) working_directory: Option<Utf8PathBuf>,
-}
-
-impl Reporter for CheckstyleReporter {
-    fn write(self, visitor: &mut dyn ReporterVisitor) -> io::Result<()> {
-        visitor.report_summary(&self.execution, self.summary, self.verbose)?;
-        visitor.report_diagnostics(
-            &self.execution,
-            self.diagnostics_payload,
-            self.verbose,
-            self.working_directory.as_deref(),
-        )?;
-        Ok(())
-    }
-}
-
-pub struct CheckstyleReporterVisitor<'a> {
-    console: &'a mut dyn Console,
-}
-
-impl<'a> CheckstyleReporterVisitor<'a> {
-    pub fn new(console: &'a mut dyn Console) -> Self {
-        Self { console }
-    }
-}
-
-impl<'a> ReporterVisitor for CheckstyleReporterVisitor<'a> {
-    fn report_summary(
-        &mut self,
-        _execution: &Execution,
-        _summary: TraversalSummary,
-        _verbose: bool,
-    ) -> io::Result<()> {
-        Ok(())
-    }
-
-    fn report_diagnostics(
-        &mut self,
-        _execution: &Execution,
-        payload: DiagnosticsPayload,
-        verbose: bool,
-        _working_directory: Option<&Utf8Path>,
-    ) -> io::Result<()> {
-        let mut files: BTreeMap<String, Vec<&Error>> = BTreeMap::new();
-        for diagnostic in &payload.diagnostics {
-            if diagnostic.severity() >= payload.diagnostic_level {
-                if diagnostic.tags().is_verbose() && !verbose {
-                    continue;
-                }
-                let path = match diagnostic.location().resource {
-                    Some(Resource::File(file)) => file.to_string(),
-                    _ => "<unknown>".to_string(),
-                };
-                files.entry(path).or_default().push(diagnostic);
-            }
-        }
-        let mut output = Vec::new();
-        writeln!(output, "<?xml version=\"1.0\" encoding=\"utf-8\"?>")?;
-        writeln!(output, "<checkstyle version=\"4.3\">")?;
-        for (file, diagnostics) in files {
-            writeln!(output, "  <file name=\"{}\">", xml_escape(&file))?;
-            for diagnostic in diagnostics {
-                let location = diagnostic.location();
-                let (line, column) = if let (Some(span), Some(source_code)) =
-                    (location.span, location.source_code)
-                {
-                    let source = SourceFile::new(source_code);
-                    if let Ok(start) = source.location(span.start()) {
-                        (start.line_number.get(), start.column_number.get())
-                    } else {
-                        (0, 0)
-                    }
-                } else {
-                    (0, 0)
-                };
-                let severity = match diagnostic.severity() {
-                    Severity::Error => "error",
-                    Severity::Warning => "warning",
-                    Severity::Information | Severity::Hint => "info",
-                    Severity::Fatal => "error",
-                };
-                let description = PrintDescription(diagnostic).to_string();
-                let source = diagnostic.category().map_or("", |c| c.name());
-                writeln!(
-                    output,
-                    "    <error line=\"{}\" column=\"{}\" severity=\"{}\" message=\"{}\" source=\"{}\" />",
-                    line,
-                    column,
-                    severity,
-                    xml_escape(&description),
-                    xml_escape(source),
-                )?;
-            }
-            writeln!(output, "  </file>")?;
-        }
-        writeln!(output, "</checkstyle>")?;
-        self.console.log(markup! {{
-            (String::from_utf8_lossy(&output))
-        }});
-        Ok(())
-    }
-}
-
-fn xml_escape(input: &str) -> String {
-    input
-        .replace('&', "&amp;")
-        .replace('<', "&lt;")
-        .replace('>', "&gt;")
-        .replace('"', "&quot;")
-        .replace('\'', "&apos;")
-}
diff --git a/crates/biome_cli/src/reporter/junit.rs b/crates/biome_cli/src/reporter/junit.rs
index bf42ea8988..2b6aeddb28 100644
--- a/crates/biome_cli/src/reporter/junit.rs
+++ b/crates/biome_cli/src/reporter/junit.rs
@@ -90,8 +90,8 @@ impl ReporterVisitor for JunitReporterVisitor<'_> {
 
                 status.set_description(format!(
                     "line {row:?}, col {col:?}, {body}",
-                    row = start.line_number.get(),
-                    col = start.column_number.get(),
+                    row = start.line_number.to_zero_indexed(),
+                    col = start.column_number.to_zero_indexed(),
                     body = message
                 ));
                 let mut case = TestCase::new(
diff --git a/crates/biome_cli/src/reporter/mod.rs b/crates/biome_cli/src/reporter/mod.rs
index fc78cb510a..599be5e2a2 100644
--- a/crates/biome_cli/src/reporter/mod.rs
+++ b/crates/biome_cli/src/reporter/mod.rs
@@ -1,9 +1,7 @@
-pub(crate) mod checkstyle;
 pub(crate) mod github;
 pub(crate) mod gitlab;
 pub(crate) mod json;
 pub(crate) mod junit;
-pub(crate) mod rdjson;
 pub(crate) mod summary;
 pub(crate) mod terminal;
 
diff --git a/crates/biome_cli/src/reporter/rdjson.rs b/crates/biome_cli/src/reporter/rdjson.rs
deleted file mode 100644
index 0ec9f288d3..0000000000
--- a/crates/biome_cli/src/reporter/rdjson.rs
+++ /dev/null
@@ -1,254 +0,0 @@
-use crate::{DiagnosticsPayload, Execution, Reporter, ReporterVisitor, TraversalSummary};
-use biome_console::fmt::{Display, Formatter};
-use biome_console::{Console, ConsoleExt, MarkupBuf, markup};
-use biome_diagnostics::display::{SourceFile, markup_to_string};
-use biome_diagnostics::{Error, Location, LogCategory, PrintDescription, Visit};
-use camino::{Utf8Path, Utf8PathBuf};
-use serde::Serialize;
-
-pub(crate) struct RdJsonReporter {
-    pub(crate) diagnostics_payload: DiagnosticsPayload,
-    pub(crate) execution: Execution,
-    pub(crate) verbose: bool,
-    pub(crate) working_directory: Option<Utf8PathBuf>,
-}
-
-impl Reporter for RdJsonReporter {
-    fn write(self, visitor: &mut dyn ReporterVisitor) -> std::io::Result<()> {
-        visitor.report_diagnostics(
-            &self.execution,
-            self.diagnostics_payload,
-            self.verbose,
-            self.working_directory.as_deref(),
-        )?;
-        Ok(())
-    }
-}
-
-pub(crate) struct RdJsonReporterVisitor<'a>(pub(crate) &'a mut dyn Console);
-
-impl ReporterVisitor for RdJsonReporterVisitor<'_> {
-    fn report_summary(
-        &mut self,
-        _execution: &Execution,
-        _summary: TraversalSummary,
-        _verbose: bool,
-    ) -> std::io::Result<()> {
-        Ok(())
-    }
-
-    fn report_diagnostics(
-        &mut self,
-        _execution: &Execution,
-        payload: DiagnosticsPayload,
-        verbose: bool,
-        _working_directory: Option<&Utf8Path>,
-    ) -> std::io::Result<()> {
-        let rdjson_diagnostics: Vec<_> = payload
-            .diagnostics
-            .iter()
-            .filter_map(|diagnostic| {
-                if diagnostic.severity() >= payload.diagnostic_level {
-                    if diagnostic.tags().is_verbose() {
-                        if verbose {
-                            diagnostic_to_rdjson(diagnostic)
-                        } else {
-                            None
-                        }
-                    } else {
-                        diagnostic_to_rdjson(diagnostic)
-                    }
-                } else {
-                    None
-                }
-            })
-            .collect();
-
-        let report = RdJsonReport {
-            source: RdJsonSource {
-                name: "Biome",
-                url: "https://biomejs.dev",
-            },
-            diagnostics: rdjson_diagnostics,
-        };
-
-        let result = serde_json::to_string_pretty(&report)?;
-
-        self.0.log(markup! {
-            {result}
-        });
-
-        Ok(())
-    }
-}
-
-fn diagnostic_to_rdjson<'a>(diagnostic: &'a Error) -> Option<RdJsonDiagnostic<'a>> {
-    let message = PrintDescription(diagnostic).to_string();
-    let location = diagnostic.location();
-    let location = to_rdjson_location(&location);
-
-    let suggestions = to_rdjson_suggetions(diagnostic);
-    let category = diagnostic.category()?;
-    let code = RdJsonCode {
-        url: category.link().map(String::from),
-        value: category.name(),
-    };
-
-    Some(RdJsonDiagnostic {
-        code,
-        location,
-        message,
-        suggestions,
-    })
-}
-
-fn to_rdjson_location(location: &Location<'_>) -> Option<RdJsonLocation> {
-    let (Some(span), Some(source_code), Some(resource)) =
-        (location.span, location.source_code, location.resource)
-    else {
-        return None;
-    };
-    let resource = resource.as_file()?;
-    let source = SourceFile::new(source_code);
-    let start = source.location(span.start()).ok()?;
-    let end = source.location(span.end()).ok()?;
-    Some(RdJsonLocation {
-        path: resource.to_string(),
-        range: Some(RdJsonRange {
-            start: RdJsonLineColumn {
-                column: start.column_number.get(),
-                line: start.line_number.get(),
-            },
-            end: RdJsonLineColumn {
-                column: end.column_number.get(),
-                line: end.line_number.get(),
-            },
-        }),
-    })
-}
-
-struct SuggestionsVisitor {
-    suggestions: Vec<RdJsonSuggestion>,
-    current_message: Option<String>,
-    last_diagnostic_length: usize,
-}
-
-impl Visit for SuggestionsVisitor {
-    fn record_log(&mut self, _category: LogCategory, text: &dyn Display) -> std::io::Result<()> {
-        let message = {
-            let mut message = MarkupBuf::default();
-            let mut fmt = Formatter::new(&mut message);
-            fmt.write_markup(markup!({ { text } }))?;
-            markup_to_string(&message).expect("Invalid markup")
-        };
-        let current_diagnostic_length = self.suggestions.len();
-
-        if self.last_diagnostic_length != current_diagnostic_length {
-            let last_suggestion = self
-                .suggestions
-                .last_mut()
-                .expect("No suggestions to append to");
-            last_suggestion.text = message;
-        } else if let Some(current_message) = self.current_message.as_mut() {
-            current_message.push_str(&message);
-        } else {
-            self.current_message = Some(message);
-        }
-
-        Ok(())
-    }
-
-    fn record_frame(&mut self, location: Location<'_>) -> std::io::Result<()> {
-        let range = if let (Some(span), Some(source_code)) = (location.span, location.source_code) {
-            let source = SourceFile::new(source_code);
-            let start = source.location(span.start()).expect("Invalid span");
-            let end = source.location(span.end()).expect("Invalid span");
-
-            RdJsonRange {
-                end: RdJsonLineColumn {
-                    line: end.line_number.get(),
-                    column: end.column_number.get(),
-                },
-                start: RdJsonLineColumn {
-                    line: start.line_number.get(),
-                    column: start.column_number.get(),
-                },
-            }
-        } else {
-            RdJsonRange::default()
-        };
-
-        self.last_diagnostic_length = self.suggestions.len();
-        self.suggestions.push(RdJsonSuggestion {
-            text: self.current_message.take().unwrap_or_default(),
-            range,
-        });
-
-        Ok(())
-    }
-}
-
-fn to_rdjson_suggetions(diagnostic: &Error) -> Vec<RdJsonSuggestion> {
-    let mut visitor = SuggestionsVisitor {
-        suggestions: vec![],
-        last_diagnostic_length: 0,
-        current_message: None,
-    };
-
-    diagnostic.advices(&mut visitor).unwrap();
-
-    visitor.suggestions
-}
-
-#[derive(Serialize)]
-pub struct RdJsonReport<'a> {
-    source: RdJsonSource,
-    diagnostics: Vec<RdJsonDiagnostic<'a>>,
-}
-
-#[derive(Serialize)]
-struct RdJsonSource {
-    name: &'static str,
-    url: &'static str,
-}
-
-#[derive(Serialize)]
-struct RdJsonDiagnostic<'a> {
-    code: RdJsonCode<'a>,
-    #[serde(skip_serializing_if = "Option::is_none")]
-    location: Option<RdJsonLocation>,
-    message: String,
-    #[serde(skip_serializing_if = "Vec::is_empty")]
-    suggestions: Vec<RdJsonSuggestion>,
-}
-
-#[derive(Serialize)]
-struct RdJsonCode<'a> {
-    #[serde(skip_serializing_if = "Option::is_none")]
-    url: Option<String>,
-    value: &'a str,
-}
-#[derive(Serialize)]
-struct RdJsonLocation {
-    path: String,
-    #[serde(skip_serializing_if = "Option::is_none")]
-    range: Option<RdJsonRange>,
-}
-
-#[derive(Default, Serialize)]
-struct RdJsonRange {
-    end: RdJsonLineColumn,
-    start: RdJsonLineColumn,
-}
-
-#[derive(Serialize)]
-pub struct RdJsonSuggestion {
-    range: RdJsonRange,
-    text: String,
-}
-
-#[derive(Default, Serialize)]
-pub struct RdJsonLineColumn {
-    column: usize,
-    line: usize,
-}
diff --git a/crates/biome_configuration/src/css.rs b/crates/biome_configuration/src/css.rs
index 0d5cabee9c..358e9d6f59 100644
--- a/crates/biome_configuration/src/css.rs
+++ b/crates/biome_configuration/src/css.rs
@@ -46,16 +46,14 @@ pub type CssTailwindDirectivesEnabled = Bool<false>;
 pub struct CssParserConfiguration {
     /// Allow comments to appear on incorrect lines in `.css` files
     #[bpaf(hide)]
-    #[serde(skip_serializing_if = "Option::is_none")]
     pub allow_wrong_line_comments: Option<CssAllowWrongLineCommentsEnabled>,
 
     /// Enables parsing of CSS Modules specific features.
-    #[serde(skip_serializing_if = "Option::is_none")]
-    #[bpaf(long("css-parse-css-modules"), argument("true|false"))]
+    #[bpaf(hide)]
     pub css_modules: Option<CssModulesEnabled>,
 
     /// Enables parsing of Tailwind CSS 4.0 directives and functions.
-    #[bpaf(long("css-parse-tailwind-directives"), argument("true|false"))]
+    #[bpaf(hide)]
     pub tailwind_directives: Option<CssTailwindDirectivesEnabled>,
 }
 
diff --git a/crates/biome_configuration/src/formatter.rs b/crates/biome_configuration/src/formatter.rs
index 93bf3fe724..64a7743be8 100644
--- a/crates/biome_configuration/src/formatter.rs
+++ b/crates/biome_configuration/src/formatter.rs
@@ -23,9 +23,9 @@ pub struct FormatterConfiguration {
     #[serde(skip_serializing_if = "Option::is_none")]
     pub enabled: Option<FormatterEnabled>,
 
-    /// Whether formatting should be allowed to proceed if a given file
+    /// Stores whether formatting should be allowed to proceed if a given file
     /// has syntax errors
-    #[bpaf(long("format-with-errors"), argument("true|false"))]
+    #[bpaf(hide)]
     #[serde(skip_serializing_if = "Option::is_none")]
     pub format_with_errors: Option<FormatWithErrorsEnabled>,
 
diff --git a/crates/biome_configuration/src/html.rs b/crates/biome_configuration/src/html.rs
index ed2d83e716..3a4494ca70 100644
--- a/crates/biome_configuration/src/html.rs
+++ b/crates/biome_configuration/src/html.rs
@@ -9,6 +9,8 @@ use biome_html_formatter::context::{
 use bpaf::Bpaf;
 use serde::{Deserialize, Serialize};
 
+pub type ExperimentalFullSupportEnabled = Bool<false>;
+
 /// Options applied to HTML files
 #[derive(
     Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize, Bpaf, Deserializable, Merge,
@@ -16,6 +18,11 @@ use serde::{Deserialize, Serialize};
 #[cfg_attr(feature = "schema", derive(schemars::JsonSchema))]
 #[serde(rename_all = "camelCase", default, deny_unknown_fields)]
 pub struct HtmlConfiguration {
+    /// Enables full support for HTML, Vue, Svelte and Astro files.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    #[bpaf(hide)]
+    pub experimental_full_support_enabled: Option<ExperimentalFullSupportEnabled>,
+
     /// HTML parsing options
     #[bpaf(hide, pure(Default::default()))]
     #[serde(skip_serializing_if = "Option::is_none")]
@@ -37,8 +44,8 @@ pub struct HtmlConfiguration {
 }
 
 pub type HtmlFormatterEnabled = Bool<false>; // Keep it disabled by default while experimental.
-pub type HtmlLinterEnabled = Bool<false>;
-pub type HtmlAssistEnabled = Bool<false>;
+pub type HtmlLinterEnabled = Bool<true>;
+pub type HtmlAssistEnabled = Bool<true>;
 pub type HtmlParseInterpolation = Bool<false>;
 
 /// Options that changes how the HTML parser behaves
diff --git a/crates/biome_configuration/src/json.rs b/crates/biome_configuration/src/json.rs
index b694a43c3d..dd7011be91 100644
--- a/crates/biome_configuration/src/json.rs
+++ b/crates/biome_configuration/src/json.rs
@@ -43,13 +43,13 @@ pub type JsonAllowTrailingCommasEnabled = Bool<false>;
 #[cfg_attr(feature = "schema", derive(schemars::JsonSchema))]
 #[serde(rename_all = "camelCase", default, deny_unknown_fields)]
 pub struct JsonParserConfiguration {
-    #[bpaf(long("json-parse-allow-comments"), argument("true|false"))]
+    #[bpaf(hide)]
     #[serde(skip_serializing_if = "Option::is_none")]
     /// Allow parsing comments in `.json` files
     pub allow_comments: Option<JsonAllowCommentsEnabled>,
 
+    #[bpaf(hide)]
     #[serde(skip_serializing_if = "Option::is_none")]
-    #[bpaf(long("json-parse-allow-trailing-commas"), argument("true|false"))]
     /// Allow parsing trailing commas in `.json` files
     pub allow_trailing_commas: Option<JsonAllowTrailingCommasEnabled>,
 }
diff --git a/crates/biome_diagnostics/src/display.rs b/crates/biome_diagnostics/src/display.rs
index 2114a0d024..c9949cfca2 100644
--- a/crates/biome_diagnostics/src/display.rs
+++ b/crates/biome_diagnostics/src/display.rs
@@ -688,15 +688,6 @@ fn is_terminal_program(name: &str) -> bool {
     }
 }
 
-/// Prints [MarkupBuf] to a [String]
-pub fn markup_to_string(markup: &MarkupBuf) -> Option<String> {
-    let mut buffer = Vec::new();
-    let mut write = fmt::Termcolor(termcolor::NoColor::new(&mut buffer));
-    let mut fmt = fmt::Formatter::new(&mut write);
-    fmt.write_markup(markup! { {markup} }).ok()?;
-    String::from_utf8(buffer).ok()
-}
-
 #[cfg(test)]
 mod tests {
     use std::io;
diff --git a/crates/biome_diagnostics/src/display_github.rs b/crates/biome_diagnostics/src/display_github.rs
index d4fc52611a..98dfcec8af 100644
--- a/crates/biome_diagnostics/src/display_github.rs
+++ b/crates/biome_diagnostics/src/display_github.rs
@@ -1,5 +1,4 @@
 use crate::display::frame::SourceFile;
-use crate::display::markup_to_string;
 use crate::{Diagnostic, Resource, Severity, diagnostic::internal::AsDiagnostic};
 use biome_console::{MarkupBuf, fmt, markup};
 use biome_text_size::{TextRange, TextSize};
@@ -120,3 +119,11 @@ fn escape_property<S: AsRef<str>>(value: S) -> String {
     }
     result
 }
+
+fn markup_to_string(markup: &MarkupBuf) -> Option<String> {
+    let mut buffer = Vec::new();
+    let mut write = fmt::Termcolor(termcolor::NoColor::new(&mut buffer));
+    let mut fmt = fmt::Formatter::new(&mut write);
+    fmt.write_markup(markup! { {markup} }).ok()?;
+    String::from_utf8(buffer).ok()
+}
diff --git a/crates/biome_formatter_test/src/spec.rs b/crates/biome_formatter_test/src/spec.rs
index 480c592ced..d918e4ff51 100644
--- a/crates/biome_formatter_test/src/spec.rs
+++ b/crates/biome_formatter_test/src/spec.rs
@@ -280,9 +280,13 @@ where
                 panic!("Configuration is invalid");
             }
 
-            let format_language = self
-                .language
-                .to_format_language(&settings, &DocumentFileSource::from_path(input_file));
+            let format_language = self.language.to_format_language(
+                &settings,
+                &DocumentFileSource::from_path(
+                    input_file,
+                    settings.experimental_full_html_support_enabled(),
+                ),
+            );
 
             let (mut output_code, printed) = self.formatted(&parsed, format_language.clone());
 
diff --git a/crates/biome_html_factory/src/generated/node_factory.rs b/crates/biome_html_factory/src/generated/node_factory.rs
index baf4a7c301..224504a5da 100644
--- a/crates/biome_html_factory/src/generated/node_factory.rs
+++ b/crates/biome_html_factory/src/generated/node_factory.rs
@@ -6,37 +6,40 @@ use biome_html_syntax::{
     HtmlSyntaxToken as SyntaxToken, *,
 };
 use biome_rowan::AstNode;
-pub fn astro_frontmatter_element(
-    l_fence_token: SyntaxToken,
-    r_fence_token: SyntaxToken,
-) -> AstroFrontmatterElementBuilder {
-    AstroFrontmatterElementBuilder {
-        l_fence_token,
-        r_fence_token,
+pub fn astro_embedded_content() -> AstroEmbeddedContentBuilder {
+    AstroEmbeddedContentBuilder {
         content_token: None,
     }
 }
-pub struct AstroFrontmatterElementBuilder {
-    l_fence_token: SyntaxToken,
-    r_fence_token: SyntaxToken,
+pub struct AstroEmbeddedContentBuilder {
     content_token: Option<SyntaxToken>,
 }
-impl AstroFrontmatterElementBuilder {
+impl AstroEmbeddedContentBuilder {
     pub fn with_content_token(mut self, content_token: SyntaxToken) -> Self {
         self.content_token = Some(content_token);
         self
     }
-    pub fn build(self) -> AstroFrontmatterElement {
-        AstroFrontmatterElement::unwrap_cast(SyntaxNode::new_detached(
-            HtmlSyntaxKind::ASTRO_FRONTMATTER_ELEMENT,
-            [
-                Some(SyntaxElement::Token(self.l_fence_token)),
-                self.content_token.map(|token| SyntaxElement::Token(token)),
-                Some(SyntaxElement::Token(self.r_fence_token)),
-            ],
+    pub fn build(self) -> AstroEmbeddedContent {
+        AstroEmbeddedContent::unwrap_cast(SyntaxNode::new_detached(
+            HtmlSyntaxKind::ASTRO_EMBEDDED_CONTENT,
+            [self.content_token.map(|token| SyntaxElement::Token(token))],
         ))
     }
 }
+pub fn astro_frontmatter_element(
+    l_fence_token: SyntaxToken,
+    content: AstroEmbeddedContent,
+    r_fence_token: SyntaxToken,
+) -> AstroFrontmatterElement {
+    AstroFrontmatterElement::unwrap_cast(SyntaxNode::new_detached(
+        HtmlSyntaxKind::ASTRO_FRONTMATTER_ELEMENT,
+        [
+            Some(SyntaxElement::Token(l_fence_token)),
+            Some(SyntaxElement::Node(content.into_syntax())),
+            Some(SyntaxElement::Token(r_fence_token)),
+        ],
+    ))
+}
 pub fn html_attribute(name: HtmlAttributeName) -> HtmlAttributeBuilder {
     HtmlAttributeBuilder {
         name,
diff --git a/crates/biome_html_factory/src/generated/syntax_factory.rs b/crates/biome_html_factory/src/generated/syntax_factory.rs
index ff6a33d039..ea8791c8ef 100644
--- a/crates/biome_html_factory/src/generated/syntax_factory.rs
+++ b/crates/biome_html_factory/src/generated/syntax_factory.rs
@@ -21,6 +21,25 @@ impl SyntaxFactory for HtmlSyntaxFactory {
             | HTML_BOGUS_TEXT_EXPRESSION => {
                 RawSyntaxNode::new(kind, children.into_iter().map(Some))
             }
+            ASTRO_EMBEDDED_CONTENT => {
+                let mut elements = (&children).into_iter();
+                let mut slots: RawNodeSlots<1usize> = RawNodeSlots::default();
+                let mut current_element = elements.next();
+                if let Some(element) = &current_element
+                    && element.kind() == HTML_LITERAL
+                {
+                    slots.mark_present();
+                    current_element = elements.next();
+                }
+                slots.next_slot();
+                if current_element.is_some() {
+                    return RawSyntaxNode::new(
+                        ASTRO_EMBEDDED_CONTENT.to_bogus(),
+                        children.into_iter().map(Some),
+                    );
+                }
+                slots.into_node(ASTRO_EMBEDDED_CONTENT, children)
+            }
             ASTRO_FRONTMATTER_ELEMENT => {
                 let mut elements = (&children).into_iter();
                 let mut slots: RawNodeSlots<3usize> = RawNodeSlots::default();
@@ -33,7 +52,7 @@ impl SyntaxFactory for HtmlSyntaxFactory {
                 }
                 slots.next_slot();
                 if let Some(element) = &current_element
-                    && element.kind() == HTML_LITERAL
+                    && AstroEmbeddedContent::can_cast(element.kind())
                 {
                     slots.mark_present();
                     current_element = elements.next();
diff --git a/crates/biome_html_formatter/src/astro/auxiliary/embedded_content.rs b/crates/biome_html_formatter/src/astro/auxiliary/embedded_content.rs
new file mode 100644
index 0000000000..b89a03a45a
--- /dev/null
+++ b/crates/biome_html_formatter/src/astro/auxiliary/embedded_content.rs
@@ -0,0 +1,22 @@
+use crate::prelude::*;
+use biome_deserialize::TextRange;
+use biome_html_syntax::AstroEmbeddedContent;
+use biome_rowan::AstNode;
+#[derive(Debug, Clone, Default)]
+pub(crate) struct FormatAstroEmbeddedContent;
+impl FormatNodeRule<AstroEmbeddedContent> for FormatAstroEmbeddedContent {
+    fn fmt_fields(&self, node: &AstroEmbeddedContent, f: &mut HtmlFormatter) -> FormatResult<()> {
+        format_html_verbatim_node(node.syntax()).fmt(f)
+    }
+
+    fn embedded_node_range(
+        &self,
+        node: &AstroEmbeddedContent,
+        f: &mut HtmlFormatter,
+    ) -> Option<TextRange> {
+        if !f.context().should_delegate_fmt_embedded_nodes() {
+            return None;
+        }
+        Some(node.range())
+    }
+}
diff --git a/crates/biome_html_formatter/src/astro/auxiliary/frontmatter_element.rs b/crates/biome_html_formatter/src/astro/auxiliary/frontmatter_element.rs
index 059ec17452..5aaf99aebe 100644
--- a/crates/biome_html_formatter/src/astro/auxiliary/frontmatter_element.rs
+++ b/crates/biome_html_formatter/src/astro/auxiliary/frontmatter_element.rs
@@ -12,16 +12,12 @@ impl FormatNodeRule<AstroFrontmatterElement> for FormatAstroFrontmatterElement {
     ) -> FormatResult<()> {
         let AstroFrontmatterElementFields {
             l_fence_token,
-            content_token,
+            content,
             r_fence_token,
         } = node.as_fields();
 
         write!(f, [l_fence_token.format(), hard_line_break()])?;
-
-        if let Some(content_token) = content_token {
-            write!(f, [content_token.format(), hard_line_break()])?;
-        }
-
+        write!(f, [content.format(), hard_line_break()])?;
         write!(f, [r_fence_token.format()])?;
 
         Ok(())
diff --git a/crates/biome_html_formatter/src/astro/auxiliary/mod.rs b/crates/biome_html_formatter/src/astro/auxiliary/mod.rs
index e51bcc0e90..8eb6037e95 100644
--- a/crates/biome_html_formatter/src/astro/auxiliary/mod.rs
+++ b/crates/biome_html_formatter/src/astro/auxiliary/mod.rs
@@ -1,3 +1,4 @@
 //! This is a generated file. Don't modify it by hand! Run 'cargo codegen formatter' to re-generate the file.
 
+pub(crate) mod embedded_content;
 pub(crate) mod frontmatter_element;
diff --git a/crates/biome_html_formatter/src/generated.rs b/crates/biome_html_formatter/src/generated.rs
index d157094a37..d2ffc6624e 100644
--- a/crates/biome_html_formatter/src/generated.rs
+++ b/crates/biome_html_formatter/src/generated.rs
@@ -6,6 +6,44 @@ use crate::{
     AsFormat, FormatBogusNodeRule, FormatNodeRule, HtmlFormatContext, HtmlFormatter, IntoFormat,
 };
 use biome_formatter::{FormatOwnedWithRule, FormatRefWithRule, FormatResult, FormatRule};
+impl FormatRule<biome_html_syntax::AstroEmbeddedContent>
+    for crate::astro::auxiliary::embedded_content::FormatAstroEmbeddedContent
+{
+    type Context = HtmlFormatContext;
+    #[inline(always)]
+    fn fmt(
+        &self,
+        node: &biome_html_syntax::AstroEmbeddedContent,
+        f: &mut HtmlFormatter,
+    ) -> FormatResult<()> {
+        FormatNodeRule::<biome_html_syntax::AstroEmbeddedContent>::fmt(self, node, f)
+    }
+}
+impl AsFormat<HtmlFormatContext> for biome_html_syntax::AstroEmbeddedContent {
+    type Format<'a> = FormatRefWithRule<
+        'a,
+        biome_html_syntax::AstroEmbeddedContent,
+        crate::astro::auxiliary::embedded_content::FormatAstroEmbeddedContent,
+    >;
+    fn format(&self) -> Self::Format<'_> {
+        FormatRefWithRule::new(
+            self,
+            crate::astro::auxiliary::embedded_content::FormatAstroEmbeddedContent::default(),
+        )
+    }
+}
+impl IntoFormat<HtmlFormatContext> for biome_html_syntax::AstroEmbeddedContent {
+    type Format = FormatOwnedWithRule<
+        biome_html_syntax::AstroEmbeddedContent,
+        crate::astro::auxiliary::embedded_content::FormatAstroEmbeddedContent,
+    >;
+    fn into_format(self) -> Self::Format {
+        FormatOwnedWithRule::new(
+            self,
+            crate::astro::auxiliary::embedded_content::FormatAstroEmbeddedContent::default(),
+        )
+    }
+}
 impl FormatRule<biome_html_syntax::AstroFrontmatterElement>
     for crate::astro::auxiliary::frontmatter_element::FormatAstroFrontmatterElement
 {
diff --git a/crates/biome_html_parser/src/syntax/astro.rs b/crates/biome_html_parser/src/syntax/astro.rs
index b6a5809a49..26673a0818 100644
--- a/crates/biome_html_parser/src/syntax/astro.rs
+++ b/crates/biome_html_parser/src/syntax/astro.rs
@@ -1,7 +1,9 @@
 use crate::parser::HtmlParser;
 use crate::syntax::parse_error::expected_closed_fence;
 use crate::token_source::HtmlLexContext;
-use biome_html_syntax::HtmlSyntaxKind::{ASTRO_FRONTMATTER_ELEMENT, FENCE, HTML_LITERAL};
+use biome_html_syntax::HtmlSyntaxKind::{
+    ASTRO_EMBEDDED_CONTENT, ASTRO_FRONTMATTER_ELEMENT, FENCE, HTML_LITERAL,
+};
 use biome_html_syntax::T;
 use biome_parser::Parser;
 use biome_parser::prelude::ParsedSyntax;
@@ -18,11 +20,19 @@ pub(crate) fn parse_astro_fence(p: &mut HtmlParser) -> ParsedSyntax {
         let c = m.complete(p, ASTRO_FRONTMATTER_ELEMENT);
         return ParsedSyntax::Present(c);
     }
-    if p.at(HTML_LITERAL) {
-        p.bump_with_context(HTML_LITERAL, HtmlLexContext::AstroFencedCodeBlock);
-    }
+    parse_astro_embedded(p).ok();
     p.expect(T![---]);
 
     let c = m.complete(p, ASTRO_FRONTMATTER_ELEMENT);
     ParsedSyntax::Present(c)
 }
+
+pub(crate) fn parse_astro_embedded(p: &mut HtmlParser) -> ParsedSyntax {
+    if !p.at(HTML_LITERAL) {
+        return Absent;
+    }
+    let m = p.start();
+    p.bump_with_context(HTML_LITERAL, HtmlLexContext::AstroFencedCodeBlock);
+
+    ParsedSyntax::Present(m.complete(p, ASTRO_EMBEDDED_CONTENT))
+}
diff --git a/crates/biome_html_syntax/src/element_ext.rs b/crates/biome_html_syntax/src/element_ext.rs
index 1252d40e0b..c3e08d5ef8 100644
--- a/crates/biome_html_syntax/src/element_ext.rs
+++ b/crates/biome_html_syntax/src/element_ext.rs
@@ -1,8 +1,8 @@
 use crate::{
-    AnyHtmlElement, HtmlAttribute, HtmlElement, HtmlSelfClosingElement, ScriptType,
-    inner_string_text,
+    AnyHtmlElement, AstroEmbeddedContent, HtmlAttribute, HtmlElement, HtmlEmbeddedContent,
+    HtmlSelfClosingElement, HtmlSyntaxToken, ScriptType, inner_string_text,
 };
-use biome_rowan::{AstNodeList, SyntaxResult, TokenText};
+use biome_rowan::{AstNodeList, SyntaxResult, TokenText, declare_node_union};
 
 /// https://html.spec.whatwg.org/#void-elements
 const VOID_ELEMENTS: &[&str] = &[
@@ -185,7 +185,7 @@ impl HtmlElement {
     }
 
     /// Returns `true` if the element is a `<script lang="ts">`
-    pub fn is_typescript_lang(&self) -> SyntaxResult<bool> {
+    pub fn is_typescript_lang(&self) -> bool {
         let is_script = self.is_script_tag();
         let lang_attribute = self.find_attribute_by_name("lang");
         let is_lang_typescript = lang_attribute.is_some_and(|attribute| {
@@ -199,7 +199,25 @@ impl HtmlElement {
                     text.eq_ignore_ascii_case("ts")
                 })
         });
-        Ok(is_script && is_lang_typescript)
+        is_script && is_lang_typescript
+    }
+
+    /// Returns `true` if the element is a `<style lang="sass">` or `<style lang="scss">`
+    pub fn is_sass_lang(&self) -> bool {
+        let is_style = self.is_style_tag();
+        let lang_attribute = self.find_attribute_by_name("lang");
+        let is_lang_typescript = lang_attribute.is_some_and(|attribute| {
+            attribute
+                .initializer()
+                .and_then(|initializer| initializer.value().ok())
+                .and_then(|value| value.as_html_string().cloned())
+                .and_then(|value| value.value_token().ok())
+                .is_some_and(|token| {
+                    let text = inner_string_text(&token);
+                    text.eq_ignore_ascii_case("sass") || text.eq_ignore_ascii_case("scss")
+                })
+        });
+        is_style && is_lang_typescript
     }
 }
 
@@ -268,3 +286,16 @@ mod tests {
         assert!(element.is_javascript_tag());
     }
 }
+
+declare_node_union! {
+    pub AnyEmbeddedContent = HtmlEmbeddedContent | AstroEmbeddedContent
+}
+
+impl AnyEmbeddedContent {
+    pub fn value_token(&self) -> Option<HtmlSyntaxToken> {
+        match self {
+            Self::HtmlEmbeddedContent(node) => node.value_token().ok(),
+            Self::AstroEmbeddedContent(node) => node.content_token(),
+        }
+    }
+}
diff --git a/crates/biome_html_syntax/src/file_source.rs b/crates/biome_html_syntax/src/file_source.rs
index 50662160bf..2328c417f8 100644
--- a/crates/biome_html_syntax/src/file_source.rs
+++ b/crates/biome_html_syntax/src/file_source.rs
@@ -133,7 +133,7 @@ impl HtmlFileSource {
         match language_id {
             "html" => Ok(Self::html()),
             "astro" => Ok(Self::astro()),
-            "vue" => Ok(Self::vue()),
+            "vuejs" | "vue" => Ok(Self::vue()),
             "svelte" => Ok(Self::svelte()),
             _ => Err(FileSourceError::UnknownLanguageId),
         }
diff --git a/crates/biome_html_syntax/src/generated/kind.rs b/crates/biome_html_syntax/src/generated/kind.rs
index 61a5270415..da52952ad0 100644
--- a/crates/biome_html_syntax/src/generated/kind.rs
+++ b/crates/biome_html_syntax/src/generated/kind.rs
@@ -42,6 +42,7 @@ pub enum HtmlSyntaxKind {
     HTML_SELF_CLOSING_TAG,
     HTML_ELEMENT,
     ASTRO_FRONTMATTER_ELEMENT,
+    ASTRO_EMBEDDED_CONTENT,
     HTML_OPENING_ELEMENT,
     HTML_CLOSING_ELEMENT,
     HTML_SELF_CLOSING_ELEMENT,
diff --git a/crates/biome_html_syntax/src/generated/macros.rs b/crates/biome_html_syntax/src/generated/macros.rs
index 71179950f5..5aec3e8bff 100644
--- a/crates/biome_html_syntax/src/generated/macros.rs
+++ b/crates/biome_html_syntax/src/generated/macros.rs
@@ -16,6 +16,10 @@ macro_rules! map_syntax_node {
     ($ node : expr , $ pattern : pat => $ body : expr) => {
         match $node {
             node => match $crate::HtmlSyntaxNode::kind(&node) {
+                $crate::HtmlSyntaxKind::ASTRO_EMBEDDED_CONTENT => {
+                    let $pattern = unsafe { $crate::AstroEmbeddedContent::new_unchecked(node) };
+                    $body
+                }
                 $crate::HtmlSyntaxKind::ASTRO_FRONTMATTER_ELEMENT => {
                     let $pattern = unsafe { $crate::AstroFrontmatterElement::new_unchecked(node) };
                     $body
diff --git a/crates/biome_html_syntax/src/generated/nodes.rs b/crates/biome_html_syntax/src/generated/nodes.rs
index 47922befd7..b6cbdab849 100644
--- a/crates/biome_html_syntax/src/generated/nodes.rs
+++ b/crates/biome_html_syntax/src/generated/nodes.rs
@@ -20,6 +20,41 @@ use std::fmt::{Debug, Formatter};
 #[doc = r" the slots are not statically known."]
 pub(crate) const SLOT_MAP_EMPTY_VALUE: u8 = u8::MAX;
 #[derive(Clone, PartialEq, Eq, Hash)]
+pub struct AstroEmbeddedContent {
+    pub(crate) syntax: SyntaxNode,
+}
+impl AstroEmbeddedContent {
+    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
+    #[doc = r""]
+    #[doc = r" # Safety"]
+    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
+    #[doc = r" or a match on [SyntaxNode::kind]"]
+    #[inline]
+    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
+        Self { syntax }
+    }
+    pub fn as_fields(&self) -> AstroEmbeddedContentFields {
+        AstroEmbeddedContentFields {
+            content_token: self.content_token(),
+        }
+    }
+    pub fn content_token(&self) -> Option<SyntaxToken> {
+        support::token(&self.syntax, 0usize)
+    }
+}
+impl Serialize for AstroEmbeddedContent {
+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
+    where
+        S: Serializer,
+    {
+        self.as_fields().serialize(serializer)
+    }
+}
+#[derive(Serialize)]
+pub struct AstroEmbeddedContentFields {
+    pub content_token: Option<SyntaxToken>,
+}
+#[derive(Clone, PartialEq, Eq, Hash)]
 pub struct AstroFrontmatterElement {
     pub(crate) syntax: SyntaxNode,
 }
@@ -36,15 +71,15 @@ impl AstroFrontmatterElement {
     pub fn as_fields(&self) -> AstroFrontmatterElementFields {
         AstroFrontmatterElementFields {
             l_fence_token: self.l_fence_token(),
-            content_token: self.content_token(),
+            content: self.content(),
             r_fence_token: self.r_fence_token(),
         }
     }
     pub fn l_fence_token(&self) -> SyntaxResult<SyntaxToken> {
         support::required_token(&self.syntax, 0usize)
     }
-    pub fn content_token(&self) -> Option<SyntaxToken> {
-        support::token(&self.syntax, 1usize)
+    pub fn content(&self) -> SyntaxResult<AstroEmbeddedContent> {
+        support::required_node(&self.syntax, 1usize)
     }
     pub fn r_fence_token(&self) -> SyntaxResult<SyntaxToken> {
         support::required_token(&self.syntax, 2usize)
@@ -61,7 +96,7 @@ impl Serialize for AstroFrontmatterElement {
 #[derive(Serialize)]
 pub struct AstroFrontmatterElementFields {
     pub l_fence_token: SyntaxResult<SyntaxToken>,
-    pub content_token: Option<SyntaxToken>,
+    pub content: SyntaxResult<AstroEmbeddedContent>,
     pub r_fence_token: SyntaxResult<SyntaxToken>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
@@ -970,6 +1005,56 @@ impl AnyHtmlTextExpression {
         }
     }
 }
+impl AstNode for AstroEmbeddedContent {
+    type Language = Language;
+    const KIND_SET: SyntaxKindSet<Language> =
+        SyntaxKindSet::from_raw(RawSyntaxKind(ASTRO_EMBEDDED_CONTENT as u16));
+    fn can_cast(kind: SyntaxKind) -> bool {
+        kind == ASTRO_EMBEDDED_CONTENT
+    }
+    fn cast(syntax: SyntaxNode) -> Option<Self> {
+        if Self::can_cast(syntax.kind()) {
+            Some(Self { syntax })
+        } else {
+            None
+        }
+    }
+    fn syntax(&self) -> &SyntaxNode {
+        &self.syntax
+    }
+    fn into_syntax(self) -> SyntaxNode {
+        self.syntax
+    }
+}
+impl std::fmt::Debug for AstroEmbeddedContent {
+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+        thread_local! { static DEPTH : std :: cell :: Cell < u8 > = const { std :: cell :: Cell :: new (0) } };
+        let current_depth = DEPTH.get();
+        let result = if current_depth < 16 {
+            DEPTH.set(current_depth + 1);
+            f.debug_struct("AstroEmbeddedContent")
+                .field(
+                    "content_token",
+                    &support::DebugOptionalElement(self.content_token()),
+                )
+                .finish()
+        } else {
+            f.debug_struct("AstroEmbeddedContent").finish()
+        };
+        DEPTH.set(current_depth);
+        result
+    }
+}
+impl From<AstroEmbeddedContent> for SyntaxNode {
+    fn from(n: AstroEmbeddedContent) -> Self {
+        n.syntax
+    }
+}
+impl From<AstroEmbeddedContent> for SyntaxElement {
+    fn from(n: AstroEmbeddedContent) -> Self {
+        n.syntax.into()
+    }
+}
 impl AstNode for AstroFrontmatterElement {
     type Language = Language;
     const KIND_SET: SyntaxKindSet<Language> =
@@ -1002,10 +1087,7 @@ impl std::fmt::Debug for AstroFrontmatterElement {
                     "l_fence_token",
                     &support::DebugSyntaxResult(self.l_fence_token()),
                 )
-                .field(
-                    "content_token",
-                    &support::DebugOptionalElement(self.content_token()),
-                )
+                .field("content", &support::DebugSyntaxResult(self.content()))
                 .field(
                     "r_fence_token",
                     &support::DebugSyntaxResult(self.r_fence_token()),
@@ -2446,6 +2528,11 @@ impl std::fmt::Display for AnyHtmlTextExpression {
         std::fmt::Display::fmt(self.syntax(), f)
     }
 }
+impl std::fmt::Display for AstroEmbeddedContent {
+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+        std::fmt::Display::fmt(self.syntax(), f)
+    }
+}
 impl std::fmt::Display for AstroFrontmatterElement {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         std::fmt::Display::fmt(self.syntax(), f)
diff --git a/crates/biome_html_syntax/src/generated/nodes_mut.rs b/crates/biome_html_syntax/src/generated/nodes_mut.rs
index b20bd803d6..35e79229c0 100644
--- a/crates/biome_html_syntax/src/generated/nodes_mut.rs
+++ b/crates/biome_html_syntax/src/generated/nodes_mut.rs
@@ -3,6 +3,14 @@
 use crate::{HtmlSyntaxToken as SyntaxToken, generated::nodes::*};
 use biome_rowan::AstNode;
 use std::iter::once;
+impl AstroEmbeddedContent {
+    pub fn with_content_token(self, element: Option<SyntaxToken>) -> Self {
+        Self::unwrap_cast(
+            self.syntax
+                .splice_slots(0usize..=0usize, once(element.map(|element| element.into()))),
+        )
+    }
+}
 impl AstroFrontmatterElement {
     pub fn with_l_fence_token(self, element: SyntaxToken) -> Self {
         Self::unwrap_cast(
@@ -10,10 +18,10 @@ impl AstroFrontmatterElement {
                 .splice_slots(0usize..=0usize, once(Some(element.into()))),
         )
     }
-    pub fn with_content_token(self, element: Option<SyntaxToken>) -> Self {
+    pub fn with_content(self, element: AstroEmbeddedContent) -> Self {
         Self::unwrap_cast(
             self.syntax
-                .splice_slots(1usize..=1usize, once(element.map(|element| element.into()))),
+                .splice_slots(1usize..=1usize, once(Some(element.into_syntax().into()))),
         )
     }
     pub fn with_r_fence_token(self, element: SyntaxToken) -> Self {
diff --git a/crates/biome_js_syntax/src/file_source.rs b/crates/biome_js_syntax/src/file_source.rs
index d07a264dfc..7bb3ca96d5 100644
--- a/crates/biome_js_syntax/src/file_source.rs
+++ b/crates/biome_js_syntax/src/file_source.rs
@@ -148,7 +148,8 @@ pub struct JsFileSource {
     variant: LanguageVariant,
     module_kind: ModuleKind,
     version: LanguageVersion,
-    /// Used to mark if the source is being used for an Astro, Svelte or Vue file
+    /// Used to mark if the JavaScript is embedded inside some particular files. This affects the parsing.
+    /// For example, if inside an Astro file, a top-level return statement is allowed.
     embedding_kind: EmbeddingKind,
 }
 
@@ -199,7 +200,6 @@ impl JsFileSource {
         }
     }
 
-    /// Astro file definition
     pub fn astro() -> Self {
         Self::ts().with_embedding_kind(EmbeddingKind::Astro)
     }
@@ -343,6 +343,7 @@ impl JsFileSource {
             "vue" => Ok(Self::vue()),
             // TODO: Remove once we have full support of svelte files
             "svelte" => Ok(Self::svelte()),
+
             _ => Err(FileSourceError::UnknownExtension),
         }
     }
@@ -372,7 +373,7 @@ impl JsFileSource {
             // TODO: Remove once we have full support of astro files
             "astro" => Ok(Self::astro()),
             // TODO: Remove once we have full support of vue files
-            "vue" => Ok(Self::vue()),
+            "vue" | "vuejs" => Ok(Self::vue()),
             // TODO: Remove once we have full support of svelte files
             "svelte" => Ok(Self::svelte()),
             _ => Err(FileSourceError::UnknownLanguageId),
diff --git a/crates/biome_lsp/src/handlers/analysis.rs b/crates/biome_lsp/src/handlers/analysis.rs
index b36b0d03a3..6fb7620df4 100644
--- a/crates/biome_lsp/src/handlers/analysis.rs
+++ b/crates/biome_lsp/src/handlers/analysis.rs
@@ -14,7 +14,9 @@ use biome_line_index::LineIndex;
 use biome_lsp_converters::from_proto;
 use biome_rowan::{TextRange, TextSize};
 use biome_service::WorkspaceError;
-use biome_service::file_handlers::{AstroFileHandler, SvelteFileHandler, VueFileHandler};
+use biome_service::file_handlers::astro::AstroFileHandler;
+use biome_service::file_handlers::svelte::SvelteFileHandler;
+use biome_service::file_handlers::vue::VueFileHandler;
 use biome_service::workspace::{
     CheckFileSizeParams, FeaturesBuilder, FileFeaturesResult, FixFileMode, FixFileParams,
     GetFileContentParams, IgnoreKind, PathIsIgnoredParams, PullActionsParams,
@@ -124,6 +126,7 @@ pub(crate) fn code_actions(
         Some("svelte") => SvelteFileHandler::start(content.as_str()),
         _ => None,
     };
+
     let cursor_range = from_proto::text_range(&doc.line_index, params.range, position_encoding)
         .with_context(|| {
             format!(
@@ -145,7 +148,6 @@ pub(crate) fn code_actions(
     } else {
         cursor_range
     };
-
     debug!("Cursor range {:?}", &cursor_range);
     let result = match session.workspace.pull_actions(PullActionsParams {
         project_key: doc.project_key,
@@ -181,7 +183,7 @@ pub(crate) fn code_actions(
     // document if the action category "source.fixAll" was explicitly requested
     // by the language client
     let fix_all = if has_fix_all {
-        fix_all(session, &url, path, &doc.line_index, &diagnostics, offset)?
+        fix_all(session, &url, path, &doc.line_index, &diagnostics, None)?
     } else {
         None
     };
@@ -241,7 +243,6 @@ pub(crate) fn code_actions(
                 position_encoding,
                 &diagnostics,
                 action,
-                offset,
             )
             .ok()?;
 
@@ -354,24 +355,26 @@ fn fix_all(
         suppression_reason: None,
         rule_categories: categories.build(),
     })?;
-
-    let output = match path.as_path().extension() {
-        Some(extension) => {
-            let input = session.workspace.get_file_content(GetFileContentParams {
-                project_key: doc.project_key,
-                path: path.clone(),
-            })?;
-            match extension {
-                "astro" => AstroFileHandler::output(input.as_str(), fixed.code.as_str()),
-                "vue" => VueFileHandler::output(input.as_str(), fixed.code.as_str()),
-                "svelte" => SvelteFileHandler::output(input.as_str(), fixed.code.as_str()),
-                _ => fixed.code,
+    let output = if file_features.supports_full_html_support() {
+        fixed.code
+    } else {
+        match path.as_path().extension() {
+            Some(extension) => {
+                let input = session.workspace.get_file_content(GetFileContentParams {
+                    project_key: doc.project_key,
+                    path: path.clone(),
+                })?;
+                match extension {
+                    "astro" => AstroFileHandler::output(input.as_str(), fixed.code.as_str()),
+                    "vue" => VueFileHandler::output(input.as_str(), fixed.code.as_str()),
+                    "svelte" => SvelteFileHandler::output(input.as_str(), fixed.code.as_str()),
+                    _ => fixed.code,
+                }
             }
-        }
 
-        _ => fixed.code,
+            _ => fixed.code,
+        }
     };
-
     if fixed.actions.is_empty() {
         return Ok(None);
     }
diff --git a/crates/biome_lsp/src/handlers/formatting.rs b/crates/biome_lsp/src/handlers/formatting.rs
index 29cb47a5ec..c039ab4da2 100644
--- a/crates/biome_lsp/src/handlers/formatting.rs
+++ b/crates/biome_lsp/src/handlers/formatting.rs
@@ -5,7 +5,9 @@ use anyhow::Context;
 use biome_fs::BiomePath;
 use biome_lsp_converters::from_proto;
 use biome_rowan::{TextLen, TextRange, TextSize};
-use biome_service::file_handlers::{AstroFileHandler, SvelteFileHandler, VueFileHandler};
+use biome_service::file_handlers::astro::AstroFileHandler;
+use biome_service::file_handlers::svelte::SvelteFileHandler;
+use biome_service::file_handlers::vue::VueFileHandler;
 use biome_service::workspace::{
     CheckFileSizeParams, FeaturesBuilder, FeaturesSupported, FileFeaturesResult, FormatFileParams,
     FormatOnTypeParams, FormatRangeParams, GetFileContentParams, IgnoreKind, PathIsIgnoredParams,
@@ -76,17 +78,19 @@ pub(crate) fn format(
         if output.is_empty() {
             return Ok(None);
         }
-        match path.extension() {
-            Some("astro") => {
-                output = AstroFileHandler::output(input.as_str(), output.as_str());
+        if !file_features.supports_full_html_support() {
+            match path.extension() {
+                Some("astro") => {
+                    output = AstroFileHandler::output(input.as_str(), output.as_str());
+                }
+                Some("vue") => {
+                    output = VueFileHandler::output(input.as_str(), output.as_str());
+                }
+                Some("svelte") => {
+                    output = SvelteFileHandler::output(input.as_str(), output.as_str());
+                }
+                _ => {}
             }
-            Some("vue") => {
-                output = VueFileHandler::output(input.as_str(), output.as_str());
-            }
-            Some("svelte") => {
-                output = SvelteFileHandler::output(input.as_str(), output.as_str());
-            }
-            _ => {}
         }
 
         let indels = biome_text_edit::TextEdit::from_unicode_words(input.as_str(), output.as_str());
@@ -161,6 +165,7 @@ pub(crate) fn format_range(
             project_key: doc.project_key,
             path: path.clone(),
         })?;
+
         let offset = match path.extension() {
             Some("vue") => VueFileHandler::start(content.as_str()),
             Some("astro") => AstroFileHandler::start(content.as_str()),
diff --git a/crates/biome_lsp/src/server.tests.rs b/crates/biome_lsp/src/server.tests.rs
index f68b83e857..5c711f7ce3 100644
--- a/crates/biome_lsp/src/server.tests.rs
+++ b/crates/biome_lsp/src/server.tests.rs
@@ -4040,7 +4040,8 @@ let useConst = "Astro Test";
                 r#"---
 const useConst = "Astro Test";
 ---
-<!doctype html>"#,
+<!doctype html>
+"#,
             ),
         }],
     );
diff --git a/crates/biome_lsp/src/session.rs b/crates/biome_lsp/src/session.rs
index 26ffd208b6..82cd9c9c4b 100644
--- a/crates/biome_lsp/src/session.rs
+++ b/crates/biome_lsp/src/session.rs
@@ -16,11 +16,10 @@ use biome_service::WorkspaceError;
 use biome_service::configuration::{
     LoadedConfiguration, ProjectScanComputer, load_configuration, load_editorconfig,
 };
-use biome_service::file_handlers::{AstroFileHandler, SvelteFileHandler, VueFileHandler};
 use biome_service::projects::ProjectKey;
 use biome_service::workspace::{
-    FeaturesBuilder, GetFileContentParams, OpenProjectParams, OpenProjectResult,
-    PullDiagnosticsParams, SupportsFeatureParams,
+    FeaturesBuilder, OpenProjectParams, OpenProjectResult, PullDiagnosticsParams,
+    SupportsFeatureParams,
 };
 use biome_service::workspace::{FileFeaturesResult, ServiceNotification};
 use biome_service::workspace::{RageEntry, RageParams, RageResult, UpdateSettingsParams};
@@ -447,17 +446,6 @@ impl Session {
                 pull_code_actions: false,
             })?;
 
-            let content = self.workspace.get_file_content(GetFileContentParams {
-                project_key: doc.project_key,
-                path: biome_path.clone(),
-            })?;
-            let offset = match biome_path.extension() {
-                Some("vue") => VueFileHandler::start(content.as_str()),
-                Some("astro") => AstroFileHandler::start(content.as_str()),
-                Some("svelte") => SvelteFileHandler::start(content.as_str()),
-                _ => None,
-            };
-
             result
                 .diagnostics
                 .into_iter()
@@ -467,7 +455,7 @@ impl Session {
                         &url,
                         &doc.line_index,
                         self.position_encoding(),
-                        offset,
+                        None,
                     ) {
                         Ok(diag) => Some(diag),
                         Err(err) => {
diff --git a/crates/biome_lsp/src/utils.rs b/crates/biome_lsp/src/utils.rs
index 051ce45571..57b442bc09 100644
--- a/crates/biome_lsp/src/utils.rs
+++ b/crates/biome_lsp/src/utils.rs
@@ -100,7 +100,6 @@ pub(crate) fn code_fix_to_lsp(
     position_encoding: PositionEncoding,
     diagnostics: &[lsp::Diagnostic],
     action: CodeAction,
-    offset: Option<u32>,
 ) -> Result<lsp::CodeAction> {
     // Mark diagnostics emitted by the same rule as resolved by this action
     let diagnostics: Vec<_> = action
@@ -135,6 +134,7 @@ pub(crate) fn code_fix_to_lsp(
     let suggestion = action.suggestion;
 
     let mut changes = HashMap::new();
+    let offset = action.offset.map(u32::from);
     let edits = text_edit(line_index, suggestion.suggestion, position_encoding, offset)?;
 
     changes.insert(url.clone(), edits);
diff --git a/crates/biome_ruledoc_utils/src/codeblock.rs b/crates/biome_ruledoc_utils/src/codeblock.rs
index a3f8ed504c..f6746fcc37 100644
--- a/crates/biome_ruledoc_utils/src/codeblock.rs
+++ b/crates/biome_ruledoc_utils/src/codeblock.rs
@@ -94,7 +94,7 @@ impl CodeBlock {
     }
 
     pub fn document_file_source(&self) -> DocumentFileSource {
-        DocumentFileSource::from_extension(&self.tag)
+        DocumentFileSource::from_extension(&self.tag, false)
     }
 
     /// Returns the block's file path, but only if one was set explicitly using
@@ -138,7 +138,8 @@ impl FromStr for CodeBlock {
 
                         code_block.file_path = Some(normalize_file_path(path));
                     } else {
-                        if DocumentFileSource::from_extension(token) == DocumentFileSource::Unknown
+                        if DocumentFileSource::from_extension(token, false)
+                            == DocumentFileSource::Unknown
                         {
                             bail!("Unrecognised attribute in code block: {token}");
                         }
diff --git a/crates/biome_service/src/diagnostics.rs b/crates/biome_service/src/diagnostics.rs
index a4a97db6df..a0816195ff 100644
--- a/crates/biome_service/src/diagnostics.rs
+++ b/crates/biome_service/src/diagnostics.rs
@@ -513,7 +513,7 @@ impl Diagnostic for QueryDiagnostic {
 }
 
 pub fn extension_error(path: &BiomePath) -> WorkspaceError {
-    let file_source = DocumentFileSource::from_path(path);
+    let file_source = DocumentFileSource::from_path(path, false);
     WorkspaceError::source_file_not_supported(
         file_source,
         path.clone().to_string(),
diff --git a/crates/biome_service/src/file_handlers/css.rs b/crates/biome_service/src/file_handlers/css.rs
index 8845c5040e..1b3a3c0350 100644
--- a/crates/biome_service/src/file_handlers/css.rs
+++ b/crates/biome_service/src/file_handlers/css.rs
@@ -601,6 +601,7 @@ pub(crate) fn code_actions(params: CodeActionsParams) -> PullActionsResult {
         suppression_reason,
         plugins,
         categories,
+        action_offset,
     } = params;
     let _ = debug_span!("Code actions CSS", range =? range, path =? path).entered();
     let tree = parse.tree();
@@ -640,6 +641,7 @@ pub(crate) fn code_actions(params: CodeActionsParams) -> PullActionsResult {
                 rule_name: item
                     .rule_name
                     .map(|(group, name)| (Cow::Borrowed(group), Cow::Borrowed(name))),
+                offset: action_offset,
                 suggestion: item.suggestion,
             }
         }));
diff --git a/crates/biome_service/src/file_handlers/graphql.rs b/crates/biome_service/src/file_handlers/graphql.rs
index 1ddb5f04de..33213f7a79 100644
--- a/crates/biome_service/src/file_handlers/graphql.rs
+++ b/crates/biome_service/src/file_handlers/graphql.rs
@@ -482,6 +482,7 @@ pub(crate) fn code_actions(params: CodeActionsParams) -> PullActionsResult {
         enabled_rules: rules,
         plugins: _,
         categories,
+        action_offset,
     } = params;
     let _ = debug_span!("Code actions GraphQL", range =? range, path =? path).entered();
     let tree = parse.tree();
@@ -525,6 +526,7 @@ pub(crate) fn code_actions(params: CodeActionsParams) -> PullActionsResult {
                     .rule_name
                     .map(|(group, name)| (Cow::Borrowed(group), Cow::Borrowed(name))),
                 suggestion: item.suggestion,
+                offset: action_offset,
             }
         }));
 
diff --git a/crates/biome_service/src/file_handlers/html.rs b/crates/biome_service/src/file_handlers/html.rs
index 650227b068..700037ff89 100644
--- a/crates/biome_service/src/file_handlers/html.rs
+++ b/crates/biome_service/src/file_handlers/html.rs
@@ -36,9 +36,12 @@ use biome_html_formatter::{
     format_node,
 };
 use biome_html_parser::{HtmlParseOptions, parse_html_with_cache};
-use biome_html_syntax::{HtmlElement, HtmlEmbeddedContent, HtmlLanguage, HtmlRoot, HtmlSyntaxNode};
+use biome_html_syntax::element_ext::AnyEmbeddedContent;
+use biome_html_syntax::{
+    AstroEmbeddedContent, HtmlElement, HtmlLanguage, HtmlRoot, HtmlSyntaxNode,
+};
 use biome_js_parser::parse_js_with_offset_and_cache;
-use biome_js_syntax::{JsFileSource, JsLanguage};
+use biome_js_syntax::{EmbeddingKind, JsFileSource, JsLanguage};
 use biome_json_parser::parse_json_with_offset_and_cache;
 use biome_json_syntax::{JsonFileSource, JsonLanguage};
 use biome_parser::AnyParse;
@@ -391,7 +394,19 @@ fn parse_embedded_nodes(
 
     // Walk through all HTML elements looking for script tags and style tags
     for element in html_root.syntax().descendants() {
-        let Some(element) = HtmlElement::cast(element) else {
+        if let Some(astro_embedded_content) = AstroEmbeddedContent::cast_ref(&element) {
+            let result = parse_astro_embedded_script(
+                astro_embedded_content.clone(),
+                cache,
+                biome_path,
+                settings,
+            );
+            if let Some((content, file_source)) = result {
+                nodes.push((content.into(), file_source));
+            }
+        }
+
+        let Some(element) = HtmlElement::cast_ref(&element) else {
             continue;
         };
 
@@ -423,6 +438,35 @@ fn parse_embedded_nodes(
     ParseEmbedResult { nodes }
 }
 
+pub(crate) fn parse_astro_embedded_script(
+    element: AstroEmbeddedContent,
+    cache: &mut NodeCache,
+    path: &BiomePath,
+    settings: &Settings,
+) -> Option<(EmbeddedSnippet<JsLanguage>, DocumentFileSource)> {
+    let content = element.content_token()?;
+    let file_source = JsFileSource::ts().with_embedding_kind(EmbeddingKind::Astro);
+    let document_file_source = DocumentFileSource::Js(file_source);
+    let options = settings.parse_options::<JsLanguage>(path, &document_file_source);
+    let parse = parse_js_with_offset_and_cache(
+        content.text(),
+        content.text_range().start(),
+        file_source,
+        options,
+        cache,
+    );
+
+    Some((
+        EmbeddedSnippet::new(
+            parse.into(),
+            element.range(),
+            content.text_trimmed_range(),
+            content.text_range().start(),
+        ),
+        document_file_source,
+    ))
+}
+
 pub(crate) fn parse_embedded_script(
     element: HtmlElement,
     cache: &mut NodeCache,
@@ -433,13 +477,17 @@ pub(crate) fn parse_embedded_script(
     let html_file_source = html_file_source.to_html_file_source()?;
     if element.is_javascript_tag() {
         let file_source = if html_file_source.is_svelte() || html_file_source.is_vue() {
-            if element.is_typescript_lang().unwrap_or_default() {
+            let mut file_source = if element.is_typescript_lang() {
                 JsFileSource::ts()
             } else {
                 JsFileSource::js_module()
+            };
+            if html_file_source.is_svelte() {
+                file_source = file_source.with_embedding_kind(EmbeddingKind::Svelte);
+            } else if html_file_source.is_vue() {
+                file_source = file_source.with_embedding_kind(EmbeddingKind::Vue);
             }
-        } else if html_file_source.is_astro() {
-            JsFileSource::ts()
+            file_source
         } else {
             let is_module = element.is_javascript_module().unwrap_or_default();
             if is_module {
@@ -482,6 +530,7 @@ pub(crate) fn parse_embedded_script(
     }
 }
 
+/// Parses embedded style, but it skips it if it contains SASS language
 pub(crate) fn parse_embedded_style(
     element: HtmlElement,
     cache: &mut NodeCache,
@@ -494,6 +543,11 @@ pub(crate) fn parse_embedded_style(
             return None;
         }
 
+        // We don't support SASS
+        if element.is_sass_lang() {
+            return None;
+        }
+
         let file_source = DocumentFileSource::Css(CssFileSource::css());
         let content = element.children().iter().next().and_then(|child| {
             let child = child.as_any_html_content()?;
@@ -720,6 +774,7 @@ pub(crate) fn code_actions(params: CodeActionsParams) -> PullActionsResult {
         enabled_rules: rules,
         plugins: _,
         categories,
+        action_offset,
     } = params;
     let _ = debug_span!("Code actions HTML", range =? range, path =? path).entered();
     let tree = parse.tree();
@@ -757,6 +812,7 @@ pub(crate) fn code_actions(params: CodeActionsParams) -> PullActionsResult {
                     .rule_name
                     .map(|(group, name)| (Cow::Borrowed(group), Cow::Borrowed(name))),
                 suggestion: item.suggestion,
+                offset: action_offset,
             }
         }));
 
@@ -879,7 +935,7 @@ pub(crate) fn fix_all(params: FixAllParams) -> Result<FixFileResult, WorkspaceEr
                             &params.document_file_source,
                         ),
                         tree.syntax(),
-                        true,
+                        false,
                     )?
                     .print()?
                     .into_code()
@@ -907,7 +963,7 @@ pub(crate) fn update_snippets(
     let iterator = tree
         .syntax()
         .descendants()
-        .filter_map(HtmlEmbeddedContent::cast);
+        .filter_map(AnyEmbeddedContent::cast);
 
     for element in iterator {
         let Some(snippet) = new_snippets
@@ -917,7 +973,7 @@ pub(crate) fn update_snippets(
             continue;
         };
 
-        if let Ok(value_token) = element.value_token() {
+        if let Some(value_token) = element.value_token() {
             let new_token = ident(snippet.new_code.as_str());
             mutation.replace_token(value_token, new_token);
         }
diff --git a/crates/biome_service/src/file_handlers/javascript.rs b/crates/biome_service/src/file_handlers/javascript.rs
index 324e8659dc..915d5f1971 100644
--- a/crates/biome_service/src/file_handlers/javascript.rs
+++ b/crates/biome_service/src/file_handlers/javascript.rs
@@ -793,6 +793,7 @@ pub(crate) fn code_actions(params: CodeActionsParams) -> PullActionsResult {
         enabled_rules: rules,
         plugins,
         categories,
+        action_offset,
     } = params;
     let _ = debug_span!("Code actions JavaScript", range =? range, path =? path).entered();
     let tree = parse.tree();
@@ -840,6 +841,7 @@ pub(crate) fn code_actions(params: CodeActionsParams) -> PullActionsResult {
                         .rule_name
                         .map(|(group, name)| (Cow::Borrowed(group), Cow::Borrowed(name))),
                     suggestion: item.suggestion,
+                    offset: action_offset,
                 }
             }));
 
diff --git a/crates/biome_service/src/file_handlers/json.rs b/crates/biome_service/src/file_handlers/json.rs
index a2eab315aa..f35f97ed77 100644
--- a/crates/biome_service/src/file_handlers/json.rs
+++ b/crates/biome_service/src/file_handlers/json.rs
@@ -573,6 +573,7 @@ fn code_actions(params: CodeActionsParams) -> PullActionsResult {
         suppression_reason,
         plugins: _,
         categories,
+        action_offset,
     } = params;
 
     let _ = debug_span!("Code actions JSON",  range =? range, path =? path).entered();
@@ -612,6 +613,7 @@ fn code_actions(params: CodeActionsParams) -> PullActionsResult {
                     .rule_name
                     .map(|(group, name)| (Cow::Borrowed(group), Cow::Borrowed(name))),
                 suggestion: item.suggestion,
+                offset: action_offset,
             }
         }));
 
diff --git a/crates/biome_service/src/file_handlers/mod.rs b/crates/biome_service/src/file_handlers/mod.rs
index 35144f46df..2001b46387 100644
--- a/crates/biome_service/src/file_handlers/mod.rs
+++ b/crates/biome_service/src/file_handlers/mod.rs
@@ -4,11 +4,11 @@ use self::{
 };
 use crate::WorkspaceError;
 use crate::diagnostics::{QueryDiagnostic, SearchError};
-pub use crate::file_handlers::astro::{ASTRO_FENCE, AstroFileHandler};
+pub use crate::file_handlers::astro::AstroFileHandler;
 use crate::file_handlers::graphql::GraphqlFileHandler;
 use crate::file_handlers::ignore::IgnoreFileHandler;
-pub use crate::file_handlers::svelte::{SVELTE_FENCE, SvelteFileHandler};
-pub use crate::file_handlers::vue::{VUE_FENCE, VueFileHandler};
+pub use crate::file_handlers::svelte::SvelteFileHandler;
+pub use crate::file_handlers::vue::VueFileHandler;
 use crate::settings::Settings;
 use crate::workspace::{
     AnyEmbeddedSnippet, FixFileMode, FixFileResult, GetSyntaxTreeResult, PullActionsResult,
@@ -55,7 +55,7 @@ use std::borrow::Cow;
 use std::sync::Arc;
 use tracing::instrument;
 
-mod astro;
+pub mod astro;
 pub(crate) mod css;
 pub(crate) mod graphql;
 pub(crate) mod grit;
@@ -63,9 +63,9 @@ pub(crate) mod html;
 mod ignore;
 pub(crate) mod javascript;
 pub(crate) mod json;
-mod svelte;
+pub mod svelte;
 mod unknown;
-mod vue;
+pub mod vue;
 
 #[cfg_attr(feature = "schema", derive(schemars::JsonSchema))]
 #[derive(
@@ -122,41 +122,72 @@ impl From<GritFileSource> for DocumentFileSource {
 
 impl From<&Utf8Path> for DocumentFileSource {
     fn from(path: &Utf8Path) -> Self {
-        Self::from_path(path)
+        Self::from_path(path, false)
     }
 }
 
 impl DocumentFileSource {
-    fn try_from_well_known(path: &Utf8Path) -> Result<Self, FileSourceError> {
+    fn try_from_well_known(
+        path: &Utf8Path,
+        experimental_full_html_support: bool,
+    ) -> Result<Self, FileSourceError> {
         if let Ok(file_source) = JsonFileSource::try_from_well_known(path) {
             return Ok(file_source.into());
         }
-        if let Ok(file_source) = JsFileSource::try_from_well_known(path) {
-            return Ok(file_source.into());
+        if experimental_full_html_support {
+            if let Ok(file_source) = HtmlFileSource::try_from_well_known(path) {
+                return Ok(file_source.into());
+            }
+            if let Ok(file_source) = JsFileSource::try_from_well_known(path) {
+                return Ok(file_source.into());
+            }
+        } else {
+            if let Ok(file_source) = JsFileSource::try_from_well_known(path) {
+                return Ok(file_source.into());
+            }
+            if let Ok(file_source) = HtmlFileSource::try_from_well_known(path) {
+                return Ok(file_source.into());
+            }
         }
+
         if let Ok(file_source) = CssFileSource::try_from_well_known(path) {
             return Ok(file_source.into());
         }
         if let Ok(file_source) = GraphqlFileSource::try_from_well_known(path) {
             return Ok(file_source.into());
         }
-        if let Ok(file_source) = HtmlFileSource::try_from_well_known(path) {
-            return Ok(file_source.into());
-        }
 
         Err(FileSourceError::UnknownFileName)
     }
 
     /// Returns the document file source corresponding to this file name from well-known files
-    pub fn from_well_known(path: &Utf8Path) -> Self {
-        Self::try_from_well_known(path).unwrap_or(Self::Unknown)
-    }
+    pub fn from_well_known(path: &Utf8Path, experimental_full_html_support: bool) -> Self {
+        Self::try_from_well_known(path, experimental_full_html_support).unwrap_or(Self::Unknown)
+    }
+
+    fn try_from_extension(
+        extension: &str,
+        experimental_full_html_support: bool,
+    ) -> Result<Self, FileSourceError> {
+        // Order here is important
+        if experimental_full_html_support {
+            if let Ok(file_source) = HtmlFileSource::try_from_extension(extension) {
+                return Ok(file_source.into());
+            }
+            if let Ok(file_source) = JsFileSource::try_from_extension(extension) {
+                return Ok(file_source.into());
+            }
+        } else {
+            if let Ok(file_source) = JsFileSource::try_from_extension(extension) {
+                return Ok(file_source.into());
+            }
 
-    fn try_from_extension(extension: &str) -> Result<Self, FileSourceError> {
-        if let Ok(file_source) = JsonFileSource::try_from_extension(extension) {
-            return Ok(file_source.into());
+            if let Ok(file_source) = HtmlFileSource::try_from_extension(extension) {
+                return Ok(file_source.into());
+            }
         }
-        if let Ok(file_source) = JsFileSource::try_from_extension(extension) {
+
+        if let Ok(file_source) = JsonFileSource::try_from_extension(extension) {
             return Ok(file_source.into());
         }
         if let Ok(file_source) = CssFileSource::try_from_extension(extension) {
@@ -165,9 +196,7 @@ impl DocumentFileSource {
         if let Ok(file_source) = GraphqlFileSource::try_from_extension(extension) {
             return Ok(file_source.into());
         }
-        if let Ok(file_source) = HtmlFileSource::try_from_extension(extension) {
-            return Ok(file_source.into());
-        }
+
         if let Ok(file_source) = GritFileSource::try_from_extension(extension) {
             return Ok(file_source.into());
         }
@@ -175,8 +204,8 @@ impl DocumentFileSource {
     }
 
     /// Returns the document file source corresponding to this file extension
-    pub fn from_extension(extension: &str) -> Self {
-        Self::try_from_extension(extension).unwrap_or(Self::Unknown)
+    pub fn from_extension(extension: &str, experimental_full_html_support: bool) -> Self {
+        Self::try_from_extension(extension, experimental_full_html_support).unwrap_or(Self::Unknown)
     }
 
     #[instrument(level = "debug", fields(result))]
@@ -212,8 +241,11 @@ impl DocumentFileSource {
         Self::try_from_language_id(language_id).unwrap_or(Self::Unknown)
     }
 
-    pub(crate) fn try_from_path(path: &Utf8Path) -> Result<Self, FileSourceError> {
-        if let Ok(file_source) = Self::try_from_well_known(path) {
+    pub(crate) fn try_from_path(
+        path: &Utf8Path,
+        experimental_full_html_support: bool,
+    ) -> Result<Self, FileSourceError> {
+        if let Ok(file_source) = Self::try_from_well_known(path, experimental_full_html_support) {
             return Ok(file_source);
         }
 
@@ -244,12 +276,12 @@ impl DocumentFileSource {
                 .ok_or(FileSourceError::MissingFileExtension)?,
         };
 
-        Self::try_from_extension(extension.as_ref())
+        Self::try_from_extension(extension.as_ref(), experimental_full_html_support)
     }
 
     /// Returns the document file source corresponding to the file path
-    pub fn from_path(path: &Utf8Path) -> Self {
-        Self::try_from_path(path).unwrap_or(Self::Unknown)
+    pub fn from_path(path: &Utf8Path, experimental_full_html_support: bool) -> Self {
+        Self::try_from_path(path, experimental_full_html_support).unwrap_or(Self::Unknown)
     }
 
     /// Returns the document file source if it's not unknown, otherwise returns `other`.
@@ -334,25 +366,16 @@ impl DocumentFileSource {
         }
     }
 
-    /// Convert the file source from a JS file source into an HTML-like file source, if the file belongs to an HTML-like language.
-    pub fn to_htmlish(&self) -> Self {
-        match self {
-            Self::Js(js) => match js.as_embedding_kind() {
-                EmbeddingKind::Astro => Self::Html(HtmlFileSource::astro()),
-                EmbeddingKind::Vue => Self::Html(HtmlFileSource::vue()),
-                EmbeddingKind::Svelte => Self::Html(HtmlFileSource::svelte()),
-                EmbeddingKind::None => Self::Unknown,
-            },
-            _ => Self::Unknown,
-        }
-    }
-
     /// The file can be parsed
     pub fn can_parse(path: &Utf8Path) -> bool {
         let file_source = Self::from(path);
         match file_source {
-            Self::Js(_) => true,
-            Self::Css(_) | Self::Graphql(_) | Self::Json(_) | Self::Html(_) | Self::Grit(_) => true,
+            Self::Js(_)
+            | Self::Css(_)
+            | Self::Graphql(_)
+            | Self::Json(_)
+            | Self::Html(_)
+            | Self::Grit(_) => true,
             Self::Ignore => false,
             Self::Unknown => false,
         }
@@ -374,8 +397,8 @@ impl DocumentFileSource {
     }
 
     /// Whether this file can contain embedded nodes
-    pub fn can_contain_embeds(path: &Utf8Path) -> bool {
-        let file_source = Self::from(path);
+    pub fn can_contain_embeds(path: &Utf8Path, experimental_full_html_support: bool) -> bool {
+        let file_source = Self::from_path(path, experimental_full_html_support);
         match file_source {
             Self::Html(_) => true,
             Self::Js(_)
@@ -650,6 +673,7 @@ pub(crate) struct CodeActionsParams<'a> {
     pub(crate) enabled_rules: &'a [AnalyzerSelector],
     pub(crate) plugins: AnalyzerPluginVec,
     pub(crate) categories: RuleCategories,
+    pub(crate) action_offset: Option<TextSize>,
 }
 
 pub(crate) struct UpdateSnippetsNodes {
@@ -702,6 +726,7 @@ type FormatEmbedded = fn(
     Vec<FormatEmbedNode>,
 ) -> Result<Printed, WorkspaceError>;
 
+#[derive(Debug)]
 pub(crate) struct FormatEmbedNode {
     pub(crate) range: TextRange,
     pub(crate) node: AnyParse,
@@ -774,8 +799,8 @@ impl Features {
             json: JsonFileHandler {},
             css: CssFileHandler {},
             astro: AstroFileHandler {},
-            vue: VueFileHandler {},
             svelte: SvelteFileHandler {},
+            vue: VueFileHandler {},
             graphql: GraphqlFileHandler {},
             html: HtmlFileHandler {},
             grit: GritFileHandler {},
@@ -787,6 +812,7 @@ impl Features {
     /// Returns the [Capabilities] associated with a [BiomePath]
     pub(crate) fn get_capabilities(&self, language_hint: DocumentFileSource) -> Capabilities {
         match language_hint {
+            // TODO: remove match once we remove vue/astro/svelte handlers
             DocumentFileSource::Js(source) => match source.as_embedding_kind() {
                 EmbeddingKind::Astro => self.astro.capabilities(),
                 EmbeddingKind::Vue => self.vue.capabilities(),
@@ -907,36 +933,6 @@ pub(crate) fn search(
     Ok(matches)
 }
 
-#[test]
-fn test_svelte_script_lang() {
-    const SVELTE_JS_SCRIPT_OPENING_TAG: &str = r#"<script>"#;
-    const SVELTE_TS_SCRIPT_OPENING_TAG: &str = r#"<script lang="ts">"#;
-    const SVELTE_CONTEXT_MODULE_JS_SCRIPT_OPENING_TAG: &str = r#"<script context="module">"#;
-    const SVELTE_CONTEXT_MODULE_TS_SCRIPT_OPENING_TAG: &str =
-        r#"<script context="module" lang="ts">"#;
-
-    assert!(
-        parse_lang_from_script_opening_tag(SVELTE_JS_SCRIPT_OPENING_TAG)
-            .0
-            .is_javascript()
-    );
-    assert!(
-        parse_lang_from_script_opening_tag(SVELTE_TS_SCRIPT_OPENING_TAG)
-            .0
-            .is_typescript()
-    );
-    assert!(
-        parse_lang_from_script_opening_tag(SVELTE_CONTEXT_MODULE_JS_SCRIPT_OPENING_TAG)
-            .0
-            .is_javascript()
-    );
-    assert!(
-        parse_lang_from_script_opening_tag(SVELTE_CONTEXT_MODULE_TS_SCRIPT_OPENING_TAG)
-            .0
-            .is_typescript()
-    );
-}
-
 /// Type meant to register all the syntax rules for each language supported by Biome
 ///
 /// When a new language is introduced, it must be implemented it. Syntax rules aren't negotiable via configuration, so it's safe
@@ -1663,59 +1659,3 @@ impl<'b> AnalyzerVisitorBuilder<'b> {
         (enabled_rules, disabled_rules, analyzer_options)
     }
 }
-
-#[test]
-fn test_vue_script_lang() {
-    const VUE_JS_SCRIPT_OPENING_TAG: &str = r#"<script>"#;
-    const VUE_TS_SCRIPT_OPENING_TAG: &str = r#"<script lang="ts">"#;
-    const VUE_TSX_SCRIPT_OPENING_TAG: &str = r#"<script lang="tsx">"#;
-    const VUE_JSX_SCRIPT_OPENING_TAG: &str = r#"<script lang="jsx">"#;
-    const VUE_SETUP_JS_SCRIPT_OPENING_TAG: &str = r#"<script setup>"#;
-    const VUE_SETUP_TS_SCRIPT_OPENING_TAG: &str = r#"<script setup lang="ts">"#;
-
-    assert!(
-        parse_lang_from_script_opening_tag(VUE_JS_SCRIPT_OPENING_TAG)
-            .0
-            .is_javascript()
-    );
-    assert!(
-        parse_lang_from_script_opening_tag(VUE_JS_SCRIPT_OPENING_TAG)
-            .1
-            .is_standard()
-    );
-    assert!(
-        parse_lang_from_script_opening_tag(VUE_TS_SCRIPT_OPENING_TAG)
-            .0
-            .is_typescript()
-    );
-    assert!(
-        parse_lang_from_script_opening_tag(VUE_TS_SCRIPT_OPENING_TAG)
-            .1
-            .is_standard()
-    );
-    assert!(
-        parse_lang_from_script_opening_tag(VUE_JSX_SCRIPT_OPENING_TAG)
-            .0
-            .is_javascript()
-    );
-    assert!(
-        parse_lang_from_script_opening_tag(VUE_JSX_SCRIPT_OPENING_TAG)
-            .1
-            .is_jsx()
-    );
-    assert!(
-        parse_lang_from_script_opening_tag(VUE_TSX_SCRIPT_OPENING_TAG)
-            .0
-            .is_typescript()
-    );
-    assert!(
-        parse_lang_from_script_opening_tag(VUE_SETUP_JS_SCRIPT_OPENING_TAG)
-            .0
-            .is_javascript()
-    );
-    assert!(
-        parse_lang_from_script_opening_tag(VUE_SETUP_TS_SCRIPT_OPENING_TAG)
-            .0
-            .is_typescript()
-    );
-}
diff --git a/crates/biome_service/src/file_handlers/svelte.rs b/crates/biome_service/src/file_handlers/svelte.rs
index ed406ae4ea..fbe3ead301 100644
--- a/crates/biome_service/src/file_handlers/svelte.rs
+++ b/crates/biome_service/src/file_handlers/svelte.rs
@@ -148,8 +148,7 @@ fn format(
     settings: &Settings,
 ) -> Result<Printed, WorkspaceError> {
     let options = settings.format_options::<JsLanguage>(biome_path, document_file_source);
-    let html_options =
-        settings.format_options::<HtmlLanguage>(biome_path, &document_file_source.to_htmlish());
+    let html_options = settings.format_options::<HtmlLanguage>(biome_path, document_file_source);
     let indent_amount = if *html_options.indent_script_and_style() {
         1
     } else {
diff --git a/crates/biome_service/src/file_handlers/vue.rs b/crates/biome_service/src/file_handlers/vue.rs
index 2540f55ff0..aa0ff53a5e 100644
--- a/crates/biome_service/src/file_handlers/vue.rs
+++ b/crates/biome_service/src/file_handlers/vue.rs
@@ -148,8 +148,7 @@ fn format(
     settings: &Settings,
 ) -> Result<Printed, WorkspaceError> {
     let options = settings.format_options::<JsLanguage>(biome_path, document_file_source);
-    let html_options =
-        settings.format_options::<HtmlLanguage>(biome_path, &document_file_source.to_htmlish());
+    let html_options = settings.format_options::<HtmlLanguage>(biome_path, document_file_source);
     let indent_amount = if *html_options.indent_script_and_style() {
         1
     } else {
diff --git a/crates/biome_service/src/settings.rs b/crates/biome_service/src/settings.rs
index e3a1fe5fe6..947f0934b4 100644
--- a/crates/biome_service/src/settings.rs
+++ b/crates/biome_service/src/settings.rs
@@ -6,7 +6,7 @@ use biome_configuration::analyzer::{LinterEnabled, RuleDomains};
 use biome_configuration::bool::Bool;
 use biome_configuration::diagnostics::InvalidIgnorePattern;
 use biome_configuration::formatter::{FormatWithErrorsEnabled, FormatterEnabled};
-use biome_configuration::html::HtmlConfiguration;
+use biome_configuration::html::{ExperimentalFullSupportEnabled, HtmlConfiguration};
 use biome_configuration::javascript::JsxRuntime;
 use biome_configuration::max_size::MaxSize;
 use biome_configuration::plugins::Plugins;
@@ -73,9 +73,18 @@ pub struct Settings {
     pub override_settings: OverrideSettings,
     /// The VCS settings of the project
     pub vcs_settings: VcsSettings,
+
+    // TODO: remove once HTML full support is stable
+    pub experimental_full_html_support: Option<ExperimentalFullSupportEnabled>,
 }
 
 impl Settings {
+    pub fn experimental_full_html_support_enabled(&self) -> bool {
+        self.experimental_full_html_support
+            .unwrap_or_default()
+            .value()
+    }
+
     pub fn source(&self) -> Option<Configuration> {
         self.source.as_ref().map(|source| {
             let (config, _) = source.deref().clone();
@@ -142,7 +151,8 @@ impl Settings {
         }
         // html settings
         if let Some(html) = configuration.html {
-            self.languages.html = html.into()
+            self.experimental_full_html_support = html.experimental_full_support_enabled;
+            self.languages.html = html.into();
         }
 
         // plugin settings
@@ -304,6 +314,7 @@ impl Settings {
             FeatureKind::Format => &self.formatter.includes,
             FeatureKind::Lint => &self.linter.includes,
             FeatureKind::Assist => &self.assist.includes,
+            FeatureKind::HtmlFullSupport => return false,
             FeatureKind::Search => return false, // There is no search-specific config.
             FeatureKind::Debug => return false,
         };
diff --git a/crates/biome_service/src/workspace.rs b/crates/biome_service/src/workspace.rs
index 5727ce8276..c3df2fdf47 100644
--- a/crates/biome_service/src/workspace.rs
+++ b/crates/biome_service/src/workspace.rs
@@ -130,13 +130,14 @@ pub struct SupportsFeatureResult {
 pub struct FeaturesSupported([SupportKind; NUM_FEATURE_KINDS]);
 
 impl FeaturesSupported {
-    /// By default, all features are not supported by a file.
+    /// By default, a file does not support all features.
     const WORKSPACE_FEATURES: [SupportKind; NUM_FEATURE_KINDS] = [
         SupportKind::FileNotSupported,
         SupportKind::FileNotSupported,
         SupportKind::FileNotSupported,
         SupportKind::FileNotSupported,
         SupportKind::FileNotSupported,
+        SupportKind::FileNotSupported,
     ];
 
     #[inline]
@@ -218,6 +219,12 @@ impl FeaturesSupported {
             }
         }
 
+        if let Some(experimental_full_html_support) = settings.experimental_full_html_support
+            && experimental_full_html_support.value()
+        {
+            self.insert(FeatureKind::HtmlFullSupport, SupportKind::Supported);
+        }
+
         debug!("The file has the following feature sets: {:?}", &self);
 
         self
@@ -267,6 +274,11 @@ impl FeaturesSupported {
         self.supports(FeatureKind::Search)
     }
 
+    // TODO: remove once html full support is stable
+    pub fn supports_full_html_support(&self) -> bool {
+        self.supports(FeatureKind::HtmlFullSupport)
+    }
+
     /// Returns the [`SupportKind`] for the given `feature`, but only if it is
     /// not enabled.
     #[inline(always)]
@@ -536,9 +548,11 @@ pub enum FeatureKind {
     Search,
     Assist,
     Debug,
+    // TODO: remove once full HTML support is stable
+    HtmlFullSupport,
 }
 
-pub const NUM_FEATURE_KINDS: usize = 5;
+pub const NUM_FEATURE_KINDS: usize = 6;
 
 impl Display for FeatureKind {
     fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
@@ -548,6 +562,7 @@ impl Display for FeatureKind {
             Self::Search => write!(f, "Search"),
             Self::Assist => write!(f, "Assist"),
             Self::Debug => write!(f, "Debug"),
+            Self::HtmlFullSupport => write!(f, "HtmlFullSupport"),
         }
     }
 }
@@ -565,6 +580,7 @@ impl FeatureKind {
             2 => Self::Search,
             3 => Self::Assist,
             4 => Self::Debug,
+            5 => Self::HtmlFullSupport,
             _ => unreachable!("invalid index for FeatureKind"),
         }
     }
@@ -578,6 +594,7 @@ impl FeatureKind {
             Self::Search => 2,
             Self::Assist => 3,
             Self::Debug => 4,
+            Self::HtmlFullSupport => 5,
         }
     }
 }
@@ -606,6 +623,7 @@ impl Debug for FeatureName {
                 FeatureKind::Search => list.entry(&"Search"),
                 FeatureKind::Assist => list.entry(&"Assist"),
                 FeatureKind::Debug => list.entry(&"Debug"),
+                FeatureKind::HtmlFullSupport => list.entry(&"HtmlFullSupport"),
             };
         }
         list.finish()
@@ -969,6 +987,7 @@ pub struct CodeAction {
     pub category: ActionCategory,
     pub rule_name: Option<(Cow<'static, str>, Cow<'static, str>)>,
     pub suggestion: CodeSuggestion,
+    pub offset: Option<TextSize>,
 }
 
 #[derive(Debug, serde::Serialize, serde::Deserialize)]
diff --git a/crates/biome_service/src/workspace/server.rs b/crates/biome_service/src/workspace/server.rs
index dd748e48c6..15413228f9 100644
--- a/crates/biome_service/src/workspace/server.rs
+++ b/crates/biome_service/src/workspace/server.rs
@@ -210,19 +210,30 @@ impl WorkspaceServer {
     }
 
     /// Gets the supported capabilities for a given file path.
-    fn get_file_capabilities(&self, path: &BiomePath) -> Capabilities {
-        let language = self.get_file_source(path);
+    fn get_file_capabilities(
+        &self,
+        path: &BiomePath,
+        experimental_full_html_support: bool,
+    ) -> Capabilities {
+        let language = self.get_file_source(path, experimental_full_html_support);
         self.features.get_capabilities(language)
     }
 
     /// Retrieves the supported language of a file.
-    fn get_file_source(&self, path: &Utf8Path) -> DocumentFileSource {
+    fn get_file_source(
+        &self,
+        path: &Utf8Path,
+        experimental_full_html_support: bool,
+    ) -> DocumentFileSource {
         self.documents
             .pin()
             .get(path)
             .map(|doc| doc.file_source_index)
             .and_then(|index| self.get_source(index))
-            .unwrap_or(DocumentFileSource::from_path(path))
+            .unwrap_or(DocumentFileSource::from_path(
+                path,
+                experimental_full_html_support,
+            ))
     }
 
     /// Returns an error factory function for unsupported features at a given
@@ -232,9 +243,10 @@ impl WorkspaceServer {
         path: &'a Utf8Path,
     ) -> impl FnOnce() -> WorkspaceError + 'a {
         move || {
-            let file_source = self.get_file_source(path);
+            // For simplicity and avoid too many changes, we hardcode the support to false
+            let file_source = self.get_file_source(path, false);
 
-            let language = DocumentFileSource::from_path(path).or(file_source);
+            let language = DocumentFileSource::from_path(path, false).or(file_source);
             WorkspaceError::source_file_not_supported(
                 language,
                 path.to_string(),
@@ -288,13 +300,16 @@ impl WorkspaceServer {
             return Ok(Default::default());
         }
 
-        let mut source = document_file_source.unwrap_or(DocumentFileSource::from_path(&path));
-
         let settings = self
             .projects
             .get_settings_based_on_path(project_key, &path)
             .ok_or_else(WorkspaceError::no_project)?;
 
+        let mut source = document_file_source.unwrap_or(DocumentFileSource::from_path(
+            &path,
+            settings.experimental_full_html_support_enabled(),
+        ));
+
         if let DocumentFileSource::Js(js) = &mut source {
             match path.extension() {
                 Some("js") => {
@@ -363,8 +378,10 @@ impl WorkspaceServer {
         };
         // Second-pass parsing for HTML files with embedded JavaScript and CSS
         // content.
-        let embedded_snippets = if DocumentFileSource::can_contain_embeds(path.as_path())
-            && let Some(Ok(any_parse)) = &syntax
+        let embedded_snippets = if DocumentFileSource::can_contain_embeds(
+            path.as_path(),
+            settings.experimental_full_html_support_enabled(),
+        ) && let Some(Ok(any_parse)) = &syntax
         {
             // Second-pass parsing for HTML files with embedded JavaScript and CSS content
 
@@ -523,7 +540,8 @@ impl WorkspaceServer {
         settings: &Settings,
     ) -> Result<Vec<AnyEmbeddedSnippet>, WorkspaceError> {
         let mut embedded_nodes = Vec::new();
-        let capabilities = self.get_file_capabilities(path);
+        let capabilities =
+            self.get_file_capabilities(path, settings.experimental_full_html_support_enabled());
         let Some(parse_embedded) = capabilities.parser.parse_embedded_nodes else {
             return Ok(Default::default());
         };
@@ -1078,7 +1096,14 @@ impl Workspace for WorkspaceServer {
         &self,
         params: SupportsFeatureParams,
     ) -> Result<FileFeaturesResult, WorkspaceError> {
-        let language = self.get_file_source(&params.path);
+        let settings = self
+            .projects
+            .get_settings_based_on_path(params.project_key, &params.path)
+            .ok_or_else(WorkspaceError::no_project)?;
+        let language = self.get_file_source(
+            &params.path,
+            settings.experimental_full_html_support_enabled(),
+        );
         let capabilities = self.features.get_capabilities(language);
 
         self.projects.get_file_features(
@@ -1116,7 +1141,14 @@ impl Workspace for WorkspaceServer {
         &self,
         params: GetSyntaxTreeParams,
     ) -> Result<GetSyntaxTreeResult, WorkspaceError> {
-        let capabilities = self.get_file_capabilities(&params.path);
+        let settings = self
+            .projects
+            .get_settings_based_on_path(params.project_key, &params.path)
+            .ok_or_else(WorkspaceError::no_project)?;
+        let capabilities = self.get_file_capabilities(
+            &params.path,
+            settings.experimental_full_html_support_enabled(),
+        );
         let debug_syntax_tree = capabilities
             .debug
             .debug_syntax_tree
@@ -1133,7 +1165,14 @@ impl Workspace for WorkspaceServer {
         &self,
         params: GetControlFlowGraphParams,
     ) -> Result<String, WorkspaceError> {
-        let capabilities = self.get_file_capabilities(&params.path);
+        let settings = self
+            .projects
+            .get_settings_based_on_path(params.project_key, &params.path)
+            .ok_or_else(WorkspaceError::no_project)?;
+        let capabilities = self.get_file_capabilities(
+            &params.path,
+            settings.experimental_full_html_support_enabled(),
+        );
         let debug_control_flow = capabilities
             .debug
             .debug_control_flow
@@ -1146,28 +1185,41 @@ impl Workspace for WorkspaceServer {
     }
 
     fn get_formatter_ir(&self, params: GetFormatterIRParams) -> Result<String, WorkspaceError> {
-        let capabilities = self.get_file_capabilities(&params.path);
-        let debug_formatter_ir = capabilities
-            .debug
-            .debug_formatter_ir
-            .ok_or_else(self.build_capability_error(&params.path))?;
         let settings = self
             .projects
             .get_settings_based_on_path(params.project_key, &params.path)
             .ok_or_else(WorkspaceError::no_project)?;
+        let capabilities = self.get_file_capabilities(
+            &params.path,
+            settings.experimental_full_html_support_enabled(),
+        );
+        let debug_formatter_ir = capabilities
+            .debug
+            .debug_formatter_ir
+            .ok_or_else(self.build_capability_error(&params.path))?;
         let parse = self.get_parse(&params.path)?;
         if !settings.format_with_errors_enabled_for_this_file_path(&params.path)
             && parse.has_errors()
         {
             return Err(WorkspaceError::format_with_errors_disabled());
         }
-        let document_file_source = self.get_file_source(&params.path);
+        let document_file_source = self.get_file_source(
+            &params.path,
+            settings.experimental_full_html_support_enabled(),
+        );
 
         debug_formatter_ir(&params.path, &document_file_source, parse, &settings)
     }
 
     fn get_type_info(&self, params: GetTypeInfoParams) -> Result<String, WorkspaceError> {
-        let capabilities = self.get_file_capabilities(&params.path);
+        let settings = self
+            .projects
+            .get_settings_based_on_path(params.project_key, &params.path)
+            .ok_or_else(WorkspaceError::no_project)?;
+        let capabilities = self.get_file_capabilities(
+            &params.path,
+            settings.experimental_full_html_support_enabled(),
+        );
         let debug_type_info = capabilities
             .debug
             .debug_type_info
@@ -1181,7 +1233,14 @@ impl Workspace for WorkspaceServer {
         &self,
         params: GetRegisteredTypesParams,
     ) -> Result<String, WorkspaceError> {
-        let capabilities = self.get_file_capabilities(&params.path);
+        let settings = self
+            .projects
+            .get_settings_based_on_path(params.project_key, &params.path)
+            .ok_or_else(WorkspaceError::no_project)?;
+        let capabilities = self.get_file_capabilities(
+            &params.path,
+            settings.experimental_full_html_support_enabled(),
+        );
         let debug_registered_types = capabilities
             .debug
             .debug_registered_types
@@ -1192,7 +1251,14 @@ impl Workspace for WorkspaceServer {
     }
 
     fn get_semantic_model(&self, params: GetSemanticModelParams) -> Result<String, WorkspaceError> {
-        let capabilities = self.get_file_capabilities(&params.path);
+        let settings = self
+            .projects
+            .get_settings_based_on_path(params.project_key, &params.path)
+            .ok_or_else(WorkspaceError::no_project)?;
+        let capabilities = self.get_file_capabilities(
+            &params.path,
+            settings.experimental_full_html_support_enabled(),
+        );
         let debug_semantic_model = capabilities
             .debug
             .debug_semantic_model
@@ -1272,10 +1338,14 @@ impl Workspace for WorkspaceServer {
 
         let parsed = self.parse(&path, &content, &settings, index, &mut node_cache)?;
         let root = parsed.any_parse.unwrap_as_send_node();
-        let document_source = self.get_file_source(&path);
+        let document_source =
+            self.get_file_source(&path, settings.experimental_full_html_support_enabled());
 
         // Second-pass parsing for HTML files with embedded JavaScript and CSS content
-        let embedded_snippets = if DocumentFileSource::can_contain_embeds(path.as_path()) {
+        let embedded_snippets = if DocumentFileSource::can_contain_embeds(
+            path.as_path(),
+            settings.experimental_full_html_support_enabled(),
+        ) {
             // Second-pass parsing for HTML files with embedded JavaScript and CSS content
             let mut node_cache = NodeCache::default();
             self.parse_embedded_language_snippets(
@@ -1365,18 +1435,18 @@ impl Workspace for WorkspaceServer {
             enabled_rules,
             pull_code_actions,
         } = params;
+        let settings = self
+            .projects
+            .get_settings_based_on_path(project_key, &path)
+            .ok_or_else(WorkspaceError::no_project)?;
         let (parse, embedded_snippets) = self.get_parse_with_snippets(&path)?;
-        let language = self.get_file_source(&path);
+        let language =
+            self.get_file_source(&path, settings.experimental_full_html_support_enabled());
         let capabilities = self.features.get_capabilities(language);
         let (diagnostics, errors, skipped_diagnostics) = if (categories.is_lint()
             || categories.is_assist())
             && let Some(lint) = capabilities.analyzer.lint
         {
-            let settings = self
-                .projects
-                .get_settings_based_on_path(project_key, &path)
-                .ok_or_else(WorkspaceError::no_project)?;
-
             let plugins = if categories.is_lint() {
                 self.get_analyzer_plugins_for_project(
                     settings.source_path().unwrap_or_default().as_path(),
@@ -1500,18 +1570,20 @@ impl Workspace for WorkspaceServer {
             enabled_rules,
             categories,
         } = params;
-        let capabilities = self.get_file_capabilities(&path);
+        let settings = self
+            .projects
+            .get_settings_based_on_path(project_key, &path)
+            .ok_or_else(WorkspaceError::no_project)?;
+        let capabilities =
+            self.get_file_capabilities(&path, settings.experimental_full_html_support_enabled());
         let code_actions = capabilities
             .analyzer
             .code_actions
             .ok_or_else(self.build_capability_error(&path))?;
 
         let (parse, embedded_snippets) = self.get_parse_with_snippets(&path)?;
-        let language = self.get_file_source(&path);
-        let settings = self
-            .projects
-            .get_settings_based_on_path(project_key, &path)
-            .ok_or_else(WorkspaceError::no_project)?;
+        let language =
+            self.get_file_source(&path, settings.experimental_full_html_support_enabled());
         let mut result = code_actions(CodeActionsParams {
             parse,
             range,
@@ -1526,6 +1598,7 @@ impl Workspace for WorkspaceServer {
             enabled_rules: &enabled_rules,
             plugins: Vec::new(),
             categories,
+            action_offset: None,
         });
 
         for embedded_snippet in embedded_snippets {
@@ -1551,6 +1624,7 @@ impl Workspace for WorkspaceServer {
                 enabled_rules: &enabled_rules,
                 plugins: Vec::new(),
                 categories,
+                action_offset: Some(embedded_snippet.content_offset()),
             });
 
             result.actions.extend(embedded_actions_result.actions);
@@ -1569,7 +1643,14 @@ impl Workspace for WorkspaceServer {
         )
     )]
     fn format_file(&self, params: FormatFileParams) -> Result<Printed, WorkspaceError> {
-        let capabilities = self.get_file_capabilities(&params.path);
+        let settings = self
+            .projects
+            .get_settings_based_on_path(params.project_key, &params.path)
+            .ok_or_else(WorkspaceError::no_project)?;
+        let capabilities = self.get_file_capabilities(
+            &params.path,
+            settings.experimental_full_html_support_enabled(),
+        );
 
         let format = capabilities
             .formatter
@@ -1578,11 +1659,6 @@ impl Workspace for WorkspaceServer {
 
         let format_embedded = capabilities.formatter.format_embedded;
 
-        let settings = self
-            .projects
-            .get_settings_based_on_path(params.project_key, &params.path)
-            .ok_or_else(WorkspaceError::no_project)?;
-
         let (parse, embedded_nodes) = self.get_parse_with_embedded_format_nodes(&params.path)?;
 
         if !settings.format_with_errors_enabled_for_this_file_path(&params.path)
@@ -1591,7 +1667,10 @@ impl Workspace for WorkspaceServer {
             return Err(WorkspaceError::format_with_errors_disabled());
         }
 
-        let document_file_source = self.get_file_source(&params.path);
+        let document_file_source = self.get_file_source(
+            &params.path,
+            settings.experimental_full_html_support_enabled(),
+        );
         if !embedded_nodes.is_empty() {
             let format_embedded =
                 format_embedded.ok_or_else(self.build_capability_error(&params.path))?;
@@ -1608,22 +1687,28 @@ impl Workspace for WorkspaceServer {
 
     #[instrument(level = "debug", skip(self, params))]
     fn format_range(&self, params: FormatRangeParams) -> Result<Printed, WorkspaceError> {
-        let capabilities = self.get_file_capabilities(&params.path);
-        let format_range = capabilities
-            .formatter
-            .format_range
-            .ok_or_else(self.build_capability_error(&params.path))?;
         let settings = self
             .projects
             .get_settings_based_on_path(params.project_key, &params.path)
             .ok_or_else(WorkspaceError::no_project)?;
+        let capabilities = self.get_file_capabilities(
+            &params.path,
+            settings.experimental_full_html_support_enabled(),
+        );
+        let format_range = capabilities
+            .formatter
+            .format_range
+            .ok_or_else(self.build_capability_error(&params.path))?;
         let parse = self.get_parse(&params.path)?;
         if !settings.format_with_errors_enabled_for_this_file_path(&params.path)
             && parse.has_errors()
         {
             return Err(WorkspaceError::format_with_errors_disabled());
         }
-        let document_file_source = self.get_file_source(&params.path);
+        let document_file_source = self.get_file_source(
+            &params.path,
+            settings.experimental_full_html_support_enabled(),
+        );
         format_range(
             &params.path,
             &document_file_source,
@@ -1635,23 +1720,29 @@ impl Workspace for WorkspaceServer {
 
     #[instrument(level = "debug", skip(self, params))]
     fn format_on_type(&self, params: FormatOnTypeParams) -> Result<Printed, WorkspaceError> {
-        let capabilities = self.get_file_capabilities(&params.path);
+        let settings = self
+            .projects
+            .get_settings_based_on_path(params.project_key, &params.path)
+            .ok_or_else(WorkspaceError::no_project)?;
+        let capabilities = self.get_file_capabilities(
+            &params.path,
+            settings.experimental_full_html_support_enabled(),
+        );
         let format_on_type = capabilities
             .formatter
             .format_on_type
             .ok_or_else(self.build_capability_error(&params.path))?;
 
-        let settings = self
-            .projects
-            .get_settings_based_on_path(params.project_key, &params.path)
-            .ok_or_else(WorkspaceError::no_project)?;
         let parse = self.get_parse(&params.path)?;
         if !settings.format_with_errors_enabled_for_this_file_path(&params.path)
             && parse.has_errors()
         {
             return Err(WorkspaceError::format_with_errors_disabled());
         }
-        let document_file_source = self.get_file_source(&params.path);
+        let document_file_source = self.get_file_source(
+            &params.path,
+            settings.experimental_full_html_support_enabled(),
+        );
 
         format_on_type(
             &params.path,
@@ -1686,7 +1777,12 @@ impl Workspace for WorkspaceServer {
             suppression_reason,
         } = params;
 
-        let capabilities = self.get_file_capabilities(&path);
+        let settings = self
+            .projects
+            .get_settings_based_on_path(project_key, &path)
+            .ok_or_else(WorkspaceError::no_project)?;
+        let capabilities =
+            self.get_file_capabilities(&path, settings.experimental_full_html_support_enabled());
 
         let fix_all = capabilities
             .analyzer
@@ -1695,17 +1791,14 @@ impl Workspace for WorkspaceServer {
 
         let (mut parse, embedded_snippets) = self.get_parse_with_snippets(&path)?;
 
-        let settings = self
-            .projects
-            .get_settings_based_on_path(project_key, &path)
-            .ok_or_else(WorkspaceError::no_project)?;
         let plugins = self
             .get_analyzer_plugins_for_project(
                 settings.source_path().unwrap_or_default().as_path(),
                 &settings.get_plugins_for_path(&path),
             )
             .map_err(WorkspaceError::plugin_errors)?;
-        let language = self.get_file_source(&path);
+        let language =
+            self.get_file_source(&path, settings.experimental_full_html_support_enabled());
         let plugins = if rule_categories.contains(RuleCategory::Lint) {
             plugins
         } else {
@@ -1789,8 +1882,15 @@ impl Workspace for WorkspaceServer {
         })
     }
 
-    fn rename(&self, params: super::RenameParams) -> Result<RenameResult, WorkspaceError> {
-        let capabilities = self.get_file_capabilities(&params.path);
+    fn rename(&self, params: RenameParams) -> Result<RenameResult, WorkspaceError> {
+        let settings = self
+            .projects
+            .get_settings_based_on_path(params.project_key, &params.path)
+            .ok_or_else(WorkspaceError::no_project)?;
+        let capabilities = self.get_file_capabilities(
+            &params.path,
+            settings.experimental_full_html_support_enabled(),
+        );
         let rename = capabilities
             .analyzer
             .rename
@@ -1864,12 +1964,17 @@ impl Workspace for WorkspaceServer {
             pattern,
         }: SearchPatternParams,
     ) -> Result<SearchResults, WorkspaceError> {
+        let settings = self
+            .projects
+            .get_settings_based_on_path(project_key, &path)
+            .ok_or_else(WorkspaceError::no_project)?;
         let patterns = self.patterns.pin();
         let query = patterns
             .get(&pattern)
             .ok_or_else(WorkspaceError::invalid_pattern)?;
 
-        let capabilities = self.get_file_capabilities(&path);
+        let capabilities =
+            self.get_file_capabilities(&path, settings.experimental_full_html_support_enabled());
         let search = capabilities
             .search
             .search
@@ -1880,13 +1985,14 @@ impl Workspace for WorkspaceServer {
             .ok_or_else(WorkspaceError::no_project)?;
         let parse = self.get_parse(&path)?;
 
-        let document_file_source = self.get_file_source(&path);
+        let document_file_source =
+            self.get_file_source(&path, settings.experimental_full_html_support_enabled());
         let matches = search(&path, &document_file_source, parse, query, &settings)?;
 
         Ok(SearchResults { path, matches })
     }
 
-    fn drop_pattern(&self, params: super::DropPatternParams) -> Result<(), WorkspaceError> {
+    fn drop_pattern(&self, params: DropPatternParams) -> Result<(), WorkspaceError> {
         self.patterns.pin().remove(&params.pattern);
         Ok(())
     }
diff --git a/crates/biome_service/src/workspace/server.tests.rs b/crates/biome_service/src/workspace/server.tests.rs
index 26950bad3c..22714f6990 100644
--- a/crates/biome_service/src/workspace/server.tests.rs
+++ b/crates/biome_service/src/workspace/server.tests.rs
@@ -270,7 +270,7 @@ function Foo({cond}) {
         })
         .unwrap();
 
-    let ts_file_source = workspace.get_file_source("/project/a.ts".into());
+    let ts_file_source = workspace.get_file_source("/project/a.ts".into(), false);
     let ts = ts_file_source.to_js_file_source().expect("JS file source");
     assert!(ts.is_typescript());
     assert!(!ts.is_jsx());
@@ -279,7 +279,7 @@ function Foo({cond}) {
         Err(error) => panic!("File not available: {error}"),
     }
 
-    let js_file_source = workspace.get_file_source("/project/a.js".into());
+    let js_file_source = workspace.get_file_source("/project/a.js".into(), false);
     let js = js_file_source.to_js_file_source().expect("JS file source");
     assert!(!js.is_typescript());
     assert!(js.is_jsx());
@@ -382,7 +382,7 @@ function Foo({cond}) {
         })
         .unwrap();
 
-    let js_file_source = workspace.get_file_source("/project/a.js".into());
+    let js_file_source = workspace.get_file_source("/project/a.js".into(), false);
     let js = js_file_source.to_js_file_source().expect("JS file source");
     assert!(!js.is_typescript());
     assert!(!js.is_jsx());
@@ -391,7 +391,7 @@ function Foo({cond}) {
         Err(error) => panic!("File not available: {error}"),
     }
 
-    let jsx_file_source = workspace.get_file_source("/project/a.jsx".into());
+    let jsx_file_source = workspace.get_file_source("/project/a.jsx".into(), false);
     let jsx = jsx_file_source.to_js_file_source().expect("JS file source");
     assert!(!jsx.is_typescript());
     assert!(jsx.is_jsx());
diff --git a/crates/biome_test_utils/src/lib.rs b/crates/biome_test_utils/src/lib.rs
index 4984696762..cd01c2626a 100644
--- a/crates/biome_test_utils/src/lib.rs
+++ b/crates/biome_test_utils/src/lib.rs
@@ -86,7 +86,10 @@ pub fn create_analyzer_options<L: ServiceLanguage>(
             &L::lookup_settings(&settings.languages).linter,
             L::resolve_environment(&settings),
             &BiomePath::new(input_file),
-            &DocumentFileSource::from_path(input_file),
+            &DocumentFileSource::from_path(
+                input_file,
+                settings.experimental_full_html_support_enabled(),
+            ),
             None,
         )
     }
@@ -130,7 +133,10 @@ where
             .merge_with_configuration(configuration, None)
             .unwrap();
 
-        let document_file_source = DocumentFileSource::from_path(input_file);
+        let document_file_source = DocumentFileSource::from_path(
+            input_file,
+            settings.experimental_full_html_support_enabled(),
+        );
         settings.format_options::<L>(&input_file.into(), &document_file_source)
     }
 }
@@ -191,7 +197,7 @@ fn get_js_like_paths_in_dir(dir: &Utf8Path) -> Vec<BiomePath> {
             if path.is_dir() {
                 get_js_like_paths_in_dir(&path)
             } else {
-                DocumentFileSource::from_well_known(&path)
+                DocumentFileSource::from_well_known(&path, false)
                     .is_javascript_like()
                     .then(|| BiomePath::new(path))
                     .into_iter()
diff --git a/packages/@biomejs/backend-jsonrpc/src/workspace.ts b/packages/@biomejs/backend-jsonrpc/src/workspace.ts
index d1adb72164..b2ed973f50 100644
--- a/packages/@biomejs/backend-jsonrpc/src/workspace.ts
+++ b/packages/@biomejs/backend-jsonrpc/src/workspace.ts
@@ -8,7 +8,13 @@ export interface SupportsFeatureParams {
 export type FeatureName = FeatureKind[];
 export type BiomePath = string;
 export type ProjectKey = number;
-export type FeatureKind = "format" | "lint" | "search" | "assist" | "debug";
+export type FeatureKind =
+	| "format"
+	| "lint"
+	| "search"
+	| "assist"
+	| "debug"
+	| "htmlFullSupport";
 export interface FileFeaturesResult {
 	featuresSupported: FeaturesSupported;
 }
@@ -179,7 +185,7 @@ export interface FormatterConfiguration {
 	 */
 	expand?: Expand;
 	/**
-	 * Whether formatting should be allowed to proceed if a given file has syntax errors
+	 * Stores whether formatting should be allowed to proceed if a given file has syntax errors
 	 */
 	formatWithErrors?: Bool;
 	/**
@@ -245,6 +251,10 @@ export interface GritConfiguration {
  */
 export interface HtmlConfiguration {
 	assist?: HtmlAssistConfiguration;
+	/**
+	 * Enables full support for HTML, Vue, Svelte and Astro files.
+	 */
+	experimentalFullSupportEnabled?: Bool;
 	/**
 	 * HTML formatter options
 	 */
@@ -9411,7 +9421,7 @@ export type DocumentFileSource =
 	| { Grit: GritFileSource };
 export interface JsFileSource {
 	/**
-	 * Used to mark if the source is being used for an Astro, Svelte or Vue file
+	 * Used to mark if the JavaScript is embedded inside some particular files. This affects the parsing. For example, if inside an Astro file, a top-level return statement is allowed.
 	 */
 	embedding_kind: EmbeddingKind;
 	language: Language;
@@ -9625,6 +9635,7 @@ export interface PullActionsResult {
 }
 export interface CodeAction {
 	category: ActionCategory;
+	offset?: TextSize;
 	ruleName?: [string, string];
 	suggestion: CodeSuggestion;
 }
diff --git a/packages/@biomejs/biome/configuration_schema.json b/packages/@biomejs/biome/configuration_schema.json
index b09e083198..bf9a15f930 100644
--- a/packages/@biomejs/biome/configuration_schema.json
+++ b/packages/@biomejs/biome/configuration_schema.json
@@ -1381,10 +1381,12 @@
 			"properties": {
 				"allowWrongLineComments": {
 					"description": "Allow comments to appear on incorrect lines in `.css` files",
+					"default": null,
 					"anyOf": [{ "$ref": "#/definitions/Bool" }, { "type": "null" }]
 				},
 				"cssModules": {
 					"description": "Enables parsing of CSS Modules specific features.",
+					"default": null,
 					"anyOf": [{ "$ref": "#/definitions/Bool" }, { "type": "null" }]
 				},
 				"tailwindDirectives": {
@@ -1572,7 +1574,7 @@
 					"anyOf": [{ "$ref": "#/definitions/Expand" }, { "type": "null" }]
 				},
 				"formatWithErrors": {
-					"description": "Whether formatting should be allowed to proceed if a given file has syntax errors",
+					"description": "Stores whether formatting should be allowed to proceed if a given file has syntax errors",
 					"anyOf": [{ "$ref": "#/definitions/Bool" }, { "type": "null" }]
 				},
 				"includes": {
@@ -1863,6 +1865,10 @@
 						{ "type": "null" }
 					]
 				},
+				"experimentalFullSupportEnabled": {
+					"description": "Enables full support for HTML, Vue, Svelte and Astro files.",
+					"anyOf": [{ "$ref": "#/definitions/Bool" }, { "type": "null" }]
+				},
 				"formatter": {
 					"description": "HTML formatter options",
 					"anyOf": [
diff --git a/xtask/codegen/html.ungram b/xtask/codegen/html.ungram
index ea7aa639c5..f8c0045d65 100644
--- a/xtask/codegen/html.ungram
+++ b/xtask/codegen/html.ungram
@@ -144,9 +144,12 @@ AnyAstroFrontmatterElement =
 
 AstroFrontmatterElement =
 	l_fence: '---'
-	content: 'html_literal'?
+	content: AstroEmbeddedContent
 	r_fence: '---'
 
+AstroEmbeddedContent =
+	content: 'html_literal'?
+
 // ==================================
 // Attributes
 // ==================================
diff --git a/xtask/codegen/src/html_kinds_src.rs b/xtask/codegen/src/html_kinds_src.rs
index e0b58e6453..22dd5a1c9c 100644
--- a/xtask/codegen/src/html_kinds_src.rs
+++ b/xtask/codegen/src/html_kinds_src.rs
@@ -31,6 +31,7 @@ pub const HTML_KINDS_SRC: KindsSrc = KindsSrc {
         "HTML_SELF_CLOSING_TAG",
         "HTML_ELEMENT",
         "ASTRO_FRONTMATTER_ELEMENT",
+        "ASTRO_EMBEDDED_CONTENT",
         "HTML_OPENING_ELEMENT",
         "HTML_CLOSING_ELEMENT",
         "HTML_SELF_CLOSING_ELEMENT",
diff --git a/xtask/rules_check/src/lib.rs b/xtask/rules_check/src/lib.rs
index d4a48da6f6..03077a85cc 100644
--- a/xtask/rules_check/src/lib.rs
+++ b/xtask/rules_check/src/lib.rs
@@ -405,8 +405,8 @@ fn assert_lint(
                 });
             }
         }
-        DocumentFileSource::Html(..) => {
-            let parse = biome_html_parser::parse_html(code, HtmlParseOptions::default());
+        DocumentFileSource::Html(source) => {
+            let parse = biome_html_parser::parse_html(code, HtmlParseOptions::from(&source));
 
             if parse.has_errors() {
                 for diag in parse.into_diagnostics() {
