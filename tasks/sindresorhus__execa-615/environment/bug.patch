diff --git a/index.d.ts b/index.d.ts
index c1cec9b..9a5ffd2 100644
--- a/index.d.ts
+++ b/index.d.ts
@@ -1,6 +1,6 @@
 import {type Buffer} from 'node:buffer';
 import {type ChildProcess} from 'node:child_process';
-import {type Stream, type Readable, type Writable} from 'node:stream';
+import {type Stream, type Readable as ReadableStream, type Writable as WritableStream} from 'node:stream';
 
 export type StdioOption =
 	| 'pipe'
@@ -17,8 +17,7 @@ export type StdinOption =
 	| Iterable<string | Uint8Array>
 	| AsyncIterable<string | Uint8Array>
 	| URL
-	| string
-	| ReadableStream;
+	| string;
 
 type EncodingOption =
   | 'utf8'
@@ -94,7 +93,7 @@ export type CommonOptions<EncodingType extends EncodingOption = DefaultEncodingO
 	/**
 	Same options as [`stdio`](https://nodejs.org/dist/latest-v6.x/docs/api/child_process.html#child_process_options_stdio).
 
-	It can also be a file path, a file URL, a web stream ([`ReadableStream`](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream)) an [`Iterable`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#the_iterable_protocol) or an [`AsyncIterable`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#the_async_iterator_and_async_iterable_protocols), providing neither [`execaSync()`](#execasyncfile-arguments-options), the [`input` option](#input) nor the [`inputFile` option](#inputfile) is used. If the file path is relative, it must start with `.`.
+	It can also be a file path, a file URL, an [`Iterable`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#the_iterable_protocol) or an [`AsyncIterable`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#the_async_iterator_and_async_iterable_protocols), providing neither [`execaSync()`](#execasyncfile-arguments-options), the [`input` option](#input) nor the [`inputFile` option](#inputfile) is used. If the file path is relative, it must start with `.`.
 
 	@default `inherit` with `$`, `pipe` otherwise
 	*/
@@ -292,7 +291,7 @@ export type Options<EncodingType extends EncodingOption = DefaultEncodingOption>
 
 	If the input is a file, use the `inputFile` option instead.
 	*/
-	readonly input?: string | Uint8Array | Readable;
+	readonly input?: string | Uint8Array | ReadableStream;
 
 	/**
 	Use a file as input to the the `stdin` of your binary.
@@ -489,7 +488,7 @@ export type ExecaChildPromise<StdoutStderrType extends StdoutStderrAll> = {
 		- the `all` option is `false` (the default value)
 		- both `stdout` and `stderr` options are set to [`'inherit'`, `'ipc'`, `Stream` or `integer`](https://nodejs.org/dist/latest-v6.x/docs/api/child_process.html#child_process_options_stdio)
 	*/
-	all?: Readable;
+	all?: ReadableStream;
 
 	catch<ResultType = never>(
 		onRejected?: (reason: ExecaError<StdoutStderrType>) => ResultType | PromiseLike<ResultType>
@@ -516,7 +515,7 @@ export type ExecaChildPromise<StdoutStderrType extends StdoutStderrAll> = {
 	The `stdout` option] must be kept as `pipe`, its default value.
 	*/
 	pipeStdout?<Target extends ExecaChildPromise<StdoutStderrAll>>(target: Target): Target;
-	pipeStdout?(target: Writable | string): ExecaChildProcess<StdoutStderrType>;
+	pipeStdout?(target: WritableStream | string): ExecaChildProcess<StdoutStderrType>;
 
 	/**
 	Like `pipeStdout()` but piping the child process's `stderr` instead.
@@ -524,7 +523,7 @@ export type ExecaChildPromise<StdoutStderrType extends StdoutStderrAll> = {
 	The `stderr` option must be kept as `pipe`, its default value.
 	*/
 	pipeStderr?<Target extends ExecaChildPromise<StdoutStderrAll>>(target: Target): Target;
-	pipeStderr?(target: Writable | string): ExecaChildProcess<StdoutStderrType>;
+	pipeStderr?(target: WritableStream | string): ExecaChildProcess<StdoutStderrType>;
 
 	/**
 	Combines both `pipeStdout()` and `pipeStderr()`.
@@ -532,7 +531,7 @@ export type ExecaChildPromise<StdoutStderrType extends StdoutStderrAll> = {
 	Either the `stdout` option or the `stderr` option must be kept as `pipe`, their default value. Also, the `all` option must be set to `true`.
 	*/
 	pipeAll?<Target extends ExecaChildPromise<StdoutStderrAll>>(target: Target): Target;
-	pipeAll?(target: Writable | string): ExecaChildProcess<StdoutStderrType>;
+	pipeAll?(target: WritableStream | string): ExecaChildProcess<StdoutStderrType>;
 };
 
 export type ExecaChildProcess<StdoutStderrType extends StdoutStderrAll = string> = ChildProcess &
diff --git a/index.test-d.ts b/index.test-d.ts
index 7016a21..34c1fe0 100644
--- a/index.test-d.ts
+++ b/index.test-d.ts
@@ -3,7 +3,7 @@ import {Buffer} from 'node:buffer';
 // `process.stdin`, `process.stderr`, and `process.stdout`
 // to get treated as `any` by `@typescript-eslint/no-unsafe-assignment`.
 import * as process from 'node:process';
-import {type Readable} from 'node:stream';
+import {type Readable as ReadableStream} from 'node:stream';
 import {createWriteStream} from 'node:fs';
 import {expectType, expectError, expectAssignable} from 'tsd';
 import {
@@ -23,7 +23,7 @@ import {
 try {
 	const execaPromise = execa('unicorns');
 	execaPromise.cancel();
-	expectType<Readable | undefined>(execaPromise.all);
+	expectType<ReadableStream | undefined>(execaPromise.all);
 
 	const execaBufferPromise = execa('unicorns', {encoding: 'buffer'});
 	const writeStream = createWriteStream('output.txt');
@@ -158,7 +158,6 @@ execa('unicorns', {stdin: 'ipc'});
 execa('unicorns', {stdin: 'ignore'});
 execa('unicorns', {stdin: 'inherit'});
 execa('unicorns', {stdin: process.stdin});
-execa('unicorns', {stdin: new ReadableStream()});
 execa('unicorns', {stdin: ['']});
 execa('unicorns', {stdin: [new Uint8Array(0)]});
 execa('unicorns', {stdin: stringGenerator()});
diff --git a/lib/stdio.js b/lib/stdio.js
index 5803083..49817b3 100644
--- a/lib/stdio.js
+++ b/lib/stdio.js
@@ -1,7 +1,7 @@
 import {createReadStream, readFileSync} from 'node:fs';
 import {isAbsolute} from 'node:path';
 import {Readable} from 'node:stream';
-import {isStream as isNodeStream} from 'is-stream';
+import {isStream} from 'is-stream';
 
 const aliases = ['stdin', 'stdout', 'stderr'];
 
@@ -9,8 +9,7 @@ const arrifyStdio = (stdio = []) => Array.isArray(stdio) ? stdio : [stdio, stdio
 
 const isIterableStdin = stdinOption => typeof stdinOption === 'object'
 	&& stdinOption !== null
-	&& !isNodeStream(stdinOption)
-	&& !isReadableStream(stdinOption)
+	&& !isStream(stdinOption)
 	&& (typeof stdinOption[Symbol.asyncIterator] === 'function' || typeof stdinOption[Symbol.iterator] === 'function');
 
 const getIterableStdin = stdioArray => isIterableStdin(stdioArray[0])
@@ -26,13 +25,10 @@ const stringIsFilePath = stdioOption => stdioOption.startsWith('.') || isAbsolut
 const isFilePath = stdioOption => typeof stdioOption === 'string' && stringIsFilePath(stdioOption);
 const isUnknownStdioString = stdioOption => typeof stdioOption === 'string' && !stringIsFilePath(stdioOption) && !KNOWN_STDIO.has(stdioOption);
 
-const isReadableStream = stdioOption => Object.prototype.toString.call(stdioOption) === '[object ReadableStream]';
-
 // Check whether the `stdin` option results in `spawned.stdin` being `undefined`.
 // We use a deny list instead of an allow list to be forward compatible with new options.
 const cannotPipeStdio = stdioOption => NO_PIPE_STDIO.has(stdioOption)
-	|| isNodeStream(stdioOption)
-	|| isReadableStream(stdioOption)
+	|| isStream(stdioOption)
 	|| typeof stdioOption === 'number'
 	|| isIterableStdin(stdioOption)
 	|| isFileUrl(stdioOption)
@@ -76,10 +72,6 @@ const getStdioStreams = (stdioArray, {input, inputFile}) => {
 		return {stdinStream: Readable.from(iterableStdin)};
 	}
 
-	if (isReadableStream(stdioArray[0])) {
-		return {stdinStream: Readable.fromWeb(stdioArray[0])};
-	}
-
 	if (isFileUrl(stdioArray[0]) || isFilePath(stdioArray[0])) {
 		return {stdinStream: createReadStream(stdioArray[0])};
 	}
@@ -92,7 +84,7 @@ const getStdioStreams = (stdioArray, {input, inputFile}) => {
 		return {};
 	}
 
-	if (isNodeStream(input)) {
+	if (isStream(input)) {
 		return {stdinStream: input};
 	}
 
@@ -144,11 +136,7 @@ const validateInputOptionsSync = (stdioArray, input) => {
 		throw new TypeError('The `stdin` option cannot be an iterable in sync mode');
 	}
 
-	if (isReadableStream(stdioArray[0])) {
-		throw new TypeError('The `stdin` option cannot be a stream in sync mode');
-	}
-
-	if (isNodeStream(input)) {
+	if (isStream(input)) {
 		throw new TypeError('The `input` option cannot be a stream in sync mode');
 	}
 };
diff --git a/readme.md b/readme.md
index 4d90328..0044b73 100644
--- a/readme.md
+++ b/readme.md
@@ -559,12 +559,12 @@ If the input is not a file, use the [`input` option](#input) instead.
 
 #### stdin
 
-Type: `string | number | stream.Readable | ReadableStream | undefined | URL | Iterable<string | Uint8Array> | AsyncIterable<string | Uint8Array>`\
+Type: `string | number | Stream | undefined | URL | Iterable<string | Uint8Array> | AsyncIterable<string | Uint8Array>`\
 Default: `inherit` with [`$`](#command), `pipe` otherwise
 
 Same options as [`stdio`](https://nodejs.org/dist/latest-v6.x/docs/api/child_process.html#child_process_options_stdio).
 
-It can also be a file path, a file URL, a web stream ([`ReadableStream`](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream)) an [`Iterable`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#the_iterable_protocol) or an [`AsyncIterable`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#the_async_iterator_and_async_iterable_protocols), providing neither [`execaSync()`](#execasyncfile-arguments-options), the [`input` option](#input) nor the [`inputFile` option](#inputfile) is used. If the file path is relative, it must start with `.`.
+It can also be a file path, a file URL, an [`Iterable`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#the_iterable_protocol) or an [`AsyncIterable`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#the_async_iterator_and_async_iterable_protocols), providing neither [`execaSync()`](#execasyncfile-arguments-options), the [`input` option](#input) nor the [`inputFile` option](#inputfile) is used. If the file path is relative, it must start with `.`.
 
 #### stdout
 
diff --git a/test/stream.js b/test/stream.js
index 914c914..e04e91c 100644
--- a/test/stream.js
+++ b/test/stream.js
@@ -212,7 +212,7 @@ test('input option can be a Buffer', async t => {
 	t.is(stdout, 'testing12');
 });
 
-test('input can be a Node.js Readable', async t => {
+test('input can be a Stream', async t => {
 	const stream = new Stream.PassThrough();
 	stream.write('howdy');
 	stream.end();
@@ -220,7 +220,7 @@ test('input can be a Node.js Readable', async t => {
 	t.is(stdout, 'howdy');
 });
 
-test('input option cannot be a Node.js Readable when stdin is set', t => {
+test('input option cannot be a Stream when stdin is set', t => {
 	t.throws(() => {
 		execa('stdin.js', {input: new Stream.PassThrough(), stdin: 'ignore'});
 	}, {message: /`input` and `stdin` options/});
@@ -231,26 +231,6 @@ test('input option can be used with $', async t => {
 	t.is(stdout, 'foobar');
 });
 
-test('stdin can be a ReadableStream', async t => {
-	const stdin = Stream.Readable.toWeb(Stream.Readable.from('howdy'));
-	const {stdout} = await execa('stdin.js', {stdin});
-	t.is(stdout, 'howdy');
-});
-
-test('stdin cannot be a ReadableStream when input is used', t => {
-	const stdin = Stream.Readable.toWeb(Stream.Readable.from('howdy'));
-	t.throws(() => {
-		execa('stdin.js', {stdin, input: 'foobar'});
-	}, {message: /`input` and `stdin` options/});
-});
-
-test('stdin cannot be a ReadableStream when inputFile is used', t => {
-	const stdin = Stream.Readable.toWeb(Stream.Readable.from('howdy'));
-	t.throws(() => {
-		execa('stdin.js', {stdin, inputFile: 'dummy.txt'});
-	}, {message: /`inputFile` and `stdin` options/});
-});
-
 test('stdin can be a file URL', async t => {
 	const inputFile = tempfile();
 	fs.writeFileSync(inputFile, 'howdy');
@@ -354,17 +334,13 @@ test('opts.stdout:ignore - stdout will not collect data', async t => {
 	t.is(stdout, undefined);
 });
 
-test('input cannot be a stream in sync mode', t => {
-	t.throws(() => {
-		execaSync('stdin.js', {input: new Stream.PassThrough()});
-	}, {message: /The `input` option cannot be a stream in sync mode/});
-});
-
-test('stdin cannot be a ReadableStream in sync mode', t => {
-	const stdin = Stream.Readable.toWeb(Stream.Readable.from('howdy'));
-	t.throws(() => {
-		execaSync('stdin.js', {stdin});
-	}, {message: /The `stdin` option cannot be a stream in sync mode/});
+test('helpful error trying to provide an input stream in sync mode', t => {
+	t.throws(
+		() => {
+			execaSync('stdin.js', {input: new Stream.PassThrough()});
+		},
+		{message: /The `input` option cannot be a stream in sync mode/},
+	);
 });
 
 test('stdin can be a file URL - sync', t => {
