diff --git a/.changeset/new-gorillas-visit.md b/.changeset/new-gorillas-visit.md
new file mode 100644
index 0000000000..883a7b3c9f
--- /dev/null
+++ b/.changeset/new-gorillas-visit.md
@@ -0,0 +1,5 @@
+---
+"xstate": major
+---
+
+Removed `State['transitions']`.
diff --git a/packages/core/src/State.ts b/packages/core/src/State.ts
index 80501fe083..1e3746ffce 100644
--- a/packages/core/src/State.ts
+++ b/packages/core/src/State.ts
@@ -17,8 +17,7 @@ import type {
   PersistedMachineState,
   Prop,
   StateConfig,
-  StateValue,
-  TransitionDefinition
+  StateValue
 } from './types.ts';
 import { flatten, isString, matchesState } from './utils.ts';
 
@@ -70,10 +69,6 @@ export class State<
    * The enabled state nodes representative of the state value.
    */
   public configuration: Array<StateNode<TContext, TEvent>>;
-  /**
-   * The transition definitions that resulted in this state.
-   */
-  public transitions: Array<TransitionDefinition<TContext, TEvent>>;
   /**
    * An object mapping actor names to spawned/invoked actors.
    */
@@ -119,7 +114,6 @@ export class State<
         context,
         meta: undefined,
         configuration: Array.from(configuration),
-        transitions: [],
         children: {}
       },
       machine
@@ -143,7 +137,6 @@ export class State<
     this.configuration =
       config.configuration ??
       Array.from(getConfiguration(getStateNodes(machine.root, config.value)));
-    this.transitions = config.transitions as any;
     this.children = config.children;
 
     this.value = getStateValue(machine.root, this.configuration);
@@ -176,7 +169,7 @@ export class State<
   }
 
   public toJSON() {
-    const { configuration, transitions, tags, machine, ...jsonValues } = this;
+    const { configuration, tags, machine, ...jsonValues } = this;
 
     return { ...jsonValues, tags: Array.from(tags), meta: this.meta };
   }
@@ -263,8 +256,7 @@ export function cloneState<TState extends AnyState>(
 export function getPersistedState<TState extends AnyState>(
   state: TState
 ): PersistedMachineState<TState> {
-  const { configuration, transitions, tags, machine, children, ...jsonValues } =
-    state;
+  const { configuration, tags, machine, children, ...jsonValues } = state;
 
   const childrenJson: Partial<PersistedMachineState<any>['children']> = {};
 
diff --git a/packages/core/src/stateUtils.ts b/packages/core/src/stateUtils.ts
index e9c5602f59..ec11633258 100644
--- a/packages/core/src/stateUtils.ts
+++ b/packages/core/src/stateUtils.ts
@@ -1039,9 +1039,7 @@ export function microstep<
   const mutConfiguration = new Set(currentState.configuration);
 
   if (!currentState._initial && !willTransition) {
-    const inertState = cloneState(currentState, {
-      transitions: []
-    });
+    const inertState = cloneState(currentState, {});
 
     inertState.changed = false;
     return inertState;
@@ -1545,15 +1543,6 @@ export function macrostep(
     let enabledTransitions = selectEventlessTransitions(nextState, nextEvent);
 
     if (!enabledTransitions.length) {
-      // TODO: this is a bit of a hack, we need to review this
-      // this matches the behavior from v4 for eventless transitions
-      // where for `hasAlwaysTransitions` we were always trying to resolve with a NULL event
-      // and if a transition was not selected the `state.transitions` stayed empty
-      // without this we get into an infinite loop in the dieHard test in `@xstate/test` for the `simplePathsTo`
-      if (nextState.configuration.some((state) => state.always)) {
-        nextState.transitions = [];
-      }
-
       if (!nextState._internalQueue.length) {
         break;
       } else {
diff --git a/packages/xstate-test/src/machine.ts b/packages/xstate-test/src/machine.ts
index b502c4eb20..10cb42205b 100644
--- a/packages/xstate-test/src/machine.ts
+++ b/packages/xstate-test/src/machine.ts
@@ -9,7 +9,8 @@ import {
   StateFrom,
   TypegenConstraint,
   TypegenDisabled,
-  MachineContext
+  MachineContext,
+  StateValue
 } from 'xstate';
 import { TestModel } from './TestModel.ts';
 import {
@@ -40,15 +41,40 @@ export function createTestMachine<
   return createMachine(config, options as any);
 }
 
+function stateValuesEqual(
+  a: StateValue | undefined,
+  b: StateValue | undefined
+): boolean {
+  if (a === b) {
+    return true;
+  }
+
+  if (a === undefined || b === undefined) {
+    return false;
+  }
+
+  if (typeof a === 'string' || typeof b === 'string') {
+    return a === b;
+  }
+
+  const aKeys = Object.keys(a);
+  const bKeys = Object.keys(b);
+
+  return (
+    aKeys.length === bKeys.length &&
+    aKeys.every((key) => stateValuesEqual(a[key], b[key]))
+  );
+}
+
 function serializeMachineTransition(
   state: AnyState,
   event: AnyEventObject | undefined,
   prevState: AnyState | undefined,
   { serializeEvent }: { serializeEvent: (event: AnyEventObject) => string }
 ): string {
-  // Only consider the transition via the serialized event if there actually
-  // was a defined transition for the event
-  if (!event || state.transitions.length === 0) {
+  // TODO: the stateValuesEqual check here is very likely not exactly correct
+  // but I'm not sure what the correct check is and what this is trying to do
+  if (!event || (prevState && stateValuesEqual(prevState.value, state.value))) {
     return '';
   }
 
