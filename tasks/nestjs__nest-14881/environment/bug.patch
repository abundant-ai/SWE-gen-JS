diff --git a/package-lock.json b/package-lock.json
index ead67f753..f5297885a 100644
Binary files a/package-lock.json and b/package-lock.json differ
diff --git a/package.json b/package.json
index 5d5f399d6..4a6fd0e3a 100644
--- a/package.json
+++ b/package.json
@@ -67,7 +67,6 @@
     "express": "5.1.0",
     "fast-json-stringify": "6.0.1",
     "fast-safe-stringify": "2.1.1",
-    "file-type": "20.4.1",
     "iterare": "1.2.1",
     "object-hash": "3.0.0",
     "path-to-regexp": "8.2.0",
diff --git a/packages/common/package.json b/packages/common/package.json
index 90c5134fc..6111d9bec 100644
--- a/packages/common/package.json
+++ b/packages/common/package.json
@@ -26,8 +26,7 @@
     "class-transformer": "*",
     "class-validator": "*",
     "reflect-metadata": "^0.1.12 || ^0.2.0",
-    "rxjs": "^7.1.0",
-    "file-type": "20.4.1"
+    "rxjs": "^7.1.0"
   },
   "peerDependenciesMeta": {
     "class-validator": {
diff --git a/packages/common/pipes/file/file-type.validator.ts b/packages/common/pipes/file/file-type.validator.ts
index 47139064f..a47f134e9 100644
--- a/packages/common/pipes/file/file-type.validator.ts
+++ b/packages/common/pipes/file/file-type.validator.ts
@@ -3,19 +3,14 @@ import { IFile } from './interfaces';
 
 export type FileTypeValidatorOptions = {
   fileType: string | RegExp;
-
-  /**
-   * If `true`, the validator will skip the magic numbers validation.
-   * This can be useful when you can't identify some files as there are no common magic numbers available for some file types.
-   * @default false
-   */
-  skipMagicNumbersValidation?: boolean;
 };
 
 /**
- * Defines the built-in FileTypeValidator. It validates incoming files by examining
- * their magic numbers using the file-type package, providing more reliable file type validation
- * than just checking the mimetype string.
+ * Defines the built-in FileType File Validator. It validates incoming files mime-type
+ * matching a string or a regular expression. Note that this validator uses a naive strategy
+ * to check the mime-type and could be fooled if the client provided a file with renamed extension.
+ * (for instance, renaming a 'malicious.bat' to 'malicious.jpeg'). To handle such security issues
+ * with more reliability, consider checking against the file's [magic-numbers](https://en.wikipedia.org/wiki/Magic_number_%28programming%29)
  *
  * @see [File Validators](https://docs.nestjs.com/techniques/file-upload#validators)
  *
@@ -32,35 +27,15 @@ export class FileTypeValidator extends FileValidator<
     return `Validation failed (expected type is ${this.validationOptions.fileType})`;
   }
 
-  async isValid(file?: IFile): Promise<boolean> {
+  isValid(file?: IFile): boolean {
     if (!this.validationOptions) {
       return true;
     }
 
-    const isFileValid = !!file && 'mimetype' in file;
-
-    if (this.validationOptions.skipMagicNumbersValidation) {
-      return (
-        isFileValid && !!file.mimetype.match(this.validationOptions.fileType)
-      );
-    }
-
-    if (!isFileValid || !file.buffer) {
-      return false;
-    }
-
-    try {
-      const { fileTypeFromBuffer } = (await eval(
-        'import ("file-type")',
-      )) as typeof import('file-type');
-
-      const fileType = await fileTypeFromBuffer(file.buffer);
-
-      return (
-        !!fileType && !!fileType.mime.match(this.validationOptions.fileType)
-      );
-    } catch {
-      return false;
-    }
+    return (
+      !!file &&
+      'mimetype' in file &&
+      !!file.mimetype.match(this.validationOptions.fileType)
+    );
   }
 }
diff --git a/packages/common/pipes/file/interfaces/file.interface.ts b/packages/common/pipes/file/interfaces/file.interface.ts
index 418fd8be8..37218734f 100644
--- a/packages/common/pipes/file/interfaces/file.interface.ts
+++ b/packages/common/pipes/file/interfaces/file.interface.ts
@@ -1,5 +1,4 @@
 export interface IFile {
   mimetype: string;
   size: number;
-  buffer?: Buffer;
 }
diff --git a/packages/common/test/pipes/file/file-type.validator.spec.ts b/packages/common/test/pipes/file/file-type.validator.spec.ts
index 43e0831ad..8ac3e971a 100644
--- a/packages/common/test/pipes/file/file-type.validator.spec.ts
+++ b/packages/common/test/pipes/file/file-type.validator.spec.ts
@@ -1,195 +1,89 @@
 import { expect } from 'chai';
-import { IFile } from '../../../../common/pipes/file/interfaces';
 import { FileTypeValidator } from '../../../pipes';
 
 describe('FileTypeValidator', () => {
   describe('isValid', () => {
-    it('should return true when the file buffer matches the specified type', async () => {
+    it('should return true when the file mimetype is the same as the specified', () => {
       const fileTypeValidator = new FileTypeValidator({
         fileType: 'image/jpeg',
       });
 
-      const jpegBuffer = Buffer.from([
-        0xff, 0xd8, 0xff, 0xe0, 0x00, 0x10, 0x4a, 0x46, 0x49, 0x46,
-      ]);
       const requestFile = {
         mimetype: 'image/jpeg',
-        buffer: jpegBuffer,
-      } as IFile;
+      } as any;
 
-      expect(await fileTypeValidator.isValid(requestFile)).to.equal(true);
+      expect(fileTypeValidator.isValid(requestFile)).to.equal(true);
     });
 
-    it('should return true when the file buffer matches the specified file extension', async () => {
+    it('should return true when the file mimetype ends with the specified option type', () => {
       const fileTypeValidator = new FileTypeValidator({
         fileType: 'jpeg',
       });
 
-      const jpegBuffer = Buffer.from([
-        0xff, 0xd8, 0xff, 0xe0, 0x00, 0x10, 0x4a, 0x46, 0x49, 0x46,
-      ]);
       const requestFile = {
         mimetype: 'image/jpeg',
-        buffer: jpegBuffer,
-      } as IFile;
-      expect(await fileTypeValidator.isValid(requestFile)).to.equal(true);
-    });
-
-    it('should return true when the file buffer matches the specified regexp', async () => {
-      const fileTypeValidator = new FileTypeValidator({
-        fileType: /^image\//,
-      });
-
-      const jpegBuffer = Buffer.from([
-        0xff, 0xd8, 0xff, 0xe0, 0x00, 0x10, 0x4a, 0x46, 0x49, 0x46,
-      ]);
-      const requestFile = {
-        mimetype: 'image/jpeg',
-        buffer: jpegBuffer,
-      } as IFile;
-
-      expect(await fileTypeValidator.isValid(requestFile)).to.equal(true);
-    });
-
-    it('should return false when the file buffer does not match the specified type', async () => {
-      const fileTypeValidator = new FileTypeValidator({
-        fileType: 'image/jpeg',
-      });
-
-      const pngBuffer = Buffer.from([
-        0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a,
-      ]);
-      const requestFile = {
-        mimetype: 'image/jpeg', // Spoofed mimetype
-        buffer: pngBuffer,
-      } as IFile;
-
-      expect(await fileTypeValidator.isValid(requestFile)).to.equal(false);
-    });
+      } as any;
 
-    it('should return false when the file buffer does not match the specified file extension', async () => {
-      const fileTypeValidator = new FileTypeValidator({
-        fileType: 'jpeg',
-      });
-
-      const pngBuffer = Buffer.from([
-        0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a,
-      ]);
-      const requestFile = {
-        mimetype: 'image/png',
-        buffer: pngBuffer,
-      } as IFile;
-
-      expect(await fileTypeValidator.isValid(requestFile)).to.equal(false);
+      expect(fileTypeValidator.isValid(requestFile)).to.equal(true);
     });
 
-    it('should return false when no buffer is provided', async () => {
+    it('should return true when the file mimetype matches the specified regexp', () => {
       const fileTypeValidator = new FileTypeValidator({
-        fileType: 'image/jpeg',
+        fileType: /word/,
       });
 
       const requestFile = {
-        mimetype: 'image/jpeg',
-      } as IFile;
+        mimetype: 'application/msword',
+      } as any;
 
-      expect(await fileTypeValidator.isValid(requestFile)).to.equal(false);
+      expect(fileTypeValidator.isValid(requestFile)).to.equal(true);
     });
 
-    it('should return false when no file is provided', async () => {
-      const fileTypeValidator = new FileTypeValidator({
-        fileType: 'image/jpeg',
-      });
-
-      expect(await fileTypeValidator.isValid()).to.equal(false);
-    });
-
-    it('should return false when no buffer is provided', async () => {
+    it('should return false when the file mimetype is different from the specified', () => {
       const fileTypeValidator = new FileTypeValidator({
         fileType: 'image/jpeg',
       });
 
       const requestFile = {
-        mimetype: 'image/jpeg',
-      } as IFile;
+        mimetype: 'image/png',
+      } as any;
 
-      expect(await fileTypeValidator.isValid(requestFile)).to.equal(false);
+      expect(fileTypeValidator.isValid(requestFile)).to.equal(false);
     });
 
-    it('should return true when the file buffer matches the specified regexp', async () => {
+    it('should return false when the file mimetype does not match the provided regexp', () => {
       const fileTypeValidator = new FileTypeValidator({
-        fileType: /^image\//,
+        fileType: /mp4/,
       });
 
-      const jpegBuffer = Buffer.from([
-        0xff, 0xd8, 0xff, 0xe0, 0x00, 0x10, 0x4a, 0x46, 0x49, 0x46,
-      ]);
       const requestFile = {
-        mimetype: 'image/jpeg',
-        buffer: jpegBuffer,
-      } as IFile;
-
-      expect(await fileTypeValidator.isValid(requestFile)).to.equal(true);
-    });
-
-    it('should return true when no validation options are provided', async () => {
-      const fileTypeValidator = new FileTypeValidator({} as any);
-      const jpegBuffer = Buffer.from([
-        0xff, 0xd8, 0xff, 0xe0, 0x00, 0x10, 0x4a, 0x46, 0x49, 0x46,
-      ]);
-      const requestFile = {
-        mimetype: 'image/jpeg',
-        buffer: jpegBuffer,
-      } as IFile;
+        mimetype: 'image/png',
+      } as any;
 
-      expect(await fileTypeValidator.isValid(requestFile)).to.equal(true);
+      expect(fileTypeValidator.isValid(requestFile)).to.equal(false);
     });
 
-    it('should skip magic numbers validation when the skipMagicNumbersValidation is true', async () => {
+    it('should return false when the file mimetype was not provided', () => {
       const fileTypeValidator = new FileTypeValidator({
         fileType: 'image/jpeg',
-        skipMagicNumbersValidation: true,
       });
 
-      const requestFile = {
-        mimetype: 'image/jpeg',
-      } as IFile;
+      const requestFile = {} as any;
 
-      expect(await fileTypeValidator.isValid(requestFile)).to.equal(true);
+      expect(fileTypeValidator.isValid(requestFile)).to.equal(false);
     });
 
-    it('should return false when the file buffer does not match any known type', async () => {
-      const fileTypeValidator = new FileTypeValidator({
-        fileType: 'unknown/type',
-      });
-
-      const unknownBuffer = Buffer.from([
-        0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
-      ]);
-      const requestFile = {
-        mimetype: 'unknown/type',
-        buffer: unknownBuffer,
-      } as IFile;
-
-      expect(await fileTypeValidator.isValid(requestFile)).to.equal(false);
-    });
-
-    it('should return false when the buffer is empty', async () => {
+    it('should return false when no file provided', () => {
       const fileTypeValidator = new FileTypeValidator({
         fileType: 'image/jpeg',
       });
 
-      const emptyBuffer = Buffer.from([]);
-      const requestFile = {
-        mimetype: 'image/jpeg',
-        buffer: emptyBuffer,
-      } as IFile;
-
-      expect(await fileTypeValidator.isValid(requestFile)).to.equal(false);
+      expect(fileTypeValidator.isValid()).to.equal(false);
     });
   });
 
   describe('buildErrorMessage', () => {
-    it('should return a string with the format "Validation failed (expected type is #fileType)"', async () => {
+    it('should return a string with the format "Validation failed (expected type is #fileType)"', () => {
       const fileType = 'image/jpeg';
       const fileTypeValidator = new FileTypeValidator({
         fileType,
@@ -200,39 +94,17 @@ describe('FileTypeValidator', () => {
       );
     });
 
-    it('should include the file type in the error message when a file is provided', async () => {
+    it('should include the file type in the error message when a file is provided', () => {
       const currentFileType = 'image/png';
       const fileType = 'image/jpeg';
       const fileTypeValidator = new FileTypeValidator({
         fileType,
       });
 
-      const file = { mimetype: currentFileType } as IFile;
-
-      expect(fileTypeValidator.buildErrorMessage(file)).to.equal(
-        `Validation failed (detected file type is ${currentFileType}, expected type is ${fileType})`,
-      );
-    });
-
-    it('should handle regexp file type in error message', async () => {
-      const fileTypeValidator = new FileTypeValidator({
-        fileType: /^image\//,
-      });
-      const file = { mimetype: 'application/pdf' } as IFile;
-
-      expect(fileTypeValidator.buildErrorMessage(file)).to.equal(
-        `Validation failed (detected file type is application/pdf, expected type is /^image\\//)`,
-      );
-    });
-
-    it('should handle file extension in error message', async () => {
-      const fileTypeValidator = new FileTypeValidator({
-        fileType: 'jpeg',
-      });
-      const file = { mimetype: 'image/png' } as IFile;
+      const file = { mimetype: currentFileType } as any;
 
       expect(fileTypeValidator.buildErrorMessage(file)).to.equal(
-        'Validation failed (detected file type is image/png, expected type is jpeg)',
+        `Validation failed (current file type is ${currentFileType}, expected type is ${fileType})`,
       );
     });
   });
diff --git a/packages/common/test/pipes/file/parse-file-pipe.builder.spec.ts b/packages/common/test/pipes/file/parse-file-pipe.builder.spec.ts
index 84c2752a4..784cea3de 100644
--- a/packages/common/test/pipes/file/parse-file-pipe.builder.spec.ts
+++ b/packages/common/test/pipes/file/parse-file-pipe.builder.spec.ts
@@ -1,9 +1,9 @@
 import { expect } from 'chai';
 import {
+  FileTypeValidator,
   FileValidator,
   MaxFileSizeValidator,
   ParseFilePipeBuilder,
-  FileTypeValidator,
 } from '../../../pipes';
 
 describe('ParseFilePipeBuilder', () => {
diff --git a/sample/29-file-upload/e2e/app/app.e2e-spec.ts b/sample/29-file-upload/e2e/app/app.e2e-spec.ts
index 415bf033b..6f8bc9034 100644
--- a/sample/29-file-upload/e2e/app/app.e2e-spec.ts
+++ b/sample/29-file-upload/e2e/app/app.e2e-spec.ts
@@ -32,14 +32,14 @@ describe('E2E FileTest', () => {
   it('should allow for file uploads that pass validation', async () => {
     return request(app.getHttpServer())
       .post('/file/pass-validation')
-      .attach('file', './resources/nestjs.jpg')
+      .attach('file', './package.json')
       .field('name', 'test')
       .expect(201)
       .expect({
         body: {
           name: 'test',
         },
-        file: readFileSync('./resources/nestjs.jpg').toString(),
+        file: readFileSync('./package.json').toString(),
       });
   });
 
diff --git a/sample/29-file-upload/package.json b/sample/29-file-upload/package.json
index 85a1e16ed..0faefaf8a 100644
--- a/sample/29-file-upload/package.json
+++ b/sample/29-file-upload/package.json
@@ -16,7 +16,7 @@
     "test:watch": "jest --watch",
     "test:cov": "jest --coverage",
     "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
-    "test:e2e": "NODE_OPTIONS=\"$NODE_OPTIONS --experimental-vm-modules\" jest --config ./e2e/jest-e2e.json"
+    "test:e2e": "jest --config ./e2e/jest-e2e.json"
   },
   "dependencies": {
     "@nestjs/common": "11.0.14",
diff --git a/sample/29-file-upload/resources/nestjs.jpg b/sample/29-file-upload/resources/nestjs.jpg
deleted file mode 100644
index f538ad571..000000000
Binary files a/sample/29-file-upload/resources/nestjs.jpg and /dev/null differ
diff --git a/sample/29-file-upload/src/app.controller.ts b/sample/29-file-upload/src/app.controller.ts
index 130fb407e..371a1fd69 100644
--- a/sample/29-file-upload/src/app.controller.ts
+++ b/sample/29-file-upload/src/app.controller.ts
@@ -40,7 +40,7 @@ export class AppController {
     @UploadedFile(
       new ParseFilePipeBuilder()
         .addFileTypeValidator({
-          fileType: 'jpeg',
+          fileType: 'json',
         })
         .build({
           fileIsRequired: false,
