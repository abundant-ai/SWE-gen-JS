diff --git a/index.js b/index.js
index 1d00839..2d34fce 100644
--- a/index.js
+++ b/index.js
@@ -173,7 +173,7 @@ const handlePromise = async ({spawned, options, stdioStreamsGroups, originalStre
 
 	const [
 		error,
-		[, exitCode, signal],
+		[exitCode, signal],
 		stdioResults,
 		allResult,
 	] = await getSpawnedResult({spawned, options, context, stdioStreamsGroups, originalStreams, controller});
diff --git a/lib/kill.js b/lib/kill.js
index 8d29a6e..dbe64d3 100644
--- a/lib/kill.js
+++ b/lib/kill.js
@@ -48,8 +48,8 @@ export const normalizeForceKillAfterDelay = forceKillAfterDelay => {
 	return forceKillAfterDelay;
 };
 
-const killAfterTimeout = async (timeout, context, controller) => {
-	await setTimeout(timeout, undefined, {signal: controller.signal});
+const killAfterTimeout = async (timeout, context, {signal}) => {
+	await setTimeout(timeout, undefined, {signal});
 	context.timedOut = true;
 	throw new Error('Timed out');
 };
diff --git a/lib/stream.js b/lib/stream.js
index 4f95599..296d15d 100644
--- a/lib/stream.js
+++ b/lib/stream.js
@@ -1,4 +1,4 @@
-import {addAbortListener} from 'node:events';
+import {once} from 'node:events';
 import {finished} from 'node:stream/promises';
 import {setImmediate} from 'node:timers/promises';
 import getStream, {getStreamAsArrayBuffer, getStreamAsArray} from 'get-stream';
@@ -115,49 +115,49 @@ const waitForCustomStreamsEnd = (stdioStreamsGroups, waitForStream) => stdioStre
 	.filter(({type, value}) => type !== 'native' && !isStandardStream(value))
 	.map(({value}) => waitForStream(value));
 
-// Like `once()` except it never rejects, especially not on `error` event.
-const pEvent = (eventEmitter, eventName, {signal}) => new Promise(resolve => {
-	const listener = (...payload) => {
-		resolve([eventName, ...payload]);
-	};
-
-	eventEmitter.once(eventName, listener);
-	addAbortListener(signal, () => {
-		eventEmitter.removeListener(eventName, listener);
-	});
-});
-
 // Wraps `finished(stream)` to handle the following case:
 //  - When the child process exits, Node.js automatically calls `childProcess.stdin.destroy()`, which we need to ignore.
 //  - However, we still need to throw if `childProcess.stdin.destroy()` is called before child process exit.
-const onFinishedStream = async ([originalStdin], processExitPromise, stream) => {
-	const finishedPromise = finished(stream, {cleanup: true});
-	if (stream !== originalStdin) {
-		await finishedPromise;
-		return;
-	}
-
-	try {
-		await finishedPromise;
-	} catch {
-		await Promise.race([processExitPromise, finishedPromise]);
-	}
+const onFinishedStream = async ([originalStdin], exitPromise, stream) => {
+	await Promise.race([
+		...(stream === originalStdin ? [exitPromise] : []),
+		finished(stream, {cleanup: true}),
+	]);
 };
 
-const throwOnProcessError = async processErrorPromise => {
-	const [, error] = await processErrorPromise;
+const throwOnProcessError = async (spawned, {signal}) => {
+	const [error] = await once(spawned, 'error', {signal});
 	throw error;
 };
 
-// First the `spawn` event is emitted, then `exit`.
-// If the `error` event is emitted:
-//  - before `spawn`: `exit` is never emitted.
-//  - after `spawn`: `exit` is always emitted.
-// We only want to listen to `exit` if it will be emitted, i.e. if `spawn` has been emitted.
-// Therefore, the arguments order of `Promise.race()` is significant.
-const waitForFailedProcess = async (processSpawnPromise, processErrorPromise, processExitPromise) => {
-	const [eventName] = await Promise.race([processSpawnPromise, processErrorPromise]);
-	return eventName === 'spawn' ? processExitPromise : [];
+// If `error` is emitted before `spawn`, `exit` will never be emitted.
+// However, `error` might be emitted after `spawn`, e.g. with the `signal` option.
+// In that case, `exit` will still be emitted.
+// Since the `exit` event contains the signal name, we want to make sure we are listening for it.
+// This function also takes into account the following unlikely cases:
+//  - `exit` being emitted in the same microtask as `spawn`
+//  - `error` being emitted multiple times
+const waitForExit = async spawned => {
+	const [spawnPayload, exitPayload] = await Promise.allSettled([
+		once(spawned, 'spawn'),
+		once(spawned, 'exit'),
+	]);
+
+	if (spawnPayload.status === 'rejected') {
+		return [];
+	}
+
+	return exitPayload.status === 'rejected'
+		? waitForProcessExit(spawned)
+		: exitPayload.value;
+};
+
+const waitForProcessExit = async spawned => {
+	try {
+		return await once(spawned, 'exit');
+	} catch {
+		return waitForProcessExit(spawned);
+	}
 };
 
 // Retrieve result of child process: exit code, signal, error, streams (stdout/stderr/all)
@@ -169,10 +169,8 @@ export const getSpawnedResult = async ({
 	originalStreams,
 	controller,
 }) => {
-	const processSpawnPromise = pEvent(spawned, 'spawn', controller);
-	const processErrorPromise = pEvent(spawned, 'error', controller);
-	const processExitPromise = pEvent(spawned, 'exit', controller);
-	const waitForStream = onFinishedStream.bind(undefined, originalStreams, processExitPromise);
+	const exitPromise = waitForExit(spawned);
+	const waitForStream = onFinishedStream.bind(undefined, originalStreams, exitPromise);
 
 	const stdioPromises = waitForChildStreams({spawned, stdioStreamsGroups, encoding, buffer, maxBuffer, waitForStream});
 	const allPromise = waitForAllStream({spawned, encoding, buffer, maxBuffer, waitForStream});
@@ -183,20 +181,20 @@ export const getSpawnedResult = async ({
 		return await Promise.race([
 			Promise.all([
 				undefined,
-				processExitPromise,
+				exitPromise,
 				Promise.all(stdioPromises),
 				allPromise,
 				...originalPromises,
 				...customStreamsEndPromises,
 			]),
-			throwOnProcessError(processErrorPromise),
+			throwOnProcessError(spawned, controller),
 			...throwOnTimeout(timeout, context, controller),
 		]);
 	} catch (error) {
 		spawned.kill();
 		return Promise.all([
 			error,
-			waitForFailedProcess(processSpawnPromise, processErrorPromise, processExitPromise),
+			exitPromise,
 			Promise.all(stdioPromises.map(stdioPromise => getBufferedData(stdioPromise, encoding))),
 			getBufferedData(allPromise, encoding),
 			Promise.allSettled(originalPromises),
