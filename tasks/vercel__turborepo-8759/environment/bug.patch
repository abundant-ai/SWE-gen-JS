diff --git a/crates/turborepo-api-client/src/lib.rs b/crates/turborepo-api-client/src/lib.rs
index 02863c59ee..e541fca9e7 100644
--- a/crates/turborepo-api-client/src/lib.rs
+++ b/crates/turborepo-api-client/src/lib.rs
@@ -123,16 +123,6 @@ pub struct APIAuth {
     pub team_slug: Option<String>,
 }
 
-impl std::fmt::Debug for APIAuth {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        f.debug_struct("APIAuth")
-            .field("team_id", &self.team_id)
-            .field("token", &"***")
-            .field("team_slug", &self.team_slug)
-            .finish()
-    }
-}
-
 pub fn is_linked(api_auth: &Option<APIAuth>) -> bool {
     api_auth
         .as_ref()
diff --git a/crates/turborepo-lib/src/cli/mod.rs b/crates/turborepo-lib/src/cli/mod.rs
index f4b399b434..7f54a52368 100644
--- a/crates/turborepo-lib/src/cli/mod.rs
+++ b/crates/turborepo-lib/src/cli/mod.rs
@@ -682,8 +682,8 @@ pub struct ExecutionArgs {
     /// Environment variable mode.
     /// Use "loose" to pass the entire existing environment.
     /// Use "strict" to use an allowlist specified in turbo.json.
-    #[clap(long = "env-mode", num_args = 0..=1, default_missing_value = "strict")]
-    pub env_mode: Option<EnvMode>,
+    #[clap(long = "env-mode", default_value = "strict", num_args = 0..=1, default_missing_value = "strict")]
+    pub env_mode: EnvMode,
     /// Use the given selector to specify package(s) to act as
     /// entry points. The syntax mirrors pnpm's syntax, and
     /// additional documentation and examples can be found in
@@ -755,8 +755,8 @@ impl ExecutionArgs {
             );
         }
 
-        if let Some(env_mode) = self.env_mode {
-            telemetry.track_arg_value("env-mode", env_mode, EventType::NonSensitive);
+        if self.env_mode != EnvMode::default() {
+            telemetry.track_arg_value("env-mode", self.env_mode, EventType::NonSensitive);
         }
 
         if let Some(output_logs) = &self.output_logs {
@@ -1443,7 +1443,7 @@ mod test {
             command: Some(Command::Run {
                 execution_args: Box::new(ExecutionArgs {
                     tasks: vec!["build".to_string()],
-                    env_mode: Some(EnvMode::Strict),
+                    env_mode: EnvMode::Strict,
                     ..get_default_execution_args()
                 }),
                 run_args: Box::new(get_default_run_args())
@@ -1452,13 +1452,28 @@ mod test {
         } ;
         "env_mode: not fully-specified"
     )]
+    #[test_case::test_case(
+		&["turbo", "run", "build"],
+        Args {
+            command: Some(Command::Run {
+                execution_args: Box::new(ExecutionArgs {
+                    tasks: vec!["build".to_string()],
+                    env_mode: EnvMode::Strict,
+                    ..get_default_execution_args()
+                }),
+                run_args: Box::new(get_default_run_args())
+            }),
+            ..Args::default()
+		} ;
+        "env_mode: default strict"
+	)]
     #[test_case::test_case(
 		&["turbo", "run", "build", "--env-mode", "loose"],
         Args {
             command: Some(Command::Run {
                 execution_args: Box::new(ExecutionArgs {
                     tasks: vec!["build".to_string()],
-                    env_mode: Some(EnvMode::Loose),
+                    env_mode: EnvMode::Loose,
                     ..get_default_execution_args()
                 }),
                 run_args: Box::new(get_default_run_args())
@@ -1473,7 +1488,7 @@ mod test {
             command: Some(Command::Run {
                 execution_args: Box::new(ExecutionArgs {
                     tasks: vec!["build".to_string()],
-                    env_mode: Some(EnvMode::Strict),
+                    env_mode: EnvMode::Strict,
                     ..get_default_execution_args()
                 }),
                 run_args: Box::new(get_default_run_args())
diff --git a/crates/turborepo-lib/src/opts.rs b/crates/turborepo-lib/src/opts.rs
index 1e31ead1b7..cb109a49f9 100644
--- a/crates/turborepo-lib/src/opts.rs
+++ b/crates/turborepo-lib/src/opts.rs
@@ -2,16 +2,14 @@ use std::{backtrace, backtrace::Backtrace};
 
 use thiserror::Error;
 use turbopath::AnchoredSystemPathBuf;
-use turborepo_api_client::APIAuth;
-use turborepo_cache::{CacheOpts, RemoteCacheOpts};
+use turborepo_cache::CacheOpts;
 
 use crate::{
     cli::{
         Command, DryRunMode, EnvMode, ExecutionArgs, LogOrder, LogPrefix, OutputLogsMode, RunArgs,
     },
-    commands::CommandBase,
-    config::ConfigurationOptions,
     run::task_id::TaskId,
+    Args,
 };
 
 #[derive(Debug, Error)]
@@ -32,8 +30,6 @@ pub enum Error {
     ConcurrencyOutOfBounds(#[backtrace] backtrace::Backtrace, String),
     #[error(transparent)]
     Path(#[from] turbopath::PathError),
-    #[error(transparent)]
-    Config(#[from] crate::config::Error),
 }
 
 #[derive(Debug)]
@@ -80,12 +76,10 @@ impl Opts {
     }
 }
 
-impl Opts {
-    pub fn new(base: &CommandBase) -> Result<Self, Error> {
-        let args = base.args();
-        let config = base.config()?;
-        let api_auth = base.api_auth()?;
+impl<'a> TryFrom<&'a Args> for Opts {
+    type Error = self::Error;
 
+    fn try_from(args: &'a Args) -> Result<Self, Self::Error> {
         let Some(Command::Run {
             run_args,
             execution_args,
@@ -93,12 +87,9 @@ impl Opts {
         else {
             return Err(Error::ExpectedRun(Backtrace::capture()));
         };
-
-        let run_and_execution_args = OptsInputs {
+        let run_and_execution_args = RunAndExecutionArgs {
             run_args: run_args.as_ref(),
             execution_args: execution_args.as_ref(),
-            config,
-            api_auth: &api_auth,
         };
         let run_opts = RunOpts::try_from(run_and_execution_args)?;
         let cache_opts = CacheOpts::from(run_and_execution_args);
@@ -114,12 +105,11 @@ impl Opts {
     }
 }
 
+// This is not ideal, but it allows us to impl From
 #[derive(Debug, Clone, Copy)]
-struct OptsInputs<'a> {
+struct RunAndExecutionArgs<'a> {
     run_args: &'a RunArgs,
     execution_args: &'a ExecutionArgs,
-    config: &'a ConfigurationOptions,
-    api_auth: &'a Option<APIAuth>,
 }
 
 #[derive(Debug, Default)]
@@ -129,12 +119,12 @@ pub struct RunCacheOpts {
     pub(crate) task_output_logs_override: Option<OutputLogsMode>,
 }
 
-impl<'a> From<OptsInputs<'a>> for RunCacheOpts {
-    fn from(inputs: OptsInputs<'a>) -> Self {
+impl<'a> From<RunAndExecutionArgs<'a>> for RunCacheOpts {
+    fn from(args: RunAndExecutionArgs<'a>) -> Self {
         RunCacheOpts {
-            skip_reads: inputs.execution_args.force.flatten().is_some_and(|f| f),
-            skip_writes: inputs.run_args.no_cache,
-            task_output_logs_override: inputs.execution_args.output_logs,
+            skip_reads: args.execution_args.force.flatten().is_some_and(|f| f),
+            skip_writes: args.run_args.no_cache,
+            task_output_logs_override: args.execution_args.output_logs,
         }
     }
 }
@@ -197,11 +187,11 @@ pub enum ResolvedLogPrefix {
 
 const DEFAULT_CONCURRENCY: u32 = 10;
 
-impl<'a> TryFrom<OptsInputs<'a>> for RunOpts {
+impl<'a> TryFrom<RunAndExecutionArgs<'a>> for RunOpts {
     type Error = self::Error;
 
-    fn try_from(inputs: OptsInputs) -> Result<Self, Self::Error> {
-        let concurrency = inputs
+    fn try_from(args: RunAndExecutionArgs) -> Result<Self, Self::Error> {
+        let concurrency = args
             .execution_args
             .concurrency
             .as_deref()
@@ -209,16 +199,16 @@ impl<'a> TryFrom<OptsInputs<'a>> for RunOpts {
             .transpose()?
             .unwrap_or(DEFAULT_CONCURRENCY);
 
-        let graph = inputs.run_args.graph.as_deref().map(|file| match file {
+        let graph = args.run_args.graph.as_deref().map(|file| match file {
             "" => GraphOpts::Stdout,
             f => GraphOpts::File(f.to_string()),
         });
 
-        let (is_github_actions, log_order, log_prefix) = match inputs.execution_args.log_order {
+        let (is_github_actions, log_order, log_prefix) = match args.execution_args.log_order {
             LogOrder::Auto if turborepo_ci::Vendor::get_constant() == Some("GITHUB_ACTIONS") => (
                 true,
                 ResolvedLogOrder::Grouped,
-                match inputs.execution_args.log_prefix {
+                match args.execution_args.log_prefix {
                     LogPrefix::Task => ResolvedLogPrefix::Task,
                     _ => ResolvedLogPrefix::None,
                 },
@@ -228,37 +218,33 @@ impl<'a> TryFrom<OptsInputs<'a>> for RunOpts {
             LogOrder::Auto | LogOrder::Stream => (
                 false,
                 ResolvedLogOrder::Stream,
-                inputs.execution_args.log_prefix.into(),
+                args.execution_args.log_prefix.into(),
             ),
             LogOrder::Grouped => (
                 false,
                 ResolvedLogOrder::Grouped,
-                inputs.execution_args.log_prefix.into(),
+                args.execution_args.log_prefix.into(),
             ),
         };
 
         Ok(Self {
-            tasks: inputs.execution_args.tasks.clone(),
+            tasks: args.execution_args.tasks.clone(),
             log_prefix,
             log_order,
-            summarize: inputs.run_args.summarize,
-            experimental_space_id: inputs
-                .run_args
-                .experimental_space_id
-                .clone()
-                .or(inputs.config.spaces_id().map(|s| s.to_owned())),
-            framework_inference: inputs.execution_args.framework_inference,
+            summarize: args.run_args.summarize,
+            experimental_space_id: args.run_args.experimental_space_id.clone(),
+            framework_inference: args.execution_args.framework_inference,
+            env_mode: args.execution_args.env_mode,
             concurrency,
-            parallel: inputs.run_args.parallel,
-            profile: inputs.run_args.profile.clone(),
-            continue_on_error: inputs.execution_args.continue_execution,
-            pass_through_args: inputs.execution_args.pass_through_args.clone(),
-            only: inputs.execution_args.only,
-            daemon: inputs.run_args.daemon(),
-            single_package: inputs.execution_args.single_package,
+            parallel: args.run_args.parallel,
+            profile: args.run_args.profile.clone(),
+            continue_on_error: args.execution_args.continue_execution,
+            pass_through_args: args.execution_args.pass_through_args.clone(),
+            only: args.execution_args.only,
+            daemon: args.run_args.daemon(),
+            single_package: args.execution_args.single_package,
             graph,
-            dry_run: inputs.run_args.dry_run,
-            env_mode: inputs.execution_args.env_mode.unwrap_or_default(),
+            dry_run: args.run_args.dry_run,
             is_github_actions,
         })
     }
@@ -302,11 +288,11 @@ pub struct ScopeOpts {
     pub filter_patterns: Vec<String>,
 }
 
-impl<'a> TryFrom<OptsInputs<'a>> for ScopeOpts {
+impl<'a> TryFrom<RunAndExecutionArgs<'a>> for ScopeOpts {
     type Error = self::Error;
 
-    fn try_from(inputs: OptsInputs<'a>) -> Result<Self, Self::Error> {
-        let pkg_inference_root = inputs
+    fn try_from(args: RunAndExecutionArgs<'a>) -> Result<Self, Self::Error> {
+        let pkg_inference_root = args
             .execution_args
             .pkg_inference_root
             .as_ref()
@@ -314,44 +300,21 @@ impl<'a> TryFrom<OptsInputs<'a>> for ScopeOpts {
             .transpose()?;
 
         Ok(Self {
-            global_deps: inputs.execution_args.global_deps.clone(),
+            global_deps: args.execution_args.global_deps.clone(),
             pkg_inference_root,
-            filter_patterns: inputs.execution_args.filter.clone(),
+            filter_patterns: args.execution_args.filter.clone(),
         })
     }
 }
 
-impl<'a> From<OptsInputs<'a>> for CacheOpts {
-    fn from(inputs: OptsInputs<'a>) -> Self {
-        let is_linked = turborepo_api_client::is_linked(inputs.api_auth);
-        let skip_remote = if !is_linked {
-            true
-        } else if let Some(enabled) = inputs.config.enabled {
-            // We're linked, but if the user has explicitly enabled or disabled, use that
-            // value
-            !enabled
-        } else {
-            false
-        };
-
-        // Note that we don't currently use the team_id value here. In the future, we
-        // should probably verify that we only use the signature value when the
-        // configured team_id matches the final resolved team_id.
-        let unused_remote_cache_opts_team_id =
-            inputs.config.team_id().map(|team_id| team_id.to_string());
-        let signature = inputs.config.signature();
-        let remote_cache_opts = Some(RemoteCacheOpts::new(
-            unused_remote_cache_opts_team_id,
-            signature,
-        ));
-
+impl<'a> From<RunAndExecutionArgs<'a>> for CacheOpts {
+    fn from(args: RunAndExecutionArgs<'a>) -> Self {
         CacheOpts {
-            override_dir: inputs.execution_args.cache_dir.clone(),
-            skip_filesystem: inputs.execution_args.remote_only,
-            remote_cache_read_only: inputs.run_args.remote_cache_read_only,
-            workers: inputs.run_args.cache_workers,
-            skip_remote,
-            remote_cache_opts,
+            override_dir: args.execution_args.cache_dir.clone(),
+            skip_filesystem: args.execution_args.remote_only,
+            remote_cache_read_only: args.run_args.remote_cache_read_only,
+            workers: args.run_args.cache_workers,
+            ..CacheOpts::default()
         }
     }
 }
diff --git a/crates/turborepo-lib/src/run/builder.rs b/crates/turborepo-lib/src/run/builder.rs
index f8aa2d6242..3bc96d3a55 100644
--- a/crates/turborepo-lib/src/run/builder.rs
+++ b/crates/turborepo-lib/src/run/builder.rs
@@ -10,7 +10,7 @@ use tracing::debug;
 use turbopath::{AbsoluteSystemPathBuf, AnchoredSystemPath};
 use turborepo_analytics::{start_analytics, AnalyticsHandle, AnalyticsSender};
 use turborepo_api_client::{APIAuth, APIClient};
-use turborepo_cache::AsyncCache;
+use turborepo_cache::{AsyncCache, RemoteCacheOpts};
 use turborepo_env::EnvironmentVariableMap;
 use turborepo_errors::Spanned;
 use turborepo_repository::{
@@ -69,13 +69,33 @@ pub struct RunBuilder {
 
 impl RunBuilder {
     pub fn new(base: CommandBase) -> Result<Self, Error> {
+        let api_auth = base.api_auth()?;
         let api_client = base.api_client()?;
 
-        let opts = Opts::new(&base)?;
-        let api_auth = base.api_auth()?;
+        let mut opts: Opts = base.args().try_into()?;
         let config = base.config()?;
         let allow_missing_package_manager = config.allow_no_package_manager();
 
+        let is_linked = turborepo_api_client::is_linked(&api_auth);
+        if !is_linked {
+            opts.cache_opts.skip_remote = true;
+        } else if let Some(enabled) = config.enabled {
+            // We're linked, but if the user has explicitly enabled or disabled, use that
+            // value
+            opts.cache_opts.skip_remote = !enabled;
+        }
+        // Note that we don't currently use the team_id value here. In the future, we
+        // should probably verify that we only use the signature value when the
+        // configured team_id matches the final resolved team_id.
+        let unused_remote_cache_opts_team_id = config.team_id().map(|team_id| team_id.to_string());
+        let signature = config.signature();
+        opts.cache_opts.remote_cache_opts = Some(RemoteCacheOpts::new(
+            unused_remote_cache_opts_team_id,
+            signature,
+        ));
+        if opts.run_opts.experimental_space_id.is_none() {
+            opts.run_opts.experimental_space_id = config.spaces_id().map(|s| s.to_owned());
+        }
         let version = base.version();
         let experimental_ui = config.ui();
         let processes = ProcessManager::new(
@@ -91,11 +111,11 @@ impl RunBuilder {
             processes,
             opts,
             api_client,
+            api_auth,
             repo_root,
             ui,
             version,
             experimental_ui,
-            api_auth,
             analytics_sender: None,
             entrypoint_packages: None,
             should_print_prelude_override: None,
diff --git a/turborepo-tests/integration/tests/no-args.t b/turborepo-tests/integration/tests/no-args.t
index dc079a8b5b..8c74321153 100644
--- a/turborepo-tests/integration/tests/no-args.t
+++ b/turborepo-tests/integration/tests/no-args.t
@@ -96,7 +96,7 @@ Make sure exit code is 2 when no args are passed
         --global-deps <GLOBAL_DEPS>
             Specify glob of global filesystem dependencies to be hashed. Useful for .env and files
         --env-mode [<ENV_MODE>]
-            Environment variable mode. Use "loose" to pass the entire existing environment. Use "strict" to use an allowlist specified in turbo.json [possible values: loose, strict]
+            Environment variable mode. Use "loose" to pass the entire existing environment. Use "strict" to use an allowlist specified in turbo.json [default: strict] [possible values: loose, strict]
     -F, --filter <FILTER>
             Use the given selector to specify package(s) to act as entry points. The syntax mirrors pnpm's syntax, and additional documentation and examples can be found in turbo's documentation https://turbo.build/repo/docs/reference/command-line-reference/run#--filter
         --output-logs <OUTPUT_LOGS>
diff --git a/turborepo-tests/integration/tests/turbo-help.t b/turborepo-tests/integration/tests/turbo-help.t
index bb2bad7144..1ec3f0c34c 100644
--- a/turborepo-tests/integration/tests/turbo-help.t
+++ b/turborepo-tests/integration/tests/turbo-help.t
@@ -96,7 +96,7 @@ Test help flag
         --global-deps <GLOBAL_DEPS>
             Specify glob of global filesystem dependencies to be hashed. Useful for .env and files
         --env-mode [<ENV_MODE>]
-            Environment variable mode. Use "loose" to pass the entire existing environment. Use "strict" to use an allowlist specified in turbo.json [possible values: loose, strict]
+            Environment variable mode. Use "loose" to pass the entire existing environment. Use "strict" to use an allowlist specified in turbo.json [default: strict] [possible values: loose, strict]
     -F, --filter <FILTER>
             Use the given selector to specify package(s) to act as entry points. The syntax mirrors pnpm's syntax, and additional documentation and examples can be found in turbo's documentation https://turbo.build/repo/docs/reference/command-line-reference/run#--filter
         --output-logs <OUTPUT_LOGS>
@@ -268,6 +268,7 @@ Test help flag
         --env-mode [<ENV_MODE>]
             Environment variable mode. Use "loose" to pass the entire existing environment. Use "strict" to use an allowlist specified in turbo.json
             
+            [default: strict]
             [possible values: loose, strict]
   
     -F, --filter <FILTER>
