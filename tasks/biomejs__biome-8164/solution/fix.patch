diff --git a/.changeset/chilly-jokes-decide.md b/.changeset/chilly-jokes-decide.md
new file mode 100644
index 0000000000..9a17e469ed
--- /dev/null
+++ b/.changeset/chilly-jokes-decide.md
@@ -0,0 +1,29 @@
+---
+"@biomejs/biome": minor
+---
+
+Added a new assist action `useSortedInterfaceMembers` that sorts TypeScript interface members, for readability.
+
+It includes an autofix.
+
+Invalid example.
+
+```ts,expect_diagnostic
+interface MixedMembers {
+  z: string;
+  a: number;
+  (): void;
+  y: boolean;
+}
+```
+
+Valid example (after using the assist).
+
+```ts
+interface MixedMembers {
+  a: number;
+  y: boolean;
+  z: string;
+  (): void;
+}
+```
diff --git a/crates/biome_configuration/src/analyzer/assist/actions.rs b/crates/biome_configuration/src/analyzer/assist/actions.rs
index 18db4dc618..1fb803266c 100644
--- a/crates/biome_configuration/src/analyzer/assist/actions.rs
+++ b/crates/biome_configuration/src/analyzer/assist/actions.rs
@@ -67,6 +67,7 @@ impl std::fmt::Display for RuleGroup {
 pub enum ActionName {
     OrganizeImports,
     UseSortedAttributes,
+    UseSortedInterfaceMembers,
     UseSortedKeys,
     UseSortedProperties,
 }
@@ -75,6 +76,7 @@ impl ActionName {
         match self {
             Self::OrganizeImports => "organizeImports",
             Self::UseSortedAttributes => "useSortedAttributes",
+            Self::UseSortedInterfaceMembers => "useSortedInterfaceMembers",
             Self::UseSortedKeys => "useSortedKeys",
             Self::UseSortedProperties => "useSortedProperties",
         }
@@ -83,6 +85,7 @@ impl ActionName {
         match self {
             Self::OrganizeImports => RuleGroup::Source,
             Self::UseSortedAttributes => RuleGroup::Source,
+            Self::UseSortedInterfaceMembers => RuleGroup::Source,
             Self::UseSortedKeys => RuleGroup::Source,
             Self::UseSortedProperties => RuleGroup::Source,
         }
@@ -94,6 +97,7 @@ impl std::str::FromStr for ActionName {
         match s {
             "organizeImports" => Ok(Self::OrganizeImports),
             "useSortedAttributes" => Ok(Self::UseSortedAttributes),
+            "useSortedInterfaceMembers" => Ok(Self::UseSortedInterfaceMembers),
             "useSortedKeys" => Ok(Self::UseSortedKeys),
             "useSortedProperties" => Ok(Self::UseSortedProperties),
             _ => Err("This rule name doesn't exist."),
@@ -193,6 +197,13 @@ pub struct Source {
             biome_rule_options::use_sorted_attributes::UseSortedAttributesOptions,
         >,
     >,
+    #[doc = "Sort interface members by key."]
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub use_sorted_interface_members: Option<
+        RuleAssistConfiguration<
+            biome_rule_options::use_sorted_interface_members::UseSortedInterfaceMembersOptions,
+        >,
+    >,
     #[doc = "Sort the keys of a JSON object in natural order."]
     #[serde(skip_serializing_if = "Option::is_none")]
     pub use_sorted_keys:
@@ -210,6 +221,7 @@ impl Source {
     pub(crate) const GROUP_RULES: &'static [&'static str] = &[
         "organizeImports",
         "useSortedAttributes",
+        "useSortedInterfaceMembers",
         "useSortedKeys",
         "useSortedProperties",
     ];
@@ -237,16 +249,21 @@ impl Source {
         {
             index_set.insert(RuleFilter::Rule(Self::GROUP_NAME, Self::GROUP_RULES[1]));
         }
-        if let Some(rule) = self.use_sorted_keys.as_ref()
+        if let Some(rule) = self.use_sorted_interface_members.as_ref()
             && rule.is_enabled()
         {
             index_set.insert(RuleFilter::Rule(Self::GROUP_NAME, Self::GROUP_RULES[2]));
         }
-        if let Some(rule) = self.use_sorted_properties.as_ref()
+        if let Some(rule) = self.use_sorted_keys.as_ref()
             && rule.is_enabled()
         {
             index_set.insert(RuleFilter::Rule(Self::GROUP_NAME, Self::GROUP_RULES[3]));
         }
+        if let Some(rule) = self.use_sorted_properties.as_ref()
+            && rule.is_enabled()
+        {
+            index_set.insert(RuleFilter::Rule(Self::GROUP_NAME, Self::GROUP_RULES[4]));
+        }
         index_set
     }
     pub(crate) fn get_disabled_rules(&self) -> FxHashSet<RuleFilter<'static>> {
@@ -261,16 +278,21 @@ impl Source {
         {
             index_set.insert(RuleFilter::Rule(Self::GROUP_NAME, Self::GROUP_RULES[1]));
         }
-        if let Some(rule) = self.use_sorted_keys.as_ref()
+        if let Some(rule) = self.use_sorted_interface_members.as_ref()
             && rule.is_disabled()
         {
             index_set.insert(RuleFilter::Rule(Self::GROUP_NAME, Self::GROUP_RULES[2]));
         }
-        if let Some(rule) = self.use_sorted_properties.as_ref()
+        if let Some(rule) = self.use_sorted_keys.as_ref()
             && rule.is_disabled()
         {
             index_set.insert(RuleFilter::Rule(Self::GROUP_NAME, Self::GROUP_RULES[3]));
         }
+        if let Some(rule) = self.use_sorted_properties.as_ref()
+            && rule.is_disabled()
+        {
+            index_set.insert(RuleFilter::Rule(Self::GROUP_NAME, Self::GROUP_RULES[4]));
+        }
         index_set
     }
     #[doc = r" Checks if, given a rule name, matches one of the rules contained in this category"]
@@ -300,6 +322,10 @@ impl Source {
                 .use_sorted_attributes
                 .as_ref()
                 .map(|conf| (conf.level(), conf.get_options())),
+            "useSortedInterfaceMembers" => self
+                .use_sorted_interface_members
+                .as_ref()
+                .map(|conf| (conf.level(), conf.get_options())),
             "useSortedKeys" => self
                 .use_sorted_keys
                 .as_ref()
diff --git a/crates/biome_diagnostics_categories/src/categories.rs b/crates/biome_diagnostics_categories/src/categories.rs
index ec2bfbb15d..0434738fb3 100644
--- a/crates/biome_diagnostics_categories/src/categories.rs
+++ b/crates/biome_diagnostics_categories/src/categories.rs
@@ -206,6 +206,8 @@ define_categories! {
     "lint/nursery/useQwikMethodUsage": "https://biomejs.dev/linter/rules/use-qwik-method-usage",
     "lint/nursery/useQwikValidLexicalScope": "https://biomejs.dev/linter/rules/use-qwik-valid-lexical-scope",
     "lint/nursery/useSortedClasses": "https://biomejs.dev/linter/rules/use-sorted-classes",
+    "lint/nursery/useSpread": "https://biomejs.dev/linter/rules/use-spread",
+    "lint/nursery/useUniqueGraphqlOperationName": "https://biomejs.dev/linter/rules/use-unique-graphql-operation-name",
     "lint/nursery/useVueDefineMacrosOrder": "https://biomejs.dev/linter/rules/use-vue-define-macros-order",
     "lint/nursery/useVueMultiWordComponentNames": "https://biomejs.dev/linter/rules/use-vue-multi-word-component-names",
     "lint/performance/noAccumulatingSpread": "https://biomejs.dev/linter/rules/no-accumulating-spread",
@@ -397,6 +399,7 @@ define_categories! {
     "lint/suspicious/useStrictMode": "https://biomejs.dev/linter/rules/use-strict-mode",
     // end lint rules
     // start assist actions
+    "assist/source/useSortedInterfaceMembers": "https://biomejs.dev/assist/actions/use-sorted-interface-members",
     "assist/source/useSortedKeys": "https://biomejs.dev/assist/actions/use-sorted-keys",
     "assist/source/useSortedProperties": "https://biomejs.dev/assist/actions/use-sorted-properties",
     "assist/source/useSortedAttributes": "https://biomejs.dev/assist/actions/use-sorted-attributes",
diff --git a/crates/biome_js_analyze/src/assist/source.rs b/crates/biome_js_analyze/src/assist/source.rs
index cee3640f65..f149e89311 100644
--- a/crates/biome_js_analyze/src/assist/source.rs
+++ b/crates/biome_js_analyze/src/assist/source.rs
@@ -5,5 +5,6 @@
 use biome_analyze::declare_assist_group;
 pub mod organize_imports;
 pub mod use_sorted_attributes;
+pub mod use_sorted_interface_members;
 pub mod use_sorted_keys;
-declare_assist_group! { pub Source { name : "source" , rules : [self :: organize_imports :: OrganizeImports , self :: use_sorted_attributes :: UseSortedAttributes , self :: use_sorted_keys :: UseSortedKeys ,] } }
+declare_assist_group! { pub Source { name : "source" , rules : [self :: organize_imports :: OrganizeImports , self :: use_sorted_attributes :: UseSortedAttributes , self :: use_sorted_interface_members :: UseSortedInterfaceMembers , self :: use_sorted_keys :: UseSortedKeys ,] } }
diff --git a/crates/biome_js_analyze/src/assist/source/use_sorted_interface_members.rs b/crates/biome_js_analyze/src/assist/source/use_sorted_interface_members.rs
new file mode 100644
index 0000000000..44235ca46d
--- /dev/null
+++ b/crates/biome_js_analyze/src/assist/source/use_sorted_interface_members.rs
@@ -0,0 +1,264 @@
+use std::borrow::Cow;
+
+use biome_analyze::{
+    Ast, FixKind, Rule, RuleAction, RuleDiagnostic, RuleSource, context::RuleContext,
+    declare_source_rule,
+};
+
+use biome_console::markup;
+use biome_diagnostics::category;
+use biome_js_syntax::{
+    AnyJsObjectMemberName, AnyTsTypeMember, TsInterfaceDeclaration, TsTypeMemberList,
+};
+use biome_rule_options::use_sorted_interface_members::UseSortedInterfaceMembersOptions;
+
+use crate::JsRuleAction;
+use biome_rowan::{AstNode, AstNodeExt, AstNodeList, BatchMutationExt, TextRange};
+use biome_string_case::comparable_token::ComparableToken;
+declare_source_rule! {
+    /// Sort interface members by key.
+    ///
+    /// Interface members are sorted according to their names. The rule distinguishes between
+    /// two types of members:
+    ///
+    /// **Sortable members** - Members with explicit, fixed names that can be alphabetically sorted:
+    /// - Property signatures: `property: type`
+    /// - Method signatures: `method(): type`
+    /// - Getter signatures: `get property(): type`
+    /// - Setter signatures: `set property(value: type): void`
+    ///
+    /// **Non-sortable members** - Members without fixed names or with dynamic/computed names:
+    /// - Call signatures: `(): type` (represents the interface as a callable function)
+    /// - Construct signatures: `new (): type` (represents the interface as a constructor)
+    /// - Index signatures: `[key: string]: type` (represents dynamic property access)
+    ///
+    /// The rule sorts all sortable members alphabetically and places them first,
+    /// followed by non-sortable members in their original order. Non-sortable members
+    /// cannot be meaningfully sorted by name since they represent different interface
+    /// contracts rather than named properties or methods.
+    ///
+    /// # Examples
+    ///
+    /// ## Invalid
+    ///
+    /// ```ts,expect_diagnostic
+    /// interface MixedMembers {
+    ///   z: string;
+    ///   a: number;
+    ///   (): void;  // Call signature
+    ///   y: boolean;
+    ///   new (): MixedMembers;  // Construct signature
+    ///   b: string;
+    ///   [key: string]: any;  // Index signature
+    /// }
+    /// ```
+    ///
+    /// ## Valid
+    ///
+    /// ```ts
+    /// interface MixedMembers {
+    ///   a: number;
+    ///   b: string;
+    ///   y: boolean;
+    ///   z: string;
+    ///   (): void;  // Non-sortable members remain in original order
+    ///   new (): MixedMembers;
+    ///   [key: string]: any;
+    /// }
+    /// ```
+    ///
+    pub UseSortedInterfaceMembers {
+        version: "next",
+        name: "useSortedInterfaceMembers",
+        language: "ts",
+        recommended: false,
+        sources: &[RuleSource::EslintPerfectionist("sort-interfaces").inspired()],
+        fix_kind: FixKind::Safe,
+    }
+}
+impl Rule for UseSortedInterfaceMembers {
+    type Query = Ast<TsInterfaceDeclaration>;
+    type State = ();
+    type Signals = Option<Self::State>;
+    type Options = UseSortedInterfaceMembersOptions;
+    fn run(ctx: &RuleContext<Self>) -> Self::Signals {
+        let interface = ctx.query();
+        let body = interface.members();
+        if is_interface_members_sorted(&body, comparator) {
+            None
+        } else {
+            Some(())
+        }
+    }
+    fn diagnostic(ctx: &RuleContext<Self>, _state: &Self::State) -> Option<RuleDiagnostic> {
+        let interface = ctx.query();
+
+        Some(RuleDiagnostic::new(
+            category!("assist/source/useSortedInterfaceMembers"),
+            interface.range(),
+            markup! {
+                "The interface members are not sorted by key."
+            },
+        ))
+    }
+    fn text_range(ctx: &RuleContext<Self>, _state: &Self::State) -> Option<TextRange> {
+        Some(ctx.query().range())
+    }
+    fn action(ctx: &RuleContext<Self>, _state: &Self::State) -> Option<JsRuleAction> {
+        let interface = ctx.query();
+        let list = interface.members();
+        let mut mutation = ctx.root().begin();
+
+        // Instead of rebuilding the entire list, replace individual members
+        // that are in the wrong position. This preserves comments better.
+        // If any token replacements fail, propagate None to skip the fix.
+        sort_interface_members_in_place(&list, comparator, &mut mutation)?;
+
+        Some(RuleAction::new(
+            rule_action_category!(),
+            ctx.metadata().applicability(),
+            markup! { "Sort the interface members by key." },
+            mutation,
+        ))
+    }
+}
+fn comparator(a: &ComparableToken, b: &ComparableToken) -> std::cmp::Ordering {
+    ComparableToken::ascii_nat_cmp(a, b)
+}
+fn get_type_member_name(member: &AnyTsTypeMember) -> Option<AnyJsObjectMemberName> {
+    match member {
+        // Property signatures have names
+        AnyTsTypeMember::TsPropertySignatureTypeMember(prop) => prop.name().ok(),
+        AnyTsTypeMember::TsMethodSignatureTypeMember(method) => method.name().ok(),
+        AnyTsTypeMember::TsGetterSignatureTypeMember(getter) => getter.name().ok(),
+        AnyTsTypeMember::TsSetterSignatureTypeMember(setter) => setter.name().ok(),
+        // Call signatures, construct signatures, and index signatures don't have sortable names
+        _ => None,
+    }
+}
+fn is_interface_members_sorted(
+    list: &TsTypeMemberList,
+    comparator: impl Fn(&ComparableToken, &ComparableToken) -> std::cmp::Ordering,
+) -> bool {
+    use std::cmp::Ordering;
+    let mut prev_key: Option<ComparableToken> = None;
+    let mut saw_non_sortable = false;
+
+    for member in list.iter() {
+        if let Some(name) = get_type_member_name(&member)
+            && let Some(token_text) = name.name()
+        {
+            if saw_non_sortable {
+                // sortable member found after a non-sortable
+                return false;
+            }
+
+            let current = ComparableToken::new(token_text);
+
+            if let Some(prev) = &prev_key
+                && comparator(prev, &current) == Ordering::Greater
+            {
+                return false;
+            }
+
+            prev_key = Some(current);
+
+            continue;
+        }
+
+        // Non-sortable member
+        saw_non_sortable = true;
+    }
+    true
+}
+
+fn sort_interface_members_in_place(
+    list: &TsTypeMemberList,
+    comparator: impl Fn(&ComparableToken, &ComparableToken) -> std::cmp::Ordering,
+    mutation: &mut biome_rowan::BatchMutation<biome_js_syntax::JsLanguage>,
+) -> Option<()> {
+    // Collect current members with their trivia
+    let members_with_trivia: Vec<_> = list
+        .iter()
+        .map(|member| {
+            let syntax = member.syntax();
+            let leading_trivia: Vec<_> = syntax
+                .first_token()
+                .map(|token| token.leading_trivia().pieces().collect())
+                .unwrap_or_default();
+            let trailing_trivia: Vec<_> = syntax
+                .last_token()
+                .map(|token| token.trailing_trivia().pieces().collect())
+                .unwrap_or_default();
+
+            (member, leading_trivia, trailing_trivia)
+        })
+        .collect();
+
+    // Separate sortable from non-sortable members
+    let mut sortable_indices = Vec::new();
+    let mut non_sortable_indices = Vec::new();
+
+    for (index, (member, _, _)) in members_with_trivia.iter().enumerate() {
+        if let Some(name) = get_type_member_name(member)
+            && name.name().is_some()
+        {
+            sortable_indices.push(index);
+        } else {
+            non_sortable_indices.push(index);
+        }
+    }
+
+    // Sort the sortable members by their keys
+    sortable_indices.sort_by(|&a, &b| {
+        let (member_a, _, _) = &members_with_trivia[a];
+        let (member_b, _, _) = &members_with_trivia[b];
+
+        let key_a = get_type_member_name(member_a)
+            .and_then(|name| name.name())
+            .map(ComparableToken::new);
+        let key_b = get_type_member_name(member_b)
+            .and_then(|name| name.name())
+            .map(ComparableToken::new);
+
+        match (key_a, key_b) {
+            (Some(a), Some(b)) => comparator(&a, &b),
+            _ => std::cmp::Ordering::Equal,
+        }
+    });
+
+    // Collect current members in order
+    // Build the expected order: sortable first, then everything else
+    let current_members: Vec<_> = list.iter().collect();
+    let expected_indices: Vec<_> = sortable_indices
+        .into_iter()
+        .chain(non_sortable_indices)
+        .collect();
+
+    // Replace each member that's in the wrong position
+    for (current_index, current_member) in current_members.iter().enumerate() {
+        let expected_index = expected_indices[current_index];
+
+        if current_index != expected_index {
+            let (expected_member, leading, trailing) = &members_with_trivia[expected_index];
+            let mut new_member = expected_member.clone();
+
+            if let Some(first_token) = new_member.syntax().first_token() {
+                let new_first = first_token
+                    .with_leading_trivia(leading.iter().map(|piece| (piece.kind(), piece.text())));
+                new_member =
+                    new_member.replace_token_discard_trivia(first_token.clone(), new_first)?;
+            }
+            if let Some(last_token) = new_member.syntax().last_token() {
+                let new_last = last_token.with_trailing_trivia_pieces(trailing.iter().cloned());
+                new_member =
+                    new_member.replace_token_discard_trivia(last_token.clone(), new_last)?;
+            }
+
+            // Use replace_node_discard_trivia to avoid transferring trivia from current_member
+            mutation.replace_node_discard_trivia(current_member.clone(), new_member);
+        }
+    }
+
+    Some(())
+}
diff --git a/crates/biome_js_analyze/src/options.rs b/crates/biome_js_analyze/src/options.rs
index 6c60db55b6..e9d28478fd 100644
--- a/crates/biome_js_analyze/src/options.rs
+++ b/crates/biome_js_analyze/src/options.rs
@@ -450,6 +450,8 @@ pub type UseSortedClasses =
     <lint::nursery::use_sorted_classes::UseSortedClasses as biome_analyze::Rule>::Options;
 pub type UseSortedKeys =
     <assist::source::use_sorted_keys::UseSortedKeys as biome_analyze::Rule>::Options;
+pub type UseSortedInterfaceMembers =
+    <assist::source::use_sorted_interface_members::UseSortedInterfaceMembers as biome_analyze::Rule>::Options;
 pub type UseStrictMode =
     <lint::suspicious::use_strict_mode::UseStrictMode as biome_analyze::Rule>::Options;
 pub type UseSymbolDescription =
diff --git a/crates/biome_rule_options/src/lib.rs b/crates/biome_rule_options/src/lib.rs
index 4695d8ccc6..e1813ad05c 100644
--- a/crates/biome_rule_options/src/lib.rs
+++ b/crates/biome_rule_options/src/lib.rs
@@ -348,6 +348,7 @@ pub mod use_single_var_declarator;
 pub mod use_solid_for_component;
 pub mod use_sorted_attributes;
 pub mod use_sorted_classes;
+pub mod use_sorted_interface_members;
 pub mod use_sorted_keys;
 pub mod use_sorted_properties;
 pub mod use_static_response_methods;
diff --git a/crates/biome_rule_options/src/use_sorted_interface_members.rs b/crates/biome_rule_options/src/use_sorted_interface_members.rs
new file mode 100644
index 0000000000..3947d614ed
--- /dev/null
+++ b/crates/biome_rule_options/src/use_sorted_interface_members.rs
@@ -0,0 +1,6 @@
+use biome_deserialize_macros::{Deserializable, Merge};
+use serde::{Deserialize, Serialize};
+#[derive(Default, Clone, Debug, Deserialize, Deserializable, Merge, Eq, PartialEq, Serialize)]
+#[cfg_attr(feature = "schema", derive(schemars::JsonSchema))]
+#[serde(rename_all = "camelCase", deny_unknown_fields, default)]
+pub struct UseSortedInterfaceMembersOptions {}
diff --git a/packages/@biomejs/backend-jsonrpc/src/workspace.ts b/packages/@biomejs/backend-jsonrpc/src/workspace.ts
index 53b84cbd3b..70cfa9733b 100644
--- a/packages/@biomejs/backend-jsonrpc/src/workspace.ts
+++ b/packages/@biomejs/backend-jsonrpc/src/workspace.ts
@@ -877,6 +877,10 @@ export interface Source {
 	 * Enforce attribute sorting in JSX elements.
 	 */
 	useSortedAttributes?: RuleAssistConfiguration_for_UseSortedAttributesOptions;
+	/**
+	 * Sort interface members by key.
+	 */
+	useSortedInterfaceMembers?: RuleAssistConfiguration_for_UseSortedInterfaceMembersOptions;
 	/**
 	 * Sort the keys of a JSON object in natural order.
 	 */
@@ -1030,6 +1034,9 @@ export type RuleAssistConfiguration_for_OrganizeImportsOptions =
 export type RuleAssistConfiguration_for_UseSortedAttributesOptions =
 	| RuleAssistPlainConfiguration
 	| RuleAssistWithOptions_for_UseSortedAttributesOptions;
+export type RuleAssistConfiguration_for_UseSortedInterfaceMembersOptions =
+	| RuleAssistPlainConfiguration
+	| RuleAssistWithOptions_for_UseSortedInterfaceMembersOptions;
 export type RuleAssistConfiguration_for_UseSortedKeysOptions =
 	| RuleAssistPlainConfiguration
 	| RuleAssistWithOptions_for_UseSortedKeysOptions;
@@ -2594,6 +2601,16 @@ export interface RuleAssistWithOptions_for_UseSortedAttributesOptions {
 	 */
 	options: UseSortedAttributesOptions;
 }
+export interface RuleAssistWithOptions_for_UseSortedInterfaceMembersOptions {
+	/**
+	 * The severity of the emitted diagnostics by the rule
+	 */
+	level: RuleAssistPlainConfiguration;
+	/**
+	 * Rule's options
+	 */
+	options: UseSortedInterfaceMembersOptions;
+}
 export interface RuleAssistWithOptions_for_UseSortedKeysOptions {
 	/**
 	 * The severity of the emitted diagnostics by the rule
@@ -3719,6 +3736,7 @@ export interface OrganizeImportsOptions {
 export interface UseSortedAttributesOptions {
 	sortOrder?: SortOrder;
 }
+export interface UseSortedInterfaceMembersOptions {}
 export interface UseSortedKeysOptions {
 	sortOrder?: SortOrder;
 }
@@ -9151,6 +9169,8 @@ export type Category =
 	| "lint/nursery/useQwikMethodUsage"
 	| "lint/nursery/useQwikValidLexicalScope"
 	| "lint/nursery/useSortedClasses"
+	| "lint/nursery/useSpread"
+	| "lint/nursery/useUniqueGraphqlOperationName"
 	| "lint/nursery/useVueDefineMacrosOrder"
 	| "lint/nursery/useVueMultiWordComponentNames"
 	| "lint/performance/noAccumulatingSpread"
@@ -9340,6 +9360,7 @@ export type Category =
 	| "lint/suspicious/useNumberToFixedDigitsArgument"
 	| "lint/suspicious/useStaticResponseMethods"
 	| "lint/suspicious/useStrictMode"
+	| "assist/source/useSortedInterfaceMembers"
 	| "assist/source/useSortedKeys"
 	| "assist/source/useSortedProperties"
 	| "assist/source/useSortedAttributes"
diff --git a/packages/@biomejs/biome/configuration_schema.json b/packages/@biomejs/biome/configuration_schema.json
index 4fb7ecc518..ae310f4a29 100644
--- a/packages/@biomejs/biome/configuration_schema.json
+++ b/packages/@biomejs/biome/configuration_schema.json
@@ -5795,6 +5795,14 @@
 				}
 			]
 		},
+		"RuleAssistConfiguration_for_UseSortedInterfaceMembersOptions": {
+			"anyOf": [
+				{ "$ref": "#/definitions/RuleAssistPlainConfiguration" },
+				{
+					"$ref": "#/definitions/RuleAssistWithOptions_for_UseSortedInterfaceMembersOptions"
+				}
+			]
+		},
 		"RuleAssistConfiguration_for_UseSortedKeysOptions": {
 			"anyOf": [
 				{ "$ref": "#/definitions/RuleAssistPlainConfiguration" },
@@ -5842,6 +5850,23 @@
 			},
 			"additionalProperties": false
 		},
+		"RuleAssistWithOptions_for_UseSortedInterfaceMembersOptions": {
+			"type": "object",
+			"required": ["level", "options"],
+			"properties": {
+				"level": {
+					"description": "The severity of the emitted diagnostics by the rule",
+					"allOf": [{ "$ref": "#/definitions/RuleAssistPlainConfiguration" }]
+				},
+				"options": {
+					"description": "Rule's options",
+					"allOf": [
+						{ "$ref": "#/definitions/UseSortedInterfaceMembersOptions" }
+					]
+				}
+			},
+			"additionalProperties": false
+		},
 		"RuleAssistWithOptions_for_UseSortedKeysOptions": {
 			"type": "object",
 			"required": ["level", "options"],
@@ -12443,6 +12468,15 @@
 						{ "type": "null" }
 					]
 				},
+				"useSortedInterfaceMembers": {
+					"description": "Sort interface members by key.",
+					"anyOf": [
+						{
+							"$ref": "#/definitions/RuleAssistConfiguration_for_UseSortedInterfaceMembersOptions"
+						},
+						{ "type": "null" }
+					]
+				},
 				"useSortedKeys": {
 					"description": "Sort the keys of a JSON object in natural order.",
 					"anyOf": [
@@ -14927,6 +14961,10 @@
 			},
 			"additionalProperties": false
 		},
+		"UseSortedInterfaceMembersOptions": {
+			"type": "object",
+			"additionalProperties": false
+		},
 		"UseSortedKeysOptions": {
 			"type": "object",
 			"properties": {
