diff --git a/docs/expressions/customization.md b/docs/expressions/customization.md
index 20895b2f8..2833f0b52 100644
--- a/docs/expressions/customization.md
+++ b/docs/expressions/customization.md
@@ -107,16 +107,17 @@ allowing the function to process the arguments in a customized way. Raw
 functions are called as:
 
 ```
-rawFunction(args: Node[], math: Object, scope: Object)
+rawFunction(args: Node[], math: Object, scope: Map)
 ```
 
 Where :
 
 - `args` is an Array with nodes of the parsed arguments.
 - `math` is the math namespace against which the expression was compiled.
-- `scope` is a shallow _copy_ of the `scope` object provided when evaluating 
-  the expression, optionally extended with nested variables like a function 
-  parameter `x` of in a custom defined function like `f(x) = x^2`.
+- `scope` is a `Map` containing the variables defined in the scope passed 
+  via `evaluate(scope)`. In case of using a custom defined function like
+  `f(x) = rawFunction(x) ^ 2`, the scope passed to `rawFunction` also contains
+  the current value of parameter `x`.
 
 Raw functions must be imported in the `math` namespace, as they need to be
 processed at compile time. They are not supported when passed via a scope
diff --git a/src/expression/node/OperatorNode.js b/src/expression/node/OperatorNode.js
index 5a4bb60c7..6890db6ec 100644
--- a/src/expression/node/OperatorNode.js
+++ b/src/expression/node/OperatorNode.js
@@ -1,5 +1,6 @@
 import { isNode, isConstantNode, isOperatorNode, isParenthesisNode } from '../../utils/is.js'
 import { map } from '../../utils/array.js'
+import { createSubScope } from '../../utils/scope.js'
 import { escape } from '../../utils/string.js'
 import { getSafeProperty, isSafeMethod } from '../../utils/customs.js'
 import { getAssociativity, getPrecedence, isAssociativeWith, properties } from '../operators.js'
@@ -309,7 +310,7 @@ export const createOperatorNode = /* #__PURE__ */ factory(name, dependencies, ({
         // "raw" evaluation
         const rawArgs = this.args
         return function evalOperatorNode (scope, args, context) {
-          return fn(rawArgs, math, scope)
+          return fn(rawArgs, math, createSubScope(scope, args))
         }
       } else if (evalArgs.length === 1) {
         const evalArg0 = evalArgs[0]
diff --git a/src/expression/transform/utils/compileInlineExpression.js b/src/expression/transform/utils/compileInlineExpression.js
index 4f62d3eff..093aa535b 100644
--- a/src/expression/transform/utils/compileInlineExpression.js
+++ b/src/expression/transform/utils/compileInlineExpression.js
@@ -1,11 +1,11 @@
 import { isSymbolNode } from '../../../utils/is.js'
-import { createSubScope } from '../../../utils/scope.js'
+import { PartitionedMap } from '../../../utils/map.js'
 
 /**
  * Compile an inline expression like "x > 0"
  * @param {Node} expression
  * @param {Object} math
- * @param {Object} scope
+ * @param {Map} scope
  * @return {function} Returns a function with one argument which fills in the
  *                    undefined variable (like "x") and evaluates the expression
  */
@@ -23,10 +23,11 @@ export function compileInlineExpression (expression, math, scope) {
 
   // create a test function for this equation
   const name = symbol.name // variable name
-  const subScope = createSubScope(scope)
+  const argsScope = new Map()
+  const subScope = new PartitionedMap(scope, argsScope, new Set([name]))
   const eq = expression.compile()
   return function inlineExpression (x) {
-    subScope.set(name, x)
+    argsScope.set(name, x)
     return eq.evaluate(subScope)
   }
 }
diff --git a/src/utils/map.js b/src/utils/map.js
index cb9a4eb86..7228bbb05 100644
--- a/src/utils/map.js
+++ b/src/utils/map.js
@@ -15,7 +15,7 @@ export class ObjectWrappingMap {
   }
 
   keys () {
-    return Object.keys(this.wrappedObject)
+    return Object.keys(this.wrappedObject).values()
   }
 
   get (key) {
@@ -30,6 +30,125 @@ export class ObjectWrappingMap {
   has (key) {
     return hasSafeProperty(this.wrappedObject, key)
   }
+
+  entries () {
+    return mapIterator(this.keys(), key => [key, this.get(key)])
+  }
+
+  forEach (callback) {
+    for (const key of this.keys()) {
+      callback(this.get(key), key, this)
+    }
+  }
+
+  delete (key) {
+    delete this.wrappedObject[key]
+  }
+
+  clear () {
+    for (const key of this.keys()) {
+      this.delete(key)
+    }
+  }
+
+  get size () {
+    return Object.keys(this.wrappedObject).length
+  }
+}
+
+/**
+ * Create a map with two partitions: a and b.
+ * The set with bKeys determines which keys/values are read/written to map b,
+ * all other values are read/written to map a
+ *
+ * For example:
+ *
+ *   const a = new Map()
+ *   const b = new Map()
+ *   const p = new PartitionedMap(a, b, new Set(['x', 'y']))
+ *
+ * In this case, values `x` and `y` are read/written to map `b`,
+ * all other values are read/written to map `a`.
+ */
+export class PartitionedMap {
+  /**
+   * @param {Map} a
+   * @param {Map} b
+   * @param {Set} bKeys
+   */
+  constructor (a, b, bKeys) {
+    this.a = a
+    this.b = b
+    this.bKeys = bKeys
+  }
+
+  get (key) {
+    return this.bKeys.has(key)
+      ? this.b.get(key)
+      : this.a.get(key)
+  }
+
+  set (key, value) {
+    if (this.bKeys.has(key)) {
+      this.b.set(key, value)
+    } else {
+      this.a.set(key, value)
+    }
+    return this
+  }
+
+  has (key) {
+    return this.b.has(key) || this.a.has(key)
+  }
+
+  keys () {
+    return new Set([
+      ...this.a.keys(),
+      ...this.b.keys()
+    ])[Symbol.iterator]()
+  }
+
+  entries () {
+    return mapIterator(this.keys(), key => [key, this.get(key)])
+  }
+
+  forEach (callback) {
+    for (const key of this.keys()) {
+      callback(this.get(key), key, this)
+    }
+  }
+
+  delete (key) {
+    return this.bKeys.has(key)
+      ? this.b.delete(key)
+      : this.a.delete(key)
+  }
+
+  clear () {
+    this.a.clear()
+    this.b.clear()
+  }
+
+  get size () {
+    return [...this.keys()].length
+  }
+}
+
+/**
+ * Create a new iterator that maps over the provided iterator, applying a mapping function to each item
+ */
+function mapIterator (it, callback) {
+  return {
+    next: () => {
+      const n = it.next()
+      return (n.done)
+        ? n
+        : {
+            value: callback(n.value),
+            done: false
+          }
+    }
+  }
 }
 
 /**
diff --git a/src/utils/scope.js b/src/utils/scope.js
index 3fdd03584..df35f4969 100644
--- a/src/utils/scope.js
+++ b/src/utils/scope.js
@@ -1,4 +1,4 @@
-import { createEmptyMap, assign } from './map.js'
+import { ObjectWrappingMap, PartitionedMap } from './map.js'
 
 /**
  * Create a new scope which can access the parent scope,
@@ -10,13 +10,13 @@ import { createEmptyMap, assign } from './map.js'
  * the remaining `args`.
  *
  * @param {Map} parentScope
- * @param  {...any} args
- * @returns {Map}
+ * @param  {Object} args
+ * @returns {PartitionedMap}
  */
-export function createSubScope (parentScope, ...args) {
-  if (typeof parentScope.createSubScope === 'function') {
-    return assign(parentScope.createSubScope(), ...args)
-  }
-
-  return assign(createEmptyMap(), parentScope, ...args)
+export function createSubScope (parentScope, args) {
+  return new PartitionedMap(
+    parentScope,
+    new ObjectWrappingMap(args),
+    new Set(Object.keys(args))
+  )
 }
