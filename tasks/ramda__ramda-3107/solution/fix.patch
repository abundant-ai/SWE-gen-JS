diff --git a/scripts/partialBuild.js b/scripts/partialBuild.js
index 261ebd39..1f91ee21 100644
--- a/scripts/partialBuild.js
+++ b/scripts/partialBuild.js
@@ -12,7 +12,7 @@ rollupConfig.plugins.push(partialBuildPlugin);
 rollup.rollup(rollupConfig).then(function(bundle) {
   return bundle.generate(rollupConfig.output);
 }).then(function(result) {
-  result.output.forEach(x => process.stdout.write(x.code))
+  result.output.forEach(x => process.stdout.write(x.code));
 });
 
 function partialBuild(options) {
diff --git a/source/index.js b/source/index.js
index 70df3e5b..d9b631ea 100644
--- a/source/index.js
+++ b/source/index.js
@@ -135,6 +135,8 @@ export { default as mergeWith } from './mergeWith.js';
 export { default as mergeWithKey } from './mergeWithKey.js';
 export { default as min } from './min.js';
 export { default as minBy } from './minBy.js';
+export { default as modify } from './modify.js';
+export { default as modifyPath } from './modifyPath.js';
 export { default as modulo } from './modulo.js';
 export { default as move } from './move.js';
 export { default as multiply } from './multiply.js';
diff --git a/source/internal/_modify.js b/source/internal/_modify.js
new file mode 100644
index 00000000..e1e14802
--- /dev/null
+++ b/source/internal/_modify.js
@@ -0,0 +1,29 @@
+import _isArray from './_isArray.js';
+import _isInteger from './_isInteger.js';
+
+/**
+ * Makes a shallow clone of an object, applying the given fn to the specified
+ * property with the given value. Note that this copies and flattens prototype
+ * properties onto the new object as well. All non-primitive properties are
+ * copied by reference.
+ *
+ * @private
+ * @param {String|Number} prop The property name to set
+ * @param {Function} fn The function to apply to the property
+ * @param {Object|Array} obj The object to clone
+ * @return {Object|Array} A new object equivalent to the original except for the changed property.
+ */
+export default function _modify(prop, fn, obj) {
+  if (_isInteger(prop) && _isArray(obj)) {
+    var arr = [].concat(obj);
+    arr[prop] = fn(arr[prop]);
+    return arr;
+  }
+
+  var result = {};
+  for (var p in obj) {
+    result[p] = obj[p];
+  }
+  result[prop] = fn(result[prop]);
+  return result;
+}
diff --git a/source/modify.js b/source/modify.js
new file mode 100644
index 00000000..25ffd553
--- /dev/null
+++ b/source/modify.js
@@ -0,0 +1,27 @@
+import _curry3 from './internal/_curry3.js';
+import modifyPath from './modifyPath.js';
+
+
+/**
+ * Creates a copy of the passed object by applying an `fn` function to the given `prop` property.
+ *
+ * The function will not be invoked, and the object will not change
+ * if its corresponding property does not exist in the object.
+ * All non-primitive properties are copied to the new object by reference.
+ *
+ * @func
+ * @memberOf R
+ * @category Object
+ * @sig Idx -> (v -> v) -> {k: v} -> {k: v}
+ * @param {String|Number} prop The property to be modified.
+ * @param {Function} fn The function to apply to the property.
+ * @param {Object} object The object to be transformed.
+ * @return {Object} The transformed object.
+ * @example
+ *
+ *      const person = {name: 'James', age: 20, pets: ['dog', 'cat']};
+ *      R.modify('age', R.add(1), person); //=> {name: 'James', age: 21, pets: ['dog', 'cat']}
+ *      R.modify('pets', R.append('turtle'), person); //=> {name: 'James', age: 20, pets: ['dog', 'cat', 'turtle']}
+ */
+var modify = _curry3(function modify(prop, fn, object) { return modifyPath([prop], fn, object); });
+export default modify;
diff --git a/source/modifyPath.js b/source/modifyPath.js
new file mode 100644
index 00000000..4760e564
--- /dev/null
+++ b/source/modifyPath.js
@@ -0,0 +1,55 @@
+import _curry3 from './internal/_curry3.js';
+import _isArray from './internal/_isArray.js';
+import _isObject from './internal/_isObject.js';
+import _has from './internal/_has.js';
+import _assoc from './internal/_assoc.js';
+import _modify from './internal/_modify.js';
+
+
+/**
+ * Creates a shallow clone of the passed object by applying an `fn` function
+ * to the value at the given path.
+ *
+ * The function will not be invoked, and the object will not change
+ * if its corresponding path does not exist in the object.
+ * All non-primitive properties are copied to the new object by reference.
+ *
+ * @func
+ * @memberOf R
+ * @category Object
+ * @sig [Idx] -> (v -> v) -> {k: v} -> {k: v}
+ * @param {Array} path The path to be modified.
+ * @param {Function} fn The function to apply to the path.
+ * @param {Object} object The object to be transformed.
+ * @return {Object} The transformed object.
+ * @example
+ *
+ *      const person = {name: 'James', address: { zipCode: '90216' }};
+ *      R.modifyPath(['address', 'zipCode'], R.reverse, person); //=> {name: 'James', address: { zipCode: '61209' }}
+ *
+ *      // Can handle arrays too
+ *      const person = {name: 'James', addresses: [{ zipCode: '90216' }]};
+ *      R.modifyPath(['addresses', 0, 'zipCode'], R.reverse, person); //=> {name: 'James', addresses: [{ zipCode: '61209' }]}
+ */
+var modifyPath = _curry3(function modifyPath(path, fn, object) {
+  if ((!_isObject(object) && !_isArray(object)) || path.length === 0) {
+    return object;
+  }
+
+  var idx = path[0];
+  if (!_has(idx, object)) {
+    return object;
+  }
+
+  if (path.length === 1) {
+    return _modify(idx, fn, object);
+  }
+
+  var val = modifyPath(Array.prototype.slice.call(path, 1), fn, object[idx]);
+  if (val === object[idx]) {
+    return object;
+  }
+  return _assoc(idx, val, object);
+
+});
+export default modifyPath;
