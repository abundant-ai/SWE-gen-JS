diff --git a/crates/turborepo-ci/src/vendor_behavior.rs b/crates/turborepo-ci/src/vendor_behavior.rs
index 396e81a8dc..e737743fb5 100644
--- a/crates/turborepo-ci/src/vendor_behavior.rs
+++ b/crates/turborepo-ci/src/vendor_behavior.rs
@@ -4,23 +4,4 @@ type GroupPrefixFn = fn(group_name: &str) -> String;
 pub struct VendorBehavior {
     pub group_prefix: GroupPrefixFn,
     pub group_suffix: GroupPrefixFn,
-    pub error_group_prefix: Option<GroupPrefixFn>,
-    pub error_group_suffix: Option<GroupPrefixFn>,
-}
-
-impl VendorBehavior {
-    pub fn new(prefix: GroupPrefixFn, suffix: GroupPrefixFn) -> Self {
-        Self {
-            group_prefix: prefix,
-            group_suffix: suffix,
-            error_group_prefix: None,
-            error_group_suffix: None,
-        }
-    }
-
-    pub fn with_error(mut self, prefix: GroupPrefixFn, suffix: GroupPrefixFn) -> Self {
-        self.error_group_prefix = Some(prefix);
-        self.error_group_suffix = Some(suffix);
-        self
-    }
 }
diff --git a/crates/turborepo-ci/src/vendors.rs b/crates/turborepo-ci/src/vendors.rs
index 0f061b0c0c..9dc8483c0f 100644
--- a/crates/turborepo-ci/src/vendors.rs
+++ b/crates/turborepo-ci/src/vendors.rs
@@ -77,10 +77,10 @@ pub(crate) fn get_vendors() -> &'static [Vendor] {
                     sha_env_var: None,
                     branch_env_var: None,
                     username_env_var: None,
-                    behavior: Some(VendorBehavior::new(
-                        |group_name| format!("##[group]{group_name}\r\n"),
-                        |_| String::from("##[endgroup]\r\n"),
-                    )),
+                    behavior: Some(VendorBehavior {
+                        group_prefix: |group_name| format!("##[group]{group_name}\r\n"),
+                        group_suffix: |_| String::from("##[endgroup]\r\n"),
+                    }),
                 },
                 Vendor {
                     name: "Bamboo",
@@ -266,16 +266,10 @@ pub(crate) fn get_vendors() -> &'static [Vendor] {
                     sha_env_var: Some("GITHUB_SHA"),
                     branch_env_var: Some("GITHUB_REF_NAME"),
                     username_env_var: Some("GITHUB_ACTOR"),
-                    behavior: Some(
-                        VendorBehavior::new(
-                            |group_name| format!("::group::{group_name}\n"),
-                            |_| String::from("::endgroup::\n"),
-                        )
-                        .with_error(
-                            |group_name| format!("\x1B[;31m{group_name}\x1B[;0m\n"),
-                            |_| String::new(),
-                        ),
-                    ),
+                    behavior: Some(VendorBehavior {
+                        group_prefix: |group_name| format!("::group::{group_name}\n"),
+                        group_suffix: |_| String::from("::endgroup::\n"),
+                    }),
                 },
                 Vendor {
                     name: "GitLab CI",
@@ -552,10 +546,14 @@ pub(crate) fn get_vendors() -> &'static [Vendor] {
                     sha_env_var: None,
                     branch_env_var: None,
                     username_env_var: None,
-                    behavior: Some(VendorBehavior::new(
-                        |group_name| format!("##teamcity[blockOpened name='{group_name}']"),
-                        |group_name| format!("##teamcity[blockClosed name='{group_name}']"),
-                    )),
+                    behavior: Some(VendorBehavior {
+                        group_prefix: |group_name| {
+                            format!("##teamcity[blockOpened name='{group_name}']")
+                        },
+                        group_suffix: |group_name| {
+                            format!("##teamcity[blockClosed name='{group_name}']")
+                        },
+                    }),
                 },
                 Vendor {
                     name: "Travis CI",
@@ -568,10 +566,10 @@ pub(crate) fn get_vendors() -> &'static [Vendor] {
                     sha_env_var: None,
                     branch_env_var: None,
                     username_env_var: None,
-                    behavior: Some(VendorBehavior::new(
-                        |group_name| format!("travis_fold:start:{group_name}\r\n"),
-                        |group_name| format!("travis_fold:end:{group_name}\r\n"),
-                    )),
+                    behavior: Some(VendorBehavior {
+                        group_prefix: |group_name| format!("travis_fold:start:{group_name}\r\n"),
+                        group_suffix: |group_name| format!("travis_fold:end:{group_name}\r\n"),
+                    }),
                 },
                 Vendor {
                     name: "Vercel",
diff --git a/crates/turborepo-lib/src/task_graph/visitor.rs b/crates/turborepo-lib/src/task_graph/visitor.rs
index b1dad029b1..b063c285b9 100644
--- a/crates/turborepo-lib/src/task_graph/visitor.rs
+++ b/crates/turborepo-lib/src/task_graph/visitor.rs
@@ -392,12 +392,6 @@ impl<'a> Visitor<'a> {
                 (vendor_behavior.group_suffix)(&group_name),
             );
             logger.with_header_footer(Some(header), Some(footer));
-
-            let (error_header, error_footer) = (
-                vendor_behavior.error_group_prefix.map(|f| f(&group_name)),
-                vendor_behavior.error_group_suffix.map(|f| f(&group_name)),
-            );
-            logger.with_error_header_footer(error_header, error_footer);
         }
         logger
     }
@@ -696,10 +690,7 @@ impl ExecContext {
             .instrument(span)
             .await;
 
-        // If the task resulted in an error, do not group in order to better highlight
-        // the error.
-        let is_error = matches!(result, ExecOutcome::Task { .. });
-        let logs = match output_client.finish(is_error) {
+        let logs = match output_client.finish() {
             Ok(logs) => logs,
             Err(e) => {
                 telemetry.track_error(TrackedErrors::DaemonFailedToMarkOutputsAsCached);
diff --git a/crates/turborepo-ui/src/output.rs b/crates/turborepo-ui/src/output.rs
index 2fcedd35e3..837c11041a 100644
--- a/crates/turborepo-ui/src/output.rs
+++ b/crates/turborepo-ui/src/output.rs
@@ -22,12 +22,6 @@ pub struct OutputClient<W> {
     // Any locals held across an await must implement Sync and RwLock lets us achieve this
     buffer: Option<RwLock<Vec<SinkBytes<'static>>>>,
     writers: Arc<Mutex<SinkWriters<W>>>,
-    primary: Marginals,
-    error: Marginals,
-}
-
-#[derive(Default)]
-struct Marginals {
     header: Option<String>,
     footer: Option<String>,
 }
@@ -88,19 +82,16 @@ impl<W: Write> OutputSink<W> {
             behavior,
             buffer,
             writers,
-            primary: Default::default(),
-            error: Default::default(),
+            header: None,
+            footer: None,
         }
     }
 }
 
 impl<W: Write> OutputClient<W> {
     pub fn with_header_footer(&mut self, header: Option<String>, footer: Option<String>) {
-        self.primary = Marginals { header, footer };
-    }
-
-    pub fn with_error_header_footer(&mut self, header: Option<String>, footer: Option<String>) {
-        self.error = Marginals { header, footer };
+        self.header = header;
+        self.footer = footer;
     }
 
     /// A writer that will write to the underlying sink's out writer according
@@ -125,23 +116,15 @@ impl<W: Write> OutputClient<W> {
 
     /// Consume the client and flush any bytes to the underlying sink if
     /// necessary
-    pub fn finish(self, use_error: bool) -> io::Result<Option<Vec<u8>>> {
+    pub fn finish(self) -> io::Result<Option<Vec<u8>>> {
         let Self {
             behavior,
             buffer,
             writers,
-            primary,
-            error,
+            header,
+            footer,
         } = self;
         let buffers = buffer.map(|cell| cell.into_inner().expect("lock poisoned"));
-        let header = use_error
-            .then_some(error.header)
-            .flatten()
-            .or(primary.header);
-        let footer = use_error
-            .then_some(error.footer)
-            .flatten()
-            .or(primary.footer);
 
         if matches!(behavior, OutputClientBehavior::Grouped) {
             let buffers = buffers
@@ -270,7 +253,7 @@ mod test {
                 let mut err = pass_thru_logger.stderr();
                 writeln!(&mut out, "task 1: out").unwrap();
                 writeln!(&mut err, "task 1: err").unwrap();
-                assert!(pass_thru_logger.finish(true).unwrap().is_none());
+                assert!(pass_thru_logger.finish().unwrap().is_none());
             });
             s.spawn(move || {
                 let mut out = buffer_logger.stdout();
@@ -278,7 +261,7 @@ mod test {
                 writeln!(&mut out, "task 2: out").unwrap();
                 writeln!(&mut err, "task 2: err").unwrap();
                 assert_eq!(
-                    buffer_logger.finish(true).unwrap().unwrap(),
+                    buffer_logger.finish().unwrap().unwrap(),
                     b"task 2: out\ntask 2: err\n"
                 );
             });
@@ -308,7 +291,7 @@ mod test {
             "pass thru should end up in sink immediately"
         );
         assert!(
-            logger.finish(true)?.is_none(),
+            logger.finish()?.is_none(),
             "pass through logs shouldn't keep a buffer"
         );
         assert_eq!(
@@ -334,7 +317,7 @@ mod test {
             "buffer should end up in sink immediately"
         );
         assert_eq!(
-            logger.finish(true)?.unwrap(),
+            logger.finish()?.unwrap(),
             b"output for 1\n",
             "buffer should return buffer"
         );
@@ -360,11 +343,11 @@ mod test {
         writeln!(&mut group2_out, "output for 2")?;
         writeln!(&mut group1_out, "output for 1")?;
         let group1_logs = group1_logger
-            .finish(true)?
+            .finish()?
             .expect("grouped logs should have buffer");
         writeln!(&mut group2_err, "warning for 2")?;
         let group2_logs = group2_logger
-            .finish(true)?
+            .finish()?
             .expect("grouped logs should have buffer");
 
         assert_eq!(group1_logs, b"output for 1\n");
@@ -377,44 +360,6 @@ mod test {
         Ok(())
     }
 
-    #[test]
-    fn test_marginals() -> io::Result<()> {
-        let sink = OutputSink::new(Vec::new(), Vec::new());
-        let mut group1_logger = sink.logger(OutputClientBehavior::Grouped);
-        group1_logger
-            .with_header_footer(Some("good header\n".into()), Some("good footer\n".into()));
-        group1_logger
-            .with_error_header_footer(Some("bad header\n".into()), Some("bad footer\n".into()));
-        let mut group2_logger = sink.logger(OutputClientBehavior::Grouped);
-        group2_logger
-            .with_header_footer(Some("good header\n".into()), Some("good footer\n".into()));
-
-        let mut group1_out = group1_logger.stdout();
-        let mut group2_out = group2_logger.stdout();
-
-        writeln!(&mut group2_out, "output for 2")?;
-        writeln!(&mut group1_out, "output for 1")?;
-        let group1_logs = group1_logger
-            .finish(true)?
-            .expect("grouped logs should have buffer");
-        let group2_logs = group2_logger
-            .finish(true)?
-            .expect("grouped logs should have buffer");
-
-        assert_eq!(group1_logs, b"output for 1\n");
-        assert_eq!(group2_logs, b"output for 2\n");
-
-        let SinkWriters { out, .. } = Arc::into_inner(sink.writers).unwrap().into_inner().unwrap();
-        // Error marginals used when present, primary ones used if errors aren't
-        // provided
-        assert_eq!(
-            out,
-            b"bad header\noutput for 1\nbad footer\ngood header\noutput for 2\ngood footer\n"
-        );
-
-        Ok(())
-    }
-
     #[test]
     fn test_loggers_wait_for_newline() {
         let b1 = Arc::new(Barrier::new(2));
@@ -429,14 +374,14 @@ mod test {
                 write!(&mut out, "task 1:").unwrap();
                 b1.wait();
                 writeln!(&mut out, " echo building").unwrap();
-                assert!(logger1.finish(true).unwrap().is_none());
+                assert!(logger1.finish().unwrap().is_none());
             });
             s.spawn(move || {
                 let mut out = logger2.stdout();
                 write!(&mut out, "task 2:").unwrap();
                 b2.wait();
                 writeln!(&mut out, " echo failing").unwrap();
-                assert!(logger2.finish(true).unwrap().is_none(),);
+                assert!(logger2.finish().unwrap().is_none(),);
             });
         });
         let SinkWriters { out, .. } = Arc::into_inner(sink.writers).unwrap().into_inner().unwrap();
diff --git a/crates/turborepo-ui/tests/threads.rs b/crates/turborepo-ui/tests/threads.rs
index a309997520..1fd2b8304e 100644
--- a/crates/turborepo-ui/tests/threads.rs
+++ b/crates/turborepo-ui/tests/threads.rs
@@ -104,7 +104,7 @@ fn echo_task(
     }
     process.wait()?;
 
-    client.finish(true)?;
+    client.finish()?;
 
     Ok(())
 }
diff --git a/turborepo-tests/integration/tests/run-logging/log-order-github.t b/turborepo-tests/integration/tests/run-logging/log-order-github.t
index 96c17cfb39..f7a282a295 100644
--- a/turborepo-tests/integration/tests/run-logging/log-order-github.t
+++ b/turborepo-tests/integration/tests/run-logging/log-order-github.t
@@ -56,7 +56,7 @@ Verify that errors are grouped properly
   \xe2\x80\xa2 Packages in scope: my-app, util (esc)
   \xe2\x80\xa2 Running fail in 2 packages (esc)
   \xe2\x80\xa2 Remote caching disabled (esc)
-  \x1b[;31mutil:fail\x1b[;0m (esc)
+  ::group::util:fail
   cache miss, executing 122cca10fdcda4f0
   
   \> fail (re)
@@ -68,6 +68,7 @@ Verify that errors are grouped properly
   npm ERR!   in workspace: util 
   npm ERR\!   at location: (.*)(\/|\\)packages(\/|\\)util  (re)
   \[ERROR\] command finished with error: command \((.*)(\/|\\)packages(\/|\\)util\) (.*)npm(?:\.cmd)? run fail exited \(1\) (re)
+  ::endgroup::
   ::error::util#fail: command \(.*(\/|\\)packages(\/|\\)util\) (.*)npm(?:\.cmd)? run fail exited \(1\) (re)
   
    Tasks:    0 successful, 1 total
