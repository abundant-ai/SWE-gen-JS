diff --git a/.changeset/eighty-lines-hope.md b/.changeset/eighty-lines-hope.md
new file mode 100644
index 0000000000..aaf56e8a10
--- /dev/null
+++ b/.changeset/eighty-lines-hope.md
@@ -0,0 +1,12 @@
+---
+"@biomejs/biome": patch
+---
+
+Support dynamic `import defer` and `import source`. The syntax looks like:
+
+```ts
+import.source("foo");
+import.source("x", { with: { attr: "val" } });
+import.defer("foo");
+import.defer("x", { with: { attr: "val" } });
+```
diff --git a/crates/biome_js_factory/src/generated/node_factory.rs b/crates/biome_js_factory/src/generated/node_factory.rs
index 91eb202aed..b510b6e9a9 100644
--- a/crates/biome_js_factory/src/generated/node_factory.rs
+++ b/crates/biome_js_factory/src/generated/node_factory.rs
@@ -2045,14 +2045,40 @@ impl JsImportBareClauseBuilder {
 pub fn js_import_call_expression(
     import_token: SyntaxToken,
     arguments: JsCallArguments,
-) -> JsImportCallExpression {
-    JsImportCallExpression::unwrap_cast(SyntaxNode::new_detached(
-        JsSyntaxKind::JS_IMPORT_CALL_EXPRESSION,
-        [
-            Some(SyntaxElement::Token(import_token)),
-            Some(SyntaxElement::Node(arguments.into_syntax())),
-        ],
-    ))
+) -> JsImportCallExpressionBuilder {
+    JsImportCallExpressionBuilder {
+        import_token,
+        arguments,
+        dot_token: None,
+        phase_token: None,
+    }
+}
+pub struct JsImportCallExpressionBuilder {
+    import_token: SyntaxToken,
+    arguments: JsCallArguments,
+    dot_token: Option<SyntaxToken>,
+    phase_token: Option<SyntaxToken>,
+}
+impl JsImportCallExpressionBuilder {
+    pub fn with_dot_token(mut self, dot_token: SyntaxToken) -> Self {
+        self.dot_token = Some(dot_token);
+        self
+    }
+    pub fn with_phase_token(mut self, phase_token: SyntaxToken) -> Self {
+        self.phase_token = Some(phase_token);
+        self
+    }
+    pub fn build(self) -> JsImportCallExpression {
+        JsImportCallExpression::unwrap_cast(SyntaxNode::new_detached(
+            JsSyntaxKind::JS_IMPORT_CALL_EXPRESSION,
+            [
+                Some(SyntaxElement::Token(self.import_token)),
+                self.dot_token.map(|token| SyntaxElement::Token(token)),
+                self.phase_token.map(|token| SyntaxElement::Token(token)),
+                Some(SyntaxElement::Node(self.arguments.into_syntax())),
+            ],
+        ))
+    }
 }
 pub fn js_import_combined_clause(
     default_specifier: JsDefaultImportSpecifier,
diff --git a/crates/biome_js_factory/src/generated/syntax_factory.rs b/crates/biome_js_factory/src/generated/syntax_factory.rs
index f314649cf2..97832980c6 100644
--- a/crates/biome_js_factory/src/generated/syntax_factory.rs
+++ b/crates/biome_js_factory/src/generated/syntax_factory.rs
@@ -2900,7 +2900,7 @@ impl SyntaxFactory for JsSyntaxFactory {
             }
             JS_IMPORT_CALL_EXPRESSION => {
                 let mut elements = (&children).into_iter();
-                let mut slots: RawNodeSlots<2usize> = RawNodeSlots::default();
+                let mut slots: RawNodeSlots<4usize> = RawNodeSlots::default();
                 let mut current_element = elements.next();
                 if let Some(element) = &current_element
                     && element.kind() == T![import]
@@ -2909,6 +2909,20 @@ impl SyntaxFactory for JsSyntaxFactory {
                     current_element = elements.next();
                 }
                 slots.next_slot();
+                if let Some(element) = &current_element
+                    && element.kind() == T ! [.]
+                {
+                    slots.mark_present();
+                    current_element = elements.next();
+                }
+                slots.next_slot();
+                if let Some(element) = &current_element
+                    && matches!(element.kind(), T![source] | T![defer])
+                {
+                    slots.mark_present();
+                    current_element = elements.next();
+                }
+                slots.next_slot();
                 if let Some(element) = &current_element
                     && JsCallArguments::can_cast(element.kind())
                 {
diff --git a/crates/biome_js_formatter/src/js/expressions/import_call_expression.rs b/crates/biome_js_formatter/src/js/expressions/import_call_expression.rs
index 1cd18a12bc..bc9d4d16f4 100644
--- a/crates/biome_js_formatter/src/js/expressions/import_call_expression.rs
+++ b/crates/biome_js_formatter/src/js/expressions/import_call_expression.rs
@@ -12,10 +12,22 @@ impl FormatNodeRule<JsImportCallExpression> for FormatJsImportCallExpression {
     fn fmt_fields(&self, node: &JsImportCallExpression, f: &mut JsFormatter) -> FormatResult<()> {
         let JsImportCallExpressionFields {
             import_token,
+            dot_token,
+            phase,
             arguments,
         } = node.as_fields();
 
-        write![f, [import_token.format(), arguments.format()]]
+        write!(f, [import_token.format()])?;
+
+        if let Some(dot_token) = dot_token {
+            write!(f, [dot_token.format()])?;
+        }
+
+        if let Some(phase) = phase {
+            write!(f, [phase.format()])?;
+        }
+
+        write![f, [arguments.format()]]
     }
 
     fn needs_parentheses(&self, item: &JsImportCallExpression) -> bool {
diff --git a/crates/biome_js_parser/src/syntax/expr.rs b/crates/biome_js_parser/src/syntax/expr.rs
index 7ca0a76ee5..5b23ac83dc 100644
--- a/crates/biome_js_parser/src/syntax/expr.rs
+++ b/crates/biome_js_parser/src/syntax/expr.rs
@@ -1335,19 +1335,17 @@ fn parse_primary_expression(p: &mut JsParser, context: ExpressionContext) -> Par
             let m = p.start();
             p.bump_any();
 
-            // test js import_meta
-            // import.meta
             if p.eat(T![.]) {
-                // test_err js import_no_meta
-                // import.foo
-                // import.metaa
-                if p.at(T![ident]) && p.text(p.cur_range()) == "meta" {
+                if p.eat(T![defer]) || p.eat(T![source]) {
+                    // Parse the call arguments
+                    parse_import_call_expression(p, context, m)
+                } else if p.at(T![ident]) && p.text(p.cur_range()) == "meta" {
                     p.bump_remap(META);
                     m.complete(p, JS_IMPORT_META_EXPRESSION)
                 } else if p.at(T![ident]) {
                     let err = p.err_builder(
                         format!(
-                            "Expected `meta` following an import keyword, but found `{}`",
+                            "Expected `meta`, `source()`, or `defer()` following an import keyword, but found `{}`",
                             p.text(p.cur_range())
                         ),
                         p.cur_range(),
@@ -1357,7 +1355,7 @@ fn parse_primary_expression(p: &mut JsParser, context: ExpressionContext) -> Par
                     m.complete(p, JS_IMPORT_META_EXPRESSION)
                 } else {
                     let err = p.err_builder(
-                        "Expected `meta` following an import keyword, but found none",
+                        "Expected `meta`, `source()`, or `defer()` following an import keyword, but found none",
                         p.cur_range(),
                     );
 
@@ -1365,65 +1363,8 @@ fn parse_primary_expression(p: &mut JsParser, context: ExpressionContext) -> Par
                     m.complete(p, JS_BOGUS)
                 }
             } else {
-                // test js import_call
-                // import("foo")
-                // import("foo", { assert: { type: 'json' } })
-                // import("foo", { with: { 'resolution-mode': 'import' } })
-
-                // test_err js import_invalid_args
-                // import()
-                // import(...["foo"])
-                // import("foo", { assert: { type: 'json' } }, "bar")
-                // import("foo", { with: { type: 'json' } }, "bar")
-                let args = p.start();
-                p.bump(T!['(']);
-                let args_list = p.start();
-
-                let mut progress = ParserProgress::default();
-                let mut error_range_start = p.cur_range().start();
-                let mut args_count = 0;
-
-                while !p.at(EOF) && !p.at(T![')']) {
-                    progress.assert_progressing(p);
-                    args_count += 1;
-
-                    if args_count == 3 {
-                        error_range_start = p.cur_range().start();
-                    }
-
-                    if p.at(T![...]) {
-                        parse_spread_element(p, context)
-                            .add_diagnostic_if_present(p, |p, range| {
-                                p.err_builder("`...` is not allowed in `import()`", range)
-                            })
-                            .map(|mut marker| {
-                                marker.change_to_bogus(p);
-                                marker
-                            });
-                    } else {
-                        parse_assignment_expression_or_higher(p, ExpressionContext::default())
-                            .or_add_diagnostic(p, js_parse_error::expected_expression_assignment);
-                    }
-
-                    if p.at(T![,]) {
-                        p.bump_any();
-                    } else {
-                        break;
-                    }
-                }
-
-                args_list.complete(p, JS_CALL_ARGUMENT_LIST);
-                if args_count == 0 || args_count > 2 {
-                    let err = p.err_builder(
-                        "`import()` requires exactly one or two arguments. ",
-                        error_range_start..p.cur_range().end(),
-                    );
-                    p.error(err);
-                }
-
-                p.expect(T![')']);
-                args.complete(p, JS_CALL_ARGUMENTS);
-                m.complete(p, JS_IMPORT_CALL_EXPRESSION)
+                // This is a direct import() call without phase
+                parse_import_call_expression(p, context, m)
             }
         }
         T![new] => parse_new_expr(p, context).unwrap(),
@@ -2170,3 +2111,60 @@ pub(super) fn is_nth_at_name(p: &mut JsParser, offset: usize) -> bool {
 pub(super) fn is_nth_at_any_name(p: &mut JsParser, n: usize) -> bool {
     is_nth_at_name(p, n) || p.nth_at(n, T![#])
 }
+
+/// Parse the arguments for an import call expression (import() or import.defer() or import.source())
+fn parse_import_call_expression(
+    p: &mut JsParser,
+    context: ExpressionContext,
+    marker: Marker,
+) -> CompletedMarker {
+    let args = p.start();
+    p.bump(T!['(']);
+    let args_list = p.start();
+
+    let mut progress = ParserProgress::default();
+    let mut error_range_start = p.cur_range().start();
+    let mut args_count = 0;
+
+    while !p.at(EOF) && !p.at(T![')']) {
+        progress.assert_progressing(p);
+        args_count += 1;
+
+        if args_count == 3 {
+            error_range_start = p.cur_range().start();
+        }
+
+        if p.at(T![...]) {
+            parse_spread_element(p, context)
+                .add_diagnostic_if_present(p, |p, range| {
+                    p.err_builder("`...` is not allowed in `import()`", range)
+                })
+                .map(|mut marker| {
+                    marker.change_to_bogus(p);
+                    marker
+                });
+        } else {
+            parse_assignment_expression_or_higher(p, ExpressionContext::default())
+                .or_add_diagnostic(p, js_parse_error::expected_expression_assignment);
+        }
+
+        if p.at(T![,]) {
+            p.bump_any();
+        } else {
+            break;
+        }
+    }
+
+    args_list.complete(p, JS_CALL_ARGUMENT_LIST);
+    if args_count == 0 || args_count > 2 {
+        let err = p.err_builder(
+            "`import()` requires exactly one or two arguments. ",
+            error_range_start..p.cur_range().end(),
+        );
+        p.error(err);
+    }
+
+    p.expect(T![')']);
+    args.complete(p, JS_CALL_ARGUMENTS);
+    marker.complete(p, JS_IMPORT_CALL_EXPRESSION)
+}
diff --git a/crates/biome_js_syntax/src/generated/nodes.rs b/crates/biome_js_syntax/src/generated/nodes.rs
index f52e0ccfdd..c643a0e4f9 100644
--- a/crates/biome_js_syntax/src/generated/nodes.rs
+++ b/crates/biome_js_syntax/src/generated/nodes.rs
@@ -3642,14 +3642,22 @@ impl JsImportCallExpression {
     pub fn as_fields(&self) -> JsImportCallExpressionFields {
         JsImportCallExpressionFields {
             import_token: self.import_token(),
+            dot_token: self.dot_token(),
+            phase: self.phase(),
             arguments: self.arguments(),
         }
     }
     pub fn import_token(&self) -> SyntaxResult<SyntaxToken> {
         support::required_token(&self.syntax, 0usize)
     }
+    pub fn dot_token(&self) -> Option<SyntaxToken> {
+        support::token(&self.syntax, 1usize)
+    }
+    pub fn phase(&self) -> Option<SyntaxToken> {
+        support::token(&self.syntax, 2usize)
+    }
     pub fn arguments(&self) -> SyntaxResult<JsCallArguments> {
-        support::required_node(&self.syntax, 1usize)
+        support::required_node(&self.syntax, 3usize)
     }
 }
 impl Serialize for JsImportCallExpression {
@@ -3663,6 +3671,8 @@ impl Serialize for JsImportCallExpression {
 #[derive(Serialize)]
 pub struct JsImportCallExpressionFields {
     pub import_token: SyntaxResult<SyntaxToken>,
+    pub dot_token: Option<SyntaxToken>,
+    pub phase: Option<SyntaxToken>,
     pub arguments: SyntaxResult<JsCallArguments>,
 }
 #[derive(Clone, PartialEq, Eq, Hash)]
@@ -20618,6 +20628,11 @@ impl std::fmt::Debug for JsImportCallExpression {
                     "import_token",
                     &support::DebugSyntaxResult(self.import_token()),
                 )
+                .field(
+                    "dot_token",
+                    &support::DebugOptionalElement(self.dot_token()),
+                )
+                .field("phase", &support::DebugOptionalElement(self.phase()))
                 .field("arguments", &support::DebugSyntaxResult(self.arguments()))
                 .finish()
         } else {
diff --git a/crates/biome_js_syntax/src/generated/nodes_mut.rs b/crates/biome_js_syntax/src/generated/nodes_mut.rs
index 8951ce8e15..6ed1caac38 100644
--- a/crates/biome_js_syntax/src/generated/nodes_mut.rs
+++ b/crates/biome_js_syntax/src/generated/nodes_mut.rs
@@ -1825,10 +1825,22 @@ impl JsImportCallExpression {
                 .splice_slots(0usize..=0usize, once(Some(element.into()))),
         )
     }
+    pub fn with_dot_token(self, element: Option<SyntaxToken>) -> Self {
+        Self::unwrap_cast(
+            self.syntax
+                .splice_slots(1usize..=1usize, once(element.map(|element| element.into()))),
+        )
+    }
+    pub fn with_phase_token(self, element: Option<SyntaxToken>) -> Self {
+        Self::unwrap_cast(
+            self.syntax
+                .splice_slots(2usize..=2usize, once(element.map(|element| element.into()))),
+        )
+    }
     pub fn with_arguments(self, element: JsCallArguments) -> Self {
         Self::unwrap_cast(
             self.syntax
-                .splice_slots(1usize..=1usize, once(Some(element.into_syntax().into()))),
+                .splice_slots(3usize..=3usize, once(Some(element.into_syntax().into()))),
         )
     }
 }
diff --git a/xtask/codegen/js.ungram b/xtask/codegen/js.ungram
index a52f8e0831..60366afa92 100644
--- a/xtask/codegen/js.ungram
+++ b/xtask/codegen/js.ungram
@@ -389,6 +389,8 @@ JsYieldArgument =
 
 JsImportCallExpression =
 	'import'
+	'.'?
+	phase: ('source' | 'defer')?
 	arguments: JsCallArguments
 
 // new target expression
