diff --git a/cSpell.json b/cSpell.json
index e67c7d48e..e8d718316 100644
--- a/cSpell.json
+++ b/cSpell.json
@@ -22,7 +22,6 @@
     "brkt",
     "brolin",
     "brotli",
-    "catmull",
     "cittÃ ",
     "classdef",
     "codedoc",
diff --git a/package.json b/package.json
index bc081f36e..232f23be1 100644
--- a/package.json
+++ b/package.json
@@ -19,7 +19,6 @@
     "build:mermaid": "pnpm build:vite --mermaid",
     "build:viz": "pnpm build:mermaid --visualize",
     "build:types": "tsc -p ./packages/mermaid/tsconfig.json --emitDeclarationOnly && tsc -p ./packages/mermaid-zenuml/tsconfig.json --emitDeclarationOnly && tsc -p ./packages/mermaid-example-diagram/tsconfig.json --emitDeclarationOnly",
-    "build:types:watch": "tsc -p ./packages/mermaid/tsconfig.json --emitDeclarationOnly --watch",
     "build:watch": "pnpm build:vite --watch",
     "build": "pnpm run -r clean && pnpm build:types && pnpm build:vite",
     "dev": "concurrently \"pnpm build:vite --watch\" \"ts-node-esm .vite/server.ts\"",
diff --git a/packages/mermaid/src/diagrams/quadrant-chart/quadrantBuilder.ts b/packages/mermaid/src/diagrams/quadrant-chart/quadrantBuilder.ts
index 5b740b0e0..9c1162762 100644
--- a/packages/mermaid/src/diagrams/quadrant-chart/quadrantBuilder.ts
+++ b/packages/mermaid/src/diagrams/quadrant-chart/quadrantBuilder.ts
@@ -4,13 +4,17 @@ import { log } from '../../logger.js';
 import type { BaseDiagramConfig, QuadrantChartConfig } from '../../config.type.js';
 import defaultConfig from '../../defaultConfig.js';
 import { getThemeVariables } from '../../themes/theme-default.js';
-import type { Point } from '../../types.js';
 
 const defaultThemeVariables = getThemeVariables();
 
 export type TextVerticalPos = 'left' | 'center' | 'right';
 export type TextHorizontalPos = 'top' | 'middle' | 'bottom';
 
+export interface Point {
+  x: number;
+  y: number;
+}
+
 export interface QuadrantPointInputType extends Point {
   text: string;
 }
diff --git a/packages/mermaid/src/mermaid.ts b/packages/mermaid/src/mermaid.ts
index a6d495471..caf4a2b9b 100644
--- a/packages/mermaid/src/mermaid.ts
+++ b/packages/mermaid/src/mermaid.ts
@@ -136,7 +136,7 @@ const runThrowsErrors = async function (
   }
 
   // generate the id of the diagram
-  const idGenerator = new utils.InitIDGenerator(conf.deterministicIds, conf.deterministicIDSeed);
+  const idGenerator = new utils.initIdGenerator(conf.deterministicIds, conf.deterministicIDSeed);
 
   let txt: string;
   const errors: DetailedError[] = [];
diff --git a/packages/mermaid/src/types.ts b/packages/mermaid/src/types.ts
deleted file mode 100644
index 4b9eedad6..000000000
--- a/packages/mermaid/src/types.ts
+++ /dev/null
@@ -1,16 +0,0 @@
-export interface Point {
-  x: number;
-  y: number;
-}
-
-export interface TextDimensionConfig {
-  fontSize?: number;
-  fontWeight?: number;
-  fontFamily?: string;
-}
-
-export interface TextDimensions {
-  width: number;
-  height: number;
-  lineHeight?: number;
-}
diff --git a/packages/mermaid/src/utils.spec.ts b/packages/mermaid/src/utils.spec.ts
index 3be3bc214..e1398efc7 100644
--- a/packages/mermaid/src/utils.spec.ts
+++ b/packages/mermaid/src/utils.spec.ts
@@ -1,5 +1,5 @@
 import { vi } from 'vitest';
-import utils, { calculatePoint, cleanAndMerge, detectDirective } from './utils.js';
+import utils, { cleanAndMerge, detectDirective } from './utils.js';
 import assignWithDepth from './assignWithDepth.js';
 import { detectType } from './diagram-api/detectType.js';
 import { addDiagrams } from './diagram-api/diagram-orchestration.js';
@@ -352,7 +352,7 @@ describe('when initializing the id generator', function () {
   });
 
   it('should return a random number generator based on Date', function () {
-    const idGenerator = new utils.InitIDGenerator(false);
+    const idGenerator = new utils.initIdGenerator(false);
     expect(typeof idGenerator.next).toEqual('function');
     const lastId = idGenerator.next();
     vi.advanceTimersByTime(1000);
@@ -360,7 +360,7 @@ describe('when initializing the id generator', function () {
   });
 
   it('should return a non random number generator', function () {
-    const idGenerator = new utils.InitIDGenerator(true);
+    const idGenerator = new utils.initIdGenerator(true);
     expect(typeof idGenerator.next).toEqual('function');
     const start = 0;
     const lastId = idGenerator.next();
@@ -369,7 +369,7 @@ describe('when initializing the id generator', function () {
   });
 
   it('should return a non random number generator based on seed', function () {
-    const idGenerator = new utils.InitIDGenerator(true, 'thisIsASeed');
+    const idGenerator = new utils.initIdGenerator(true, 'thisIsASeed');
     expect(typeof idGenerator.next).toEqual('function');
     const start = 11;
     const lastId = idGenerator.next();
@@ -490,107 +490,3 @@ describe('cleanAndMerge', () => {
     expect(inputDeep).toEqual({ a: { b: 1 } });
   });
 });
-
-describe('calculatePoint', () => {
-  it('should calculate a point on a straight line', () => {
-    const points = [
-      { x: 0, y: 0 },
-      { x: 0, y: 10 },
-      { x: 0, y: 20 },
-    ];
-    expect(calculatePoint(points, 0)).toEqual({ x: 0, y: 0 });
-    expect(calculatePoint(points, 5)).toEqual({ x: 0, y: 5 });
-    expect(calculatePoint(points, 10)).toEqual({ x: 0, y: 10 });
-  });
-
-  it('should calculate a point on a straight line with slope', () => {
-    const points = [
-      { x: 0, y: 0 },
-      { x: 10, y: 10 },
-      { x: 20, y: 20 },
-    ];
-    expect(calculatePoint(points, 0)).toMatchInlineSnapshot(`
-      {
-        "x": 0,
-        "y": 0,
-      }
-    `);
-    expect(calculatePoint(points, 5)).toMatchInlineSnapshot(`
-      {
-        "x": 3.53553,
-        "y": 3.53553,
-      }
-    `);
-    expect(calculatePoint(points, 10)).toMatchInlineSnapshot(`
-      {
-        "x": 7.07107,
-        "y": 7.07107,
-      }
-    `);
-  });
-
-  it('should calculate a point on a straight line with negative slope', () => {
-    const points = [
-      { x: 20, y: 20 },
-      { x: 10, y: 10 },
-      { x: 15, y: 15 },
-      { x: 0, y: 0 },
-    ];
-    expect(calculatePoint(points, 0)).toMatchInlineSnapshot(`
-      {
-        "x": 20,
-        "y": 20,
-      }
-    `);
-    expect(calculatePoint(points, 5)).toMatchInlineSnapshot(`
-      {
-        "x": 16.46447,
-        "y": 16.46447,
-      }
-    `);
-    expect(calculatePoint(points, 10)).toMatchInlineSnapshot(`
-      {
-        "x": 12.92893,
-        "y": 12.92893,
-      }
-    `);
-  });
-
-  it('should calculate a point on a curved line', () => {
-    const points = [
-      { x: 0, y: 0 },
-      { x: 10, y: 10 },
-      { x: 20, y: 0 },
-    ];
-    expect(calculatePoint(points, 0)).toMatchInlineSnapshot(`
-      {
-        "x": 0,
-        "y": 0,
-      }
-    `);
-    expect(calculatePoint(points, 15)).toMatchInlineSnapshot(`
-      {
-        "x": 10.6066,
-        "y": 9.3934,
-      }
-    `);
-    expect(calculatePoint(points, 20)).toMatchInlineSnapshot(`
-      {
-        "x": 14.14214,
-        "y": 5.85786,
-      }
-    `);
-  });
-
-  it('should throw an error if the new point cannot be found', () => {
-    const points = [
-      { x: 0, y: 0 },
-      { x: 10, y: 10 },
-      { x: 20, y: 20 },
-    ];
-    const distanceToTraverse = 30;
-    expect(() => calculatePoint(points, distanceToTraverse)).toThrow(
-      'Could not find a suitable point for the given distance'
-    );
-  });
-});
diff --git a/packages/mermaid/src/utils.ts b/packages/mermaid/src/utils.ts
index e706ef122..70de197da 100644
--- a/packages/mermaid/src/utils.ts
+++ b/packages/mermaid/src/utils.ts
@@ -1,3 +1,4 @@
+// @ts-nocheck : TODO Fix ts errors
 import { sanitizeUrl } from '@braintree/sanitize-url';
 import type { CurveFactory } from 'd3';
 import {
@@ -32,8 +33,6 @@ import type { MermaidConfig } from './config.type.js';
 import memoize from 'lodash-es/memoize.js';
 import merge from 'lodash-es/merge.js';
 import { directiveRegex } from './diagram-api/regexes.js';
-import type { D3Element } from './mermaidAPI.js';
-import type { Point, TextDimensionConfig, TextDimensions } from './types.js';
 
 export const ZERO_WIDTH_SPACE = '\u200b';
 
@@ -59,7 +58,7 @@ const d3CurveTypes = {
   curveStep: curveStep,
   curveStepAfter: curveStepAfter,
   curveStepBefore: curveStepBefore,
-} as const;
+};
 
 const directiveWithoutOpen =
   /\s*(?:(\w+)(?=:):|(\w+))\s*(?:(\w+)|((?:(?!}%{2}).|\r?\n)*))?\s*(?:}%{2})?/gi;
@@ -102,14 +101,14 @@ export const detectInit = function (
   config?: MermaidConfig
 ): MermaidConfig | undefined {
   const inits = detectDirective(text, /(?:init\b)|(?:initialize\b)/);
-  let results: MermaidConfig & { config?: unknown } = {};
+  let results = {};
 
   if (Array.isArray(inits)) {
     const args = inits.map((init) => init.args);
     sanitizeDirective(args);
     results = assignWithDepth(results, [...args]);
   } else {
-    results = inits.args as MermaidConfig;
+    results = inits.args;
   }
 
   if (!results) {
@@ -117,24 +116,19 @@ export const detectInit = function (
   }
 
   let type = detectType(text, config);
-
-  // Move the `config` value to appropriate diagram type value
-  const prop = 'config';
-  if (results[prop] !== undefined) {
-    if (type === 'flowchart-v2') {
-      type = 'flowchart';
+  ['config'].forEach((prop) => {
+    if (results[prop] !== undefined) {
+      if (type === 'flowchart-v2') {
+        type = 'flowchart';
+      }
+      results[type] = results[prop];
+      delete results[prop];
     }
-    results[type as keyof MermaidConfig] = results[prop];
-    delete results[prop];
-  }
+  });
 
   return results;
 };
 
-interface Directive {
-  type?: string;
-  args?: unknown;
-}
 /**
  * Detects the directive from the text.
  *
@@ -160,8 +154,8 @@ interface Directive {
  */
 export const detectDirective = function (
   text: string,
-  type: string | RegExp | null = null
-): Directive | Directive[] {
+  type: string | RegExp = null
+): { type?: string; args?: any } | { type?: string; args?: any }[] {
   try {
     const commentWithoutDirectives = new RegExp(
       `[%]{2}(?![{]${directiveWithoutOpen.source})(?=[}][%]{2}).*\n`,
@@ -171,8 +165,8 @@ export const detectDirective = function (
     log.debug(
       `Detecting diagram directive${type !== null ? ' type:' + type : ''} based on the text:${text}`
     );
-    let match: RegExpExecArray | null;
-    const result: Directive[] = [];
+    let match;
+    const result = [];
     while ((match = directiveRegex.exec(text)) !== null) {
       // This is necessary to avoid infinite loops with zero-width matches
       if (match.index === directiveRegex.lastIndex) {
@@ -189,17 +183,16 @@ export const detectDirective = function (
       }
     }
     if (result.length === 0) {
-      return { type: text, args: null };
+      result.push({ type: text, args: null });
     }
 
     return result.length === 1 ? result[0] : result;
   } catch (error) {
     log.error(
-      `ERROR: ${
-        (error as Error).message
-      } - Unable to parse directive type: '${type}' based on the text: '${text}'`
+      `ERROR: ${error.message} - Unable to parse directive
+      ${type !== null ? ' type:' + type : ''} based on the text:${text}`
     );
-    return { type: undefined, args: null };
+    return { type: null, args: null };
   }
 };
 
@@ -238,9 +231,7 @@ export function interpolateToCurve(
     return defaultCurve;
   }
   const curveName = `curve${interpolate.charAt(0).toUpperCase() + interpolate.slice(1)}`;
-
-  // @ts-ignore TODO: Fix issue with curve type
-  return d3CurveTypes[curveName as keyof typeof d3CurveTypes] ?? defaultCurve;
+  return d3CurveTypes[curveName] || defaultCurve;
 }
 
 /**
@@ -253,15 +244,13 @@ export function interpolateToCurve(
 export function formatUrl(linkStr: string, config: MermaidConfig): string | undefined {
   const url = linkStr.trim();
 
-  if (!url) {
-    return undefined;
-  }
+  if (url) {
+    if (config.securityLevel !== 'loose') {
+      return sanitizeUrl(url);
+    }
 
-  if (config.securityLevel !== 'loose') {
-    return sanitizeUrl(url);
+    return url;
   }
-
-  return url;
 }
 
 /**
@@ -270,7 +259,7 @@ export function formatUrl(linkStr: string, config: MermaidConfig): string | unde
  * @param functionName - A dot separated path to the function relative to the `window`
  * @param params - Parameters to pass to the function
  */
-export const runFunc = (functionName: string, ...params: unknown[]) => {
+export const runFunc = (functionName: string, ...params) => {
   const arrPaths = functionName.split('.');
 
   const len = arrPaths.length - 1;
@@ -278,16 +267,23 @@ export const runFunc = (functionName: string, ...params: unknown[]) => {
 
   let obj = window;
   for (let i = 0; i < len; i++) {
-    obj = obj[arrPaths[i] as keyof typeof obj];
+    obj = obj[arrPaths[i]];
     if (!obj) {
-      log.error(`Function name: ${functionName} not found in window`);
       return;
     }
   }
 
-  obj[fnName as keyof typeof obj](...params);
+  obj[fnName](...params);
 };
 
+/** A (x, y) point */
+interface Point {
+  /** The x value */
+  x: number;
+  /** The y value */
+  y: number;
+}
+
 /**
  * Finds the distance between two points using the Distance Formula
  *
@@ -295,11 +291,8 @@ export const runFunc = (functionName: string, ...params: unknown[]) => {
  * @param p2 - The second point
  * @returns The distance between the two points.
  */
-function distance(p1?: Point, p2?: Point): number {
-  if (!p1 || !p2) {
-    return 0;
-  }
-  return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
+function distance(p1: Point, p2: Point): number {
+  return p1 && p2 ? Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2)) : 0;
 }
 
 /**
@@ -308,7 +301,7 @@ function distance(p1?: Point, p2?: Point): number {
  * @param points - List of points
  */
 function traverseEdge(points: Point[]): Point {
-  let prevPoint: Point | undefined;
+  let prevPoint;
   let totalDistance = 0;
 
   points.forEach((point) => {
@@ -317,8 +310,35 @@ function traverseEdge(points: Point[]): Point {
   });
 
   // Traverse half of total distance along points
-  const remainingDistance = totalDistance / 2;
-  return calculatePoint(points, remainingDistance);
+  let remainingDistance = totalDistance / 2;
+  let center = undefined;
+  prevPoint = undefined;
+  points.forEach((point) => {
+    if (prevPoint && !center) {
+      const vectorDistance = distance(point, prevPoint);
+      if (vectorDistance < remainingDistance) {
+        remainingDistance -= vectorDistance;
+      } else {
+        // The point is remainingDistance from prevPoint in the vector between prevPoint and point
+        // Calculate the coordinates
+        const distanceRatio = remainingDistance / vectorDistance;
+        if (distanceRatio <= 0) {
+          center = prevPoint;
+        }
+        if (distanceRatio >= 1) {
+          center = { x: point.x, y: point.y };
+        }
+        if (distanceRatio > 0 && distanceRatio < 1) {
+          center = {
+            x: (1 - distanceRatio) * prevPoint.x + distanceRatio * point.x,
+            y: (1 - distanceRatio) * prevPoint.y + distanceRatio * point.y,
+          };
+        }
+      }
+    }
+    prevPoint = point;
+  });
+  return center;
 }
 
 /**
@@ -331,16 +351,20 @@ function calcLabelPosition(points: Point[]): Point {
   return traverseEdge(points);
 }
 
-export const roundNumber = (num: number, precision = 2) => {
-  const factor = Math.pow(10, precision);
-  return Math.round(num * factor) / factor;
-};
+const calcCardinalityPosition = (isRelationTypePresent, points, initialPosition) => {
+  let prevPoint;
+  log.info(`our points ${JSON.stringify(points)}`);
+  if (points[0] !== initialPosition) {
+    points = points.reverse();
+  }
+  // Traverse only 25 total distance along points to find cardinality point
+  const distanceToCardinalityPoint = 25;
 
-export const calculatePoint = (points: Point[], distanceToTraverse: number): Point => {
-  let prevPoint: Point | undefined = undefined;
-  let remainingDistance = distanceToTraverse;
-  for (const point of points) {
-    if (prevPoint) {
+  let remainingDistance = distanceToCardinalityPoint;
+  let center;
+  prevPoint = undefined;
+  points.forEach((point) => {
+    if (prevPoint && !center) {
       const vectorDistance = distance(point, prevPoint);
       if (vectorDistance < remainingDistance) {
         remainingDistance -= vectorDistance;
@@ -349,42 +373,27 @@ export const calculatePoint = (points: Point[], distanceToTraverse: number): Poi
         // Calculate the coordinates
         const distanceRatio = remainingDistance / vectorDistance;
         if (distanceRatio <= 0) {
-          return prevPoint;
+          center = prevPoint;
         }
         if (distanceRatio >= 1) {
-          return { x: point.x, y: point.y };
+          center = { x: point.x, y: point.y };
         }
         if (distanceRatio > 0 && distanceRatio < 1) {
-          return {
-            x: roundNumber((1 - distanceRatio) * prevPoint.x + distanceRatio * point.x, 5),
-            y: roundNumber((1 - distanceRatio) * prevPoint.y + distanceRatio * point.y, 5),
+          center = {
+            x: (1 - distanceRatio) * prevPoint.x + distanceRatio * point.x,
+            y: (1 - distanceRatio) * prevPoint.y + distanceRatio * point.y,
           };
         }
       }
     }
     prevPoint = point;
-  }
-  throw new Error('Could not find a suitable point for the given distance');
-};
-
-const calcCardinalityPosition = (
-  isRelationTypePresent: boolean,
-  points: Point[],
-  initialPosition: Point
-) => {
-  log.info(`our points ${JSON.stringify(points)}`);
-  if (points[0] !== initialPosition) {
-    points = points.reverse();
-  }
-  // Traverse only 25 total distance along points to find cardinality point
-  const distanceToCardinalityPoint = 25;
-  const center = calculatePoint(points, distanceToCardinalityPoint);
+  });
   // if relation is present (Arrows will be added), change cardinality point off-set distance (d)
   const d = isRelationTypePresent ? 10 : 5;
   //Calculate Angle for x and y axis
   const angle = Math.atan2(points[0].y - center.y, points[0].x - center.x);
   const cardinalityPosition = { x: 0, y: 0 };
-  //Calculation cardinality position using angle, center point on the line/curve but perpendicular and with offset-distance
+  //Calculation cardinality position using angle, center point on the line/curve but pendicular and with offset-distance
   cardinalityPosition.x = Math.sin(angle) * d + (points[0].x + center.x) / 2;
   cardinalityPosition.y = -Math.cos(angle) * d + (points[0].y + center.y) / 2;
   return cardinalityPosition;
@@ -403,36 +412,71 @@ function calcTerminalLabelPosition(
   position: 'start_left' | 'start_right' | 'end_left' | 'end_right',
   _points: Point[]
 ): Point {
-  const points = structuredClone(_points);
+  // Todo looking to faster cloning method
+  let points = JSON.parse(JSON.stringify(_points));
+  let prevPoint;
   log.info('our points', points);
   if (position !== 'start_left' && position !== 'start_right') {
-    points.reverse();
+    points = points.reverse();
   }
 
+  points.forEach((point) => {
+    prevPoint = point;
+  });
+
   // Traverse only 25 total distance along points to find cardinality point
   const distanceToCardinalityPoint = 25 + terminalMarkerSize;
-  const center = calculatePoint(points, distanceToCardinalityPoint);
 
+  let remainingDistance = distanceToCardinalityPoint;
+  let center;
+  prevPoint = undefined;
+  points.forEach((point) => {
+    if (prevPoint && !center) {
+      const vectorDistance = distance(point, prevPoint);
+      if (vectorDistance < remainingDistance) {
+        remainingDistance -= vectorDistance;
+      } else {
+        // The point is remainingDistance from prevPoint in the vector between prevPoint and point
+        // Calculate the coordinates
+        const distanceRatio = remainingDistance / vectorDistance;
+        if (distanceRatio <= 0) {
+          center = prevPoint;
+        }
+        if (distanceRatio >= 1) {
+          center = { x: point.x, y: point.y };
+        }
+        if (distanceRatio > 0 && distanceRatio < 1) {
+          center = {
+            x: (1 - distanceRatio) * prevPoint.x + distanceRatio * point.x,
+            y: (1 - distanceRatio) * prevPoint.y + distanceRatio * point.y,
+          };
+        }
+      }
+    }
+    prevPoint = point;
+  });
   // if relation is present (Arrows will be added), change cardinality point off-set distance (d)
   const d = 10 + terminalMarkerSize * 0.5;
   //Calculate Angle for x and y axis
   const angle = Math.atan2(points[0].y - center.y, points[0].x - center.x);
 
-  const cardinalityPosition: Point = { x: 0, y: 0 };
-  //Calculation cardinality position using angle, center point on the line/curve but perpendicular and with offset-distance
+  const cardinalityPosition = { x: 0, y: 0 };
+
+  //Calculation cardinality position using angle, center point on the line/curve but pendicular and with offset-distance
 
+  cardinalityPosition.x = Math.sin(angle) * d + (points[0].x + center.x) / 2;
+  cardinalityPosition.y = -Math.cos(angle) * d + (points[0].y + center.y) / 2;
   if (position === 'start_left') {
     cardinalityPosition.x = Math.sin(angle + Math.PI) * d + (points[0].x + center.x) / 2;
     cardinalityPosition.y = -Math.cos(angle + Math.PI) * d + (points[0].y + center.y) / 2;
-  } else if (position === 'end_right') {
+  }
+  if (position === 'end_right') {
     cardinalityPosition.x = Math.sin(angle - Math.PI) * d + (points[0].x + center.x) / 2 - 5;
     cardinalityPosition.y = -Math.cos(angle - Math.PI) * d + (points[0].y + center.y) / 2 - 5;
-  } else if (position === 'end_left') {
+  }
+  if (position === 'end_left') {
     cardinalityPosition.x = Math.sin(angle) * d + (points[0].x + center.x) / 2 - 5;
     cardinalityPosition.y = -Math.cos(angle) * d + (points[0].y + center.y) / 2 - 5;
-  } else {
-    cardinalityPosition.x = Math.sin(angle) * d + (points[0].x + center.x) / 2;
-    cardinalityPosition.y = -Math.cos(angle) * d + (points[0].y + center.y) / 2;
   }
   return cardinalityPosition;
 }
@@ -458,7 +502,7 @@ export function getStylesFromArray(arr: string[]): { style: string; labelStyle:
     }
   }
 
-  return { style, labelStyle };
+  return { style: style, labelStyle: labelStyle };
 }
 
 let cnt = 0;
@@ -470,10 +514,10 @@ export const generateId = () => {
 /**
  * Generates a random hexadecimal id of the given length.
  *
- * @param length - Length of string.
- * @returns The generated string.
+ * @param length - Length of ID.
+ * @returns The generated ID.
  */
-function makeRandomHex(length: number): string {
+function makeid(length: number): string {
   let result = '';
   const characters = '0123456789abcdef';
   const charactersLength = characters.length;
@@ -483,8 +527,8 @@ function makeRandomHex(length: number): string {
   return result;
 }
 
-export const random = (options: { length: number }) => {
-  return makeRandomHex(options.length);
+export const random = (options) => {
+  return makeid(options.length);
 };
 
 export const getTextObj = function () {
@@ -500,7 +544,6 @@ export const getTextObj = function () {
     rx: 0,
     ry: 0,
     valign: undefined,
-    text: '',
   };
 };
 
@@ -531,7 +574,7 @@ export const drawSimpleText = function (
 
   const [, _fontSizePx] = parseFontSize(textData.fontSize);
 
-  const textElem = elem.append('text') as any;
+  const textElem = elem.append('text');
   textElem.attr('x', textData.x);
   textElem.attr('y', textData.y);
   textElem.style('text-anchor', textData.anchor);
@@ -539,7 +582,6 @@ export const drawSimpleText = function (
   textElem.style('font-size', _fontSizePx);
   textElem.style('font-weight', textData.fontWeight);
   textElem.attr('fill', textData.fill);
-
   if (textData.class !== undefined) {
     textElem.attr('class', textData.class);
   }
@@ -559,9 +601,9 @@ interface WrapLabelConfig {
   joinWith: string;
 }
 
-export const wrapLabel: (label: string, maxWidth: number, config: WrapLabelConfig) => string =
+export const wrapLabel: (label: string, maxWidth: string, config: WrapLabelConfig) => string =
   memoize(
-    (label: string, maxWidth: number, config: WrapLabelConfig): string => {
+    (label: string, maxWidth: string, config: WrapLabelConfig): string => {
       if (!label) {
         return label;
       }
@@ -573,7 +615,7 @@ export const wrapLabel: (label: string, maxWidth: number, config: WrapLabelConfi
         return label;
       }
       const words = label.split(' ');
-      const completedLines: string[] = [];
+      const completedLines = [];
       let nextLine = '';
       words.forEach((word, index) => {
         const wordLength = calculateTextWidth(`${word} `, config);
@@ -658,6 +700,10 @@ export function calculateTextHeight(
   text: Parameters<typeof calculateTextDimensions>[0],
   config: Parameters<typeof calculateTextDimensions>[1]
 ): ReturnType<typeof calculateTextDimensions>['height'] {
+  config = Object.assign(
+    { fontSize: 12, fontWeight: 400, fontFamily: 'Arial', margin: 15 },
+    config
+  );
   return calculateTextDimensions(text, config).height;
 }
 
@@ -673,9 +719,20 @@ export function calculateTextWidth(
   text: Parameters<typeof calculateTextDimensions>[0],
   config: Parameters<typeof calculateTextDimensions>[1]
 ): ReturnType<typeof calculateTextDimensions>['width'] {
+  config = Object.assign({ fontSize: 12, fontWeight: 400, fontFamily: 'Arial' }, config);
   return calculateTextDimensions(text, config).width;
 }
 
+interface TextDimensionConfig {
+  fontSize?: number;
+  fontWeight?: number;
+  fontFamily?: string;
+}
+interface TextDimensions {
+  width: number;
+  height: number;
+  lineHeight?: number;
+}
 /**
  * This calculates the dimensions of the given text, font size, font family, font weight, and
  * margins.
@@ -690,7 +747,8 @@ export const calculateTextDimensions: (
   config: TextDimensionConfig
 ) => TextDimensions = memoize(
   (text: string, config: TextDimensionConfig): TextDimensions => {
-    const { fontSize = 12, fontFamily = 'Arial', fontWeight = 400 } = config;
+    config = Object.assign({ fontSize: 12, fontWeight: 400, fontFamily: 'Arial' }, config);
+    const { fontSize, fontFamily, fontWeight } = config;
     if (!text) {
       return { width: 0, height: 0 };
     }
@@ -714,14 +772,12 @@ export const calculateTextDimensions: (
     const g = body.append('svg');
 
     for (const fontFamily of fontFamilies) {
-      let cHeight = 0;
+      let cheight = 0;
       const dim = { width: 0, height: 0, lineHeight: 0 };
       for (const line of lines) {
         const textObj = getTextObj();
         textObj.text = line || ZERO_WIDTH_SPACE;
-        // @ts-ignore TODO: Fix D3 types
         const textElem = drawSimpleText(g, textObj)
-          // @ts-ignore TODO: Fix D3 types
           .style('font-size', _fontSizePx)
           .style('font-weight', fontWeight)
           .style('font-family', fontFamily);
@@ -731,9 +787,9 @@ export const calculateTextDimensions: (
           throw new Error('svg element not in render tree');
         }
         dim.width = Math.round(Math.max(dim.width, bBox.width));
-        cHeight = Math.round(bBox.height);
-        dim.height += cHeight;
-        dim.lineHeight = Math.round(Math.max(dim.lineHeight, cHeight));
+        cheight = Math.round(bBox.height);
+        dim.height += cheight;
+        dim.lineHeight = Math.round(Math.max(dim.lineHeight, cheight));
       }
       dims.push(dim);
     }
@@ -754,18 +810,25 @@ export const calculateTextDimensions: (
   (text, config) => `${text}${config.fontSize}${config.fontWeight}${config.fontFamily}`
 );
 
-export class InitIDGenerator {
-  private count = 0;
-  public next: () => number;
-  constructor(deterministic = false, seed?: string) {
+export const initIdGenerator = class iterator {
+  constructor(deterministic, seed?: any) {
+    this.deterministic = deterministic;
     // TODO: Seed is only used for length?
-    // v11: Use the actual value of seed string to generate an initial value for count.
+    this.seed = seed;
+
     this.count = seed ? seed.length : 0;
-    this.next = deterministic ? () => this.count++ : () => Date.now();
   }
-}
 
-let decoder: HTMLDivElement;
+  next() {
+    if (!this.deterministic) {
+      return Date.now();
+    }
+
+    return this.count++;
+  }
+};
+
+let decoder;
 
 /**
  * Decodes HTML, source: {@link https://github.com/shrpne/entity-decode/blob/v2.0.1/browser.js}
@@ -777,23 +840,20 @@ export const entityDecode = function (html: string): string {
   decoder = decoder || document.createElement('div');
   // Escape HTML before decoding for HTML Entities
   html = escape(html).replace(/%26/g, '&').replace(/%23/g, '#').replace(/%3B/g, ';');
+  // decoding
   decoder.innerHTML = html;
-  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
-  return unescape(decoder.textContent!);
+  return unescape(decoder.textContent);
 };
 
 export interface DetailedError {
   str: string;
-  // eslint-disable-next-line @typescript-eslint/no-explicit-any
   hash: any;
-  // eslint-disable-next-line @typescript-eslint/no-explicit-any
   error?: any;
   message?: string;
 }
 
 /** @param error - The error to check */
-// eslint-disable-next-line @typescript-eslint/no-explicit-any
-export function isDetailedError(error: any): error is DetailedError {
+export function isDetailedError(error: unknown): error is DetailedError {
   return 'str' in error;
 }
 
@@ -814,7 +874,7 @@ export function getErrorMessage(error: unknown): string {
  * @param title - The title. If empty, returns immediately.
  */
 export const insertTitle = (
-  parent: D3Element,
+  parent,
   cssClass: string,
   titleTopMargin: number,
   title?: string
@@ -822,10 +882,7 @@ export const insertTitle = (
   if (!title) {
     return;
   }
-  const bounds = parent.node()?.getBBox();
-  if (!bounds) {
-    return;
-  }
+  const bounds = parent.node().getBBox();
   parent
     .append('text')
     .text(title)
@@ -848,7 +905,7 @@ export const parseFontSize = (fontSize: string | number | undefined): [number?,
     return [fontSize, fontSize + 'px'];
   }
 
-  const fontSizeNumber = parseInt(fontSize ?? '', 10);
+  const fontSizeNumber = parseInt(fontSize, 10);
   if (Number.isNaN(fontSizeNumber)) {
     // if a number value can't be parsed, return null for both values
     return [undefined, undefined];
@@ -884,7 +941,7 @@ export default {
   random,
   runFunc,
   entityDecode,
+  initIdGenerator,
   insertTitle,
   parseFontSize,
-  InitIDGenerator,
 };
