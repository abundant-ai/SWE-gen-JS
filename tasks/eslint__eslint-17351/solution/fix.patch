diff --git a/lib/config/flat-config-schema.js b/lib/config/flat-config-schema.js
index 3922e8a94..a79c02d66 100644
--- a/lib/config/flat-config-schema.js
+++ b/lib/config/flat-config-schema.js
@@ -507,7 +507,7 @@ const eslintrcKeys = [
 // Full schema
 //-----------------------------------------------------------------------------
 
-exports.flatConfigSchema = {
+const flatConfigSchema = {
 
     // eslintrc-style keys that should always error
     ...Object.fromEntries(eslintrcKeys.map(key => [key, createEslintrcErrorSchema(key)])),
@@ -533,3 +533,13 @@ exports.flatConfigSchema = {
     plugins: pluginsSchema,
     rules: rulesSchema
 };
+
+//-----------------------------------------------------------------------------
+// Exports
+//-----------------------------------------------------------------------------
+
+module.exports = {
+    flatConfigSchema,
+    assertIsRuleSeverity,
+    assertIsRuleOptions
+};
diff --git a/lib/linter/linter.js b/lib/linter/linter.js
index 48b2bdbe5..e195812e5 100644
--- a/lib/linter/linter.js
+++ b/lib/linter/linter.js
@@ -42,7 +42,8 @@ const
     ruleReplacements = require("../../conf/replacements.json");
 const { getRuleFromConfig } = require("../config/flat-config-helpers");
 const { FlatConfigArray } = require("../config/flat-config-array");
-
+const { RuleValidator } = require("../config/rule-validator");
+const { assertIsRuleOptions, assertIsRuleSeverity } = require("../config/flat-config-schema");
 const debug = require("debug")("eslint:linter");
 const MAX_AUTOFIX_PASSES = 10;
 const DEFAULT_PARSER_NAME = "espree";
@@ -50,7 +51,6 @@ const DEFAULT_ECMA_VERSION = 5;
 const commentParser = new ConfigCommentParser();
 const DEFAULT_ERROR_LOC = { start: { line: 1, column: 0 }, end: { line: 1, column: 1 } };
 const parserSymbol = Symbol.for("eslint.RuleTester.parser");
-const globals = require("../../conf/globals");
 
 //------------------------------------------------------------------------------
 // Typedefs
@@ -145,29 +145,6 @@ function isEspree(parser) {
     return !!(parser === espree || parser[parserSymbol] === espree);
 }
 
-/**
- * Retrieves globals for the given ecmaVersion.
- * @param {number} ecmaVersion The version to retrieve globals for.
- * @returns {Object} The globals for the given ecmaVersion.
- */
-function getGlobalsForEcmaVersion(ecmaVersion) {
-
-    switch (ecmaVersion) {
-        case 3:
-            return globals.es3;
-
-        case 5:
-            return globals.es5;
-
-        default:
-            if (ecmaVersion < 2015) {
-                return globals[`es${ecmaVersion + 2009}`];
-            }
-
-            return globals[`es${ecmaVersion}`];
-    }
-}
-
 /**
  * Ensures that variables representing built-in properties of the Global Object,
  * and any globals declared by special block comments, are present in the global
@@ -361,13 +338,13 @@ function extractDirectiveComment(value) {
  * Parses comments in file to extract file-specific config of rules, globals
  * and environments and merges them with global config; also code blocks
  * where reporting is disabled or enabled and merges them with reporting config.
- * @param {ASTNode} ast The top node of the AST.
+ * @param {SourceCode} sourceCode The SourceCode object to get comments from.
  * @param {function(string): {create: Function}} ruleMapper A map from rule IDs to defined rules
  * @param {string|null} warnInlineConfig If a string then it should warn directive comments as disabled. The string value is the config name what the setting came from.
  * @returns {{configuredRules: Object, enabledGlobals: {value:string,comment:Token}[], exportedVariables: Object, problems: LintMessage[], disableDirectives: DisableDirective[]}}
  * A collection of the directive comments that were found, along with any problems that occurred when parsing
  */
-function getDirectiveComments(ast, ruleMapper, warnInlineConfig) {
+function getDirectiveComments(sourceCode, ruleMapper, warnInlineConfig) {
     const configuredRules = {};
     const enabledGlobals = Object.create(null);
     const exportedVariables = {};
@@ -377,7 +354,7 @@ function getDirectiveComments(ast, ruleMapper, warnInlineConfig) {
         builtInRules: Rules
     });
 
-    ast.comments.filter(token => token.type !== "Shebang").forEach(comment => {
+    sourceCode.getInlineConfigNodes().filter(token => token.type !== "Shebang").forEach(comment => {
         const { directivePart, justificationPart } = extractDirectiveComment(comment.value);
 
         const match = directivesPattern.exec(directivePart);
@@ -511,6 +488,69 @@ function getDirectiveComments(ast, ruleMapper, warnInlineConfig) {
     };
 }
 
+/**
+ * Parses comments in file to extract disable directives.
+ * @param {SourceCode} sourceCode The SourceCode object to get comments from.
+ * @param {function(string): {create: Function}} ruleMapper A map from rule IDs to defined rules
+ * @returns {{problems: LintMessage[], disableDirectives: DisableDirective[]}}
+ * A collection of the directive comments that were found, along with any problems that occurred when parsing
+ */
+function getDirectiveCommentsForFlatConfig(sourceCode, ruleMapper) {
+    const problems = [];
+    const disableDirectives = [];
+
+    sourceCode.getInlineConfigNodes().filter(token => token.type !== "Shebang").forEach(comment => {
+        const { directivePart, justificationPart } = extractDirectiveComment(comment.value);
+
+        const match = directivesPattern.exec(directivePart);
+
+        if (!match) {
+            return;
+        }
+        const directiveText = match[1];
+        const lineCommentSupported = /^eslint-disable-(next-)?line$/u.test(directiveText);
+
+        if (comment.type === "Line" && !lineCommentSupported) {
+            return;
+        }
+
+        if (directiveText === "eslint-disable-line" && comment.loc.start.line !== comment.loc.end.line) {
+            const message = `${directiveText} comment should not span multiple lines.`;
+
+            problems.push(createLintingProblem({
+                ruleId: null,
+                message,
+                loc: comment.loc
+            }));
+            return;
+        }
+
+        const directiveValue = directivePart.slice(match.index + directiveText.length);
+
+        switch (directiveText) {
+            case "eslint-disable":
+            case "eslint-enable":
+            case "eslint-disable-next-line":
+            case "eslint-disable-line": {
+                const directiveType = directiveText.slice("eslint-".length);
+                const options = { commentToken: comment, type: directiveType, value: directiveValue, justification: justificationPart, ruleMapper };
+                const { directives, directiveProblems } = createDisableDirectives(options);
+
+                disableDirectives.push(...directives);
+                problems.push(...directiveProblems);
+                break;
+            }
+
+            // no default
+        }
+    });
+
+    return {
+        problems,
+        disableDirectives
+    };
+}
+
 /**
  * Normalize ECMAScript version from the initial config
  * @param {Parser} parser The parser which uses this options.
@@ -1313,7 +1353,7 @@ class Linter {
 
         const sourceCode = slots.lastSourceCode;
         const commentDirectives = options.allowInlineConfig
-            ? getDirectiveComments(sourceCode.ast, ruleId => getRule(slots, ruleId), options.warnInlineConfig)
+            ? getDirectiveComments(sourceCode, ruleId => getRule(slots, ruleId), options.warnInlineConfig)
             : { configuredRules: {}, enabledGlobals: {}, exportedVariables: {}, problems: [], disableDirectives: [] };
 
         // augment global scope with declared global variables
@@ -1324,7 +1364,6 @@ class Linter {
         );
 
         const configuredRules = Object.assign({}, config.rules, commentDirectives.configuredRules);
-
         let lintingProblems;
 
         try {
@@ -1540,19 +1579,6 @@ class Linter {
             languageOptions.ecmaVersion
         );
 
-        /*
-         * add configured globals and language globals
-         *
-         * using Object.assign instead of object spread for performance reasons
-         * https://github.com/eslint/eslint/issues/16302
-         */
-        const configuredGlobals = Object.assign(
-            {},
-            getGlobalsForEcmaVersion(languageOptions.ecmaVersion),
-            languageOptions.sourceType === "commonjs" ? globals.commonjs : void 0,
-            languageOptions.globals
-        );
-
         // double check that there is a parser to avoid mysterious error messages
         if (!languageOptions.parser) {
             throw new TypeError(`No parser specified for ${options.filename}`);
@@ -1608,25 +1634,113 @@ class Linter {
         }
 
         const sourceCode = slots.lastSourceCode;
-        const commentDirectives = options.allowInlineConfig
-            ? getDirectiveComments(
-                sourceCode.ast,
-                ruleId => getRuleFromConfig(ruleId, config),
-                options.warnInlineConfig
-            )
-            : { configuredRules: {}, enabledGlobals: {}, exportedVariables: {}, problems: [], disableDirectives: [] };
 
-        // augment global scope with declared global variables
-        addDeclaredGlobals(
-            sourceCode.scopeManager.scopes[0],
-            configuredGlobals,
-            { exportedVariables: commentDirectives.exportedVariables, enabledGlobals: commentDirectives.enabledGlobals }
-        );
+        /*
+         * Make adjustments based on the language options. For JavaScript,
+         * this is primarily about adding variables into the global scope
+         * to account for ecmaVersion and configured globals.
+         */
+        sourceCode.applyLanguageOptions(languageOptions);
 
-        const configuredRules = Object.assign({}, config.rules, commentDirectives.configuredRules);
+        const mergedInlineConfig = {
+            rules: {}
+        };
+        const inlineConfigProblems = [];
+
+        /*
+         * Inline config can be either enabled or disabled. If disabled, it's possible
+         * to detect the inline config and emit a warning (though this is not required).
+         * So we first check to see if inline config is allowed at all, and if so, we
+         * need to check if it's a warning or not.
+         */
+        if (options.allowInlineConfig) {
+
+            // if inline config should warn then add the warnings
+            if (options.warnInlineConfig) {
+                sourceCode.getInlineConfigNodes().forEach(node => {
+                    inlineConfigProblems.push(createLintingProblem({
+                        ruleId: null,
+                        message: `'${sourceCode.text.slice(node.range[0], node.range[1])}' has no effect because you have 'noInlineConfig' setting in ${options.warnInlineConfig}.`,
+                        loc: node.loc,
+                        severity: 1
+                    }));
+
+                });
+            } else {
+                const inlineConfigResult = sourceCode.applyInlineConfig();
+
+                inlineConfigProblems.push(
+                    ...inlineConfigResult.problems
+                        .map(createLintingProblem)
+                        .map(problem => {
+                            problem.fatal = true;
+                            return problem;
+                        })
+                );
+
+                // next we need to verify information about the specified rules
+                const ruleValidator = new RuleValidator();
+
+                for (const { config: inlineConfig, node } of inlineConfigResult.configs) {
+
+                    Object.keys(inlineConfig.rules).forEach(ruleId => {
+                        const rule = getRuleFromConfig(ruleId, config);
+                        const ruleValue = inlineConfig.rules[ruleId];
+
+                        if (!rule) {
+                            inlineConfigProblems.push(createLintingProblem({ ruleId, loc: node.loc }));
+                            return;
+                        }
+
+                        try {
+
+                            const ruleOptions = Array.isArray(ruleValue) ? ruleValue : [ruleValue];
+
+                            assertIsRuleOptions(ruleId, ruleValue);
+                            assertIsRuleSeverity(ruleId, ruleOptions[0]);
+
+                            ruleValidator.validate({
+                                plugins: config.plugins,
+                                rules: {
+                                    [ruleId]: ruleOptions
+                                }
+                            });
+                            mergedInlineConfig.rules[ruleId] = ruleValue;
+                        } catch (err) {
+
+                            let baseMessage = err.message.slice(
+                                err.message.startsWith("Key \"rules\":")
+                                    ? err.message.indexOf(":", 12) + 1
+                                    : err.message.indexOf(":") + 1
+                            ).trim();
+
+                            if (err.messageTemplate) {
+                                baseMessage += ` You passed "${ruleValue}".`;
+                            }
+
+                            inlineConfigProblems.push(createLintingProblem({
+                                ruleId,
+                                message: `Inline configuration for rule "${ruleId}" is invalid:\n\t${baseMessage}\n`,
+                                loc: node.loc
+                            }));
+                        }
+                    });
+                }
+            }
+        }
 
+        const commentDirectives = options.allowInlineConfig && !options.warnInlineConfig
+            ? getDirectiveCommentsForFlatConfig(
+                sourceCode,
+                ruleId => getRuleFromConfig(ruleId, config)
+            )
+            : { problems: [], disableDirectives: [] };
+
+        const configuredRules = Object.assign({}, config.rules, mergedInlineConfig.rules);
         let lintingProblems;
 
+        sourceCode.finalize();
+
         try {
             lintingProblems = runRules(
                 sourceCode,
@@ -1667,6 +1781,7 @@ class Linter {
             disableFixes: options.disableFixes,
             problems: lintingProblems
                 .concat(commentDirectives.problems)
+                .concat(inlineConfigProblems)
                 .sort((problemA, problemB) => problemA.line - problemB.line || problemA.column - problemB.column),
             reportUnusedDisableDirectives: options.reportUnusedDisableDirectives
         });
diff --git a/lib/rule-tester/flat-rule-tester.js b/lib/rule-tester/flat-rule-tester.js
index d5f5981e6..300bcb744 100644
--- a/lib/rule-tester/flat-rule-tester.js
+++ b/lib/rule-tester/flat-rule-tester.js
@@ -133,6 +133,15 @@ const suggestionObjectParameters = new Set([
 ]);
 const friendlySuggestionObjectParameterList = `[${[...suggestionObjectParameters].map(key => `'${key}'`).join(", ")}]`;
 
+const forbiddenMethods = [
+    "applyInlineConfig",
+    "applyLanguageOptions",
+    "finalize"
+];
+
+/** @type {Map<string,WeakSet>} */
+const forbiddenMethodCalls = new Map(forbiddenMethods.map(methodName => ([methodName, new WeakSet()])));
+
 const hasOwnProperty = Function.call.bind(Object.hasOwnProperty);
 
 /**
@@ -291,6 +300,34 @@ function emitCodePathCurrentSegmentsWarning(ruleName) {
     }
 }
 
+/**
+ * Function to replace forbidden `SourceCode` methods. Allows just one call per method.
+ * @param {string} methodName The name of the method to forbid.
+ * @param {Function} prototype The prototype with the original method to call.
+ * @returns {Function} The function that throws the error.
+ */
+function throwForbiddenMethodError(methodName, prototype) {
+
+    const original = prototype[methodName];
+
+    return function(...args) {
+
+        const called = forbiddenMethodCalls.get(methodName);
+
+        /* eslint-disable no-invalid-this -- needed to operate as a method. */
+        if (!called.has(this)) {
+            called.add(this);
+
+            return original.apply(this, args);
+        }
+        /* eslint-enable no-invalid-this -- not needed past this point */
+
+        throw new Error(
+            `\`SourceCode#${methodName}()\` cannot be called inside a rule.`
+        );
+    };
+}
+
 //------------------------------------------------------------------------------
 // Public Interface
 //------------------------------------------------------------------------------
@@ -679,11 +716,6 @@ class FlatRuleTester {
                 }
             }
 
-            // Verify the code.
-            const { getComments } = SourceCode.prototype;
-            const originalCurrentSegments = Object.getOwnPropertyDescriptor(CodePath.prototype, "currentSegments");
-            let messages;
-
             // check for validation errors
             try {
                 configs.normalizeSync();
@@ -693,6 +725,11 @@ class FlatRuleTester {
                 throw error;
             }
 
+            // Verify the code.
+            const { getComments, applyLanguageOptions, applyInlineConfig, finalize } = SourceCode.prototype;
+            const originalCurrentSegments = Object.getOwnPropertyDescriptor(CodePath.prototype, "currentSegments");
+            let messages;
+
             try {
                 SourceCode.prototype.getComments = getCommentsDeprecation;
                 Object.defineProperty(CodePath.prototype, "currentSegments", {
@@ -702,10 +739,17 @@ class FlatRuleTester {
                     }
                 });
 
+                forbiddenMethods.forEach(methodName => {
+                    SourceCode.prototype[methodName] = throwForbiddenMethodError(methodName, SourceCode.prototype);
+                });
+
                 messages = linter.verify(code, configs, filename);
             } finally {
                 SourceCode.prototype.getComments = getComments;
                 Object.defineProperty(CodePath.prototype, "currentSegments", originalCurrentSegments);
+                SourceCode.prototype.applyInlineConfig = applyInlineConfig;
+                SourceCode.prototype.applyLanguageOptions = applyLanguageOptions;
+                SourceCode.prototype.finalize = finalize;
             }
 
 
diff --git a/lib/rule-tester/rule-tester.js b/lib/rule-tester/rule-tester.js
index 82d79790a..fbabdb562 100644
--- a/lib/rule-tester/rule-tester.js
+++ b/lib/rule-tester/rule-tester.js
@@ -163,6 +163,12 @@ const suggestionObjectParameters = new Set([
 ]);
 const friendlySuggestionObjectParameterList = `[${[...suggestionObjectParameters].map(key => `'${key}'`).join(", ")}]`;
 
+const forbiddenMethods = [
+    "applyInlineConfig",
+    "applyLanguageOptions",
+    "finalize"
+];
+
 const hasOwnProperty = Function.call.bind(Object.hasOwnProperty);
 
 const DEPRECATED_SOURCECODE_PASSTHROUGHS = {
@@ -330,6 +336,19 @@ function getCommentsDeprecation() {
     );
 }
 
+/**
+ * Function to replace forbidden `SourceCode` methods.
+ * @param {string} methodName The name of the method to forbid.
+ * @returns {Function} The function that throws the error.
+ */
+function throwForbiddenMethodError(methodName) {
+    return () => {
+        throw new Error(
+            `\`SourceCode#${methodName}()\` cannot be called inside a rule.`
+        );
+    };
+}
+
 /**
  * Emit a deprecation warning if function-style format is being used.
  * @param {string} ruleName Name of the rule.
@@ -761,7 +780,7 @@ class RuleTester {
             validate(config, "rule-tester", id => (id === ruleName ? rule : null));
 
             // Verify the code.
-            const { getComments } = SourceCode.prototype;
+            const { getComments, applyLanguageOptions, applyInlineConfig, finalize } = SourceCode.prototype;
             const originalCurrentSegments = Object.getOwnPropertyDescriptor(CodePath.prototype, "currentSegments");
             let messages;
 
@@ -774,10 +793,17 @@ class RuleTester {
                     }
                 });
 
+                forbiddenMethods.forEach(methodName => {
+                    SourceCode.prototype[methodName] = throwForbiddenMethodError(methodName);
+                });
+
                 messages = linter.verify(code, config, filename);
             } finally {
                 SourceCode.prototype.getComments = getComments;
                 Object.defineProperty(CodePath.prototype, "currentSegments", originalCurrentSegments);
+                SourceCode.prototype.applyInlineConfig = applyInlineConfig;
+                SourceCode.prototype.applyLanguageOptions = applyLanguageOptions;
+                SourceCode.prototype.finalize = finalize;
             }
 
             const fatalErrorMessage = messages.find(m => m.fatal);
diff --git a/lib/source-code/source-code.js b/lib/source-code/source-code.js
index 07c0d2948..4bbd5ae3a 100644
--- a/lib/source-code/source-code.js
+++ b/lib/source-code/source-code.js
@@ -12,7 +12,15 @@ const
     { isCommentToken } = require("@eslint-community/eslint-utils"),
     TokenStore = require("./token-store"),
     astUtils = require("../shared/ast-utils"),
-    Traverser = require("../shared/traverser");
+    Traverser = require("../shared/traverser"),
+    globals = require("../../conf/globals"),
+    {
+        directivesPattern
+    } = require("../shared/directives"),
+
+    /* eslint-disable-next-line n/no-restricted-require -- Too messy to figure out right now. */
+    ConfigCommentParser = require("../linter/config-comment-parser"),
+    eslintScope = require("eslint-scope");
 
 //------------------------------------------------------------------------------
 // Type Definitions
@@ -24,6 +32,8 @@ const
 // Private
 //------------------------------------------------------------------------------
 
+const commentParser = new ConfigCommentParser();
+
 /**
  * Validates that the given AST has the required information.
  * @param {ASTNode} ast The Program node of the AST to check.
@@ -49,6 +59,29 @@ function validate(ast) {
     }
 }
 
+/**
+ * Retrieves globals for the given ecmaVersion.
+ * @param {number} ecmaVersion The version to retrieve globals for.
+ * @returns {Object} The globals for the given ecmaVersion.
+ */
+function getGlobalsForEcmaVersion(ecmaVersion) {
+
+    switch (ecmaVersion) {
+        case 3:
+            return globals.es3;
+
+        case 5:
+            return globals.es5;
+
+        default:
+            if (ecmaVersion < 2015) {
+                return globals[`es${ecmaVersion + 2009}`];
+            }
+
+            return globals[`es${ecmaVersion}`];
+    }
+}
+
 /**
  * Check to see if its a ES6 export declaration.
  * @param {ASTNode} astNode An AST node.
@@ -83,6 +116,36 @@ function sortedMerge(tokens, comments) {
     return result;
 }
 
+/**
+ * Normalizes a value for a global in a config
+ * @param {(boolean|string|null)} configuredValue The value given for a global in configuration or in
+ * a global directive comment
+ * @returns {("readable"|"writeable"|"off")} The value normalized as a string
+ * @throws Error if global value is invalid
+ */
+function normalizeConfigGlobal(configuredValue) {
+    switch (configuredValue) {
+        case "off":
+            return "off";
+
+        case true:
+        case "true":
+        case "writeable":
+        case "writable":
+            return "writable";
+
+        case null:
+        case false:
+        case "false":
+        case "readable":
+        case "readonly":
+            return "readonly";
+
+        default:
+            throw new Error(`'${configuredValue}' is not a valid configuration for a global (use 'readonly', 'writable', or 'off')`);
+    }
+}
+
 /**
  * Determines if two nodes or tokens overlap.
  * @param {ASTNode|Token} first The first node or token to check.
@@ -145,6 +208,116 @@ function isSpaceBetween(sourceCode, first, second, checkInsideOfJSXText) {
     return false;
 }
 
+//-----------------------------------------------------------------------------
+// Directive Comments
+//-----------------------------------------------------------------------------
+
+/**
+ * Extract the directive and the justification from a given directive comment and trim them.
+ * @param {string} value The comment text to extract.
+ * @returns {{directivePart: string, justificationPart: string}} The extracted directive and justification.
+ */
+function extractDirectiveComment(value) {
+    const match = /\s-{2,}\s/u.exec(value);
+
+    if (!match) {
+        return { directivePart: value.trim(), justificationPart: "" };
+    }
+
+    const directive = value.slice(0, match.index).trim();
+    const justification = value.slice(match.index + match[0].length).trim();
+
+    return { directivePart: directive, justificationPart: justification };
+}
+
+/**
+ * Ensures that variables representing built-in properties of the Global Object,
+ * and any globals declared by special block comments, are present in the global
+ * scope.
+ * @param {Scope} globalScope The global scope.
+ * @param {Object|undefined} configGlobals The globals declared in configuration
+ * @param {Object|undefined} inlineGlobals The globals declared in the source code
+ * @returns {void}
+ */
+function addDeclaredGlobals(globalScope, configGlobals = {}, inlineGlobals = {}) {
+
+    // Define configured global variables.
+    for (const id of new Set([...Object.keys(configGlobals), ...Object.keys(inlineGlobals)])) {
+
+        /*
+         * `normalizeConfigGlobal` will throw an error if a configured global value is invalid. However, these errors would
+         * typically be caught when validating a config anyway (validity for inline global comments is checked separately).
+         */
+        const configValue = configGlobals[id] === void 0 ? void 0 : normalizeConfigGlobal(configGlobals[id]);
+        const commentValue = inlineGlobals[id] && inlineGlobals[id].value;
+        const value = commentValue || configValue;
+        const sourceComments = inlineGlobals[id] && inlineGlobals[id].comments;
+
+        if (value === "off") {
+            continue;
+        }
+
+        let variable = globalScope.set.get(id);
+
+        if (!variable) {
+            variable = new eslintScope.Variable(id, globalScope);
+
+            globalScope.variables.push(variable);
+            globalScope.set.set(id, variable);
+        }
+
+        variable.eslintImplicitGlobalSetting = configValue;
+        variable.eslintExplicitGlobal = sourceComments !== void 0;
+        variable.eslintExplicitGlobalComments = sourceComments;
+        variable.writeable = (value === "writable");
+    }
+
+    /*
+     * "through" contains all references which definitions cannot be found.
+     * Since we augment the global scope using configuration, we need to update
+     * references and remove the ones that were added by configuration.
+     */
+    globalScope.through = globalScope.through.filter(reference => {
+        const name = reference.identifier.name;
+        const variable = globalScope.set.get(name);
+
+        if (variable) {
+
+            /*
+             * Links the variable and the reference.
+             * And this reference is removed from `Scope#through`.
+             */
+            reference.resolved = variable;
+            variable.references.push(reference);
+
+            return false;
+        }
+
+        return true;
+    });
+}
+
+/**
+ * Sets the given variable names as exported so they won't be triggered by
+ * the `no-unused-vars` rule.
+ * @param {eslint.Scope} globalScope The global scope to define exports in.
+ * @param {Record<string,string>} variables An object whose keys are the variable
+ *      names to export.
+ * @returns {void}
+ */
+function markExportedVariables(globalScope, variables) {
+
+    Object.keys(variables).forEach(name => {
+        const variable = globalScope.set.get(name);
+
+        if (variable) {
+            variable.eslintUsed = true;
+            variable.eslintExported = true;
+        }
+    });
+
+}
+
 //------------------------------------------------------------------------------
 // Public Interface
 //------------------------------------------------------------------------------
@@ -187,7 +360,9 @@ class SourceCode extends TokenStore {
          * General purpose caching for the class.
          */
         this[caches] = new Map([
-            ["scopes", new WeakMap()]
+            ["scopes", new WeakMap()],
+            ["vars", new Map()],
+            ["configNodes", void 0]
         ]);
 
         /**
@@ -266,7 +441,7 @@ class SourceCode extends TokenStore {
         // Cache for comments found using getComments().
         this._commentCache = new WeakMap();
 
-        // don't allow modification of this object
+        // don't allow further modification of this object
         Object.freeze(this);
         Object.freeze(this.lines);
     }
@@ -724,6 +899,178 @@ class SourceCode extends TokenStore {
     }
 
 
+    /**
+     * Returns an array of all inline configuration nodes found in the
+     * source code.
+     * @returns {Array<Token>} An array of all inline configuration nodes.
+     */
+    getInlineConfigNodes() {
+
+        // check the cache first
+        let configNodes = this[caches].get("configNodes");
+
+        if (configNodes) {
+            return configNodes;
+        }
+
+        // calculate fresh config nodes
+        configNodes = this.ast.comments.filter(comment => {
+
+            // shebang comments are never directives
+            if (comment.type === "Shebang") {
+                return false;
+            }
+
+            const { directivePart } = extractDirectiveComment(comment.value);
+
+            const directiveMatch = directivesPattern.exec(directivePart);
+
+            if (!directiveMatch) {
+                return false;
+            }
+
+            // only certain comment types are supported as line comments
+            return comment.type !== "Line" || !!/^eslint-disable-(next-)?line$/u.test(directiveMatch[1]);
+        });
+
+        this[caches].set("configNodes", configNodes);
+
+        return configNodes;
+    }
+
+    /**
+     * Applies language options sent in from the core.
+     * @param {Object} languageOptions The language options for this run.
+     * @returns {void}
+     */
+    applyLanguageOptions(languageOptions) {
+
+        /*
+         * Add configured globals and language globals
+         *
+         * Using Object.assign instead of object spread for performance reasons
+         * https://github.com/eslint/eslint/issues/16302
+         */
+        const configGlobals = Object.assign(
+            {},
+            getGlobalsForEcmaVersion(languageOptions.ecmaVersion),
+            languageOptions.sourceType === "commonjs" ? globals.commonjs : void 0,
+            languageOptions.globals
+        );
+        const varsCache = this[caches].get("vars");
+
+        varsCache.set("configGlobals", configGlobals);
+    }
+
+    /**
+     * Applies configuration found inside of the source code. This method is only
+     * called when ESLint is running with inline configuration allowed.
+     * @returns {{problems:Array<Problem>,configs:{config:FlatConfigArray,node:ASTNode}}} Information
+     *      that ESLint needs to further process the inline configuration.
+     */
+    applyInlineConfig() {
+
+        const problems = [];
+        const configs = [];
+        const exportedVariables = {};
+        const inlineGlobals = Object.create(null);
+
+        this.getInlineConfigNodes().forEach(comment => {
+
+            const { directivePart } = extractDirectiveComment(comment.value);
+            const match = directivesPattern.exec(directivePart);
+            const directiveText = match[1];
+            const directiveValue = directivePart.slice(match.index + directiveText.length);
+
+            switch (directiveText) {
+                case "exported":
+                    Object.assign(exportedVariables, commentParser.parseStringConfig(directiveValue, comment));
+                    break;
+
+                case "globals":
+                case "global":
+                    for (const [id, { value }] of Object.entries(commentParser.parseStringConfig(directiveValue, comment))) {
+                        let normalizedValue;
+
+                        try {
+                            normalizedValue = normalizeConfigGlobal(value);
+                        } catch (err) {
+                            problems.push({
+                                ruleId: null,
+                                loc: comment.loc,
+                                message: err.message
+                            });
+                            continue;
+                        }
+
+                        if (inlineGlobals[id]) {
+                            inlineGlobals[id].comments.push(comment);
+                            inlineGlobals[id].value = normalizedValue;
+                        } else {
+                            inlineGlobals[id] = {
+                                comments: [comment],
+                                value: normalizedValue
+                            };
+                        }
+                    }
+                    break;
+
+                case "eslint": {
+                    const parseResult = commentParser.parseJsonConfig(directiveValue, comment.loc);
+
+                    if (parseResult.success) {
+                        configs.push({
+                            config: {
+                                rules: parseResult.config
+                            },
+                            node: comment
+                        });
+                    } else {
+                        problems.push(parseResult.error);
+                    }
+
+                    break;
+                }
+
+                // no default
+            }
+        });
+
+        // save all the new variables for later
+        const varsCache = this[caches].get("vars");
+
+        varsCache.set("inlineGlobals", inlineGlobals);
+        varsCache.set("exportedVariables", exportedVariables);
+
+        return {
+            configs,
+            problems
+        };
+    }
+
+    /**
+     * Called by ESLint core to indicate that it has finished providing
+     * information. We now add in all the missing variables and ensure that
+     * state-changing methods cannot be called by rules.
+     * @returns {void}
+     */
+    finalize() {
+
+        // Step 1: ensure that all of the necessary variables are up to date
+        const varsCache = this[caches].get("vars");
+        const globalScope = this.scopeManager.scopes[0];
+        const configGlobals = varsCache.get("configGlobals");
+        const inlineGlobals = varsCache.get("inlineGlobals");
+        const exportedVariables = varsCache.get("exportedVariables");
+
+        addDeclaredGlobals(globalScope, configGlobals, inlineGlobals);
+
+        if (exportedVariables) {
+            markExportedVariables(globalScope, exportedVariables);
+        }
+
+    }
+
 }
 
 module.exports = SourceCode;
