diff --git a/packages/query-core/src/queriesObserver.ts b/packages/query-core/src/queriesObserver.ts
index c9fbc5e16..1e0062a07 100644
--- a/packages/query-core/src/queriesObserver.ts
+++ b/packages/query-core/src/queriesObserver.ts
@@ -117,10 +117,6 @@ export class QueriesObserver extends Subscribable<QueriesObserverListener> {
     return this.observers.map((observer) => observer.getCurrentQuery())
   }
 
-  getObservers() {
-    return this.observers
-  }
-
   getOptimisticResult(queries: QueryObserverOptions[]): QueryObserverResult[] {
     return this.findMatchingObservers(queries).map((match) =>
       match.observer.getOptimisticResult(match.defaultedQueryOptions),
diff --git a/packages/react-query/src/__tests__/suspense.test.tsx b/packages/react-query/src/__tests__/suspense.test.tsx
index 3b27c6c90..220a11b17 100644
--- a/packages/react-query/src/__tests__/suspense.test.tsx
+++ b/packages/react-query/src/__tests__/suspense.test.tsx
@@ -8,7 +8,6 @@ import {
   QueryCache,
   QueryErrorResetBoundary,
   useInfiniteQuery,
-  useQueries,
   useQuery,
   useQueryErrorResetBoundary,
 } from '..'
@@ -1012,113 +1011,3 @@ describe("useQuery's in Suspense mode", () => {
     expect(rendered.queryByText('rendered')).not.toBeNull()
   })
 })
-
-describe('useQueries with suspense', () => {
-  const queryClient = createQueryClient()
-  it('should suspend all queries in parallel', async () => {
-    const key1 = queryKey()
-    const key2 = queryKey()
-    const results: string[] = []
-
-    function Fallback() {
-      results.push('loading')
-      return <div>loading</div>
-    }
-
-    function Page() {
-      const result = useQueries({
-        queries: [
-          {
-            queryKey: key1,
-            queryFn: async () => {
-              results.push('1')
-              await sleep(10)
-              return '1'
-            },
-            suspense: true,
-          },
-          {
-            queryKey: key2,
-            queryFn: async () => {
-              results.push('2')
-              await sleep(20)
-              return '2'
-            },
-            suspense: true,
-          },
-        ],
-      })
-      return (
-        <div>
-          <h1>data: {result.map((it) => it.data ?? 'null').join(',')}</h1>
-        </div>
-      )
-    }
-
-    const rendered = renderWithClient(
-      queryClient,
-      <React.Suspense fallback={<Fallback />}>
-        <Page />
-      </React.Suspense>,
-    )
-    await waitFor(() => rendered.getByText('loading'))
-    await waitFor(() => rendered.getByText('data: 1,2'))
-
-    expect(results).toEqual(['1', '2', 'loading'])
-  })
-
-  it('should allow to mix suspense with non-suspense', async () => {
-    const key1 = queryKey()
-    const key2 = queryKey()
-    const results: string[] = []
-
-    function Fallback() {
-      results.push('loading')
-      return <div>loading</div>
-    }
-
-    function Page() {
-      const result = useQueries({
-        queries: [
-          {
-            queryKey: key1,
-            queryFn: async () => {
-              results.push('1')
-              await sleep(10)
-              return '1'
-            },
-            suspense: true,
-          },
-          {
-            queryKey: key2,
-            queryFn: async () => {
-              results.push('2')
-              await sleep(20)
-              return '2'
-            },
-            suspense: false,
-          },
-        ],
-      })
-      return (
-        <div>
-          <h1>data: {result.map((it) => it.data ?? 'null').join(',')}</h1>
-          <h2>status: {result.map((it) => it.status).join(',')}</h2>
-        </div>
-      )
-    }
-
-    const rendered = renderWithClient(
-      queryClient,
-      <React.Suspense fallback={<Fallback />}>
-        <Page />
-      </React.Suspense>,
-    )
-    await waitFor(() => rendered.getByText('loading'))
-    await waitFor(() => rendered.getByText('status: success,loading'))
-    await waitFor(() => rendered.getByText('data: 1,null'))
-    await waitFor(() => rendered.getByText('data: 1,2'))
-
-    expect(results).toEqual(['1', '2', 'loading'])
-  })
-})
diff --git a/packages/react-query/src/suspense.ts b/packages/react-query/src/suspense.ts
deleted file mode 100644
index 682409e75..000000000
--- a/packages/react-query/src/suspense.ts
+++ /dev/null
@@ -1,59 +0,0 @@
-import type { DefaultedQueryObserverOptions } from '@tanstack/query-core'
-import type { QueryObserver } from '@tanstack/query-core'
-import type { QueryErrorResetBoundaryValue } from './QueryErrorResetBoundary'
-import type { QueryObserverResult } from '@tanstack/query-core'
-import type { QueryKey } from '@tanstack/query-core'
-
-export const ensureStaleTime = (
-  defaultedOptions: DefaultedQueryObserverOptions<any, any, any, any, any>,
-) => {
-  if (defaultedOptions.suspense) {
-    // Always set stale time when using suspense to prevent
-    // fetching again when directly mounting after suspending
-    if (typeof defaultedOptions.staleTime !== 'number') {
-      defaultedOptions.staleTime = 1000
-    }
-  }
-}
-
-export const willFetch = (
-  result: QueryObserverResult<any, any>,
-  isRestoring: boolean,
-) => result.isLoading && result.isFetching && !isRestoring
-
-export const shouldSuspend = (
-  defaultedOptions:
-    | DefaultedQueryObserverOptions<any, any, any, any, any>
-    | undefined,
-  result: QueryObserverResult<any, any>,
-  isRestoring: boolean,
-) => defaultedOptions?.suspense && willFetch(result, isRestoring)
-
-export const fetchOptimistic = <
-  TQueryFnData,
-  TError,
-  TData,
-  TQueryData,
-  TQueryKey extends QueryKey,
->(
-  defaultedOptions: DefaultedQueryObserverOptions<
-    TQueryFnData,
-    TError,
-    TData,
-    TQueryData,
-    TQueryKey
-  >,
-  observer: QueryObserver<TQueryFnData, TError, TData, TQueryData, TQueryKey>,
-  errorResetBoundary: QueryErrorResetBoundaryValue,
-) =>
-  observer
-    .fetchOptimistic(defaultedOptions)
-    .then(({ data }) => {
-      defaultedOptions.onSuccess?.(data as TData)
-      defaultedOptions.onSettled?.(data, null)
-    })
-    .catch((error) => {
-      errorResetBoundary.clearReset()
-      defaultedOptions.onError?.(error)
-      defaultedOptions.onSettled?.(undefined, error)
-    })
diff --git a/packages/react-query/src/useBaseQuery.ts b/packages/react-query/src/useBaseQuery.ts
index df537ab74..607ee1f74 100644
--- a/packages/react-query/src/useBaseQuery.ts
+++ b/packages/react-query/src/useBaseQuery.ts
@@ -12,7 +12,6 @@ import {
   getHasError,
   useClearResetErrorBoundary,
 } from './errorBoundaryUtils'
-import { ensureStaleTime, shouldSuspend, fetchOptimistic } from './suspense'
 
 export function useBaseQuery<
   TQueryFnData,
@@ -59,7 +58,14 @@ export function useBaseQuery<
     )
   }
 
-  ensureStaleTime(defaultedOptions)
+  if (defaultedOptions.suspense) {
+    // Always set stale time when using suspense to prevent
+    // fetching again when directly mounting after suspending
+    if (typeof defaultedOptions.staleTime !== 'number') {
+      defaultedOptions.staleTime = 1000
+    }
+  }
+
   ensurePreventErrorBoundaryRetry(defaultedOptions, errorResetBoundary)
 
   useClearResetErrorBoundary(errorResetBoundary)
@@ -93,8 +99,23 @@ export function useBaseQuery<
   }, [defaultedOptions, observer])
 
   // Handle suspense
-  if (shouldSuspend(defaultedOptions, result, isRestoring)) {
-    throw fetchOptimistic(defaultedOptions, observer, errorResetBoundary)
+  if (
+    defaultedOptions.suspense &&
+    result.isLoading &&
+    result.isFetching &&
+    !isRestoring
+  ) {
+    throw observer
+      .fetchOptimistic(defaultedOptions)
+      .then(({ data }) => {
+        defaultedOptions.onSuccess?.(data as TData)
+        defaultedOptions.onSettled?.(data, null)
+      })
+      .catch((error) => {
+        errorResetBoundary.clearReset()
+        defaultedOptions.onError?.(error)
+        defaultedOptions.onSettled?.(undefined, error)
+      })
   }
 
   // Handle error boundary
diff --git a/packages/react-query/src/useQueries.ts b/packages/react-query/src/useQueries.ts
index 0682d30f1..ab9a98ab1 100644
--- a/packages/react-query/src/useQueries.ts
+++ b/packages/react-query/src/useQueries.ts
@@ -12,12 +12,6 @@ import {
   getHasError,
   useClearResetErrorBoundary,
 } from './errorBoundaryUtils'
-import {
-  ensureStaleTime,
-  shouldSuspend,
-  fetchOptimistic,
-  willFetch,
-} from './suspense'
 
 // This defines the `UseQueryOptions` that are accepted in `QueriesOptions` & `GetOptions`.
 // - `context` is omitted as it is passed as a root-level option to `useQueries` instead.
@@ -176,7 +170,7 @@ export function useQueries<T extends any[]>({
     () => new QueriesObserver(queryClient, defaultedQueries),
   )
 
-  const optimisticResult = observer.getOptimisticResult(defaultedQueries)
+  const result = observer.getOptimisticResult(defaultedQueries)
 
   useSyncExternalStore(
     React.useCallback(
@@ -200,48 +194,22 @@ export function useQueries<T extends any[]>({
 
   defaultedQueries.forEach((query) => {
     ensurePreventErrorBoundaryRetry(query, errorResetBoundary)
-    ensureStaleTime(query)
   })
 
   useClearResetErrorBoundary(errorResetBoundary)
 
-  const shouldAtLeastOneSuspend = optimisticResult.some((result, index) =>
-    shouldSuspend(defaultedQueries[index], result, isRestoring),
-  )
-
-  const suspensePromises = shouldAtLeastOneSuspend
-    ? optimisticResult.flatMap((result, index) => {
-        const options = defaultedQueries[index]
-        const queryObserver = observer.getObservers()[index]
-
-        if (options && queryObserver) {
-          if (shouldSuspend(options, result, isRestoring)) {
-            return fetchOptimistic(options, queryObserver, errorResetBoundary)
-          } else if (willFetch(result, isRestoring)) {
-            void fetchOptimistic(options, queryObserver, errorResetBoundary)
-          }
-        }
-        return []
-      })
-    : []
-
-  if (suspensePromises.length > 0) {
-    throw Promise.all(suspensePromises)
-  }
-
-  const firstSingleResultWhichShouldThrow = optimisticResult.find(
-    (result, index) =>
-      getHasError({
-        result,
-        errorResetBoundary,
-        useErrorBoundary: defaultedQueries[index]?.useErrorBoundary ?? false,
-        query: observer.getQueries()[index]!,
-      }),
+  const firstSingleResultWhichShouldThrow = result.find((singleResult, index) =>
+    getHasError({
+      result: singleResult,
+      errorResetBoundary,
+      useErrorBoundary: defaultedQueries[index]?.useErrorBoundary ?? false,
+      query: observer.getQueries()[index]!,
+    }),
   )
 
   if (firstSingleResultWhichShouldThrow?.error) {
     throw firstSingleResultWhichShouldThrow.error
   }
 
-  return optimisticResult as QueriesResults<T>
+  return result as QueriesResults<T>
 }
