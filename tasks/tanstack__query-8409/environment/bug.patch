diff --git a/packages/angular-query-experimental/src/__tests__/inject-mutation-state.test.ts b/packages/angular-query-experimental/src/__tests__/inject-mutation-state.test.ts
index 90360ee44..f7e6cf20d 100644
--- a/packages/angular-query-experimental/src/__tests__/inject-mutation-state.test.ts
+++ b/packages/angular-query-experimental/src/__tests__/inject-mutation-state.test.ts
@@ -30,7 +30,7 @@ describe('injectMutationState', () => {
   })
 
   describe('injectMutationState', () => {
-    test('should return variables after calling mutate 1', () => {
+    test('should return variables after calling mutate 1', async () => {
       const mutationKey = ['mutation']
       const variables = 'foo123'
 
@@ -53,7 +53,7 @@ describe('injectMutationState', () => {
       expect(mutationState()).toEqual([variables])
     })
 
-    test('reactive options should update injectMutationState', () => {
+    test('reactive options should update injectMutationState', async () => {
       const mutationKey1 = ['mutation1']
       const mutationKey2 = ['mutation2']
       const variables1 = 'foo123'
@@ -87,10 +87,11 @@ describe('injectMutationState', () => {
       expect(mutationState()).toEqual([variables1])
 
       filterKey.set(mutationKey2)
+      TestBed.flushEffects()
       expect(mutationState()).toEqual([variables2])
     })
 
-    test('should return variables after calling mutate 2', () => {
+    test('should return variables after calling mutate 2', async () => {
       queryClient.clear()
       const mutationKey = ['mutation']
       const variables = 'bar234'
@@ -155,6 +156,8 @@ describe('injectMutationState', () => {
       const { debugElement } = fixture
       setFixtureSignalInputs(fixture, { name: fakeName })
 
+      fixture.detectChanges()
+
       let spans = debugElement
         .queryAll(By.css('span'))
         .map((span) => span.nativeNode.textContent)
diff --git a/packages/angular-query-experimental/src/__tests__/inject-mutation.test.ts b/packages/angular-query-experimental/src/__tests__/inject-mutation.test.ts
index 66d061b55..d44d1c40a 100644
--- a/packages/angular-query-experimental/src/__tests__/inject-mutation.test.ts
+++ b/packages/angular-query-experimental/src/__tests__/inject-mutation.test.ts
@@ -51,7 +51,7 @@ describe('injectMutation', () => {
     })
   })
 
-  test('should change state after invoking mutate', () => {
+  test('should change state after invoking mutate', async () => {
     const result = 'Mock data'
 
     const mutation = TestBed.runInInjectionContext(() => {
@@ -60,8 +60,6 @@ describe('injectMutation', () => {
       }))
     })
 
-    TestBed.flushEffects()
-
     mutation.mutate(result)
     vi.advanceTimersByTime(1)
 
@@ -81,7 +79,6 @@ describe('injectMutation', () => {
         mutationFn: errorMutator,
       }))
     })
-
     mutation.mutate({})
 
     await resolveMutations()
@@ -132,6 +129,8 @@ describe('injectMutation', () => {
 
     mutationKey.set(['2'])
 
+    TestBed.flushEffects()
+
     mutation.mutate('xyz')
 
     const mutations = mutationCache.find({ mutationKey: ['2'] })
@@ -406,8 +405,6 @@ describe('injectMutation', () => {
         }))
       })
 
-      TestBed.flushEffects()
-
       mutate()
 
       await resolveMutations()
diff --git a/packages/angular-query-experimental/src/__tests__/inject-query.test.ts b/packages/angular-query-experimental/src/__tests__/inject-query.test.ts
index a70d59e8c..f9a7dee65 100644
--- a/packages/angular-query-experimental/src/__tests__/inject-query.test.ts
+++ b/packages/angular-query-experimental/src/__tests__/inject-query.test.ts
@@ -78,7 +78,7 @@ describe('injectQuery', () => {
     const withResultInfer = TestBed.runInInjectionContext(() =>
       injectQuery(() => ({
         queryKey: key,
-        queryFn: () => true,
+        queryFn: async () => true,
       })),
     )
     expectTypeOf(withResultInfer.data()).toEqualTypeOf<boolean | undefined>()
@@ -263,6 +263,8 @@ describe('injectQuery', () => {
     expect(query.isFetching()).toBe(true)
     expect(query.isStale()).toBe(true)
     expect(query.isFetched()).toBe(false)
+
+    flush()
   }))
 
   test('should resolve to success and update signal: injectQuery()', fakeAsync(() => {
@@ -273,7 +275,7 @@ describe('injectQuery', () => {
       }))
     })
 
-    tick()
+    flush()
 
     expect(query.status()).toBe('success')
     expect(query.data()).toBe('result2')
@@ -292,7 +294,7 @@ describe('injectQuery', () => {
       }))
     })
 
-    tick()
+    flush()
 
     expect(query.status()).toBe('error')
     expect(query.data()).toBe(undefined)
@@ -314,7 +316,7 @@ describe('injectQuery', () => {
         queryFn: spy,
       }))
     })
-    tick()
+    flush()
     expect(spy).toHaveBeenCalledTimes(1)
 
     expect(query.status()).toBe('success')
@@ -329,6 +331,7 @@ describe('injectQuery', () => {
       queryKey: ['key8'],
       signal: expect.anything(),
     })
+    flush()
   }))
 
   test('should only run query once enabled signal is set to true', fakeAsync(() => {
@@ -347,7 +350,8 @@ describe('injectQuery', () => {
     expect(query.status()).toBe('pending')
 
     enabled.set(true)
-    tick()
+    TestBed.flushEffects()
+    flush()
     expect(spy).toHaveBeenCalledTimes(1)
     expect(query.status()).toBe('success')
   }))
@@ -377,6 +381,7 @@ describe('injectQuery', () => {
     expect(dependentQueryFn).not.toHaveBeenCalled()
 
     tick()
+    TestBed.flushEffects()
 
     expect(query1.data()).toStrictEqual('Some data')
     expect(query2.fetchStatus()).toStrictEqual('fetching')
@@ -414,7 +419,7 @@ describe('injectQuery', () => {
       )
     })
 
-    tick()
+    flush()
 
     keySignal.set('key12')
 
@@ -428,6 +433,8 @@ describe('injectQuery', () => {
         }),
       )
     })
+
+    flush()
   }))
 
   describe('throwOnError', () => {
@@ -464,6 +471,7 @@ describe('injectQuery', () => {
       expect(() => {
         flush()
       }).toThrowError('Some error')
+      flush()
     }))
 
     test('should throw when throwOnError function returns true', fakeAsync(() => {
@@ -478,6 +486,7 @@ describe('injectQuery', () => {
       expect(() => {
         flush()
       }).toThrowError('Some error')
+      flush()
     }))
   })
 
@@ -492,12 +501,12 @@ describe('injectQuery', () => {
 
     expect(query.status()).toBe('pending')
 
-    tick()
+    flush()
 
     expect(query.status()).toBe('error')
   }))
 
-  test('should render with required signal inputs', fakeAsync(() => {
+  test('should render with required signal inputs', fakeAsync(async () => {
     @Component({
       selector: 'app-fake',
       template: `{{ query.data() }}`,
@@ -508,7 +517,7 @@ describe('injectQuery', () => {
 
       query = injectQuery(() => ({
         queryKey: ['fake', this.name()],
-        queryFn: () => this.name(),
+        queryFn: () => Promise.resolve(this.name()),
       }))
     }
 
@@ -517,10 +526,10 @@ describe('injectQuery', () => {
       name: 'signal-input-required-test',
     })
 
+    flush()
     fixture.detectChanges()
-    tick()
 
-    expect(fixture.componentInstance.query.data()).toEqual(
+    expect(fixture.debugElement.nativeElement.textContent).toEqual(
       'signal-input-required-test',
     )
   }))
@@ -556,13 +565,13 @@ describe('injectQuery', () => {
 
     const fixture = TestBed.createComponent(FakeComponent)
     fixture.detectChanges()
-    tick()
+    flush()
 
     expect(fixture.componentInstance.query.data()).toEqual('test name')
 
     fixture.componentInstance.name.set('test name 2')
     fixture.detectChanges()
-    tick()
+    flush()
 
     expect(fixture.componentInstance.query.data()).toEqual('test name 2')
   }))
@@ -599,13 +608,13 @@ describe('injectQuery', () => {
 
     const fixture = TestBed.createComponent(FakeComponent)
     fixture.detectChanges()
-    tick()
+    flush()
 
     expect(fixture.componentInstance.query.data()).toEqual('test name')
 
     fixture.componentInstance.name.set('test name 2')
     fixture.detectChanges()
-    tick()
+    flush()
 
     expect(fixture.componentInstance.query.data()).toEqual('test name 2')
   }))
diff --git a/packages/angular-query-experimental/src/__tests__/util/lazy-init/lazy-init.test.ts b/packages/angular-query-experimental/src/__tests__/util/lazy-init/lazy-init.test.ts
new file mode 100644
index 000000000..18220d593
--- /dev/null
+++ b/packages/angular-query-experimental/src/__tests__/util/lazy-init/lazy-init.test.ts
@@ -0,0 +1,122 @@
+import { describe, expect, test } from 'vitest'
+import {
+  ChangeDetectionStrategy,
+  Component,
+  computed,
+  effect,
+  input,
+  signal,
+} from '@angular/core'
+import { TestBed } from '@angular/core/testing'
+import { setFixtureSignalInputs } from '../../test-utils'
+import { lazyInit } from '../../../util/lazy-init/lazy-init'
+import type { WritableSignal } from '@angular/core'
+
+describe('lazyInit', () => {
+  test('should init lazily in next tick when not accessing manually', async () => {
+    const mockFn = vi.fn()
+
+    TestBed.runInInjectionContext(() => {
+      lazyInit(() => {
+        mockFn()
+        return {
+          data: signal(true),
+        }
+      })
+    })
+
+    expect(mockFn).not.toHaveBeenCalled()
+
+    await new Promise(setImmediate)
+
+    expect(mockFn).toHaveBeenCalled()
+  })
+
+  test('should init eagerly accessing manually', async () => {
+    const mockFn = vi.fn()
+
+    TestBed.runInInjectionContext(() => {
+      const lazySignal = lazyInit(() => {
+        mockFn()
+        return {
+          data: signal(true),
+        }
+      })
+
+      lazySignal.data()
+    })
+
+    expect(mockFn).toHaveBeenCalled()
+  })
+
+  test('should init lazily and only once', async () => {
+    const initCallFn = vi.fn()
+    const registerDataValue = vi.fn<(arg: number) => any>()
+
+    let value!: { data: WritableSignal<number> }
+    const outerSignal = signal(0)
+
+    TestBed.runInInjectionContext(() => {
+      value = lazyInit(() => {
+        initCallFn()
+
+        void outerSignal()
+
+        return { data: signal(0) }
+      })
+
+      effect(() => registerDataValue(value.data()))
+    })
+
+    value.data()
+
+    expect(outerSignal).toBeDefined()
+
+    expect(initCallFn).toHaveBeenCalledTimes(1)
+
+    outerSignal.set(1)
+
+    TestBed.flushEffects()
+
+    outerSignal.set(2)
+    value.data.set(4)
+    TestBed.flushEffects()
+
+    expect(initCallFn).toHaveBeenCalledTimes(1)
+    expect(registerDataValue).toHaveBeenCalledTimes(2)
+  })
+
+  test('should support required signal input', async () => {
+    @Component({
+      standalone: true,
+      template: `{{ call }} - {{ lazySignal.data() }}`,
+      changeDetection: ChangeDetectionStrategy.OnPush,
+    })
+    class Test {
+      readonly title = input.required<string>()
+      call = 0
+
+      lazySignal = lazyInit(() => {
+        this.call++
+        return {
+          data: computed(() => this.title()),
+        }
+      })
+    }
+
+    const fixture = TestBed.createComponent(Test)
+
+    setFixtureSignalInputs(fixture, { title: 'newValue' })
+    expect(fixture.debugElement.nativeElement.textContent).toBe('0 - newValue')
+
+    setFixtureSignalInputs(fixture, { title: 'updatedValue' })
+    expect(fixture.debugElement.nativeElement.textContent).toBe(
+      '1 - updatedValue',
+    )
+
+    setFixtureSignalInputs(fixture, { title: 'newUpdatedValue' })
+    expect(fixture.debugElement.nativeElement.textContent).toBe(
+      '1 - newUpdatedValue',
+    )
+  })
+})
diff --git a/packages/angular-query-experimental/src/__tests__/util/lazy-signal-initializer/lazy-signal-initializer.test.ts b/packages/angular-query-experimental/src/__tests__/util/lazy-signal-initializer/lazy-signal-initializer.test.ts
new file mode 100644
index 000000000..52081c606
--- /dev/null
+++ b/packages/angular-query-experimental/src/__tests__/util/lazy-signal-initializer/lazy-signal-initializer.test.ts
@@ -0,0 +1,126 @@
+import { describe, expect, test } from 'vitest'
+import { Component, effect, input, signal } from '@angular/core'
+import { TestBed } from '@angular/core/testing'
+import { lazySignalInitializer } from '../../../util/lazy-signal-initializer/lazy-signal-initializer'
+import { setFixtureSignalInputs } from '../../test-utils'
+import type { Signal, WritableSignal } from '@angular/core'
+
+describe('lazySignalInitializer', () => {
+  test('should init lazily in next tick when not accessing manually', async () => {
+    const mockFn = vi.fn()
+
+    TestBed.runInInjectionContext(() => {
+      lazySignalInitializer(() => {
+        mockFn()
+        return signal(true)
+      })
+    })
+
+    expect(mockFn).not.toHaveBeenCalled()
+
+    await new Promise(setImmediate)
+
+    expect(mockFn).toHaveBeenCalled()
+  })
+
+  test('should init eagerly accessing manually', async () => {
+    const mockFn = vi.fn()
+
+    TestBed.runInInjectionContext(() => {
+      const lazySignal = lazySignalInitializer(() => {
+        mockFn()
+        return signal(true)
+      })
+
+      lazySignal()
+    })
+
+    expect(mockFn).toHaveBeenCalled()
+  })
+
+  test('should init lazily and only once', async () => {
+    const initCallFn = vi.fn()
+    const registerEffectValue = vi.fn<(arg: number) => any>()
+
+    let value!: Signal<number>
+    const outerSignal = signal(0)
+    let innerSignal!: WritableSignal<number>
+
+    TestBed.runInInjectionContext(() => {
+      value = lazySignalInitializer(() => {
+        initCallFn()
+        innerSignal = signal(0)
+
+        void outerSignal()
+
+        return innerSignal
+      })
+
+      effect(() => registerEffectValue(value()))
+    })
+
+    value()
+
+    TestBed.flushEffects()
+
+    expect(outerSignal).toBeDefined()
+    expect(innerSignal).toBeDefined()
+
+    expect(registerEffectValue).toHaveBeenCalledTimes(1)
+
+    expect(initCallFn).toHaveBeenCalledTimes(1)
+
+    innerSignal.set(1)
+    outerSignal.set(2)
+
+    TestBed.flushEffects()
+
+    expect(initCallFn).toHaveBeenCalledTimes(1)
+    expect(registerEffectValue).toHaveBeenCalledTimes(2)
+  })
+
+  test('should init lazily', async () => {
+    @Component({
+      standalone: true,
+      template: `{{ subscribed }}`,
+    })
+    class Test {
+      subscribed = false
+
+      lazySignal = lazySignalInitializer(() => {
+        this.subscribed = true
+        return signal('value')
+      })
+    }
+
+    const fixture = TestBed.createComponent(Test)
+    const { debugElement } = fixture
+    fixture.detectChanges()
+
+    expect(debugElement.nativeElement.textContent).toBe('false')
+
+    await new Promise(setImmediate)
+
+    fixture.detectChanges()
+
+    expect(debugElement.nativeElement.textContent).toBe('true')
+  })
+
+  test('should support required signal input', () => {
+    @Component({
+      standalone: true,
+      template: `{{ subscribed }}`,
+    })
+    class Test {
+      readonly title = input.required<string>()
+      subscribed = false
+
+      lazySignal = lazySignalInitializer(() => {
+        return signal(this.title())
+      })
+    }
+
+    const fixture = TestBed.createComponent(Test)
+    setFixtureSignalInputs(fixture, { title: 'newValue' })
+  })
+})
diff --git a/packages/angular-query-experimental/src/create-base-query.ts b/packages/angular-query-experimental/src/create-base-query.ts
index ad927a28d..c44aea231 100644
--- a/packages/angular-query-experimental/src/create-base-query.ts
+++ b/packages/angular-query-experimental/src/create-base-query.ts
@@ -12,6 +12,7 @@ import {
 import { QueryClient, notifyManager } from '@tanstack/query-core'
 import { signalProxy } from './signal-proxy'
 import { shouldThrowError } from './util'
+import { lazyInit } from './util/lazy-init/lazy-init'
 import type {
   QueryKey,
   QueryObserver,
@@ -39,75 +40,58 @@ export function createBaseQuery<
   Observer: typeof QueryObserver,
 ) {
   const injector = inject(Injector)
-  const ngZone = injector.get(NgZone)
-  const destroyRef = injector.get(DestroyRef)
-  const queryClient = injector.get(QueryClient)
+  return lazyInit(() => {
+    const ngZone = injector.get(NgZone)
+    const destroyRef = injector.get(DestroyRef)
+    const queryClient = injector.get(QueryClient)
 
-  /**
-   * Signal that has the default options from query client applied
-   * computed() is used so signals can be inserted into the options
-   * making it reactive. Wrapping options in a function ensures embedded expressions
-   * are preserved and can keep being applied after signal changes
-   */
-  const defaultedOptionsSignal = computed(() => {
-    const options = runInInjectionContext(injector, () => optionsFn())
-    const defaultedOptions = queryClient.defaultQueryOptions(options)
-    defaultedOptions._optimisticResults = 'optimistic'
-    return defaultedOptions
-  })
+    /**
+     * Signal that has the default options from query client applied
+     * computed() is used so signals can be inserted into the options
+     * making it reactive. Wrapping options in a function ensures embedded expressions
+     * are preserved and can keep being applied after signal changes
+     */
+    const defaultedOptionsSignal = computed(() => {
+      const options = runInInjectionContext(injector, () => optionsFn())
+      const defaultedOptions = queryClient.defaultQueryOptions(options)
+      defaultedOptions._optimisticResults = 'optimistic'
+      return defaultedOptions
+    })
 
-  const observerSignal = (() => {
-    let instance: QueryObserver<
+    const observer = new Observer<
       TQueryFnData,
       TError,
       TData,
       TQueryData,
       TQueryKey
-    > | null = null
-
-    return computed(() => {
-      return (instance ||= new Observer(queryClient, defaultedOptionsSignal()))
-    })
-  })()
-
-  const optimisticResultSignal = computed(() =>
-    observerSignal().getOptimisticResult(defaultedOptionsSignal()),
-  )
-
-  const resultFromSubscriberSignal = signal<QueryObserverResult<
-    TData,
-    TError
-  > | null>(null)
+    >(queryClient, defaultedOptionsSignal())
 
-  effect(
-    (onCleanup) => {
-      const observer = observerSignal()
-      const defaultedOptions = defaultedOptionsSignal()
+    const resultSignal = signal(
+      observer.getOptimisticResult(defaultedOptionsSignal()),
+    )
 
-      untracked(() => {
+    effect(
+      () => {
+        const defaultedOptions = defaultedOptionsSignal()
         observer.setOptions(defaultedOptions, {
           // Do not notify on updates because of changes in the options because
           // these changes should already be reflected in the optimistic result.
           listeners: false,
         })
-      })
-      onCleanup(() => {
-        resultFromSubscriberSignal.set(null)
-      })
-    },
-    {
-      injector,
-    },
-  )
+        untracked(() => {
+          resultSignal.set(observer.getOptimisticResult(defaultedOptions))
+        })
+      },
+      {
+        injector,
+      },
+    )
 
-  effect(() => {
     // observer.trackResult is not used as this optimization is not needed for Angular
-    const observer = observerSignal()
-
-    untracked(() => {
-      const unsubscribe = ngZone.runOutsideAngular(() =>
-        observer.subscribe(
-          notifyManager.batchCalls((state) => {
+    const unsubscribe = ngZone.runOutsideAngular(() =>
+      observer.subscribe(
+        notifyManager.batchCalls(
+          (state: QueryObserverResult<TData, TError>) => {
             ngZone.run(() => {
               if (
                 state.isError &&
@@ -120,20 +104,14 @@ export function createBaseQuery<
               ) {
                 throw state.error
               }
-              resultFromSubscriberSignal.set(state)
+              resultSignal.set(state)
             })
-          }),
+          },
         ),
-      )
-      destroyRef.onDestroy(unsubscribe)
-    })
-  })
+      ),
+    )
+    destroyRef.onDestroy(unsubscribe)
 
-  return signalProxy(
-    computed(() => {
-      const subscriberResult = resultFromSubscriberSignal()
-      const optimisticResult = optimisticResultSignal()
-      return subscriberResult ?? optimisticResult
-    }),
-  )
+    return signalProxy(resultSignal)
+  })
 }
diff --git a/packages/angular-query-experimental/src/inject-mutation-state.ts b/packages/angular-query-experimental/src/inject-mutation-state.ts
index 9bd5c61cd..e3a019a0a 100644
--- a/packages/angular-query-experimental/src/inject-mutation-state.ts
+++ b/packages/angular-query-experimental/src/inject-mutation-state.ts
@@ -1,10 +1,18 @@
-import { DestroyRef, NgZone, computed, inject, signal } from '@angular/core'
+import {
+  DestroyRef,
+  NgZone,
+  effect,
+  inject,
+  signal,
+  untracked,
+} from '@angular/core'
 import {
   QueryClient,
   notifyManager,
   replaceEqualDeep,
 } from '@tanstack/query-core'
 import { assertInjector } from './util/assert-injector/assert-injector'
+import { lazySignalInitializer } from './util/lazy-signal-initializer/lazy-signal-initializer'
 import type { Injector, Signal } from '@angular/core'
 import type {
   Mutation,
@@ -55,55 +63,42 @@ export function injectMutationState<TResult = MutationState>(
 
     const mutationCache = queryClient.getMutationCache()
 
-    /**
-     * Computed signal that gets result from mutation cache based on passed options
-     * First element is the result, second element is the time when the result was set
-     */
-    const resultFromOptionsSignal = computed(() => {
-      return [
+    return lazySignalInitializer((injector) => {
+      const result = signal<Array<TResult>>(
         getResult(mutationCache, mutationStateOptionsFn()),
-        performance.now(),
-      ] as const
-    })
+      )
 
-    /**
-     * Signal that contains result set by subscriber
-     * First element is the result, second element is the time when the result was set
-     */
-    const resultFromSubscriberSignal = signal<[Array<TResult>, number] | null>(
-      null,
-    )
+      effect(
+        () => {
+          const mutationStateOptions = mutationStateOptionsFn()
+          untracked(() => {
+            // Setting the signal from an effect because it's both 'computed' from options()
+            // and needs to be set imperatively in the mutationCache listener.
+            result.set(getResult(mutationCache, mutationStateOptions))
+          })
+        },
+        { injector },
+      )
 
-    /**
-     * Returns the last result by either subscriber or options
-     */
-    const effectiveResultSignal = computed(() => {
-      const optionsResult = resultFromOptionsSignal()
-      const subscriberResult = resultFromSubscriberSignal()
-      return subscriberResult && subscriberResult[1] > optionsResult[1]
-        ? subscriberResult[0]
-        : optionsResult[0]
-    })
+      const unsubscribe = ngZone.runOutsideAngular(() =>
+        mutationCache.subscribe(
+          notifyManager.batchCalls(() => {
+            const nextResult = replaceEqualDeep(
+              result(),
+              getResult(mutationCache, mutationStateOptionsFn()),
+            )
+            if (result() !== nextResult) {
+              ngZone.run(() => {
+                result.set(nextResult)
+              })
+            }
+          }),
+        ),
+      )
 
-    const unsubscribe = ngZone.runOutsideAngular(() =>
-      mutationCache.subscribe(
-        notifyManager.batchCalls(() => {
-          const [lastResult] = effectiveResultSignal()
-          const nextResult = replaceEqualDeep(
-            lastResult,
-            getResult(mutationCache, mutationStateOptionsFn()),
-          )
-          if (lastResult !== nextResult) {
-            ngZone.run(() => {
-              resultFromSubscriberSignal.set([nextResult, performance.now()])
-            })
-          }
-        }),
-      ),
-    )
-
-    destroyRef.onDestroy(unsubscribe)
+      destroyRef.onDestroy(unsubscribe)
 
-    return effectiveResultSignal
+      return result
+    })
   })
 }
diff --git a/packages/angular-query-experimental/src/inject-mutation.ts b/packages/angular-query-experimental/src/inject-mutation.ts
index cf6b86f38..7112c2ad3 100644
--- a/packages/angular-query-experimental/src/inject-mutation.ts
+++ b/packages/angular-query-experimental/src/inject-mutation.ts
@@ -7,7 +7,6 @@ import {
   inject,
   runInInjectionContext,
   signal,
-  untracked,
 } from '@angular/core'
 import {
   MutationObserver,
@@ -17,6 +16,8 @@ import {
 import { assertInjector } from './util/assert-injector/assert-injector'
 import { signalProxy } from './signal-proxy'
 import { noop, shouldThrowError } from './util'
+
+import { lazyInit } from './util/lazy-init/lazy-init'
 import type { DefaultError, MutationObserverResult } from '@tanstack/query-core'
 import type { CreateMutateFunction, CreateMutationResult } from './types'
 import type { CreateMutationOptions } from './mutation-options'
@@ -45,78 +46,42 @@ export function injectMutation<
     const ngZone = inject(NgZone)
     const queryClient = inject(QueryClient)
 
-    /**
-     * computed() is used so signals can be inserted into the options
-     * making it reactive. Wrapping options in a function ensures embedded expressions
-     * are preserved and can keep being applied after signal changes
-     */
-    const optionsSignal = computed(() =>
-      runInInjectionContext(currentInjector, () => optionsFn()),
-    )
-
-    const observerSignal = (() => {
-      let instance: MutationObserver<
-        TData,
-        TError,
-        TVariables,
-        TContext
-      > | null = null
-
-      return computed(() => {
-        return (instance ||= new MutationObserver(queryClient, optionsSignal()))
-      })
-    })()
-
-    const mutateFnSignal = computed<
-      CreateMutateFunction<TData, TError, TVariables, TContext>
-    >(() => {
-      const observer = observerSignal()
-      return (variables, mutateOptions) => {
-        observer.mutate(variables, mutateOptions).catch(noop)
-      }
-    })
-
-    /**
-     * Computed signal that gets result from mutation cache based on passed options
-     */
-    const resultFromInitialOptionsSignal = computed(() => {
-      const observer = observerSignal()
-      return observer.getCurrentResult()
-    })
-
-    /**
-     * Signal that contains result set by subscriber
-     */
-    const resultFromSubscriberSignal = signal<MutationObserverResult<
-      TData,
-      TError,
-      TVariables,
-      TContext
-    > | null>(null)
-
-    effect(
-      () => {
-        const observer = observerSignal()
-        const options = optionsSignal()
-
-        untracked(() => {
-          observer.setOptions(options)
+    return lazyInit(() =>
+      runInInjectionContext(currentInjector, () => {
+        const observer = new MutationObserver<
+          TData,
+          TError,
+          TVariables,
+          TContext
+        >(queryClient, optionsFn())
+        const mutate: CreateMutateFunction<
+          TData,
+          TError,
+          TVariables,
+          TContext
+        > = (variables, mutateOptions) => {
+          observer.mutate(variables, mutateOptions).catch(noop)
+        }
+
+        effect(() => {
+          observer.setOptions(
+            runInInjectionContext(currentInjector, () => optionsFn()),
+          )
         })
-      },
-      {
-        injector,
-      },
-    )
-
-    effect(
-      () => {
-        // observer.trackResult is not used as this optimization is not needed for Angular
-        const observer = observerSignal()
 
-        untracked(() => {
-          const unsubscribe = ngZone.runOutsideAngular(() =>
-            observer.subscribe(
-              notifyManager.batchCalls((state) => {
+        const result = signal(observer.getCurrentResult())
+
+        const unsubscribe = ngZone.runOutsideAngular(() =>
+          observer.subscribe(
+            notifyManager.batchCalls(
+              (
+                state: MutationObserverResult<
+                  TData,
+                  TError,
+                  TVariables,
+                  TContext
+                >,
+              ) => {
                 ngZone.run(() => {
                   if (
                     state.isError &&
@@ -126,38 +91,28 @@ export function injectMutation<
                   ) {
                     throw state.error
                   }
-
-                  resultFromSubscriberSignal.set(state)
+                  result.set(state)
                 })
-              }),
+              },
             ),
-          )
-          destroyRef.onDestroy(unsubscribe)
-        })
-      },
-      {
-        injector,
-      },
+          ),
+        )
+
+        destroyRef.onDestroy(unsubscribe)
+
+        const resultSignal = computed(() => ({
+          ...result(),
+          mutate,
+          mutateAsync: result().mutate,
+        }))
+
+        return signalProxy(resultSignal) as unknown as CreateMutationResult<
+          TData,
+          TError,
+          TVariables,
+          TContext
+        >
+      }),
     )
-
-    const resultSignal = computed(() => {
-      const resultFromSubscriber = resultFromSubscriberSignal()
-      const resultFromInitialOptions = resultFromInitialOptionsSignal()
-
-      const result = resultFromSubscriber ?? resultFromInitialOptions
-
-      return {
-        ...result,
-        mutate: mutateFnSignal(),
-        mutateAsync: result.mutate,
-      }
-    })
-
-    return signalProxy(resultSignal) as CreateMutationResult<
-      TData,
-      TError,
-      TVariables,
-      TContext
-    >
   })
 }
diff --git a/packages/angular-query-experimental/src/providers.ts b/packages/angular-query-experimental/src/providers.ts
index 42645b1b8..cd340757d 100644
--- a/packages/angular-query-experimental/src/providers.ts
+++ b/packages/angular-query-experimental/src/providers.ts
@@ -99,7 +99,6 @@ export function provideTanStackQuery(
   return makeEnvironmentProviders([
     provideQueryClient(queryClient),
     {
-      // Do not use provideEnvironmentInitializer to support Angular < v19
       provide: ENVIRONMENT_INITIALIZER,
       multi: true,
       useValue: () => {
diff --git a/packages/angular-query-experimental/src/util/lazy-init/lazy-init.ts b/packages/angular-query-experimental/src/util/lazy-init/lazy-init.ts
new file mode 100644
index 000000000..16c58429c
--- /dev/null
+++ b/packages/angular-query-experimental/src/util/lazy-init/lazy-init.ts
@@ -0,0 +1,34 @@
+import { untracked } from '@angular/core'
+
+export function lazyInit<T extends object>(initializer: () => T): T {
+  let object: T | null = null
+
+  const initializeObject = () => {
+    if (!object) {
+      object = untracked(() => initializer())
+    }
+  }
+
+  queueMicrotask(() => initializeObject())
+
+  return new Proxy<T>({} as T, {
+    get(_, prop, receiver) {
+      initializeObject()
+      return Reflect.get(object as T, prop, receiver)
+    },
+    has(_, prop) {
+      initializeObject()
+      return Reflect.has(object as T, prop)
+    },
+    ownKeys() {
+      initializeObject()
+      return Reflect.ownKeys(object as T)
+    },
+    getOwnPropertyDescriptor() {
+      return {
+        enumerable: true,
+        configurable: true,
+      }
+    },
+  })
+}
diff --git a/packages/angular-query-experimental/src/util/lazy-signal-initializer/lazy-signal-initializer.ts b/packages/angular-query-experimental/src/util/lazy-signal-initializer/lazy-signal-initializer.ts
new file mode 100644
index 000000000..64cf16839
--- /dev/null
+++ b/packages/angular-query-experimental/src/util/lazy-signal-initializer/lazy-signal-initializer.ts
@@ -0,0 +1,23 @@
+import { Injector, computed, inject, untracked } from '@angular/core'
+import type { Signal } from '@angular/core'
+
+type SignalInitializerFn<T> = (injector: Injector) => Signal<T>
+
+export function lazySignalInitializer<T>(
+  initializerFn: SignalInitializerFn<T>,
+) {
+  const injector = inject(Injector)
+
+  let source: Signal<T> | null = null
+
+  const unwrapSignal = () => {
+    if (!source) {
+      source = untracked(() => initializerFn(injector))
+    }
+    return source()
+  }
+
+  queueMicrotask(() => unwrapSignal())
+
+  return computed(unwrapSignal)
+}
