diff --git a/.changeset/balanced-bananas-balloon.md b/.changeset/balanced-bananas-balloon.md
deleted file mode 100644
index 37c12e9d06..0000000000
--- a/.changeset/balanced-bananas-balloon.md
+++ /dev/null
@@ -1,5 +0,0 @@
----
-"@biomejs/biome": patch
----
-
-Fixed [#7999](https://github.com/biomejs/biome/issues/7999): Correctly place `await` after leading comment in auto-fix action from `noFloatingPromises` rule.
diff --git a/.changeset/forty-hornets-burn.md b/.changeset/forty-hornets-burn.md
deleted file mode 100644
index 434fa32449..0000000000
--- a/.changeset/forty-hornets-burn.md
+++ /dev/null
@@ -1,16 +0,0 @@
----
-"@biomejs/biome": patch
----
-
-Fixed [#7876](https://github.com/biomejs/biome/issues/7876): The [`noUnusedImports`](https://biomejs.dev/linter/rules/no-unused-imports/) rule now ignores imports that are used by @linkcode and @linkplain (previously supported @link and @see).
-
-The following code will no longer be a false positive:
-
-```js
-import type { a } from "a"
-
-/**
- * {@linkcode a}
- */
-function func() {}
-```
diff --git a/.changeset/lovely-sloths-chew.md b/.changeset/lovely-sloths-chew.md
deleted file mode 100644
index 3475eab21d..0000000000
--- a/.changeset/lovely-sloths-chew.md
+++ /dev/null
@@ -1,20 +0,0 @@
----
-"@biomejs/biome": patch
----
-
-Improved the detection of the rule `noUnnecessaryConditions`. Now the rule isn't triggered for variables that are mutated inside a module.
-
-This logic deviates from the original rule, hence `noUnnecessaryConditions` is now marked as "inspired".
-
-In the following example, `hey` starts as `false`, but then it's assigned to a string. The rule isn't triggered inside the `if` check.
-
-```js
-let hey = false;
-
-function test() {
-    hey = "string";
-}
-
-if (hey) {}
-
-```
diff --git a/.changeset/upset-cameras-walk.md b/.changeset/upset-cameras-walk.md
deleted file mode 100644
index 4927e92413..0000000000
--- a/.changeset/upset-cameras-walk.md
+++ /dev/null
@@ -1,5 +0,0 @@
----
-"@biomejs/biome": patch
----
-
-Improved the type inference engine, by resolving types for variables that are assigned to multiple values.
diff --git a/.changeset/use-vue-valid-v-text-rule.md b/.changeset/use-vue-valid-v-text-rule.md
deleted file mode 100644
index 2d4349737a..0000000000
--- a/.changeset/use-vue-valid-v-text-rule.md
+++ /dev/null
@@ -1,13 +0,0 @@
----
-"@biomejs/biome": patch
----
-
-Added the `useVueValidVText` lint rule to enforce valid `v-text` directives. The rule reports when `v-text` has an argument, has modifiers, or is missing a value.
-
-Invalid:
-
-```vue
-<div v-text /> <!-- missing value -->
-<div v-text:aaa="foo" /> <!-- has argument -->
-<div v-text.bbb="foo" /> <!-- has modifier -->
-```
diff --git a/.changeset/weak-houses-doubt.md b/.changeset/weak-houses-doubt.md
deleted file mode 100644
index 525568cad4..0000000000
--- a/.changeset/weak-houses-doubt.md
+++ /dev/null
@@ -1,5 +0,0 @@
----
-"@biomejs/biome": patch
----
-
-Fixed `useVueValidVHtml` so that it will now flag empty strings, e.g. `v-html=""`
diff --git a/.changeset/wise-dots-rush.md b/.changeset/wise-dots-rush.md
new file mode 100644
index 0000000000..96bdd80d32
--- /dev/null
+++ b/.changeset/wise-dots-rush.md
@@ -0,0 +1,25 @@
+---
+"@biomejs/biome": patch
+---
+
+Fixed CSS formatting of dimension units to use correct casing for `Q`, `Hz` and `kHz`.
+
+**Before:**
+
+``` css
+.cssUnits {
+  a: 1q;
+  b: 1hz;
+  c: 1khz;
+}
+```
+
+**After:**
+
+``` css
+.cssUnits {
+  a: 1Q;
+  b: 1Hz;
+  c: 1kHz;
+}
+```
diff --git a/crates/biome_cli/src/execute/migrate/eslint_any_rule_to_biome.rs b/crates/biome_cli/src/execute/migrate/eslint_any_rule_to_biome.rs
index 6b01459b21..e8f996268e 100644
--- a/crates/biome_cli/src/execute/migrate/eslint_any_rule_to_biome.rs
+++ b/crates/biome_cli/src/execute/migrate/eslint_any_rule_to_biome.rs
@@ -502,10 +502,6 @@ pub(crate) fn migrate_eslint_any_rule(
             rule.set_level(rule.level().max(rule_severity.into()));
         }
         "@typescript-eslint/no-unnecessary-condition" => {
-            if !options.include_inspired {
-                results.add(eslint_name, eslint_to_biome::RuleMigrationResult::Inspired);
-                return false;
-            }
             if !options.include_nursery {
                 results.add(eslint_name, eslint_to_biome::RuleMigrationResult::Nursery);
                 return false;
diff --git a/crates/biome_configuration/src/analyzer/linter/rules.rs b/crates/biome_configuration/src/analyzer/linter/rules.rs
index 4242737f3c..b0d66c0b7a 100644
--- a/crates/biome_configuration/src/analyzer/linter/rules.rs
+++ b/crates/biome_configuration/src/analyzer/linter/rules.rs
@@ -468,7 +468,6 @@ pub enum RuleName {
     UseVueValidVHtml,
     UseVueValidVIf,
     UseVueValidVOn,
-    UseVueValidVText,
     UseWhile,
     UseYield,
 }
@@ -858,7 +857,6 @@ impl RuleName {
             Self::UseVueValidVHtml => "useVueValidVHtml",
             Self::UseVueValidVIf => "useVueValidVIf",
             Self::UseVueValidVOn => "useVueValidVOn",
-            Self::UseVueValidVText => "useVueValidVText",
             Self::UseWhile => "useWhile",
             Self::UseYield => "useYield",
         }
@@ -1244,7 +1242,6 @@ impl RuleName {
             Self::UseVueValidVHtml => RuleGroup::Nursery,
             Self::UseVueValidVIf => RuleGroup::Nursery,
             Self::UseVueValidVOn => RuleGroup::Nursery,
-            Self::UseVueValidVText => RuleGroup::Nursery,
             Self::UseWhile => RuleGroup::Complexity,
             Self::UseYield => RuleGroup::Correctness,
         }
@@ -1639,7 +1636,6 @@ impl std::str::FromStr for RuleName {
             "useVueValidVHtml" => Ok(Self::UseVueValidVHtml),
             "useVueValidVIf" => Ok(Self::UseVueValidVIf),
             "useVueValidVOn" => Ok(Self::UseVueValidVOn),
-            "useVueValidVText" => Ok(Self::UseVueValidVText),
             "useWhile" => Ok(Self::UseWhile),
             "useYield" => Ok(Self::UseYield),
             _ => Err("This rule name doesn't exist."),
@@ -4776,7 +4772,7 @@ impl From<GroupPlainConfiguration> for Correctness {
 #[cfg_attr(feature = "schema", derive(JsonSchema))]
 #[serde(rename_all = "camelCase", default, deny_unknown_fields)]
 #[doc = r" A list of rules that belong to this group"]
-pub struct Nursery { # [doc = r" Enables the recommended rules for this group"] # [serde (skip_serializing_if = "Option::is_none")] pub recommended : Option < bool > , # [doc = "Disallow continue statements.\nSee https://biomejs.dev/linter/rules/no-continue"] # [serde (skip_serializing_if = "Option::is_none")] pub no_continue : Option < RuleConfiguration < biome_rule_options :: no_continue :: NoContinueOptions >> , # [doc = "Restrict imports of deprecated exports.\nSee https://biomejs.dev/linter/rules/no-deprecated-imports"] # [serde (skip_serializing_if = "Option::is_none")] pub no_deprecated_imports : Option < RuleConfiguration < biome_rule_options :: no_deprecated_imports :: NoDeprecatedImportsOptions >> , # [doc = "Prevent the listing of duplicate dependencies. The rule supports the following dependency groups: \"bundledDependencies\", \"bundleDependencies\", \"dependencies\", \"devDependencies\", \"overrides\", \"optionalDependencies\", and \"peerDependencies\".\nSee https://biomejs.dev/linter/rules/no-duplicate-dependencies"] # [serde (skip_serializing_if = "Option::is_none")] pub no_duplicate_dependencies : Option < RuleConfiguration < biome_rule_options :: no_duplicate_dependencies :: NoDuplicateDependenciesOptions >> , # [doc = "Disallow empty sources.\nSee https://biomejs.dev/linter/rules/no-empty-source"] # [serde (skip_serializing_if = "Option::is_none")] pub no_empty_source : Option < RuleConfiguration < biome_rule_options :: no_empty_source :: NoEmptySourceOptions >> , # [doc = "Require Promise-like statements to be handled appropriately.\nSee https://biomejs.dev/linter/rules/no-floating-promises"] # [serde (skip_serializing_if = "Option::is_none")] pub no_floating_promises : Option < RuleFixConfiguration < biome_rule_options :: no_floating_promises :: NoFloatingPromisesOptions >> , # [doc = "Disallow iterating using a for-in loop.\nSee https://biomejs.dev/linter/rules/no-for-in"] # [serde (skip_serializing_if = "Option::is_none")] pub no_for_in : Option < RuleConfiguration < biome_rule_options :: no_for_in :: NoForInOptions >> , # [doc = "Prevent import cycles.\nSee https://biomejs.dev/linter/rules/no-import-cycles"] # [serde (skip_serializing_if = "Option::is_none")] pub no_import_cycles : Option < RuleConfiguration < biome_rule_options :: no_import_cycles :: NoImportCyclesOptions >> , # [doc = "Disallows the usage of the unary operators ++ and --.\nSee https://biomejs.dev/linter/rules/no-increment-decrement"] # [serde (skip_serializing_if = "Option::is_none")] pub no_increment_decrement : Option < RuleConfiguration < biome_rule_options :: no_increment_decrement :: NoIncrementDecrementOptions >> , # [doc = "Disallow string literals inside JSX elements.\nSee https://biomejs.dev/linter/rules/no-jsx-literals"] # [serde (skip_serializing_if = "Option::is_none")] pub no_jsx_literals : Option < RuleConfiguration < biome_rule_options :: no_jsx_literals :: NoJsxLiteralsOptions >> , # [doc = "Disallow Promises to be used in places where they are almost certainly a mistake.\nSee https://biomejs.dev/linter/rules/no-misused-promises"] # [serde (skip_serializing_if = "Option::is_none")] pub no_misused_promises : Option < RuleFixConfiguration < biome_rule_options :: no_misused_promises :: NoMisusedPromisesOptions >> , # [doc = "Prevent client components from being async functions.\nSee https://biomejs.dev/linter/rules/no-next-async-client-component"] # [serde (skip_serializing_if = "Option::is_none")] pub no_next_async_client_component : Option < RuleConfiguration < biome_rule_options :: no_next_async_client_component :: NoNextAsyncClientComponentOptions >> , # [doc = "Disallow function parameters that are only used in recursive calls.\nSee https://biomejs.dev/linter/rules/no-parameters-only-used-in-recursion"] # [serde (skip_serializing_if = "Option::is_none")] pub no_parameters_only_used_in_recursion : Option < RuleFixConfiguration < biome_rule_options :: no_parameters_only_used_in_recursion :: NoParametersOnlyUsedInRecursionOptions >> , # [doc = "Replaces usages of forwardRef with passing ref as a prop.\nSee https://biomejs.dev/linter/rules/no-react-forward-ref"] # [serde (skip_serializing_if = "Option::is_none")] pub no_react_forward_ref : Option < RuleFixConfiguration < biome_rule_options :: no_react_forward_ref :: NoReactForwardRefOptions >> , # [doc = "Disallow variable declarations from shadowing variables declared in the outer scope.\nSee https://biomejs.dev/linter/rules/no-shadow"] # [serde (skip_serializing_if = "Option::is_none")] pub no_shadow : Option < RuleConfiguration < biome_rule_options :: no_shadow :: NoShadowOptions >> , # [doc = "Prevent the usage of synchronous scripts.\nSee https://biomejs.dev/linter/rules/no-sync-scripts"] # [serde (skip_serializing_if = "Option::is_none")] pub no_sync_scripts : Option < RuleConfiguration < biome_rule_options :: no_sync_scripts :: NoSyncScriptsOptions >> , # [doc = "Disallow unknown DOM properties.\nSee https://biomejs.dev/linter/rules/no-unknown-attribute"] # [serde (skip_serializing_if = "Option::is_none")] pub no_unknown_attribute : Option < RuleConfiguration < biome_rule_options :: no_unknown_attribute :: NoUnknownAttributeOptions >> , # [doc = "Disallow unnecessary type-based conditions that can be statically determined as redundant.\nSee https://biomejs.dev/linter/rules/no-unnecessary-conditions"] # [serde (skip_serializing_if = "Option::is_none")] pub no_unnecessary_conditions : Option < RuleConfiguration < biome_rule_options :: no_unnecessary_conditions :: NoUnnecessaryConditionsOptions >> , # [doc = "Warn when importing non-existing exports.\nSee https://biomejs.dev/linter/rules/no-unresolved-imports"] # [serde (skip_serializing_if = "Option::is_none")] pub no_unresolved_imports : Option < RuleConfiguration < biome_rule_options :: no_unresolved_imports :: NoUnresolvedImportsOptions >> , # [doc = "Disallow expression statements that are neither a function call nor an assignment.\nSee https://biomejs.dev/linter/rules/no-unused-expressions"] # [serde (skip_serializing_if = "Option::is_none")] pub no_unused_expressions : Option < RuleConfiguration < biome_rule_options :: no_unused_expressions :: NoUnusedExpressionsOptions >> , # [doc = "Disallow unused catch bindings.\nSee https://biomejs.dev/linter/rules/no-useless-catch-binding"] # [serde (skip_serializing_if = "Option::is_none")] pub no_useless_catch_binding : Option < RuleFixConfiguration < biome_rule_options :: no_useless_catch_binding :: NoUselessCatchBindingOptions >> , # [doc = "Disallow the use of useless undefined.\nSee https://biomejs.dev/linter/rules/no-useless-undefined"] # [serde (skip_serializing_if = "Option::is_none")] pub no_useless_undefined : Option < RuleFixConfiguration < biome_rule_options :: no_useless_undefined :: NoUselessUndefinedOptions >> , # [doc = "Enforce that Vue component data options are declared as functions.\nSee https://biomejs.dev/linter/rules/no-vue-data-object-declaration"] # [serde (skip_serializing_if = "Option::is_none")] pub no_vue_data_object_declaration : Option < RuleFixConfiguration < biome_rule_options :: no_vue_data_object_declaration :: NoVueDataObjectDeclarationOptions >> , # [doc = "Disallow duplicate keys in Vue component data, methods, computed properties, and other options.\nSee https://biomejs.dev/linter/rules/no-vue-duplicate-keys"] # [serde (skip_serializing_if = "Option::is_none")] pub no_vue_duplicate_keys : Option < RuleConfiguration < biome_rule_options :: no_vue_duplicate_keys :: NoVueDuplicateKeysOptions >> , # [doc = "Disallow reserved keys in Vue component data and computed properties.\nSee https://biomejs.dev/linter/rules/no-vue-reserved-keys"] # [serde (skip_serializing_if = "Option::is_none")] pub no_vue_reserved_keys : Option < RuleConfiguration < biome_rule_options :: no_vue_reserved_keys :: NoVueReservedKeysOptions >> , # [doc = "Disallow reserved names to be used as props.\nSee https://biomejs.dev/linter/rules/no-vue-reserved-props"] # [serde (skip_serializing_if = "Option::is_none")] pub no_vue_reserved_props : Option < RuleConfiguration < biome_rule_options :: no_vue_reserved_props :: NoVueReservedPropsOptions >> , # [doc = "Disallow using v-if and v-for directives on the same element.\nSee https://biomejs.dev/linter/rules/no-vue-v-if-with-v-for"] # [serde (skip_serializing_if = "Option::is_none")] pub no_vue_v_if_with_v_for : Option < RuleConfiguration < biome_rule_options :: no_vue_v_if_with_v_for :: NoVueVIfWithVForOptions >> , # [doc = "Require Array#sort and Array#toSorted calls to always provide a compareFunction.\nSee https://biomejs.dev/linter/rules/use-array-sort-compare"] # [serde (skip_serializing_if = "Option::is_none")] pub use_array_sort_compare : Option < RuleConfiguration < biome_rule_options :: use_array_sort_compare :: UseArraySortCompareOptions >> , # [doc = "Enforce consistent arrow function bodies.\nSee https://biomejs.dev/linter/rules/use-consistent-arrow-return"] # [serde (skip_serializing_if = "Option::is_none")] pub use_consistent_arrow_return : Option < RuleFixConfiguration < biome_rule_options :: use_consistent_arrow_return :: UseConsistentArrowReturnOptions >> , # [doc = "Require all descriptions to follow the same style (either block or inline) to  maintain consistency and improve readability across the schema.\nSee https://biomejs.dev/linter/rules/use-consistent-graphql-descriptions"] # [serde (skip_serializing_if = "Option::is_none")] pub use_consistent_graphql_descriptions : Option < RuleConfiguration < biome_rule_options :: use_consistent_graphql_descriptions :: UseConsistentGraphqlDescriptionsOptions >> , # [doc = "Require the @deprecated directive to specify a deletion date.\nSee https://biomejs.dev/linter/rules/use-deprecated-date"] # [serde (skip_serializing_if = "Option::is_none")] pub use_deprecated_date : Option < RuleConfiguration < biome_rule_options :: use_deprecated_date :: UseDeprecatedDateOptions >> , # [doc = "Require switch-case statements to be exhaustive.\nSee https://biomejs.dev/linter/rules/use-exhaustive-switch-cases"] # [serde (skip_serializing_if = "Option::is_none")] pub use_exhaustive_switch_cases : Option < RuleFixConfiguration < biome_rule_options :: use_exhaustive_switch_cases :: UseExhaustiveSwitchCasesOptions >> , # [doc = "Enforce types in functions, methods, variables, and parameters.\nSee https://biomejs.dev/linter/rules/use-explicit-type"] # [serde (skip_serializing_if = "Option::is_none")] pub use_explicit_type : Option < RuleConfiguration < biome_rule_options :: use_explicit_type :: UseExplicitTypeOptions >> , # [doc = "Enforce the use of Array.prototype.find() over Array.prototype.filter() followed by [0] when looking for a single result.\nSee https://biomejs.dev/linter/rules/use-find"] # [serde (skip_serializing_if = "Option::is_none")] pub use_find : Option < RuleConfiguration < biome_rule_options :: use_find :: UseFindOptions >> , # [doc = "Enforce a maximum number of parameters in function definitions.\nSee https://biomejs.dev/linter/rules/use-max-params"] # [serde (skip_serializing_if = "Option::is_none")] pub use_max_params : Option < RuleConfiguration < biome_rule_options :: use_max_params :: UseMaxParamsOptions >> , # [doc = "Disallow use* hooks outside of component$ or other use* hooks in Qwik applications.\nSee https://biomejs.dev/linter/rules/use-qwik-method-usage"] # [serde (skip_serializing_if = "Option::is_none")] pub use_qwik_method_usage : Option < RuleConfiguration < biome_rule_options :: use_qwik_method_usage :: UseQwikMethodUsageOptions >> , # [doc = "Disallow unserializable expressions in Qwik dollar ($) scopes.\nSee https://biomejs.dev/linter/rules/use-qwik-valid-lexical-scope"] # [serde (skip_serializing_if = "Option::is_none")] pub use_qwik_valid_lexical_scope : Option < RuleConfiguration < biome_rule_options :: use_qwik_valid_lexical_scope :: UseQwikValidLexicalScopeOptions >> , # [doc = "Enforce the sorting of CSS utility classes.\nSee https://biomejs.dev/linter/rules/use-sorted-classes"] # [serde (skip_serializing_if = "Option::is_none")] pub use_sorted_classes : Option < RuleFixConfiguration < biome_rule_options :: use_sorted_classes :: UseSortedClassesOptions >> , # [doc = "Enforce the use of the spread operator over .apply().\nSee https://biomejs.dev/linter/rules/use-spread"] # [serde (skip_serializing_if = "Option::is_none")] pub use_spread : Option < RuleFixConfiguration < biome_rule_options :: use_spread :: UseSpreadOptions >> , # [doc = "Enforce unique operation names across a GraphQL document.\nSee https://biomejs.dev/linter/rules/use-unique-graphql-operation-name"] # [serde (skip_serializing_if = "Option::is_none")] pub use_unique_graphql_operation_name : Option < RuleConfiguration < biome_rule_options :: use_unique_graphql_operation_name :: UseUniqueGraphqlOperationNameOptions >> , # [doc = "Enforce specific order of Vue compiler macros.\nSee https://biomejs.dev/linter/rules/use-vue-define-macros-order"] # [serde (skip_serializing_if = "Option::is_none")] pub use_vue_define_macros_order : Option < RuleFixConfiguration < biome_rule_options :: use_vue_define_macros_order :: UseVueDefineMacrosOrderOptions >> , # [doc = "Enforce hyphenated (kebab-case) attribute names in Vue templates.\nSee https://biomejs.dev/linter/rules/use-vue-hyphenated-attributes"] # [serde (skip_serializing_if = "Option::is_none")] pub use_vue_hyphenated_attributes : Option < RuleFixConfiguration < biome_rule_options :: use_vue_hyphenated_attributes :: UseVueHyphenatedAttributesOptions >> , # [doc = "Enforce multi-word component names in Vue components.\nSee https://biomejs.dev/linter/rules/use-vue-multi-word-component-names"] # [serde (skip_serializing_if = "Option::is_none")] pub use_vue_multi_word_component_names : Option < RuleConfiguration < biome_rule_options :: use_vue_multi_word_component_names :: UseVueMultiWordComponentNamesOptions >> , # [doc = "Forbids v-bind directives with missing arguments or invalid modifiers.\nSee https://biomejs.dev/linter/rules/use-vue-valid-v-bind"] # [serde (skip_serializing_if = "Option::is_none")] pub use_vue_valid_v_bind : Option < RuleConfiguration < biome_rule_options :: use_vue_valid_v_bind :: UseVueValidVBindOptions >> , # [doc = "Enforce valid usage of v-else.\nSee https://biomejs.dev/linter/rules/use-vue-valid-v-else"] # [serde (skip_serializing_if = "Option::is_none")] pub use_vue_valid_v_else : Option < RuleConfiguration < biome_rule_options :: use_vue_valid_v_else :: UseVueValidVElseOptions >> , # [doc = "Enforce valid v-else-if directives.\nSee https://biomejs.dev/linter/rules/use-vue-valid-v-else-if"] # [serde (skip_serializing_if = "Option::is_none")] pub use_vue_valid_v_else_if : Option < RuleConfiguration < biome_rule_options :: use_vue_valid_v_else_if :: UseVueValidVElseIfOptions >> , # [doc = "Enforce valid v-html directives.\nSee https://biomejs.dev/linter/rules/use-vue-valid-v-html"] # [serde (skip_serializing_if = "Option::is_none")] pub use_vue_valid_v_html : Option < RuleConfiguration < biome_rule_options :: use_vue_valid_v_html :: UseVueValidVHtmlOptions >> , # [doc = "Enforces valid v-if usage for Vue templates.\nSee https://biomejs.dev/linter/rules/use-vue-valid-v-if"] # [serde (skip_serializing_if = "Option::is_none")] pub use_vue_valid_v_if : Option < RuleConfiguration < biome_rule_options :: use_vue_valid_v_if :: UseVueValidVIfOptions >> , # [doc = "Enforce valid v-on directives with proper arguments, modifiers, and handlers.\nSee https://biomejs.dev/linter/rules/use-vue-valid-v-on"] # [serde (skip_serializing_if = "Option::is_none")] pub use_vue_valid_v_on : Option < RuleConfiguration < biome_rule_options :: use_vue_valid_v_on :: UseVueValidVOnOptions >> , # [doc = "Enforce valid v-text Vue directives.\nSee https://biomejs.dev/linter/rules/use-vue-valid-v-text"] # [serde (skip_serializing_if = "Option::is_none")] pub use_vue_valid_v_text : Option < RuleConfiguration < biome_rule_options :: use_vue_valid_v_text :: UseVueValidVTextOptions >> }
+pub struct Nursery { # [doc = r" Enables the recommended rules for this group"] # [serde (skip_serializing_if = "Option::is_none")] pub recommended : Option < bool > , # [doc = "Disallow continue statements.\nSee https://biomejs.dev/linter/rules/no-continue"] # [serde (skip_serializing_if = "Option::is_none")] pub no_continue : Option < RuleConfiguration < biome_rule_options :: no_continue :: NoContinueOptions >> , # [doc = "Restrict imports of deprecated exports.\nSee https://biomejs.dev/linter/rules/no-deprecated-imports"] # [serde (skip_serializing_if = "Option::is_none")] pub no_deprecated_imports : Option < RuleConfiguration < biome_rule_options :: no_deprecated_imports :: NoDeprecatedImportsOptions >> , # [doc = "Prevent the listing of duplicate dependencies. The rule supports the following dependency groups: \"bundledDependencies\", \"bundleDependencies\", \"dependencies\", \"devDependencies\", \"overrides\", \"optionalDependencies\", and \"peerDependencies\".\nSee https://biomejs.dev/linter/rules/no-duplicate-dependencies"] # [serde (skip_serializing_if = "Option::is_none")] pub no_duplicate_dependencies : Option < RuleConfiguration < biome_rule_options :: no_duplicate_dependencies :: NoDuplicateDependenciesOptions >> , # [doc = "Disallow empty sources.\nSee https://biomejs.dev/linter/rules/no-empty-source"] # [serde (skip_serializing_if = "Option::is_none")] pub no_empty_source : Option < RuleConfiguration < biome_rule_options :: no_empty_source :: NoEmptySourceOptions >> , # [doc = "Require Promise-like statements to be handled appropriately.\nSee https://biomejs.dev/linter/rules/no-floating-promises"] # [serde (skip_serializing_if = "Option::is_none")] pub no_floating_promises : Option < RuleFixConfiguration < biome_rule_options :: no_floating_promises :: NoFloatingPromisesOptions >> , # [doc = "Disallow iterating using a for-in loop.\nSee https://biomejs.dev/linter/rules/no-for-in"] # [serde (skip_serializing_if = "Option::is_none")] pub no_for_in : Option < RuleConfiguration < biome_rule_options :: no_for_in :: NoForInOptions >> , # [doc = "Prevent import cycles.\nSee https://biomejs.dev/linter/rules/no-import-cycles"] # [serde (skip_serializing_if = "Option::is_none")] pub no_import_cycles : Option < RuleConfiguration < biome_rule_options :: no_import_cycles :: NoImportCyclesOptions >> , # [doc = "Disallows the usage of the unary operators ++ and --.\nSee https://biomejs.dev/linter/rules/no-increment-decrement"] # [serde (skip_serializing_if = "Option::is_none")] pub no_increment_decrement : Option < RuleConfiguration < biome_rule_options :: no_increment_decrement :: NoIncrementDecrementOptions >> , # [doc = "Disallow string literals inside JSX elements.\nSee https://biomejs.dev/linter/rules/no-jsx-literals"] # [serde (skip_serializing_if = "Option::is_none")] pub no_jsx_literals : Option < RuleConfiguration < biome_rule_options :: no_jsx_literals :: NoJsxLiteralsOptions >> , # [doc = "Disallow Promises to be used in places where they are almost certainly a mistake.\nSee https://biomejs.dev/linter/rules/no-misused-promises"] # [serde (skip_serializing_if = "Option::is_none")] pub no_misused_promises : Option < RuleFixConfiguration < biome_rule_options :: no_misused_promises :: NoMisusedPromisesOptions >> , # [doc = "Prevent client components from being async functions.\nSee https://biomejs.dev/linter/rules/no-next-async-client-component"] # [serde (skip_serializing_if = "Option::is_none")] pub no_next_async_client_component : Option < RuleConfiguration < biome_rule_options :: no_next_async_client_component :: NoNextAsyncClientComponentOptions >> , # [doc = "Disallow function parameters that are only used in recursive calls.\nSee https://biomejs.dev/linter/rules/no-parameters-only-used-in-recursion"] # [serde (skip_serializing_if = "Option::is_none")] pub no_parameters_only_used_in_recursion : Option < RuleFixConfiguration < biome_rule_options :: no_parameters_only_used_in_recursion :: NoParametersOnlyUsedInRecursionOptions >> , # [doc = "Replaces usages of forwardRef with passing ref as a prop.\nSee https://biomejs.dev/linter/rules/no-react-forward-ref"] # [serde (skip_serializing_if = "Option::is_none")] pub no_react_forward_ref : Option < RuleFixConfiguration < biome_rule_options :: no_react_forward_ref :: NoReactForwardRefOptions >> , # [doc = "Disallow variable declarations from shadowing variables declared in the outer scope.\nSee https://biomejs.dev/linter/rules/no-shadow"] # [serde (skip_serializing_if = "Option::is_none")] pub no_shadow : Option < RuleConfiguration < biome_rule_options :: no_shadow :: NoShadowOptions >> , # [doc = "Prevent the usage of synchronous scripts.\nSee https://biomejs.dev/linter/rules/no-sync-scripts"] # [serde (skip_serializing_if = "Option::is_none")] pub no_sync_scripts : Option < RuleConfiguration < biome_rule_options :: no_sync_scripts :: NoSyncScriptsOptions >> , # [doc = "Disallow unknown DOM properties.\nSee https://biomejs.dev/linter/rules/no-unknown-attribute"] # [serde (skip_serializing_if = "Option::is_none")] pub no_unknown_attribute : Option < RuleConfiguration < biome_rule_options :: no_unknown_attribute :: NoUnknownAttributeOptions >> , # [doc = "Disallow unnecessary type-based conditions that can be statically determined as redundant.\nSee https://biomejs.dev/linter/rules/no-unnecessary-conditions"] # [serde (skip_serializing_if = "Option::is_none")] pub no_unnecessary_conditions : Option < RuleConfiguration < biome_rule_options :: no_unnecessary_conditions :: NoUnnecessaryConditionsOptions >> , # [doc = "Warn when importing non-existing exports.\nSee https://biomejs.dev/linter/rules/no-unresolved-imports"] # [serde (skip_serializing_if = "Option::is_none")] pub no_unresolved_imports : Option < RuleConfiguration < biome_rule_options :: no_unresolved_imports :: NoUnresolvedImportsOptions >> , # [doc = "Disallow expression statements that are neither a function call nor an assignment.\nSee https://biomejs.dev/linter/rules/no-unused-expressions"] # [serde (skip_serializing_if = "Option::is_none")] pub no_unused_expressions : Option < RuleConfiguration < biome_rule_options :: no_unused_expressions :: NoUnusedExpressionsOptions >> , # [doc = "Disallow unused catch bindings.\nSee https://biomejs.dev/linter/rules/no-useless-catch-binding"] # [serde (skip_serializing_if = "Option::is_none")] pub no_useless_catch_binding : Option < RuleFixConfiguration < biome_rule_options :: no_useless_catch_binding :: NoUselessCatchBindingOptions >> , # [doc = "Disallow the use of useless undefined.\nSee https://biomejs.dev/linter/rules/no-useless-undefined"] # [serde (skip_serializing_if = "Option::is_none")] pub no_useless_undefined : Option < RuleFixConfiguration < biome_rule_options :: no_useless_undefined :: NoUselessUndefinedOptions >> , # [doc = "Enforce that Vue component data options are declared as functions.\nSee https://biomejs.dev/linter/rules/no-vue-data-object-declaration"] # [serde (skip_serializing_if = "Option::is_none")] pub no_vue_data_object_declaration : Option < RuleFixConfiguration < biome_rule_options :: no_vue_data_object_declaration :: NoVueDataObjectDeclarationOptions >> , # [doc = "Disallow duplicate keys in Vue component data, methods, computed properties, and other options.\nSee https://biomejs.dev/linter/rules/no-vue-duplicate-keys"] # [serde (skip_serializing_if = "Option::is_none")] pub no_vue_duplicate_keys : Option < RuleConfiguration < biome_rule_options :: no_vue_duplicate_keys :: NoVueDuplicateKeysOptions >> , # [doc = "Disallow reserved keys in Vue component data and computed properties.\nSee https://biomejs.dev/linter/rules/no-vue-reserved-keys"] # [serde (skip_serializing_if = "Option::is_none")] pub no_vue_reserved_keys : Option < RuleConfiguration < biome_rule_options :: no_vue_reserved_keys :: NoVueReservedKeysOptions >> , # [doc = "Disallow reserved names to be used as props.\nSee https://biomejs.dev/linter/rules/no-vue-reserved-props"] # [serde (skip_serializing_if = "Option::is_none")] pub no_vue_reserved_props : Option < RuleConfiguration < biome_rule_options :: no_vue_reserved_props :: NoVueReservedPropsOptions >> , # [doc = "Disallow using v-if and v-for directives on the same element.\nSee https://biomejs.dev/linter/rules/no-vue-v-if-with-v-for"] # [serde (skip_serializing_if = "Option::is_none")] pub no_vue_v_if_with_v_for : Option < RuleConfiguration < biome_rule_options :: no_vue_v_if_with_v_for :: NoVueVIfWithVForOptions >> , # [doc = "Require Array#sort and Array#toSorted calls to always provide a compareFunction.\nSee https://biomejs.dev/linter/rules/use-array-sort-compare"] # [serde (skip_serializing_if = "Option::is_none")] pub use_array_sort_compare : Option < RuleConfiguration < biome_rule_options :: use_array_sort_compare :: UseArraySortCompareOptions >> , # [doc = "Enforce consistent arrow function bodies.\nSee https://biomejs.dev/linter/rules/use-consistent-arrow-return"] # [serde (skip_serializing_if = "Option::is_none")] pub use_consistent_arrow_return : Option < RuleFixConfiguration < biome_rule_options :: use_consistent_arrow_return :: UseConsistentArrowReturnOptions >> , # [doc = "Require all descriptions to follow the same style (either block or inline) to  maintain consistency and improve readability across the schema.\nSee https://biomejs.dev/linter/rules/use-consistent-graphql-descriptions"] # [serde (skip_serializing_if = "Option::is_none")] pub use_consistent_graphql_descriptions : Option < RuleConfiguration < biome_rule_options :: use_consistent_graphql_descriptions :: UseConsistentGraphqlDescriptionsOptions >> , # [doc = "Require the @deprecated directive to specify a deletion date.\nSee https://biomejs.dev/linter/rules/use-deprecated-date"] # [serde (skip_serializing_if = "Option::is_none")] pub use_deprecated_date : Option < RuleConfiguration < biome_rule_options :: use_deprecated_date :: UseDeprecatedDateOptions >> , # [doc = "Require switch-case statements to be exhaustive.\nSee https://biomejs.dev/linter/rules/use-exhaustive-switch-cases"] # [serde (skip_serializing_if = "Option::is_none")] pub use_exhaustive_switch_cases : Option < RuleFixConfiguration < biome_rule_options :: use_exhaustive_switch_cases :: UseExhaustiveSwitchCasesOptions >> , # [doc = "Enforce types in functions, methods, variables, and parameters.\nSee https://biomejs.dev/linter/rules/use-explicit-type"] # [serde (skip_serializing_if = "Option::is_none")] pub use_explicit_type : Option < RuleConfiguration < biome_rule_options :: use_explicit_type :: UseExplicitTypeOptions >> , # [doc = "Enforce the use of Array.prototype.find() over Array.prototype.filter() followed by [0] when looking for a single result.\nSee https://biomejs.dev/linter/rules/use-find"] # [serde (skip_serializing_if = "Option::is_none")] pub use_find : Option < RuleConfiguration < biome_rule_options :: use_find :: UseFindOptions >> , # [doc = "Enforce a maximum number of parameters in function definitions.\nSee https://biomejs.dev/linter/rules/use-max-params"] # [serde (skip_serializing_if = "Option::is_none")] pub use_max_params : Option < RuleConfiguration < biome_rule_options :: use_max_params :: UseMaxParamsOptions >> , # [doc = "Disallow use* hooks outside of component$ or other use* hooks in Qwik applications.\nSee https://biomejs.dev/linter/rules/use-qwik-method-usage"] # [serde (skip_serializing_if = "Option::is_none")] pub use_qwik_method_usage : Option < RuleConfiguration < biome_rule_options :: use_qwik_method_usage :: UseQwikMethodUsageOptions >> , # [doc = "Disallow unserializable expressions in Qwik dollar ($) scopes.\nSee https://biomejs.dev/linter/rules/use-qwik-valid-lexical-scope"] # [serde (skip_serializing_if = "Option::is_none")] pub use_qwik_valid_lexical_scope : Option < RuleConfiguration < biome_rule_options :: use_qwik_valid_lexical_scope :: UseQwikValidLexicalScopeOptions >> , # [doc = "Enforce the sorting of CSS utility classes.\nSee https://biomejs.dev/linter/rules/use-sorted-classes"] # [serde (skip_serializing_if = "Option::is_none")] pub use_sorted_classes : Option < RuleFixConfiguration < biome_rule_options :: use_sorted_classes :: UseSortedClassesOptions >> , # [doc = "Enforce the use of the spread operator over .apply().\nSee https://biomejs.dev/linter/rules/use-spread"] # [serde (skip_serializing_if = "Option::is_none")] pub use_spread : Option < RuleFixConfiguration < biome_rule_options :: use_spread :: UseSpreadOptions >> , # [doc = "Enforce unique operation names across a GraphQL document.\nSee https://biomejs.dev/linter/rules/use-unique-graphql-operation-name"] # [serde (skip_serializing_if = "Option::is_none")] pub use_unique_graphql_operation_name : Option < RuleConfiguration < biome_rule_options :: use_unique_graphql_operation_name :: UseUniqueGraphqlOperationNameOptions >> , # [doc = "Enforce specific order of Vue compiler macros.\nSee https://biomejs.dev/linter/rules/use-vue-define-macros-order"] # [serde (skip_serializing_if = "Option::is_none")] pub use_vue_define_macros_order : Option < RuleFixConfiguration < biome_rule_options :: use_vue_define_macros_order :: UseVueDefineMacrosOrderOptions >> , # [doc = "Enforce hyphenated (kebab-case) attribute names in Vue templates.\nSee https://biomejs.dev/linter/rules/use-vue-hyphenated-attributes"] # [serde (skip_serializing_if = "Option::is_none")] pub use_vue_hyphenated_attributes : Option < RuleFixConfiguration < biome_rule_options :: use_vue_hyphenated_attributes :: UseVueHyphenatedAttributesOptions >> , # [doc = "Enforce multi-word component names in Vue components.\nSee https://biomejs.dev/linter/rules/use-vue-multi-word-component-names"] # [serde (skip_serializing_if = "Option::is_none")] pub use_vue_multi_word_component_names : Option < RuleConfiguration < biome_rule_options :: use_vue_multi_word_component_names :: UseVueMultiWordComponentNamesOptions >> , # [doc = "Forbids v-bind directives with missing arguments or invalid modifiers.\nSee https://biomejs.dev/linter/rules/use-vue-valid-v-bind"] # [serde (skip_serializing_if = "Option::is_none")] pub use_vue_valid_v_bind : Option < RuleConfiguration < biome_rule_options :: use_vue_valid_v_bind :: UseVueValidVBindOptions >> , # [doc = "Enforce valid usage of v-else.\nSee https://biomejs.dev/linter/rules/use-vue-valid-v-else"] # [serde (skip_serializing_if = "Option::is_none")] pub use_vue_valid_v_else : Option < RuleConfiguration < biome_rule_options :: use_vue_valid_v_else :: UseVueValidVElseOptions >> , # [doc = "Enforce valid v-else-if directives.\nSee https://biomejs.dev/linter/rules/use-vue-valid-v-else-if"] # [serde (skip_serializing_if = "Option::is_none")] pub use_vue_valid_v_else_if : Option < RuleConfiguration < biome_rule_options :: use_vue_valid_v_else_if :: UseVueValidVElseIfOptions >> , # [doc = "Enforce valid v-html directives.\nSee https://biomejs.dev/linter/rules/use-vue-valid-v-html"] # [serde (skip_serializing_if = "Option::is_none")] pub use_vue_valid_v_html : Option < RuleConfiguration < biome_rule_options :: use_vue_valid_v_html :: UseVueValidVHtmlOptions >> , # [doc = "Enforces valid v-if usage for Vue templates.\nSee https://biomejs.dev/linter/rules/use-vue-valid-v-if"] # [serde (skip_serializing_if = "Option::is_none")] pub use_vue_valid_v_if : Option < RuleConfiguration < biome_rule_options :: use_vue_valid_v_if :: UseVueValidVIfOptions >> , # [doc = "Enforce valid v-on directives with proper arguments, modifiers, and handlers.\nSee https://biomejs.dev/linter/rules/use-vue-valid-v-on"] # [serde (skip_serializing_if = "Option::is_none")] pub use_vue_valid_v_on : Option < RuleConfiguration < biome_rule_options :: use_vue_valid_v_on :: UseVueValidVOnOptions >> }
 impl Nursery {
     const GROUP_NAME: &'static str = "nursery";
     pub(crate) const GROUP_RULES: &'static [&'static str] = &[
@@ -4828,7 +4824,6 @@ impl Nursery {
         "useVueValidVHtml",
         "useVueValidVIf",
         "useVueValidVOn",
-        "useVueValidVText",
     ];
     const RECOMMENDED_RULES_AS_FILTERS: &'static [RuleFilter<'static>] =
         &[RuleFilter::Rule(Self::GROUP_NAME, Self::GROUP_RULES[37])];
@@ -4881,7 +4876,6 @@ impl Nursery {
         RuleFilter::Rule(Self::GROUP_NAME, Self::GROUP_RULES[45]),
         RuleFilter::Rule(Self::GROUP_NAME, Self::GROUP_RULES[46]),
         RuleFilter::Rule(Self::GROUP_NAME, Self::GROUP_RULES[47]),
-        RuleFilter::Rule(Self::GROUP_NAME, Self::GROUP_RULES[48]),
     ];
 }
 impl RuleGroupExt for Nursery {
@@ -5133,11 +5127,6 @@ impl RuleGroupExt for Nursery {
         {
             index_set.insert(RuleFilter::Rule(Self::GROUP_NAME, Self::GROUP_RULES[47]));
         }
-        if let Some(rule) = self.use_vue_valid_v_text.as_ref()
-            && rule.is_enabled()
-        {
-            index_set.insert(RuleFilter::Rule(Self::GROUP_NAME, Self::GROUP_RULES[48]));
-        }
         index_set
     }
     fn get_disabled_rules(&self) -> FxHashSet<RuleFilter<'static>> {
@@ -5382,11 +5371,6 @@ impl RuleGroupExt for Nursery {
         {
             index_set.insert(RuleFilter::Rule(Self::GROUP_NAME, Self::GROUP_RULES[47]));
         }
-        if let Some(rule) = self.use_vue_valid_v_text.as_ref()
-            && rule.is_disabled()
-        {
-            index_set.insert(RuleFilter::Rule(Self::GROUP_NAME, Self::GROUP_RULES[48]));
-        }
         index_set
     }
     #[doc = r" Checks if, given a rule name, matches one of the rules contained in this category"]
@@ -5609,10 +5593,6 @@ impl RuleGroupExt for Nursery {
                 .use_vue_valid_v_on
                 .as_ref()
                 .map(|conf| (conf.level(), conf.get_options())),
-            "useVueValidVText" => self
-                .use_vue_valid_v_text
-                .as_ref()
-                .map(|conf| (conf.level(), conf.get_options())),
             _ => None,
         }
     }
@@ -5669,7 +5649,6 @@ impl From<GroupPlainConfiguration> for Nursery {
             use_vue_valid_v_html: Some(value.into()),
             use_vue_valid_v_if: Some(value.into()),
             use_vue_valid_v_on: Some(value.into()),
-            use_vue_valid_v_text: Some(value.into()),
         }
     }
 }
diff --git a/crates/biome_css_formatter/src/css/value/regular_dimension.rs b/crates/biome_css_formatter/src/css/value/regular_dimension.rs
index 01ec0f68f7..9c8ff79106 100644
--- a/crates/biome_css_formatter/src/css/value/regular_dimension.rs
+++ b/crates/biome_css_formatter/src/css/value/regular_dimension.rs
@@ -1,4 +1,4 @@
-use crate::{prelude::*, utils::string_utils::FormatTokenAsLowercase};
+use crate::{prelude::*, utils::string_utils::FormatDimensionUnit};
 use biome_css_syntax::{CssRegularDimension, CssRegularDimensionFields};
 use biome_formatter::{token::number::NumberFormatOptions, write};
 
@@ -15,7 +15,7 @@ impl FormatNodeRule<CssRegularDimension> for FormatCssRegularDimension {
             f,
             [
                 format_number_token(&value_token?, NumberFormatOptions::default()),
-                FormatTokenAsLowercase::from(unit_token?),
+                FormatDimensionUnit::from(unit_token?),
             ]
         )
     }
diff --git a/crates/biome_css_formatter/src/css/value/unknown_dimension.rs b/crates/biome_css_formatter/src/css/value/unknown_dimension.rs
index 47f1963774..16b59fc970 100644
--- a/crates/biome_css_formatter/src/css/value/unknown_dimension.rs
+++ b/crates/biome_css_formatter/src/css/value/unknown_dimension.rs
@@ -1,4 +1,7 @@
-use crate::{prelude::*, utils::string_utils::FormatTokenAsLowercase};
+use crate::{
+    prelude::*,
+    utils::string_utils::{FormatDimensionUnit, FormatTokenAsLowercase},
+};
 use biome_css_syntax::{CssUnknownDimension, CssUnknownDimensionFields};
 use biome_formatter::write;
 
@@ -15,7 +18,7 @@ impl FormatNodeRule<CssUnknownDimension> for FormatCssUnknownDimension {
             f,
             [
                 FormatTokenAsLowercase::from(value_token?),
-                FormatTokenAsLowercase::from(unit_token?),
+                FormatDimensionUnit::from(unit_token?),
             ]
         );
         var_name
diff --git a/crates/biome_css_formatter/src/utils/string_utils.rs b/crates/biome_css_formatter/src/utils/string_utils.rs
index 84fa158a2d..1ce602be98 100644
--- a/crates/biome_css_formatter/src/utils/string_utils.rs
+++ b/crates/biome_css_formatter/src/utils/string_utils.rs
@@ -296,3 +296,61 @@ impl<'token> LiteralStringNormaliser<'token> {
         }
     }
 }
+
+pub(crate) struct FormatDimensionUnit {
+    token: SyntaxToken<CssLanguage>,
+}
+
+impl From<SyntaxToken<CssLanguage>> for FormatDimensionUnit {
+    fn from(value: SyntaxToken<CssLanguage>) -> Self {
+        Self { token: value }
+    }
+}
+
+impl Format<CssFormatContext> for FormatDimensionUnit {
+    fn fmt(&self, f: &mut CssFormatter) -> FormatResult<()> {
+        let original = self.token.text_trimmed();
+
+        match original.to_ascii_lowercase_cow() {
+            Cow::Borrowed(lowercase) => {
+                if let Some(uppercase) = map_dimension_unit(lowercase) {
+                    write!(
+                        f,
+                        [format_replaced(
+                            &self.token,
+                            &text(&uppercase, self.token.text_trimmed_range().start()),
+                        )]
+                    )
+                } else {
+                    write!(f, [self.token.format()])
+                }
+            }
+
+            Cow::Owned(lowercase) => {
+                write!(
+                    f,
+                    [format_replaced(
+                        &self.token,
+                        &text(
+                            &map_dimension_unit(lowercase.as_str()).unwrap_or(lowercase),
+                            self.token.text_trimmed_range().start()
+                        ),
+                    )]
+                )
+            }
+        }
+    }
+}
+
+/// Most CSS dimension units can be formatted as lower case, but there are
+/// a few that are more commonly formatted with some uppercase characters.
+/// This maps those few cases to the correct casing. This matches the
+/// behavior of the Prettier formatter.
+fn map_dimension_unit(unit: &str) -> Option<String> {
+    match unit {
+        "hz" => Some(String::from("Hz")),
+        "khz" => Some(String::from("kHz")),
+        "q" => Some(String::from("Q")),
+        _ => None,
+    }
+}
diff --git a/crates/biome_diagnostics_categories/src/categories.rs b/crates/biome_diagnostics_categories/src/categories.rs
index d8f380a24d..1193a5906b 100644
--- a/crates/biome_diagnostics_categories/src/categories.rs
+++ b/crates/biome_diagnostics_categories/src/categories.rs
@@ -225,7 +225,6 @@ define_categories! {
     "lint/nursery/useVueValidVIf": "https://biomejs.dev/linter/rules/use-vue-valid-v-if",
     "lint/nursery/useVueValidVModel": "https://biomejs.dev/linter/rules/use-vue-valid-v-model",
     "lint/nursery/useVueValidVOn": "https://biomejs.dev/linter/rules/use-vue-valid-v-on",
-    "lint/nursery/useVueValidVText": "https://biomejs.dev/linter/rules/use-vue-valid-v-text",
     "lint/performance/noAccumulatingSpread": "https://biomejs.dev/linter/rules/no-accumulating-spread",
     "lint/performance/noAwaitInLoops": "https://biomejs.dev/linter/rules/no-await-in-loops",
     "lint/performance/noBarrelFile": "https://biomejs.dev/linter/rules/no-barrel-file",
diff --git a/crates/biome_html_analyze/src/lint/nursery.rs b/crates/biome_html_analyze/src/lint/nursery.rs
index 57159a909a..3385e08d6d 100644
--- a/crates/biome_html_analyze/src/lint/nursery.rs
+++ b/crates/biome_html_analyze/src/lint/nursery.rs
@@ -12,5 +12,4 @@ pub mod use_vue_valid_v_else_if;
 pub mod use_vue_valid_v_html;
 pub mod use_vue_valid_v_if;
 pub mod use_vue_valid_v_on;
-pub mod use_vue_valid_v_text;
-declare_lint_group! { pub Nursery { name : "nursery" , rules : [self :: no_sync_scripts :: NoSyncScripts , self :: no_vue_v_if_with_v_for :: NoVueVIfWithVFor , self :: use_vue_hyphenated_attributes :: UseVueHyphenatedAttributes , self :: use_vue_valid_v_bind :: UseVueValidVBind , self :: use_vue_valid_v_else :: UseVueValidVElse , self :: use_vue_valid_v_else_if :: UseVueValidVElseIf , self :: use_vue_valid_v_html :: UseVueValidVHtml , self :: use_vue_valid_v_if :: UseVueValidVIf , self :: use_vue_valid_v_on :: UseVueValidVOn , self :: use_vue_valid_v_text :: UseVueValidVText ,] } }
+declare_lint_group! { pub Nursery { name : "nursery" , rules : [self :: no_sync_scripts :: NoSyncScripts , self :: no_vue_v_if_with_v_for :: NoVueVIfWithVFor , self :: use_vue_hyphenated_attributes :: UseVueHyphenatedAttributes , self :: use_vue_valid_v_bind :: UseVueValidVBind , self :: use_vue_valid_v_else :: UseVueValidVElse , self :: use_vue_valid_v_else_if :: UseVueValidVElseIf , self :: use_vue_valid_v_html :: UseVueValidVHtml , self :: use_vue_valid_v_if :: UseVueValidVIf , self :: use_vue_valid_v_on :: UseVueValidVOn ,] } }
diff --git a/crates/biome_html_analyze/src/lint/nursery/use_vue_valid_v_html.rs b/crates/biome_html_analyze/src/lint/nursery/use_vue_valid_v_html.rs
index ca8e6630e7..54a3015947 100644
--- a/crates/biome_html_analyze/src/lint/nursery/use_vue_valid_v_html.rs
+++ b/crates/biome_html_analyze/src/lint/nursery/use_vue_valid_v_html.rs
@@ -2,7 +2,7 @@ use biome_analyze::{
     Ast, Rule, RuleDiagnostic, RuleDomain, RuleSource, context::RuleContext, declare_lint_rule,
 };
 use biome_console::markup;
-use biome_html_syntax::{AnyHtmlAttributeInitializer, VueDirective, inner_string_text};
+use biome_html_syntax::{AnyHtmlAttributeInitializer, AnyVueDirective};
 use biome_rowan::{AstNode, AstNodeList, TextRange};
 use biome_rule_options::use_vue_valid_v_html::UseVueValidVHtmlOptions;
 
@@ -53,36 +53,54 @@ pub enum ViolationKind {
 }
 
 impl Rule for UseVueValidVHtml {
-    type Query = Ast<VueDirective>;
+    type Query = Ast<AnyVueDirective>;
     type State = ViolationKind;
     type Signals = Option<Self::State>;
     type Options = UseVueValidVHtmlOptions;
 
     fn run(ctx: &RuleContext<Self>) -> Option<Self::State> {
-        let vue_directive = ctx.query();
-        if vue_directive.name_token().ok()?.text_trimmed() != "v-html" {
-            return None;
-        }
-        if let Some(arg) = vue_directive.arg() {
-            return Some(ViolationKind::UnexpectedArgument(arg.range()));
-        }
+        let node = ctx.query();
+        match node {
+            AnyVueDirective::VueDirective(vue_directive) => {
+                if vue_directive.name_token().ok()?.text_trimmed() != "v-html" {
+                    return None;
+                }
 
-        if !vue_directive.modifiers().is_empty() {
-            let first_modifier = vue_directive.modifiers().iter().next()?;
-            return Some(ViolationKind::UnexpectedModifier(first_modifier.range()));
-        }
+                if let Some(arg) = vue_directive.arg() {
+                    return Some(ViolationKind::UnexpectedArgument(arg.range()));
+                }
+
+                if !vue_directive.modifiers().is_empty() {
+                    let first_modifier = vue_directive.modifiers().iter().next()?;
+                    return Some(ViolationKind::UnexpectedModifier(first_modifier.range()));
+                }
+
+                if let Some(initializer) = vue_directive.initializer() {
+                    // Check if value is empty
+                    if let Ok(value) = initializer.value() {
+                        if let AnyHtmlAttributeInitializer::HtmlString(html_string) = value {
+                            // Check if the string value is empty
+                            if let Ok(token) = html_string.value_token() {
+                                if token.text().is_empty() {
+                                    return Some(ViolationKind::MissingValue);
+                                }
+                            } else {
+                                // No value token means empty string
+                                return Some(ViolationKind::MissingValue);
+                            }
+                        }
+                        // Non-string values (like expressions) are valid
+                    } else {
+                        // No value at all
+                        return Some(ViolationKind::MissingValue);
+                    }
+                } else {
+                    return Some(ViolationKind::MissingValue);
+                }
 
-        if let Some(initializer) = vue_directive.initializer()
-            && let Ok(AnyHtmlAttributeInitializer::HtmlString(html_string)) = initializer.value()
-            && let Ok(token) = html_string.value_token()
-        {
-            if inner_string_text(&token).trim().is_empty() {
-                Some(ViolationKind::MissingValue)
-            } else {
                 None
             }
-        } else {
-            Some(ViolationKind::MissingValue)
+            _ => None,
         }
     }
 
diff --git a/crates/biome_html_analyze/src/lint/nursery/use_vue_valid_v_text.rs b/crates/biome_html_analyze/src/lint/nursery/use_vue_valid_v_text.rs
deleted file mode 100644
index e534b8e9f1..0000000000
--- a/crates/biome_html_analyze/src/lint/nursery/use_vue_valid_v_text.rs
+++ /dev/null
@@ -1,128 +0,0 @@
-use biome_analyze::{
-    Ast, Rule, RuleDiagnostic, RuleDomain, RuleSource, context::RuleContext, declare_lint_rule,
-};
-use biome_console::markup;
-use biome_html_syntax::{AnyHtmlAttributeInitializer, VueDirective, inner_string_text};
-use biome_rowan::{AstNode, AstNodeList, TextRange};
-use biome_rule_options::use_vue_valid_v_text::UseVueValidVTextOptions;
-
-declare_lint_rule! {
-    /// Enforce valid `v-text` Vue directives.
-    ///
-    /// This rule reports `v-text` directives in the following cases:
-    /// - The directive has an argument. E.g. `<div v-text:aaa></div>`
-    /// - The directive has any modifiers. E.g. `<div v-text.bbb></div>`
-    /// - The directive does not have a value. E.g. `<div v-text></div>`
-    ///
-    /// ## Examples
-    ///
-    /// ### Invalid
-    ///
-    /// ```vue,expect_diagnostic
-    /// <div v-text />
-    /// ```
-    ///
-    /// ```vue,expect_diagnostic
-    /// <div v-text:aaa="foo"></div>
-    /// ```
-    ///
-    /// ```vue,expect_diagnostic
-    /// <div v-text.bbb="foo"></div>
-    /// ```
-    ///
-    /// ### Valid
-    ///
-    /// ```vue
-    /// <div v-text="foo" />
-    /// ```
-    ///
-    pub UseVueValidVText {
-        version: "next",
-        name: "useVueValidVText",
-        language: "html",
-        recommended: true,
-        domains: &[RuleDomain::Vue],
-        sources: &[RuleSource::EslintVueJs("valid-v-text").same()],
-    }
-}
-
-pub enum ViolationKind {
-    UnexpectedArgument(TextRange),
-    UnexpectedModifier(TextRange),
-    MissingValue,
-}
-
-impl Rule for UseVueValidVText {
-    type Query = Ast<VueDirective>;
-    type State = ViolationKind;
-    type Signals = Option<Self::State>;
-    type Options = UseVueValidVTextOptions;
-
-    fn run(ctx: &RuleContext<Self>) -> Option<Self::State> {
-        let vue_directive = ctx.query();
-        if vue_directive.name_token().ok()?.text_trimmed() != "v-text" {
-            return None;
-        }
-
-        if let Some(arg) = vue_directive.arg() {
-            return Some(ViolationKind::UnexpectedArgument(arg.range()));
-        }
-
-        if !vue_directive.modifiers().is_empty() {
-            let first_modifier = vue_directive.modifiers().iter().next()?;
-            return Some(ViolationKind::UnexpectedModifier(first_modifier.range()));
-        }
-
-        if let Some(initializer) = vue_directive.initializer()
-            && let Ok(AnyHtmlAttributeInitializer::HtmlString(html_string)) = initializer.value()
-            && let Ok(token) = html_string.value_token()
-        {
-            if inner_string_text(&token).trim().is_empty() {
-                Some(ViolationKind::MissingValue)
-            } else {
-                None
-            }
-        } else {
-            Some(ViolationKind::MissingValue)
-        }
-    }
-
-    fn diagnostic(ctx: &RuleContext<Self>, state: &Self::State) -> Option<RuleDiagnostic> {
-        Some(
-            match state {
-                ViolationKind::UnexpectedArgument(range) => RuleDiagnostic::new(
-                    rule_category!(),
-                    range,
-                    markup! {
-                        "The v-text directive does not accept an argument."
-                    },
-                )
-                .note(markup! {
-                    "v-text directives should be used without arguments, like " <Emphasis>"v-text=\"content\""</Emphasis>"."
-                }),
-                ViolationKind::UnexpectedModifier(range) => RuleDiagnostic::new(
-                    rule_category!(),
-                    range,
-                    markup! {
-                        "The v-text directive does not support modifiers."
-                    },
-                )
-                .note(markup! {
-                    "v-text directives do not support any modifiers. Remove the modifier."
-                }),
-                ViolationKind::MissingValue => RuleDiagnostic::new(
-                    rule_category!(),
-                    ctx.query().range(),
-                    markup! {
-                        "The v-text directive is missing a value."
-                    },
-                )
-                .note(markup! {
-                    "v-text directives require a value containing the text content to render."
-                }).note(markup! {
-                    "For example, use " <Emphasis>"v-text=\"foo\""</Emphasis> " to render the content of the " <Emphasis>"foo"</Emphasis> " variable."
-                }),
-            }
-        )
-    }
-}
diff --git a/crates/biome_js_analyze/src/lint/correctness/no_unused_imports.rs b/crates/biome_js_analyze/src/lint/correctness/no_unused_imports.rs
index 2c453a1a02..e306782040 100644
--- a/crates/biome_js_analyze/src/lint/correctness/no_unused_imports.rs
+++ b/crates/biome_js_analyze/src/lint/correctness/no_unused_imports.rs
@@ -164,9 +164,8 @@ fn load_jsdoc_types_from_node(model: &mut JsDocTypeModel, node: &SyntaxNode<JsLa
     });
 }
 
-static JSDOC_INLINE_TAG_REGEX: LazyLock<Regex> = LazyLock::new(|| {
-    Regex::new(r"\{@(linkcode|linkplain|link|see)\s*([^}| #\.]+)(?:[^}]+)?\}").unwrap()
-});
+static JSDOC_INLINE_TAG_REGEX: LazyLock<Regex> =
+    LazyLock::new(|| Regex::new(r"\{@(link|see)\s*([^}| #\.]+)(?:[^}]+)?\}").unwrap());
 
 static JSDOC_TYPE_TAG_REGEX: LazyLock<Regex> =
     LazyLock::new(|| Regex::new(r"@(param|returns|type|typedef)\s*\{([^}]+)\}").unwrap());
diff --git a/crates/biome_js_analyze/src/lint/nursery/no_floating_promises.rs b/crates/biome_js_analyze/src/lint/nursery/no_floating_promises.rs
index 47762a04f5..92565c9a6e 100644
--- a/crates/biome_js_analyze/src/lint/nursery/no_floating_promises.rs
+++ b/crates/biome_js_analyze/src/lint/nursery/no_floating_promises.rs
@@ -292,10 +292,10 @@ impl Rule for NoFloatingPromises {
                     AnyJsExpression::JsAwaitExpression(make::js_await_expression(
                         make::token(JsSyntaxKind::AWAIT_KW)
                             .with_trailing_trivia([(TriviaPieceKind::Whitespace, " ")]),
-                        expression.clone().trim_comments_and_trivia()?,
+                        expression.clone().trim_leading_trivia()?,
                     ));
 
-                mutation.replace_node_transfer_trivia(expression, await_expression);
+                mutation.replace_node(expression, await_expression);
                 Some(JsRuleAction::new(
                     ctx.metadata().action_category(ctx.category(), ctx.group()),
                     ctx.metadata().applicability(),
diff --git a/crates/biome_js_analyze/src/lint/nursery/no_unnecessary_conditions.rs b/crates/biome_js_analyze/src/lint/nursery/no_unnecessary_conditions.rs
index b4f3aefa4e..f10287a65a 100644
--- a/crates/biome_js_analyze/src/lint/nursery/no_unnecessary_conditions.rs
+++ b/crates/biome_js_analyze/src/lint/nursery/no_unnecessary_conditions.rs
@@ -44,22 +44,6 @@ declare_lint_rule! {
     /// }
     /// ```
     ///
-    /// Contrary to the source rule, this rule doesn't trigger bindings that are assigned to multiple
-    /// values. In the following example, the variable `greeting` is assigned to multiple values; hence
-    /// it can't be inferred to a truthy or falsy value.
-    ///
-    /// ```ts
-    /// let greeting = false;
-    ///
-    /// function changeGreeting() {
-    ///     greeting = "Hello World!"
-    /// }
-    ///
-    /// if (greeting) {} // rule not triggered here
-    ///
-    /// ```
-    ///
-    ///
     /// ### Valid
     ///
     /// ```ts
@@ -87,7 +71,7 @@ declare_lint_rule! {
         version: "2.1.4",
         name: "noUnnecessaryConditions",
         language: "js",
-        sources: &[RuleSource::EslintTypeScript("no-unnecessary-condition").inspired()],
+        sources: &[RuleSource::EslintTypeScript("no-unnecessary-condition").same()],
         recommended: false,
         severity: Severity::Warning,
         domains: &[RuleDomain::Project],
diff --git a/crates/biome_js_type_info/src/resolver.rs b/crates/biome_js_type_info/src/resolver.rs
index 161bb9f29f..0c39dcafd6 100644
--- a/crates/biome_js_type_info/src/resolver.rs
+++ b/crates/biome_js_type_info/src/resolver.rs
@@ -722,14 +722,6 @@ pub trait TypeResolver {
         ]))))))
     }
 
-    /// Register a new type that is a union between `current_type` and `ty`
-    fn union_with(&mut self, current_type: TypeReference, ty: TypeReference) -> TypeId {
-        self.register_type(Cow::Owned(TypeData::Union(Box::new(Union(Box::new([
-            current_type,
-            ty,
-        ]))))))
-    }
-
     // #endregion
 }
 
diff --git a/crates/biome_module_graph/src/js_module_info/collector.rs b/crates/biome_module_graph/src/js_module_info/collector.rs
index d86fde17d8..d4c2d627ee 100644
--- a/crates/biome_module_graph/src/js_module_info/collector.rs
+++ b/crates/biome_module_graph/src/js_module_info/collector.rs
@@ -3,10 +3,9 @@ use std::{borrow::Cow, collections::BTreeSet, sync::Arc};
 use biome_js_semantic::{SemanticEvent, SemanticEventExtractor};
 use biome_js_syntax::{
     AnyJsCombinedSpecifier, AnyJsDeclaration, AnyJsExportDefaultDeclaration, AnyJsExpression,
-    AnyJsImportClause, JsAssignmentExpression, JsForVariableDeclaration, JsFormalParameter,
-    JsIdentifierBinding, JsRestParameter, JsSyntaxKind, JsSyntaxNode, JsSyntaxToken,
-    JsVariableDeclaration, TsIdentifierBinding, TsTypeParameter, TsTypeParameterName,
-    inner_string_text,
+    AnyJsImportClause, JsForVariableDeclaration, JsFormalParameter, JsIdentifierBinding,
+    JsRestParameter, JsSyntaxKind, JsSyntaxNode, JsSyntaxToken, JsVariableDeclaration,
+    TsIdentifierBinding, TsTypeParameter, TsTypeParameterName, inner_string_text,
 };
 use biome_js_type_info::{
     BindingId, FunctionParameter, GLOBAL_RESOLVER, GLOBAL_UNKNOWN_ID, GenericTypeParameter,
@@ -574,58 +573,34 @@ impl JsModuleInfoCollector {
         for index in 0..self.bindings.len() {
             let binding = &self.bindings[index];
             if let Some(node) = self.binding_node_by_start.get(&binding.range.start()) {
+                let name = binding.name.clone();
                 let scope_id = scope_id_for_range(scope_by_range, binding.range);
-                let ty = self.infer_type(&node.clone(), binding.clone(), scope_id);
+                let ty = self.infer_type(&node.clone(), &name, scope_id);
                 self.bindings[index].ty = ty;
             }
         }
     }
 
-    fn has_writable_reference(&self, binding: &JsBindingData) -> bool {
-        binding
-            .references
-            .iter()
-            .any(|reference| reference.is_write())
-    }
-
-    fn get_writable_references(&self, binding: &JsBindingData) -> Vec<JsBindingReference> {
-        binding
-            .references
-            .iter()
-            .filter(|reference| reference.is_write())
-            .cloned()
-            .collect()
-    }
-
     fn infer_type(
         &mut self,
         node: &JsSyntaxNode,
-        binding: JsBindingData,
+        binding_name: &Text,
         scope_id: ScopeId,
     ) -> TypeReference {
-        let binding_name = &binding.name.clone();
         for ancestor in node.ancestors() {
             if let Some(decl) = AnyJsDeclaration::cast_ref(&ancestor) {
-                let ty = if let Some(typed_bindings) = decl
+                return if let Some(typed_bindings) = decl
                     .as_js_variable_declaration()
                     .and_then(|decl| self.variable_declarations.get(decl.syntax()))
                 {
-                    let ty = typed_bindings
+                    typed_bindings
                         .iter()
                         .find_map(|(name, ty)| (name == binding_name).then(|| ty.clone()))
-                        .unwrap_or_default();
-
-                    if self.has_writable_reference(&binding) {
-                        self.widen_binding_from_writable_references(scope_id, &binding, &ty)
-                    } else {
-                        ty
-                    }
+                        .unwrap_or_default()
                 } else {
                     let data = TypeData::from_any_js_declaration(self, scope_id, &decl);
                     self.reference_to_owned_data(data)
                 };
-
-                return ty;
             } else if let Some(declaration) = AnyJsExportDefaultDeclaration::cast_ref(&ancestor) {
                 let data =
                     TypeData::from_any_js_export_default_declaration(self, scope_id, &declaration);
@@ -665,37 +640,6 @@ impl JsModuleInfoCollector {
         TypeReference::unknown()
     }
 
-    /// Widen the type of binding from its writable references.
-    fn widen_binding_from_writable_references(
-        &mut self,
-        scope_id: ScopeId,
-        binding: &JsBindingData,
-        ty: &TypeReference,
-    ) -> TypeReference {
-        let references = self.get_writable_references(binding);
-        let mut ty = ty.clone();
-        for reference in references {
-            let Some(node) = self.binding_node_by_start.get(&reference.range_start) else {
-                continue;
-            };
-            for ancestor in node.ancestors().skip(1) {
-                if let Some(assignment) = JsAssignmentExpression::cast_ref(&ancestor)
-                    && let Ok(right) = assignment.right()
-                {
-                    let data = TypeData::from_any_js_expression(self, scope_id, &right);
-                    let assigned_type = self.reference_to_owned_data(data);
-                    ty = ResolvedTypeId::new(
-                        self.level(),
-                        self.union_with(ty.clone(), assigned_type),
-                    )
-                    .into();
-                }
-            }
-        }
-
-        ty
-    }
-
     /// After the first pass of the collector, import references have been
     /// resolved to an import binding. But we can't store the information of the
     /// import target inside the `ResolvedTypeId`, because it resides in the
diff --git a/crates/biome_rowan/src/ast/batch.rs b/crates/biome_rowan/src/ast/batch.rs
index d054da1ca3..fd28078701 100644
--- a/crates/biome_rowan/src/ast/batch.rs
+++ b/crates/biome_rowan/src/ast/batch.rs
@@ -221,37 +221,6 @@ where
         self.replace_element_discard_trivia(prev_token.into(), next_token.into())
     }
 
-    /// Push a change to replace the "prev_node" with "next_node".
-    ///
-    /// - leading trivia of `prev_node`
-    /// - leading trivia of `next_node`
-    /// - trailing trivia of `prev_node`
-    /// - trailing trivia of `next_node`
-    pub fn replace_node_transfer_trivia<T>(&mut self, prev_node: T, next_node: T) -> Option<()>
-    where
-        T: AstNode<Language = L>,
-    {
-        let prev_node = prev_node.into_syntax();
-        let next_node = next_node.into_syntax();
-
-        let leading_trivia = chain_trivia_pieces(
-            prev_node.first_token()?.leading_trivia().pieces(),
-            next_node.first_token()?.leading_trivia().pieces(),
-        );
-
-        let trailing_trivia = chain_trivia_pieces(
-            prev_node.last_token()?.trailing_trivia().pieces(),
-            next_node.last_token()?.trailing_trivia().pieces(),
-        );
-        let new_node = next_node
-            .with_leading_trivia_pieces(leading_trivia)?
-            .with_trailing_trivia_pieces(trailing_trivia)?;
-
-        self.replace_element_discard_trivia(prev_node.into(), new_node.into());
-
-        Some(())
-    }
-
     /// Push a change to replace the "prev_token" with "next_token".
     ///
     /// - leading trivia of `prev_token`
diff --git a/crates/biome_rowan/src/ast/mod.rs b/crates/biome_rowan/src/ast/mod.rs
index 6d223125c3..cedb0b95d1 100644
--- a/crates/biome_rowan/src/ast/mod.rs
+++ b/crates/biome_rowan/src/ast/mod.rs
@@ -276,15 +276,6 @@ pub trait AstNode: Clone {
         Self::cast(self.into_syntax().append_trivia_pieces(trivia)?)
     }
 
-    /// Returns a new version of this node with *all* trivia stripped.
-    fn trim_comments_and_trivia(self) -> Option<Self> {
-        Self::cast(
-            self.into_syntax()
-                .with_leading_trivia_pieces([])?
-                .with_trailing_trivia_pieces([])?,
-        )
-    }
-
     /// Return a new version of this node without leading and trailing newlines and whitespaces.
     fn trim_trivia(self) -> Option<Self> {
         Self::cast(
diff --git a/crates/biome_rule_options/src/lib.rs b/crates/biome_rule_options/src/lib.rs
index b3a6f8f024..50e5653d09 100644
--- a/crates/biome_rule_options/src/lib.rs
+++ b/crates/biome_rule_options/src/lib.rs
@@ -385,6 +385,5 @@ pub mod use_vue_valid_v_else_if;
 pub mod use_vue_valid_v_html;
 pub mod use_vue_valid_v_if;
 pub mod use_vue_valid_v_on;
-pub mod use_vue_valid_v_text;
 pub mod use_while;
 pub mod use_yield;
diff --git a/crates/biome_rule_options/src/use_vue_valid_v_text.rs b/crates/biome_rule_options/src/use_vue_valid_v_text.rs
deleted file mode 100644
index 61180df996..0000000000
--- a/crates/biome_rule_options/src/use_vue_valid_v_text.rs
+++ /dev/null
@@ -1,6 +0,0 @@
-use biome_deserialize_macros::{Deserializable, Merge};
-use serde::{Deserialize, Serialize};
-#[derive(Default, Clone, Debug, Deserialize, Deserializable, Merge, Eq, PartialEq, Serialize)]
-#[cfg_attr(feature = "schema", derive(schemars::JsonSchema))]
-#[serde(rename_all = "camelCase", deny_unknown_fields, default)]
-pub struct UseVueValidVTextOptions {}
diff --git a/justfile b/justfile
index 246a0146b7..571460181d 100644
--- a/justfile
+++ b/justfile
@@ -112,11 +112,6 @@ new-html-lintrule rulename:
   cargo run -p xtask_codegen -- new-lintrule --kind=html --category=lint --name={{rulename}}
   just gen-analyzer
 
-# Creates a new html lint rule with the given name, but targets vue. Name has to be camel case.
-new-html-vue-lintrule rulename:
-  cargo run -p xtask_codegen -- new-lintrule --kind=html-vue --category=lint --name={{rulename}}
-  just gen-analyzer
-
 # Promotes a rule from the nursery group to a new group
 move-rule rulename group:
   cargo run -p xtask_codegen -- move-rule --group={{group}} --name={{rulename}}
diff --git a/packages/@biomejs/backend-jsonrpc/src/workspace.ts b/packages/@biomejs/backend-jsonrpc/src/workspace.ts
index 7176d99415..b20e6788de 100644
--- a/packages/@biomejs/backend-jsonrpc/src/workspace.ts
+++ b/packages/@biomejs/backend-jsonrpc/src/workspace.ts
@@ -2099,11 +2099,6 @@ See https://biomejs.dev/linter/rules/use-vue-valid-v-if
 See https://biomejs.dev/linter/rules/use-vue-valid-v-on 
 	 */
 	useVueValidVOn?: UseVueValidVOnConfiguration;
-	/**
-	* Enforce valid v-text Vue directives.
-See https://biomejs.dev/linter/rules/use-vue-valid-v-text 
-	 */
-	useVueValidVText?: UseVueValidVTextConfiguration;
 }
 /**
  * A list of rules that belong to this group
@@ -3672,9 +3667,6 @@ export type UseVueValidVIfConfiguration =
 export type UseVueValidVOnConfiguration =
 	| RulePlainConfiguration
 	| RuleWithUseVueValidVOnOptions;
-export type UseVueValidVTextConfiguration =
-	| RulePlainConfiguration
-	| RuleWithUseVueValidVTextOptions;
 export type NoAccumulatingSpreadConfiguration =
 	| RulePlainConfiguration
 	| RuleWithNoAccumulatingSpreadOptions;
@@ -5107,10 +5099,6 @@ export interface RuleWithUseVueValidVOnOptions {
 	level: RulePlainConfiguration;
 	options?: UseVueValidVOnOptions;
 }
-export interface RuleWithUseVueValidVTextOptions {
-	level: RulePlainConfiguration;
-	options?: UseVueValidVTextOptions;
-}
 export interface RuleWithNoAccumulatingSpreadOptions {
 	level: RulePlainConfiguration;
 	options?: NoAccumulatingSpreadOptions;
@@ -6350,7 +6338,6 @@ export interface UseVueValidVOnOptions {
 	 */
 	modifiers?: string[];
 }
-export type UseVueValidVTextOptions = {};
 export type NoAccumulatingSpreadOptions = {};
 export type NoAwaitInLoopsOptions = {};
 export type NoBarrelFileOptions = {};
@@ -7125,7 +7112,6 @@ export type Category =
 	| "lint/nursery/useVueValidVIf"
 	| "lint/nursery/useVueValidVModel"
 	| "lint/nursery/useVueValidVOn"
-	| "lint/nursery/useVueValidVText"
 	| "lint/performance/noAccumulatingSpread"
 	| "lint/performance/noAwaitInLoops"
 	| "lint/performance/noBarrelFile"
diff --git a/packages/@biomejs/biome/configuration_schema.json b/packages/@biomejs/biome/configuration_schema.json
index 4fa95b1b2a..316200db5d 100644
--- a/packages/@biomejs/biome/configuration_schema.json
+++ b/packages/@biomejs/biome/configuration_schema.json
@@ -5376,13 +5376,6 @@
 						{ "$ref": "#/$defs/UseVueValidVOnConfiguration" },
 						{ "type": "null" }
 					]
-				},
-				"useVueValidVText": {
-					"description": "Enforce valid v-text Vue directives.\nSee https://biomejs.dev/linter/rules/use-vue-valid-v-text",
-					"anyOf": [
-						{ "$ref": "#/$defs/UseVueValidVTextConfiguration" },
-						{ "type": "null" }
-					]
 				}
 			},
 			"additionalProperties": false
@@ -9484,15 +9477,6 @@
 			"additionalProperties": false,
 			"required": ["level"]
 		},
-		"RuleWithUseVueValidVTextOptions": {
-			"type": "object",
-			"properties": {
-				"level": { "$ref": "#/$defs/RulePlainConfiguration" },
-				"options": { "$ref": "#/$defs/UseVueValidVTextOptions" }
-			},
-			"additionalProperties": false,
-			"required": ["level"]
-		},
 		"RuleWithUseWhileOptions": {
 			"type": "object",
 			"properties": {
@@ -12518,16 +12502,6 @@
 			},
 			"additionalProperties": false
 		},
-		"UseVueValidVTextConfiguration": {
-			"oneOf": [
-				{ "$ref": "#/$defs/RulePlainConfiguration" },
-				{ "$ref": "#/$defs/RuleWithUseVueValidVTextOptions" }
-			]
-		},
-		"UseVueValidVTextOptions": {
-			"type": "object",
-			"additionalProperties": false
-		},
 		"UseWhileConfiguration": {
 			"oneOf": [
 				{ "$ref": "#/$defs/RulePlainConfiguration" },
diff --git a/xtask/codegen/src/generate_new_analyzer_rule.rs b/xtask/codegen/src/generate_new_analyzer_rule.rs
index b385ecca5c..87508a5906 100644
--- a/xtask/codegen/src/generate_new_analyzer_rule.rs
+++ b/xtask/codegen/src/generate_new_analyzer_rule.rs
@@ -10,7 +10,6 @@ pub enum LanguageKind {
     Css,
     Graphql,
     Html,
-    HtmlVue,
 }
 
 impl LanguageKind {
@@ -21,7 +20,6 @@ impl LanguageKind {
             Self::Css => "css",
             Self::Graphql => "graphql",
             Self::Html => "html",
-            Self::HtmlVue => "html",
         }
     }
 }
@@ -35,7 +33,6 @@ impl FromStr for LanguageKind {
             "css" => Ok(Self::Css),
             "graphql" => Ok(Self::Graphql),
             "html" => Ok(Self::Html),
-            "html-vue" => Ok(Self::HtmlVue),
             _ => Err("Unsupported value"),
         }
     }
@@ -356,81 +353,6 @@ impl Rule for {rule_name_upper_camel} {{
     type Options = {rule_name_upper_camel}Options;
 
 
-    fn run(ctx: &RuleContext<Self>) -> Option<Self::State> {{
-        let _node = ctx.query();
-        None
-    }}
-
-    fn diagnostic(ctx: &RuleContext<Self>, _state: &Self::State) -> Option<RuleDiagnostic> {{
-        //
-        // Read our guidelines to write great diagnostics:
-        // https://docs.rs/biome_analyze/latest/biome_analyze/#what-a-rule-should-say-to-the-user
-        //
-        let span = ctx.query().range();
-        Some(
-            RuleDiagnostic::new(
-                rule_category!(),
-                span,
-                markup! {{
-                    "Unexpected empty block is not allowed"
-                }},
-            )
-            .note(markup! {{
-                    "This note will give you more information."
-            }}),
-        )
-    }}
-}}
-"#
-            )
-        }
-        LanguageKind::HtmlVue => {
-            format!(
-                r#"use biome_analyze::{{context::RuleContext, {macro_name}, Ast, Rule, RuleDiagnostic, RuleDomain, RuleSource}};
-use biome_console::markup;
-use biome_html_syntax::HtmlRoot;
-use biome_rowan::AstNode;
-use biome_rule_options::{rule_name_snake_case}::{rule_name_upper_camel}Options;
-
-{macro_name}! {{
-    /// Succinct description of the rule.
-    ///
-    /// Put context and details about the rule.
-    /// As a starting point, you can take the description of the corresponding _ESLint_ rule (if any).
-    ///
-    /// Try to stay consistent with the descriptions of implemented rules.
-    ///
-    /// ## Examples
-    ///
-    /// ### Invalid
-    ///
-    /// ```vue,expect_diagnostic
-    /// <div></div>
-    /// ```
-    ///
-    /// ### Valid
-    ///
-    /// ```vue
-    /// <div>foo</div>
-    /// ```
-    ///
-    pub {rule_name_upper_camel} {{
-        version: "next",
-        name: "{rule_name_lower_camel}",
-        language: "html",
-        recommended: false,
-        domains: &[RuleDomain::Vue],
-        sources: &[RuleSource::EslintVueJs("rule-name").same()],
-    }}
-}}
-
-impl Rule for {rule_name_upper_camel} {{
-    type Query = Ast<HtmlRoot>;
-    type State = ();
-    type Signals = Option<Self::State>;
-    type Options = {rule_name_upper_camel}Options;
-
-
     fn run(ctx: &RuleContext<Self>) -> Option<Self::State> {{
         let _node = ctx.query();
         None
@@ -538,21 +460,6 @@ impl Rule for {rule_name_upper_camel} {{
 pub fn generate_new_analyzer_rule(kind: LanguageKind, category: Category, rule_name: &str) {
     let rule_name_camel = Case::Camel.convert(rule_name);
     let rule_kind = kind.as_str();
-    let test_extension = if matches!(kind, LanguageKind::HtmlVue) {
-        "vue"
-    } else {
-        rule_kind
-    };
-    let valid_contents = if matches!(kind, LanguageKind::HtmlVue) {
-        "<!-- should not generate diagnostics -->\n<div>ok</div>"
-    } else {
-        "/* should not generate diagnostics */\n// var a = 1;"
-    };
-    let invalid_contents = if matches!(kind, LanguageKind::HtmlVue) {
-        "<!-- should generate diagnostics -->\n<div></div>"
-    } else {
-        "/* should generate diagnostics */\nvar a = 1;\na = 2;\na = 3;"
-    };
     let crate_folder = project_root().join(format!("crates/biome_{rule_kind}_analyze"));
     let test_folder = crate_folder.join("tests/specs/nursery");
     let rule_folder = match &category {
@@ -620,18 +527,21 @@ pub fn generate_new_analyzer_rule(kind: LanguageKind, category: Category, rule_n
     let _ = std::fs::create_dir_all(tests_path);
 
     let test_file = format!(
-        "{}/{rule_name_camel}/valid.{test_extension}",
+        "{}/{rule_name_camel}/valid.{rule_kind}",
         test_folder.display()
     );
     if std::fs::File::open(&test_file).is_err() {
-        let _ = std::fs::write(test_file, valid_contents);
+        let _ = std::fs::write(
+            test_file,
+            "/* should not generate diagnostics */\n// var a = 1;",
+        );
     }
 
     let test_file = format!(
-        "{}/{rule_name_camel}/invalid.{test_extension}",
+        "{}/{rule_name_camel}/invalid.{rule_kind}",
         test_folder.display()
     );
     if std::fs::File::open(&test_file).is_err() {
-        let _ = std::fs::write(test_file, invalid_contents);
+        let _ = std::fs::write(test_file, "var a = 1;\na = 2;\na = 3;");
     }
 }
