diff --git a/.changeset/balanced-bananas-balloon.md b/.changeset/balanced-bananas-balloon.md
new file mode 100644
index 0000000000..37c12e9d06
--- /dev/null
+++ b/.changeset/balanced-bananas-balloon.md
@@ -0,0 +1,5 @@
+---
+"@biomejs/biome": patch
+---
+
+Fixed [#7999](https://github.com/biomejs/biome/issues/7999): Correctly place `await` after leading comment in auto-fix action from `noFloatingPromises` rule.
diff --git a/.changeset/forty-hornets-burn.md b/.changeset/forty-hornets-burn.md
new file mode 100644
index 0000000000..434fa32449
--- /dev/null
+++ b/.changeset/forty-hornets-burn.md
@@ -0,0 +1,16 @@
+---
+"@biomejs/biome": patch
+---
+
+Fixed [#7876](https://github.com/biomejs/biome/issues/7876): The [`noUnusedImports`](https://biomejs.dev/linter/rules/no-unused-imports/) rule now ignores imports that are used by @linkcode and @linkplain (previously supported @link and @see).
+
+The following code will no longer be a false positive:
+
+```js
+import type { a } from "a"
+
+/**
+ * {@linkcode a}
+ */
+function func() {}
+```
diff --git a/.changeset/lovely-sloths-chew.md b/.changeset/lovely-sloths-chew.md
new file mode 100644
index 0000000000..3475eab21d
--- /dev/null
+++ b/.changeset/lovely-sloths-chew.md
@@ -0,0 +1,20 @@
+---
+"@biomejs/biome": patch
+---
+
+Improved the detection of the rule `noUnnecessaryConditions`. Now the rule isn't triggered for variables that are mutated inside a module.
+
+This logic deviates from the original rule, hence `noUnnecessaryConditions` is now marked as "inspired".
+
+In the following example, `hey` starts as `false`, but then it's assigned to a string. The rule isn't triggered inside the `if` check.
+
+```js
+let hey = false;
+
+function test() {
+    hey = "string";
+}
+
+if (hey) {}
+
+```
diff --git a/.changeset/upset-cameras-walk.md b/.changeset/upset-cameras-walk.md
new file mode 100644
index 0000000000..4927e92413
--- /dev/null
+++ b/.changeset/upset-cameras-walk.md
@@ -0,0 +1,5 @@
+---
+"@biomejs/biome": patch
+---
+
+Improved the type inference engine, by resolving types for variables that are assigned to multiple values.
diff --git a/.changeset/use-vue-valid-v-text-rule.md b/.changeset/use-vue-valid-v-text-rule.md
new file mode 100644
index 0000000000..2d4349737a
--- /dev/null
+++ b/.changeset/use-vue-valid-v-text-rule.md
@@ -0,0 +1,13 @@
+---
+"@biomejs/biome": patch
+---
+
+Added the `useVueValidVText` lint rule to enforce valid `v-text` directives. The rule reports when `v-text` has an argument, has modifiers, or is missing a value.
+
+Invalid:
+
+```vue
+<div v-text /> <!-- missing value -->
+<div v-text:aaa="foo" /> <!-- has argument -->
+<div v-text.bbb="foo" /> <!-- has modifier -->
+```
diff --git a/.changeset/weak-houses-doubt.md b/.changeset/weak-houses-doubt.md
new file mode 100644
index 0000000000..525568cad4
--- /dev/null
+++ b/.changeset/weak-houses-doubt.md
@@ -0,0 +1,5 @@
+---
+"@biomejs/biome": patch
+---
+
+Fixed `useVueValidVHtml` so that it will now flag empty strings, e.g. `v-html=""`
diff --git a/.changeset/wise-dots-rush.md b/.changeset/wise-dots-rush.md
deleted file mode 100644
index 96bdd80d32..0000000000
--- a/.changeset/wise-dots-rush.md
+++ /dev/null
@@ -1,25 +0,0 @@
----
-"@biomejs/biome": patch
----
-
-Fixed CSS formatting of dimension units to use correct casing for `Q`, `Hz` and `kHz`.
-
-**Before:**
-
-``` css
-.cssUnits {
-  a: 1q;
-  b: 1hz;
-  c: 1khz;
-}
-```
-
-**After:**
-
-``` css
-.cssUnits {
-  a: 1Q;
-  b: 1Hz;
-  c: 1kHz;
-}
-```
diff --git a/crates/biome_cli/src/execute/migrate/eslint_any_rule_to_biome.rs b/crates/biome_cli/src/execute/migrate/eslint_any_rule_to_biome.rs
index e8f996268e..6b01459b21 100644
--- a/crates/biome_cli/src/execute/migrate/eslint_any_rule_to_biome.rs
+++ b/crates/biome_cli/src/execute/migrate/eslint_any_rule_to_biome.rs
@@ -502,6 +502,10 @@ pub(crate) fn migrate_eslint_any_rule(
             rule.set_level(rule.level().max(rule_severity.into()));
         }
         "@typescript-eslint/no-unnecessary-condition" => {
+            if !options.include_inspired {
+                results.add(eslint_name, eslint_to_biome::RuleMigrationResult::Inspired);
+                return false;
+            }
             if !options.include_nursery {
                 results.add(eslint_name, eslint_to_biome::RuleMigrationResult::Nursery);
                 return false;
diff --git a/crates/biome_configuration/src/analyzer/linter/rules.rs b/crates/biome_configuration/src/analyzer/linter/rules.rs
index b0d66c0b7a..4242737f3c 100644
--- a/crates/biome_configuration/src/analyzer/linter/rules.rs
+++ b/crates/biome_configuration/src/analyzer/linter/rules.rs
@@ -468,6 +468,7 @@ pub enum RuleName {
     UseVueValidVHtml,
     UseVueValidVIf,
     UseVueValidVOn,
+    UseVueValidVText,
     UseWhile,
     UseYield,
 }
@@ -857,6 +858,7 @@ impl RuleName {
             Self::UseVueValidVHtml => "useVueValidVHtml",
             Self::UseVueValidVIf => "useVueValidVIf",
             Self::UseVueValidVOn => "useVueValidVOn",
+            Self::UseVueValidVText => "useVueValidVText",
             Self::UseWhile => "useWhile",
             Self::UseYield => "useYield",
         }
@@ -1242,6 +1244,7 @@ impl RuleName {
             Self::UseVueValidVHtml => RuleGroup::Nursery,
             Self::UseVueValidVIf => RuleGroup::Nursery,
             Self::UseVueValidVOn => RuleGroup::Nursery,
+            Self::UseVueValidVText => RuleGroup::Nursery,
             Self::UseWhile => RuleGroup::Complexity,
             Self::UseYield => RuleGroup::Correctness,
         }
@@ -1636,6 +1639,7 @@ impl std::str::FromStr for RuleName {
             "useVueValidVHtml" => Ok(Self::UseVueValidVHtml),
             "useVueValidVIf" => Ok(Self::UseVueValidVIf),
             "useVueValidVOn" => Ok(Self::UseVueValidVOn),
+            "useVueValidVText" => Ok(Self::UseVueValidVText),
             "useWhile" => Ok(Self::UseWhile),
             "useYield" => Ok(Self::UseYield),
             _ => Err("This rule name doesn't exist."),
@@ -4772,7 +4776,7 @@ impl From<GroupPlainConfiguration> for Correctness {
 #[cfg_attr(feature = "schema", derive(JsonSchema))]
 #[serde(rename_all = "camelCase", default, deny_unknown_fields)]
 #[doc = r" A list of rules that belong to this group"]
-pub struct Nursery { # [doc = r" Enables the recommended rules for this group"] # [serde (skip_serializing_if = "Option::is_none")] pub recommended : Option < bool > , # [doc = "Disallow continue statements.\nSee https://biomejs.dev/linter/rules/no-continue"] # [serde (skip_serializing_if = "Option::is_none")] pub no_continue : Option < RuleConfiguration < biome_rule_options :: no_continue :: NoContinueOptions >> , # [doc = "Restrict imports of deprecated exports.\nSee https://biomejs.dev/linter/rules/no-deprecated-imports"] # [serde (skip_serializing_if = "Option::is_none")] pub no_deprecated_imports : Option < RuleConfiguration < biome_rule_options :: no_deprecated_imports :: NoDeprecatedImportsOptions >> , # [doc = "Prevent the listing of duplicate dependencies. The rule supports the following dependency groups: \"bundledDependencies\", \"bundleDependencies\", \"dependencies\", \"devDependencies\", \"overrides\", \"optionalDependencies\", and \"peerDependencies\".\nSee https://biomejs.dev/linter/rules/no-duplicate-dependencies"] # [serde (skip_serializing_if = "Option::is_none")] pub no_duplicate_dependencies : Option < RuleConfiguration < biome_rule_options :: no_duplicate_dependencies :: NoDuplicateDependenciesOptions >> , # [doc = "Disallow empty sources.\nSee https://biomejs.dev/linter/rules/no-empty-source"] # [serde (skip_serializing_if = "Option::is_none")] pub no_empty_source : Option < RuleConfiguration < biome_rule_options :: no_empty_source :: NoEmptySourceOptions >> , # [doc = "Require Promise-like statements to be handled appropriately.\nSee https://biomejs.dev/linter/rules/no-floating-promises"] # [serde (skip_serializing_if = "Option::is_none")] pub no_floating_promises : Option < RuleFixConfiguration < biome_rule_options :: no_floating_promises :: NoFloatingPromisesOptions >> , # [doc = "Disallow iterating using a for-in loop.\nSee https://biomejs.dev/linter/rules/no-for-in"] # [serde (skip_serializing_if = "Option::is_none")] pub no_for_in : Option < RuleConfiguration < biome_rule_options :: no_for_in :: NoForInOptions >> , # [doc = "Prevent import cycles.\nSee https://biomejs.dev/linter/rules/no-import-cycles"] # [serde (skip_serializing_if = "Option::is_none")] pub no_import_cycles : Option < RuleConfiguration < biome_rule_options :: no_import_cycles :: NoImportCyclesOptions >> , # [doc = "Disallows the usage of the unary operators ++ and --.\nSee https://biomejs.dev/linter/rules/no-increment-decrement"] # [serde (skip_serializing_if = "Option::is_none")] pub no_increment_decrement : Option < RuleConfiguration < biome_rule_options :: no_increment_decrement :: NoIncrementDecrementOptions >> , # [doc = "Disallow string literals inside JSX elements.\nSee https://biomejs.dev/linter/rules/no-jsx-literals"] # [serde (skip_serializing_if = "Option::is_none")] pub no_jsx_literals : Option < RuleConfiguration < biome_rule_options :: no_jsx_literals :: NoJsxLiteralsOptions >> , # [doc = "Disallow Promises to be used in places where they are almost certainly a mistake.\nSee https://biomejs.dev/linter/rules/no-misused-promises"] # [serde (skip_serializing_if = "Option::is_none")] pub no_misused_promises : Option < RuleFixConfiguration < biome_rule_options :: no_misused_promises :: NoMisusedPromisesOptions >> , # [doc = "Prevent client components from being async functions.\nSee https://biomejs.dev/linter/rules/no-next-async-client-component"] # [serde (skip_serializing_if = "Option::is_none")] pub no_next_async_client_component : Option < RuleConfiguration < biome_rule_options :: no_next_async_client_component :: NoNextAsyncClientComponentOptions >> , # [doc = "Disallow function parameters that are only used in recursive calls.\nSee https://biomejs.dev/linter/rules/no-parameters-only-used-in-recursion"] # [serde (skip_serializing_if = "Option::is_none")] pub no_parameters_only_used_in_recursion : Option < RuleFixConfiguration < biome_rule_options :: no_parameters_only_used_in_recursion :: NoParametersOnlyUsedInRecursionOptions >> , # [doc = "Replaces usages of forwardRef with passing ref as a prop.\nSee https://biomejs.dev/linter/rules/no-react-forward-ref"] # [serde (skip_serializing_if = "Option::is_none")] pub no_react_forward_ref : Option < RuleFixConfiguration < biome_rule_options :: no_react_forward_ref :: NoReactForwardRefOptions >> , # [doc = "Disallow variable declarations from shadowing variables declared in the outer scope.\nSee https://biomejs.dev/linter/rules/no-shadow"] # [serde (skip_serializing_if = "Option::is_none")] pub no_shadow : Option < RuleConfiguration < biome_rule_options :: no_shadow :: NoShadowOptions >> , # [doc = "Prevent the usage of synchronous scripts.\nSee https://biomejs.dev/linter/rules/no-sync-scripts"] # [serde (skip_serializing_if = "Option::is_none")] pub no_sync_scripts : Option < RuleConfiguration < biome_rule_options :: no_sync_scripts :: NoSyncScriptsOptions >> , # [doc = "Disallow unknown DOM properties.\nSee https://biomejs.dev/linter/rules/no-unknown-attribute"] # [serde (skip_serializing_if = "Option::is_none")] pub no_unknown_attribute : Option < RuleConfiguration < biome_rule_options :: no_unknown_attribute :: NoUnknownAttributeOptions >> , # [doc = "Disallow unnecessary type-based conditions that can be statically determined as redundant.\nSee https://biomejs.dev/linter/rules/no-unnecessary-conditions"] # [serde (skip_serializing_if = "Option::is_none")] pub no_unnecessary_conditions : Option < RuleConfiguration < biome_rule_options :: no_unnecessary_conditions :: NoUnnecessaryConditionsOptions >> , # [doc = "Warn when importing non-existing exports.\nSee https://biomejs.dev/linter/rules/no-unresolved-imports"] # [serde (skip_serializing_if = "Option::is_none")] pub no_unresolved_imports : Option < RuleConfiguration < biome_rule_options :: no_unresolved_imports :: NoUnresolvedImportsOptions >> , # [doc = "Disallow expression statements that are neither a function call nor an assignment.\nSee https://biomejs.dev/linter/rules/no-unused-expressions"] # [serde (skip_serializing_if = "Option::is_none")] pub no_unused_expressions : Option < RuleConfiguration < biome_rule_options :: no_unused_expressions :: NoUnusedExpressionsOptions >> , # [doc = "Disallow unused catch bindings.\nSee https://biomejs.dev/linter/rules/no-useless-catch-binding"] # [serde (skip_serializing_if = "Option::is_none")] pub no_useless_catch_binding : Option < RuleFixConfiguration < biome_rule_options :: no_useless_catch_binding :: NoUselessCatchBindingOptions >> , # [doc = "Disallow the use of useless undefined.\nSee https://biomejs.dev/linter/rules/no-useless-undefined"] # [serde (skip_serializing_if = "Option::is_none")] pub no_useless_undefined : Option < RuleFixConfiguration < biome_rule_options :: no_useless_undefined :: NoUselessUndefinedOptions >> , # [doc = "Enforce that Vue component data options are declared as functions.\nSee https://biomejs.dev/linter/rules/no-vue-data-object-declaration"] # [serde (skip_serializing_if = "Option::is_none")] pub no_vue_data_object_declaration : Option < RuleFixConfiguration < biome_rule_options :: no_vue_data_object_declaration :: NoVueDataObjectDeclarationOptions >> , # [doc = "Disallow duplicate keys in Vue component data, methods, computed properties, and other options.\nSee https://biomejs.dev/linter/rules/no-vue-duplicate-keys"] # [serde (skip_serializing_if = "Option::is_none")] pub no_vue_duplicate_keys : Option < RuleConfiguration < biome_rule_options :: no_vue_duplicate_keys :: NoVueDuplicateKeysOptions >> , # [doc = "Disallow reserved keys in Vue component data and computed properties.\nSee https://biomejs.dev/linter/rules/no-vue-reserved-keys"] # [serde (skip_serializing_if = "Option::is_none")] pub no_vue_reserved_keys : Option < RuleConfiguration < biome_rule_options :: no_vue_reserved_keys :: NoVueReservedKeysOptions >> , # [doc = "Disallow reserved names to be used as props.\nSee https://biomejs.dev/linter/rules/no-vue-reserved-props"] # [serde (skip_serializing_if = "Option::is_none")] pub no_vue_reserved_props : Option < RuleConfiguration < biome_rule_options :: no_vue_reserved_props :: NoVueReservedPropsOptions >> , # [doc = "Disallow using v-if and v-for directives on the same element.\nSee https://biomejs.dev/linter/rules/no-vue-v-if-with-v-for"] # [serde (skip_serializing_if = "Option::is_none")] pub no_vue_v_if_with_v_for : Option < RuleConfiguration < biome_rule_options :: no_vue_v_if_with_v_for :: NoVueVIfWithVForOptions >> , # [doc = "Require Array#sort and Array#toSorted calls to always provide a compareFunction.\nSee https://biomejs.dev/linter/rules/use-array-sort-compare"] # [serde (skip_serializing_if = "Option::is_none")] pub use_array_sort_compare : Option < RuleConfiguration < biome_rule_options :: use_array_sort_compare :: UseArraySortCompareOptions >> , # [doc = "Enforce consistent arrow function bodies.\nSee https://biomejs.dev/linter/rules/use-consistent-arrow-return"] # [serde (skip_serializing_if = "Option::is_none")] pub use_consistent_arrow_return : Option < RuleFixConfiguration < biome_rule_options :: use_consistent_arrow_return :: UseConsistentArrowReturnOptions >> , # [doc = "Require all descriptions to follow the same style (either block or inline) to  maintain consistency and improve readability across the schema.\nSee https://biomejs.dev/linter/rules/use-consistent-graphql-descriptions"] # [serde (skip_serializing_if = "Option::is_none")] pub use_consistent_graphql_descriptions : Option < RuleConfiguration < biome_rule_options :: use_consistent_graphql_descriptions :: UseConsistentGraphqlDescriptionsOptions >> , # [doc = "Require the @deprecated directive to specify a deletion date.\nSee https://biomejs.dev/linter/rules/use-deprecated-date"] # [serde (skip_serializing_if = "Option::is_none")] pub use_deprecated_date : Option < RuleConfiguration < biome_rule_options :: use_deprecated_date :: UseDeprecatedDateOptions >> , # [doc = "Require switch-case statements to be exhaustive.\nSee https://biomejs.dev/linter/rules/use-exhaustive-switch-cases"] # [serde (skip_serializing_if = "Option::is_none")] pub use_exhaustive_switch_cases : Option < RuleFixConfiguration < biome_rule_options :: use_exhaustive_switch_cases :: UseExhaustiveSwitchCasesOptions >> , # [doc = "Enforce types in functions, methods, variables, and parameters.\nSee https://biomejs.dev/linter/rules/use-explicit-type"] # [serde (skip_serializing_if = "Option::is_none")] pub use_explicit_type : Option < RuleConfiguration < biome_rule_options :: use_explicit_type :: UseExplicitTypeOptions >> , # [doc = "Enforce the use of Array.prototype.find() over Array.prototype.filter() followed by [0] when looking for a single result.\nSee https://biomejs.dev/linter/rules/use-find"] # [serde (skip_serializing_if = "Option::is_none")] pub use_find : Option < RuleConfiguration < biome_rule_options :: use_find :: UseFindOptions >> , # [doc = "Enforce a maximum number of parameters in function definitions.\nSee https://biomejs.dev/linter/rules/use-max-params"] # [serde (skip_serializing_if = "Option::is_none")] pub use_max_params : Option < RuleConfiguration < biome_rule_options :: use_max_params :: UseMaxParamsOptions >> , # [doc = "Disallow use* hooks outside of component$ or other use* hooks in Qwik applications.\nSee https://biomejs.dev/linter/rules/use-qwik-method-usage"] # [serde (skip_serializing_if = "Option::is_none")] pub use_qwik_method_usage : Option < RuleConfiguration < biome_rule_options :: use_qwik_method_usage :: UseQwikMethodUsageOptions >> , # [doc = "Disallow unserializable expressions in Qwik dollar ($) scopes.\nSee https://biomejs.dev/linter/rules/use-qwik-valid-lexical-scope"] # [serde (skip_serializing_if = "Option::is_none")] pub use_qwik_valid_lexical_scope : Option < RuleConfiguration < biome_rule_options :: use_qwik_valid_lexical_scope :: UseQwikValidLexicalScopeOptions >> , # [doc = "Enforce the sorting of CSS utility classes.\nSee https://biomejs.dev/linter/rules/use-sorted-classes"] # [serde (skip_serializing_if = "Option::is_none")] pub use_sorted_classes : Option < RuleFixConfiguration < biome_rule_options :: use_sorted_classes :: UseSortedClassesOptions >> , # [doc = "Enforce the use of the spread operator over .apply().\nSee https://biomejs.dev/linter/rules/use-spread"] # [serde (skip_serializing_if = "Option::is_none")] pub use_spread : Option < RuleFixConfiguration < biome_rule_options :: use_spread :: UseSpreadOptions >> , # [doc = "Enforce unique operation names across a GraphQL document.\nSee https://biomejs.dev/linter/rules/use-unique-graphql-operation-name"] # [serde (skip_serializing_if = "Option::is_none")] pub use_unique_graphql_operation_name : Option < RuleConfiguration < biome_rule_options :: use_unique_graphql_operation_name :: UseUniqueGraphqlOperationNameOptions >> , # [doc = "Enforce specific order of Vue compiler macros.\nSee https://biomejs.dev/linter/rules/use-vue-define-macros-order"] # [serde (skip_serializing_if = "Option::is_none")] pub use_vue_define_macros_order : Option < RuleFixConfiguration < biome_rule_options :: use_vue_define_macros_order :: UseVueDefineMacrosOrderOptions >> , # [doc = "Enforce hyphenated (kebab-case) attribute names in Vue templates.\nSee https://biomejs.dev/linter/rules/use-vue-hyphenated-attributes"] # [serde (skip_serializing_if = "Option::is_none")] pub use_vue_hyphenated_attributes : Option < RuleFixConfiguration < biome_rule_options :: use_vue_hyphenated_attributes :: UseVueHyphenatedAttributesOptions >> , # [doc = "Enforce multi-word component names in Vue components.\nSee https://biomejs.dev/linter/rules/use-vue-multi-word-component-names"] # [serde (skip_serializing_if = "Option::is_none")] pub use_vue_multi_word_component_names : Option < RuleConfiguration < biome_rule_options :: use_vue_multi_word_component_names :: UseVueMultiWordComponentNamesOptions >> , # [doc = "Forbids v-bind directives with missing arguments or invalid modifiers.\nSee https://biomejs.dev/linter/rules/use-vue-valid-v-bind"] # [serde (skip_serializing_if = "Option::is_none")] pub use_vue_valid_v_bind : Option < RuleConfiguration < biome_rule_options :: use_vue_valid_v_bind :: UseVueValidVBindOptions >> , # [doc = "Enforce valid usage of v-else.\nSee https://biomejs.dev/linter/rules/use-vue-valid-v-else"] # [serde (skip_serializing_if = "Option::is_none")] pub use_vue_valid_v_else : Option < RuleConfiguration < biome_rule_options :: use_vue_valid_v_else :: UseVueValidVElseOptions >> , # [doc = "Enforce valid v-else-if directives.\nSee https://biomejs.dev/linter/rules/use-vue-valid-v-else-if"] # [serde (skip_serializing_if = "Option::is_none")] pub use_vue_valid_v_else_if : Option < RuleConfiguration < biome_rule_options :: use_vue_valid_v_else_if :: UseVueValidVElseIfOptions >> , # [doc = "Enforce valid v-html directives.\nSee https://biomejs.dev/linter/rules/use-vue-valid-v-html"] # [serde (skip_serializing_if = "Option::is_none")] pub use_vue_valid_v_html : Option < RuleConfiguration < biome_rule_options :: use_vue_valid_v_html :: UseVueValidVHtmlOptions >> , # [doc = "Enforces valid v-if usage for Vue templates.\nSee https://biomejs.dev/linter/rules/use-vue-valid-v-if"] # [serde (skip_serializing_if = "Option::is_none")] pub use_vue_valid_v_if : Option < RuleConfiguration < biome_rule_options :: use_vue_valid_v_if :: UseVueValidVIfOptions >> , # [doc = "Enforce valid v-on directives with proper arguments, modifiers, and handlers.\nSee https://biomejs.dev/linter/rules/use-vue-valid-v-on"] # [serde (skip_serializing_if = "Option::is_none")] pub use_vue_valid_v_on : Option < RuleConfiguration < biome_rule_options :: use_vue_valid_v_on :: UseVueValidVOnOptions >> }
+pub struct Nursery { # [doc = r" Enables the recommended rules for this group"] # [serde (skip_serializing_if = "Option::is_none")] pub recommended : Option < bool > , # [doc = "Disallow continue statements.\nSee https://biomejs.dev/linter/rules/no-continue"] # [serde (skip_serializing_if = "Option::is_none")] pub no_continue : Option < RuleConfiguration < biome_rule_options :: no_continue :: NoContinueOptions >> , # [doc = "Restrict imports of deprecated exports.\nSee https://biomejs.dev/linter/rules/no-deprecated-imports"] # [serde (skip_serializing_if = "Option::is_none")] pub no_deprecated_imports : Option < RuleConfiguration < biome_rule_options :: no_deprecated_imports :: NoDeprecatedImportsOptions >> , # [doc = "Prevent the listing of duplicate dependencies. The rule supports the following dependency groups: \"bundledDependencies\", \"bundleDependencies\", \"dependencies\", \"devDependencies\", \"overrides\", \"optionalDependencies\", and \"peerDependencies\".\nSee https://biomejs.dev/linter/rules/no-duplicate-dependencies"] # [serde (skip_serializing_if = "Option::is_none")] pub no_duplicate_dependencies : Option < RuleConfiguration < biome_rule_options :: no_duplicate_dependencies :: NoDuplicateDependenciesOptions >> , # [doc = "Disallow empty sources.\nSee https://biomejs.dev/linter/rules/no-empty-source"] # [serde (skip_serializing_if = "Option::is_none")] pub no_empty_source : Option < RuleConfiguration < biome_rule_options :: no_empty_source :: NoEmptySourceOptions >> , # [doc = "Require Promise-like statements to be handled appropriately.\nSee https://biomejs.dev/linter/rules/no-floating-promises"] # [serde (skip_serializing_if = "Option::is_none")] pub no_floating_promises : Option < RuleFixConfiguration < biome_rule_options :: no_floating_promises :: NoFloatingPromisesOptions >> , # [doc = "Disallow iterating using a for-in loop.\nSee https://biomejs.dev/linter/rules/no-for-in"] # [serde (skip_serializing_if = "Option::is_none")] pub no_for_in : Option < RuleConfiguration < biome_rule_options :: no_for_in :: NoForInOptions >> , # [doc = "Prevent import cycles.\nSee https://biomejs.dev/linter/rules/no-import-cycles"] # [serde (skip_serializing_if = "Option::is_none")] pub no_import_cycles : Option < RuleConfiguration < biome_rule_options :: no_import_cycles :: NoImportCyclesOptions >> , # [doc = "Disallows the usage of the unary operators ++ and --.\nSee https://biomejs.dev/linter/rules/no-increment-decrement"] # [serde (skip_serializing_if = "Option::is_none")] pub no_increment_decrement : Option < RuleConfiguration < biome_rule_options :: no_increment_decrement :: NoIncrementDecrementOptions >> , # [doc = "Disallow string literals inside JSX elements.\nSee https://biomejs.dev/linter/rules/no-jsx-literals"] # [serde (skip_serializing_if = "Option::is_none")] pub no_jsx_literals : Option < RuleConfiguration < biome_rule_options :: no_jsx_literals :: NoJsxLiteralsOptions >> , # [doc = "Disallow Promises to be used in places where they are almost certainly a mistake.\nSee https://biomejs.dev/linter/rules/no-misused-promises"] # [serde (skip_serializing_if = "Option::is_none")] pub no_misused_promises : Option < RuleFixConfiguration < biome_rule_options :: no_misused_promises :: NoMisusedPromisesOptions >> , # [doc = "Prevent client components from being async functions.\nSee https://biomejs.dev/linter/rules/no-next-async-client-component"] # [serde (skip_serializing_if = "Option::is_none")] pub no_next_async_client_component : Option < RuleConfiguration < biome_rule_options :: no_next_async_client_component :: NoNextAsyncClientComponentOptions >> , # [doc = "Disallow function parameters that are only used in recursive calls.\nSee https://biomejs.dev/linter/rules/no-parameters-only-used-in-recursion"] # [serde (skip_serializing_if = "Option::is_none")] pub no_parameters_only_used_in_recursion : Option < RuleFixConfiguration < biome_rule_options :: no_parameters_only_used_in_recursion :: NoParametersOnlyUsedInRecursionOptions >> , # [doc = "Replaces usages of forwardRef with passing ref as a prop.\nSee https://biomejs.dev/linter/rules/no-react-forward-ref"] # [serde (skip_serializing_if = "Option::is_none")] pub no_react_forward_ref : Option < RuleFixConfiguration < biome_rule_options :: no_react_forward_ref :: NoReactForwardRefOptions >> , # [doc = "Disallow variable declarations from shadowing variables declared in the outer scope.\nSee https://biomejs.dev/linter/rules/no-shadow"] # [serde (skip_serializing_if = "Option::is_none")] pub no_shadow : Option < RuleConfiguration < biome_rule_options :: no_shadow :: NoShadowOptions >> , # [doc = "Prevent the usage of synchronous scripts.\nSee https://biomejs.dev/linter/rules/no-sync-scripts"] # [serde (skip_serializing_if = "Option::is_none")] pub no_sync_scripts : Option < RuleConfiguration < biome_rule_options :: no_sync_scripts :: NoSyncScriptsOptions >> , # [doc = "Disallow unknown DOM properties.\nSee https://biomejs.dev/linter/rules/no-unknown-attribute"] # [serde (skip_serializing_if = "Option::is_none")] pub no_unknown_attribute : Option < RuleConfiguration < biome_rule_options :: no_unknown_attribute :: NoUnknownAttributeOptions >> , # [doc = "Disallow unnecessary type-based conditions that can be statically determined as redundant.\nSee https://biomejs.dev/linter/rules/no-unnecessary-conditions"] # [serde (skip_serializing_if = "Option::is_none")] pub no_unnecessary_conditions : Option < RuleConfiguration < biome_rule_options :: no_unnecessary_conditions :: NoUnnecessaryConditionsOptions >> , # [doc = "Warn when importing non-existing exports.\nSee https://biomejs.dev/linter/rules/no-unresolved-imports"] # [serde (skip_serializing_if = "Option::is_none")] pub no_unresolved_imports : Option < RuleConfiguration < biome_rule_options :: no_unresolved_imports :: NoUnresolvedImportsOptions >> , # [doc = "Disallow expression statements that are neither a function call nor an assignment.\nSee https://biomejs.dev/linter/rules/no-unused-expressions"] # [serde (skip_serializing_if = "Option::is_none")] pub no_unused_expressions : Option < RuleConfiguration < biome_rule_options :: no_unused_expressions :: NoUnusedExpressionsOptions >> , # [doc = "Disallow unused catch bindings.\nSee https://biomejs.dev/linter/rules/no-useless-catch-binding"] # [serde (skip_serializing_if = "Option::is_none")] pub no_useless_catch_binding : Option < RuleFixConfiguration < biome_rule_options :: no_useless_catch_binding :: NoUselessCatchBindingOptions >> , # [doc = "Disallow the use of useless undefined.\nSee https://biomejs.dev/linter/rules/no-useless-undefined"] # [serde (skip_serializing_if = "Option::is_none")] pub no_useless_undefined : Option < RuleFixConfiguration < biome_rule_options :: no_useless_undefined :: NoUselessUndefinedOptions >> , # [doc = "Enforce that Vue component data options are declared as functions.\nSee https://biomejs.dev/linter/rules/no-vue-data-object-declaration"] # [serde (skip_serializing_if = "Option::is_none")] pub no_vue_data_object_declaration : Option < RuleFixConfiguration < biome_rule_options :: no_vue_data_object_declaration :: NoVueDataObjectDeclarationOptions >> , # [doc = "Disallow duplicate keys in Vue component data, methods, computed properties, and other options.\nSee https://biomejs.dev/linter/rules/no-vue-duplicate-keys"] # [serde (skip_serializing_if = "Option::is_none")] pub no_vue_duplicate_keys : Option < RuleConfiguration < biome_rule_options :: no_vue_duplicate_keys :: NoVueDuplicateKeysOptions >> , # [doc = "Disallow reserved keys in Vue component data and computed properties.\nSee https://biomejs.dev/linter/rules/no-vue-reserved-keys"] # [serde (skip_serializing_if = "Option::is_none")] pub no_vue_reserved_keys : Option < RuleConfiguration < biome_rule_options :: no_vue_reserved_keys :: NoVueReservedKeysOptions >> , # [doc = "Disallow reserved names to be used as props.\nSee https://biomejs.dev/linter/rules/no-vue-reserved-props"] # [serde (skip_serializing_if = "Option::is_none")] pub no_vue_reserved_props : Option < RuleConfiguration < biome_rule_options :: no_vue_reserved_props :: NoVueReservedPropsOptions >> , # [doc = "Disallow using v-if and v-for directives on the same element.\nSee https://biomejs.dev/linter/rules/no-vue-v-if-with-v-for"] # [serde (skip_serializing_if = "Option::is_none")] pub no_vue_v_if_with_v_for : Option < RuleConfiguration < biome_rule_options :: no_vue_v_if_with_v_for :: NoVueVIfWithVForOptions >> , # [doc = "Require Array#sort and Array#toSorted calls to always provide a compareFunction.\nSee https://biomejs.dev/linter/rules/use-array-sort-compare"] # [serde (skip_serializing_if = "Option::is_none")] pub use_array_sort_compare : Option < RuleConfiguration < biome_rule_options :: use_array_sort_compare :: UseArraySortCompareOptions >> , # [doc = "Enforce consistent arrow function bodies.\nSee https://biomejs.dev/linter/rules/use-consistent-arrow-return"] # [serde (skip_serializing_if = "Option::is_none")] pub use_consistent_arrow_return : Option < RuleFixConfiguration < biome_rule_options :: use_consistent_arrow_return :: UseConsistentArrowReturnOptions >> , # [doc = "Require all descriptions to follow the same style (either block or inline) to  maintain consistency and improve readability across the schema.\nSee https://biomejs.dev/linter/rules/use-consistent-graphql-descriptions"] # [serde (skip_serializing_if = "Option::is_none")] pub use_consistent_graphql_descriptions : Option < RuleConfiguration < biome_rule_options :: use_consistent_graphql_descriptions :: UseConsistentGraphqlDescriptionsOptions >> , # [doc = "Require the @deprecated directive to specify a deletion date.\nSee https://biomejs.dev/linter/rules/use-deprecated-date"] # [serde (skip_serializing_if = "Option::is_none")] pub use_deprecated_date : Option < RuleConfiguration < biome_rule_options :: use_deprecated_date :: UseDeprecatedDateOptions >> , # [doc = "Require switch-case statements to be exhaustive.\nSee https://biomejs.dev/linter/rules/use-exhaustive-switch-cases"] # [serde (skip_serializing_if = "Option::is_none")] pub use_exhaustive_switch_cases : Option < RuleFixConfiguration < biome_rule_options :: use_exhaustive_switch_cases :: UseExhaustiveSwitchCasesOptions >> , # [doc = "Enforce types in functions, methods, variables, and parameters.\nSee https://biomejs.dev/linter/rules/use-explicit-type"] # [serde (skip_serializing_if = "Option::is_none")] pub use_explicit_type : Option < RuleConfiguration < biome_rule_options :: use_explicit_type :: UseExplicitTypeOptions >> , # [doc = "Enforce the use of Array.prototype.find() over Array.prototype.filter() followed by [0] when looking for a single result.\nSee https://biomejs.dev/linter/rules/use-find"] # [serde (skip_serializing_if = "Option::is_none")] pub use_find : Option < RuleConfiguration < biome_rule_options :: use_find :: UseFindOptions >> , # [doc = "Enforce a maximum number of parameters in function definitions.\nSee https://biomejs.dev/linter/rules/use-max-params"] # [serde (skip_serializing_if = "Option::is_none")] pub use_max_params : Option < RuleConfiguration < biome_rule_options :: use_max_params :: UseMaxParamsOptions >> , # [doc = "Disallow use* hooks outside of component$ or other use* hooks in Qwik applications.\nSee https://biomejs.dev/linter/rules/use-qwik-method-usage"] # [serde (skip_serializing_if = "Option::is_none")] pub use_qwik_method_usage : Option < RuleConfiguration < biome_rule_options :: use_qwik_method_usage :: UseQwikMethodUsageOptions >> , # [doc = "Disallow unserializable expressions in Qwik dollar ($) scopes.\nSee https://biomejs.dev/linter/rules/use-qwik-valid-lexical-scope"] # [serde (skip_serializing_if = "Option::is_none")] pub use_qwik_valid_lexical_scope : Option < RuleConfiguration < biome_rule_options :: use_qwik_valid_lexical_scope :: UseQwikValidLexicalScopeOptions >> , # [doc = "Enforce the sorting of CSS utility classes.\nSee https://biomejs.dev/linter/rules/use-sorted-classes"] # [serde (skip_serializing_if = "Option::is_none")] pub use_sorted_classes : Option < RuleFixConfiguration < biome_rule_options :: use_sorted_classes :: UseSortedClassesOptions >> , # [doc = "Enforce the use of the spread operator over .apply().\nSee https://biomejs.dev/linter/rules/use-spread"] # [serde (skip_serializing_if = "Option::is_none")] pub use_spread : Option < RuleFixConfiguration < biome_rule_options :: use_spread :: UseSpreadOptions >> , # [doc = "Enforce unique operation names across a GraphQL document.\nSee https://biomejs.dev/linter/rules/use-unique-graphql-operation-name"] # [serde (skip_serializing_if = "Option::is_none")] pub use_unique_graphql_operation_name : Option < RuleConfiguration < biome_rule_options :: use_unique_graphql_operation_name :: UseUniqueGraphqlOperationNameOptions >> , # [doc = "Enforce specific order of Vue compiler macros.\nSee https://biomejs.dev/linter/rules/use-vue-define-macros-order"] # [serde (skip_serializing_if = "Option::is_none")] pub use_vue_define_macros_order : Option < RuleFixConfiguration < biome_rule_options :: use_vue_define_macros_order :: UseVueDefineMacrosOrderOptions >> , # [doc = "Enforce hyphenated (kebab-case) attribute names in Vue templates.\nSee https://biomejs.dev/linter/rules/use-vue-hyphenated-attributes"] # [serde (skip_serializing_if = "Option::is_none")] pub use_vue_hyphenated_attributes : Option < RuleFixConfiguration < biome_rule_options :: use_vue_hyphenated_attributes :: UseVueHyphenatedAttributesOptions >> , # [doc = "Enforce multi-word component names in Vue components.\nSee https://biomejs.dev/linter/rules/use-vue-multi-word-component-names"] # [serde (skip_serializing_if = "Option::is_none")] pub use_vue_multi_word_component_names : Option < RuleConfiguration < biome_rule_options :: use_vue_multi_word_component_names :: UseVueMultiWordComponentNamesOptions >> , # [doc = "Forbids v-bind directives with missing arguments or invalid modifiers.\nSee https://biomejs.dev/linter/rules/use-vue-valid-v-bind"] # [serde (skip_serializing_if = "Option::is_none")] pub use_vue_valid_v_bind : Option < RuleConfiguration < biome_rule_options :: use_vue_valid_v_bind :: UseVueValidVBindOptions >> , # [doc = "Enforce valid usage of v-else.\nSee https://biomejs.dev/linter/rules/use-vue-valid-v-else"] # [serde (skip_serializing_if = "Option::is_none")] pub use_vue_valid_v_else : Option < RuleConfiguration < biome_rule_options :: use_vue_valid_v_else :: UseVueValidVElseOptions >> , # [doc = "Enforce valid v-else-if directives.\nSee https://biomejs.dev/linter/rules/use-vue-valid-v-else-if"] # [serde (skip_serializing_if = "Option::is_none")] pub use_vue_valid_v_else_if : Option < RuleConfiguration < biome_rule_options :: use_vue_valid_v_else_if :: UseVueValidVElseIfOptions >> , # [doc = "Enforce valid v-html directives.\nSee https://biomejs.dev/linter/rules/use-vue-valid-v-html"] # [serde (skip_serializing_if = "Option::is_none")] pub use_vue_valid_v_html : Option < RuleConfiguration < biome_rule_options :: use_vue_valid_v_html :: UseVueValidVHtmlOptions >> , # [doc = "Enforces valid v-if usage for Vue templates.\nSee https://biomejs.dev/linter/rules/use-vue-valid-v-if"] # [serde (skip_serializing_if = "Option::is_none")] pub use_vue_valid_v_if : Option < RuleConfiguration < biome_rule_options :: use_vue_valid_v_if :: UseVueValidVIfOptions >> , # [doc = "Enforce valid v-on directives with proper arguments, modifiers, and handlers.\nSee https://biomejs.dev/linter/rules/use-vue-valid-v-on"] # [serde (skip_serializing_if = "Option::is_none")] pub use_vue_valid_v_on : Option < RuleConfiguration < biome_rule_options :: use_vue_valid_v_on :: UseVueValidVOnOptions >> , # [doc = "Enforce valid v-text Vue directives.\nSee https://biomejs.dev/linter/rules/use-vue-valid-v-text"] # [serde (skip_serializing_if = "Option::is_none")] pub use_vue_valid_v_text : Option < RuleConfiguration < biome_rule_options :: use_vue_valid_v_text :: UseVueValidVTextOptions >> }
 impl Nursery {
     const GROUP_NAME: &'static str = "nursery";
     pub(crate) const GROUP_RULES: &'static [&'static str] = &[
@@ -4824,6 +4828,7 @@ impl Nursery {
         "useVueValidVHtml",
         "useVueValidVIf",
         "useVueValidVOn",
+        "useVueValidVText",
     ];
     const RECOMMENDED_RULES_AS_FILTERS: &'static [RuleFilter<'static>] =
         &[RuleFilter::Rule(Self::GROUP_NAME, Self::GROUP_RULES[37])];
@@ -4876,6 +4881,7 @@ impl Nursery {
         RuleFilter::Rule(Self::GROUP_NAME, Self::GROUP_RULES[45]),
         RuleFilter::Rule(Self::GROUP_NAME, Self::GROUP_RULES[46]),
         RuleFilter::Rule(Self::GROUP_NAME, Self::GROUP_RULES[47]),
+        RuleFilter::Rule(Self::GROUP_NAME, Self::GROUP_RULES[48]),
     ];
 }
 impl RuleGroupExt for Nursery {
@@ -5127,6 +5133,11 @@ impl RuleGroupExt for Nursery {
         {
             index_set.insert(RuleFilter::Rule(Self::GROUP_NAME, Self::GROUP_RULES[47]));
         }
+        if let Some(rule) = self.use_vue_valid_v_text.as_ref()
+            && rule.is_enabled()
+        {
+            index_set.insert(RuleFilter::Rule(Self::GROUP_NAME, Self::GROUP_RULES[48]));
+        }
         index_set
     }
     fn get_disabled_rules(&self) -> FxHashSet<RuleFilter<'static>> {
@@ -5371,6 +5382,11 @@ impl RuleGroupExt for Nursery {
         {
             index_set.insert(RuleFilter::Rule(Self::GROUP_NAME, Self::GROUP_RULES[47]));
         }
+        if let Some(rule) = self.use_vue_valid_v_text.as_ref()
+            && rule.is_disabled()
+        {
+            index_set.insert(RuleFilter::Rule(Self::GROUP_NAME, Self::GROUP_RULES[48]));
+        }
         index_set
     }
     #[doc = r" Checks if, given a rule name, matches one of the rules contained in this category"]
@@ -5593,6 +5609,10 @@ impl RuleGroupExt for Nursery {
                 .use_vue_valid_v_on
                 .as_ref()
                 .map(|conf| (conf.level(), conf.get_options())),
+            "useVueValidVText" => self
+                .use_vue_valid_v_text
+                .as_ref()
+                .map(|conf| (conf.level(), conf.get_options())),
             _ => None,
         }
     }
@@ -5649,6 +5669,7 @@ impl From<GroupPlainConfiguration> for Nursery {
             use_vue_valid_v_html: Some(value.into()),
             use_vue_valid_v_if: Some(value.into()),
             use_vue_valid_v_on: Some(value.into()),
+            use_vue_valid_v_text: Some(value.into()),
         }
     }
 }
diff --git a/crates/biome_css_formatter/src/css/value/regular_dimension.rs b/crates/biome_css_formatter/src/css/value/regular_dimension.rs
index 9c8ff79106..01ec0f68f7 100644
--- a/crates/biome_css_formatter/src/css/value/regular_dimension.rs
+++ b/crates/biome_css_formatter/src/css/value/regular_dimension.rs
@@ -1,4 +1,4 @@
-use crate::{prelude::*, utils::string_utils::FormatDimensionUnit};
+use crate::{prelude::*, utils::string_utils::FormatTokenAsLowercase};
 use biome_css_syntax::{CssRegularDimension, CssRegularDimensionFields};
 use biome_formatter::{token::number::NumberFormatOptions, write};
 
@@ -15,7 +15,7 @@ impl FormatNodeRule<CssRegularDimension> for FormatCssRegularDimension {
             f,
             [
                 format_number_token(&value_token?, NumberFormatOptions::default()),
-                FormatDimensionUnit::from(unit_token?),
+                FormatTokenAsLowercase::from(unit_token?),
             ]
         )
     }
diff --git a/crates/biome_css_formatter/src/css/value/unknown_dimension.rs b/crates/biome_css_formatter/src/css/value/unknown_dimension.rs
index 16b59fc970..47f1963774 100644
--- a/crates/biome_css_formatter/src/css/value/unknown_dimension.rs
+++ b/crates/biome_css_formatter/src/css/value/unknown_dimension.rs
@@ -1,7 +1,4 @@
-use crate::{
-    prelude::*,
-    utils::string_utils::{FormatDimensionUnit, FormatTokenAsLowercase},
-};
+use crate::{prelude::*, utils::string_utils::FormatTokenAsLowercase};
 use biome_css_syntax::{CssUnknownDimension, CssUnknownDimensionFields};
 use biome_formatter::write;
 
@@ -18,7 +15,7 @@ impl FormatNodeRule<CssUnknownDimension> for FormatCssUnknownDimension {
             f,
             [
                 FormatTokenAsLowercase::from(value_token?),
-                FormatDimensionUnit::from(unit_token?),
+                FormatTokenAsLowercase::from(unit_token?),
             ]
         );
         var_name
diff --git a/crates/biome_css_formatter/src/utils/string_utils.rs b/crates/biome_css_formatter/src/utils/string_utils.rs
index 1ce602be98..84fa158a2d 100644
--- a/crates/biome_css_formatter/src/utils/string_utils.rs
+++ b/crates/biome_css_formatter/src/utils/string_utils.rs
@@ -296,61 +296,3 @@ impl<'token> LiteralStringNormaliser<'token> {
         }
     }
 }
-
-pub(crate) struct FormatDimensionUnit {
-    token: SyntaxToken<CssLanguage>,
-}
-
-impl From<SyntaxToken<CssLanguage>> for FormatDimensionUnit {
-    fn from(value: SyntaxToken<CssLanguage>) -> Self {
-        Self { token: value }
-    }
-}
-
-impl Format<CssFormatContext> for FormatDimensionUnit {
-    fn fmt(&self, f: &mut CssFormatter) -> FormatResult<()> {
-        let original = self.token.text_trimmed();
-
-        match original.to_ascii_lowercase_cow() {
-            Cow::Borrowed(lowercase) => {
-                if let Some(uppercase) = map_dimension_unit(lowercase) {
-                    write!(
-                        f,
-                        [format_replaced(
-                            &self.token,
-                            &text(&uppercase, self.token.text_trimmed_range().start()),
-                        )]
-                    )
-                } else {
-                    write!(f, [self.token.format()])
-                }
-            }
-
-            Cow::Owned(lowercase) => {
-                write!(
-                    f,
-                    [format_replaced(
-                        &self.token,
-                        &text(
-                            &map_dimension_unit(lowercase.as_str()).unwrap_or(lowercase),
-                            self.token.text_trimmed_range().start()
-                        ),
-                    )]
-                )
-            }
-        }
-    }
-}
-
-/// Most CSS dimension units can be formatted as lower case, but there are
-/// a few that are more commonly formatted with some uppercase characters.
-/// This maps those few cases to the correct casing. This matches the
-/// behavior of the Prettier formatter.
-fn map_dimension_unit(unit: &str) -> Option<String> {
-    match unit {
-        "hz" => Some(String::from("Hz")),
-        "khz" => Some(String::from("kHz")),
-        "q" => Some(String::from("Q")),
-        _ => None,
-    }
-}
diff --git a/crates/biome_css_formatter/tests/specs/css/units.css b/crates/biome_css_formatter/tests/specs/css/units.css
index c60d1bb722..fe59451616 100644
--- a/crates/biome_css_formatter/tests/specs/css/units.css
+++ b/crates/biome_css_formatter/tests/specs/css/units.css
@@ -20,7 +20,6 @@
   a: 5CM;
   a: 5MM;
   a: 5Q;
-  a: 5q;
   a: 5IN;
   a: 5PT;
   a: 5PC;
@@ -31,9 +30,7 @@
   a: 5S;
   a: 5MS;
   a: 5HZ;
-  a: 5hz;
   a: 5KHZ;
-  a: 5kHz;
   a: 5DPI;
   a: 5DPCM;
   a: 5DPPX;
@@ -44,4 +41,4 @@
   a: 5Unknown;
   /* http://browserbu.gs/css-hacks/media-min-width-0-backslash-0/ */
   a: 0\0;
-}
+}
\ No newline at end of file
diff --git a/crates/biome_css_formatter/tests/specs/css/units.css.snap b/crates/biome_css_formatter/tests/specs/css/units.css.snap
index 39e7cafc87..6dcdbf9db3 100644
--- a/crates/biome_css_formatter/tests/specs/css/units.css.snap
+++ b/crates/biome_css_formatter/tests/specs/css/units.css.snap
@@ -2,6 +2,7 @@
 source: crates/biome_formatter_test/src/snapshot_builder.rs
 info: css/units.css
 ---
+
 # Input
 
 ```css
@@ -27,7 +28,6 @@ info: css/units.css
   a: 5CM;
   a: 5MM;
   a: 5Q;
-  a: 5q;
   a: 5IN;
   a: 5PT;
   a: 5PC;
@@ -38,9 +38,7 @@ info: css/units.css
   a: 5S;
   a: 5MS;
   a: 5HZ;
-  a: 5hz;
   a: 5KHZ;
-  a: 5kHz;
   a: 5DPI;
   a: 5DPCM;
   a: 5DPPX;
@@ -52,7 +50,6 @@ info: css/units.css
   /* http://browserbu.gs/css-hacks/media-min-width-0-backslash-0/ */
   a: 0\0;
 }
-
 ```
 
 
@@ -92,8 +89,7 @@ Quote style: Double Quotes
 	a: 5vmax;
 	a: 5cm;
 	a: 5mm;
-	a: 5Q;
-	a: 5Q;
+	a: 5q;
 	a: 5in;
 	a: 5pt;
 	a: 5pc;
@@ -103,10 +99,8 @@ Quote style: Double Quotes
 	a: 5rad;
 	a: 5s;
 	a: 5ms;
-	a: 5Hz;
-	a: 5Hz;
-	a: 5kHz;
-	a: 5kHz;
+	a: 5hz;
+	a: 5khz;
 	a: 5dpi;
 	a: 5dpcm;
 	a: 5dppx;
@@ -119,3 +113,5 @@ Quote style: Double Quotes
 	a: 0\0;
 }
 ```
+
+
diff --git a/crates/biome_diagnostics_categories/src/categories.rs b/crates/biome_diagnostics_categories/src/categories.rs
index 1193a5906b..d8f380a24d 100644
--- a/crates/biome_diagnostics_categories/src/categories.rs
+++ b/crates/biome_diagnostics_categories/src/categories.rs
@@ -225,6 +225,7 @@ define_categories! {
     "lint/nursery/useVueValidVIf": "https://biomejs.dev/linter/rules/use-vue-valid-v-if",
     "lint/nursery/useVueValidVModel": "https://biomejs.dev/linter/rules/use-vue-valid-v-model",
     "lint/nursery/useVueValidVOn": "https://biomejs.dev/linter/rules/use-vue-valid-v-on",
+    "lint/nursery/useVueValidVText": "https://biomejs.dev/linter/rules/use-vue-valid-v-text",
     "lint/performance/noAccumulatingSpread": "https://biomejs.dev/linter/rules/no-accumulating-spread",
     "lint/performance/noAwaitInLoops": "https://biomejs.dev/linter/rules/no-await-in-loops",
     "lint/performance/noBarrelFile": "https://biomejs.dev/linter/rules/no-barrel-file",
diff --git a/crates/biome_html_analyze/src/lint/nursery.rs b/crates/biome_html_analyze/src/lint/nursery.rs
index 3385e08d6d..57159a909a 100644
--- a/crates/biome_html_analyze/src/lint/nursery.rs
+++ b/crates/biome_html_analyze/src/lint/nursery.rs
@@ -12,4 +12,5 @@ pub mod use_vue_valid_v_else_if;
 pub mod use_vue_valid_v_html;
 pub mod use_vue_valid_v_if;
 pub mod use_vue_valid_v_on;
-declare_lint_group! { pub Nursery { name : "nursery" , rules : [self :: no_sync_scripts :: NoSyncScripts , self :: no_vue_v_if_with_v_for :: NoVueVIfWithVFor , self :: use_vue_hyphenated_attributes :: UseVueHyphenatedAttributes , self :: use_vue_valid_v_bind :: UseVueValidVBind , self :: use_vue_valid_v_else :: UseVueValidVElse , self :: use_vue_valid_v_else_if :: UseVueValidVElseIf , self :: use_vue_valid_v_html :: UseVueValidVHtml , self :: use_vue_valid_v_if :: UseVueValidVIf , self :: use_vue_valid_v_on :: UseVueValidVOn ,] } }
+pub mod use_vue_valid_v_text;
+declare_lint_group! { pub Nursery { name : "nursery" , rules : [self :: no_sync_scripts :: NoSyncScripts , self :: no_vue_v_if_with_v_for :: NoVueVIfWithVFor , self :: use_vue_hyphenated_attributes :: UseVueHyphenatedAttributes , self :: use_vue_valid_v_bind :: UseVueValidVBind , self :: use_vue_valid_v_else :: UseVueValidVElse , self :: use_vue_valid_v_else_if :: UseVueValidVElseIf , self :: use_vue_valid_v_html :: UseVueValidVHtml , self :: use_vue_valid_v_if :: UseVueValidVIf , self :: use_vue_valid_v_on :: UseVueValidVOn , self :: use_vue_valid_v_text :: UseVueValidVText ,] } }
diff --git a/crates/biome_html_analyze/src/lint/nursery/use_vue_valid_v_html.rs b/crates/biome_html_analyze/src/lint/nursery/use_vue_valid_v_html.rs
index 54a3015947..ca8e6630e7 100644
--- a/crates/biome_html_analyze/src/lint/nursery/use_vue_valid_v_html.rs
+++ b/crates/biome_html_analyze/src/lint/nursery/use_vue_valid_v_html.rs
@@ -2,7 +2,7 @@ use biome_analyze::{
     Ast, Rule, RuleDiagnostic, RuleDomain, RuleSource, context::RuleContext, declare_lint_rule,
 };
 use biome_console::markup;
-use biome_html_syntax::{AnyHtmlAttributeInitializer, AnyVueDirective};
+use biome_html_syntax::{AnyHtmlAttributeInitializer, VueDirective, inner_string_text};
 use biome_rowan::{AstNode, AstNodeList, TextRange};
 use biome_rule_options::use_vue_valid_v_html::UseVueValidVHtmlOptions;
 
@@ -53,54 +53,36 @@ pub enum ViolationKind {
 }
 
 impl Rule for UseVueValidVHtml {
-    type Query = Ast<AnyVueDirective>;
+    type Query = Ast<VueDirective>;
     type State = ViolationKind;
     type Signals = Option<Self::State>;
     type Options = UseVueValidVHtmlOptions;
 
     fn run(ctx: &RuleContext<Self>) -> Option<Self::State> {
-        let node = ctx.query();
-        match node {
-            AnyVueDirective::VueDirective(vue_directive) => {
-                if vue_directive.name_token().ok()?.text_trimmed() != "v-html" {
-                    return None;
-                }
-
-                if let Some(arg) = vue_directive.arg() {
-                    return Some(ViolationKind::UnexpectedArgument(arg.range()));
-                }
-
-                if !vue_directive.modifiers().is_empty() {
-                    let first_modifier = vue_directive.modifiers().iter().next()?;
-                    return Some(ViolationKind::UnexpectedModifier(first_modifier.range()));
-                }
+        let vue_directive = ctx.query();
+        if vue_directive.name_token().ok()?.text_trimmed() != "v-html" {
+            return None;
+        }
+        if let Some(arg) = vue_directive.arg() {
+            return Some(ViolationKind::UnexpectedArgument(arg.range()));
+        }
 
-                if let Some(initializer) = vue_directive.initializer() {
-                    // Check if value is empty
-                    if let Ok(value) = initializer.value() {
-                        if let AnyHtmlAttributeInitializer::HtmlString(html_string) = value {
-                            // Check if the string value is empty
-                            if let Ok(token) = html_string.value_token() {
-                                if token.text().is_empty() {
-                                    return Some(ViolationKind::MissingValue);
-                                }
-                            } else {
-                                // No value token means empty string
-                                return Some(ViolationKind::MissingValue);
-                            }
-                        }
-                        // Non-string values (like expressions) are valid
-                    } else {
-                        // No value at all
-                        return Some(ViolationKind::MissingValue);
-                    }
-                } else {
-                    return Some(ViolationKind::MissingValue);
-                }
+        if !vue_directive.modifiers().is_empty() {
+            let first_modifier = vue_directive.modifiers().iter().next()?;
+            return Some(ViolationKind::UnexpectedModifier(first_modifier.range()));
+        }
 
+        if let Some(initializer) = vue_directive.initializer()
+            && let Ok(AnyHtmlAttributeInitializer::HtmlString(html_string)) = initializer.value()
+            && let Ok(token) = html_string.value_token()
+        {
+            if inner_string_text(&token).trim().is_empty() {
+                Some(ViolationKind::MissingValue)
+            } else {
                 None
             }
-            _ => None,
+        } else {
+            Some(ViolationKind::MissingValue)
         }
     }
 
diff --git a/crates/biome_html_analyze/src/lint/nursery/use_vue_valid_v_text.rs b/crates/biome_html_analyze/src/lint/nursery/use_vue_valid_v_text.rs
new file mode 100644
index 0000000000..e534b8e9f1
--- /dev/null
+++ b/crates/biome_html_analyze/src/lint/nursery/use_vue_valid_v_text.rs
@@ -0,0 +1,128 @@
+use biome_analyze::{
+    Ast, Rule, RuleDiagnostic, RuleDomain, RuleSource, context::RuleContext, declare_lint_rule,
+};
+use biome_console::markup;
+use biome_html_syntax::{AnyHtmlAttributeInitializer, VueDirective, inner_string_text};
+use biome_rowan::{AstNode, AstNodeList, TextRange};
+use biome_rule_options::use_vue_valid_v_text::UseVueValidVTextOptions;
+
+declare_lint_rule! {
+    /// Enforce valid `v-text` Vue directives.
+    ///
+    /// This rule reports `v-text` directives in the following cases:
+    /// - The directive has an argument. E.g. `<div v-text:aaa></div>`
+    /// - The directive has any modifiers. E.g. `<div v-text.bbb></div>`
+    /// - The directive does not have a value. E.g. `<div v-text></div>`
+    ///
+    /// ## Examples
+    ///
+    /// ### Invalid
+    ///
+    /// ```vue,expect_diagnostic
+    /// <div v-text />
+    /// ```
+    ///
+    /// ```vue,expect_diagnostic
+    /// <div v-text:aaa="foo"></div>
+    /// ```
+    ///
+    /// ```vue,expect_diagnostic
+    /// <div v-text.bbb="foo"></div>
+    /// ```
+    ///
+    /// ### Valid
+    ///
+    /// ```vue
+    /// <div v-text="foo" />
+    /// ```
+    ///
+    pub UseVueValidVText {
+        version: "next",
+        name: "useVueValidVText",
+        language: "html",
+        recommended: true,
+        domains: &[RuleDomain::Vue],
+        sources: &[RuleSource::EslintVueJs("valid-v-text").same()],
+    }
+}
+
+pub enum ViolationKind {
+    UnexpectedArgument(TextRange),
+    UnexpectedModifier(TextRange),
+    MissingValue,
+}
+
+impl Rule for UseVueValidVText {
+    type Query = Ast<VueDirective>;
+    type State = ViolationKind;
+    type Signals = Option<Self::State>;
+    type Options = UseVueValidVTextOptions;
+
+    fn run(ctx: &RuleContext<Self>) -> Option<Self::State> {
+        let vue_directive = ctx.query();
+        if vue_directive.name_token().ok()?.text_trimmed() != "v-text" {
+            return None;
+        }
+
+        if let Some(arg) = vue_directive.arg() {
+            return Some(ViolationKind::UnexpectedArgument(arg.range()));
+        }
+
+        if !vue_directive.modifiers().is_empty() {
+            let first_modifier = vue_directive.modifiers().iter().next()?;
+            return Some(ViolationKind::UnexpectedModifier(first_modifier.range()));
+        }
+
+        if let Some(initializer) = vue_directive.initializer()
+            && let Ok(AnyHtmlAttributeInitializer::HtmlString(html_string)) = initializer.value()
+            && let Ok(token) = html_string.value_token()
+        {
+            if inner_string_text(&token).trim().is_empty() {
+                Some(ViolationKind::MissingValue)
+            } else {
+                None
+            }
+        } else {
+            Some(ViolationKind::MissingValue)
+        }
+    }
+
+    fn diagnostic(ctx: &RuleContext<Self>, state: &Self::State) -> Option<RuleDiagnostic> {
+        Some(
+            match state {
+                ViolationKind::UnexpectedArgument(range) => RuleDiagnostic::new(
+                    rule_category!(),
+                    range,
+                    markup! {
+                        "The v-text directive does not accept an argument."
+                    },
+                )
+                .note(markup! {
+                    "v-text directives should be used without arguments, like " <Emphasis>"v-text=\"content\""</Emphasis>"."
+                }),
+                ViolationKind::UnexpectedModifier(range) => RuleDiagnostic::new(
+                    rule_category!(),
+                    range,
+                    markup! {
+                        "The v-text directive does not support modifiers."
+                    },
+                )
+                .note(markup! {
+                    "v-text directives do not support any modifiers. Remove the modifier."
+                }),
+                ViolationKind::MissingValue => RuleDiagnostic::new(
+                    rule_category!(),
+                    ctx.query().range(),
+                    markup! {
+                        "The v-text directive is missing a value."
+                    },
+                )
+                .note(markup! {
+                    "v-text directives require a value containing the text content to render."
+                }).note(markup! {
+                    "For example, use " <Emphasis>"v-text=\"foo\""</Emphasis> " to render the content of the " <Emphasis>"foo"</Emphasis> " variable."
+                }),
+            }
+        )
+    }
+}
diff --git a/crates/biome_html_analyze/tests/specs/nursery/useVueValidVHtml/invalid.vue.snap b/crates/biome_html_analyze/tests/specs/nursery/useVueValidVHtml/invalid.vue.snap
index c7ade717be..102d26fc3d 100644
--- a/crates/biome_html_analyze/tests/specs/nursery/useVueValidVHtml/invalid.vue.snap
+++ b/crates/biome_html_analyze/tests/specs/nursery/useVueValidVHtml/invalid.vue.snap
@@ -48,6 +48,24 @@ invalid.vue:5:8 lint/nursery/useVueValidVHtml 
   i For example, use v-html="htmlContent" to render the content of the htmlContent variable.
   
 
+```
+
+```
+invalid.vue:8:8 lint/nursery/useVueValidVHtml 
+
+  i The v-html directive is missing a value.
+  
+     7    <!-- Empty value -->
+   > 8    <div v-html=""></div>
+               ^^^^^^^^^
+     9    
+    10    <!-- Unexpected argument -->
+  
+  i v-html directives require a value containing the HTML content to render.
+  
+  i For example, use v-html="htmlContent" to render the content of the htmlContent variable.
+  
+
 ```
 
 ```
diff --git a/crates/biome_html_analyze/tests/specs/nursery/useVueValidVText/invalid.vue b/crates/biome_html_analyze/tests/specs/nursery/useVueValidVText/invalid.vue
new file mode 100644
index 0000000000..d8435e99bf
--- /dev/null
+++ b/crates/biome_html_analyze/tests/specs/nursery/useVueValidVText/invalid.vue
@@ -0,0 +1,14 @@
+<!-- should generate diagnostics -->
+
+<div v-text></div>
+<div v-text=""></div>
+<div v-text="    "></div>
+<div v-text:aaa="foo"></div>
+<div v-text.bbb="foo"></div>
+<div v-text:aaa></div>
+<div v-text.bbb></div>
+
+<div v-text />
+<div v-text="" />
+<div v-text:aaa="foo" />
+<div v-text.bbb="foo" />
diff --git a/crates/biome_html_analyze/tests/specs/nursery/useVueValidVText/invalid.vue.snap b/crates/biome_html_analyze/tests/specs/nursery/useVueValidVText/invalid.vue.snap
new file mode 100644
index 0000000000..4e9e81ba38
--- /dev/null
+++ b/crates/biome_html_analyze/tests/specs/nursery/useVueValidVText/invalid.vue.snap
@@ -0,0 +1,217 @@
+---
+source: crates/biome_html_analyze/tests/spec_tests.rs
+expression: invalid.vue
+---
+# Input
+```html
+<!-- should generate diagnostics -->
+
+<div v-text></div>
+<div v-text=""></div>
+<div v-text="    "></div>
+<div v-text:aaa="foo"></div>
+<div v-text.bbb="foo"></div>
+<div v-text:aaa></div>
+<div v-text.bbb></div>
+
+<div v-text />
+<div v-text="" />
+<div v-text:aaa="foo" />
+<div v-text.bbb="foo" />
+
+```
+
+# Diagnostics
+```
+invalid.vue:3:6 lint/nursery/useVueValidVText 
+
+  i The v-text directive is missing a value.
+  
+    1  <!-- should generate diagnostics -->
+    2  
+  > 3  <div v-text></div>
+            ^^^^^^
+    4  <div v-text=""></div>
+    5  <div v-text="    "></div>
+  
+  i v-text directives require a value containing the text content to render.
+  
+  i For example, use v-text="foo" to render the content of the foo variable.
+  
+
+```
+
+```
+invalid.vue:4:6 lint/nursery/useVueValidVText 
+
+  i The v-text directive is missing a value.
+  
+    3  <div v-text></div>
+  > 4  <div v-text=""></div>
+            ^^^^^^^^^
+    5  <div v-text="    "></div>
+    6  <div v-text:aaa="foo"></div>
+  
+  i v-text directives require a value containing the text content to render.
+  
+  i For example, use v-text="foo" to render the content of the foo variable.
+  
+
+```
+
+```
+invalid.vue:5:6 lint/nursery/useVueValidVText 
+
+  i The v-text directive is missing a value.
+  
+    3  <div v-text></div>
+    4  <div v-text=""></div>
+  > 5  <div v-text="    "></div>
+            ^^^^^^^^^^^^^
+    6  <div v-text:aaa="foo"></div>
+    7  <div v-text.bbb="foo"></div>
+  
+  i v-text directives require a value containing the text content to render.
+  
+  i For example, use v-text="foo" to render the content of the foo variable.
+  
+
+```
+
+```
+invalid.vue:6:12 lint/nursery/useVueValidVText 
+
+  i The v-text directive does not accept an argument.
+  
+    4  <div v-text=""></div>
+    5  <div v-text="    "></div>
+  > 6  <div v-text:aaa="foo"></div>
+                  ^^^^
+    7  <div v-text.bbb="foo"></div>
+    8  <div v-text:aaa></div>
+  
+  i v-text directives should be used without arguments, like v-text="content".
+  
+
+```
+
+```
+invalid.vue:7:12 lint/nursery/useVueValidVText 
+
+  i The v-text directive does not support modifiers.
+  
+    5  <div v-text="    "></div>
+    6  <div v-text:aaa="foo"></div>
+  > 7  <div v-text.bbb="foo"></div>
+                  ^^^^
+    8  <div v-text:aaa></div>
+    9  <div v-text.bbb></div>
+  
+  i v-text directives do not support any modifiers. Remove the modifier.
+  
+
+```
+
+```
+invalid.vue:8:12 lint/nursery/useVueValidVText 
+
+  i The v-text directive does not accept an argument.
+  
+     6  <div v-text:aaa="foo"></div>
+     7  <div v-text.bbb="foo"></div>
+   > 8  <div v-text:aaa></div>
+                   ^^^^
+     9  <div v-text.bbb></div>
+    10  
+  
+  i v-text directives should be used without arguments, like v-text="content".
+  
+
+```
+
+```
+invalid.vue:9:12 lint/nursery/useVueValidVText 
+
+  i The v-text directive does not support modifiers.
+  
+     7  <div v-text.bbb="foo"></div>
+     8  <div v-text:aaa></div>
+   > 9  <div v-text.bbb></div>
+                   ^^^^
+    10  
+    11  <div v-text />
+  
+  i v-text directives do not support any modifiers. Remove the modifier.
+  
+
+```
+
+```
+invalid.vue:11:6 lint/nursery/useVueValidVText 
+
+  i The v-text directive is missing a value.
+  
+     9  <div v-text.bbb></div>
+    10  
+  > 11  <div v-text />
+             ^^^^^^
+    12  <div v-text="" />
+    13  <div v-text:aaa="foo" />
+  
+  i v-text directives require a value containing the text content to render.
+  
+  i For example, use v-text="foo" to render the content of the foo variable.
+  
+
+```
+
+```
+invalid.vue:12:6 lint/nursery/useVueValidVText 
+
+  i The v-text directive is missing a value.
+  
+    11  <div v-text />
+  > 12  <div v-text="" />
+             ^^^^^^^^^
+    13  <div v-text:aaa="foo" />
+    14  <div v-text.bbb="foo" />
+  
+  i v-text directives require a value containing the text content to render.
+  
+  i For example, use v-text="foo" to render the content of the foo variable.
+  
+
+```
+
+```
+invalid.vue:13:12 lint/nursery/useVueValidVText 
+
+  i The v-text directive does not accept an argument.
+  
+    11  <div v-text />
+    12  <div v-text="" />
+  > 13  <div v-text:aaa="foo" />
+                   ^^^^
+    14  <div v-text.bbb="foo" />
+    15  
+  
+  i v-text directives should be used without arguments, like v-text="content".
+  
+
+```
+
+```
+invalid.vue:14:12 lint/nursery/useVueValidVText 
+
+  i The v-text directive does not support modifiers.
+  
+    12  <div v-text="" />
+    13  <div v-text:aaa="foo" />
+  > 14  <div v-text.bbb="foo" />
+                   ^^^^
+    15  
+  
+  i v-text directives do not support any modifiers. Remove the modifier.
+  
+
+```
diff --git a/crates/biome_html_analyze/tests/specs/nursery/useVueValidVText/valid.vue b/crates/biome_html_analyze/tests/specs/nursery/useVueValidVText/valid.vue
new file mode 100644
index 0000000000..ebbc16ffd1
--- /dev/null
+++ b/crates/biome_html_analyze/tests/specs/nursery/useVueValidVText/valid.vue
@@ -0,0 +1,4 @@
+<!-- should not generate diagnostics -->
+
+<div v-text="foo"></div>
+<div v-text="foo" />
diff --git a/crates/biome_html_analyze/tests/specs/nursery/useVueValidVText/valid.vue.snap b/crates/biome_html_analyze/tests/specs/nursery/useVueValidVText/valid.vue.snap
new file mode 100644
index 0000000000..8fd3c8f593
--- /dev/null
+++ b/crates/biome_html_analyze/tests/specs/nursery/useVueValidVText/valid.vue.snap
@@ -0,0 +1,12 @@
+---
+source: crates/biome_html_analyze/tests/spec_tests.rs
+expression: valid.vue
+---
+# Input
+```html
+<!-- should not generate diagnostics -->
+
+<div v-text="foo"></div>
+<div v-text="foo" />
+
+```
diff --git a/crates/biome_js_analyze/src/lint/correctness/no_unused_imports.rs b/crates/biome_js_analyze/src/lint/correctness/no_unused_imports.rs
index e306782040..2c453a1a02 100644
--- a/crates/biome_js_analyze/src/lint/correctness/no_unused_imports.rs
+++ b/crates/biome_js_analyze/src/lint/correctness/no_unused_imports.rs
@@ -164,8 +164,9 @@ fn load_jsdoc_types_from_node(model: &mut JsDocTypeModel, node: &SyntaxNode<JsLa
     });
 }
 
-static JSDOC_INLINE_TAG_REGEX: LazyLock<Regex> =
-    LazyLock::new(|| Regex::new(r"\{@(link|see)\s*([^}| #\.]+)(?:[^}]+)?\}").unwrap());
+static JSDOC_INLINE_TAG_REGEX: LazyLock<Regex> = LazyLock::new(|| {
+    Regex::new(r"\{@(linkcode|linkplain|link|see)\s*([^}| #\.]+)(?:[^}]+)?\}").unwrap()
+});
 
 static JSDOC_TYPE_TAG_REGEX: LazyLock<Regex> =
     LazyLock::new(|| Regex::new(r"@(param|returns|type|typedef)\s*\{([^}]+)\}").unwrap());
diff --git a/crates/biome_js_analyze/src/lint/nursery/no_floating_promises.rs b/crates/biome_js_analyze/src/lint/nursery/no_floating_promises.rs
index 92565c9a6e..47762a04f5 100644
--- a/crates/biome_js_analyze/src/lint/nursery/no_floating_promises.rs
+++ b/crates/biome_js_analyze/src/lint/nursery/no_floating_promises.rs
@@ -292,10 +292,10 @@ impl Rule for NoFloatingPromises {
                     AnyJsExpression::JsAwaitExpression(make::js_await_expression(
                         make::token(JsSyntaxKind::AWAIT_KW)
                             .with_trailing_trivia([(TriviaPieceKind::Whitespace, " ")]),
-                        expression.clone().trim_leading_trivia()?,
+                        expression.clone().trim_comments_and_trivia()?,
                     ));
 
-                mutation.replace_node(expression, await_expression);
+                mutation.replace_node_transfer_trivia(expression, await_expression);
                 Some(JsRuleAction::new(
                     ctx.metadata().action_category(ctx.category(), ctx.group()),
                     ctx.metadata().applicability(),
diff --git a/crates/biome_js_analyze/src/lint/nursery/no_unnecessary_conditions.rs b/crates/biome_js_analyze/src/lint/nursery/no_unnecessary_conditions.rs
index f10287a65a..b4f3aefa4e 100644
--- a/crates/biome_js_analyze/src/lint/nursery/no_unnecessary_conditions.rs
+++ b/crates/biome_js_analyze/src/lint/nursery/no_unnecessary_conditions.rs
@@ -44,6 +44,22 @@ declare_lint_rule! {
     /// }
     /// ```
     ///
+    /// Contrary to the source rule, this rule doesn't trigger bindings that are assigned to multiple
+    /// values. In the following example, the variable `greeting` is assigned to multiple values; hence
+    /// it can't be inferred to a truthy or falsy value.
+    ///
+    /// ```ts
+    /// let greeting = false;
+    ///
+    /// function changeGreeting() {
+    ///     greeting = "Hello World!"
+    /// }
+    ///
+    /// if (greeting) {} // rule not triggered here
+    ///
+    /// ```
+    ///
+    ///
     /// ### Valid
     ///
     /// ```ts
@@ -71,7 +87,7 @@ declare_lint_rule! {
         version: "2.1.4",
         name: "noUnnecessaryConditions",
         language: "js",
-        sources: &[RuleSource::EslintTypeScript("no-unnecessary-condition").same()],
+        sources: &[RuleSource::EslintTypeScript("no-unnecessary-condition").inspired()],
         recommended: false,
         severity: Severity::Warning,
         domains: &[RuleDomain::Project],
diff --git a/crates/biome_js_analyze/tests/specs/correctness/noUnusedImports/issue_7876_tsdoc_linkcode.ts b/crates/biome_js_analyze/tests/specs/correctness/noUnusedImports/issue_7876_tsdoc_linkcode.ts
new file mode 100644
index 0000000000..7502da0fd5
--- /dev/null
+++ b/crates/biome_js_analyze/tests/specs/correctness/noUnusedImports/issue_7876_tsdoc_linkcode.ts
@@ -0,0 +1,111 @@
+// See https://github.com/biomejs/biome/issues/7876
+
+// some types for the different locations
+import type LinkOnFunction from "mod";
+
+import type LinkOnVariable from "mod";
+import type LinkOnClass from "mod";
+
+import type LinkOnClassField from "mod";
+import type LinkOnClassMethod from "mod";
+import type LinkOnClassConstructor from "mod";
+import type LinkOnClassAccessor from "mod";
+import type LinkOnClassIndexer from "mod";
+
+import type LinkOnInterface from "mod";
+import type LinkOnInterfaceField from "mod";
+import type LinkOnInterfaceMethod from "mod";
+import type LinkOnInterfaceIndexer from "mod";
+
+import type LinkOnEnum from "mod";
+import type LinkOnEnumMember from "mod";
+
+
+/**
+ * {@linkcode LinkOnFunction}
+ */
+function testLinkOnFunction() { }
+
+/**
+ * {@linkcode LinkOnVariable}
+ */
+const testLinkOnVariable = 3;
+
+/**
+ * {@linkcode LinkOnClass}
+ */
+class TestLinkOnClass { }
+
+class TestLinkOnClassField {
+    /**
+     * {@linkcode LinkOnClassField}
+     */
+    field: number;
+}
+
+class TestLinkOnClassMethod {
+    /**
+     * {@linkcode LinkOnClassMethod}
+     */
+    method(): void { }
+}
+
+class TestLinkOnClassConstructor {
+    /**
+     * {@linkcode LinkOnClassConstructor}
+     */
+    constructor() { }
+}
+
+class TestLinkOnClassAccessor {
+    /**
+     * {@linkcode LinkOnClassAccessor}
+     */
+    get accessor(): number { return 0 }
+}
+
+class TestLinkOnClassIndexer {
+    /**
+     * {@linkcode LinkOnClassIndexer}
+     */
+    [index: number]: string;
+}
+
+/**
+ * {@linkcode LinkOnInterface}
+ */
+interface TestLinkOnInterface { }
+
+interface TestLinkOnInterfaceField {
+    /**
+     * {@linkcode LinkOnInterfaceField}
+     */
+    field: string;
+}
+
+interface TestLinkOnInterfaceMethod {
+    /**
+     * {@linkcode LinkOnInterfaceMethod}
+     */
+    method(): string;
+}
+
+interface TestLinkOnInterfaceIndexer {
+    /**
+     * {@linkcode LinkOnInterfaceIndexer}
+     */
+    [index: number]: string;
+}
+
+/**
+ * {@linkcode LinkOnEnum}
+ */
+enum TestLinkOnEnum {
+}
+
+enum TestLinkOnEnumMember {
+    /**
+     * {@linkcode LinkOnEnumMember}
+     */
+    member
+}
\ No newline at end of file
diff --git a/crates/biome_js_analyze/tests/specs/correctness/noUnusedImports/issue_7876_tsdoc_linkcode.ts.snap b/crates/biome_js_analyze/tests/specs/correctness/noUnusedImports/issue_7876_tsdoc_linkcode.ts.snap
new file mode 100644
index 0000000000..5f644b1f45
--- /dev/null
+++ b/crates/biome_js_analyze/tests/specs/correctness/noUnusedImports/issue_7876_tsdoc_linkcode.ts.snap
@@ -0,0 +1,118 @@
+---
+source: crates/biome_js_analyze/tests/spec_tests.rs
+expression: issue_7876_tsdoc_linkcode.ts
+---
+# Input
+```ts
+// See https://github.com/biomejs/biome/issues/7876
+
+// some types for the different locations
+import type LinkOnFunction from "mod";
+
+import type LinkOnVariable from "mod";
+import type LinkOnClass from "mod";
+
+import type LinkOnClassField from "mod";
+import type LinkOnClassMethod from "mod";
+import type LinkOnClassConstructor from "mod";
+import type LinkOnClassAccessor from "mod";
+import type LinkOnClassIndexer from "mod";
+
+import type LinkOnInterface from "mod";
+import type LinkOnInterfaceField from "mod";
+import type LinkOnInterfaceMethod from "mod";
+import type LinkOnInterfaceIndexer from "mod";
+
+import type LinkOnEnum from "mod";
+import type LinkOnEnumMember from "mod";
+
+
+/**
+ * {@linkcode LinkOnFunction}
+ */
+function testLinkOnFunction() { }
+
+/**
+ * {@linkcode LinkOnVariable}
+ */
+const testLinkOnVariable = 3;
+
+/**
+ * {@linkcode LinkOnClass}
+ */
+class TestLinkOnClass { }
+
+class TestLinkOnClassField {
+    /**
+     * {@linkcode LinkOnClassField}
+     */
+    field: number;
+}
+
+class TestLinkOnClassMethod {
+    /**
+     * {@linkcode LinkOnClassMethod}
+     */
+    method(): void { }
+}
+
+class TestLinkOnClassConstructor {
+    /**
+     * {@linkcode LinkOnClassConstructor}
+     */
+    constructor() { }
+}
+
+class TestLinkOnClassAccessor {
+    /**
+     * {@linkcode LinkOnClassAccessor}
+     */
+    get accessor(): number { return 0 }
+}
+
+class TestLinkOnClassIndexer {
+    /**
+     * {@linkcode LinkOnClassIndexer}
+     */
+    [index: number]: string;
+}
+
+/**
+ * {@linkcode LinkOnInterface}
+ */
+interface TestLinkOnInterface { }
+
+interface TestLinkOnInterfaceField {
+    /**
+     * {@linkcode LinkOnInterfaceField}
+     */
+    field: string;
+}
+
+interface TestLinkOnInterfaceMethod {
+    /**
+     * {@linkcode LinkOnInterfaceMethod}
+     */
+    method(): string;
+}
+
+interface TestLinkOnInterfaceIndexer {
+    /**
+     * {@linkcode LinkOnInterfaceIndexer}
+     */
+    [index: number]: string;
+}
+
+/**
+ * {@linkcode LinkOnEnum}
+ */
+enum TestLinkOnEnum {
+}
+
+enum TestLinkOnEnumMember {
+    /**
+     * {@linkcode LinkOnEnumMember}
+     */
+    member
+}
+```
diff --git a/crates/biome_js_analyze/tests/specs/correctness/noUnusedImports/issue_7876_tsdoc_linkplain.ts b/crates/biome_js_analyze/tests/specs/correctness/noUnusedImports/issue_7876_tsdoc_linkplain.ts
new file mode 100644
index 0000000000..3550628905
--- /dev/null
+++ b/crates/biome_js_analyze/tests/specs/correctness/noUnusedImports/issue_7876_tsdoc_linkplain.ts
@@ -0,0 +1,111 @@
+// See https://github.com/biomejs/biome/issues/7876
+
+// some types for the different locations
+import type LinkOnFunction from "mod";
+
+import type LinkOnVariable from "mod";
+import type LinkOnClass from "mod";
+
+import type LinkOnClassField from "mod";
+import type LinkOnClassMethod from "mod";
+import type LinkOnClassConstructor from "mod";
+import type LinkOnClassAccessor from "mod";
+import type LinkOnClassIndexer from "mod";
+
+import type LinkOnInterface from "mod";
+import type LinkOnInterfaceField from "mod";
+import type LinkOnInterfaceMethod from "mod";
+import type LinkOnInterfaceIndexer from "mod";
+
+import type LinkOnEnum from "mod";
+import type LinkOnEnumMember from "mod";
+
+
+/**
+ * {@linkplain LinkOnFunction}
+ */
+function testLinkOnFunction() { }
+
+/**
+ * {@linkplain LinkOnVariable}
+ */
+const testLinkOnVariable = 3;
+
+/**
+ * {@linkplain LinkOnClass}
+ */
+class TestLinkOnClass { }
+
+class TestLinkOnClassField {
+    /**
+     * {@linkplain LinkOnClassField}
+     */
+    field: number;
+}
+
+class TestLinkOnClassMethod {
+    /**
+     * {@linkplain LinkOnClassMethod}
+     */
+    method(): void { }
+}
+
+class TestLinkOnClassConstructor {
+    /**
+     * {@linkplain LinkOnClassConstructor}
+     */
+    constructor() { }
+}
+
+class TestLinkOnClassAccessor {
+    /**
+     * {@linkplain LinkOnClassAccessor}
+     */
+    get accessor(): number { return 0 }
+}
+
+class TestLinkOnClassIndexer {
+    /**
+     * {@linkplain LinkOnClassIndexer}
+     */
+    [index: number]: string;
+}
+
+/**
+ * {@linkplain LinkOnInterface}
+ */
+interface TestLinkOnInterface { }
+
+interface TestLinkOnInterfaceField {
+    /**
+     * {@linkplain LinkOnInterfaceField}
+     */
+    field: string;
+}
+
+interface TestLinkOnInterfaceMethod {
+    /**
+     * {@linkplain LinkOnInterfaceMethod}
+     */
+    method(): string;
+}
+
+interface TestLinkOnInterfaceIndexer {
+    /**
+     * {@linkplain LinkOnInterfaceIndexer}
+     */
+    [index: number]: string;
+}
+
+/**
+ * {@linkplain LinkOnEnum}
+ */
+enum TestLinkOnEnum {
+}
+
+enum TestLinkOnEnumMember {
+    /**
+     * {@linkplain LinkOnEnumMember}
+     */
+    member
+}
\ No newline at end of file
diff --git a/crates/biome_js_analyze/tests/specs/correctness/noUnusedImports/issue_7876_tsdoc_linkplain.ts.snap b/crates/biome_js_analyze/tests/specs/correctness/noUnusedImports/issue_7876_tsdoc_linkplain.ts.snap
new file mode 100644
index 0000000000..70ee8081db
--- /dev/null
+++ b/crates/biome_js_analyze/tests/specs/correctness/noUnusedImports/issue_7876_tsdoc_linkplain.ts.snap
@@ -0,0 +1,118 @@
+---
+source: crates/biome_js_analyze/tests/spec_tests.rs
+expression: issue_7876_tsdoc_linkplain.ts
+---
+# Input
+```ts
+// See https://github.com/biomejs/biome/issues/7876
+
+// some types for the different locations
+import type LinkOnFunction from "mod";
+
+import type LinkOnVariable from "mod";
+import type LinkOnClass from "mod";
+
+import type LinkOnClassField from "mod";
+import type LinkOnClassMethod from "mod";
+import type LinkOnClassConstructor from "mod";
+import type LinkOnClassAccessor from "mod";
+import type LinkOnClassIndexer from "mod";
+
+import type LinkOnInterface from "mod";
+import type LinkOnInterfaceField from "mod";
+import type LinkOnInterfaceMethod from "mod";
+import type LinkOnInterfaceIndexer from "mod";
+
+import type LinkOnEnum from "mod";
+import type LinkOnEnumMember from "mod";
+
+
+/**
+ * {@linkplain LinkOnFunction}
+ */
+function testLinkOnFunction() { }
+
+/**
+ * {@linkplain LinkOnVariable}
+ */
+const testLinkOnVariable = 3;
+
+/**
+ * {@linkplain LinkOnClass}
+ */
+class TestLinkOnClass { }
+
+class TestLinkOnClassField {
+    /**
+     * {@linkplain LinkOnClassField}
+     */
+    field: number;
+}
+
+class TestLinkOnClassMethod {
+    /**
+     * {@linkplain LinkOnClassMethod}
+     */
+    method(): void { }
+}
+
+class TestLinkOnClassConstructor {
+    /**
+     * {@linkplain LinkOnClassConstructor}
+     */
+    constructor() { }
+}
+
+class TestLinkOnClassAccessor {
+    /**
+     * {@linkplain LinkOnClassAccessor}
+     */
+    get accessor(): number { return 0 }
+}
+
+class TestLinkOnClassIndexer {
+    /**
+     * {@linkplain LinkOnClassIndexer}
+     */
+    [index: number]: string;
+}
+
+/**
+ * {@linkplain LinkOnInterface}
+ */
+interface TestLinkOnInterface { }
+
+interface TestLinkOnInterfaceField {
+    /**
+     * {@linkplain LinkOnInterfaceField}
+     */
+    field: string;
+}
+
+interface TestLinkOnInterfaceMethod {
+    /**
+     * {@linkplain LinkOnInterfaceMethod}
+     */
+    method(): string;
+}
+
+interface TestLinkOnInterfaceIndexer {
+    /**
+     * {@linkplain LinkOnInterfaceIndexer}
+     */
+    [index: number]: string;
+}
+
+/**
+ * {@linkplain LinkOnEnum}
+ */
+enum TestLinkOnEnum {
+}
+
+enum TestLinkOnEnumMember {
+    /**
+     * {@linkplain LinkOnEnumMember}
+     */
+    member
+}
+```
diff --git a/crates/biome_js_analyze/tests/specs/nursery/noFloatingPromises/invalid.js b/crates/biome_js_analyze/tests/specs/nursery/noFloatingPromises/invalid.js
index 36812f53c7..4ffa6f7161 100644
--- a/crates/biome_js_analyze/tests/specs/nursery/noFloatingPromises/invalid.js
+++ b/crates/biome_js_analyze/tests/specs/nursery/noFloatingPromises/invalid.js
@@ -3,3 +3,8 @@ async function returnsPromise() {
 }
 returnsPromise();
 returnsPromise().then(() => { }).finally(() => { });
+
+async function issue7999() {
+  // 
+  returnsPromise();
+}
diff --git a/crates/biome_js_analyze/tests/specs/nursery/noFloatingPromises/invalid.js.snap b/crates/biome_js_analyze/tests/specs/nursery/noFloatingPromises/invalid.js.snap
index 891bf15660..ef69f8c47f 100644
--- a/crates/biome_js_analyze/tests/specs/nursery/noFloatingPromises/invalid.js.snap
+++ b/crates/biome_js_analyze/tests/specs/nursery/noFloatingPromises/invalid.js.snap
@@ -10,6 +10,11 @@ async function returnsPromise() {
 returnsPromise();
 returnsPromise().then(() => { }).finally(() => { });
 
+async function issue7999() {
+  // 
+  returnsPromise();
+}
+
 ```
 
 # Diagnostics
@@ -40,8 +45,30 @@ invalid.js:5:1 lint/nursery/noFloatingPromises 
   > 5  returnsPromise().then(() => { }).finally(() => { });
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     6  
+    7  async function issue7999() {
   
   i This happens when a Promise is not awaited, lacks a `.catch` or `.then` rejection handler, or is not explicitly ignored using the `void` operator.
   
 
 ```
+
+```
+invalid.js:9:3 lint/nursery/noFloatingPromises  FIXABLE  
+
+  i A "floating" Promise was found, meaning it is not properly handled and could lead to ignored errors or unexpected behavior.
+  
+     7  async function issue7999() {
+     8    // 
+   > 9    returnsPromise();
+          ^^^^^^^^^^^^^^^^^
+    10  }
+    11  
+  
+  i This happens when a Promise is not awaited, lacks a `.catch` or `.then` rejection handler, or is not explicitly ignored using the `void` operator.
+  
+  i Unsafe fix: Add await operator.
+  
+    9  awaitreturnsPromise();
+         ++++++                 
+
+```
diff --git a/crates/biome_js_analyze/tests/specs/nursery/noUnnecessaryConditions/validAssignment.ts b/crates/biome_js_analyze/tests/specs/nursery/noUnnecessaryConditions/validAssignment.ts
new file mode 100644
index 0000000000..b02bffe2b0
--- /dev/null
+++ b/crates/biome_js_analyze/tests/specs/nursery/noUnnecessaryConditions/validAssignment.ts
@@ -0,0 +1,9 @@
+// should not generate diagnostics
+
+let hey = false;
+
+function test() {
+	hey = "string"
+}
+
+if (hey) {}
diff --git a/crates/biome_js_analyze/tests/specs/nursery/noUnnecessaryConditions/validAssignment.ts.snap b/crates/biome_js_analyze/tests/specs/nursery/noUnnecessaryConditions/validAssignment.ts.snap
new file mode 100644
index 0000000000..2a48c704b3
--- /dev/null
+++ b/crates/biome_js_analyze/tests/specs/nursery/noUnnecessaryConditions/validAssignment.ts.snap
@@ -0,0 +1,17 @@
+---
+source: crates/biome_js_analyze/tests/spec_tests.rs
+expression: validAssignment.ts
+---
+# Input
+```ts
+// should not generate diagnostics
+
+let hey = false;
+
+function test() {
+	hey = "string"
+}
+
+if (hey) {}
+
+```
diff --git a/crates/biome_js_type_info/src/resolver.rs b/crates/biome_js_type_info/src/resolver.rs
index 0c39dcafd6..161bb9f29f 100644
--- a/crates/biome_js_type_info/src/resolver.rs
+++ b/crates/biome_js_type_info/src/resolver.rs
@@ -722,6 +722,14 @@ pub trait TypeResolver {
         ]))))))
     }
 
+    /// Register a new type that is a union between `current_type` and `ty`
+    fn union_with(&mut self, current_type: TypeReference, ty: TypeReference) -> TypeId {
+        self.register_type(Cow::Owned(TypeData::Union(Box::new(Union(Box::new([
+            current_type,
+            ty,
+        ]))))))
+    }
+
     // #endregion
 }
 
diff --git a/crates/biome_module_graph/src/js_module_info/collector.rs b/crates/biome_module_graph/src/js_module_info/collector.rs
index d4c2d627ee..d86fde17d8 100644
--- a/crates/biome_module_graph/src/js_module_info/collector.rs
+++ b/crates/biome_module_graph/src/js_module_info/collector.rs
@@ -3,9 +3,10 @@ use std::{borrow::Cow, collections::BTreeSet, sync::Arc};
 use biome_js_semantic::{SemanticEvent, SemanticEventExtractor};
 use biome_js_syntax::{
     AnyJsCombinedSpecifier, AnyJsDeclaration, AnyJsExportDefaultDeclaration, AnyJsExpression,
-    AnyJsImportClause, JsForVariableDeclaration, JsFormalParameter, JsIdentifierBinding,
-    JsRestParameter, JsSyntaxKind, JsSyntaxNode, JsSyntaxToken, JsVariableDeclaration,
-    TsIdentifierBinding, TsTypeParameter, TsTypeParameterName, inner_string_text,
+    AnyJsImportClause, JsAssignmentExpression, JsForVariableDeclaration, JsFormalParameter,
+    JsIdentifierBinding, JsRestParameter, JsSyntaxKind, JsSyntaxNode, JsSyntaxToken,
+    JsVariableDeclaration, TsIdentifierBinding, TsTypeParameter, TsTypeParameterName,
+    inner_string_text,
 };
 use biome_js_type_info::{
     BindingId, FunctionParameter, GLOBAL_RESOLVER, GLOBAL_UNKNOWN_ID, GenericTypeParameter,
@@ -573,34 +574,58 @@ impl JsModuleInfoCollector {
         for index in 0..self.bindings.len() {
             let binding = &self.bindings[index];
             if let Some(node) = self.binding_node_by_start.get(&binding.range.start()) {
-                let name = binding.name.clone();
                 let scope_id = scope_id_for_range(scope_by_range, binding.range);
-                let ty = self.infer_type(&node.clone(), &name, scope_id);
+                let ty = self.infer_type(&node.clone(), binding.clone(), scope_id);
                 self.bindings[index].ty = ty;
             }
         }
     }
 
+    fn has_writable_reference(&self, binding: &JsBindingData) -> bool {
+        binding
+            .references
+            .iter()
+            .any(|reference| reference.is_write())
+    }
+
+    fn get_writable_references(&self, binding: &JsBindingData) -> Vec<JsBindingReference> {
+        binding
+            .references
+            .iter()
+            .filter(|reference| reference.is_write())
+            .cloned()
+            .collect()
+    }
+
     fn infer_type(
         &mut self,
         node: &JsSyntaxNode,
-        binding_name: &Text,
+        binding: JsBindingData,
         scope_id: ScopeId,
     ) -> TypeReference {
+        let binding_name = &binding.name.clone();
         for ancestor in node.ancestors() {
             if let Some(decl) = AnyJsDeclaration::cast_ref(&ancestor) {
-                return if let Some(typed_bindings) = decl
+                let ty = if let Some(typed_bindings) = decl
                     .as_js_variable_declaration()
                     .and_then(|decl| self.variable_declarations.get(decl.syntax()))
                 {
-                    typed_bindings
+                    let ty = typed_bindings
                         .iter()
                         .find_map(|(name, ty)| (name == binding_name).then(|| ty.clone()))
-                        .unwrap_or_default()
+                        .unwrap_or_default();
+
+                    if self.has_writable_reference(&binding) {
+                        self.widen_binding_from_writable_references(scope_id, &binding, &ty)
+                    } else {
+                        ty
+                    }
                 } else {
                     let data = TypeData::from_any_js_declaration(self, scope_id, &decl);
                     self.reference_to_owned_data(data)
                 };
+
+                return ty;
             } else if let Some(declaration) = AnyJsExportDefaultDeclaration::cast_ref(&ancestor) {
                 let data =
                     TypeData::from_any_js_export_default_declaration(self, scope_id, &declaration);
@@ -640,6 +665,37 @@ impl JsModuleInfoCollector {
         TypeReference::unknown()
     }
 
+    /// Widen the type of binding from its writable references.
+    fn widen_binding_from_writable_references(
+        &mut self,
+        scope_id: ScopeId,
+        binding: &JsBindingData,
+        ty: &TypeReference,
+    ) -> TypeReference {
+        let references = self.get_writable_references(binding);
+        let mut ty = ty.clone();
+        for reference in references {
+            let Some(node) = self.binding_node_by_start.get(&reference.range_start) else {
+                continue;
+            };
+            for ancestor in node.ancestors().skip(1) {
+                if let Some(assignment) = JsAssignmentExpression::cast_ref(&ancestor)
+                    && let Ok(right) = assignment.right()
+                {
+                    let data = TypeData::from_any_js_expression(self, scope_id, &right);
+                    let assigned_type = self.reference_to_owned_data(data);
+                    ty = ResolvedTypeId::new(
+                        self.level(),
+                        self.union_with(ty.clone(), assigned_type),
+                    )
+                    .into();
+                }
+            }
+        }
+
+        ty
+    }
+
     /// After the first pass of the collector, import references have been
     /// resolved to an import binding. But we can't store the information of the
     /// import target inside the `ResolvedTypeId`, because it resides in the
diff --git a/crates/biome_module_graph/tests/snapshots/test_widening_via_assignment.snap b/crates/biome_module_graph/tests/snapshots/test_widening_via_assignment.snap
new file mode 100644
index 0000000000..7ed3b4a42d
--- /dev/null
+++ b/crates/biome_module_graph/tests/snapshots/test_widening_via_assignment.snap
@@ -0,0 +1,71 @@
+---
+source: crates/biome_module_graph/tests/snap/mod.rs
+expression: content
+---
+# `index.ts` (Not imported by resolver)
+
+## Source
+
+```ts
+let hey = false;
+function f() {
+	hey = true;
+}
+```
+
+## Module Info
+
+```
+Exports {
+  No exports
+}
+Imports {
+  No imports
+}
+```
+
+## Registered types
+
+```
+Module TypeId(0) => bool: false
+
+Module TypeId(1) => bool: true
+
+Module TypeId(2) => unknown
+
+Module TypeId(3) => Module(0) TypeId(0) | Module(0) TypeId(1)
+
+Module TypeId(4) => void
+
+Module TypeId(5) => sync Function "f" {
+  accepts: {
+    params: []
+    type_args: []
+  }
+  returns: Module(0) TypeId(4)
+}
+```
+
+# Module Resolver
+
+## Registered types
+
+```
+Full TypeId(0) => bool: false
+
+Full TypeId(1) => bool: true
+
+Full TypeId(2) => unknown
+
+Full TypeId(3) => Module(0) TypeId(0) | Module(0) TypeId(1)
+
+Full TypeId(4) => void
+
+Full TypeId(5) => sync Function "f" {
+  accepts: {
+    params: []
+    type_args: []
+  }
+  returns: Module(0) TypeId(4)
+}
+```
diff --git a/crates/biome_module_graph/tests/snapshots/test_widening_via_assignment_multiple_values.snap b/crates/biome_module_graph/tests/snapshots/test_widening_via_assignment_multiple_values.snap
new file mode 100644
index 0000000000..f08a8f1b7b
--- /dev/null
+++ b/crates/biome_module_graph/tests/snapshots/test_widening_via_assignment_multiple_values.snap
@@ -0,0 +1,98 @@
+---
+source: crates/biome_module_graph/tests/snap/mod.rs
+expression: content
+---
+# `index.ts` (Not imported by resolver)
+
+## Source
+
+```ts
+let hey = undefined;
+function f() {
+	hey = "some string";
+}
+function g() {
+	hey = 123;
+}
+```
+
+## Module Info
+
+```
+Exports {
+  No exports
+}
+Imports {
+  No imports
+}
+```
+
+## Registered types
+
+```
+Module TypeId(0) => undefined
+
+Module TypeId(1) => string: some string
+
+Module TypeId(2) => unknown
+
+Module TypeId(3) => number: 123
+
+Module TypeId(4) => Module(0) TypeId(0) | Module(0) TypeId(1)
+
+Module TypeId(5) => Module(0) TypeId(4) | Module(0) TypeId(3)
+
+Module TypeId(6) => void
+
+Module TypeId(7) => sync Function "f" {
+  accepts: {
+    params: []
+    type_args: []
+  }
+  returns: Module(0) TypeId(6)
+}
+
+Module TypeId(8) => sync Function "g" {
+  accepts: {
+    params: []
+    type_args: []
+  }
+  returns: Module(0) TypeId(6)
+}
+```
+
+# Module Resolver
+
+## Registered types
+
+```
+Full TypeId(0) => undefined
+
+Full TypeId(1) => string: some string
+
+Full TypeId(2) => unknown
+
+Full TypeId(3) => number: 123
+
+Full TypeId(4) => Module(0) TypeId(0) | Module(0) TypeId(1)
+
+Full TypeId(5) => Module(0) TypeId(4) | Module(0) TypeId(3)
+
+Full TypeId(6) => void
+
+Full TypeId(7) => sync Function "f" {
+  accepts: {
+    params: []
+    type_args: []
+  }
+  returns: Module(0) TypeId(6)
+}
+
+Full TypeId(8) => sync Function "g" {
+  accepts: {
+    params: []
+    type_args: []
+  }
+  returns: Module(0) TypeId(6)
+}
+```
diff --git a/crates/biome_module_graph/tests/spec_tests.rs b/crates/biome_module_graph/tests/spec_tests.rs
index 68002304a5..dd21d11ff1 100644
--- a/crates/biome_module_graph/tests/spec_tests.rs
+++ b/crates/biome_module_graph/tests/spec_tests.rs
@@ -2129,6 +2129,76 @@ fn test_resolve_swr_types() {
     assert!(mutate_result_ty.is_promise_instance());
 }
 
+#[test]
+fn test_widening_via_assignment() {
+    let fs = MemoryFileSystem::default();
+
+    fs.insert(
+        "index.ts".into(),
+        r#"
+let hey = false;
+function f() {
+    hey = true;
+}"#,
+    );
+
+    let added_paths = [BiomePath::new("index.ts")];
+    let added_paths = get_added_paths(&fs, &added_paths);
+
+    let module_graph = Arc::new(ModuleGraph::default());
+
+    module_graph.update_graph_for_js_paths(&fs, &ProjectLayout::default(), &added_paths, &[]);
+
+    let index_module = module_graph
+        .module_info_for_path(Utf8Path::new("index.ts"))
+        .expect("module must exist");
+    let resolver = Arc::new(ModuleResolver::for_module(
+        index_module,
+        module_graph.clone(),
+    ));
+
+    let snapshot = ModuleGraphSnapshot::new(&module_graph, &fs).with_resolver(resolver.as_ref());
+
+    snapshot.assert_snapshot("test_widening_via_assignment");
+}
+
+#[test]
+fn test_widening_via_assignment_multiple_values() {
+    let fs = MemoryFileSystem::default();
+
+    fs.insert(
+        "index.ts".into(),
+        r#"
+let hey = undefined;
+function f() {
+    hey = "some string";
+}
+function g() {
+    hey = 123;
+}
+"#,
+    );
+
+    let added_paths = [BiomePath::new("index.ts")];
+    let added_paths = get_added_paths(&fs, &added_paths);
+
+    let module_graph = Arc::new(ModuleGraph::default());
+
+    module_graph.update_graph_for_js_paths(&fs, &ProjectLayout::default(), &added_paths, &[]);
+
+    let index_module = module_graph
+        .module_info_for_path(Utf8Path::new("index.ts"))
+        .expect("module must exist");
+    let resolver = Arc::new(ModuleResolver::for_module(
+        index_module,
+        module_graph.clone(),
+    ));
+
+    let snapshot = ModuleGraphSnapshot::new(&module_graph, &fs).with_resolver(resolver.as_ref());
+
+    snapshot.assert_snapshot("test_widening_via_assignment_multiple_values");
+}
+
 fn find_files_recursively_in_directory(
     directory: &Utf8Path,
     predicate: impl Fn(&Utf8Path) -> bool,
diff --git a/crates/biome_rowan/src/ast/batch.rs b/crates/biome_rowan/src/ast/batch.rs
index fd28078701..d054da1ca3 100644
--- a/crates/biome_rowan/src/ast/batch.rs
+++ b/crates/biome_rowan/src/ast/batch.rs
@@ -221,6 +221,37 @@ where
         self.replace_element_discard_trivia(prev_token.into(), next_token.into())
     }
 
+    /// Push a change to replace the "prev_node" with "next_node".
+    ///
+    /// - leading trivia of `prev_node`
+    /// - leading trivia of `next_node`
+    /// - trailing trivia of `prev_node`
+    /// - trailing trivia of `next_node`
+    pub fn replace_node_transfer_trivia<T>(&mut self, prev_node: T, next_node: T) -> Option<()>
+    where
+        T: AstNode<Language = L>,
+    {
+        let prev_node = prev_node.into_syntax();
+        let next_node = next_node.into_syntax();
+
+        let leading_trivia = chain_trivia_pieces(
+            prev_node.first_token()?.leading_trivia().pieces(),
+            next_node.first_token()?.leading_trivia().pieces(),
+        );
+
+        let trailing_trivia = chain_trivia_pieces(
+            prev_node.last_token()?.trailing_trivia().pieces(),
+            next_node.last_token()?.trailing_trivia().pieces(),
+        );
+        let new_node = next_node
+            .with_leading_trivia_pieces(leading_trivia)?
+            .with_trailing_trivia_pieces(trailing_trivia)?;
+
+        self.replace_element_discard_trivia(prev_node.into(), new_node.into());
+
+        Some(())
+    }
+
     /// Push a change to replace the "prev_token" with "next_token".
     ///
     /// - leading trivia of `prev_token`
diff --git a/crates/biome_rowan/src/ast/mod.rs b/crates/biome_rowan/src/ast/mod.rs
index cedb0b95d1..6d223125c3 100644
--- a/crates/biome_rowan/src/ast/mod.rs
+++ b/crates/biome_rowan/src/ast/mod.rs
@@ -276,6 +276,15 @@ pub trait AstNode: Clone {
         Self::cast(self.into_syntax().append_trivia_pieces(trivia)?)
     }
 
+    /// Returns a new version of this node with *all* trivia stripped.
+    fn trim_comments_and_trivia(self) -> Option<Self> {
+        Self::cast(
+            self.into_syntax()
+                .with_leading_trivia_pieces([])?
+                .with_trailing_trivia_pieces([])?,
+        )
+    }
+
     /// Return a new version of this node without leading and trailing newlines and whitespaces.
     fn trim_trivia(self) -> Option<Self> {
         Self::cast(
diff --git a/crates/biome_rule_options/src/lib.rs b/crates/biome_rule_options/src/lib.rs
index 50e5653d09..b3a6f8f024 100644
--- a/crates/biome_rule_options/src/lib.rs
+++ b/crates/biome_rule_options/src/lib.rs
@@ -385,5 +385,6 @@ pub mod use_vue_valid_v_else_if;
 pub mod use_vue_valid_v_html;
 pub mod use_vue_valid_v_if;
 pub mod use_vue_valid_v_on;
+pub mod use_vue_valid_v_text;
 pub mod use_while;
 pub mod use_yield;
diff --git a/crates/biome_rule_options/src/use_vue_valid_v_text.rs b/crates/biome_rule_options/src/use_vue_valid_v_text.rs
new file mode 100644
index 0000000000..61180df996
--- /dev/null
+++ b/crates/biome_rule_options/src/use_vue_valid_v_text.rs
@@ -0,0 +1,6 @@
+use biome_deserialize_macros::{Deserializable, Merge};
+use serde::{Deserialize, Serialize};
+#[derive(Default, Clone, Debug, Deserialize, Deserializable, Merge, Eq, PartialEq, Serialize)]
+#[cfg_attr(feature = "schema", derive(schemars::JsonSchema))]
+#[serde(rename_all = "camelCase", deny_unknown_fields, default)]
+pub struct UseVueValidVTextOptions {}
diff --git a/justfile b/justfile
index 571460181d..246a0146b7 100644
--- a/justfile
+++ b/justfile
@@ -112,6 +112,11 @@ new-html-lintrule rulename:
   cargo run -p xtask_codegen -- new-lintrule --kind=html --category=lint --name={{rulename}}
   just gen-analyzer
 
+# Creates a new html lint rule with the given name, but targets vue. Name has to be camel case.
+new-html-vue-lintrule rulename:
+  cargo run -p xtask_codegen -- new-lintrule --kind=html-vue --category=lint --name={{rulename}}
+  just gen-analyzer
+
 # Promotes a rule from the nursery group to a new group
 move-rule rulename group:
   cargo run -p xtask_codegen -- move-rule --group={{group}} --name={{rulename}}
diff --git a/packages/@biomejs/backend-jsonrpc/src/workspace.ts b/packages/@biomejs/backend-jsonrpc/src/workspace.ts
index b20e6788de..7176d99415 100644
--- a/packages/@biomejs/backend-jsonrpc/src/workspace.ts
+++ b/packages/@biomejs/backend-jsonrpc/src/workspace.ts
@@ -2099,6 +2099,11 @@ See https://biomejs.dev/linter/rules/use-vue-valid-v-if
 See https://biomejs.dev/linter/rules/use-vue-valid-v-on 
 	 */
 	useVueValidVOn?: UseVueValidVOnConfiguration;
+	/**
+	* Enforce valid v-text Vue directives.
+See https://biomejs.dev/linter/rules/use-vue-valid-v-text 
+	 */
+	useVueValidVText?: UseVueValidVTextConfiguration;
 }
 /**
  * A list of rules that belong to this group
@@ -3667,6 +3672,9 @@ export type UseVueValidVIfConfiguration =
 export type UseVueValidVOnConfiguration =
 	| RulePlainConfiguration
 	| RuleWithUseVueValidVOnOptions;
+export type UseVueValidVTextConfiguration =
+	| RulePlainConfiguration
+	| RuleWithUseVueValidVTextOptions;
 export type NoAccumulatingSpreadConfiguration =
 	| RulePlainConfiguration
 	| RuleWithNoAccumulatingSpreadOptions;
@@ -5099,6 +5107,10 @@ export interface RuleWithUseVueValidVOnOptions {
 	level: RulePlainConfiguration;
 	options?: UseVueValidVOnOptions;
 }
+export interface RuleWithUseVueValidVTextOptions {
+	level: RulePlainConfiguration;
+	options?: UseVueValidVTextOptions;
+}
 export interface RuleWithNoAccumulatingSpreadOptions {
 	level: RulePlainConfiguration;
 	options?: NoAccumulatingSpreadOptions;
@@ -6338,6 +6350,7 @@ export interface UseVueValidVOnOptions {
 	 */
 	modifiers?: string[];
 }
+export type UseVueValidVTextOptions = {};
 export type NoAccumulatingSpreadOptions = {};
 export type NoAwaitInLoopsOptions = {};
 export type NoBarrelFileOptions = {};
@@ -7112,6 +7125,7 @@ export type Category =
 	| "lint/nursery/useVueValidVIf"
 	| "lint/nursery/useVueValidVModel"
 	| "lint/nursery/useVueValidVOn"
+	| "lint/nursery/useVueValidVText"
 	| "lint/performance/noAccumulatingSpread"
 	| "lint/performance/noAwaitInLoops"
 	| "lint/performance/noBarrelFile"
diff --git a/packages/@biomejs/biome/configuration_schema.json b/packages/@biomejs/biome/configuration_schema.json
index 316200db5d..4fa95b1b2a 100644
--- a/packages/@biomejs/biome/configuration_schema.json
+++ b/packages/@biomejs/biome/configuration_schema.json
@@ -5376,6 +5376,13 @@
 						{ "$ref": "#/$defs/UseVueValidVOnConfiguration" },
 						{ "type": "null" }
 					]
+				},
+				"useVueValidVText": {
+					"description": "Enforce valid v-text Vue directives.\nSee https://biomejs.dev/linter/rules/use-vue-valid-v-text",
+					"anyOf": [
+						{ "$ref": "#/$defs/UseVueValidVTextConfiguration" },
+						{ "type": "null" }
+					]
 				}
 			},
 			"additionalProperties": false
@@ -9477,6 +9484,15 @@
 			"additionalProperties": false,
 			"required": ["level"]
 		},
+		"RuleWithUseVueValidVTextOptions": {
+			"type": "object",
+			"properties": {
+				"level": { "$ref": "#/$defs/RulePlainConfiguration" },
+				"options": { "$ref": "#/$defs/UseVueValidVTextOptions" }
+			},
+			"additionalProperties": false,
+			"required": ["level"]
+		},
 		"RuleWithUseWhileOptions": {
 			"type": "object",
 			"properties": {
@@ -12502,6 +12518,16 @@
 			},
 			"additionalProperties": false
 		},
+		"UseVueValidVTextConfiguration": {
+			"oneOf": [
+				{ "$ref": "#/$defs/RulePlainConfiguration" },
+				{ "$ref": "#/$defs/RuleWithUseVueValidVTextOptions" }
+			]
+		},
+		"UseVueValidVTextOptions": {
+			"type": "object",
+			"additionalProperties": false
+		},
 		"UseWhileConfiguration": {
 			"oneOf": [
 				{ "$ref": "#/$defs/RulePlainConfiguration" },
diff --git a/xtask/codegen/src/generate_new_analyzer_rule.rs b/xtask/codegen/src/generate_new_analyzer_rule.rs
index 87508a5906..b385ecca5c 100644
--- a/xtask/codegen/src/generate_new_analyzer_rule.rs
+++ b/xtask/codegen/src/generate_new_analyzer_rule.rs
@@ -10,6 +10,7 @@ pub enum LanguageKind {
     Css,
     Graphql,
     Html,
+    HtmlVue,
 }
 
 impl LanguageKind {
@@ -20,6 +21,7 @@ impl LanguageKind {
             Self::Css => "css",
             Self::Graphql => "graphql",
             Self::Html => "html",
+            Self::HtmlVue => "html",
         }
     }
 }
@@ -33,6 +35,7 @@ impl FromStr for LanguageKind {
             "css" => Ok(Self::Css),
             "graphql" => Ok(Self::Graphql),
             "html" => Ok(Self::Html),
+            "html-vue" => Ok(Self::HtmlVue),
             _ => Err("Unsupported value"),
         }
     }
@@ -353,6 +356,81 @@ impl Rule for {rule_name_upper_camel} {{
     type Options = {rule_name_upper_camel}Options;
 
 
+    fn run(ctx: &RuleContext<Self>) -> Option<Self::State> {{
+        let _node = ctx.query();
+        None
+    }}
+
+    fn diagnostic(ctx: &RuleContext<Self>, _state: &Self::State) -> Option<RuleDiagnostic> {{
+        //
+        // Read our guidelines to write great diagnostics:
+        // https://docs.rs/biome_analyze/latest/biome_analyze/#what-a-rule-should-say-to-the-user
+        //
+        let span = ctx.query().range();
+        Some(
+            RuleDiagnostic::new(
+                rule_category!(),
+                span,
+                markup! {{
+                    "Unexpected empty block is not allowed"
+                }},
+            )
+            .note(markup! {{
+                    "This note will give you more information."
+            }}),
+        )
+    }}
+}}
+"#
+            )
+        }
+        LanguageKind::HtmlVue => {
+            format!(
+                r#"use biome_analyze::{{context::RuleContext, {macro_name}, Ast, Rule, RuleDiagnostic, RuleDomain, RuleSource}};
+use biome_console::markup;
+use biome_html_syntax::HtmlRoot;
+use biome_rowan::AstNode;
+use biome_rule_options::{rule_name_snake_case}::{rule_name_upper_camel}Options;
+
+{macro_name}! {{
+    /// Succinct description of the rule.
+    ///
+    /// Put context and details about the rule.
+    /// As a starting point, you can take the description of the corresponding _ESLint_ rule (if any).
+    ///
+    /// Try to stay consistent with the descriptions of implemented rules.
+    ///
+    /// ## Examples
+    ///
+    /// ### Invalid
+    ///
+    /// ```vue,expect_diagnostic
+    /// <div></div>
+    /// ```
+    ///
+    /// ### Valid
+    ///
+    /// ```vue
+    /// <div>foo</div>
+    /// ```
+    ///
+    pub {rule_name_upper_camel} {{
+        version: "next",
+        name: "{rule_name_lower_camel}",
+        language: "html",
+        recommended: false,
+        domains: &[RuleDomain::Vue],
+        sources: &[RuleSource::EslintVueJs("rule-name").same()],
+    }}
+}}
+
+impl Rule for {rule_name_upper_camel} {{
+    type Query = Ast<HtmlRoot>;
+    type State = ();
+    type Signals = Option<Self::State>;
+    type Options = {rule_name_upper_camel}Options;
+
+
     fn run(ctx: &RuleContext<Self>) -> Option<Self::State> {{
         let _node = ctx.query();
         None
@@ -460,6 +538,21 @@ impl Rule for {rule_name_upper_camel} {{
 pub fn generate_new_analyzer_rule(kind: LanguageKind, category: Category, rule_name: &str) {
     let rule_name_camel = Case::Camel.convert(rule_name);
     let rule_kind = kind.as_str();
+    let test_extension = if matches!(kind, LanguageKind::HtmlVue) {
+        "vue"
+    } else {
+        rule_kind
+    };
+    let valid_contents = if matches!(kind, LanguageKind::HtmlVue) {
+        "<!-- should not generate diagnostics -->\n<div>ok</div>"
+    } else {
+        "/* should not generate diagnostics */\n// var a = 1;"
+    };
+    let invalid_contents = if matches!(kind, LanguageKind::HtmlVue) {
+        "<!-- should generate diagnostics -->\n<div></div>"
+    } else {
+        "/* should generate diagnostics */\nvar a = 1;\na = 2;\na = 3;"
+    };
     let crate_folder = project_root().join(format!("crates/biome_{rule_kind}_analyze"));
     let test_folder = crate_folder.join("tests/specs/nursery");
     let rule_folder = match &category {
@@ -527,21 +620,18 @@ pub fn generate_new_analyzer_rule(kind: LanguageKind, category: Category, rule_n
     let _ = std::fs::create_dir_all(tests_path);
 
     let test_file = format!(
-        "{}/{rule_name_camel}/valid.{rule_kind}",
+        "{}/{rule_name_camel}/valid.{test_extension}",
         test_folder.display()
     );
     if std::fs::File::open(&test_file).is_err() {
-        let _ = std::fs::write(
-            test_file,
-            "/* should not generate diagnostics */\n// var a = 1;",
-        );
+        let _ = std::fs::write(test_file, valid_contents);
     }
 
     let test_file = format!(
-        "{}/{rule_name_camel}/invalid.{rule_kind}",
+        "{}/{rule_name_camel}/invalid.{test_extension}",
         test_folder.display()
     );
     if std::fs::File::open(&test_file).is_err() {
-        let _ = std::fs::write(test_file, "var a = 1;\na = 2;\na = 3;");
+        let _ = std::fs::write(test_file, invalid_contents);
     }
 }
